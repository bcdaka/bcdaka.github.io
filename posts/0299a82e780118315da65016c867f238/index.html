<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-C语言-排序（3） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0299a82e780118315da65016c867f238/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构-C语言-排序（3）">
  <meta property="og:description" content="代码位置：test-c-2024: 对C语言习题代码的练习 (gitee.com)
一、前言： 1.1-排序定义： 排序就是将一组杂乱无章的数据按照一定的规律（升序或降序）组织起来。(注：我们这里的排序采用的都为升序)
1.2-排序分类： 常见的排序算法： 插入排序
a. 直接插入排序
b. 希尔排序
选择排序
a. 选择排序
b. 堆排序交换排序
a. 冒泡排序
b. 快速排序归并排序
a. 归并排序非比较排序
a.计数排序
b.基数排序 1.3-算法比较： 1.4-目的： 今天，我们这里要实现的是快速排序。
1.5-快速排序定义： 通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。
二、快速排序-key的选择： 2.1-直接在left和right中选择： 这种选择方法具有局限性如果排序的序列已经为升序的情况下，根据快速排序的定义，我们可知，快速排序的话，会确定一个值的位置也就是key，这个值的作用就是把数据分割成独立的两部分，一部分是比他大，一部分是比他小，而如果是升序的情况下直接选择left，选出的left的值是最小的，也就是说右面的部分是N-1个数据，而如果是用递归的方式实现的快排，那么就需要递归N次，也就是建立N个栈才能实现最终排序的操作，如果数据量大就很有可能出现栈溢出的情况。
该情况下递归的图片如图所示：
2.2-随机选择key: 随机选择key，也就是说，在数组下标范围内，随机生成一个下标，采用这个下标位置的数据值作为key这样的情况下，我们就大大降低了选出的key是最小值的情况。能有效地减少栈溢出的情况。
2.3-三数取中： 三数取中就是在left 、midi（(right&#43;left)/2) 、right三个下标位置上的数据之间选择出这三个数据中的中间数。这样就避免了key为最小值的情况。
2.4-代码： void Swap(int* p, int* q)	//交换函数 { int tem = *p; *p = *q; *q = tem; } //直接选取法 int keyi = left; //随机选keyi int randi = left &#43; (rand() % (right - left)); Swap(&amp;a[randi], &amp;a[left]); int keyi = left; //三数取中 int midi = GetMidNumi(a, left, right); if (midi !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T17:11:24+08:00">
    <meta property="article:modified_time" content="2024-07-17T17:11:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-C语言-排序（3）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p></p> 
<p></p> 
<p>        代码位置：<a href="https://gitee.com/liu-wenfu-c/test-c-2024" rel="nofollow" title="test-c-2024: 对C语言习题代码的练习 (gitee.com)">test-c-2024: 对C语言习题代码的练习 (gitee.com)</a></p> 
<h2>一、前言：</h2> 
<h3>1.1-排序定义：</h3> 
<p>        排序就是将一组杂乱无章的数据按照一定的规律（升序或降序）组织起来。(注：我们这里的排序采用的都为升序)</p> 
<h3><a name="t2"></a>1.2-排序分类：</h3> 
<h6>常见的排序算法：</h6> 
<ul><li> <p><a href="https://blog.csdn.net/lyjwonderful/article/details/80489340" title="插入排序">插入排序</a><br> a. <a href="https://so.csdn.net/so/search?q=%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;spm=1001.2101.3001.7020" title="直接插入排序">直接插入排序</a><br> b. <a href="https://so.csdn.net/so/search?q=%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F&amp;spm=1001.2101.3001.7020" title="希尔排序">希尔排序</a></p> </li><li><a href="https://blog.csdn.net/lyjwonderful/article/details/80490433" title="选择排序">选择排序</a><br> a. 选择排序<br> b. 堆排序</li><li><a href="https://blog.csdn.net/lyjwonderful/article/details/80498398" title="交换排序">交换排序</a><br> a. 冒泡排序<br> b. 快速排序</li><li><a href="https://blog.csdn.net/lyjwonderful/article/details/80498663" title="归并排序">归并排序</a><br> a. 归并排序</li><li><a href="https://blog.csdn.net/lyjwonderful/article/details/80611347" title="非比较排序">非比较排序</a><br> a.计数排序<br> b.基数排序</li></ul> 
<h3>1.3-算法比较：</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ea/03/bPzvz8B5_o.jpg"></p> 
<p style="text-align:center;"></p> 
<h3>1.4-目的：</h3> 
<p>        今天，我们这里要实现的是<span style="color:#fe2c24;"><strong>快速排序</strong></span>。</p> 
<h3>1.5-快速排序定义：</h3> 
<p>        通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。</p> 
<h2>二、快速排序-key的选择：</h2> 
<h3>2.1-直接在left和right中选择：</h3> 
<p>        这种选择方法具有局限性如果排序的序列已经为升序的情况下，根据快速排序的定义，我们可知，快速排序的话，会确定一个值的位置也就是key，这个值的作用就是把数据分割成独立的两部分，一部分是比他大，一部分是比他小，而如果是升序的情况下直接选择left，选出的left的值是最小的，也就是说右面的部分是N-1个数据，而如果是用递归的方式实现的快排，那么就需要递归N次，也就是建立N个栈才能实现最终排序的操作，如果数据量大就很有可能出现栈溢出的情况。</p> 
<p>该情况下递归的图片如图所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/75/59/VW23Nx5A_o.png"></p> 
<h3>2.2-随机选择key:</h3> 
<p>        随机选择key，也就是说，在数组下标范围内，随机生成一个下标，采用这个下标位置的数据值作为key这样的情况下，我们就大大降低了选出的key是最小值的情况。能有效地减少栈溢出的情况。</p> 
<h3>2.3-三数取中：</h3> 
<p>        三数取中就是在left 、midi（(right+left)/2) 、right三个下标位置上的数据之间选择出这三个数据中的中间数。这样就避免了key为最小值的情况。</p> 
<h3>2.4-代码：</h3> 
<pre><code class="language-cpp">void Swap(int* p, int* q)				//交换函数
{
	int tem = *p;
	*p = *q;
	*q = tem;
}</code></pre> 
<pre><code class="language-cpp">//直接选取法
int keyi = left;

//随机选keyi
int randi = left + (rand() % (right - left));
Swap(&amp;a[randi], &amp;a[left]);
int keyi = left;

//三数取中
int midi = GetMidNumi(a, left, right);
if (midi != left)
	Swap(&amp;a[midi], &amp;a[left]);
int keyi = left;</code></pre> 
<pre><code class="language-cpp">int GetMidNumi(int* a, int left, int right)			//三数取中法
{
	int mid = (left + right) / 2;
	if (a[left] &gt; a[mid])
	{
		if (a[mid] &gt; a[right])
		{
			return mid;
		}
		if (a[left] &lt; a[right])
		{
			return left;
		}
		else
		{
			return right;
		}
	}
	if (a[left] &lt; a[mid])
	{
		if (a[left] &gt; a[right])
		{
			return left;
		}
		if (a[right] &gt; a[mid])
		{
			return mid;
		}
		else
		{
			return right;
		}
	}
}</code></pre> 
<h2>三、快速排序-Hoare：</h2> 
<h3>3.1-思路：</h3> 
<h4>Hoare快速排序的思路就是:</h4> 
<p>        如果key定义的是left，那么就首先从右边找小，找到以后再从左边出发找大，找完以后后将他们俩的数据调换，然后接着进行下一次先右后左找小再找大，直到left小于right为止。同理若定义key在right处那么就先左后右，处理方式与left类似。        </p> 
<p>        这样排完一趟后，我们能将大于key的数分布在右边，小于key的数分布在左边，最后，我们只需要按照这个思路递归下去，就实现快速排序啦。</p> 
<p>       <span style="color:#fe2c24;"> 注意:在递归时，如果出现left&gt;=right的情况下，我们就需要返回，否则就会死循环。</span></p> 
<h4>左边做key为什么相遇位置一定比key小？</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9d/42/KqnOWP6K_o.png"></p> 
<h3>3.2-过程图：</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/4d/hgIJRgb5_o.jpg"></p> 
<h3>3.3-代码：</h3> 
<pre><code class="language-cpp">//Hoare
void QuickSort1(int* a, int left,int right)			//快速排序---时间复杂度(O(N*logN))
{
	if (left &gt;= right)
		return;

	int begin = left;
	int end = right;
	//直接选取法
	//int keyi = left;

	//随机选keyi
	//int randi = left + (rand() % (right - left));
	//Swap(&amp;a[randi], &amp;a[left]);
	//int keyi = left;

	//三数取中
	int midi = GetMidNumi(a, left, right);
	if(midi!=left)
	Swap(&amp;a[midi], &amp;a[left]);
	int keyi = left;
	while (left &lt; right)
	{
		//右边找小
		while (left&lt;right&amp;&amp;a[right] &gt;=a[keyi])
		{
			--right;
		}
		//左边找大
		while (left&lt;right&amp;&amp;a[left] &lt;= a[keyi])
		{
			++left;
		}
		Swap(&amp;a[left], &amp;a[right]);
	}
	Swap(&amp;a[keyi], &amp;a[left]);
	keyi = left;
	//递归---小区间优化--小区间直接使用插入排序
	if (end - begin+1 &gt; 10)
	{
		QuickSort1(a, begin, keyi - 1);
		QuickSort1(a, keyi + 1, end);
	}
	else
	{
		InsertSort(a + begin, end - begin + 1);
	}
}</code></pre> 
<h2>四、快速排序-挖坑法：</h2> 
<h3>4.1-思路：</h3> 
<p>        快速排序，挖坑法的思路就是：</p> 
<p>        先将第一个数据存放在临时变量k中，形成一个坑位，然后再数组的右边出发，向左寻找小于key的数，然后将这个数填在以前的坑位上，然后在该处重新生成坑位，接着在从左边向右寻找，找大于ker的数，然后将这个数填在生成的坑位上，然后在该处重新生成坑位，就这样一直循环实现上述操作，直到left与right相遇为止，此时，该坑位就应该填key。。</p> 
<p>        这样排完一趟后，我们能将大于key的数分布在右边，小于key的数分布在左边，最后，我们只需要按照这个思路递归下去，就实现快速排序啦。</p> 
<p>       <span style="color:#fe2c24;"> 注意:在递归时，如果出现left&gt;=right的情况下，我们就需要返回，否则就会死循环。</span></p> 
<h3>4.2-过程图：</h3> 
<p>        <img alt="" height="818" src="https://images2.imgbox.com/5a/4c/sQeFLpMo_o.png" width="486"></p> 
<h3>4.3-代码：</h3> 
<pre><code class="language-cpp">//挖坑法
void QuickSort2(int* a, int left, int right)			//快速排序---时间复杂度(O(N*logN))
{
	if (left &gt;= right)
		return;

	int begin = left;
	int end = right;
	//直接选取法
	//int keyi = left;

	//随机选keyi
	//int randi = left + (rand() % (right - left));
	//Swap(&amp;a[randi], &amp;a[left]);
	//int keyi = left;

	//三数取中
	int midi = GetMidNumi(a, left, right);
	if(midi!=left)
	Swap(&amp;a[midi], &amp;a[left]);
	int key = a[left];
	int hole = left;
	while (left &lt; right)
	{
		while (left &lt; right &amp;&amp;a[right] &gt;= key)
		{
			--right;
		}
		a[hole] = a[right];
		hole = right;
		while (left &lt; right&amp;&amp;a[left] &lt;= key)
		{
			++left;
		}
		a[hole] = a[left];
		hole = left;
	}
	a[hole] = key;
	
	//递归---小区间优化--小区间直接使用插入排序
	if (end - begin + 1 &gt; 10)
	{
		QuickSort2(a, begin, hole - 1);
		QuickSort2(a, hole + 1, end);
	}
	else
	{
		InsertSort(a + begin, end - begin + 1);
	}
}</code></pre> 
<h2>五、快速排序-前后指针法：</h2> 
<h3>5.1-思路：</h3> 
<p>快速排序，前后指针法的思路就是:</p> 
<p>首先，定义一个prev=left ; cur=left+1。这里我们实现的操作：</p> 
<p>        1.cur找到比key小的值，++prove， cur和prev位置的数调换，然后++cur。</p> 
<p>        2.cur找到比key大的值，++cur。</p> 
<p>说明：</p> 
<p>        1.prev要么紧跟着cur（prev下一个位置就是cur）。</p> 
<p>        2.prev跟cur中间隔着一段比key大的值。</p> 
<p>         就这样，按上述思想进入循环知道，直到cur走到数组末端的下一个位置为止，接下来我们要实行的操作就是将keyi位置的值(key)与prev位置的值交换。这样排完一趟后，我们能将大于key的数分布在右边，小于key的数分布在左边，最后，我们只需要按照这个思路递归下去，就实现快速排序啦。</p> 
<p>       <span style="color:#fe2c24;"> 注意:在递归时，如果出现left&gt;=right的情况下，我们就需要返回，否则就会死循环。</span></p> 
<h3>5.2-过程图：</h3> 
<p><img alt="" height="841" src="https://images2.imgbox.com/05/a2/t8GgADLd_o.png" width="353"></p> 
<h3>5.3-代码：</h3> 
<pre><code class="language-cpp">//前后指针法
void QuickSort3(int* a, int left, int right)			//快速排序---时间复杂度(O(N*logN))
{
	if (left&gt;=right)
		return;

	int begin = left;
	int end = right;
	//直接选取法
	//int keyi = left;

	//随机选keyi
	//int randi = left + (rand() % (right - left));
	//Swap(&amp;a[randi], &amp;a[left]);
	//int keyi = left;

	//三数取中
	int midi = GetMidNumi(a, left, right);
	if (midi != left)
		Swap(&amp;a[midi], &amp;a[left]);
	int keyi = left;
	int prev= left;
	int cur = left + 1;
	while (cur&lt;=right)
	{
		if(a[cur]&lt;a[keyi]&amp;&amp;++prev!=cur)
		Swap(&amp;a[cur], &amp;a[prev]);

		cur++;
	}
	Swap(&amp;a[keyi], &amp;a[prev]);
	keyi = prev;
	//递归---小区间优化--小区间直接使用插入排序
	if (end - begin + 1 &gt; 10)
	{
		QuickSort3(a, begin, keyi - 1);
		QuickSort3(a, keyi + 1, end);
	}
	else
	{
		InsertSort(a + begin, end - begin + 1);
	}

}</code></pre> 
<h2>六、递归的问题与优化：</h2> 
<h3>6.1-递归的问题：</h3> 
<p>        1.效率问题（略有影响）。</p> 
<p>        <strong><span style="color:#fe2c24;">2.深度太深时会栈溢出。</span></strong></p> 
<p>递归过程图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/23/6e/TWxZjLLT_o.png"></p> 
<h3>6.2-小区间优化：</h3> 
<p>小区间优化的思想就是：</p> 
<p>        将递归的最后几层，也就是基本有序的小区间，采用直接插入排序的方法，不再采用递归的方式，这样能够减少递归时所开辟栈。</p> 
<p>        因为，递归栈的开辟相当于二叉树，而二叉树的最后一层相当于总数的一半，如果把最后一层省掉，也就是省去了递归所需开辟栈的大概50%的空间。</p> 
<p>        所以，我们可以通过小区间优化来减少栈的开辟，在不影响时间复杂度的情况下，也减小了深度太深时会栈溢出的问题。</p> 
<h3>6.3-小区间优化代码：</h3> 
<pre><code class="language-cpp">//递归---小区间优化--小区间直接使用插入排序
if (end - begin + 1 &gt; 10)
{
	QuickSort3(a, begin, keyi - 1);
	QuickSort3(a, keyi + 1, end);
}
else
{
	InsertSort(a + begin, end - begin + 1);
}</code></pre> 
<h2>七、递归改非递归：</h2> 
<p>        由上述可知，通过递归实现快排，具有一定的弊端，也就是栈溢出，所以这里我们可以采取将递归改成非递归的方式来实现快速排序</p> 
<h3>7.1-方式：</h3> 
<p>        1.直接改成循环。</p> 
<p>        2.使用栈辅助改成循环。</p> 
<p>        通过上述代码可观察发现，递归改非递归的第一种方式，我们是实现不了的，所以我们这里需要借助栈来辅助将递归改成循环。</p> 
<h3>7.2-思路：</h3> 
<p>        这里的思路就是将递归时的左右区间，存入栈中。然后在循环的过程中，我们只需将区间值出站即可。</p> 
<p>        <span style="color:#fe2c24;">注意：栈的原理是后进先出。</span></p> 
<h3>7.3-代码：</h3> 
<pre><code class="language-cpp">#include "Stack.h"
//递归改非递归
void QuickSortNonR(int* a, int left, int right)		//快速排序---时间复杂度(O(N*logN))
{
	ST ps;
	STInit(&amp;ps);
	STpush(&amp;ps, right);	//入栈
	STpush(&amp;ps, left);	//入栈
	
	while (!STEmpty(&amp;ps))
	{
		int begin= STTop(&amp;ps);		//取栈顶元素
		STPop(&amp;ps);		//出栈
		int end = STTop(&amp;ps);		//取栈顶元素
		STPop(&amp;ps);		//出栈

		int midi = GetMidNumi(a, begin, end);
		if (midi != begin)
			Swap(&amp;a[midi], &amp;a[begin]);
		int keyi = begin;
		int prev = begin;
		int cur = begin + 1;
		while (cur &lt;= end)
		{
			if (a[cur] &lt; a[keyi] &amp;&amp; ++prev != cur)
				Swap(&amp;a[cur], &amp;a[prev]);

			cur++;
		}
		Swap(&amp;a[keyi], &amp;a[prev]);
		keyi = prev;
		if (keyi + 1 &lt; end)
		{
			STpush(&amp;ps, end);	//入栈
			STpush(&amp;ps, keyi + 1);	//入栈
		}
		if (keyi - 1 &gt; begin)
		{
			STpush(&amp;ps, keyi - 1);	//入栈
			STpush(&amp;ps, begin);	//入栈
		}
	}
	for (int i = 0; i &lt;=right; i++)
	{
		printf("%d  ", a[i]);
	}
	printf("\n");
	STDestory(&amp;ps);
}
</code></pre> 
<h2>7.4-栈的代码：</h2> 
<pre><code class="language-cpp">#pragma once

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;


typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;

void STInit(ST* ps);		//初始化
void STDestory(ST* ps);	//释放销毁

void STpush(ST* ps, STDataType x);	//入栈
void STPop(ST* ps);		//出栈
int STSize(ST* ps);		//栈中元素个数
bool STEmpty(ST* ps);		//判断栈空
STDataType STTop(ST* ps);		//栈顶元素

</code></pre> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include "Stack.h"

void STInit(ST* ps)		//初始化
{
	assert(ps);

	ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);
	if (ps-&gt;a == NULL)
	{
		perror("malloc");
		return;
	}

	ps-&gt;capacity = 4;
	ps-&gt;top = 0;				//top是栈顶元素的下一个位置

	//ps-&gt;top=-1				//top是栈顶元素位置
}

void STDestory(ST* ps)		//释放销毁
{
	assert(ps);

	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
	free(ps-&gt;a);
	ps-&gt;a = NULL;
}


void STpush(ST* ps, STDataType x)		//入栈
{
	assert(ps);

	if (ps-&gt;top == ps-&gt;capacity)
	{
		STDataType* tem = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * ps-&gt;capacity * 2);
		if (tem == NULL)
		{
			perror("realloc");
			return;
		}

		ps-&gt;a = tem;
		ps-&gt;capacity *= 2;
	}

	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;
}

void STPop(ST* ps)		//出栈
{
	assert(ps);
	assert(!STEmpty(ps));

	ps-&gt;top--;
}

int STSize(ST* ps)			//栈中元素个数
{
	assert(ps);

	return ps-&gt;top;
}

bool STEmpty(ST* ps)		//判断栈空
{
	assert(ps);

	return ps-&gt;top == 0;
}

STDataType STTop(ST* ps)		//返回栈顶元素
{
	assert(ps);
	assert(!STEmpty(ps));

	return ps-&gt;a[ps-&gt;top - 1];
}
</code></pre> 
<h2>八、结语：</h2> 
<p>        上述内容，即是我个人对数据结构排序中<span style="color:#fe2c24;"><strong>快速排序</strong></span>的个人见解以及自我实现。若有大佬发现哪里有问题可以私信或评论指教一下我这个小萌新。非常感谢各位友友们的点赞，关注，收藏与支持，我会更加努力的学习编程语言，还望各位多多关照，让我们一起进步吧！</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c0/c1/GLsO8q9D_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d32e8367ee51a2206465a765d6f7da9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kafka-client如何打印连接日志</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cac1b5455dc9f6e4b58e3c785651ee40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【LeetCode:试题 16.06. 最小差 &#43; 双指针 &#43; 防止整型溢出】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>