<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——二叉树之c语言实现堆与堆排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ef37a1f478e7d5aa9758614e4c7b11a2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——二叉树之c语言实现堆与堆排序">
  <meta property="og:description" content="目录
前言：
1.二叉树的概念及结构
1.1 特殊的二叉树 1.2 二叉树的存储结构
1.顺序存储
2.链式存储 2. 二叉树的顺序结构及实现 2.1 堆的概念 ​编辑
2.2 堆的创建
3.堆的实现
3.1 堆的初始化和销毁 初始化：
销毁： 插入：
向上调整：
删除： 向下调整： 堆顶元素： 判空： 4.堆排序
4.1排序实现
前言： 在上一期我们介绍了有关于树的基础概念，了解了关于树的各名称的含义，然而在现实中树被用得最多的场景还是在我们计算机中的资源管理器的文件存储结构中，在其他场景被使用的情况很少，所以我们这一期要介绍一种被广泛使用的树型结构——二叉树。
1.二叉树的概念及结构 顾名思义，二叉树是由一个根结点和两棵子树构成，二叉树的每个结点最多只有两个结点：
从上图可以看出：
1. 二叉树不存在度大于2的结点
2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 二叉树是由以下几种情况复合而成的：
现实中的二叉树：
1.1 特殊的二叉树 1. 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数K次方-1，则它就是满二叉树。
2. 完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。
1.2 二叉树的存储结构 二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。
1.顺序存储 顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。二叉树顺 序存储在物理上是一个数组，在逻辑上是一颗二叉树。 2.链式存储 二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。
2. 二叉树的顺序结构及实现 普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。
2.1 堆的概念 堆的性质：
1.堆中某个结点的值总是不大于或不小于其父结点的值。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T18:12:48+08:00">
    <meta property="article:modified_time" content="2024-07-08T18:12:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——二叉树之c语言实现堆与堆排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:200px;"></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.二叉树的概念及结构</a></p> 
<p id="1.1%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0-toc" style="margin-left:40px;"><a href="#1.1%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0" rel="nofollow">1.1 特殊的二叉树 </a></p> 
<p id="1.2%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.2%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">1.2 二叉树的存储结构</a></p> 
<p id="%C2%A0%20%C2%A01.%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A01.%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8" rel="nofollow">   1.顺序存储</a></p> 
<p id="2.%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%C2%A0-toc" style="margin-left:80px;"><a href="#2.%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%C2%A0" rel="nofollow">2.链式存储 </a></p> 
<p id="2.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#2.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2. 二叉树的顺序结构及实现 </a></p> 
<p id="2.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:40px;"><a href="#2.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow">2.1 堆的概念 </a></p> 
<p id="%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">  ​编辑</a></p> 
<p id="2.2%20%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2.2%20%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2.2 堆的创建</a></p> 
<p id="3.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.堆的实现</a></p> 
<p id="3.1%20%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%C2%A0-toc" style="margin-left:40px;"><a href="#3.1%20%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%C2%A0" rel="nofollow">3.1 堆的初始化和销毁 </a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A" rel="nofollow">初始化：</a></p> 
<p id="%E9%94%80%E6%AF%81%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E9%94%80%E6%AF%81%EF%BC%9A%C2%A0" rel="nofollow">销毁： </a></p> 
<p id="%E6%8F%92%E5%85%A5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%8F%92%E5%85%A5%EF%BC%9A" rel="nofollow">插入：</a></p> 
<p id="%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%EF%BC%9A" rel="nofollow">向上调整：</a></p> 
<p id="%E5%88%A0%E9%99%A4%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%88%A0%E9%99%A4%EF%BC%9A%C2%A0" rel="nofollow">删除： </a></p> 
<p id="%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%EF%BC%9A%C2%A0" rel="nofollow">向下调整： </a></p> 
<p id="%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A%C2%A0" rel="nofollow">堆顶元素： </a></p> 
<p id="%E5%88%A4%E7%A9%BA%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%88%A4%E7%A9%BA%EF%BC%9A%C2%A0" rel="nofollow">判空： </a></p> 
<p id="%C2%A04.%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%C2%A04.%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow"> 4.堆排序</a></p> 
<p id="4.1%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#4.1%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0" rel="nofollow">4.1排序实现</a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0" rel="nofollow"> </a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<hr id="hr-toc"> 
<p></p> 
<h6 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h6> 
<p>   在上一期我们介绍了有关于树的基础概念，了解了关于树的各名称的含义，然而在现实中树被用得最多的场景还是在我们计算机中的资源管理器的文件存储结构中，在其他场景被使用的情况很少，所以我们这一期要介绍一种被广泛使用的树型结构——二叉树。</p> 
<h2 id="1.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.二叉树的概念及结构</h2> 
<p>  顾名思义，二叉树是由一个根结点和两棵子树构成，二叉树的每个结点最多只有两个结点：</p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/cc/8b/zf96bIaw_o.png" width="914"></p> 
<p>从上图可以看出：</p> 
<p>1. 二叉树不存在度大于2的结点</p> 
<p>2. 二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树  </p> 
<p>二叉树是由以下几种情况复合而成的：</p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/9c/b6/aGysb51t_o.png" width="773"></p> 
<p> </p> 
<p>现实中的二叉树：<img alt="" height="709" src="https://images2.imgbox.com/73/88/3gSbCJAM_o.jpg" width="1052"></p> 
<h3 id="1.1%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%C2%A0">1.1 特殊的二叉树 </h3> 
<p> 1. 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数K次方-1，则它就是满二叉树。</p> 
<p>2. 完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/98/67/QdrdnWgP_o.png" width="714"></p> 
<h3 id="1.2%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">1.2 二叉树的存储结构</h3> 
<p>  二叉树一般可以使用两种结构存储，一种顺序结构，一种链式结构。</p> 
<h4 id="%C2%A0%20%C2%A01.%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">   1.顺序存储</h4> 
<p>  顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，关于堆我们后面的章节会专门讲解。二叉树顺 序存储在物理上是一个数组，在逻辑上是一颗二叉树。 </p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/dc/35/m2CNlln7_o.png" width="1076"></p> 
<h4 id="2.%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%C2%A0">2.链式存储 </h4> 
<p>    二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是 链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所 在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程 学到高阶数据结构如红黑树等会用到三叉链。</p> 
<p><img alt="" height="417" src="https://images2.imgbox.com/e7/77/yXvTl5lX_o.png" width="984"></p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/73/ce/fooh9tiG_o.png" width="1036"> </p> 
<h2 id="2.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%C2%A0" style="background-color:transparent;">2. 二叉树的顺序结构及实现 </h2> 
<p>  普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结 构存储。<strong>现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段</strong>。</p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/f6/a9/oeptzPGB_o.png" width="1083"></p> 
<h3 id="2.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%C2%A0">2.1 堆的概念 </h3> 
<h3 id="%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91">  <img alt="" height="128" src="https://images2.imgbox.com/16/eb/QFhwmWHo_o.png" width="1119"></h3> 
<p>堆的性质：</p> 
<p>1.堆中某个结点的值总是不大于或不小于其父结点的值。</p> 
<p>2.堆总是一棵完全二叉树。 </p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/f0/21/0jWFQybX_o.png" width="658"></p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/5a/46/uHh3xnjw_o.png" width="631"> </p> 
<h3 id="2.2%20%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" style="background-color:transparent;">2.2 堆的创建</h3> 
<p>  下面我们给出一个数组，这个数组逻辑上可以看做一颗完全二叉树，但是还不是一个堆，现在我们通过算 法，把它构建成一个堆。根结点左右子树不是堆，我们怎么调整呢？这里我们从倒数的第一个非叶子结点的子树开始调整，一直调整到根结点的树，就可以调整成堆。</p> 
<h2 id="3.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0">3.堆的实现</h2> 
<p> 介绍完堆的概念和性质之后，我们接下来就要来用代码实现堆及堆的各个方法。由于堆是顺序结构实现的，所以我们选择使用顺序表来实现它：</p> 
<pre><code class="hljs">typedef int HPDataType;
typedef struct Heap
{
	HPDataType* a;
	int size;
	int capacity;
}HP;</code></pre> 
<h3 id="3.1%20%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%C2%A0">3.1 堆的初始化和销毁 </h3> 
<p>  堆是用顺序表来实现的，而顺序表的空间都是我们手动在内存中的堆中开辟的，所以也需要手动释放，而在程序最初运行时我们也要对它进行初始化。</p> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A">初始化：</h4> 
<pre><code class="hljs">void HPInit(HP* php)
{
	assert(php);
	php-&gt;a = NULL;
	php-&gt;size = php-&gt;capacity = 0;
}//初始化</code></pre> 
<h4 id="%E9%94%80%E6%AF%81%EF%BC%9A%C2%A0">销毁： </h4> 
<pre><code class="hljs">void HPDestroy(HP* php)
{
	assert(php);
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;capacity = php-&gt;size = 0;
}//销毁</code></pre> 
<h4 id="%E6%8F%92%E5%85%A5%EF%BC%9A">插入：</h4> 
<p> 在插入数据之前，我们选确定空间够不够，如果city等于cpapcity，我们就判断空间满了，需要扩容，然后插入数据，而要实现建堆的话，我们还需要使用向上调整方法实现：</p> 
<pre><code class="hljs">void HPPush(HP* php, HPDataType x)
{
	assert(php);
	if (php-&gt;capacity == php-&gt;size)
	{
		int newcapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(php-&gt;a, sizeof(HPDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("realloc fail!");
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;

	}
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;

	AdjustUp(php-&gt;a, php-&gt;size-1);//向上调整
}//插入</code></pre> 
<h4 id="%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%EF%BC%9A">向上调整：</h4> 
<p>   向上调整是建堆的关键，在我们插入一个数据时，我们之前建的堆可能会遭到破坏，这时就需要重新调整建堆，我们插入操作是尾插，用堆来表示的话它就是在堆低，这时我们就要向上调整，如果我们建的是小堆，那么我们就要判断我们插入的结点与它的父结点的大小关系，如果它比它的父结点小的话。那么就要与它的父结点交换位置，走到下一轮，如果它还是小于自己的父节点，那么继续执行交换操作，直到数组变成一个小堆：</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/4e/ec/cfgYmDCc_o.png" width="1064"></p> 
<p>代码实现：</p> 
<pre><code class="hljs">void AdjustUp(HPDataType* a,  int child)
{
	int parent = (child - 1) / 2;
	while (child&gt;0)
	{
		if (a[child] &lt; a[parent])
		{
			swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;;
			
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<h4 id="%E5%88%A0%E9%99%A4%EF%BC%9A%C2%A0">删除： </h4> 
<p>  有插入操作就必然有删除操作，那么我们如何实现删除操作呢？如果我们直接进行头删，那么我们建的堆就会被破环，如果尾删的话，那么堆就没有意义了（后面详细解释），所以我们先让堆中第一个元素与最后一个元素交换，然后再让size减一，而这时我们建的堆被破环了，所以还需要使用向下调整方法来重新建堆，而向下建堆的算法也比较简单，先找出第一个结点更小的那个子结点，只要这个结点比它的父结点小就让它们交换位置，如此循环往复，直到走到堆尾：</p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/ee/40/khbK7mdn_o.png" width="963"></p> 
<p>删除代码实现：</p> 
<pre><code class="hljs">void HPPop(HP* php)
{
	assert(&amp;php);
	assert(php-&gt;size &gt; 0);
	swap(&amp;(php-&gt;a[0]), &amp;(php-&gt;a[php-&gt;size - 1]));
	php-&gt;size--;

	AdjustDown(php-&gt;a,php-&gt;size,0);//向下调整
}//删除</code></pre> 
<h4 id="%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%EF%BC%9A%C2%A0">向下调整： </h4> 
<pre><code class="hljs">void AdjustDown(HPDataType* a, int n, int parent)
{
	//假设更小的孩子是左孩子
	int child = parent * 2 + 1;
	while (child&lt;n)//child&gt;=n说明孩子已经不存在
	{
		if (child+1&lt;n&amp;&amp;a[child + 1] &lt; a[child])
		{
			child++;
		}
		if (a[child] &lt; a[parent])
		{
			swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
	
}//向下调整</code></pre> 
<h4 id="%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%EF%BC%9A%C2%A0">堆顶元素： </h4> 
<pre><code class="hljs">HPDataType HPTop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);
	return php-&gt;a[0];
}//堆顶元素</code></pre> 
<h4 id="%E5%88%A4%E7%A9%BA%EF%BC%9A%C2%A0">判空： </h4> 
<pre><code class="hljs">bool HPEmpty(HP* php)
{
	assert(php);
	return php-&gt;size = 0;
}//判空
</code></pre> 
<h2 id="%C2%A04.%E5%A0%86%E6%8E%92%E5%BA%8F"> 4.堆排序</h2> 
<p> 堆排序是一种速度很快的排序算法，冒泡排序的时间复杂度为O（N^2），而堆排序的时间复杂度仅为O（logN），学完堆，我们就可以来试着实现堆排序了。</p> 
<h3 id="4.1%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">4.1排序实现</h3> 
<p> 我们先创建一个无序数组：</p> 
<pre><code class="hljs">int a[] = { 8,6,5,3,9,0,7,1,4,2 };</code></pre> 
<p>现在这个数组不是堆，我们堆排序的第一步就是先建堆呢，可以使用向下调整吗，答案是不可以，只有下面的子树都是堆时才可以使用，而现在这棵树仅是一个无序数组，所以我们选择从后往前建堆，什么意思呢，我们可以把这组树看成一棵一棵树：</p> 
<p><img alt="" height="469" src="https://images2.imgbox.com/4c/aa/dbuXZ7dG_o.png" width="649"> </p> 
<p>我们发现，从9开始，往上每一个结点都有自己的子结点，这就意味着从就开始，每往前走一步就是一棵树，所以我们只要从9开始使用向下调整建堆，每往前走一步就可以实现一棵树的建堆，而走到8时，整棵树也就完成了建堆：</p> 
<pre><code class="hljs">int a[] = { 8,6,5,3,9,0,7,1,4,2 };
int len = sizeof(a) / sizeof(int);
for (int i = (len - 1 - 1) / 2; i &gt;= 0; i--)
{
	AdjustDown(a, len, i);
}//建堆</code></pre> 
<p>这个算法到底怎么样呢？我们运行一下程序看看：</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/92/f4/y36qTRJR_o.png" width="699"> </p> 
<p>我们将这些数字摆成一棵二叉树：</p> 
<p><img alt="" height="337" src="https://images2.imgbox.com/4f/bc/TLfMMi4U_o.png" width="439"> </p> 
<p>从上图可以看出，这组数字摆成一棵二叉树它就是一个标准的堆。 </p> 
<p>     成功建堆之后，我们就可以来使用堆来排序了，从上图可以看出，我们建的是小堆，如果我们要实现降序，可以使用小堆实现吗？答案是可以，而且经过实验，我们得出结论：<strong>升序：建大堆</strong> ，<strong>降序：建小堆</strong>，所以我们使用小堆来实现降序是没有问题的。如何实现呢，我们可以先创建一个变量end指向最后一个结点，然后让第一个结点和尾结点交换，因为第一个结点是整个堆最小的数，交换位置之后，最小的数就在最后一个结点了，我们让end向前走一步，然后使用向下调整让堆第二小的数字走到第一个结点，然后再和end指向的结点交换，循环往复之后最大的数就走到了第一个结点，而我们也完成了降序排序：</p> 
<pre><code class="hljs">while (end &gt; 0)
    {
        swap(&amp;a[0], &amp;a[end]);
        end--;
        AdjustDown(a, end, 0);
        
    }//调整</code></pre> 
<p>来看看结果：</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/ed/4c/C1Prn4Jt_o.png" width="741"> </p> 
<p> 下面是完整代码：</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
void swap(int* p1, int* p2)
{
	int tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}
void AdjustDown(int* a, int n, int parent)
{
	int child = parent * 2 + 1;

	while (child&lt;n)
	{
		if (child+1&lt;n&amp;&amp;a[child + 1] &lt; a[child])
		{
			child++;
		}

		if (a[child] &lt; a[parent])
		{
			swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;

		}
	}
}

void test()
{
	int a[] = { 8,6,5,3,9,0,7,1,4,2 };
	int len = sizeof(a) / sizeof(int);
	for (int i = (len - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDown(a, len, i);
	}//建堆

	

	int end = len - 1;

	while (end &gt; 0)
	{
		swap(&amp;a[0], &amp;a[end]);
		end--;
		AdjustDown(a, end, 0);
		
	}//调整
	
	for (int i = 0; i &lt; len; i++)
	{
		printf("%d ", a[i]);
	}
}
int main()
{
	test();
	return 0;
}</code></pre> 
<p>到这里我们的堆就结束了，我将代码放在下面，感兴趣的小伙伴可以试试哦。</p> 
<p>Heap.h :</p> 
<pre><code class="hljs">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int HPDataType;
typedef struct Heap
{
	HPDataType* a;
	int size;
	int capacity;
}HP;

void HPInit(HP* php);//初始化
void HPDestroy(HP* php);//销毁
void HPPush(HP* php, HPDataType x);//插入
void HPPop(HP* php);//删除
HPDataType HPTop(HP* php);//堆顶元素
void AdjustUp(HPDataType* a, int child);//向上调整
void AdjustDown(HPDataType* a, int n,int parent);//向下调整
bool HPEmpty(HP* php);//判空
</code></pre> 
<p>Heap.c :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"Heap.h"

void HPInit(HP* php)
{
	assert(php);
	php-&gt;a = NULL;
	php-&gt;size = php-&gt;capacity = 0;
}//初始化
void swap(HPDataType* p1, HPDataType* p2)
{
	HPDataType tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}//交换
void AdjustDown(HPDataType* a, int n, int parent)
{
	//假设更小的孩子是左孩子
	int child = parent * 2 + 1;
	while (child&lt;n)//child&gt;=n说明孩子已经不存在
	{
		if (child+1&lt;n&amp;&amp;a[child + 1] &lt; a[child])
		{
			child++;
		}
		if (a[child] &lt; a[parent])
		{
			swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
	
}//向下调整
void AdjustUp(HPDataType* a,  int child)
{
	int parent = (child - 1) / 2;
	while (child&gt;0)
	{
		if (a[child] &lt; a[parent])
		{
			swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;;
			
		}
		else
		{
			break;
		}
	}
}
//向上调整
void HPPush(HP* php, HPDataType x)
{
	assert(php);
	if (php-&gt;capacity == php-&gt;size)
	{
		int newcapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(php-&gt;a, sizeof(HPDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("realloc fail!");
		}
		php-&gt;a = tmp;
		php-&gt;capacity = newcapacity;

	}
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;

	AdjustUp(php-&gt;a, php-&gt;size-1);//向上调整
}//插入
void HPPop(HP* php)
{
	assert(&amp;php);
	assert(php-&gt;size &gt; 0);
	swap(&amp;(php-&gt;a[0]), &amp;(php-&gt;a[php-&gt;size - 1]));
	php-&gt;size--;

	AdjustDown(php-&gt;a,php-&gt;size,0);//向下调整
}//删除
HPDataType HPTop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);
	return php-&gt;a[0];
}//堆顶元素
bool HPEmpty(HP* php)
{
	assert(php);
	return php-&gt;size = 0;
}//判空

void HPDestroy(HP* php)
{
	assert(php);
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;capacity = php-&gt;size = 0;
}//销毁</code></pre> 
<p>test.c :</p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1
#include"Heap.h"
void test()
{
	int a[] = { 4,9,0,2,5,3,7,1,8,6 };
	HP hp;
	HPInit(&amp;hp);
	for (size_t i = 0; i &lt; sizeof(a) / sizeof(int); i++)
	{
		HPPush(&amp;hp, a[i]);
	}
	while (hp.size)
	{
		printf("%d ", hp.a[hp.size - 1]);
		hp.size--;
	}
	HPDestroy(&amp;hp);
}
void test02()
{
	int a[] = { 4,9,0,2,5,3,7,1,8,6 };
	HP hp;
	HPInit(&amp;hp);
	for (size_t i = 0; i &lt; sizeof(a) / sizeof(int); i++)
	{
		HPPush(&amp;hp, a[i]);
	}

	while (hp.size&gt;0)
	{
		int top = HPTop(&amp;hp);
		printf("%d ", top);
		HPPop(&amp;hp);
	}

	HPDestroy(&amp;hp);

}
void test03()
{
	int a[] = { 4,9,0,2,5,3,7,1,8,6 };

	size_t len = sizeof(a) / sizeof(int);
	for (int i = (len - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDown(a, len, i);
	}
	int end = len - 1;

	while (end&gt;0)
	{
		swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		end--;
	}

	for (int i = 0; i &lt; len; i++)
	{
		printf("%d ", a[i]);
	}
}
int main()
{
	//test02();
	test03();
	return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/adcca0b95f3a49d190aa26ea3669542d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Spring Boot】Spring AOP动态代理，以及静态代理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f553f3d6bbcb35e35e33d38987f7dff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Java】搜索引擎设计：信息搜索怎么避免大海捞针？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>