<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 集合框架：HashMap 的介绍、使用、原理与源码解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/55f5b86856d473fb895713586dee0915/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 集合框架：HashMap 的介绍、使用、原理与源码解析">
  <meta property="og:description" content="大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 020 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在 Java 编程中，集合框架提供了强大而灵活的数据存储和操作方式。作为 Java 集合框架中的重要一员，HashMap 是一种常用的键值对映射实现。它广泛应用于需要高效数据查找、插入和删除的场景中。理解 HashMap 的工作原理对于编写高效的 Java 程序至关重要。
HashMap 是一个基于哈希表的 Map 实现，它的设计目标是提供高效的键值对存储和操作。通过将键的哈希值映射到哈希表的索引位置，HashMap 能够以接近常数时间的复杂度完成 get 和 put 操作。然而，HashMap 的内部实现包含多个复杂的机制，如哈希函数、冲突解决、扩容策略等，这些都是确保其高效性能的关键因素。
本篇文章将深入探讨 HashMap 的各种方面，包括其基础介绍、常见用法、工作原理以及源码解析。我们将从 HashMap 的基本特性和构造函数入手，逐步揭示其内部数据结构和方法的实现细节。同时，我们也会分析其性能特点和可能的优化策略，以帮助读者更好地理解和使用 HashMap。
通过对 HashMap 的全面解读，希望读者能够深入掌握这一关键集合类的工作机制，从而在实际开发中做出更加合理的选择和优化。无论你是刚刚接触 Java 集合框架的新手，还是希望深入了解其实现细节的资深开发者，本篇文章都将为你提供有价值的参考和指导。
文章目录 @[toc]1、HashMap 概述2、HashMap 底层数据结构1.1、JAVA7 实现1.2、JAVA8 实现1.3、源码解读 3、HashMap 的扩容机制3.1、什么时候触发扩容？3.2、JDK7 中的扩容机制3.3、JDK8 的扩容机制3.4、JDK7 的元素迁移3.5、JDK8 的元素迁移3.6、源码解读3.6.1、`resize` 方法3.6.2、`transfer` 方法3.6.3、`indexFor` 方法3.6.4、`ensureCapacity` 方法3.6.5、`addEntry` 方法 4、HashMap 相关知识点4.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T18:18:57+08:00">
    <meta property="article:modified_time" content="2024-07-23T18:18:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 集合框架：HashMap 的介绍、使用、原理与源码解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 020 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。</p> 
 <p>–</p> 
 <p>在 Java 编程中，集合框架提供了强大而灵活的数据存储和操作方式。作为 Java 集合框架中的重要一员，<code>HashMap</code> 是一种常用的键值对映射实现。它广泛应用于需要高效数据查找、插入和删除的场景中。理解 <code>HashMap</code> 的工作原理对于编写高效的 Java 程序至关重要。</p> 
 <p><code>HashMap</code> 是一个基于哈希表的 <code>Map</code> 实现，它的设计目标是提供高效的键值对存储和操作。通过将键的哈希值映射到哈希表的索引位置，<code>HashMap</code> 能够以接近常数时间的复杂度完成 <code>get</code> 和 <code>put</code> 操作。然而，<code>HashMap</code> 的内部实现包含多个复杂的机制，如哈希函数、冲突解决、扩容策略等，这些都是确保其高效性能的关键因素。</p> 
 <p>本篇文章将深入探讨 <code>HashMap</code> 的各种方面，包括其基础介绍、常见用法、工作原理以及源码解析。我们将从 <code>HashMap</code> 的基本特性和构造函数入手，逐步揭示其内部数据结构和方法的实现细节。同时，我们也会分析其性能特点和可能的优化策略，以帮助读者更好地理解和使用 <code>HashMap</code>。</p> 
 <p>通过对 <code>HashMap</code> 的全面解读，希望读者能够深入掌握这一关键集合类的工作机制，从而在实际开发中做出更加合理的选择和优化。无论你是刚刚接触 Java 集合框架的新手，还是希望深入了解其实现细节的资深开发者，本篇文章都将为你提供有价值的参考和指导。</p> 
</blockquote> 
<hr> 
<h3><a id="toc_15"></a> 
 <div class="toc"> 
  <h3>文章目录</h3> 
  <ul><li><ul><li><a href="#toc_15" rel="nofollow">@[toc]</a></li><li><ul><li><a href="#1HashMap__18" rel="nofollow">1、HashMap 概述</a></li><li><a href="#2HashMap__26" rel="nofollow">2、HashMap 底层数据结构</a></li><li><ul><li><a href="#11JAVA7__37" rel="nofollow">1.1、JAVA7 实现</a></li><li><a href="#12JAVA8__51" rel="nofollow">1.2、JAVA8 实现</a></li><li><a href="#13_59" rel="nofollow">1.3、源码解读</a></li></ul> 
     </li><li><a href="#3HashMap__219" rel="nofollow">3、HashMap 的扩容机制</a></li><li><ul><li><a href="#31_227" rel="nofollow">3.1、什么时候触发扩容？</a></li><li><a href="#32JDK7__231" rel="nofollow">3.2、JDK7 中的扩容机制</a></li><li><a href="#33JDK8__240" rel="nofollow">3.3、JDK8 的扩容机制</a></li><li><a href="#34JDK7__255" rel="nofollow">3.4、JDK7 的元素迁移</a></li><li><a href="#35JDK8__265" rel="nofollow">3.5、JDK8 的元素迁移</a></li><li><a href="#36_282" rel="nofollow">3.6、源码解读</a></li><li><ul><li><a href="#361resize__288" rel="nofollow">3.6.1、`resize` 方法</a></li><li><a href="#362transfer__318" rel="nofollow">3.6.2、`transfer` 方法</a></li><li><a href="#363indexFor__352" rel="nofollow">3.6.3、`indexFor` 方法</a></li><li><a href="#364ensureCapacity__370" rel="nofollow">3.6.4、`ensureCapacity` 方法</a></li><li><a href="#365addEntry__391" rel="nofollow">3.6.5、`addEntry` 方法</a></li></ul> 
     </li></ul> 
     </li><li><a href="#4HashMap__417" rel="nofollow">4、HashMap 相关知识点</a></li><li><ul><li><a href="#41HashMap__419" rel="nofollow">4.1、HashMap 的线程不安全</a></li><li><a href="#42_LinkedHashMap_465" rel="nofollow">4.2、关于 LinkedHashMap</a></li><li><ul><li><a href="#421_473" rel="nofollow">4.2.1、基本特性</a></li><li><a href="#422_484" rel="nofollow">4.2.2、构造函数</a></li><li><a href="#423_514" rel="nofollow">4.2.3、主要特性和方法</a></li><li><a href="#424_HashMap__527" rel="nofollow">4.2.4、与 `HashMap` 的区别</a></li><li><a href="#425_535" rel="nofollow">4.2.5、示例代码</a></li></ul> 
     </li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </div></h3> 
<h4><a id="1HashMap__18"></a>1、HashMap 概述</h4> 
<p>HashMap 根据是一个键值对集合，采用 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap 最多只允许一条记录的键为 null。</p> 
<p>HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p> 
<hr> 
<h4><a id="2HashMap__26"></a>2、HashMap 底层数据结构</h4> 
<p>HashMap 的主体为数组，链表则是主要为了解决哈希冲突而存在的（"拉链法"解决冲突）。</p> 
<p>JDK1.8 之后 HashMap 的组成多了红黑树，在满足下面两个条件之后，会执行链表转红黑树操作，以此来加快搜索速度。</p> 
<ul><li>链表长度大于阈值（默认为 8）</li><li>HashMap 数组长度超过 64</li></ul> 
<p>我们用下面这张图来介绍 HashMap 的结构。</p> 
<h5><a id="11JAVA7__37"></a>1.1、JAVA7 实现</h5> 
<p><img src="https://images2.imgbox.com/41/4b/YuwTrGUX_o.png" alt="image-20240722145625946"></p> 
<p>JDK1.8 之前 HashMap 里面是一个数组，数组中每个元素是一个单向链表。</p> 
<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：<code>key</code>，<code>value</code>，<code>hash</code> 值和用于单向链表的 next</p> 
<ol><li> <p><code>capacity</code>：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p> </li><li> <p><code>loadFactor</code>：负载因子，默认为 0.75。</p> </li><li> <p><code>threshold</code>：扩容的阈值，等于 <code>capacity * loadFactor</code></p> </li></ol> 
<h5><a id="12JAVA8__51"></a>1.2、JAVA8 实现</h5> 
<p><img src="https://images2.imgbox.com/58/7d/pPKKB7Pb_o.png" alt="image-20240722145642520"></p> 
<p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p> 
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 <code>O(n)</code>。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 <code>O(logN)</code>。</p> 
<h5><a id="13_59"></a>1.3、源码解读</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span>

    <span class="token comment">/*
     * 实现说明。
     *
     * 这个 Map 通常作为一个桶化的哈希表，但当桶过大时，它们会被转换为 TreeNodes 桶，
     * 这些 TreeNodes 结构类似于 java.util.TreeMap 中的节点。大多数方法尝试使用普通桶，
     * 但在适用的情况下会转到 TreeNode 方法（通过检查 instanceof 一个节点）。树形桶
     * 可以像普通桶一样遍历和使用，但当过度拥挤时支持更快的查找。然而，由于在正常使用中
     * 大多数桶不会过度拥挤，因此检查树桶的存在可能会延迟。
     *
     * 树桶（即所有元素都是 TreeNodes 的桶）主要按 hashCode 排序，但在哈希码相同的情况下，
     * 如果两个元素的类 C 实现了 Comparable&lt;C&gt;，则使用它们的 compareTo 方法进行排序。
     * （我们通过反射谨慎地检查泛型类型以验证这一点 -- 参见方法 comparableClassFor）。树桶的复杂性
     * 在于提供了最坏情况下 O(log n) 的操作，当键的哈希码不同或可排序时，这一点尤其重要。这样，
     * 性能在哈希码返回值分布不均或许多键共享哈希码时优雅地退化，只要它们也是 Comparable 的。
     * （如果这两者都不适用，我们可能会浪费约两倍的时间和空间，但这通常由于糟糕的用户编程实践
     * 导致，这些实践已经很慢，因此这种影响不大。）
     *
     * 由于 TreeNodes 大约是普通节点的两倍大小，我们只有在桶中包含足够多的节点时才使用它们
     * （参见 TREEIFY_THRESHOLD）。当它们变得太小（由于删除或调整大小）时，它们会被转换回普通桶。
     * 在哈希码分布良好的使用中，树桶很少使用。理想情况下，在随机哈希码下，桶中节点的频率遵循
     * 泊松分布（http://en.wikipedia.org/wiki/Poisson_distribution），默认调整大小阈值为 0.75，
     * 平均值约为 0.5，虽然由于调整大小的粒度较大，具有较大的方差。忽略方差，列表大小为 k 的预期
     * 发生次数为 (exp(-0.5) * pow(0.5, k) / factorial(k))。前几个值为：
     *
     * 0:    0.60653066
     * 1:    0.30326533
     * 2:    0.07581633
     * 3:    0.01263606
     * 4:    0.00157952
     * 5:    0.00015795
     * 6:    0.00001316
     * 7:    0.00000094
     * 8:    0.00000006
     * more: 少于一千万分之一
     *
     * 树桶的根通常是其第一个节点。然而，有时（当前仅在 Iterator.remove 之后），根可能在其他地方，
     * 但可以通过父链接恢复（方法 TreeNode.root()）。
     *
     * 所有适用的内部方法都接受哈希码作为参数（通常从公共方法提供），以允许它们相互调用而不重新计算用户哈希码。
     * 大多数内部方法还接受一个“tab”参数，这通常是当前表，但在调整大小或转换时可能是新表或旧表。
     *
     * 当桶列表被树化、拆分或撤销树化时，我们保持它们在相对访问/遍历顺序（即字段 Node.next），
     * 以更好地保留局部性，并稍微简化拆分和遍历，这些操作会调用 iterator.remove。当使用比较器插入时，
     * 为了在重新平衡期间保持总排序（或尽可能接近所需的排序），我们比较类和 identityHashCodes 作为平局打破者。
     *
     * 普通与树形模式的使用和转换由于存在子类 LinkedHashMap 而变得复杂。请参见下文，为插入、删除和访问定义了
     * 钩子方法，以允许 LinkedHashMap 内部保持独立于这些机制。（这也要求某些工具方法传递一个 map 实例，
     * 可能会创建新节点。）
     *
     * 这种类似并发编程的 SSA 基于编码风格有助于避免在所有弯曲的指针操作中出现别名错误。
     */</span>

    <span class="token comment">/**
     * 默认初始容量 - 必须是 2 的幂。
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 即 16</span>

    <span class="token comment">/**
     * 最大容量，当构造函数的参数指定了更高的值时使用。
     * 必须是 2 的幂 &lt;= 1&lt;&lt;30。
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 当构造函数中未指定时使用的负载因子。
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 使用树而不是列表的桶计数阈值。桶中的节点数至少达到这个阈值时，会将桶转换为树。
     * 该值必须大于 2，且应至少为 8，以与树形移除时的回退假设匹配。
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 在调整大小操作期间，将（拆分的）桶撤销树化的桶计数阈值。应小于 TREEIFY_THRESHOLD，并且
     * 最多为 6，以与删除时的收缩检测匹配。
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 可以树化的最小表容量。（否则如果桶中节点过多，表将调整大小。）
     * 应至少是 TREEIFY_THRESHOLD 的 4 倍，以避免调整大小和树化阈值之间的冲突。
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 基本的哈希桶节点，用于大多数条目。（参见下文的 TreeNode 子类，以及 LinkedHashMap 的 Entry 子类。）
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>  <span class="token comment">// 哈希码</span>
        <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>     <span class="token comment">// 键</span>
        <span class="token class-name">V</span> value<span class="token punctuation">;</span>         <span class="token comment">// 值</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>  <span class="token comment">// 下一个节点</span>

        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 返回键</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 返回值</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 返回键值对的字符串表示</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回键值对的哈希码</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token comment">// 保存旧值</span>
            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>    <span class="token comment">// 设置新值</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>     <span class="token comment">// 返回旧值</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 返回是否相等</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>源码解读：</p> 
<ol><li><code>HashMap</code> 类概述： 
  <ul><li><code>HashMap</code> 是一个基于哈希表的 <code>Map</code> 实现。它允许使用键值对存储数据，键和值都可以是任意对象；</li><li>它实现了 <code>Map</code> 接口，允许通过键来存取值。它还实现了 <code>Cloneable</code> 和 <code>Serializable</code> 接口，支持克隆和序列化。</li></ul> </li><li>内部结构和工作原理： 
  <ul><li>桶化哈希表：<code>HashMap</code> 使用桶（数组）来存储键值对。每个桶中的节点链表用于处理哈希冲突；</li><li>树形桶：当一个桶中的节点数达到 <code>TREEIFY_THRESHOLD</code>（8），桶会被转化为树结构（<code>TreeNode</code>）。这样可以提供更快的查找速度；</li><li>转换条件：如果桶中的节点数下降到 <code>UNTREEIFY_THRESHOLD</code>（6），树形桶会被转换回普通桶。</li></ul> </li><li>关键常量： 
  <ul><li><code>DEFAULT_INITIAL_CAPACITY</code>：默认初始容量为 16；</li><li><code>MAXIMUM_CAPACITY</code>：最大容量为 <code>2302^{30}230</code>；</li><li><code>DEFAULT_LOAD_FACTOR</code>：默认负载因子为 <code>0.75f</code>，用于控制桶的扩容；</li><li><code>TREEIFY_THRESHOLD</code> 和 <code>UNTREEIFY_THRESHOLD</code>：控制桶是否转为树结构的阈值。</li></ul> </li><li><code>Node</code> 类： 
  <ul><li><code>Node</code> 类是 <code>HashMap</code> 中的基本节点类。每个节点包含键、值、哈希码和指向下一个节点的引用；</li><li><code>equals</code> 和 <code>hashCode</code> 方法用来比较节点和计算哈希码，确保 <code>HashMap</code> 的一致性和性能。</li></ul> </li></ol> 
<hr> 
<h4><a id="3HashMap__219"></a>3、HashMap 的扩容机制</h4> 
<p>为了方便说明，这里明确几个名词：</p> 
<ul><li><code>capacity</code> ：即容量，默认16。</li><li><code>loadFactor</code> ：加载因子，默认是0.75</li><li><code>threshold</code> ：阈值，阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容</li></ul> 
<h5><a id="31_227"></a>3.1、什么时候触发扩容？</h5> 
<p>一般情况下，当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍</p> 
<h5><a id="32JDK7__231"></a>3.2、JDK7 中的扩容机制</h5> 
<p>JDK7 的扩容机制相对简单，有以下特性：</p> 
<ul><li>空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是<strong>空数组</strong>。</li><li>有参构造函数：根据参数确定容量、负载因子、阈值等。</li><li>第一次 put 时会初始化数组，其容量变为不小于指定容量的2的幂数。然后根据负载因子确定阈值。</li><li>如果不是第一次扩容，则<code>新阈值 = 新容量 X 负载因子</code></li></ul> 
<h5><a id="33JDK8__240"></a>3.3、JDK8 的扩容机制</h5> 
<p>JDK8 的扩容做了许多调整。</p> 
<p><code>HashMap</code> 的容量变化通常存在以下几种情况：</p> 
<ol><li>空参数的构造函数：实例化的 <code>HashMap</code> 默认内部数组是 null，即没有实例化。第一次调用 <code>put</code> 方法时，则会开始第一次初始化扩容，长度为16。</li><li>有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的2的幂数，将这个数设置赋值给阈值（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 <code>阈值 = 容量 X 负载因子</code>（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！）</li><li>如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。<em>（容量和阈值都变为原来的2倍时，负载因子还是不变）</em></li></ol> 
<p>此外还有几个细节需要注意：</p> 
<ul><li>首次 <code>put</code> 时，先会触发扩容（算是初始化），然后存入数据，然后判断是否需要扩容；</li><li>不是首次 <code>put</code>，则不再初始化，直接存入数据，然后判断是否需要扩容；</li></ul> 
<h5><a id="34JDK7__255"></a>3.4、JDK7 的元素迁移</h5> 
<p>JDK 7中，<code>HashMap</code> 的内部数据保存的都是链表。因此逻辑相对简单：在准备好新的数组后，<code>map</code> 会遍历数组的每个“桶”，然后遍历桶中的每个 Entity，重新计算其 hash 值（也有可能不计算），找到新数组中的对应位置，以头插法插入新的链表。</p> 
<p>这里有几个注意点：</p> 
<ul><li>是否要重新计算hash值的条件这里不深入讨论，读者可自行查阅源码。</li><li>因为是头插法，因此新旧链表的元素位置会发生转置现象。</li><li>元素迁移的过程中在多线程情境下有可能会触发死循环（无限进行链表反转）。</li></ul> 
<h5><a id="35JDK8__265"></a>3.5、JDK8 的元素迁移</h5> 
<p>JDK8则因为巧妙的设计，性能有了大大的提升：由于数组的容量是以2的幂次方扩容的，那么一个Entity在扩容时，新的位置要么在原位置，要么在 原长度+原位置 的位置。原因如下图：</p> 
<p><img src="https://images2.imgbox.com/07/bd/gyTQtluI_o.png" alt="img"></p> 
<p>数组长度变为原来的2倍，表现在二进制上就是多了一个高位参与数组下标确定。此时，一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：最高位是0则坐标不变，最高位是1则坐标变为“10000+原坐标”，即“原长度+原坐标”。如下图：</p> 
<p><img src="https://images2.imgbox.com/03/4b/0Qq6m5kw_o.jpg" alt="img"></p> 
<p>因此，在扩容时，不需要重新计算元素的hash了，只需要判断最高位是1还是0就好了。</p> 
<p>JDK8 的 <code>HashMap</code> 还有以下细节：</p> 
<ul><li>JDK8在迁移元素时是正序的，不会出现链表转置的发生。</li><li>如果某个桶内的元素超过8个，则会将链表转化成红黑树，加快数据查询效率。</li></ul> 
<h5><a id="36_282"></a>3.6、源码解读</h5> 
<p>在 <code>HashMap</code> 的实现中，扩容机制是一个关键的部分，用于保持 <code>HashMap</code> 的性能，防止哈希表过载。扩容时，<code>HashMap</code> 会将当前表的容量翻倍，并重新计算每个节点的索引，将其重新放入新的表中。扩容是一个昂贵的操作，因此 <code>HashMap</code> 使用负载因子来控制扩容的频率，避免频繁的扩容操作。扩容操作通常在添加新元素时触发，当 <code>HashMap</code> 的大小超出预设的阈值时进行。</p> 
<p>这些方法和机制一起确保了 <code>HashMap</code> 在大数据量下的性能和效率。扩容机制主要涉及到以下几个方法和步骤：</p> 
<h6><a id="361resize__288"></a>3.6.1、<code>resize</code> 方法</h6> 
<p><code>resize</code> 方法是 <code>HashMap</code> 扩容的核心方法。当哈希表的负载因子超过设定阈值时，<code>HashMap</code> 会调用 <code>resize</code> 方法来扩容。扩容的过程包括以下几个步骤：</p> 
<pre><code>java
复制代码
void resize(int newCapacity) {
    Node&lt;K,V&gt;[] oldTable = table;
    int oldCapacity = oldTable.length;

    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }

    Node&lt;K,V&gt;[] newTable = (Node&lt;K,V&gt;[]) new Node[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int) (newCapacity * loadFactor);
}
</code></pre> 
<p>解释：</p> 
<ul><li><code>newCapacity</code>：新的容量，即扩容后的大小。</li><li><code>oldTable</code>：原始的哈希表。</li><li><code>newTable</code>：新的哈希表，大小为 <code>newCapacity</code>。</li><li><code>transfer</code> 方法：负责将原哈希表中的所有节点转移到新哈希表中。</li></ul> 
<h6><a id="362transfer__318"></a>3.6.2、<code>transfer</code> 方法</h6> 
<p><code>transfer</code> 方法负责将旧的哈希表中的节点移动到新的哈希表中，同时进行再哈希操作：</p> 
<pre><code>java
复制代码
void transfer(Node&lt;K,V&gt;[] newTable) {
    Node&lt;K,V&gt;[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j &lt; src.length; ++j) {
        Node&lt;K,V&gt; e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Node&lt;K,V&gt; next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
</code></pre> 
<p>解释：</p> 
<ul><li><code>src</code>：旧的哈希表。</li><li><code>newCapacity</code>：新哈希表的容量。</li><li><code>indexFor</code> 方法：计算节点在新哈希表中的索引。</li><li><code>e.next</code>：节点的下一个节点。</li><li><code>newTable[i]</code>：将节点添加到新哈希表中。</li></ul> 
<h6><a id="363indexFor__352"></a>3.6.3、<code>indexFor</code> 方法</h6> 
<p><code>indexFor</code> 方法用来计算给定哈希码的节点在新哈希表中的索引位置：</p> 
<pre><code>java
复制代码
static int indexFor(int hash, int length) {
    return hash &amp; (length - 1);
}
</code></pre> 
<p>解释：</p> 
<ul><li><code>hash</code>：节点的哈希码。</li><li><code>length</code>：哈希表的长度。</li><li><code>hash &amp; (length - 1)</code>：将哈希码与哈希表长度减一进行按位与运算，得到索引位置。</li></ul> 
<h6><a id="364ensureCapacity__370"></a>3.6.4、<code>ensureCapacity</code> 方法</h6> 
<p><code>ensureCapacity</code> 方法用于确保 <code>HashMap</code> 的容量足够，避免在添加新元素时触发不必要的扩容：</p> 
<pre><code>java
复制代码
public void ensureCapacity(int minCapacity) {
    int threshold = table.length * loadFactor;
    if (minCapacity &gt; threshold) {
        resize(table.length * 2);
    }
}
</code></pre> 
<p>解释：</p> 
<ul><li><code>minCapacity</code>：期望的最小容量。</li><li><code>threshold</code>：当前负载因子下的阈值。</li><li>如果 <code>minCapacity</code> 大于 <code>threshold</code>，则调用 <code>resize</code> 方法扩容。</li></ul> 
<h6><a id="365addEntry__391"></a>3.6.5、<code>addEntry</code> 方法</h6> 
<p><code>addEntry</code> 方法用于在 <code>HashMap</code> 中添加新节点。如果插入操作导致负载因子超过阈值，会触发扩容：</p> 
<pre><code>java
复制代码
void addEntry(int hash, K key, V value, int bucketIndex) {
    Node&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Node&lt;&gt;(hash, key, value, e);
    if (size++ &gt;= threshold) {
        resize(2 * table.length);
    }
}
</code></pre> 
<p>解释：</p> 
<ul><li><code>hash</code>：节点的哈希码。</li><li><code>key</code>：节点的键。</li><li><code>value</code>：节点的值。</li><li><code>bucketIndex</code>：节点在桶中的索引位置。</li><li>如果 <code>size</code>（当前节点数量）超过了 <code>threshold</code>，则调用 <code>resize</code> 方法扩容。</li></ul> 
<hr> 
<h4><a id="4HashMap__417"></a>4、HashMap 相关知识点</h4> 
<h5><a id="41HashMap__419"></a>4.1、HashMap 的线程不安全</h5> 
<p><code>HashMap</code> 在 Java 中是一个非常流行的集合类，用于存储键值对。然而，<code>HashMap</code> 是线程不安全的，这意味着在多线程环境中对同一个 <code>HashMap</code> 实例的并发操作可能会导致不一致的状态或数据损坏。下面是 <code>HashMap</code> 线程不安全的主要原因及其影响：</p> 
<p>线程不安全的原因：</p> 
<ol><li> <p>非同步操作：<code>HashMap</code> 的所有方法都是非同步的。这意味着如果多个线程同时对一个 <code>HashMap</code> 实例进行读写操作，可能会导致数据竞争和不一致的问题（在 Jdk1.8 中，在多线程环境下，会发生数据覆盖的情况）。</p> </li><li> <p>扩容过程中的竞态条件：当 <code>HashMap</code> 扩容时（即调整内部数组的大小），需要重新计算每个元素的位置并将它们移动到新的数组中。如果在扩容过程中另一个线程正在修改哈希表，可能会导致数据丢失、重复或丢失（在 Jdk1.7 中，在多线程环境下，扩容时会造成环形链或数据丢失。）。</p> </li><li> <p>链表操作：在 <code>HashMap</code> 中，哈希冲突通过链表解决。多个线程同时访问或修改同一个桶的链表可能会导致链表结构损坏。例如，一个线程可能在另一个线程遍历链表时修改链表，这会导致遍历过程中的异常或丢失数据。</p> </li></ol> 
<p>线程不安全的影响：</p> 
<ol><li> <p>数据不一致：并发写入操作可能会导致数据丢失或覆盖，导致 <code>HashMap</code> 中的数据不一致。例如，两个线程同时插入相同的键，可能会导致只保留一个值，而另一个值被丢弃。</p> </li><li> <p>性能问题：在多线程环境中，如果多个线程频繁对 <code>HashMap</code> 进行操作，可能会导致大量的锁竞争，影响程序性能。</p> </li><li> <p>无限循环或抛出异常：在扩容或操作链表时，多个线程并发操作可能导致链表结构混乱，甚至可能导致无限循环或抛出 <code>ConcurrentModificationException</code> 异常。Ps：关于死循环的问题，在 Java8 中个人认为是不存在了，在 Java8 之前的版本中之所以出现死循环是因为在resize的过程中对链表进行了倒序处理；在Java8中不再倒序处理，自然也不会出现死循环。</p> </li></ol> 
<p>线程安全的替代方案：</p> 
<p><code>HashMap</code> 在设计时并未考虑多线程的并发问题，因此在多线程环境中使用时需要特别小心。为了避免线程不安全的问题，可以使用 <code>ConcurrentHashMap</code> 或通过 <code>Collections.synchronizedMap</code> 方法来确保线程安全。了解 <code>HashMap</code> 的线程不安全特性以及合适的替代方案，可以帮助开发者在并发编程中选择正确的数据结构。</p> 
<p>为了在多线程环境中使用类似于 <code>HashMap</code> 的数据结构，Java 提供了几种线程安全的替代方案：</p> 
<ol><li> <p><code>ConcurrentHashMap</code>：<code>ConcurrentHashMap</code> 是 <code>java.util.concurrent</code> 包中的类，提供了线程安全的哈希表实现。它通过将数据分段并使用锁分段技术来实现并发操作的高效支持。</p> <pre><code class="prism language-java"><span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><code>Collections.synchronizedMap</code>：<code>Collections.synchronizedMap</code> 方法可以将任何 <code>Map</code> 包装成线程安全的 <code>Map</code>。这种包装会对所有的操作加锁，从而确保线程安全。</p> <pre><code class="prism language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> synchronizedMap <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><code>ReadWriteLock</code>：如果应用场景涉及到大量的读操作和少量的写操作，可以考虑使用 <code>ReadWriteLock</code>（如 <code>ReentrantReadWriteLock</code>），它允许多个线程同时读操作，但在写操作时进行排他锁定。</p> <pre><code class="prism language-java"><span class="token class-name">ReadWriteLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Lock</span> readLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Lock</span> writeLock <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ol> 
<h5><a id="42_LinkedHashMap_465"></a>4.2、关于 LinkedHashMap</h5> 
<p>在使用 HashMap 的时候，可能会遇到需要按照当时 put 的顺序来进行哈希表的遍历。但我们知道 HashMap 中不存在保存顺序的机制。</p> 
<p>LinkedHashMap 专为此特性而生。在 LinkedHashMap 中可以保持两种顺序，分别是插入顺序和访问顺序，这个是可以在 LinkedHashMap 的初始化方法中进行指定的。相对于访问顺序，按照插入顺序进行编排被使用到的场景更多一些，所以默认是按照插入顺序进行编排。</p> 
<p>LinkedHashMap 相对于 HashMap，增加了双链表的结果（即节点中增加了前后指针），其他处理逻辑与 HashMap 一致，同样也没有锁保护，多线程使用存在风险。</p> 
<h6><a id="421_473"></a>4.2.1、基本特性</h6> 
<p>继承与实现：</p> 
<ul><li>继承自 <code>HashMap</code>：<code>LinkedHashMap</code> 继承了 <code>HashMap</code> 的所有功能，包括哈希表的存储和操作。</li><li>实现 <code>Map</code> 接口：<code>LinkedHashMap</code> 实现了 <code>Map</code> 接口，因此可以用作常规的键值对映射。</li></ul> 
<p>链表结构：</p> 
<ul><li><code>LinkedHashMap</code> 使用双向链表维护元素的插入顺序或访问顺序。这意味着可以在迭代时按照插入顺序或访问顺序遍历元素。</li></ul> 
<h6><a id="422_484"></a>4.2.2、构造函数</h6> 
<p><code>LinkedHashMap</code> 提供了几种构造函数：</p> 
<p>默认构造函数：</p> 
<pre><code class="prism language-java"><span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>指定初始容量：</p> 
<pre><code class="prism language-java"><span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>指定初始容量和负载因子：</p> 
<pre><code class="prism language-java"><span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>指定初始容量、负载因子和顺序类型：</p> 
<pre><code class="prism language-java"><span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><code>accessOrder</code> 为 <code>true</code> 时，表示按照访问顺序排列元素（最近访问的元素会移动到链表的末尾），为 <code>false</code> 时，按照插入顺序排列元素。</li></ul> 
<h6><a id="423_514"></a>4.2.3、主要特性和方法</h6> 
<p>插入顺序：如果构造时 <code>accessOrder</code> 为 <code>false</code>（默认值），<code>LinkedHashMap</code> 维护元素的插入顺序。即迭代时元素的顺序与插入顺序一致。</p> 
<p>访问顺序：如果构造时 <code>accessOrder</code> 为 <code>true</code>，<code>LinkedHashMap</code> 维护元素的访问顺序。即每次访问元素（通过 <code>get</code> 方法）时，该元素会被移动到链表的末尾，确保迭代顺序是最近访问顺序。</p> 
<p><code>LinkedHashMap</code> 特有方法：</p> 
<ul><li><code>boolean containsValue(Object value)</code>：检查 <code>LinkedHashMap</code> 是否包含指定的值。</li><li><code>V get(Object key)</code>：获取指定键的值，并根据 <code>accessOrder</code> 参数更新访问顺序。</li><li><code>void put(K key, V value)</code>：插入一个新的键值对或更新现有的键值对。</li><li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>：返回一个包含 <code>LinkedHashMap</code> 中所有键值对的 <code>Set</code> 视图。</li></ul> 
<h6><a id="424_HashMap__527"></a>4.2.4、与 <code>HashMap</code> 的区别</h6> 
<p>顺序维护：<code>HashMap</code> 不保证元素的顺序，而 <code>LinkedHashMap</code> 保证插入顺序或访问顺序。</p> 
<p>性能：<code>LinkedHashMap</code> 的性能通常稍微低于 <code>HashMap</code>，因为它需要维护额外的链表结构。然而，<code>LinkedHashMap</code> 提供了对元素顺序的控制，这是 <code>HashMap</code> 所不具备的。</p> 
<p>用途：<code>LinkedHashMap</code> 适用于需要保持元素顺序的情况，例如实现缓存机制时，需要按照访问顺序维护元素。</p> 
<h6><a id="425_535"></a>4.2.5、示例代码</h6> 
<p>以下是使用 <code>LinkedHashMap</code> 的示例：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedHashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMapExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 按照插入顺序</span>
        <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"One"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Two"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Three"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 按照访问顺序</span>
        <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> accessOrderMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        accessOrderMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"One"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        accessOrderMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Two"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        accessOrderMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Three"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 访问元素，更新访问顺序</span>
        accessOrderMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Insertion order:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\nAccess order:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> accessOrderMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出：</p> 
<pre><code>Insertion order:
One: 1
Two: 2
Three: 3

Access order:
One: 1
Three: 3
Two: 2
</code></pre> 
<p>总的来说，<code>LinkedHashMap</code> 是 <code>HashMap</code> 的一个扩展，增加了对元素顺序的维护。它适用于需要保持插入顺序或访问顺序的场景。虽然性能略低于 <code>HashMap</code>，但其顺序保证是其独特的优势。如果你的应用场景需要按顺序遍历 <code>Map</code>，<code>LinkedHashMap</code> 是一个合适的选择。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5716970ed92892c8933c63c9ecd46390/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决kkfileview 使用https预览问题记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f72e28063c30c7468fb6af4653f4f9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tomcat</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>