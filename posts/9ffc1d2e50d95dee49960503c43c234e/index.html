<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>字符串函数（2）＜C语言＞ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9ffc1d2e50d95dee49960503c43c234e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="字符串函数（2）＜C语言＞">
  <meta property="og:description" content="前言 快一周没更博客了，最近有点忙，今天闲下来了，还是不行，继续干，书接上回继续介绍字符串函数：strncpy()、strncat()、strcmp()、strtok()使用、strstr()使用以及模拟实现、strerror()使用。
strncpy()、strncat()、strncmp() 这几个函数看着很眼熟，用法确实和前文的函数类似，不同的是多出了一个n，也有一些不同。
strncpy() 函数参数及其返回类型:
char* strncpy(char* destination , const char* source , size_t num); //返回值是目的字符串的起始地址 作用：
从源字符串中拷贝num个字符串到目的字符串中。
注意点：
①如果num大于源字符长度，在拷贝完源字符串后，在目标字符串中追加\0，直到num个。
②如果num小于源字符长度，在拷贝完指定字符串后，不会在目标字符串中追加\0。
使用举例：
strncat() 函数参数及其返回类型:
char* strncat(char* destination , const char* source , size_t num); //返回值是目的字符串的起始地址 作用：
从源字符串中追加前num个字符串到目的字符串中，再追加个\0。
注意点：
①如果num大于源字符长度，只会将源字符串中到\0的字符串追加到目的字符串末尾。
②相较于strcat()函数，strncat()可实现自追加（先用strlen()函数求出字符串长度，再追加），原因也很简单，strncat()每次追加完毕会自动追加一个\0。
使用举例：
strncmp() 函数参数及其返回类型:
int strncat(const char* str1, const char* str2 , size_t num); //返回值是大于：大于0的数、等于：0、小于：小于0的数 作用：
比较str1与str2前num个字符
注意点：无
使用举例：
strtok()使用 函数参数及其返回类型:
char* strtok(char* str, const char* sep ); //返回值是指向找到以sep中的字符分隔的字符串的首地址，如果没找到返回NULL 作用：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T15:17:07+08:00">
    <meta property="article:modified_time" content="2024-05-27T15:17:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">字符串函数（2）＜C语言＞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言</h4> 
<p>        快一周没更博客了，最近有点忙，今天闲下来了，还是不行，继续干，书接上回继续介绍字符串函数：strncpy()、strncat()、strcmp()、strtok()使用、strstr()使用以及模拟实现、strerror()使用。</p> 
<hr> 
<h4>strncpy()、strncat()、strncmp()</h4> 
<p>        这几个函数看着很眼熟，用法确实和前文的函数类似，不同的是多出了一个n，也有一些不同。</p> 
<h5>strncpy()</h5> 
<p>        <strong>函数参数及其返回类型:</strong></p> 
<pre><code class="language-cpp">char* strncpy(char* destination , const char* source , size_t num);
//返回值是目的字符串的起始地址</code></pre> 
<p><strong>作用：</strong></p> 
<p>从源字符串中拷贝num个字符串到目的字符串中。</p> 
<p><strong>注意点：</strong></p> 
<p>①如果num大于源字符长度，在拷贝完源字符串后，在目标字符串中追加<strong>\0</strong>，直到num个。</p> 
<p>②如果num小于源字符长度，在拷贝完指定字符串后，不会在目标字符串中追加<strong>\0</strong>。</p> 
<p><strong>使用举例：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/e5/32/9gjrq06t_o.png"></strong></p> 
<p></p> 
<h5> strncat()</h5> 
<p>        <strong>函数参数及其返回类型:</strong></p> 
<pre><code class="language-cpp">char* strncat(char* destination , const char* source , size_t num);
//返回值是目的字符串的起始地址</code></pre> 
<p><strong>作用：</strong></p> 
<p>从源字符串中追加前num个字符串到目的字符串中，再追加个<strong>\0。</strong></p> 
<p><strong>注意点：</strong></p> 
<p>①如果num大于源字符长度，只会将源字符串中到<strong>\0</strong>的字符串追加到目的字符串末尾。</p> 
<p>②相较于strcat()函数，strncat()可实现自追加（先用strlen()函数求出字符串长度，再追加），原因也很简单，strncat()每次追加完毕会自动追加一个<strong>\0。</strong></p> 
<p><strong>使用举例：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/5a/1e/cQNLgVTR_o.png"></strong></p> 
<p></p> 
<h5>  strncmp()</h5> 
<p>        <strong>函数参数及其返回类型:</strong></p> 
<pre><code class="language-cpp">int strncat(const char* str1, const char* str2 , size_t num);
//返回值是大于：大于0的数、等于：0、小于：小于0的数</code></pre> 
<p><strong>作用：</strong></p> 
<p>比较str1与str2前num个字符</p> 
<p><strong>注意点：</strong>无</p> 
<p><strong>使用举例：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/34/51/u0S54Loh_o.png"></strong></p> 
<hr> 
<h4> strtok()使用</h4> 
<p>        <strong>函数参数及其返回类型:</strong></p> 
<pre><code class="language-cpp">char* strtok(char* str, const char* sep );
//返回值是指向找到以sep中的字符分隔的字符串的首地址，如果没找到返回NULL
</code></pre> 
<p><strong>作用：</strong></p> 
<p>找到第一次以sep字符串中的字符分隔的字符串的首地址</p> 
<p><strong>注意点：</strong></p> 
<p>①sep参数中定义了分隔字符串的集合，也就是说可以为多个分隔字符且可以无序</p> 
<p>②当找到第一个以sep中字符分隔的字符串时，将分隔字符以<strong>\0</strong>替代（strtok()函数会改变源字符，所以一般会使用一个临时变量来接收，不改变源字符）</p> 
<p>③strtok()函数具有记忆性（含有static关键字），所以当多次调用strtok()函数时,可将多个字段打印出来</p> 
<p>④如果找不到以sep字符串中的字符分隔的字符串，就返回NULL</p> 
<p>⑤strtok()函数第一个参数为NULL时，函数将在同一个字符保存的位置找下一个字段</p> 
<p><strong>使用举例：</strong></p> 
<pre><code class="language-cpp">//strtok()函数举例
#include&lt;string.h&gt;
int main() {
	char str[20] = "192.91.89.7";//以“.”分隔的字符串
	char* sep = ".";//分隔字符（可以为多个）
	char* ret = NULL;
	for (ret = strtok(str, sep); ret != NULL;ret=strtok(NULL,sep))
	//初始化表达式只执行一次，取出第一个字段：ret = strtok(str, sep)
	//条件表达式用于判断是否为NULL，为NULL则找不到了：ret != NULL
	//更新表达式用于查找下一个字段，第一个参数为NULL时，会从上一次分隔位置查找：ret=strtok(NULL,sep)
		printf("%s\n", ret);
	return 0;
}</code></pre> 
<p><strong>运行结果： </strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/2b/98/5zx4fbLG_o.png"></strong></p> 
<hr> 
<h4> strstr()使用以及模拟实现</h4> 
<p>      <strong>函数参数及其返回类型:</strong></p> 
<pre><code class="language-cpp">char* strstr(const char* str1, const char* str2 );
//返回值是在str1中第一次出现str2字符串的首地址，如果没找到返回NULL
</code></pre> 
<p><strong>作用：</strong></p> 
<p>在str1中找str2字符串首次出现的位置</p> 
<p><strong>使用举例：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/48/b5/kNSS3KC0_o.png"></strong></p> 
<p><strong> 模拟实现：</strong></p> 
<pre><code class="language-cpp">#include&lt;assert.h&gt;
char* my_strstr(const char* str1, const char* str2) {
	assert(str1 &amp;&amp; str2);
	const char* s1 = NULL;
	const char* s2 = NULL;
	const char* cur = str1;//cur直接指向str1
	while (*cur) {
		s1 = cur;//s1指向cur
		s2 = str2;//s2变量用来指向str2
		while (*s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2) {
		//当s1和s2不为\0时继续找：*s1 &amp;&amp; *s2 
		//满足条件找下一对字符：*s1 == *s2
			s1++;
			s2++;
		}
		if (!*s2) {//取反操作判断是否为\0，为\0说明s2对应到最后一个字符，跳出循环了
			return cur;
		}
		cur++;
		//cur自增，当一次不满足时，使指向cur的s1跳到下一个字符继续匹配
	}
	return NULL;
	//指向str1的cur自增到str1的最后一个字符，还没匹配成功，说明找不到了，返回NULL
}
//strstr()函数模拟实现
int main() {
	char str2[100] = "ABC";
	char str1[100] = "HJKANUABCENNS";
	char* str;
	str = my_strstr(str1, str2);
	printf("%s", str);
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b9/7d/j4RwFOiY_o.png"></p> 
<hr> 
<h4> strerror()</h4> 
<p>       <strong>函数参数及其返回类型:</strong></p> 
<pre><code class="language-cpp">char* strerror(int errornum);
//返回值是整型数字errornum对应的错误码信息首地址
</code></pre> 
<p><strong>作用：</strong></p> 
<p>strerror()函数可以把参数部分对应的错误码返回</p> 
<p><strong>注意点：</strong></p> 
<p>简单来说，在C语言编译器上规定了一些错误码（如栈溢出：strack overflew），一般存放在error.h头文件中，当C语言程序启动时，会使用全局变量errno来记录当前错误码的地址。</p> 
<p>errno是一个全局变量用来存放错误码。</p> 
<p><strong>使用举例：</strong></p> 
<pre><code class="language-cpp">#include&lt;string.h&gt;
int main() {
	int i;
	for (i = 0; i &lt; 10; i++) {
		printf("%s\n", strerror(i));
		//打印前10条错误码，其中错误码0为无错
	}
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/b5/54/MvSC9f1D_o.png"></strong></p> 
<p> 值得注意的是使用perror()函数可以直接将当前错误码打印出来（括号内为提示信息，可不传参）</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25fc10357c28272a65c13010e597d8f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】二叉搜索树——高阶数据结构的敲门砖</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b54e4cdcab515b4820e54cbf121484fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【SpringCloud】负载均衡</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>