<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉树相关的算法题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f7ec5274b0c3f26d67f048f232d49fec/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="二叉树相关的算法题">
  <meta property="og:description" content="二叉树相关的算法题 单值二叉树 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
只有给定的树是单值二叉树时，才返回 true；否则返回 false。
示例 1：
输入：[1,1,1,1,1,null,1] 输出：true 示例 2：
输入：[2,2,2,5,2] 输出：false 提示：
给定树的节点数范围是 [1, 100]。每个节点的值都是整数，范围为 [0, 99] 。 思路如下：
代码如下：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ typedef struct TreeNode TreeNode; bool isUnivalTree(struct TreeNode* root) { //根节点为空 if(root==NULL) { return true; } //根节点不为空 if(root-&gt;left&amp;&amp;root-&gt;left-&gt;val!=root-&gt;val) { return false; } if(root-&gt;right&amp;&amp;root-&gt;right-&gt;val!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T12:35:18+08:00">
    <meta property="article:modified_time" content="2024-08-11T12:35:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉树相关的算法题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>二叉树相关的算法题</h2> 
<h3><a id="_2"></a>单值二叉树</h3> 
<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p> 
<p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p> 
<p><strong>示例 1：</strong></p> 
<p><img src="https://images2.imgbox.com/ba/7c/f18Ccgox_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：[1,1,1,1,1,null,1]
输出：true
</code></pre> 
<p><strong>示例 2：</strong></p> 
<p><img src="https://images2.imgbox.com/b3/58/4P1hujQ6_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：[2,2,2,5,2]
输出：false
</code></pre> 
<p><strong>提示：</strong></p> 
<ol><li>给定树的节点数范围是 <code>[1, 100]</code>。</li><li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li></ol> 
<p>思路如下：</p> 
<p><img src="https://images2.imgbox.com/79/a0/9UzD15nB_o.png" alt="在这里插入图片描述"></p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 typedef struct TreeNode TreeNode;
bool isUnivalTree(struct TreeNode* root) {
    //根节点为空
    if(root==NULL)
    {
        return true;
    }
    //根节点不为空
    if(root-&gt;left&amp;&amp;root-&gt;left-&gt;val!=root-&gt;val)
    {
        return false;
    }
    if(root-&gt;right&amp;&amp;root-&gt;right-&gt;val!=root-&gt;val)
    {
        return false;
    }
    return isUnivalTree(root-&gt;left)&amp;&amp;isUnivalTree(root-&gt;right);
}
</code></pre> 
<h3><a id="_69"></a>相同的树</h3> 
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p> 
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p> 
<p><strong>示例 1：</strong></p> 
<p><img src="https://images2.imgbox.com/14/68/JPWY9QvB_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：p = [1,2,3], q = [1,2,3]
输出：true
</code></pre> 
<p><strong>示例 2：</strong><br> <img src="https://images2.imgbox.com/7d/e7/bCw5Q7t8_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：p = [1,2], q = [1,null,2]
输出：false
</code></pre> 
<p><strong>示例 3：</strong></p> 
<p><img src="https://images2.imgbox.com/6e/a3/a0TcWUZs_o.png" alt="在这里插入图片描述"></p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
   //该树为空
    if(p==NULL&amp;&amp;q==NULL)
    {
        return true;
    }
    //其中一个为空
    if(p==NULL||q==NULL)
    {
        return false;
    }
    //值不同
    if(p-&gt;val!=q-&gt;val)
    {
        return false;
    }
    return isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);
}
</code></pre> 
<h3><a id="_133"></a>对称二叉树</h3> 
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p> 
<p><strong>示例 1：</strong><br> <img src="https://images2.imgbox.com/09/e7/Qzwgsz10_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [1,2,2,3,4,4,3]
输出：true
</code></pre> 
<p><strong>示例 2：</strong></p> 
<p><img src="https://images2.imgbox.com/61/83/jNoyQtTB_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [1,2,2,null,3,null,3]
输出：false
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul> 
<p><u>这道题是基于上一题相同的树来完成的。</u></p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 bool isSameTree(struct TreeNode*p,struct TreeNode*q)
 {
    if(p==NULL&amp;&amp;q==NULL)
    {
        return true;
    }
    if(p==NULL||q==NULL)
    {
        return false;
    }
    if(p-&gt;val!=q-&gt;val)
    {
        return false;
    }
    return isSameTree(p-&gt;left,q-&gt;right)&amp;&amp;isSameTree(p-&gt;right,q-&gt;left);//不同点在于这里两个树的结构进行比较，不是说树的内部进行比较
 }
bool isSymmetric(struct TreeNode* root) {
    return isSameTree(root-&gt;left,root-&gt;right);
}
</code></pre> 
<h3><a id="_196"></a>另一个树的子树</h3> 
<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p> 
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p> 
<p><strong>示例 1：</strong></p> 
<p><img src="https://images2.imgbox.com/bc/cf/lp3f8ylV_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
</code></pre> 
<p><strong>示例 2：</strong><br> <img src="https://images2.imgbox.com/90/c1/6SW9m310_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li><li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li><li><code>-104 &lt;= root.val &lt;= 104</code></li><li><code>-104 &lt;= subRoot.val &lt;= 104</code></li></ul> 
<p>代码如下：</p> 
<pre><code class="prism language-C">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

bool isSameTree(struct TreeNode*p,struct TreeNode*q)
{
    if(p==NULL&amp;&amp;q==NULL)
    {
        return true;
    }
    if(p==NULL||q==NULL)
    {
        return false;
    }
    if(p-&gt;val!=q-&gt;val)
    {
        return false;
    }
    return isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);
}
bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot){
    if(root==NULL)
    {
        return false;
    }
    if(isSameTree(root,subRoot))
    {
        return true;
    }
    return isSubtree(root-&gt;left,subRoot)||isSubtree(root-&gt;right,subRoot);
}
</code></pre> 
<p>这几道题我们可以发现重要的规律，都要用到相同的二叉树里面的代码，这里有所不同的地方在于让根节点的左右子树分别和subRoot进行比较。</p> 
<h3><a id="_272"></a>二叉树的前序遍历</h3> 
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p> 
<p><strong>示例 1：</strong></p> 
<p><img src="https://images2.imgbox.com/98/df/QIT3xnVK_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [1,null,2,3]
输出：[1,2,3]
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：root = []
输出：[]
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：root = [1]
输出：[1]
</code></pre> 
<p><strong>示例 4：</strong></p> 
<p><img src="https://images2.imgbox.com/2b/9a/sLj3JX34_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [1,2]
输出：[1,2]
</code></pre> 
<p><strong>示例 5：</strong><br> <img src="https://images2.imgbox.com/a8/46/p3Fv9ICk_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [1,null,2]
输出：[1,2]
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul> 
<p>代码如下：</p> 
<pre><code class="prism language-C">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 typedef struct TreeNode TreeNode;
 int TreeSize(TreeNode*root)
 {
    if(root==NULL)
    {
        return 0;
    }
    return 1+TreeSize(root-&gt;left)+TreeSize(root-&gt;right);
 }
//前序遍历：根左右
 void _preorderTraversal(TreeNode*root,int*arr,int*pi)
 {
    if(root==NULL)
    {
        return;
    }
     //为什么这里不是传值，而是要传地址呢，因为传值是放到另一块空间，并没有改变本身，也就意味着，从始至终都是从0开始
     //形参要想改变实参就要传址调用
    arr[(*pi)++]=root-&gt;val;
    _preorderTraversal(root-&gt;left,arr,pi);
    _preorderTraversal(root-&gt;right,arr,pi);
 }
int* preorderTraversal(struct TreeNode* root, int* returnSize) {
    //求节点个数
    *returnSize=TreeSize(root);
    //计算数组大小
    int*returnArr=(int*)malloc(sizeof(int)*(*returnSize));
    int i=0;
    _preorderTraversal(root,returnArr,&amp;i);
    return returnArr;
}
</code></pre> 
<h3><a id="_372"></a>二叉树的中序遍历</h3> 
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p> 
<p><strong>示例 1：</strong></p> 
<p><img src="https://images2.imgbox.com/a2/9f/MHQQN75q_o.png" alt="在这里插入图片描述"></p> 
<pre><code>输入：root = [1,null,2,3]
输出：[1,3,2]
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：root = []
输出：[]
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：root = [1]
输出：[1]
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul> 
<p>代码如下：</p> 
<pre><code class="prism language-C">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 typedef struct TreeNode TreeNode;
 int TreeSize(TreeNode*root)
 {
    if(root==NULL)
 {
    return 0;
 }
 return 1+TreeSize(root-&gt;left)+TreeSize(root-&gt;right);
 }

 void _inorderTraversal(struct TreeNode*root,int*arr,int*pi)
 {
    if(root==NULL)
    {
        return;
    }
   _inorderTraversal(root-&gt;left,arr,pi);
    arr[(*pi)++]=root-&gt;val;
    _inorderTraversal(root-&gt;right,arr,pi);
 }
int* inorderTraversal(struct TreeNode* root, int* returnSize) {
    *returnSize=TreeSize(root);
    int* returnArr=(int*)malloc(sizeof(int)*(*returnSize));
    int i=0;
    _inorderTraversal(root,returnArr,&amp;i);
    return returnArr;
}
</code></pre> 
<h3><a id="_450"></a>二叉树的后序遍历</h3> 
<p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：root = [1,null,2,3]
输出：[3,2,1]
</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：root = []
输出：[]
</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：root = [1]
输出：[1]
</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li>树中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul> 
<pre><code class="prism language-C">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 typedef struct TreeNode TreeNode;
 int TreeSize(TreeNode*root)
 {
    if(root==NULL)
    {
        return 0;
    }
    return 1+TreeSize(root-&gt;left)+TreeSize(root-&gt;right);
 }
void _postorderTraversal(struct TreeNode*root,int*arr,int*pi)
{
    if(root==NULL)
    {
        return;
    }
    _postorderTraversal(root-&gt;left,arr,pi);
    _postorderTraversal(root-&gt;right,arr,pi);
    arr[(*pi)++]=root-&gt;val;
}
int* postorderTraversal(struct TreeNode* root, int* returnSize) {
    *returnSize=TreeSize(root);
    int*returnArr=(int*)malloc(sizeof(int)*(*returnSize));
    int i=0;
    _postorderTraversal(root,returnArr,&amp;i);
    return returnArr;
}
</code></pre> 
<p>这三道题我们可以感受到只要掌握了怎样遍历二叉树就会变得简单许多</p> 
<h3><a id="_522"></a>二叉树遍历</h3> 
<p><strong>描述</strong></p> 
<p>编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p> 
<p><strong>输入描述：</strong></p> 
<p>输入包括1行字符串，长度不超过100。</p> 
<p><strong>输出描述：</strong></p> 
<p>可能有多组测试数据，对于每组数据， 输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。 每个输出结果占一行。</p> 
<p><strong>示例1</strong></p> 
<pre><code>abc##de#g##f###
c b e g d f a 

</code></pre> 
<p>思路如下：<br> <img src="https://images2.imgbox.com/f5/60/LyfudLyo_o.png" alt="在这里插入图片描述"></p> 
<p>代码如下：</p> 
<pre><code class="prism language-C">include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct BinaryTreeNode
{
    char data;
     struct BinaryTreeNode*left;
     struct BinaryTreeNode*right;
}BTNode;
BTNode* BuyNode(char x)
{
    BTNode*newnode=(BTNode*)malloc(sizeof(BTNode));
    newnode-&gt;data=x;
    newnode-&gt;left=newnode-&gt;right=NULL;
    return newnode;
}
BTNode*CreateNode(char*arr,int*pi)
{
    if(arr[*pi]=='#')
    {
        (*pi)++;
        return NULL;
    }
    BTNode*root=BuyNode(arr[(*pi)++]);
    root-&gt;left=CreateNode(arr, pi);
    root-&gt;right=CreateNode(arr, pi);
    return root;
}
 void Inorder(BTNode*root)
{
    if(root==NULL)
    {
        return;
    }
    Inorder(root-&gt;left);
    printf("%c ",root-&gt;data);
    Inorder(root-&gt;right);
}
int main() {
    char arr[100];
    scanf(" %s ",arr);
    int i=0;
    BTNode*root=CreateNode(arr,&amp;i);
    Inorder(root);
    return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95f720904dd1fab47514ef18733c33d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">avx sse系列介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8b52e42df26b61d57c3185097ac7fbc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构-双链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>