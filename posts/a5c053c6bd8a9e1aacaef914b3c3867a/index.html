<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻松上手MYSQL：MYSQL事务隔离级别的奇幻之旅 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a5c053c6bd8a9e1aacaef914b3c3867a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="轻松上手MYSQL：MYSQL事务隔离级别的奇幻之旅">
  <meta property="og:description" content="​🌈 个人主页：danci_
🔥 系列专栏：《设计模式》《MYSQL》
💪🏻 制定明确可量化的目标，坚持默默的做事。
✨欢迎加入探索MYSQL索引数据结构之旅✨
👋 大家好！文本学习研究事务隔离级别。👋 无论您是刚接触MySQL的初学者，还是希望深入优化性能的资深开发者，这篇文章都将为您揭开MySQL事务隔离级别的神秘面纱，让您掌握其中的奥秘，进而提升数据库操作的效率和精度。快来一起探索吧！
1. 什么是事务？
目录
一、事务隔离级别
1.1 事务并发执行的一致性问题
1.1.1 脏写
1.1.2 脏读
1.1.3 不可重复读：
1.1.4 幻读
1.2 SQL标准中的4种隔离级别
1.3 MYSQL查询事务隔离级别
1.4 MYSQL设置隔离级别
二、MYSQL4种隔离级别实战
2.1 READ UNCOMMITTED
2.2 READ COMMITTED
2.3 REPEATABLE READ（MYSQL默认的隔离级别）
2.4 SERIALIZABLE
三、总结
一、事务隔离级别 MYSQL是客户端 / 服务器的软件，是多对一的关系，即同时可以有多个客户端同时连一个接服务，每个客户端连接服务器后，就生成一个会话。每个会话都可以向服务器发送请求语句，一个请求语句可能是一个事务，也可能是一个事务的某一部分语句。而服务器可以同时处理来自多个客户端的请求语句。
事务简述：一个事务就对应着现实世界的一次状态转换。 下面举个例子，比如用户A向用户B转账100元，账户状态变更简化为以下几个步骤：
取出A账户余额a1。即一次select A a1 &lt; 100，退出转账a1 &gt;= 100，则继续a1 -= 100更新入库。即一次update A取出B账户余额b1。即一次select Bb1 &#43;= 100更新入库。即一次update B 在这个转账事务中，一定要保证 A减100 和 B加100 都成功，换句话说就是必须保证参与转账的账户的总余额保持不变，这也就是这个转账事务的一致性要求。
如果事务是以单个的形式一个接一个地执行，那么在一个事务开始时，面对的就是上一个事务执行结束后留下的一致性状态，它执行之后又会产生下一个一致性状态。那么在多个事务的情况下，情况就变得比较复杂。假如事务是交替执行的，如下图">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-23T21:42:41+08:00">
    <meta property="article:modified_time" content="2024-06-23T21:42:41+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻松上手MYSQL：MYSQL事务隔离级别的奇幻之旅</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><a id="2024_0"></a></h3> 
<p></p> 
<p class="img-center"><img alt="" height="87" src="https://images2.imgbox.com/6f/26/SpdL9U0h_o.png" width="83"></p> 
<p>​🌈 <strong>个人主页：</strong><a href="https://blog.csdn.net/danci_" title="danci_">danci_</a><br> 🔥 <strong>系列专栏：</strong><a href="https://blog.csdn.net/danci_/category_12551117.html" title="《设计模式》">《设计模式》</a><a href="https://blog.csdn.net/danci_/category_12641052.html" title="《MYSQL》">《MYSQL》</a><br> 💪🏻 <strong>制定明确可量化的目标，坚持默默的做事。</strong></p> 
<hr> 
<div class="csdn-video-box"> 
 <iframe id="WnY5jSzF-1719149670273" frameborder="0" src="https://live.csdn.net/v/embed/401918" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p></p> 
</div> 
<p>✨欢迎加入探索MYSQL索引数据结构之旅✨<br>     👋 大家好！文本学习研究事务隔离级别。👋 无论您是刚接触MySQL的初学者，还是希望深入优化性能的资深开发者，这篇文章都将为您揭开MySQL事务隔离级别的神秘面纱，让您掌握其中的奥秘，进而提升数据库操作的效率和精度。快来一起探索吧！</p> 
<p></p> 
<hr> 
<p>1. 什么是事务？</p> 
<hr id="hr-toc"> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">一、事务隔离级别</a></p> 
<p id="1.1%20%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#1.1%20%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98" rel="nofollow">1.1 事务并发执行的一致性问题</a></p> 
<p id="1.1.1%20%E8%84%8F%E5%86%99-toc" style="margin-left:120px;"><a href="#1.1.1%20%E8%84%8F%E5%86%99" rel="nofollow">1.1.1 脏写</a></p> 
<p id="1.1.2%20%E8%84%8F%E8%AF%BB-toc" style="margin-left:120px;"><a href="#1.1.2%20%E8%84%8F%E8%AF%BB" rel="nofollow">1.1.2 脏读</a></p> 
<p id="1.1.3%20%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9A-toc" style="margin-left:120px;"><a href="#1.1.3%20%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9A" rel="nofollow">1.1.3 不可重复读：</a></p> 
<p id="1.1.4%20%E5%B9%BB%E8%AF%BB-toc" style="margin-left:120px;"><a href="#1.1.4%20%E5%B9%BB%E8%AF%BB" rel="nofollow">1.1.4 幻读</a></p> 
<p id="1.2%20SQL%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%844%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.2%20SQL%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%844%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">1.2 SQL标准中的4种隔离级别</a></p> 
<p id="%C2%A01.3%C2%A0MYSQL%E6%9F%A5%E8%AF%A2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:80px;"><a href="#%C2%A01.3%C2%A0MYSQL%E6%9F%A5%E8%AF%A2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">1.3 MYSQL查询事务隔离级别</a></p> 
<p id="1.3%20MYSQL%E6%94%AF%E6%8C%814%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-toc" style="margin-left:80px;"><a href="#1.3%20MYSQL%E6%94%AF%E6%8C%814%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" rel="nofollow">1.4 MYSQL设置隔离级别</a></p> 
<p id="%E4%BA%8C%E3%80%81MYSQL4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E6%88%98-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81MYSQL4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E6%88%98" rel="nofollow">二、MYSQL4种隔离级别实战</a></p> 
<p id="2.1%20READ%20UNCOMMITTED-toc" style="margin-left:80px;"><a href="#2.1%20READ%20UNCOMMITTED" rel="nofollow">2.1 READ UNCOMMITTED</a></p> 
<p id="2.2%20READ%20COMMITTED-toc" style="margin-left:80px;"><a href="#2.2%20READ%20COMMITTED" rel="nofollow">2.2 READ COMMITTED</a></p> 
<p id="2.3%20REPEATABLE%20READ%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#2.3%20REPEATABLE%20READ%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">2.3 REPEATABLE READ（MYSQL默认的隔离级别）</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="2.4%20SERIALIZABLE-toc" style="margin-left:80px;"><a href="#2.4%20SERIALIZABLE" rel="nofollow">2.4 SERIALIZABLE</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">三、总结</a></p> 
<hr> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">一、事务隔离级别</h3> 
<p>MYSQL是客户端 / 服务器的软件，是多对一的关系，即同时可以有多个客户端同时连一个接服务，每个客户端连接服务器后，就生成一个会话。每个会话都可以向服务器发送请求语句，一个请求语句可能是一个事务，也可能是一个事务的某一部分语句。而服务器可以同时处理来自多个客户端的请求语句。</p> 
<div> 
 <pre><code>事务简述：一个事务就对应着现实世界的一次状态转换。</code></pre> 
</div> 
<p>下面举个例子，比如用户A向用户B转账100元，账户状态变更简化为以下几个步骤：</p> 
<ol><li>取出A账户余额a1。即一次select A 
  <ol><li>a1 &lt; 100，退出转账</li><li>a1 &gt;= 100，则继续</li></ol></li><li>a1 -= 100</li><li>更新入库。即一次update A</li><li>取出B账户余额b1。即一次select B</li><li>b1 += 100</li><li>更新入库。即一次update B</li></ol> 
<p>在这个转账事务中，一定要保证 A减100 和 B加100 都成功，换句话说就是必须保证参与转账的账户的总余额保持不变，这也就是这个转账事务的<strong>一致性</strong>要求。</p> 
<p></p> 
<p>如果事务是以单个的形式一个接一个地执行，那么在一个事务开始时，面对的就是上一个事务执行结束后留下的一致性状态，它执行之后又会产生下一个一致性状态。那么在多个事务的情况下，情况就变得比较复杂。假如事务是交替执行的，如下图</p> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/19/4a/dsroHqAV_o.png" width="1200"></p> 
<p></p> 
<p>如图中的交替执行的两个事务，A转账了两次5最后余额为6 ，B转入两次余额为12。显然A账户余额是错误的，这就违背了“参与转账的账户的总余额保持不变”的一致性要求。</p> 
<p></p> 
<p>这时就需要某种手段来强制让这些事务按照顺序一个一个单独地执行，或者最终执行的效果和单独执行一样。换句话说就是让多个事务隔离的执行，也就是互不干涉。这就是事务的<strong>隔离性</strong>要求。</p> 
<p></p> 
<p>如何实现事务的隔离性？</p> 
<ul><li>串行执行：在系统中同一时刻最多只允许一个事务运行 
  <ul><li>能保证一致性</li><li>导致许多事务等待时间，资源利用率低</li></ul></li><li>可串行化执行：事务可并发执行，但涉及到同一个数据时，就等待其它事务提交之后才能继续访问这个数据。</li></ul> 
<p>可串行化执行对同一数据写操作就会出现等待，性能还是不高。在一些高并发场景中影响会非常明显。</p> 
<p></p> 
<h4 id="1.1%20%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">1.1 事务并发执行的一致性问题</h4> 
<h5 id="1.1.1%20%E8%84%8F%E5%86%99">1.1.1 脏写</h5> 
<p>事务T1和事务T2同时修改数据x，事务T1开启事务写x值且还没有提交事务，事务T2开始写x值，这就发生了脏写。如下图：</p> 
<p></p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/ee/85/Zzxv9MS9_o.png" width="342"></p> 
<p></p> 
<p></p> 
<p>脏写不只影响数据的一致性，还影响事务的原子性，如下图：（假设x初始值为 5）</p> 
<p></p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/4d/5c/560Uu3iL_o.png" width="344"></p> 
<p></p> 
<p></p> 
<p>事务 T1 因某种原因要回滚，那么需要将它的数据回滚到事务开启时的状态，也就是将x的值变为初始值为 5。但是对于事务 T2 来说，它修改x为200并且已经提交了，如果 T1 回滚，则 T2 事务的修改有一部分数据回滚了，这就影响了事务的原子性。</p> 
<h5 id="1.1.2%20%E8%84%8F%E8%AF%BB">1.1.2 脏读</h5> 
<p>事务T1读到未提交事务T2修改过的数据，这就发生了脏读。如下图：</p> 
<p></p> 
<p></p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/11/93/9FWM4rjb_o.png" width="357"></p> 
<p></p> 
<p>事务T1 读 x 时 T2 未提交，这时 T1 读到的是不一致的数据。</p> 
<p></p> 
<h5 id="1.1.3%20%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9A">1.1.3 不可重复读：</h5> 
<p>事务 T1 修改了未提醒事务 T2 读取的数据，这就发生了不可重复读。如下图：</p> 
<p></p> 
<p></p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/b8/70/xF4K9LEe_o.png" width="373"></p> 
<p></p> 
<p>事务 T1 和事务 T2 都开启事务，事务 T2 读 x 为 50，之后事务 T1 修改 x = 100 并且提交了事务，事务 T2 再次读 x，此时 x 的值为 100了，这就出现在同一个事务中读同一条数据的值不一致问题。这种在同一个事务中读同一条数据不一致问题不应该暴露给用户的。</p> 
<p></p> 
<h5 id="1.1.4%20%E5%B9%BB%E8%AF%BB">1.1.4 幻读</h5> 
<p>事务 T1 根据某种搜索条件井底出记录，在该事务未提交时，另一事务写入了符合那些搜索条件的记录，这就产生了幻读。如下图：</p> 
<p></p> 
<p></p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/6e/f4/cTwzOVxX_o.png" width="376"></p> 
<p></p> 
<p>事务 T1 查询 col = 1 的数据有记录1 和 记录2，此时事务 T2 修改记录3 的col = 1并且提交事务，这时，事务 T1 再查询 col = 1 的数据有 记录1、记录2 和 记录3，与之前的查询结果不一致，不符合一致性要求。</p> 
<p>影响一致性严重性大到小排序： 脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p> 
<p></p> 
<h4 id="1.2%20SQL%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%844%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">1.2 SQL标准中的4种隔离级别</h4> 
<p></p> 
<ul><li> <p id="READ%20UNCOMMITTED%3A%20%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4">READ UNCOMMITTED: 读未提交</p> </li><li> <p id="READ%20COMMITTED%3A%20%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4">READ COMMITTED: 读已提交</p> </li><li> <p id="REPEATABLE%20READ%3A%20%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">REPEATABLE READ: 可重复读</p> </li><li> <p id="SERIALIZABLE%3A%20%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96">SERIALIZABLE: 可串行化</p> </li></ul> 
<p></p> 
<p>四种隔离级别在并发事务中可能发生的数据一致性问题如下：</p> 
<p></p> 
<p></p> 
<p><img alt="" height="820" src="https://images2.imgbox.com/2f/28/nQN8n6Tp_o.png" width="1200"></p> 
<p></p> 
<p>也就是说：</p> 
<ul><li>READ UNCOMMITTED隔离级别下，可能脏读、不可重复读和幻读</li><li>READ COMMITTED隔离级别下，可能发生不要重复读和幻读</li><li>REPEATABLE READ隔离级别下，可能发生幻读</li><li>SERLIALIZABLE隔离级别下，脏读、不可重复读和 幻读 均不可能发生</li></ul> 
<p>注：脏写这个情况对一致性影响很严重，以上四种隔离级别都不准脏写发生。</p> 
<p></p> 
<h4 id="%C2%A01.3%C2%A0MYSQL%E6%9F%A5%E8%AF%A2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" style="background-color:transparent;">1.3 MYSQL查询事务隔离级别</h4> 
<div> 
 <pre><code>Mysql8以前：SELECT @@GLOBAL.tx_isolation, @@tx_isolation;

Mysql8开始：SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;</code></pre> 
</div> 
<p></p> 
<h4 id="1.3%20MYSQL%E6%94%AF%E6%8C%814%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">1.4 MYSQL设置隔离级别</h4> 
<p>MYSQL支持4种事务隔离级别，默认的隔离级别为REPEATABLE READ（可重复读）</p> 
<p><strong>设置事务隔离级别</strong></p> 
<div> 
 <pre><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level</code></pre> 
</div> 
<p>其中</p> 
<ul><li>level有：REPEATABLE READ、READ UNCOMMITTED、READ COMMIITTED 和 SERIALIZABLE</li><li>GLOBAL| SESSION：可设置可不设置 
  <ul><li>不设置：只对执行SET后的下一个事务有效 
    <ul><li>对下一个事务有效</li><li>对下下个事务无效，事务隔离级别恢复到之前的隔离级别</li><li>在已经开启的事件中执行会报错</li></ul></li><li>GLOBAL：全局范围有效 
    <ul><li>当前会话无效</li><li>只对执行完该SET后的会话有效</li></ul></li><li>SESSION：在当前会话有效 
    <ul><li>多个事务执行，只对该语句后面执行的事务有效</li><li>可在开启的事务中执行，不影响之前正在执行的事务</li><li>对当前会话后续的事务无效</li></ul></li></ul></li></ul> 
<p><strong>查看事务隔离级别</strong></p> 
<div> 
 <pre><code>mysql&gt; SHOW VARIABLES LIKE 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.03 sec)</code></pre> 
</div> 
<div> 
 <pre><code>mysql&gt; select @@transaction_isolation;
+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
1 row in set (0.00 sec)</code></pre> 
</div> 
<p>其实设置事务隔离级别相当于修改transaction_isolation的值。</p> 
<p>设置隔离级别：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>语法</td><td>作用范围</td></tr><tr><td>SET GLOBAL transaction_isolation = 隔离级别</td><td>全局</td></tr><tr><td>SET @@GLOBAL.var_name = 隔离级别</td><td>全局</td></tr><tr><td>SET var_name = 隔离级别</td><td>会话</td></tr><tr><td>SET SESSION var_name = 隔离级别</td><td>会话</td></tr><tr><td>SET @@SESSION.var_name = 隔离级别</td><td>会话</td></tr><tr><td>SET @@var_name = 隔离级别</td><td>下一个事务</td></tr></tbody></table> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81MYSQL4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E6%88%98">二、MYSQL4种隔离级别实战</h3> 
<p>创建个测试表</p> 
<div> 
 <pre><code>CREATE TABLE `test`.`test`  (
  `id` int NULL DEFAULT NULL,
  `name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;
INSERT INTO test values(1, 'zhangsan');</code></pre> 
</div> 
<p></p> 
<h4 id="2.1%20READ%20UNCOMMITTED">2.1 READ UNCOMMITTED</h4> 
<p>设置事务隔离级别、开启两个会话且开启事务，操作如下：(左边：事务a；右边：事务b）</p> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/60/47/Hpy9mf0F_o.png" width="1200"></p> 
<p>                                                                图 2.1-1</p> 
<p></p> 
<p> 打开两个会话，事务隔离级别设置为 READ UNCOMMITTED（读未提交）</p> 
<div> 
 <pre><code>SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></pre> 
</div> 
<p></p> 
<div> 
 <pre><code>如图2.1-1中
脏读： name初始化为zhangsan，事务a修改name为lisi 且事务未提交，
事务b已读出name为lisi，而不是zhangsan（读未提交），出现了“脏读”现象。

不可重复读：在事务b中两次读取的数据不一样，出现了“不可重复读”现象。</code></pre> 
</div> 
<p></p> 
<p><img alt="" height="1188" src="https://images2.imgbox.com/09/27/sQFZPO4T_o.png" width="1200"></p> 
<p>                                                                图 2.1-2</p> 
<div> 
 <pre><code>如图2.1-2中
在事务a插入新数据之前读name='zhangsan'和事务b读name='zhangsan'都为一条数据，
事务a插入一条数据且未提交，
幻读： 此时事务b用相同的查询条件，读出来了两条两次读出来不一致的数据，出现了“幻读”现象。</code></pre> 
</div> 
<p></p> 
<h4 id="2.2%20READ%20COMMITTED">2.2 READ COMMITTED</h4> 
<p>设置事务隔离级别、开启两个会话且开启事务，操作如下：(左边：事务a；右边：事务b）</p> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/bd/99/rZ5VhSU0_o.png" width="1200"></p> 
<p>                                                                图2.2-1</p> 
<p></p> 
<p>如图2.1-1中，同时启动两个事务ab</p> 
<p>name初始化为 'lisi'，事务a修改name为 'zhangsan' 且事务未提交，事务b读name时，值仍然为 'lisi'，而不是 'zhangsan'（读已提交）。当事务a提交了事务，事务读出的数据为 'zhangsan'。</p> 
<p><strong>未出现脏读</strong>： 在事务a未提交的情况下，事务b读的数据没有变化，未出现“脏读”现象。</p> 
<p><strong>不可重复读</strong>： 在同一个事务b中两次读取的数据不一致，出现了“不可重复读”现象。</p> 
<p><strong>幻读</strong>：在同一个事务b中相同条件下读数据不一致，出现了“幻读”现象。</p> 
<p></p> 
<h4 id="2.3%20REPEATABLE%20READ%E2%80%8B%E7%BC%96%E8%BE%91">2.3 REPEATABLE READ（MYSQL默认的隔离级别）</h4> 
<h4></h4> 
<p><img alt="" height="1154" src="https://images2.imgbox.com/a0/a5/mD8j7lZl_o.png" width="1200"></p> 
<p style="text-align:center;"><img alt="" height="776" src="https://images2.imgbox.com/a1/63/CbgsLJEK_o.png" width="1200">图 2.3-1</p> 
<p></p> 
<p>如图2.3-1，区域 1，同时启两个事务ab。</p> 
<p><strong>可重复读</strong>：事务ab执行之后，事务a删除id为2的数据，提交前或提交后，事务b再次读取的数据者与之前读取的数据保持一致。</p> 
<p><br> 如图2.3-1，区域 2，同时启两个事务ab。（事务a已提交，默认自动提交）</p> 
<p><strong>幻读</strong>：事务a插入一条新数据id为3（自动提交事务）后，事务b读取数据，还是两条，保证了可重复读特性。但，事务b可以修改 id=3 的数据，然后再查询就能把 id为3 的数据查询出来了，出现了幻读的现象。</p> 
<p></p> 
<h4 id="2.4%20SERIALIZABLE">2.4 SERIALIZABLE</h4> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/89/72/CgLG5nZW_o.png" width="1200"></p> 
<p>                                                                图 2.4-1</p> 
<p></p> 
<p> 如图2.4-1，设置隔离级别为SERIALIZABLE，同时开启两个事务，各步骤说明和结论：</p> 
<ul><li>1: 读 id = 1 的数据</li><li>2: 修改 id = 1 的数据报锁超时，结论：读某数据且加锁，本事务可读写，别的事务只可读不可写</li><li>3: 更新 id = 5 成功，无其它事务读或写的数据，可写</li><li>4: 读 id = 5 报锁超时，结论：写某数据，别的事务不允许读也不允许写</li><li>5: 插入 id = 2 成功，无其它事务读或写的数据，可写</li><li>6: 范围查询 id (5, 11)</li><li>7: 插入 id = 7 成功，无其它事务读或写的数据，可写</li><li>8: 插入 id为6 报锁超时</li><li>9: 插入 id为6 成功</li><li>10: 范围查询 id (5, 11)</li><li>11: 插入 id为7 成功</li><li>12: 插入 id为8 报锁牛奶时，结论：范围查询加锁，该范围数据本事务可读写，其它事务只可读</li><li>13: 插入 id = 12 成功，无其它事务读或写的数据 id = 12，可写</li></ul> 
<p> 如此，本事务查询的数据，本事务可修改，其它事务只可读； 本事务修改的数据，其它事务不可查询和修改。完美避免脏读、不可重复读、幻读等读现象。当然因各种加锁，使得该事务隔离级别下效率低下，耗费数据库性能，不推荐使用。</p> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93">三、总结</h3> 
<p></p> 
<p>        本文我们深入探索了MySQL事务隔离级别的奥秘。从READ UNCOMMITTED到SERIALIZABLE，每个级别都有其独特的特点和适用场景。READ UNCOMMITTED虽快但风险高，SERIALIZABLE则提供最严格的数据一致性保证但性能消耗大。在实际应用中，根据业务需求和性能考量，合理选择事务隔离级别至关重要。通过本次奇幻之旅，我们掌握了事务隔离级别的核心概念及实战，为在MySQL数据库中实现高效、稳定的数据处理提供了有力支持。</p> 
<p></p> 
<p>   <span style="background-color:#fef2f0;"> </span><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">希望你喜欢这次的探索之旅！不要忘记 "点赞" 和 "关注" 哦，我们下次见！</span></span><span style="color:#be191c;"><span style="background-color:#fef2f0;">🎈</span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3531e26e763665125888dacdc29ffc1c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安卓lua解密——opcode修改后dump反编译</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d780f3c8ca4dba3a89b92090e1df945/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机组成入门知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>