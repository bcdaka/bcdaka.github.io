<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【排序算法】堆排序详解与实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9c867882975ca8dd757e9a3495731bba/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【排序算法】堆排序详解与实现">
  <meta property="og:description" content="一、堆排序的思想 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆（若不清楚什么是堆，可以看我前面的文章，有详细阐述）来进行选择数据，通过向下调整算法，从第一个非叶子结点开始在局部先创建出大堆（或小堆），然后父亲结点不断往上走，直到整棵树都建成一个堆。 需要注意的是排升序要建大堆，排降序建小堆。（ 然后不断交换根节点和最后一个节点的值，交换完后节点的数目减1（因为最后一个节点已经是它应该在的位置了，不用再参与建堆），再从根节点向下建堆（除最后一个节点其它节点又会建成一个堆） ） 。 然后重复红色括号中的过程，堆排序就完成了。 二、堆排序的图解 下图以建大堆为例排一个升序序列
三、堆排序的实现 3.1向下调整算法的实现 实现堆排序最重要的就是实现向下调整算法。以下是向下调整算法的代码以及解释
//这里以建大堆为例 void AdjustDown(int* a, int n, int root) { int child = root * 2 &#43; 1;//找到根节点的左孩子 while (child &lt; n)//判断左孩子是否出界 { if (child &#43; 1 &lt; n &amp;&amp; a[child &#43; 1] &gt; a[child]) //child &#43; 1 &lt; n判断右孩子是否出界， //a[child &#43; 1] &gt; a[child]判断左右孩子的大小，取左右孩子中大的那一个 child&#43;&#43;; if (a[child] &gt; a[root])//入过孩子的值比父亲的值大，就交换孩子和父亲的位置 Swap(&amp;a[child], &amp;a[root]); else//如果孩子的值不比父亲的值大，就证明大堆已经建好了（因为此时父亲的左右子树都是大堆）， //直接break跳出循环。 break; //没有break来到这里就顺着子树继续往下走 root = child; child = root * 2 &#43; 1; } } 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-08T12:21:30+08:00">
    <meta property="article:modified_time" content="2023-10-08T12:21:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【排序算法】堆排序详解与实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/78/mZW0iPq3_o.jpg"></h2> 
<h2><span style="color:#0d0016;">一、堆排序的思想</span></h2> 
<div> 
 <span style="color:#777777;">       </span> 
 <span style="color:#0d0016;"> 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆（若不清楚什么是堆，可以看我前面的文章，有详细阐述）来进行选择数据，通过向下调整算法，从第一个非叶子结点开始在局部先创建出大堆（或小堆），然后父亲结点不断往上走，直到整棵树都建成一个堆<strong>。</strong></span> 
 <span style="color:#fe2c24;"><strong>需要注意的是排升序要建大堆，排降序建小堆。（</strong></span> 
 <span style="color:#0d0016;">然后不断交换根节点和最后一个节点的值，交换完后节点的数目减1（因为最后一个节点已经是它应该在的位置了，不用再参与建堆），再从根节点向下建堆（除最后一个节点其它节点又会建成一个堆）</span> 
 <strong><span style="color:#fe2c24;">）</span></strong> 
 <span style="color:#777777;">。</span> 
 <span style="color:#0d0016;">然后重复红色括号中的过程，堆排序就完成了。</span> 
</div> 
<h2><span style="color:#0d0016;">二、堆排序的图解</span></h2> 
<p><span style="color:#0d0016;">下图以建大堆为例排一个升序序列</span></p> 
<p><img alt="" height="793" src="https://images2.imgbox.com/29/e6/Y4edPKep_o.png" width="819"></p> 
<h2>三、堆排序的实现</h2> 
<h3>3.1向下调整算法的实现</h3> 
<p><span style="color:#0d0016;">实现堆排序最重要的就是实现向下调整算法。以下是向下调整算法的代码以及解释</span></p> 
<pre><code class="language-cpp">//这里以建大堆为例
void AdjustDown(int* a, int n, int root)
{
	int child = root * 2 + 1;//找到根节点的左孩子
	while (child &lt; n)//判断左孩子是否出界
	{
		if (child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child])
			//child + 1 &lt; n判断右孩子是否出界，
			//a[child + 1] &gt; a[child]判断左右孩子的大小，取左右孩子中大的那一个
			child++;
		if (a[child] &gt; a[root])//入过孩子的值比父亲的值大，就交换孩子和父亲的位置
			Swap(&amp;a[child], &amp;a[root]);
		else//如果孩子的值不比父亲的值大，就证明大堆已经建好了（因为此时父亲的左右子树都是大堆），
			//直接break跳出循环。
			break;
		//没有break来到这里就顺着子树继续往下走
		root = child;
		child = root * 2 + 1;
	}
}</code></pre> 
<h3>3.2堆排序的实现</h3> 
<p><span style="color:#0d0016;">以下是堆排序的代码实现以及解释</span></p> 
<pre><code class="language-cpp">void HeapSort(int* a, int n)
{
	//向下调整建堆
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)
	{
		//(n - 1 - 1) / 2找到第一个非叶子节点，从第一个非叶子结点开始向下建堆
		AdjustDown(a, n, i);
	}
	//堆建好了
	int end = n - 1;
	while (end &gt; 0)
	{
		//假设是建大堆，将下标为0的元素和下标为end的元素交换，
		//最大的数就排到最后了，也就相当于最后的那个数已经排好了，不用再参与下面的向下建堆
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);//还没有排好的数向下建堆从0位置开始向下建堆
		end--;
	}
}</code></pre> 
<h2>四、总结</h2> 
<div>
  堆排序的时间复杂度为 
 <span style="color:#0d0016;">O(N*logN) （向下建堆时间复杂度为O(N)，排序时间复杂度为O(N*logN)）， 空间复杂度：O(1) ，稳定性：不稳定。</span> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/418ce5afab707df03525ebc6834f52a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jar 命令启动java 指定配置文件路径 jar如何启动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28e0875d3ea6407c277f248632a6b446/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java Map集合里面取键和值的四种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>