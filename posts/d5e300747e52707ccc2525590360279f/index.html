<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>二叉树的链式结构 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d5e300747e52707ccc2525590360279f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="二叉树的链式结构">
  <meta property="og:description" content="前言 Hello,友友们，小编将继续重新开始数据结构的学习，前面讲解了堆的部分知识，今天将讲解二叉树的链式结构的部分内容。
1.概念回顾与新增 二叉树是一种数据结构，其中每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树的链式结构表示是使用指针（或引用）来连接节点，形成树形结构。每个节点包含一个数据元素和两个指向子节点的指针。
2.简单创建二叉树 分为节点的定义，创建节点，创建树
下面我们将简单的手撕一个二叉树：
typedef struct BTnode { int val; struct BTnode* left; struct BTnode* right; }Node; //节点创建 Node* BuyNode(int x) { Node* node = (Node*)malloc(sizeof(Node)); if (node == NULL) { perror(&#34;node fail&#34;); return NULL; } node-&gt;val = x; node-&gt;left = NULL; node-&gt;right = NULL; return node; } //树的创建 Node* CreatTree() { Node* node1 = BuyNode(1); Node* node2 = BuyNode(2); Node* node3 = BuyNode(3); Node* node4 = BuyNode(4); Node* node5 = BuyNode(5); Node* node6 = BuyNode(6); node1-&gt;left = node2; node1-&gt;right = node4; node2-&gt;left = node3; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 注意：上述代码并不是创建二叉树的方式，真正创建二叉树方式后序详解重点讲解。 二叉树建立过后，接下来我们要进行二叉树的遍历操作 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-07T13:53:08+08:00">
    <meta property="article:modified_time" content="2024-07-07T13:53:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">二叉树的链式结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="text-align:center;"></h3> 
<h3>前言</h3> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>Hello,友友们，小编将继续重新开始数据结构的学习，前面讲解了堆的部分知识，今天将讲解二叉树的链式结构的部分内容。</strong></span></p> 
</blockquote> 
<h3 style="text-align:center;"><br><img alt="" src="https://images2.imgbox.com/03/a4/zEhF1BON_o.jpg"></h3> 
<h3></h3> 
<h3 id="1.%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%96%B0%E5%A2%9E">1.概念回顾与新增</h3> 
<p>二叉树是一种数据结构，其中每个节点最多有两个子节点，分别是左子节点和右子节点。<strong>二叉树的链式结构表示是使用指针（或引用）来连接节点，形成树形结构。每个节点包含一个数据元素和两个指向子节点的指针。</strong></p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/2e/87/zoqNMXyt_o.png" width="1200"></p> 
<h3 id="2.%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">2.简单创建二叉树</h3> 
<p>分为节点的定义，创建节点，创建树</p> 
<p><strong>下面我们将简单的手撕一个二叉树：</strong></p> 
<pre><code class="language-cs">typedef struct BTnode {
	int val;
	struct BTnode* left;
	struct BTnode* right;
}Node;

//节点创建
Node* BuyNode(int x) {
	Node* node = (Node*)malloc(sizeof(Node));
	if (node == NULL) {
		perror("node fail");
		return NULL;
	}
	node-&gt;val = x;
	node-&gt;left = NULL;
	node-&gt;right = NULL;
	return node;
}
//树的创建
Node* CreatTree() {
	
		Node* node1 = BuyNode(1);
		Node* node2 = BuyNode(2);
		Node* node3 = BuyNode(3);
		Node* node4 = BuyNode(4);
		Node* node5 = BuyNode(5);
		Node* node6 = BuyNode(6);

		node1-&gt;left = node2;
		node1-&gt;right = node4;
		node2-&gt;left = node3;
		node4-&gt;left = node5;
		node4-&gt;right = node6;
		return node1;
}</code></pre> 
<div> 
 <span style="color:#fe2c24;"><strong>注意：上述代码并不是创建二叉树的方式，真正创建二叉树方式后序详解重点讲解。 </strong></span> 
</div> 
<div></div> 
<div></div> 
<div> 
 <strong><span style="color:#777777;">二叉树建立过后，接下来我们要进行二叉树的遍历操作</span></strong> 
</div> 
<div></div> 
<h3 id="3.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">3.二叉树的遍历</h3> 
<div> 
 <div></div> 
 <div> 
  <span style="color:#777777;">所谓<strong>二叉树遍历(Traversal)是按照某种特定的规则，依次对二叉树中的结点进行相应的操作，并且每个结点只操作一次</strong>。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。 </span> 
 </div> 
 <div> 
  <span style="color:#777777;">按照规则，二叉树的遍历有：</span> 
  <span style="color:#777777;"><strong>前序</strong></span> 
  <span style="color:#777777;"><strong>/</strong></span> 
  <span style="color:#777777;"><strong>中序</strong></span> 
  <span style="color:#777777;"><strong>/</strong></span> 
  <span style="color:#777777;"><strong>后序的递归结构遍历</strong></span> 
  <span style="color:#777777;">：</span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#777777;">1. </span> 
   <span style="color:#777777;">前序遍历</span> 
   <span style="color:#777777;">(Preorder Traversal </span> 
   <span style="color:#777777;">亦称先序遍历</span> 
   <span style="color:#777777;">)——</span> 
   <span style="color:#777777;">访问根结点的操作发生在遍历其左右子树之前。 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">2. </span> 
   <span style="color:#777777;">中序遍历</span> 
   <span style="color:#777777;">(Inorder Traversal)——</span> 
   <span style="color:#777777;">访问根结点的操作发生在遍历其左右子树之中（间）。 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">3. </span> 
   <span style="color:#777777;">后序遍历</span> 
   <span style="color:#777777;">(Postorder Traversal)——</span> 
   <span style="color:#777777;">访问根结点的操作发生在遍历其左右子树之后。 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">由于被访问的结点必是某子树的根，</span> 
   <span style="color:#777777;"><strong>所以</strong></span> 
   <span style="color:#777777;"><strong>N(Node</strong></span> 
   <span style="color:#777777;"><strong>）、</strong></span> 
   <span style="color:#777777;"><strong>L(Left subtree</strong></span> 
   <span style="color:#777777;"><strong>）和</strong></span> 
   <span style="color:#777777;"><strong>R(Right subtree</strong></span> 
   <span style="color:#777777;"><strong>）又可解释为，</strong></span> 
   <span style="color:#777777;"><strong>根的左子树和根的右子树</strong></span> 
   <span style="color:#777777;">。</span> 
   <span style="color:#777777;">NLR</span> 
   <span style="color:#777777;">、</span> 
   <span style="color:#777777;">LNR</span> 
   <span style="color:#777777;">和</span> 
   <span style="color:#777777;">LRN</span> 
   <span style="color:#777777;">分别又称为先根遍历、中根遍历和后根遍历。</span> 
  </div> 
  <div> 
   <strong><span style="color:#777777;">注意：为了方便理解，我们将空节点都视作为NULL</span></strong> 
  </div> 
  <div></div> 
  <h4 id="3.1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span style="color:#777777;">3.1前序遍历</span></h4> 
  <div> 
   <strong><span style="color:#777777;">代码：</span></strong> 
  </div> 
  <div> 
   <pre><code class="language-cs">void PreOrder(Node* root) {
	if (root == NULL) {
		printf("N ");
		return;
	}
	printf("%d ", root-&gt;val);
	PreOrder(root-&gt;left);
	PreOrder(root-&gt;right);

}</code></pre> 
  </div> 
  <div></div> 
  <div> 
   <strong>递归图解：</strong> 
  </div> 
  <div> 
   <img alt="" height="599" src="https://images2.imgbox.com/91/fe/yrKdaQYa_o.png" width="1200"> 
  </div> 
  <div> 
   <strong>代码递归理解：</strong> 
  </div> 
  <div></div> 
  <div> 
   <img alt="" height="1200" src="https://images2.imgbox.com/fd/a0/ZcjC83o8_o.png" width="1200"> 
  </div> 
  <div></div> 
  <div></div> 
  <div>
    运行结果：1 2 3 N N N 4 5 N N 6 N N 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#fe2c24;"><strong>注意：中序和后序与前序的递归展开图类似，小编就不在展示了。</strong></span> 
  </div> 
  <div></div> 
  <div></div> 
  <h4 id="3.2%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><strong>3.2中序遍历</strong></h4> 
  <div> 
   <pre><code class="language-cs">void InOrder(Node* root) {
	if (root == NULL) {
		printf("N ");
		return;
	}
	InOrder(root-&gt;left);
	printf("%d ", root-&gt;val);
    InOrder(root-&gt;right);

}</code></pre> 
   <p>运行结果：N 3 N 2 N 1 N 5 N 4 N 6 N </p> 
  </div> 
  <h4 id="3.3%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">3.3后序遍历</h4> 
  <div> 
   <pre><code class="language-cs">void PostOrder(Node* root) {
	if (root == NULL) {
		printf("N ");
		return;
	}
	PostOrder(root-&gt;left);
	PostOrder(root-&gt;right);
	printf("%d ", root-&gt;val);

}</code></pre> 
   <p>运行结果:N N 3 N 2 N N 5 N N 6 4 1</p> 
   <h4 id="3.4%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">3.4层序遍历</h4> 
   <div> 
    <span style="color:#777777;"><strong>层序遍历</strong></span> 
    <span style="color:#777777;">：除了先序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历。设二叉树的根结点所在层数为1</span> 
    <span style="color:#777777;">，层序遍历就是从所在二叉树的根结点出发，首先访问第一层的树根结点，然后从左到右访问第</span> 
    <span style="color:#777777;">2</span> 
    <span style="color:#777777;">层上的结点，接着是第三层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。</span> 
   </div> 
   <div></div> 
   <div></div> 
   <div> 
    <img alt="" height="511" src="https://images2.imgbox.com/e5/d2/hdBDW6na_o.png" width="1022"> 
   </div> 
   <div></div> 
   <div></div> 
   <div> 
    <strong>层序遍历较为复杂，这里我们采用队列的方式来实现层序遍历。</strong> 
   </div> 
   <div></div> 
   <div> 
    <strong>这里我们简单的用动态数组实现队列，包括了队列的初始化，入队出队判空的操作。</strong> 
   </div> 
   <div></div> 
   <div></div> 
   <h5 id="3.4.1%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><strong>3.4.1队列的实现</strong></h5> 
   <div> 
    <pre><code class="language-cs">// 队列结构
typedef struct Queue {
	Node* data[MAX];
	int front;
	int rear;
} Queue;

// 初始化队列
void initQueue(Queue* q) {
	q-&gt;front = 0;
	q-&gt;rear = 0;
}

// 入队
void enqueue(Queue* q, Node* node) {
	if ((q-&gt;rear + 1) % MAX == q-&gt;front) {
		printf("Queue is full\n");
		return;
	}
	q-&gt;data[q-&gt;rear] = node;
	q-&gt;rear = (q-&gt;rear + 1) % MAX;
}

// 出队
Node* dequeue(Queue* q) {
	if (q-&gt;front == q-&gt;rear) {
		printf("Queue is empty\n");
		return NULL;
	}
	Node* node = q-&gt;data[q-&gt;front];
	q-&gt;front = (q-&gt;front + 1) % MAX;
	return node;
}

// 判断队列是否为空
int isEmpty(Queue* q) {
	return q-&gt;front == q-&gt;rear;
}</code></pre> 
    <h5 id="3.4.2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0">3.4.2层序遍历实现</h5> 
    <p><strong>从根节点开始，将每个节点的值打印出来，并依次将其左子节点和右子节点加入队列。</strong></p> 
    <pre><code class="language-cs">// 层序遍历函数
void levelOrder(Node* root) {
	if (root == NULL) {
		return;
	}

	Queue q;
	initQueue(&amp;q);
	enqueue(&amp;q, root);

	while (!isEmpty(&amp;q)) {
		Node* node = dequeue(&amp;q);
		printf("%d ", node-&gt;val);

		if (node-&gt;left) {
			enqueue(&amp;q, node-&gt;left);
		}
		if (node-&gt;right) {
			enqueue(&amp;q, node-&gt;right);
		}
	}
}</code></pre> 
    <h4 id="3.5%E4%B8%BB%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">3.5主函数测试代码</h4> 
    <pre><code class="language-cs">int main() {
	Node* root = CreatTree();
	PreOrder(root);
	printf("\n");
	InOrder(root);
	printf("\n");
	PostOrder(root);
	printf("\n");
	levelOrder(root);
	return 0;
}</code></pre> 
    <p><strong>运行结果展示：</strong></p> 
   </div> 
  </div> 
  <div></div> 
  <div> 
   <img alt="" height="104" src="https://images2.imgbox.com/f4/19/kaW0Wigr_o.png" width="792"> 
  </div> 
  <div></div> 
  <div></div> 
  <h3>4.遍历相关选择练习</h3> 
  <div></div> 
  <div> 
   <div> 
    <span style="color:#777777;">1.</span> 
    <span style="color:#777777;">某完全二叉树按层次输出（同一层从左到右）的序列为</span> 
    <span style="color:#777777;"> ABCDEFGH </span> 
    <span style="color:#777777;">。该完全二叉树的前序序列为（ A） </span> 
   </div> 
   <div> 
    <span style="color:#777777;">A .    ABDHECFG </span> 
   </div> 
   <div> 
    <span style="color:#777777;">B.    ABCDEFGH </span> 
   </div> 
   <div> 
    <span style="color:#777777;">C.    HDBEAFCG </span> 
   </div> 
   <div> 
    <span style="color:#777777;">D.    HDEBFGCA </span> 
   </div> 
   <div> 
    <span style="color:#777777;">2.</span> 
    <span style="color:#777777;">二叉树的先序遍历和中序遍历如下：先序遍历：</span> 
    <span style="color:#777777;">EFHIGJK;</span> 
    <span style="color:#777777;">中序遍历：</span> 
    <span style="color:#777777;">HFIEJKG.</span> 
    <span style="color:#777777;">则二叉树根结点为（A） </span> 
   </div> 
   <div> 
    <span style="color:#777777;">A .  E                        B.   F                      C.   G                          D.   H </span> 
   </div> 
   <div> 
    <span style="color:#777777;">3.</span> 
    <span style="color:#777777;">设一课二叉树的中序遍历序列：</span> 
    <span style="color:#777777;">badce</span> 
    <span style="color:#777777;">，后序遍历序列：</span> 
    <span style="color:#777777;">bdeca</span> 
    <span style="color:#777777;">，则二叉树前序遍历序列为(D)</span> 
   </div> 
   <div> 
    <span style="color:#777777;">A. adbce                   B. decab                C. debac                    D. abcde </span> 
   </div> 
   <div> 
    <span style="color:#777777;">4.</span> 
    <span style="color:#777777;">某二叉树的后序遍历序列与中序遍历序列相同，均为</span> 
    <span style="color:#777777;"> ABCDEF ，则按层次输出（同一层从左到右）的序列</span> 
    <span style="color:#777777;">为(A)</span> 
    <div> 
     <span style="color:#777777;">A. FEDCBA </span> 
    </div> 
    <div> 
     <span style="color:#777777;">B. CBAFED </span> 
    </div> 
    <div> 
     <span style="color:#777777;">C. DEFCBA </span> 
    </div> 
    <div> 
     <span style="color:#777777;">D. ABCDEF</span> 
    </div> 
    <div></div> 
    <h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fe/a9/7wlzlXsi_o.jpg"></h3> 
    <h3><span style="color:#777777;">结束语</span></h3> 
    <blockquote> 
     <div> 
      <span style="color:#38d8f0;"><strong>好了，本节内容到此结束了，主要对二叉树的遍历有了新的认识理解，下一节小编将介绍二叉树的相关计算操作。</strong></span> 
     </div> 
     <div> 
      <span style="color:#38d8f0;"><strong>最后感谢友友们的支持，动下手指给小编点点赞，发个评论吧！！！</strong></span> 
     </div> 
    </blockquote> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3fb0f36c32c1610cf0205e418ea5a6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Could not install Gradle distribution from ‘https://services.gradle.org/distributions/gradle-8.7-bin</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce536c9c27d72125a818c7b472afc3e8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python】搭建属于自己 AI 机器人</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>