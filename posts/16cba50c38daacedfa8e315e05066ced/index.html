<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring Boot】Spring AOP中的环绕通知 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/16cba50c38daacedfa8e315e05066ced/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Spring Boot】Spring AOP中的环绕通知">
  <meta property="og:description" content="目录 一、什么是AOP?二、AOP 的环绕通知2.1 切点以及切点表达式2.2 连接点2.3 通知（Advice）2.4 切面(Aspect)2.5 不同通知类型的区别2.5.1 正常情况下2.5.2异常情况下 2.6 统一管理切点@PointCut 一、什么是AOP? Aspect Oriented Programming（面向切面编程）
AOP是Spring框架的第⼆⼤核⼼(第⼀⼤核⼼是IoC)
AOP是一种思想，是对某一类事情的集中处理。
其中在下面的学习中我们会学习到拦截器、统一异常处理，统一结果处理等，这些都是运用了AOP的统一思想来实现的。
拦截器实现AOP思想作用的维度是前端对后端进行的一次请求和一次响应，主要是检索前端传来的URL，如果检索后返回True，则可以进入Controller开始执行代码，如果返回的为False，则表示失败，直接被拦截在外面，无法执行代码。
统一结果处理则是使用注解@ControllerAdvice(通知类注解)，实现ResponseBodyAdvice接口，对响应的结果进行统一处理，对齐进行统一的包装后响应，其中如果数据类型为String类型的话要进行特殊处理，使用ObjectMapper的方法将String格式转为Json格式再次响应。
统一异常处理也是使用注解@ControllerAdvice(通知类注解)，以及在方法上使用@ExceptionHandler注解，在全部的程序中如果遇到运行时异常则会自动捕捉，进行抛出，注：编译时异常是写代码过程中出现的，不手动解决就无法运行程序。
接下来我们要学习的是运用了AOP思想，进行AOP的环绕处理
二、AOP 的环绕通知 2.1 切点以及切点表达式 切点=通知类型&#43;切点表达式
切点表示了为该方法提供一组规则，来对程序进行功能增强
通知类型有以下5种：
@Around:环绕通知,此注解标注的通知方法在目标方法前,后都被执行
@Before:前置通知,此注解标注的通知方法在目标方法前被执行
@After:后置通知,此注解标注的通知方法在目标方法后被执行,⽆论是否有异常都会执行
@AfterReturning:返回后通知,此注解标注的通知方法在目标方法后被执行,有异常不会执行
@AfterThrowing:异常后通知,此注解标注的通知方法发⽣异常后执行
如下图所示：
在该方法上的@Around,表示的是环绕处理，是一种通知类型
其后面的execution(* com.example.demo.controller..(…)) 表示的是该通知类型作用的范围，是切点表达式
2.2 连接点 满足切点表达式规则的方法就是连接点
在该图中，public recordTime方法就是连接点
2.3 通知（Advice） 通知就是具体要做的内容，简单来说就是方法内执行的代码内容
如图所示：
该图中标红的位置就是通知内容，在AOP面向切面编程当中,我们把这部分重复的代码逻辑抽取出来单独定义,这部分代码就是通知的内容
2.4 切面(Aspect) 首先使用注解@Aspect来表示该类是一个切面类
然后使用不同的通知类型进行处理,如图表示的是环绕通知类型
在处理过程中ProceedingJoinPoint.proceed()让原始方法执行
切面(Aspect)=切点(Pointcut)&#43;通知(Advice)
以下代码表示一个完整的切面类:
import lombok.extern.slf4j.Slf4j; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.stereotype.Component; @Slf4j @Aspect @Component public class TimeAspect { /** * 记录方法耗时 */ @Around(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-02T18:22:34+08:00">
    <meta property="article:modified_time" content="2024-07-02T18:22:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring Boot】Spring AOP中的环绕通知</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#AOP_2" rel="nofollow">一、什么是AOP?</a></li><li><a href="#AOP__17" rel="nofollow">二、AOP 的环绕通知</a></li><li><ul><li><a href="#21__18" rel="nofollow">2.1 切点以及切点表达式</a></li><li><a href="#22__34" rel="nofollow">2.2 连接点</a></li><li><a href="#23_Advice_38" rel="nofollow">2.3 通知（Advice）</a></li><li><a href="#24_Aspect_44" rel="nofollow">2.4 切面(Aspect)</a></li><li><a href="#25__85" rel="nofollow">2.5 不同通知类型的区别</a></li><li><ul><li><a href="#251__86" rel="nofollow">2.5.1 正常情况下</a></li><li><a href="#252_90" rel="nofollow">2.5.2异常情况下</a></li></ul> 
    </li><li><a href="#26___PointCut_103" rel="nofollow">2.6 统一管理切点@PointCut</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="AOP_2"></a>一、什么是AOP?</h3> 
<p>Aspect Oriented Programming（面向切面编程）</p> 
<p>AOP是Spring框架的第⼆⼤核⼼(第⼀⼤核⼼是IoC)</p> 
<p>AOP是一种思想，是对某一类事情的集中处理。<br> 其中在下面的学习中我们会学习到拦截器、统一异常处理，统一结果处理等，这些都是运用了AOP的统一思想来实现的。</p> 
<p>拦截器实现AOP思想作用的维度是前端对后端进行的一次请求和一次响应，主要是检索前端传来的URL，如果检索后返回True，则可以进入Controller开始执行代码，如果返回的为False，则表示失败，直接被拦截在外面，无法执行代码。</p> 
<p>统一结果处理则是使用注解@ControllerAdvice(通知类注解)，实现ResponseBodyAdvice接口，对响应的结果进行统一处理，对齐进行统一的包装后响应，其中如果数据类型为String类型的话要进行特殊处理，使用ObjectMapper的方法将String格式转为Json格式再次响应。</p> 
<p>统一异常处理也是使用注解@ControllerAdvice(通知类注解)，以及在方法上使用@ExceptionHandler注解，在全部的程序中如果遇到运行时异常则会自动捕捉，进行抛出，注：编译时异常是写代码过程中出现的，不手动解决就无法运行程序。</p> 
<p>接下来我们要学习的是运用了AOP思想，进行AOP的环绕处理</p> 
<h3><a id="AOP__17"></a>二、AOP 的环绕通知</h3> 
<h4><a id="21__18"></a>2.1 切点以及切点表达式</h4> 
<p>切点=通知类型+切点表达式<br> 切点表示了为该方法提供一组规则，来对程序进行功能增强</p> 
<p>通知类型有以下5种：</p> 
<blockquote> 
 <p><strong>@Around:环绕通知,此注解标注的通知方法在目标方法前,后都被执行</strong><br> <strong>@Before:前置通知,此注解标注的通知方法在目标方法前被执行<br> @After:后置通知,此注解标注的通知方法在目标方法后被执行,⽆论是否有异常都会执行<br> @AfterReturning:返回后通知,此注解标注的通知方法在目标方法后被执行,有异常不会执行<br> @AfterThrowing:异常后通知,此注解标注的通知方法发⽣异常后执行</strong></p> 
</blockquote> 
<p>如下图所示：<br> <img src="https://images2.imgbox.com/93/d8/roddeo5e_o.png" alt="在这里插入图片描述"><br> 在该方法上的@Around,表示的是环绕处理，是一种通知类型<br> 其后面的execution(* com.example.demo.controller.<em>.</em>(…)) 表示的是该通知类型作用的范围，是切点表达式</p> 
<h4><a id="22__34"></a>2.2 连接点</h4> 
<p>满足切点表达式规则的方法就是连接点<br> <img src="https://images2.imgbox.com/cd/08/d3yutVJf_o.png" alt="在这里插入图片描述"><br> 在该图中，public recordTime方法就是连接点</p> 
<h4><a id="23_Advice_38"></a>2.3 通知（Advice）</h4> 
<p>通知就是具体要做的内容，简单来说就是方法内执行的代码内容</p> 
<p>如图所示：<br> <img src="https://images2.imgbox.com/92/c2/oV4lrXmN_o.png" alt="在这里插入图片描述"><br> 该图中标红的位置就是通知内容，在AOP面向切面编程当中,我们把这部分重复的代码逻辑抽取出来单独定义,这部分代码就是通知的内容</p> 
<h4><a id="24_Aspect_44"></a>2.4 切面(Aspect)</h4> 
<p>首先使用注解@Aspect来表示该类是一个切面类<br> 然后使用不同的通知类型进行处理,如图表示的是环绕通知类型<br> 在处理过程中ProceedingJoinPoint.proceed()让原始方法执行<br> <img src="https://images2.imgbox.com/a2/e6/DehiFIu1_o.png" alt="在这里插入图片描述"><br> 切面(Aspect)=切点(Pointcut)+通知(Advice)<br> 以下代码表示一个完整的切面类:</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span></span><span class="token class-name">Slf4j</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">ProceedingJoinPoint</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Around</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Aspect</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimeAspect</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">/**
	* 记录方法耗时
	*/</span>
	<span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.demo.controller.*.*(..))"</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">recordTime</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//记录方法执行开始时间</span>
		<span class="token keyword">long</span> begin <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">//执行原始方法</span>
		<span class="token class-name">Object</span> result <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">//记录方法执行结束时间</span>
		<span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">//记录方法执行耗时</span>
		log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>pjp<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行耗时: {}ms"</span><span class="token punctuation">,</span> end <span class="token operator">-</span> begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="25__85"></a>2.5 不同通知类型的区别</h4> 
<h5><a id="251__86"></a>2.5.1 正常情况下</h5> 
<p>环绕通知 @Around 标识的通知方法包含两部分,⼀个"前置逻辑",⼀个"后置逻辑".其<br> 中"前置逻辑"会先于 @Before 标识的通知方法执行,"后置逻辑"会晚于 @After 标识的通知方法执行<br> <img src="https://images2.imgbox.com/02/7b/HEZkNekm_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="252_90"></a>2.5.2异常情况下</h5> 
<p>程序发⽣异常的情况下：<br> • @AfterReturning 标识的通知方法不会执行， @AfterThrowing 标识的通知方法执行了<br> • @Around 环绕通知中原始方法调⽤时有异常，通知中的环绕后的代码逻辑也不会在执行了(因为<br> 原始方法调⽤出异常了)<br> <img src="https://images2.imgbox.com/a9/c5/D37dL97x_o.png" alt="在这里插入图片描述"><br> 注意事项:<br> • @Around 环绕通知需要调⽤ ProceedingJoinPoint.proceed() 来让原始方法执行,其他<br> 通知不需要考虑目标方法执行.<br> • @Around 环绕通知方法的返回值,必须指定为Object,来接收原始方法的返回值,否则原始方法执<br> 行完毕,是获取不到返回值的.<br> • ⼀个切面类可以有多个切点</p> 
<h4><a id="26___PointCut_103"></a>2.6 统一管理切点@PointCut</h4> 
<p>统一管理切点就是对于复杂的切点表达式进行提取，然后用@PointCut注解方法进行单独声明，再本类下面的程序中如果用到该切点表达式，则直接使用注解后的方法即可，如果在其他类中使用该声明过后的切点表达式则需要使用全路径限定名+该方法即可</p> 
<p>本类使用注解后的切点表达式代码如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AspectDemo</span> <span class="token punctuation">{<!-- --></span>

		<span class="token comment">//定义切点(公共的切点表达式)</span>
		<span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.demo.controller.*.*(..))"</span><span class="token punctuation">)</span>
		<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
		
		<span class="token comment">//前置通知</span>
		<span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//...代码省略</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">//后置通知</span>
		<span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//...代码省略</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">//返回后通知</span>
		<span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfterReturning</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//...代码省略</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">//抛出异常后通知</span>
		<span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfterThrowing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//...代码省略</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">//添加环绕通知</span>
		<span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pt()"</span><span class="token punctuation">)</span>
		<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//...代码省略</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在其他类中调用该切点表达式代码如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>

	<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AspectDemo2</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//前置通知</span>
		<span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"com.example.demo.aspect.AspectDemo.pt()"</span><span class="token punctuation">)</span>
		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"执行 AspectDemo2 -&gt; Before 方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span>```

当切点定义使⽤<span class="token keyword">private</span>修饰时<span class="token punctuation">,</span>仅能在当前切面类中使⽤<span class="token punctuation">,</span>当其他切面类也要使⽤当前切点定义时<span class="token punctuation">,</span>就需要把<span class="token keyword">private</span>改为<span class="token keyword">public</span><span class="token punctuation">.</span>引⽤方式为<span class="token operator">:</span>全限定类名<span class="token punctuation">.</span>方法名<span class="token punctuation">(</span><span class="token punctuation">)</span>
### <span class="token number">2.7</span>     切面优先级<span class="token annotation punctuation">@Order</span>
在切面类中会有多个切点同时匹配成功，那么该如何进行执行顺序呢？
应该使用注解<span class="token annotation punctuation">@Order</span>（数字）来表示优先级顺序

<span class="token annotation punctuation">@Order</span>注解标识的切面类<span class="token punctuation">,</span>执行顺序如下<span class="token operator">:</span>
• <span class="token annotation punctuation">@Before</span> 通知：数字越⼩先执行
• <span class="token annotation punctuation">@After</span> 通知：数字越⼤先执行

<span class="token annotation punctuation">@Order</span> 控制切面的优先级<span class="token punctuation">,</span>先执行优先级较⾼的切面<span class="token punctuation">,</span>再执行优先级较低的切面<span class="token punctuation">,</span>最终执行目标方法<span class="token punctuation">.</span>


</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7db943813b37e6121e453959ee7340a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络物理隔离</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4b45a03ddfe425de0a6880d62fe72da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL】mysql访问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>