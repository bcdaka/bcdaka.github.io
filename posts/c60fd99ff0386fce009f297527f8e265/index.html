<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android中Room数据库的基本使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c60fd99ff0386fce009f297527f8e265/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="android中Room数据库的基本使用">
  <meta property="og:description" content="还在使用原生的sqllite？有这么清爽且稳如狗的room为啥不用呢？
Room是Google官方推荐使用的数据库，相比较某些优秀数据库框架来说，不用过于担心某天库会停止维护，且访问数据库非常流畅，并且提供了与常规的ORM框架一样，通过添加编译期注解来进行表和字段的配置，譬如@Database、@Dao、@Entity、@Query、@Insert、@Update、@Detele等的注解,可以使用简单代码实现相比以前SQLite更复杂的代码的效果，这点儿有点儿类似于java世界里的mybatis。总而言之, Room功能强大，速度和稳定性不弱，还简单易用，算得上是一个优秀的数据库。
PS：
Demo以kotlin代码为例，kotlin最近刚在学O.o？java应该也是类似的。插入代码时没有看到kotlin语言选项，代码标识可能显示js，复制代码注意包名~
Demo展示效果：
架构组件：
LiveData、ViewModel 和 Room
LiveData：一种可监测的数据存储器类。务必保存/缓存最新版本的数据，并在数据发生变化时通知其监测者。LiveData 具有生命周期感知能力。界面组件只是监测相关数据，不会停止或恢复监测。LiveData 将自动管理所有这些操作，因为它在监测时可以感知相关的生命周期状态变化。ViewModel：充当存储库（数据）和界面之间的通信中心。对于界面而言，数据来源不再是一个需要关注的问题。ViewModel 实例在重新创建 activity/fragment 后仍然存在。存储库：您创建的类，主要用于管理多个数据源。实体：使用 Room 时用于描述数据库表的带注解的类。Room 数据库：可简化数据库工作，并充当 SQLite 底层数据库的接入点（隐藏 SQLiteOpenHelper)。它使用 DAO 向 SQLite 数据库发出查询请求。SQLite 数据库：设备上的存储空间。Room 持久性库会为您创建和维护此数据库。DAO：数据访问对象。从 SQL 查询到函数的映射。在使用 DAO 时，您需要调用相应方法，其余操作均由 Room 完成。 依赖添加：
在app(应用模块)下的build.gradle(app)中添加
apply plugin: &#39;kotlin-kapt&#39; dependencies { // ... 省略无关 // room implementation &#34;androidx.room:room-runtime:$rootProject.roomVersion&#34; implementation &#34;androidx.room:room-ktx:$rootProject.roomVersion&#34; kapt &#34;androidx.room:room-compiler:$rootProject.roomVersion&#34; androidTestImplementation &#34;androidx.room:room-testing:$rootProject.roomVersion&#34; } 在项目下的build.gradle(project)中添加
ext { roomVersion = &#39;2.1.0-alpha06&#39; //... 省略无关 } 项目结构：
使用步骤：
1.创建entity
创建一个Kotlin类，用于表示数据库中的一个表，表名为&#34;word_table&#34;。
import androidx.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T06:25:46+08:00">
    <meta property="article:modified_time" content="2024-05-13T06:25:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android中Room数据库的基本使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>还在使用原生的sqllite？有这么清爽且稳如狗的room为啥不用呢？</p> 
<p>Room是Google官方推荐使用的数据库，相比较某些优秀数据库框架来说，不用过于担心某天库会停止维护，且访问数据库非常流畅，并且提供了与常规的ORM框架一样，通过添加编译期注解来进行表和字段的配置，譬如@Database、@Dao、@Entity、@Query、@Insert、@Update、@Detele等的注解,可以使用简单代码实现相比以前SQLite更复杂的代码的效果，这点儿有点儿类似于java世界里的mybatis。总而言之, Room功能强大，速度和稳定性不弱，还简单易用，算得上是一个优秀的数据库。</p> 
<p><strong>PS：</strong></p> 
<p>Demo以kotlin代码为例，kotlin最近刚在学O.o？java应该也是类似的。插入代码时没有看到kotlin语言选项，代码标识可能显示js，复制代码注意包名~</p> 
<p><strong>Demo展示效果：</strong></p> 
<table><tbody><tr><td colspan="1" rowspan="1"> <p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/e5/b2/LGxXI6nv_o.png" width="534"></p> </td><td colspan="1" rowspan="1"> <p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/ab/c0/MuccGZUC_o.png" width="534"></p> </td><td colspan="1" rowspan="1"> <p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/32/34/bcQRsQhU_o.png" width="534"></p> </td></tr></tbody></table> 
<p></p> 
<p><strong>架构组件：</strong></p> 
<p>LiveData、ViewModel 和 Room</p> 
<p></p> 
<p class="img-center"><img alt="" height="362" src="https://images2.imgbox.com/2e/a0/3hAUi1I7_o.png" width="624"></p> 
<p></p> 
<ul><li>LiveData：一种可监测的数据存储器类。务必保存/缓存最新版本的数据，并在数据发生变化时通知其监测者。LiveData 具有生命周期感知能力。界面组件只是监测相关数据，不会停止或恢复监测。LiveData 将自动管理所有这些操作，因为它在监测时可以感知相关的生命周期状态变化。</li><li>ViewModel：充当存储库（数据）和界面之间的通信中心。对于界面而言，数据来源不再是一个需要关注的问题。ViewModel 实例在重新创建 activity/fragment 后仍然存在。</li><li>存储库：您创建的类，主要用于管理多个数据源。</li><li>实体：使用 Room 时用于描述数据库表的带注解的类。</li><li>Room 数据库：可简化数据库工作，并充当 SQLite 底层数据库的接入点（隐藏 SQLiteOpenHelper)。它使用 DAO 向 SQLite 数据库发出查询请求。</li><li>SQLite 数据库：设备上的存储空间。Room 持久性库会为您创建和维护此数据库。</li><li>DAO：数据访问对象。从 SQL 查询到函数的映射。在使用 DAO 时，您需要调用相应方法，其余操作均由 Room 完成。</li></ul> 
<p><strong>依赖添加：</strong></p> 
<p>在app(应用模块)下的build.gradle(app)中添加</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/c8/f9/mR78WcY6_o.gif" width="20"></p> 
<pre>apply plugin: 'kotlin-kapt'

dependencies {
    // ... 省略无关
    // 
room
    implementation "androidx.room:room-runtime:$rootProject.roomVersion"
    implementation "androidx.room:room-ktx:$rootProject.roomVersion"
    kapt "androidx.room:room-compiler:$rootProject.roomVersion"
    androidTestImplementation "androidx.room:room-testing:$rootProject.roomVersion"
}</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/1c/0a/MUUcUmOT_o.gif" width="20"></p> 
<p>在项目下的build.gradle(project)中添加</p> 
<pre>ext {
    roomVersion = '2.1.0-alpha06'
   //... 省略无关
}</pre> 
<p><strong>项目结构：</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="686" src="https://images2.imgbox.com/37/00/parsPqbh_o.png" width="507"></p> 
<p></p> 
<p><strong>使用步骤：</strong></p> 
<p>1.创建entity</p> 
<p>创建一个Kotlin类，用于表示数据库中的一个表，表名为"word_table"。</p> 
<pre>import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "word_table")
class Word(@PrimaryKey @ColumnInfo(name = "word") val word: String)</pre> 
<p>@Entity(tableName = "word_table"): 这是一个注解，用于标识这个Kotlin类是一个Room数据库实体。tableName参数指定了在数据库中对应的表名为"word_table"。Room是一个Android持久性库，用于简化数据库访问，并在编译时进行SQL查询验证。</p> 
<p>class Word: 这是一个Kotlin类的声明，类名为Word，用于表示数据库中的一个条目。通常，一个Entity类会映射到数据库中的一张表，每个实例则代表表中的一行数据。</p> 
<p>@PrimaryKey @ColumnInfo(name = "word") val word: String: 这是Word类的一个属性，表示数据库表中的一个列。这个属性被@PrimaryKey注解标记，表示它是表中的主键。主键是唯一标识数据库表中每一行的字段。@ColumnInfo(name = "word")指定了这个属性在数据库表中对应的列名为"word"。val word: String定义了一个名为word的不可变属性，类型为String，用于存储单词的值。</p> 
<p>这段代码定义了一个名为Word的数据库实体类，它映射到数据库中的"word_table"表，包含一个名为"word"的主键列，用于存储单词的字符串值。</p> 
<p></p> 
<p>2.创建Dao</p> 
<p>创建一个Kotlin接口，用于定义访问数据库中word_table表的操作</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/54/98/qkX5140N_o.gif" width="20"></p> 
<pre> 1 import androidx.room.Dao
 2 import androidx.room.Insert
 3 import androidx.room.OnConflictStrategy
 4 import androidx.room.Query
 5 import com.example.roomwordsample.datac.Word
 6 import kotlinx.coroutines.flow.Flow
 7 
 8 @Dao
 9 interface WordDao {
10     @Query("select * from word_table order by word asc")
11     fun getAlphabetizedWords(): Flow&lt;List&lt;Word&gt;&gt;
12 
13     @Insert(onConflict = OnConflictStrategy.IGNORE)
14      fun insert(word:Word)
15 
16     @Query("DELETE FROM word_table")
17       fun deleteAll()
18 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/50/97/rQwxAvwH_o.gif" width="20"></p> 
<p></p> 
<p>@Dao: 这是一个注解，标识这个Kotlin接口是一个Room数据库访问对象（DAO）。DAO（Data Access Object）用于定义数据库操作的方法。</p> 
<p>interface WordDao: 这是一个Kotlin接口的声明，用于定义与单词表相关的数据库操作方法。</p> 
<p>@Query("select * from word_table order by word asc"): 这是一个注解，用于标识一个查询操作。在这里，它指定了一个SQL查询，从"word_table"表中选择所有列，并按照"word"列的升序排列。这个方法返回一个Flow&lt;List&lt;Word&gt;&gt;对象，表示查询结果以流的形式返回，其中每个元素都是一个Word对象的列表。</p> 
<p>fun getAlphabetizedWords(): Flow&lt;List&lt;Word&gt;&gt;: 这是一个抽象方法，用于执行查询操作，并返回结果。</p> 
<p>@Insert(onConflict = OnConflictStrategy.IGNORE): 这是一个注解，用于标识一个插入操作。onConflict = OnConflictStrategy.IGNORE指定了当插入的数据与现有数据发生冲突时，忽略新数据。这个方法用于将一个Word对象插入到数据库中。</p> 
<p>fun insert(word: Word): 这是一个抽象方法，用于执行插入操作。</p> 
<p>@Query("DELETE FROM word_table"): 这是一个注解，用于标识一个删除操作。它指定了一个SQL删除语句，从"word_table"表中删除所有数据。</p> 
<p>fun deleteAll(): 这是一个抽象方法，用于执行删除操作。</p> 
<p>这个接口定义了三种操作：获取按字母顺序排列的单词列表、插入单词到数据库中以及删除数据库中所有的单词。</p> 
<p></p> 
<p>3.创建RoomDatabase</p> 
<p>定义一个用于创建和管理数据库的类，主要使用了Room Persistence Library。</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/c5/fb/Zx9gKCVU_o.gif" width="20"></p> 
<pre> 1 import android.content.Context
 2 import androidx.room.Database
 3 import androidx.room.Room
 4 import androidx.room.RoomDatabase
 5 import androidx.sqlite.db.SupportSQLiteDatabase
 6 import com.example.roomwordsample.dao.WordDao
 7 import com.example.roomwordsample.datac.Word
 8 import kotlinx.coroutines.CoroutineScope
 9 import kotlinx.coroutines.launch
10 
11 @Database(entities = arrayOf(Word::class), version = 1, exportSchema = false)
12 public abstract class WordRoomDatabase :RoomDatabase(){
13     abstract fun wordDao(): WordDao
14 
15     private class WordDatabaseCallback(
16         private val scope: CoroutineScope
17     ) : RoomDatabase.Callback() {
18 
19         override fun onCreate(db: SupportSQLiteDatabase) {
20             super.onCreate(db)
21             INSTANCE?.let { database -&gt;
22                 scope.launch {
23                     populateDatabase(database.wordDao())
24                 }
25             }
26         }
27 
28         suspend fun populateDatabase(wordDao: WordDao) {
29             // Delete all content here.
30             wordDao.deleteAll()
31 
32             // Add sample words.
33             var word = Word("Hello")
34             wordDao.insert(word)
35             word = Word("World!")
36             wordDao.insert(word)
37 
38             // TODO: Add your own words!
39         }
40     }
41 
42     companion object {
43         // Singleton prevents multiple instances of database opening at the
44         // same time.
45         @Volatile
46         private var INSTANCE: WordRoomDatabase? = null
47 
48         fun getDatabase(
49             context: Context,
50             scope: CoroutineScope
51         ): WordRoomDatabase  {
52             return INSTANCE ?: synchronized(this) {
53                 val instance = Room.databaseBuilder(
54                     context.applicationContext,
55                     WordRoomDatabase::class.java,
56                     "word_database"
57                 )
58                 .addCallback(WordDatabaseCallback(scope))
59                 .allowMainThreadQueries()
60                 .build()
61                 INSTANCE = instance
62                 // return instance
63                 instance
64             }
65         }
66     }
67 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/c8/6e/Zqvny8fz_o.gif" width="20"></p> 
<p>@Database(entities = arrayOf(Word::class), version = 1, exportSchema = false): 这是一个注解，用于标识这个类是一个Room数据库类。entities参数指定了数据库中的实体类，这里只有一个Word类。version参数指定了数据库的版本号，如果你更新了数据库结构，需要增加版本号以执行相应的数据库迁移。exportSchema参数指定是否导出数据库的schema到文件中，这里设置为false表示不导出。</p> 
<p>public abstract class WordRoomDatabase : RoomDatabase(): 这是一个抽象类，继承自RoomDatabase类，用于定义数据库操作。它包含了一个抽象方法wordDao()，用于获取WordDao接口的实例。</p> 
<p>private class WordDatabaseCallback(...) : RoomDatabase.Callback() {...}: 这是一个内部类，继承自RoomDatabase.Callback类，用于在数据库被创建时执行一些操作。在这个例子中，它在数据库创建时调用了populateDatabase()方法，用于初始化数据库。</p> 
<p>companion object {...}: 这是一个伴生对象，包含了一些静态方法和属性。其中INSTANCE是一个WordRoomDatabase的单例实例，使用了双重校验锁来确保线程安全。</p> 
<p>fun getDatabase(...): 这是一个静态方法，用于获取数据库实例。如果实例为空，则创建一个新的数据库实例，并在创建时调用WordDatabaseCallback来初始化数据库。</p> 
<p>populateDatabase(wordDao: WordDao): 这是一个挂起函数，用于在数据库创建时初始化数据库内容。在这个例子中，它删除了数据库中的所有内容，然后插入了两个示例单词"Hello"和"World!"，你也可以添加自己的单词。</p> 
<p>这个类负责创建和管理数据库，定义了数据库的版本、实体、以及初始化操作。</p> 
<p></p> 
<p>4.创建Repository</p> 
<p>创建一个简单的Repository类，用于连接ViewModel和DAO（Data Access Object）。</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/ff/b2/Ddbf1dX4_o.gif" width="20"></p> 
<pre> 1 import androidx.annotation.WorkerThread
 2 import com.example.roomwordsample.dao.WordDao
 3 import com.example.roomwordsample.datac.Word
 4 import kotlinx.coroutines.flow.Flow
 5 
 6 class  WordRepository(private val wordDao: WordDao){
 7 
 8     val allWords: Flow&lt;List&lt;Word&gt;&gt; = wordDao.getAlphabetizedWords()
 9 
10     @Suppress("RedundantSuspendModifier")
11     @WorkerThread
12     suspend fun insert(word: Word) {
13         wordDao.insert(word)
14     }
15 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/a6/69/s5ic727l_o.gif" width="20"></p> 
<p>import语句: 这些是导入所需的类和包，包括androidx.annotation.WorkerThread、com.example.roomwordsample.dao.WordDao、com.example.roomwordsample.data.Word和kotlinx.coroutines.flow.Flow。这些类用于定义数据流以及DAO接口。</p> 
<p>class WordRepository(private val wordDao: WordDao): 这是一个Kotlin类的声明，表示WordRepository类。它包含一个私有属性wordDao，类型为WordDao，用于对数据库进行操作。</p> 
<p>val allWords: Flow&lt;List&lt;Word&gt;&gt; = wordDao.getAlphabetizedWords(): 这是一个属性，用于获取从数据库中获取的所有单词。它是一个Flow&lt;List&lt;Word&gt;&gt;类型的属性，表示这是一个数据流，可以观察到数据库中单词列表的变化。</p> 
<p>@Suppress("RedundantSuspendModifier") @WorkerThread suspend fun insert(word: Word): 这是一个插入操作的挂起函数。@WorkerThread注解表示该函数应该在工作线程中执行，通常用于防止在主线程中执行长时间运行的操作。suspend关键字表示这是一个挂起函数，可以在协程中调用。</p> 
<p>wordDao.insert(word): 这是调用WordDao接口的插入方法，将单词插入到数据库中。</p> 
<p>这个Repository类负责从DAO获取数据，并暴露一个数据流以供ViewModel观察。它还包含一个方法用于在数据库中插入新的单词。</p> 
<p></p> 
<p>5.创建ViewModel</p> 
<p> 定义了一个ViewModel类（WordViewModel）以及一个用于创建ViewModel实例的工厂类（WordViewModelFactory）。</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/30/3a/AjBdnERg_o.gif" width="20"></p> 
<pre> 1 import androidx.lifecycle.LiveData
 2 import androidx.lifecycle.ViewModel
 3 import androidx.lifecycle.ViewModelProvider
 4 import androidx.lifecycle.asLiveData
 5 import androidx.lifecycle.viewModelScope
 6 import com.example.roomwordsample.datac.Word
 7 import com.example.roomwordsample.repository.WordRepository
 8 import kotlinx.coroutines.launch
 9 
10 class WordViewModel(private val repository: WordRepository) : ViewModel() {
11 
12     val allWords: LiveData&lt;List&lt;Word&gt;&gt; = repository.allWords.asLiveData()
13 
14     /**
15      * Launching a new coroutine to insert the data in a non-blocking way
16      */
17     fun insert(word: Word) = viewModelScope.launch {
18         repository.insert(word)
19     }
20 }
21 
22 class WordViewModelFactory(private val repository: WordRepository) : ViewModelProvider.Factory {
23     override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {
24         if (modelClass.isAssignableFrom(WordViewModel::class.java)) {
25             @Suppress("UNCHECKED_CAST")
26             return WordViewModel(repository) as T
27         }
28         throw IllegalArgumentException("Unknown ViewModel class")
29     }
30 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/3d/4f/5lf2qg84_o.gif" width="20"></p> 
<p>class WordViewModel(private val repository: WordRepository) : ViewModel() {...}:</p> 
<p>WordViewModel是一个ViewModel类，用于管理与单词相关的数据和用户界面状态。<br> 它有一个名为repository的私有属性，类型为WordRepository，用于与数据层交互。<br> allWords是一个LiveData对象，用于保存从数据层获取的所有单词列表。通过调用repository.allWords.asLiveData()，将数据流转换为LiveData对象，以便在UI层观察数据变化。<br> insert是一个公共方法，用于向数据层插入新的单词。它启动一个新的协程（coroutine），在非阻塞的方式下执行插入操作。</p> 
<p><br> class WordViewModelFactory(private val repository: WordRepository) : ViewModelProvider.Factory {...}:</p> 
<p>WordViewModelFactory是一个用于创建WordViewModel实例的工厂类。<br> 它实现了ViewModelProvider.Factory接口，并重写了create方法。<br> 在create方法中，它首先检查所请求的ViewModel类是否是WordViewModel，如果是，则返回一个新的WordViewModel实例，否则抛出一个IllegalArgumentException异常。<br> 这些类的组合使得在应用程序中可以方便地管理与单词相关的UI逻辑和数据。ViewModel类负责从数据层获取数据，并在需要时将其提供给UI层。ViewModelFactory类负责实例化ViewModel类，并确保每个ViewModel都具有正确的依赖项。</p> 
<p></p> 
<p>6.创建Adapter</p> 
<p>创建一个RecyclerView的适配器类（WordListAdapter），用于将数据绑定到RecyclerView中的列表项。</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/ed/81/FkbBP4UV_o.gif" width="20"></p> 
<pre> 1 import android.view.LayoutInflater
 2 import android.view.View
 3 import android.view.ViewGroup
 4 import android.widget.TextView
 5 import androidx.recyclerview.widget.DiffUtil
 6 import androidx.recyclerview.widget.ListAdapter
 7 import androidx.recyclerview.widget.RecyclerView
 8 import com.example.roomwordsample.R
 9 import com.example.roomwordsample.datac.Word
10 
11 class WordListAdapter : ListAdapter&lt;Word, WordListAdapter.WordViewHolder&gt;(WordsComparator()) {
12     override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): WordViewHolder {
13         return WordViewHolder.create(parent)
14     }
15 
16     override fun onBindViewHolder(holder: WordViewHolder, position: Int) {
17         val current = getItem(position)
18         holder.bind(current.word)
19     }
20     class WordViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
21         private val wordItemView: TextView = itemView.findViewById(R.id.textView)
22 
23         fun bind(text: String?) {
24             wordItemView.text = text
25         }
26 
27         companion object {
28             fun create(parent: ViewGroup): WordViewHolder {
29                 val view: View = LayoutInflater.from(parent.context)
30                     .inflate(R.layout.recyclerview_item, parent, false)
31                 return WordViewHolder(view)
32             }
33         }
34     }
35 
36     class WordsComparator : DiffUtil.ItemCallback&lt;Word&gt;() {
37         override fun areItemsTheSame(oldItem: Word, newItem: Word): Boolean {
38             return oldItem === newItem
39         }
40 
41         override fun areContentsTheSame(oldItem: Word, newItem: Word): Boolean {
42             return oldItem.word == newItem.word
43         }
44     }
45 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/98/2d/ZCm7I8iT_o.gif" width="20"></p> 
<p>class WordListAdapter : ListAdapter&lt;Word, WordListAdapter.WordViewHolder&gt;(WordsComparator()) {...}:</p> 
<p>WordListAdapter继承自ListAdapter类，并指定了泛型参数，第一个参数是数据项的类型（Word），第二个参数是ViewHolder的类型（WordViewHolder），并传入了一个用于比较数据项的WordsComparator对象。<br> ListAdapter是RecyclerView的一个辅助类，用于处理列表数据的更新和差异计算。<br> onCreateViewHolder:</p> 
<p>onCreateViewHolder方法用于创建ViewHolder对象。在这里，它调用了WordViewHolder的create方法来创建ViewHolder。<br> onBindViewHolder:</p> 
<p>onBindViewHolder方法用于绑定数据到ViewHolder上。在这里，它获取当前位置的数据项，然后调用ViewHolder的bind方法将数据绑定到UI上。<br> class WordViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {...}:</p> 
<p>WordViewHolder是一个内部类，继承自RecyclerView.ViewHolder类，用于管理列表项的视图。<br> 它包含一个私有属性wordItemView，类型为TextView，用于显示单词。<br> bind方法:</p> 
<p>bind方法用于将数据绑定到ViewHolder上。在这里，它接收一个字符串参数，并将其设置到wordItemView的文本属性上。<br> create方法:</p> 
<p>create方法用于创建ViewHolder实例。在这里，它使用LayoutInflater从指定的布局文件（recyclerview_item.xml）中创建一个View对象，并将其传递给ViewHolder的构造函数。<br> WordsComparator类:</p> 
<p>WordsComparator是一个内部类，继承自DiffUtil.ItemCallback&lt;Word&gt;类，用于比较两个数据项。<br> areItemsTheSame方法用于判断两个数据项是否代表同一个对象。<br> areContentsTheSame方法用于判断两个数据项的内容是否相同。<br> 这个适配器类负责管理RecyclerView的列表项，包括创建ViewHolder、绑定数据以及比较数据项的差异。</p> 
<p>7.创建MainActivity</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/7c/23/I1LD2Lwh_o.gif" width="20"></p> 
<pre> 1 import android.app.Activity
 2 import android.content.Intent
 3 import android.os.Bundle
 4 import android.widget.Toast
 5 import androidx.activity.viewModels
 6 import androidx.appcompat.app.AppCompatActivity
 7 import androidx.lifecycle.Observer
 8 import androidx.recyclerview.widget.LinearLayoutManager
 9 import androidx.recyclerview.widget.RecyclerView
10 import com.example.roomwordsample.adapter.WordListAdapter
11 import com.example.roomwordsample.datac.Word
12 import com.example.roomwordsample.vm.WordViewModel
13 import com.example.roomwordsample.vm.WordViewModelFactory
14 import com.google.android.material.floatingactionbutton.FloatingActionButton
15 
16 
17 class MainActivity : AppCompatActivity() {
18     private val newWordActivityRequestCode = 1
19 
20     private val wordViewModel: WordViewModel by viewModels {
21         WordViewModelFactory((application as WordsApplication).repository)
22     }
23 
24     override fun onCreate(savedInstanceState: Bundle?) {
25         super.onCreate(savedInstanceState)
26         setContentView(R.layout.activity_main)
27         val recyclerView = findViewById&lt;RecyclerView&gt;(R.id.recyclerview)
28         val adapter = WordListAdapter()
29         recyclerView.adapter = adapter
30         recyclerView.layoutManager = LinearLayoutManager(this)
31         wordViewModel.allWords.observe(this, Observer { words -&gt;
32             words?.let { adapter.submitList(it) }
33         })
34         val fab = findViewById&lt;FloatingActionButton&gt;(R.id.fab)
35         fab.setOnClickListener {
36             val intent = Intent(this@MainActivity, NewWordActivity::class.java)
37             startActivityForResult(intent, newWordActivityRequestCode)
38         }
39     }
40     override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
41         super.onActivityResult(requestCode, resultCode, data)
42 
43         if (requestCode == newWordActivityRequestCode &amp;&amp; resultCode == Activity.RESULT_OK) {
44             data?.getStringExtra(NewWordActivity.EXTRA_REPLY)?.let {
45                 val word = Word(it)
46                 wordViewModel.insert(word)
47             }
48         } else {
49             Toast.makeText(
50                 applicationContext,
51                 R.string.empty_not_saved,
52                 Toast.LENGTH_LONG).show()
53         }
54     }
55 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/8e/af/fj56McVA_o.gif" width="20"></p> 
<p></p> 
<p>8.创建NewWordActivity</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/2e/77/zVlbPcEU_o.gif" width="20"></p> 
<pre> 1 import android.app.Activity
 2 import android.content.Intent
 3 import android.os.Bundle
 4 import android.text.TextUtils
 5 import android.widget.Button
 6 import android.widget.EditText
 7 import androidx.appcompat.app.AppCompatActivity
 8 
 9 class NewWordActivity : AppCompatActivity() {
10     private lateinit var editWordView:EditText
11 
12     override fun onCreate(savedInstanceState: Bundle?) {
13         super.onCreate(savedInstanceState)
14         setContentView(R.layout.activity_new_word)
15         editWordView = findViewById(R.id.edit_word)
16         val button = findViewById&lt;Button&gt;(R.id.button_save)
17         button.setOnClickListener {
18             val replyIntent = Intent()
19             if (TextUtils.isEmpty(editWordView.text)) {
20                 setResult(Activity.RESULT_CANCELED, replyIntent)
21             } else {
22                 val word = editWordView.text.toString()
23                 replyIntent.putExtra(EXTRA_REPLY, word)
24                 setResult(Activity.RESULT_OK, replyIntent)
25             }
26             finish()
27         }
28     }
29     companion object{
30         const val EXTRA_REPLY = "com.example.android.wordlistsql.REPLY"
31     }
32 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/2d/84/9CW8oHiT_o.gif" width="20"></p> 
<p></p> 
<p>9.创建WordsApplication</p> 
<p>创建一个名为WordsApplication的自定义Application类，用于初始化应用程序的全局状态。</p> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/db/7b/Z9ngu2ZV_o.gif" width="20"></p> 
<pre> 1 import android.app.Application
 2 import com.example.roomwordsample.repository.WordRepository
 3 import com.example.roomwordsample.room.WordRoomDatabase
 4 import kotlinx.coroutines.CoroutineScope
 5 import kotlinx.coroutines.SupervisorJob
 6 
 7 class WordsApplication:Application() {
 8     val applicationScope = CoroutineScope(SupervisorJob())
 9     val database by lazy { WordRoomDatabase.getDatabase(this,applicationScope) }
10     val repository by lazy { WordRepository(database.wordDao()) }
11 }</pre> 
<p></p> 
<p class="img-center"><img alt="复制代码" height="20" src="https://images2.imgbox.com/c4/54/XQd6I7Or_o.gif" width="20"></p> 
<p>class WordsApplication : Application() {...}:</p> 
<p>WordsApplication类继承自Android的Application类，表示一个应用程序级别的全局状态。<br> val applicationScope = CoroutineScope(SupervisorJob()):</p> 
<p>applicationScope是一个CoroutineScope对象，用于管理应用程序范围内的协程。它使用了SupervisorJob，表示在子协程出现异常时，不会影响其他子协程的执行。<br> val database by lazy { WordRoomDatabase.getDatabase(this, applicationScope) }:</p> 
<p>database是一个延迟初始化的属性，使用了懒加载机制。它通过调用WordRoomDatabase.getDatabase()方法来获取应用程序的数据库实例。这个数据库实例是单例的，并且会在第一次访问时被初始化。<br> val repository by lazy { WordRepository(database.wordDao()) }:</p> 
<p>repository也是一个延迟初始化的属性，使用了懒加载机制。它通过调用WordRepository类的构造函数来创建一个单词仓库的实例。这个仓库实例会将数据库实例传递给其构造函数，以便它可以与数据库进行交互。<br> WordsApplication类负责创建应用程序的全局状态，包括数据库实例和单词仓库实例。这些实例可以在应用程序的任何地方使用，以便进行数据存储和检索操作。</p> 
<p></p> 
<p><strong>查看room数据库文件</strong></p> 
<p>room数据库本质上就是对SQlite的一个封装，类似于java中的mybatis框架，对SQLiteOpenHelper类进行了一些封装，简化了数据库的操作。</p> 
<p>简单来说：Room是一个基于SQLite的强大数据库框架。</p> 
<p>在AndroidManifest.xml清单文件中添加权限</p> 
<pre>1     &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
2     &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</pre> 
<p>导出并使用SQLiteStudio软件打开，其他数据库管理工具也可以</p> 
<p>SQLiteStudio下载链接：<a href="https://sqlitestudio.pl/" rel="nofollow" title="SQLiteStudio">SQLiteStudio</a></p> 
<p> 在AndroidStudio中打开Device Explorer(设备浏览器)</p> 
<p></p> 
<p class="img-center"><img alt="" height="267" src="https://images2.imgbox.com/71/27/rbqRUrOS_o.png" width="608"></p> 
<p> 文件后缀为.db或.sqlite都可以，这里我直接将三个文件(二进制文件)导出</p> 
<p>使用SQLite打开界面</p> 
<p></p> 
<p class="img-center"><img alt="" height="454" src="https://images2.imgbox.com/d2/50/0giDibH2_o.png" width="1014"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/820545d0e466a3abb86286fb2608de7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一文实现Llama 3 图片理解能力微调（XTuner&#43;LLaVA 版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9029cd34226fd16779efd665c79348bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ZooKeeper【部署 01】单机版安装&#43;配置&#43;添加到service服务&#43;开机启动配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>