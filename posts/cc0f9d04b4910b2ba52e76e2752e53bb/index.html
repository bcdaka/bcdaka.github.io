<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python魔法之旅-魔法方法(04) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cc0f9d04b4910b2ba52e76e2752e53bb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python魔法之旅-魔法方法(04)">
  <meta property="og:description" content="目录
一、概述
1、定义
2、作用
二、主要应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
14、__enter__方法
14-1、语法
14-2、参数
14-3、功能
14-4、返回值
14-5、说明
14-6、用法
15、__eq__方法
15-1、语法
15-2、参数
15-3、功能
15-4、返回值
15-5、说明
15-6、用法
16、__exit__方法
16-1、语法
16-2、参数
16-3、功能
16-4、返回值
16-5、说明
16-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、主要应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-30T19:20:25+08:00">
    <meta property="article:modified_time" content="2024-05-30T19:20:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python魔法之旅-魔法方法(04)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><span style="color:#1a439c;"><strong>目录</strong></span></p> 
<p id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><strong><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow"><span style="color:#1a439c;">一、概述</span></a></strong></p> 
<p id="1%E3%80%81%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E5%AE%9A%E4%B9%89" rel="nofollow"><span style="color:#1a439c;">1、定义</span></a></strong></p> 
<p id="2%E3%80%81%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E4%BD%9C%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">2、作用</span></a></strong></p> 
<p id="%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow"><span style="color:#1a439c;">二、主要应用场景</span></a></strong></p> 
<p id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84" rel="nofollow"><span style="color:#1a439c;">1、构造和析构</span></a></strong></p> 
<p id="2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow"><span style="color:#1a439c;">2、操作符重载</span></a></strong></p> 
<p id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA" rel="nofollow"><span style="color:#1a439c;">3、字符串和表示</span></a></strong></p> 
<p id="4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86" rel="nofollow"><span style="color:#1a439c;">4、容器管理</span></a></strong></p> 
<p id="5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><strong><a href="#5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1" rel="nofollow"><span style="color:#1a439c;">5、可调用对象</span></a></strong></p> 
<p id="6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><strong><a href="#6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86" rel="nofollow"><span style="color:#1a439c;">6、上下文管理</span></a></strong></p> 
<p id="7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6-toc" style="margin-left:80px;"><strong><a href="#7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6" rel="nofollow"><span style="color:#1a439c;">7、属性访问和描述符</span></a></strong></p> 
<p id="8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8-toc" style="margin-left:80px;"><strong><a href="#8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8" rel="nofollow"><span style="color:#1a439c;">8、迭代器和生成器</span></a></strong></p> 
<p id="9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><strong><a href="#9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B" rel="nofollow"><span style="color:#1a439c;">9、数值类型</span></a></strong></p> 
<p id="10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96-toc" style="margin-left:80px;"><strong><a href="#10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96" rel="nofollow"><span style="color:#1a439c;">10、复制和序列化</span></a></strong></p> 
<p id="11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA-toc" style="margin-left:80px;"><strong><a href="#11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA" rel="nofollow"><span style="color:#1a439c;">11、自定义元类行为</span></a></strong></p> 
<p id="12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA-toc" style="margin-left:80px;"><strong><a href="#12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA" rel="nofollow"><span style="color:#1a439c;">12、自定义类行为</span></a></strong></p> 
<p id="13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><strong><a href="#13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2" rel="nofollow"><span style="color:#1a439c;">13、类型检查和转换</span></a></strong></p> 
<p id="14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><strong><a href="#14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8" rel="nofollow"><span style="color:#1a439c;">14、自定义异常</span></a></strong></p> 
<p id="%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">三、学习方法</span></a></strong></p> 
<p id="1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80" rel="nofollow"><span style="color:#1a439c;">1、理解基础</span></a></strong></p> 
<p id="2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3" rel="nofollow"><span style="color:#1a439c;">2、查阅文档</span></a></strong></p> 
<p id="3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">3、编写示例</span></a></strong></p> 
<p id="4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">4、实践应用</span></a></strong></p> 
<p id="5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><strong><a href="#5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81" rel="nofollow"><span style="color:#1a439c;">5、阅读他人代码</span></a></strong></p> 
<p id="6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA-toc" style="margin-left:80px;"><strong><a href="#6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA" rel="nofollow"><span style="color:#1a439c;">6、参加社区讨论</span></a></strong></p> 
<p id="7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0-toc" style="margin-left:80px;"><strong><a href="#7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0" rel="nofollow"><span style="color:#1a439c;">7、持续学习</span></a></strong></p> 
<p id="8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><strong><a href="#8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93" rel="nofollow"><span style="color:#1a439c;">8、练习与总结</span></a></strong></p> 
<p id="9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:80px;"><strong><a href="#9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow"><span style="color:#1a439c;">9、注意兼容性</span></a></strong></p> 
<p id="10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">10、避免过度使用</span></a></strong></p> 
<p id="%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><strong><a href="#%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">四、魔法方法</span></a></strong></p> 
<p id="1%E3%80%81__abs__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81__abs__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">14、__enter__方法</span></a></strong></p> 
<p id="1-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#1-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">14-1、语法</span></a></strong></p> 
<p id="1-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#1-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">14-2、参数</span></a></strong></p> 
<p id="1-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#1-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">14-3、功能</span></a></strong></p> 
<p id="1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">14-4、返回值</span></a></strong></p> 
<p id="1-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#1-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">14-5、说明</span></a></strong></p> 
<p id="1-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#1-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">14-6、用法</span></a></strong></p> 
<p id="2%E3%80%81__add__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81__add__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">15、__eq__方法</span></a></strong></p> 
<p id="17-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#17-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">15-1、语法</span></a></strong></p> 
<p id="17-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#17-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">15-2、参数</span></a></strong></p> 
<p id="17-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#17-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">15-3、功能</span></a></strong></p> 
<p id="17-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#17-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">15-4、返回值</span></a></strong></p> 
<p id="17-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#17-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">15-5、说明</span></a></strong></p> 
<p id="17-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#17-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">15-6、用法</span></a></strong></p> 
<p id="16%E3%80%81__exit__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#16%E3%80%81__exit__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">16、__exit__方法</span></a></strong></p> 
<p id="18-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#18-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">16-1、语法</span></a></strong></p> 
<p id="18-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#18-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">16-2、参数</span></a></strong></p> 
<p id="18-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#18-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">16-3、功能</span></a></strong></p> 
<p id="18-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#18-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">16-4、返回值</span></a></strong></p> 
<p id="18-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#18-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">16-5、说明</span></a></strong></p> 
<p id="18-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#18-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">16-6、用法</span></a></strong></p> 
<p id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-toc" style="margin-left:40px;"><strong><a href="#%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" rel="nofollow"><span style="color:#1a439c;">五、推荐阅读</span></a></strong></p> 
<p id="1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">1、Python筑基之旅</span></a></strong></p> 
<p id="2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">2、Python函数之旅</span></a></strong></p> 
<p id="3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">3、Python算法之旅</span></a></strong></p> 
<p id="4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5" rel="nofollow"><span style="color:#1a439c;">4、博客个人主页</span></a></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/b2/46M8q2gb_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c6/70/Y7YyfyXg_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/f6/ahImWXzs_o.gif"></p> 
<h3 id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0">一、概述</h3> 
<h4 id="1%E3%80%81%E5%AE%9A%E4%B9%89">1、定义</h4> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span><span style="color:#956fe7;"><strong>(Magic Methods/Special Methods，</strong></span><span style="color:#fe2c24;"><strong>也称特殊方法或双下划线方法</strong></span><span style="color:#956fe7;"><strong>)</strong></span>是Python中<span style="color:#fe2c24;"><strong>一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾</strong></span>。</p> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span>用于在特定情况下<span style="color:#fe2c24;"><strong>自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，</strong></span>让你可以定义自定义类时具有与内置类型相似的行为。</p> 
<h4 id="2%E3%80%81%E4%BD%9C%E7%94%A8">2、作用</h4> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span>允许开发者<span style="color:#fe2c24;"><strong>重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能</strong>。</span></p> 
<h3 id="%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">二、主要应用场景</h3> 
<h4 id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84">1、构造和析构</h4> 
<p>1-1、__init__(self, [args...])：在创建对象时初始化属性。<br> 1-2、__new__(cls, [args...])：在创建对象时控制实例的创建过程(通常与元类一起使用)。<br> 1-3、__del__(self)：在对象被销毁前执行清理操作，如关闭文件或释放资源。</p> 
<h4 id="2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD">2、操作符重载</h4> 
<p>2-1、__add__(self, other)、__sub__(self, other)、__mul__(self, other)等：自定义对象之间的算术运算。<br> 2-2、__eq__(self, other)、__ne__(self, other)、__lt__(self, other)等：定义对象之间的比较操作。</p> 
<h4 id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA">3、字符串和表示</h4> 
<p>3-1、__str__(self)：定义对象的字符串表示，常用于print()函数。<br> 3-2、__repr__(self)：定义对象的官方字符串表示，用于repr()函数和交互式解释器。</p> 
<h4 id="4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86">4、容器管理</h4> 
<p>4-1、__getitem__(self, key)、__setitem__(self, key, value)、__delitem__(self, key)：用于实现类似列表或字典的索引访问、设置和删除操作。<br> 4-2、__len__(self)：返回对象的长度或元素个数。</p> 
<h4 id="5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1">5、可调用对象</h4> 
<p>5-1、__call__(self, [args...])：允许对象像函数一样被调用。</p> 
<h4 id="6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86">6、上下文管理</h4> 
<p>6-1、__enter__(self)、__exit__(self, exc_type, exc_val, exc_tb)：用于实现上下文管理器，如with语句中的对象。</p> 
<h4 id="7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6">7、属性访问和描述符</h4> 
<p>7-1、__getattr__, __setattr__, __delattr__：这些方法允许对象在访问或修改不存在的属性时执行自定义操作。<br> 7-2、描述符(Descriptors)是实现了__get__, __set__, 和__delete__方法的对象，它们可以控制对另一个对象属性的访问。</p> 
<h4 id="8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8">8、迭代器和生成器</h4> 
<p>8-1、__iter__和__next__：这些方法允许对象支持迭代操作，如使用for循环遍历对象。<br> 8-2、__aiter__, __anext__：这些是异步迭代器的魔法方法，用于支持异步迭代。</p> 
<h4 id="9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">9、数值类型</h4> 
<p>9-1、__int__(self)、__float__(self)、__complex__(self)：定义对象到数值类型的转换。<br> 9-2、__index__(self)：定义对象用于切片时的整数转换。</p> 
<h4 id="10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96">10、复制和序列化</h4> 
<p>10-1、__copy__和__deepcopy__：允许对象支持浅复制和深复制操作。<br> 10-2、__getstate__和__setstate__：用于自定义对象的序列化和反序列化过程。</p> 
<h4 id="11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA">11、自定义元类行为</h4> 
<p>11-1、__metaclass__(Python 2)或元类本身(Python 3)：允许自定义类的创建过程，如动态创建类、修改类的定义等。</p> 
<h4 id="12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA">12、自定义类行为</h4> 
<p>12-1、__init__和__new__：用于初始化对象或控制对象的创建过程。<br> 12-2、__init_subclass__：在子类被创建时调用，允许在子类中执行一些额外的操作。</p> 
<h4 id="13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2">13、类型检查和转换</h4> 
<p>13-1、__instancecheck__和__subclasscheck__：用于自定义isinstance()和issubclass()函数的行为。</p> 
<h4 id="14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">14、自定义异常</h4> 
<p>14-1、你可以通过继承内置的Exception类来创建自定义的异常类，并定义其特定的行为。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/30/0b/cYP94E2J_o.png"></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95">三、学习方法</h3> 
<p>        要学好Python的魔法方法，你可以遵循以下方法及步骤：</p> 
<h4 id="1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80">1、理解基础</h4> 
<p>        首先确保你对Python的基本语法、数据类型、类和对象等概念有深入的理解，这些是理解魔法方法的基础。</p> 
<h4 id="2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3">2、查阅文档</h4> 
<p>        仔细阅读Python官方文档中关于魔法方法的部分，文档会详细解释每个魔法方法的作用、参数和返回值。你可以通过访问Python的官方网站或使用help()函数在Python解释器中查看文档。</p> 
<h4 id="3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B">3、编写示例</h4> 
<p>        为每个魔法方法编写简单的示例代码，以便更好地理解其用法和效果，通过实际编写和运行代码，你可以更直观地感受到魔法方法如何改变对象的行为。</p> 
<h4 id="4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8">4、实践应用</h4> 
<p>        在实际项目中尝试使用魔法方法。如，你可以创建一个自定义的集合类，使用__getitem__、__setitem__和__delitem__方法来实现索引操作。只有通过实践应用，你才能更深入地理解魔法方法的用途和重要性。</p> 
<h4 id="5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81">5、阅读他人代码</h4> 
<p>        阅读开源项目或他人编写的代码，特别是那些使用了魔法方法的代码，这可以帮助你学习如何在实际项目中使用魔法方法。通过分析他人代码中的魔法方法使用方式，你可以学习到一些新的技巧和最佳实践。</p> 
<h4 id="6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA">6、参加社区讨论</h4> 
<p>        参与Python社区的讨论，与其他开发者交流关于魔法方法的使用经验和技巧，在社区中提问或回答关于魔法方法的问题，这可以帮助你更深入地理解魔法方法并发现新的应用场景。</p> 
<h4 id="7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0">7、持续学习</h4> 
<p>        Python语言和其生态系统不断发展，新的魔法方法和功能可能会不断被引入，保持对Python社区的关注，及时学习新的魔法方法和最佳实践。</p> 
<h4 id="8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93">8、练习与总结</h4> 
<p>        多做练习，通过编写各种使用魔法方法的代码来巩固你的理解，定期总结你学到的知识和经验，形成自己的知识体系。</p> 
<h4 id="9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7">9、注意兼容性</h4> 
<p>        在使用魔法方法时，要注意不同Python版本之间的兼容性差异，确保你的代码在不同版本的Python中都能正常工作。</p> 
<h4 id="10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8">10、避免过度使用</h4> 
<p>        虽然魔法方法非常强大，但过度使用可能会导致代码难以理解和维护，在编写代码时，要权衡使用魔法方法的利弊，避免滥用。</p> 
<p>        总之，学好Python的魔法方法需要不断地学习、实践和总结，只有通过不断地练习和积累经验，你才能更好地掌握这些强大的工具，并在实际项目中灵活运用它们。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/da/4fOUafjT_o.png"></p> 
<h3 id="%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">四、魔法方法</h3> 
<h4 id="1%E3%80%81__abs__%E6%96%B9%E6%B3%95">14、__enter__方法</h4> 
<h5 id="1-1%E3%80%81%E8%AF%AD%E6%B3%95">14-1、语法</h5> 
<pre><code class="language-python">__enter__(self)
    return self # 可以返回任何对象，或者简单地返回self</code></pre> 
<h5 id="1-2%E3%80%81%E5%8F%82%E6%95%B0">14-2、参数</h5> 
<p><span style="color:#fe2c24;"><strong>14-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<h5 id="1-3%E3%80%81%E5%8A%9F%E8%83%BD">14-3、功能</h5> 
<p>        用于在进入一个由with语句控制的代码块时执行特定的操作。</p> 
<h5 id="1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">14-4、返回值</h5> 
<p>        在with语句块开始执行时调用，并通常返回一个对象。</p> 
<h5 id="1-5%E3%80%81%E8%AF%B4%E6%98%8E">14-5、说明</h5> 
<p>        在Python的官方文档中，<code>__</code>enter<code>__</code> 方法是不接受任何参数的。但是，如果你真的看到了带有参数的 __enter__ 方法，那可能是某个特定库或框架的扩展用法，或者可能是对该方法的误用。</p> 
<h5 id="1-6%E3%80%81%E7%94%A8%E6%B3%95">14-6、用法</h5> 
<pre><code class="language-python"># 014、__enter__方法：
# 1、文件操作
# 定义一个名为 FileContextManager 的类，用于管理文件的上下文
class FileContextManager:
    # 初始化方法，接收一个文件名作为参数
    def __init__(self, filename):
        # 将传入的文件名保存到实例变量 filename 中
        self.filename = filename
    # 定义 __enter__ 方法，用于 with 语句执行时进入上下文时调用
    def __enter__(self):
        # 使用实例变量 filename 打开文件，并设置文件模式为只读 ('r')
        self.file = open(self.filename, 'r')
        # 返回打开的文件对象，以便在 with 语句的 as 子句中引用
        return self.file
    # 定义 __exit__ 方法，用于 with 语句执行完毕后退出上下文时调用
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 关闭之前打开的文件对象
        self.file.close()
 # 使用 with 语句和 FileContextManager 类来管理文件操作
# 'test.txt' 是要打开的文件名，'file' 是打开文件后在 with 语句内部使用的引用名
with FileContextManager('test.txt') as file:
    # 读取文件内容并打印，假设文件内容是 "Hello, World!"
    print(file.read())  # 输出：Hello, World!

# 2、数据库连接
# 假设有一个数据库连接库（但在这里我们只是模拟它）
class DatabaseContext:
    # 定义一个上下文管理器的进入方法
    def __enter__(self):
        # 当使用 with 语句进入上下文时，该方法会被调用
        # 这里只是一个示例，实际中会使用数据库连接库来建立真实的数据库连接
        print("Connecting to database...")
        # 假设我们有一个模拟的数据库连接字符串
        self.connection = "Mock Database Connection"
        # 返回连接对象（或连接字符串），以便在 with 语句的 as 子句中引用
        return self.connection
    # 定义一个上下文管理器的退出方法
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 当 with 语句块结束时，无论是否发生异常，该方法都会被调用
        print("Closing database connection...")
        # 在这里，我们只是打印了一条消息，但在真实情况下，你会关闭数据库连接
# 使用 with 语句和 DatabaseContext 类来管理数据库连接的上下文
with DatabaseContext() as db:
    # 在这里使用数据库连接（这里只是打印了一条消息）
    # 假设 db 是一个数据库连接对象，但在本例中它只是一个字符串
    print("Using database:", db)
    # 当 with 语句块结束时，__exit__ 方法会被自动调用，打印 "Closing database connection..."

# 3、临时目录
# 导入tempfile模块，用于创建临时文件和目录
import tempfile
# 导入shutil模块，用于删除目录及其内容
import shutil
# 定义一个名为TempDirContext的上下文管理类
class TempDirContext:
    # 定义__enter__方法，当使用with语句进入上下文时调用
    def __enter__(self):
        # 使用tempfile.mkdtemp()方法创建一个临时目录
        self.temp_dir = tempfile.mkdtemp()
        # 打印创建的临时目录的路径
        print(f"Created temp directory: {self.temp_dir}")
        # 返回临时目录的路径，以便在with语句的as子句中引用
        return self.temp_dir
     # 定义__exit__方法，当with语句块结束时调用
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 打印将要删除的临时目录的路径
        print(f"Deleting temp directory: {self.temp_dir}")
        # 使用shutil.rmtree()方法删除临时目录及其所有内容
        shutil.rmtree(self.temp_dir)
# 使用with语句和TempDirContext类来管理临时目录的上下文
with TempDirContext() as temp_dir:
    # 打印正在使用的临时目录的路径
    print(f"Using temp directory: {temp_dir}")
    # 在这里可以使用temp_dir变量来引用临时目录，并执行相关操作
    # 例如：在临时目录中创建文件、写入数据等
    # 注意：由于此代码片段是一个注释示例，所以没有包含实际的文件操作

# 4、锁机制
# 导入threading模块，用于多线程操作
import threading
# 定义一个名为ThreadLock的类，用于管理线程锁
class ThreadLock:
    # 初始化方法，创建一个threading.Lock对象
    def __init__(self):
        self.lock = threading.Lock()
    # 定义__enter__方法，当使用with语句进入上下文时调用
    def __enter__(self):
        # 尝试获取锁
        self.lock.acquire()
        # 打印锁已被获取的消息
        print("Acquired lock")
        # 返回锁对象（虽然通常不需要返回，但这里为了示例还是返回了）
        return self.lock
    # 定义__exit__方法，当with语句块结束时调用
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 释放锁
        self.lock.release()
        # 打印锁已被释放的消息
        print("Released lock")
# 使用with语句和ThreadLock类来管理线程锁
with ThreadLock() as lock:
    # 在这里进行线程安全的操作
    # 注意：因为with语句已经处理了锁的获取和释放，所以这里的lock变量其实不需要使用
    # 除非你想在with块内部检查锁的状态或做其他与锁相关的操作
    pass

# 5、设置和恢复环境变量
# 定义一个名为EnvVarContext的上下文管理器类，用于临时修改环境变量
class EnvVarContext:
    def __init__(self, var_name, new_value):
        # 初始化时接收环境变量名和新值
        self.var_name = var_name  # 存储要修改的环境变量名
        self.new_value = new_value  # 存储新的环境变量值
        self.old_value = None  # 用于存储原始的环境变量值
    def __enter__(self):
        # 当使用with语句进入上下文时调用
        # 获取环境变量原来的值
        self.old_value = os.environ.get(self.var_name)
        # 设置新的环境变量值
        os.environ[self.var_name] = self.new_value
        # 打印已设置新的环境变量值
        print(f"Set {self.var_name} to {self.new_value}")
        # 因为with语句的as子句没有使用变量来接收返回值，所以这里不需要返回具体的值
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 当with语句块结束时调用
        # 恢复环境变量为原来的值
        if self.old_value is not None:
            # 如果原值存在，则恢复为原值
            os.environ[self.var_name] = self.old_value
        else:
            # 如果原值不存在，则从环境变量中删除该变量
            del os.environ[self.var_name]
            # 打印环境变量已恢复为原始值或已删除
        print(f"Restored {self.var_name} to its original value")
# 导入os模块，以便操作环境变量
import os
# 使用with语句和EnvVarContext类来修改环境变量
with EnvVarContext('MY_VAR', 'new_value') as _:
    # 在with块内部，MY_VAR的值已被临时修改为'new_value'
    print(os.environ['MY_VAR'])  # 输出: new_value
# 退出with块后，MY_VAR被恢复为原来的值或删除
# 之后的代码可以确认MY_VAR的值是否已被恢复

# 6、模拟上下文状态管理
class MyContextManager:
    def __enter__(self):
        print("Entering the context")
        # 在这里，你可以设置任何进入上下文时需要的状态或资源
        # 例如，打开一个文件、获取一个锁等
        self.resource = "some resource"  # 假设这是一个需要管理的资源
        return self  # 通常，__enter__ 应该返回一个对象，以便在 with 块中使用
    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting the context")
        # 在这里，你可以执行任何清理工作，例如关闭文件、释放锁等
        # 你可以检查 exc_type, exc_value, traceback 来确定是否发生了异常
        # 如果发生了异常并且你想重新抛出它，则不应该在这里进行任何操作
        # 如果你想忽略异常，你可以在这里返回 True
        # 如果你想在退出时总是执行一些清理代码，无论是否发生异常，你可以将这里留空
# 使用 with 语句和上下文管理器
with MyContextManager() as manager:
    print("Inside the with block, accessing resource:", manager.resource)
    # 这里是代码块，当执行到这里时，__enter__ 已经被调用
    # 当这个代码块执行完毕（或者发生异常）时，__exit__ 将会被调用</code></pre> 
<h4 id="2%E3%80%81__add__%E6%96%B9%E6%B3%95">15、__eq__方法</h4> 
<h5 id="17-1%E3%80%81%E8%AF%AD%E6%B3%95">15-1、语法</h5> 
<pre><code class="language-python">__eq__(self, other, /)
    Return self==other</code></pre> 
<h5 id="17-2%E3%80%81%E5%8F%82%E6%95%B0">15-2、参数</h5> 
<p><strong><span style="color:#fe2c24;">15-2-1、self</span><span style="color:#956fe7;">(必须)</span><span style="color:#fe2c24;">：</span></strong>表示调用该方法的对象本身。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-2、other</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>表示与self进行相等性比较操作的对象。</p> 
<p><span style="color:#fe2c24;"><strong>15-2-3、/</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>这是从Python 3.8开始引入的参数注解语法，它表示这个方法不接受任何位置参数(positional-only parameters)之后的关键字参数(keyword arguments)。</p> 
<h5 id="17-3%E3%80%81%E5%8A%9F%E8%83%BD">15-3、功能</h5> 
<p>        用于定义对象之间的相等性比较。</p> 
<h5 id="17-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">15-4、返回值</h5> 
<p>        返回一个布尔值(True或False)，表示两个对象是否相等。</p> 
<h5 id="17-5%E3%80%81%E8%AF%B4%E6%98%8E">15-5、说明</h5> 
<p>        当你使用<code>==</code>运算符来比较两个对象是否相等时，Python会尝试调用这两个对象的<code>__<font face="-apple-system, SF UI Text, Arial, PingFang SC, Hiragino Sans GB, Microsoft YaHei, WenQuanYi Micro Hei, sans-serif, SimHei, SimSun">eq</font></code><code>__</code>方法(如果它们定义了的话)。</p> 
<h5 id="17-6%E3%80%81%E7%94%A8%E6%B3%95">15-6、用法</h5> 
<pre><code class="language-python"># 015、__eq__方法：
# 1、简单的数值类
# 定义一个名为Number的类，用于封装数值
class Number:
    # 类的初始化方法，当创建Number类的实例时调用
    def __init__(self, value):
        # 给实例对象添加一个属性value，并赋值为传入的参数value
        self.value = value
    # 类的相等性比较方法，用于比较两个Number对象是否相等
    def __eq__(self, other):
        # 检查other是否是Number类的实例
        if isinstance(other, Number):
            # 如果是，则比较两个Number对象的value属性是否相等
            return self.value == other.value
            # 如果other不是Number类的实例，则直接返回False
        return False
# 当这个脚本作为主程序运行时，以下代码会被执行
if __name__ == '__main__':
    # 创建两个Number对象，它们的value属性都是5
    num1 = Number(5)
    num2 = Number(5)
    # 创建一个Number对象，它的value属性是10
    num3 = Number(10)
    # 使用==操作符比较num1和num2是否相等，并打印结果（注释说明预期输出为True）
    print(num1 == num2)  # 输出: True
    # 使用==操作符比较num1和num3是否相等，并打印结果（注释说明预期输出为False）
    print(num1 == num3)  # 输出: False

# 2、点类(二维坐标)
# 定义一个名为Point的类，用于表示二维平面上的点
class Point:
    # 初始化方法，当创建Point类的实例时调用
    def __init__(self, x, y):
        # 设置点的x坐标
        self.x = x
        # 设置点的y坐标
        self.y = y
    # 相等性比较方法，用于比较两个Point对象是否相等
    def __eq__(self, other):
        # 检查other是否也是Point类的实例
        if isinstance(other, Point):
            # 如果是，则比较两个点的x和y坐标是否都相等
            return self.x == other.x and self.y == other.y
            # 如果other不是Point类的实例，则返回False
        return False
# 当这个脚本作为主程序运行时，以下代码会被执行
if __name__ == '__main__':
    # 创建一个Point对象p1，其x坐标为1，y坐标为2
    p1 = Point(1, 2)
    # 创建一个Point对象p2，其x坐标为1，y坐标为2（与p1相同）
    p2 = Point(1, 2)
    # 创建一个Point对象p3，其x坐标为2，y坐标为2（与p1不同）
    p3 = Point(2, 2)
    # 使用==操作符比较p1和p2是否相等，并打印结果（注释说明预期输出为True）
    print(p1 == p2)  # 输出: True
    # 使用==操作符比较p1和p3是否相等，并打印结果（注释说明预期输出为False）
    print(p1 == p3)  # 输出: False

# 3、字符串封装类
# 定义一个名为StringWrapper的类，用于封装字符串  
class StringWrapper:
    # 初始化方法，当创建StringWrapper类的实例时调用  
    def __init__(self, text):
        # 给实例对象添加一个属性text，并赋值为传入的参数text  
        self.text = text
    # 相等性比较方法，用于比较两个StringWrapper对象是否相等  
    def __eq__(self, other):
        # 检查other是否也是StringWrapper类的实例  
        if isinstance(other, StringWrapper):
            # 如果是，则比较两个StringWrapper对象的text属性是否相等  
            return self.text == other.text
        # 如果other不是StringWrapper类的实例，则返回False  
        return False
# 当这个脚本作为主程序运行时，以下代码会被执行  
if __name__ == '__main__':
    # 创建一个StringWrapper对象s1，封装字符串"hello"  
    s1 = StringWrapper("hello")
    # 创建一个StringWrapper对象s2，封装字符串"hello"（与s1相同）  
    s2 = StringWrapper("hello")
    # 创建一个StringWrapper对象s3，封装字符串"world"（与s1不同）  
    s3 = StringWrapper("world")
    # 使用==操作符比较s1和s2是否相等，并打印结果（注释说明预期输出为True）  
    print(s1 == s2)  # 输出: True  
    # 使用==操作符比较s1和s3是否相等，并打印结果（注释说明预期输出为False）  
    print(s1 == s3)  # 输出: False

# 4、用户类(只比较用户名)
# 定义一个名为 User 的类，表示用户信息
class User:
    # 初始化方法，当创建 User 类的实例时会被调用
    def __init__(self, username, age):
        # 设置实例属性 username，存储用户名
        self.username = username
        # 设置实例属性 age，存储年龄
        self.age = age
    # 重写 __eq__ 方法，用于比较两个 User 实例是否相等
    # 这里的相等定义为：如果两个 User 实例的 username 属性相等，则它们相等
    def __eq__(self, other):
        # 检查 other 是否是 User 类的实例
        if isinstance(other, User):
            # 如果 other 是 User 类的实例，则比较两者的 username 属性
            return self.username == other.username
            # 如果 other 不是 User 类的实例，则返回 False
        return False
# 如果当前脚本作为主程序运行（而不是被导入为模块）
if __name__ == '__main__':
    # 创建一个 User 实例，用户名为 "Myelsa"，年龄为 18
    user1 = User("Myelsa", 18)
    # 创建一个 User 实例，用户名为 "Myelsa"，年龄为 28
    user2 = User("Myelsa", 28)
    # 创建一个 User 实例，用户名为 "Jimmy"，年龄为 15
    user3 = User("Jimmy", 15)
    # 使用 __eq__ 方法比较 user1 和 user2 是否相等，并打印结果
    # 因为它们的 username 相等，所以输出为 True
    print(user1 == user2)  # 输出: True
    # 使用 __eq__ 方法比较 user1 和 user3 是否相等，并打印结果
    # 因为它们的 username 不相等，所以输出为 False
    print(user1 == user3)  # 输出: False

# 5、列表包装类(考虑顺序)
# 定义一个名为ListWrapper的类，用于包装列表
class ListWrapper:
    # 类的初始化方法，用于设置items属性
    def __init__(self, items):
        # items属性存储传入的列表
        self.items = items
    # 类的相等性比较方法，用于判断两个ListWrapper对象是否相等
    def __eq__(self, other):
        # 检查other是否是ListWrapper的实例
        if isinstance(other, ListWrapper):
            # 如果是，则比较两个ListWrapper对象的items属性是否相等
            # 这里使用了Python列表的相等性比较，即元素相同且顺序也相同
            return self.items == other.items
        # 如果other不是ListWrapper的实例，则返回False
        return False
# 如果当前脚本作为主程序运行（而不是被导入）
if __name__ == '__main__':
    # 创建三个ListWrapper对象，分别包装不同的列表
    lst1 = ListWrapper([1, 2, 3])  # 第一个ListWrapper对象，包装了列表[1, 2, 3]
    lst2 = ListWrapper([2, 1, 3])  # 第二个ListWrapper对象，包装了列表[2, 1, 3]，与lst1元素相同但顺序不同
    lst3 = ListWrapper([1, 2, 3])  # 第三个ListWrapper对象，包装了列表[1, 2, 3]，与lst1完全相同
    # 使用Python内置的相等性比较来比较lst1和lst2
    # 因为lst1和lst2的items属性（即包装的列表）元素相同但顺序不同，所以不相等
    print(lst1 == lst2)  # 输出：False
    # 使用Python内置的相等性比较来比较lst1和lst3
    # 因为lst1和lst3的items属性（即包装的列表）完全相同，所以相等
    print(lst1 == lst3)  # 输出：True

# 6、日期类(考虑年、月、日)
# 导入Python内置的date类，该类用于处理日期
from datetime import date
# 定义一个名为CustomDate的类，用于封装日期功能
class CustomDate:
    # 类的初始化方法，用于创建CustomDate对象时设置日期
    def __init__(self, year, month, day):
        # 使用Python内置的date类来创建一个日期对象，并将其存储在self.date属性中
        self.date = date(year, month, day)
    # 类的相等性比较方法，用于判断两个CustomDate对象是否相等
    def __eq__(self, other):
        # 检查other是否是CustomDate的实例
        if isinstance(other, CustomDate):
            # 如果是，则比较两个CustomDate对象的date属性是否相等
            # 这里使用了Python内置的date类的相等性比较
            return self.date == other.date
        # 如果other不是CustomDate的实例，则返回False
        return False
# 如果当前脚本作为主程序运行（而不是被导入）
if __name__ == '__main__':
    # 创建三个CustomDate对象，分别表示不同的日期
    date_1 = CustomDate(2024, 10, 24)  # 第一个CustomDate对象，表示2024年10月24日
    date_2 = CustomDate(2024, 10, 24)  # 第二个CustomDate对象，也表示2024年10月24日
    date_3 = CustomDate(2024, 10, 8)  # 第三个CustomDate对象，表示2024年10月8日
    # 使用Python内置的相等性比较来比较date_1和date_2
    # 因为date_1和date_2的date属性相同（都是2024年10月24日），所以相等
    print(date_1 == date_2)  # 输出：True
    # 使用Python内置的相等性比较来比较date_1和date_3
    # 因为date_1和date_3的date属性不同（分别是2024年10月24日和2024年10月8日），所以不相等
    print(date_1 == date_3)  # 输出：False</code></pre> 
<h4 id="16%E3%80%81__exit__%E6%96%B9%E6%B3%95">16、__exit__方法</h4> 
<h5 id="18-1%E3%80%81%E8%AF%AD%E6%B3%95">16-1、语法</h5> 
<pre><code class="language-python">__exit__(self, exc_type, exc_value, exc_tb)
    return True  # 或者False或不返回任何值(即None)
    # 如果要忽略异常，则返回True</code></pre> 
<h5 id="18-2%E3%80%81%E5%8F%82%E6%95%B0">16-2、参数</h5> 
<p><span style="color:#fe2c24;"><strong>16-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<p><span style="color:#fe2c24;"><strong>16-2-2、exc_type</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>异常类型，如果在with块中引发了异常，则此参数是异常的类型；否则</p> 
<p>为None。</p> 
<p><strong><span style="color:#fe2c24;">16-2-3、exc_value</span><span style="color:#956fe7;">(可选)</span><span style="color:#fe2c24;">：</span></strong>异常值，即with块中引发的异常的实例；如果未引发异常则为None。</p> 
<p><strong><span style="color:#fe2c24;">16-2-4、exc_tb</span><span style="color:#956fe7;">(可选)</span><span style="color:#fe2c24;">：</span></strong>追踪信息(traceback object)，它是一个指向引发异常位置的堆栈跟</p> 
<p>踪；如果未引发异常则为None。</p> 
<h5 id="18-3%E3%80%81%E5%8A%9F%E8%83%BD">16-3、功能</h5> 
<p>        用于在退出一个由with语句控制的代码块时执行特定的操作。</p> 
<h5 id="18-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">16-4、返回值</h5> 
<p>16-4-1、返回<code>True</code>，那么它会抑制(忽略)异常，也就是说，即使with块中的代码引发了异常，这个异常也不会被传播到with语句之外。</p> 
<p>16-4-2、返回False或不返回任何值(即None)，那么with块中引发的异常将会按照正常的异常处理机制来处理。</p> 
<h5 id="18-5%E3%80%81%E8%AF%B4%E6%98%8E">16-5、说明</h5> 
<p>        无</p> 
<h5 id="18-6%E3%80%81%E7%94%A8%E6%B3%95">16-6、用法</h5> 
<pre><code class="language-python"># 016、__exit__方法：
# 1、文件操作
# 定义一个名为 FileContextManager 的类，用于管理文件的上下文
class FileContextManager:
    # 初始化方法，接收一个文件名作为参数
    def __init__(self, filename):
        # 将传入的文件名保存到实例变量 filename 中
        self.filename = filename
    # 定义 __enter__ 方法，用于 with 语句执行时进入上下文时调用
    def __enter__(self):
        # 使用实例变量 filename 打开文件，并设置文件模式为只读 ('r')
        self.file = open(self.filename, 'r')
        # 返回打开的文件对象，以便在 with 语句的 as 子句中引用
        return self.file
    # 定义 __exit__ 方法，用于 with 语句执行完毕后退出上下文时调用
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 关闭之前打开的文件对象
        self.file.close()
 # 使用 with 语句和 FileContextManager 类来管理文件操作
# 'test.txt' 是要打开的文件名，'file' 是打开文件后在 with 语句内部使用的引用名
with FileContextManager('test.txt') as file:
    # 读取文件内容并打印，假设文件内容是 "Hello, World!"
    print(file.read())  # 输出：Hello, World!

# 2、数据库连接
# 假设有一个数据库连接库（但在这里我们只是模拟它）
class DatabaseContext:
    # 定义一个上下文管理器的进入方法
    def __enter__(self):
        # 当使用 with 语句进入上下文时，该方法会被调用
        # 这里只是一个示例，实际中会使用数据库连接库来建立真实的数据库连接
        print("Connecting to database...")
        # 假设我们有一个模拟的数据库连接字符串
        self.connection = "Mock Database Connection"
        # 返回连接对象（或连接字符串），以便在 with 语句的 as 子句中引用
        return self.connection
    # 定义一个上下文管理器的退出方法
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 当 with 语句块结束时，无论是否发生异常，该方法都会被调用
        print("Closing database connection...")
        # 在这里，我们只是打印了一条消息，但在真实情况下，你会关闭数据库连接
# 使用 with 语句和 DatabaseContext 类来管理数据库连接的上下文
with DatabaseContext() as db:
    # 在这里使用数据库连接（这里只是打印了一条消息）
    # 假设 db 是一个数据库连接对象，但在本例中它只是一个字符串
    print("Using database:", db)
    # 当 with 语句块结束时，__exit__ 方法会被自动调用，打印 "Closing database connection..."

# 3、临时目录
# 导入tempfile模块，用于创建临时文件和目录
import tempfile
# 导入shutil模块，用于删除目录及其内容
import shutil
# 定义一个名为TempDirContext的上下文管理类
class TempDirContext:
    # 定义__enter__方法，当使用with语句进入上下文时调用
    def __enter__(self):
        # 使用tempfile.mkdtemp()方法创建一个临时目录
        self.temp_dir = tempfile.mkdtemp()
        # 打印创建的临时目录的路径
        print(f"Created temp directory: {self.temp_dir}")
        # 返回临时目录的路径，以便在with语句的as子句中引用
        return self.temp_dir
     # 定义__exit__方法，当with语句块结束时调用
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 打印将要删除的临时目录的路径
        print(f"Deleting temp directory: {self.temp_dir}")
        # 使用shutil.rmtree()方法删除临时目录及其所有内容
        shutil.rmtree(self.temp_dir)
# 使用with语句和TempDirContext类来管理临时目录的上下文
with TempDirContext() as temp_dir:
    # 打印正在使用的临时目录的路径
    print(f"Using temp directory: {temp_dir}")
    # 在这里可以使用temp_dir变量来引用临时目录，并执行相关操作
    # 例如：在临时目录中创建文件、写入数据等
    # 注意：由于此代码片段是一个注释示例，所以没有包含实际的文件操作

# 4、锁机制
# 导入threading模块，用于多线程操作
import threading
# 定义一个名为ThreadLock的类，用于管理线程锁
class ThreadLock:
    # 初始化方法，创建一个threading.Lock对象
    def __init__(self):
        self.lock = threading.Lock()
    # 定义__enter__方法，当使用with语句进入上下文时调用
    def __enter__(self):
        # 尝试获取锁
        self.lock.acquire()
        # 打印锁已被获取的消息
        print("Acquired lock")
        # 返回锁对象（虽然通常不需要返回，但这里为了示例还是返回了）
        return self.lock
    # 定义__exit__方法，当with语句块结束时调用
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 释放锁
        self.lock.release()
        # 打印锁已被释放的消息
        print("Released lock")
# 使用with语句和ThreadLock类来管理线程锁
with ThreadLock() as lock:
    # 在这里进行线程安全的操作
    # 注意：因为with语句已经处理了锁的获取和释放，所以这里的lock变量其实不需要使用
    # 除非你想在with块内部检查锁的状态或做其他与锁相关的操作
    pass

# 5、设置和恢复环境变量
# 定义一个名为EnvVarContext的上下文管理器类，用于临时修改环境变量
class EnvVarContext:
    def __init__(self, var_name, new_value):
        # 初始化时接收环境变量名和新值
        self.var_name = var_name  # 存储要修改的环境变量名
        self.new_value = new_value  # 存储新的环境变量值
        self.old_value = None  # 用于存储原始的环境变量值
    def __enter__(self):
        # 当使用with语句进入上下文时调用
        # 获取环境变量原来的值
        self.old_value = os.environ.get(self.var_name)
        # 设置新的环境变量值
        os.environ[self.var_name] = self.new_value
        # 打印已设置新的环境变量值
        print(f"Set {self.var_name} to {self.new_value}")
        # 因为with语句的as子句没有使用变量来接收返回值，所以这里不需要返回具体的值
    def __exit__(self, exc_type, exc_val, exc_tb):
        # 当with语句块结束时调用
        # 恢复环境变量为原来的值
        if self.old_value is not None:
            # 如果原值存在，则恢复为原值
            os.environ[self.var_name] = self.old_value
        else:
            # 如果原值不存在，则从环境变量中删除该变量
            del os.environ[self.var_name]
            # 打印环境变量已恢复为原始值或已删除
        print(f"Restored {self.var_name} to its original value")
# 导入os模块，以便操作环境变量
import os
# 使用with语句和EnvVarContext类来修改环境变量
with EnvVarContext('MY_VAR', 'new_value') as _:
    # 在with块内部，MY_VAR的值已被临时修改为'new_value'
    print(os.environ['MY_VAR'])  # 输出: new_value
# 退出with块后，MY_VAR被恢复为原来的值或删除
# 之后的代码可以确认MY_VAR的值是否已被恢复

# 6、模拟上下文状态管理
class MyContextManager:
    def __enter__(self):
        print("Entering the context")
        # 在这里，你可以设置任何进入上下文时需要的状态或资源
        # 例如，打开一个文件、获取一个锁等
        self.resource = "some resource"  # 假设这是一个需要管理的资源
        return self  # 通常，__enter__ 应该返回一个对象，以便在 with 块中使用
    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting the context")
        # 在这里，你可以执行任何清理工作，例如关闭文件、释放锁等
        # 你可以检查 exc_type, exc_value, traceback 来确定是否发生了异常
        # 如果发生了异常并且你想重新抛出它，则不应该在这里进行任何操作
        # 如果你想忽略异常，你可以在这里返回 True
        # 如果你想在退出时总是执行一些清理代码，无论是否发生异常，你可以将这里留空
# 使用 with 语句和上下文管理器
with MyContextManager() as manager:
    print("Inside the with block, accessing resource:", manager.resource)
    # 这里是代码块，当执行到这里时，__enter__ 已经被调用
    # 当这个代码块执行完毕（或者发生异常）时，__exit__ 将会被调用</code></pre> 
<h3 id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">五、推荐阅读</h3> 
<h4 id="1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85">1、<a href="https://myelsa1024.blog.csdn.net/article/details/139241094?spm=1001.2014.3001.5502" rel="nofollow" title="Python筑基之旅">Python筑基之旅</a></h4> 
<h4 id="2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85">2、<a href="https://myelsa1024.blog.csdn.net/article/details/138916144?spm=1001.2014.3001.5502" rel="nofollow" title="Python函数之旅">Python函数之旅</a></h4> 
<h4 id="3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85">3、<a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Python算法之旅">Python算法之旅</a></h4> 
<h4 id="4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5">4、<a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="博客个人主页">博客个人主页</a></h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4539ea16db51b31121204bba10a35f79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 如何传递参数给webView的h5页面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3abe70d0fe65df709284babb591063bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pylance has crashed. Would you like to try using a Node.js executable to run the language server?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>