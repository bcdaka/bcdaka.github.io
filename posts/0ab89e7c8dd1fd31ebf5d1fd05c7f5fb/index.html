<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：二叉树与树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0ab89e7c8dd1fd31ebf5d1fd05c7f5fb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构：二叉树与树">
  <meta property="og:description" content="一 树的基本概念： 1.树的形状： 2.树的定义： 树是一种非线性的数据结构，它是n(n &gt;= 0)个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：
2.1 有且仅有一个特定的称为根的结点。
2.2 当n &gt; 1时，其余结点可分为m(m &gt; 0)个互不相交的有限集T1 ……Tm，其中每个集合本身又是一棵树，并且称为根的子树。
显然，树的定义是递归的，即在树的定义中又用到其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两点特点：
2.3 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
2.4 树中所有结点可以有零个或多个后继。
3.树中相关的关键词概念： 3.1 节点的度：一个节点含有的子树的个数称为该节点的度；如上图：A的为6
3.2 路径：树的路径是指从根节点到树内特定节点遍历的节点序列
3.3 根：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点
3.4 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；如上图：A是B的父节点
3.5 子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图：B是A的子节点
3.6 兄弟节点：具有相同父节点的节点互称为兄弟节点 如上图：I与J就是兄弟
3.7 堂兄弟节点：不是相同父亲的节点且在同一层而和相邻的称堂兄弟节点 如上图：H与I就是堂兄弟
3.8 叶节点：度为0的节点就是叶节点或者说没有孩子的节点 如上图：P和Q
3.9 分支节点：度不为0的点。列如：B、C、D、都是分支节点。
3.10 子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。
3.11 节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推。
3.12 深度 \ 高度：树中节点的最大层。如图就是4。
3.13 节点的祖先：从根到该节点的所经过分支上的所有节点，A就是所有节点的祖先。
3.14 深林：互不相交的树的集合被称为深林。
3.15 子孙：以某节点为根的子树的子树中任一节点都被称为该节点的子孙。列如所有节点都是A的子孙
4.树的性质： 4.1 树中的结点数等于所有结点的度数之和加1
4.2 度为m的树中第i层上至多有m^(i-1)个结点(i &gt;= 1)
4.3 高度为h的m叉树至多有(m^h - 1)/(m - 1)个结点">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-28T22:51:02+08:00">
    <meta property="article:modified_time" content="2024-05-28T22:51:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：二叉树与树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2>一 树的基本概念：</h2> 
<h4>1.树的形状：</h4> 
<p class="img-center"><img alt="" height="345" src="https://images2.imgbox.com/66/6d/8x8Xcqhs_o.png" width="627"></p> 
<h4>2.树的定义：</h4> 
<p>树是一种非线性的数据结构，它是n(n &gt;= 0)个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：</p> 
<p>2.1 有且仅有一个特定的称为根的结点。<br> 2.2 当n &gt; 1时，其余结点可分为m(m &gt; 0)个互不相交的有限集T1 ……Tm，其中每个集合本身又是一棵树，并且称为根的子树。<br> 显然，树的定义是递归的，即在树的定义中又用到其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两点特点：</p> 
<p>2.3 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。<br> 2.4 树中所有结点可以有零个或多个后继。</p> 
<h4>3.树中相关的关键词概念：</h4> 
<p><strong>3.1 节点的度：</strong>一个节点含有的子树的个数称为该节点的度；如上图：A的为6</p> 
<p><strong>3.2 路径</strong>：树的路径是指从根节点到树内特定节点遍历的节点序列</p> 
<p><strong>3.3 根</strong>：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点</p> 
<p><strong>3.4 父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；如上图：A是B的父节点</p> 
<p><strong>3.5 子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；如上图：B是A的子节点</p> 
<p><strong>3.6 兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点 如上图：I与J就是兄弟</p> 
<p><strong>3.7 堂兄弟节点：</strong>不是相同父亲的节点且在同一层而和相邻的称堂兄弟节点 如上图：H与I就是堂兄弟</p> 
<p><strong>3.8 叶节点</strong>：度为0的节点就是叶节点或者说没有孩子的节点 如上图：P和Q</p> 
<p><strong>3.9 分支节点：</strong>度不为0的点。列如：B、C、D、都是分支节点。</p> 
<p><strong>3.10 子树</strong>：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。</p> 
<p><strong>3.11 节点的层次</strong>：从根开始定义，根为第一层，根的子节点为第二层，以此类推。</p> 
<p><strong>3.12 深度 \ 高度</strong>：树中节点的最大层。如图就是4。</p> 
<p><strong>3.13 节点的祖先：</strong>从根到该节点的所经过分支上的所有节点，A就是所有节点的祖先。</p> 
<p><strong>3.14 深林：</strong>互不相交的树的集合被称为深林。</p> 
<p><strong>3.15 子孙：</strong>以某节点为根的子树的子树中任一节点都被称为该节点的子孙。列如所有节点都是A的子孙</p> 
<h4>4.树的性质：</h4> 
<p>4.1 树中的结点数等于所有结点的度数之和加1<br> 4.2 度为m的树中第i层上至多有m^(i-1)个结点(i &gt;= 1)<br> 4.3 高度为h的m叉树至多有(m^h - 1)/(m - 1)个结点<br> 4.4 具有n个结点的m二叉的最小高度为[logm(n(m - 1) + 1)]</p> 
<h2>二 二叉树的基本概念：</h2> 
<h4>1.二叉树的形状：</h4> 
<p><img alt="" height="1097" src="https://images2.imgbox.com/54/5d/eVidghaS_o.png" width="1200"></p> 
<h4>2.二叉树的定义：</h4> 
<p>二叉树是另一种树形结构，其特点时每个结点<span style="color:#fe2c24;">至多只能有两棵树(</span>即二叉树中不存在度大于2的结点)，并且二叉树的子树也有左右之分，其次序不能任意颠倒。</p> 
<p>与树相似，二叉树也有递归的形式定义。二叉树是n(n &gt;= 0)个结点的有限集合：</p> 
<p>2.1 或者为空二叉树，即n = 0.<br> 2.2 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组合。左子树和右子树又是分别  是一棵二叉树<br> 二叉树是<strong><span style="color:#fe2c24;">有序树</span><span style="color:#0d0016;">，</span></strong><span style="color:#0d0016;">若将其左右子树颠倒，则成为另一颗不同的二叉树。即使树中结点只有一颗子树，也要区分它是左子树还是右子树。</span></p> 
<h4>3.二叉树的性质：</h4> 
<p>3.1 非空二叉树上的叶子节点数等于度为2的结点数加1，n0 = n1 + 1<br> 3.2 非空二叉树上第k层上至多有2^(k-1)个结点(k &gt;= 1)<br> 3.3 高度为h二叉树至多有2^(h - 1)个结点(h &gt;= 1)<br> 3.4 对完全二叉树按从上到下、左到右的顺序依次编号1，2……n<br> 3.5 具有n个(n &gt; 0)结点的完全二叉树的高度为[log2(n + 1)]或[log2n] + 1</p> 
<h3>三 特殊的二叉树：</h3> 
<h4>1.满二叉树(FBT)：</h4> 
<p>1.1 所有非叶节点都拥有两个子节点。</p> 
<p>1.2 最深层的叶子节点从左到右依次排列，没有空缺。</p> 
<p>1.3 深度为 h 的完全二叉树，具有 2^h - 1 个节点。</p> 
<h4>2.完全二叉树(CBT)：</h4> 
<p>2.1 每一层都拥有最大数量的节点。</p> 
<p>2.2 深度为 k 的满二叉树，具有 2^k - 1 个节点。</p> 
<p>2.3 非叶节点都拥有两个子节点，最底层可能存在一些空缺。</p> 
<h4>3.满二叉树和完全二叉树的形状：</h4> 
<p><img alt="" height="222" src="https://images2.imgbox.com/f0/a5/QJOweQeK_o.png" width="766"></p> 
<h2>四 二叉树的存储结构：</h2> 
<h3>1.顺序存储结构：</h3> 
<p>二叉树的顺序存储是指使用一维数组来存储二叉树中的节点，并将节点的逻辑结构映射到数组的物理结构中。这种存储方式通常用于空间受限的场景，因为只需要一个数组即可存储整个二叉树。</p> 
<h4><strong> 2.为什么二叉树的顺序存储只能应用于完全二叉树？</strong></h4> 
<p><strong>2.1 节点索引与子节点关系：</strong> 在顺序存储中，节点的索引与它的子节点之间存在着固定的关系。例如，对于一个节点 i，它的左子节点的索引为 2i，右子节点的索引为 2i + 1。这种关系依赖于完全二叉树的结构特点，即每个非叶节点都拥有两个子节点。</p> 
<p><strong>2.2 空间利用率：</strong> 顺序存储旨在节省空间，因此需要尽可能地利用数组空间。在完全二叉树中，所有非叶节点都拥有两个子节点，因此数组空间可以得到充分利用。而对于非完全二叉树，可能存在一些节点只有一个子节点或没有子节点，导致数组空间浪费。</p> 
<p><strong>2.3 空缺节点处理：</strong> 在非完全二叉树中，可能存在空缺节点，即没有实际内容的节点。顺序存储难以有效地处理这些空缺节点，因为它们会破坏节点索引与子节点关系的约定。</p> 
<p><strong>2.4 算法复杂度：</strong> 对于非完全二叉树，顺序存储需要额外的机制来处理空缺节点，这会导致算法复杂度的增加，降低效率。</p> 
<h4>3.完全二叉树的顺序存储与非完全二叉树存储形状的区别：</h4> 
<p><img alt="" height="373" src="https://images2.imgbox.com/57/a2/PS2g9MSB_o.png" width="998"></p> 
<h3>2.堆(Heap)：</h3> 
<h4>堆的定义：</h4> 
<p>堆（Heap）是一种特殊的树形数据结构，它满足堆性质：允许高效地检索和删除最大/最小元素。堆通常用于实现优先队列。</p> 
<h4>堆的性质：</h4> 
<p>在堆中，每个非叶节点的值都应该大于或等于其子节点的值（最大堆）或者小于或等于其子节点的值（最小堆）。</p> 
<p>堆通常使用完全二叉树来实现，因为完全二叉树结构可以保证堆性质的有效性和空间利用率。</p> 
<p><span style="color:#fe2c24;">在最大堆中，根节点是堆中最大的元素；在最小堆中，根节点是堆中最小的元素。</span></p> 
<h4><strong>堆的种类:</strong></h4> 
<p>根据堆性质的不同，堆可以分为两种类型：</p> 
<p><strong><span style="color:#0d0016;">最大堆：</span></strong> 在最大堆中，每个非叶节点的值都大于或等于其子节点的值。<span style="color:#0d0016;">根节点是堆中最大的元素。</span></p> 
<p><strong><span style="color:#0d0016;">最小堆：</span></strong><span style="color:#0d0016;"> </span>在最小堆中，每个非叶节点的值都小于或等于其子节点的值。<span style="color:#0d0016;">根节点是堆中最小的元素。</span></p> 
<h4>最大堆与最小堆的形状：</h4> 
<p><img alt="" height="825" src="https://images2.imgbox.com/cd/4d/KDIQNbFt_o.png" width="1154"></p> 
<h3>3.顺序存储代码实现：</h3> 
<h5>堆的存储结构：</h5> 
<pre><code>typedef int HPDataType;
typedef struct Heap
{
	HPDataType* a;
	int size;
	int capacity;
}HP;</code></pre> 
<h5>堆的所有接口：</h5> 
<pre><code>//初始化、销毁
void HPInit(HP* php);
void HPDestroy(HP* php);

// 插入
void HPPush(HP* php, HPDataType x);

//获取堆顶元素、堆的有效数据个数
HPDataType HPTop(HP* php);
HPDataType HPsize(HP* php);

// 删除堆顶的数据
void HPPop(HP* php);

//判断堆是否为空
bool HPEmpty(HP* php);</code></pre> 
<h5>堆的初始化：</h5> 
<pre><code>void HPInit(HP* php)
{
	assert(php);
	php-&gt;a = NULL;
	php-&gt;capacity = php-&gt;size = 0;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/1d/76/1ySd4PT7_o.png" width="1103"></p> 
<h5>堆的销毁：</h5> 
<pre><code>void HPDestroy(HP* php)
{
	assert(php);
	free(php-&gt;a);
	php-&gt;a = NULL;
	php-&gt;capacity = php-&gt;size = 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="101" src="https://images2.imgbox.com/92/68/cga9ygKI_o.png" width="1182"></p> 
<h5>插入：</h5> 
<pre><code>void HPPush(HP* php, HPDataType x)
{
	assert(php);
	//扩容数组
	if (php-&gt;capacity == php-&gt;size)
	{
		HPDataType Newcapacity = php-&gt;capacity == 0 ? 4 : php-&gt;capacity * 2;
		HPDataType* Ptmp = (HPDataType*)realloc(php-&gt;a , sizeof(HPDataType) * Newcapacity);
		if (Ptmp == NULL)
		{
			perror("calloc error");
			exit(-1);
		}
		php-&gt;a = Ptmp;
		php-&gt;capacity = Newcapacity;	
	}
	php-&gt;a[php-&gt;size] = x;
	php-&gt;size++;
	//向上调整
	AdjustUp(php-&gt;a, php-&gt;size - 1); //因为php-&gt;size最后是指向最后数据的后面一个所以传要减一
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/83/6e/DujYc915_o.png" width="1200"></p> 
<h5>向上调整(建小堆)：</h5> 
<pre><code>void AdjustUp(HPDataType* a , HPDataType child)
{
	HPDataType parents = (child - 1) / 2;//找父节点
	while (child &gt; 0)//当child走到首节点时就会停止循环
	{
		if (a[child] &lt; a[parents])
		{
			Swap(&amp;a[child] , &amp;a[parents]);//交换数据
			child = parents;
			parents = (parents - 1) / 2;//改变父亲指针的指向，让父亲指针往上指
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<h5>交换父子数据：</h5> 
<pre><code>void Swap(HPDataType* x , HPDataType* y)
{
	int tmp = *x;
	*x = *y;
	*y = tmp;
}</code></pre> 
<h3><img alt="" height="392" src="https://images2.imgbox.com/1e/bd/dQUGxUcj_o.png" width="1200"></h3> 
<p>当堆(小堆)要插入新数据时在逻辑层面上是在堆的最右下方插入一个值而在物理层面上是直接在添加在数组的后面，而我们插入一个值必然会改变小堆(大堆)的性质所以需要向上调整以此来保持，所以当插入32时首先需要找到父亲节点然后再跟它比下大小如果新插入的节点比它小那就需要调整，把数据互相交换然后让孩子指向父亲然后再让父亲指向父亲同时要查看数据的大小，当child小于0时就可以退出了</p> 
<h5>获取堆顶(最大或最小)的元素：</h5> 
<pre><code>HPDataType HPTop(HP* php)
{
	assert(php);
	return php-&gt;a[0];
}</code></pre> 
<p>输出：</p> 
<h3><img alt="" height="137" src="https://images2.imgbox.com/76/64/GF41IB1O_o.png" width="1200"></h3> 
<h5>获取堆的数据个数：</h5> 
<pre><code>HPDataType HPsize(HP* php)
{
	assert(php);
	return php-&gt;size;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/8c/58/nrxTtB7x_o.png" width="1200"></p> 
<h5>删除堆顶的数据：</h5> 
<pre><code>void HPPop(HP* php)
{
	assert(php);
	assert(php-&gt;size &gt; 0);
	Swap(&amp;php-&gt;a[0] , &amp;php-&gt;a[php-&gt;size-1]);//先首尾交换
	php-&gt;size--;//删除尾部数据(实际上是隐藏交换之后的尾部数据)
	AdjustDown(php-&gt;a , php-&gt;size ,0);//向下调整
}</code></pre> 
<p>输出：</p> 
<h3><img alt="" height="217" src="https://images2.imgbox.com/50/ad/yE7E5bHU_o.png" width="1088"></h3> 
<p>虽然50 32还是显示但是我们靠自减已经将他们在逻辑层面给删除了但是再物理层面上还是带显示的</p> 
<h5>向下调整(逐个删除每个数据)：</h5> 
<pre><code>void AdjustDown(HPDataType* a , HPDataType n , HPDataType parents)
{
	
	HPDataType child = (parents * 2) + 1;
	while (child &lt; n)
	{
		//假设child指向左孩子
		if (child + 1 &lt; n &amp;&amp; a[child] &gt; a[child + 1])//选出左右孩子谁大谁小
		{
			
			child++;//如果右孩子小那就让child指针自增指向右孩指就行
		}
		if (a[child] &lt; a[parents])
		{
			Swap(&amp;a[child], &amp;a[parents]);
			child = parents;
			child = (parents * 2) + 1;
		}
		else
		{
			break;
		}
	}

}</code></pre> 
<h3><img alt="" height="1200" src="https://images2.imgbox.com/88/2e/1b9qFcsT_o.png" width="1200"></h3> 
<h5>判断堆是否为空：</h5> 
<pre><code>bool HPEmpty(HP* php)
{
	assert(php);
	if (php-&gt;size == 0)
	{
		return false;
	}
	return true;
	//return php-&gt;size == 0;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/14/a9/7VrV3gcH_o.png" width="1200"></p> 
<h5>打印堆：</h5> 
<p><img alt="" height="287" src="https://images2.imgbox.com/d5/bc/Cjh81rt3_o.png" width="1200"></p> 
<h3>4.链表存储结构：</h3> 
<p>链式二叉树是一种非线性数据结构，它使用链接而不是连续的内存布局来表示元素之间的层次关系。与将节点存储在数组中的传统二叉树不同，链式二叉树使用指针来连接节点，从而为节点分配和动态内存管理提供了灵活性。</p> 
<h4>二叉树的前序，中序，后序遍历:</h4> 
<p>二叉树遍历是指对二叉树中的每个节点恰好访问一次的系统过程。它是探索和操作二叉树的基本技术。三种常见的遍历方法是前序、中序、后序。</p> 
<h4><img alt="" height="510" src="https://images2.imgbox.com/ac/21/6Y7czXaj_o.png" width="1027"></h4> 
<h4><strong>前序遍历：</strong></h4> 
<p>在前序遍历中，首<span style="color:#fe2c24;">先访问根结点</span>，然后访问<span style="color:#fe2c24;">左子树</span>，<span style="color:#fe2c24;">最后访问右子树 </span>如上图：</p> 
<p>遍历顺序：</p> 
<p>首先访问根节点 1 ，然后再访问根节点 1 的左子树 2 最后再访问以 2 为根节点的左子树 4，接下来就是访问以 4 为根节点的左子树 NULL 与 右子树 NULL </p> 
<blockquote> 
 <p>1 2 4 NULL NULL</p> 
</blockquote> 
<p>当右子树是NULL那就需要向上返回 ，先是返回到 4 但因 4 已经遍历过了所以需要再次向上返回，返回到 2 但因 2 已经遍历过了但以它为根节点的右子树并没有被遍历过所以就先访问 以 2 为根节点的右子树 5 ，最后访问以5为根的左子树 NULL 和右子树 NULL</p> 
<blockquote> 
 <p>5 NULL NULL</p> 
</blockquote> 
<p>这里需要直接返回到 1 这里就不过多解释了思想和上面一样，遍历以 1 为根节点的右子树 3 然后再遍历以 3 为根节点的左子树 6 然后再访问以 3 为根节点的左子树 NULL 和 右子树 NULL，接下来需要返回到 以 3 为根节点的右子树 7最后访问以 7 为根节点的左子树 NULL 和 右子树 NULL</p> 
<blockquote> 
 <p>3 6 NULL NULL 7 NULL NULL</p> 
</blockquote> 
<p>它的完整顺序就是 1 2 4 NULL NULL  5 NULL NULL 3 6 NULL NULL 7 NULL NULL</p> 
<h4>中序遍历：</h4> 
<p>在中序遍历中，首<span style="color:#fe2c24;">先访问左子树</span>，然后访问<span style="color:#fe2c24;">根结点</span>，<span style="color:#fe2c24;">最后访问右子树 </span>如上图：</p> 
<p>遍历顺序：</p> 
<p>首先是访问 根节点的左子树 2 然后再访问以 2 为根节点的左子树 4最后再访问以 4 为根节点的左子树 NULL当碰到NULL就可以返回到根节点 4 最后再访问以 4 为根节点的右子树 NULL</p> 
<blockquote> 
 <p> NULL 4 NULL</p> 
</blockquote> 
<p>访问完以 4 为根节点的左树右树那就需要继续向上返回到根节点 2 因只遍历过以根节点的 2 的左子树但右子树并没有遍历所以现在需要遍历右子树 ，先遍历以根节点 5 的左子树 NULL然后再遍历根节点 5 最后需遍历以根节点 5 的右子树 NULL</p> 
<blockquote> 
 <p>2 NULL 5 NULL</p> 
</blockquote> 
<p>当以根节点 1 的左子树全部遍历完所以就需要遍历根节点 1 了  那么遍历完左子树 根节点那就需要遍历右子树了。先访问以根节点 1 的右子树 3然后再访问以根节点 3 的左子树 6 然后再遍历以根节点 6 的左子树 NULL当碰到 NULL 那这个程序就需要返回到根节点 6 然后向右访问 NULL碰到NULL那就需要再次返回到根节点 3 ，以3的左子树已经全部访问完所以就需要向右访问以此循环</p> 
<blockquote> 
 <p>1 NULL 6 NULL 3 NULL 7 NULL</p> 
</blockquote> 
<p>它的完整顺序就是 NULL 4 NULL 2 NULL 5 NULL 1 NULL 6 NULL 3 NULL 7 NULL</p> 
<h4>后序遍历：</h4> 
<p>在后序遍历中，首<span style="color:#fe2c24;">先访问左子树</span>，然后访问<span style="color:#fe2c24;">右子树</span>，<span style="color:#fe2c24;">最后访问根结点 </span>如上图：</p> 
<p>遍历顺序：</p> 
<p>首先是访问 根节点的左子树 2 然后再访问以 2 为根节点的左子树 4最后再访问以 4 为根节点的左子树 NULL当碰到NULL就可以返回到根节点 4 但是根节点是最后才访问的所以现在不能访问 4 而是先访问以 4 为根节点的右子树 NULL最后再访问以 4 为根节点</p> 
<blockquote> 
 <p>NULL NULL 4</p> 
</blockquote> 
<p>访问完根节点 4 之后就需要向上返回到以 2 为根节点但是后序的访问顺序是先访问左 右最后再访问根节点的 所以我们需要向以 2 为根节点的右遍历左子树与右子树 NULL最后再访问根节点 5。</p> 
<blockquote> 
 <p>NULL NULL 5</p> 
</blockquote> 
<p>访问完以 2 为根节点的左子树与右子树那么就可以访问根节点了但是根节点 2 也是也是以 1 为根节点的左子树，现在以 1 为左子树已经访问完那就可以访问以 1 为根节点的右子树了所以我们现在向右遍历 直到遍历到以 6 为根节点的左子树 NULL 然后就需开始返回到 根节点 6 然后再向右子树 NULL 最后再访问 根节点 6</p> 
<blockquote> 
 <p>NULL NULL 6</p> 
</blockquote> 
<p>访问根节点 6 之后就和以 根节点 1 为左子树的 2 一样这里我就不重新赘述了 最后访问完以 1 为右子树就需要访问 根节点 1 了</p> 
<blockquote> 
 <p>NULL NULL 7 3 1</p> 
</blockquote> 
<p>它的完整顺序就是 NULL NULL 4 NULL NULL 5 2 NULL NULL 6 NULL NULL 7 3 1</p> 
<h3>4.链式存储代码实现：</h3> 
<h5>链式存储结构：</h5> 
<pre><code>typedef int BTDataType;
typedef struct BinaryTree
{
	struct BinaryTree* left;//左子树
	struct BinaryTree* right;//右子树
	BTDataType data;
}BT;
</code></pre> 
<h5>链式存储所有接口：</h5> 
<pre><code>//二叉树的初始化
BT* CreatTreeNode(int x);

//二叉树的销毁
void DestroyBinaryTree(BT* root);

//前序遍历、中序遍历、后序遍历
void PrevOrder(BT* root);
void InOrder(BT* root);
void PostOrder(BT* root);

//获取二叉树相关个数
int BinaryTreeSize(BT* root);

//获取叶子节点相关个数
int BinaryTreeleafSize(BT* root);

//获取树的高度
int  BinaryTreeHeight(BT* root);

//计算第K层节点个数
int  BinaryTreeKcount(BT* root, BTDataType k);

</code></pre> 
<h5>链式存储初始化：</h5> 
<pre><code>BT* CreatTreeNode(int x)
{
	BT* Newnode = (BT*)malloc(sizeof(BT));
	if (Newnode == NULL)
	{
		perror("malloc error");
		return NULL;
	}
	Newnode-&gt;data = x;
	Newnode-&gt;left = NULL;
	Newnode-&gt;right = NULL;
	return Newnode;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/16/f0/X55yIqqN_o.png" width="1200"></p> 
<h5>链式存储销毁：</h5> 
<pre><code>void DestroyBinaryTree(BT* root)
{
	if (root == NULL)
	{
		return;
	}
	DestroyBinaryTree(root-&gt;left);
	DestroyBinaryTree(root-&gt;right);
	free(root);
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/73/3a/pFOuHlEP_o.png" width="1200"></p> 
<h5>前序遍历：</h5> 
<pre><code>void PrevOrder(BT* root)
{
	if (root == NULL)
	{
		printf("NULL ");
		return;
	}
	printf("%d ", root-&gt;data);
	PrevOrder(root-&gt;left);
	PrevOrder(root-&gt;right);
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/86/20/wXKGcPay_o.png" width="1200"></p> 
<h5>中续遍历：</h5> 
<pre><code>void InOrder(BT* root)
{
	if (root == NULL)
	{
		printf("NULL ");
		return;
	}
	InOrder(root-&gt;left);
	printf("%d ", root-&gt;data);
	InOrder(root-&gt;right);
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/44/41/KtZxD1Az_o.png" width="1200"></p> 
<h5>后续遍历：</h5> 
<pre><code>void PostOrder(BT* root)
{
	if (root == NULL)
	{
		printf("NULL ");
		return;
	}
	PostOrder(root-&gt;left);
	PostOrder(root-&gt;right);
	printf("%d ", root-&gt;data);
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="89" src="https://images2.imgbox.com/cc/36/pXIrpIyf_o.png" width="1200"></p> 
<h5>获取二叉树相关个数：</h5> 
<pre><code>int BinaryTreeSize(BT* root)
{
	if (root == NULL)
	{
		return 0;
	}
	return 1 + BinaryTreeSize(root-&gt;left) + BinaryTreeSize(root-&gt;right);
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/45/88/0fmP7FQS_o.png" width="1200"></p> 
<h5>获取叶子节点相关个数：</h5> 
<pre><code>int BinaryTreeleafSize(BT* root)
{
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		return 1;
	}
	if (root == NULL)
	{
		return 0;
	}
	else
	{
		return BinaryTreeleafSize(root-&gt;left) + BinaryTreeleafSize(root-&gt;right);
	}
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/04/dd/ZlZxAaqV_o.png" width="1200"></p> 
<h5>获取树的高度：</h5> 
<pre><code>int  BinaryTreeHeight(BT* root)
{
	if (root == NULL)
	{
		return 0;
	}
	BTDataType Tleft = BinaryTreeHeight(root-&gt;left);
	BTDataType Tright = BinaryTreeHeight(root-&gt;right);
	return Tleft &gt; Tright ? Tleft + 1 : Tright + 1;

}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="129" src="https://images2.imgbox.com/cb/d6/ViNRPT9n_o.png" width="1200"></p> 
<h5>计算第K层节点个数：</h5> 
<pre><code>int  BinaryTreeKcount(BT* root, BTDataType k)
{
	if (root == NULL || k &lt; 1)
	{
		return 0;
	}
	if (k == 1)
	{
		return 1;
	}
	return BinaryTreeKcount(root-&gt;left, k - 1) + BinaryTreeKcount(root-&gt;right, k - 1);
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/2f/42/aIaQ92uH_o.png" width="1200"></p> 
<h2>五 树与二叉树的区别：</h2> 
<p><strong>1. 子节点数量</strong></p> 
<ul><li>树：一个节点可以拥有任意多个子节点。</li><li>二叉树：一个节点最多只能拥有两个子节点，通常称为左子节点和右子节点。</li></ul> 
<p><strong>2. 子节点的顺序</strong></p> 
<ul><li>树：树的子节点可以任意排列，没有左右之分。</li><li>二叉树：二叉树的子节点必须严格按照左右顺序排列。</li></ul> 
<p><strong>3. 应用场景</strong></p> 
<ul><li>树：树常用于表示具有层次关系的数据结构，例如文件目录树、组织机构图等。</li><li>二叉树：二叉树由于其结构简单、易于实现，在计算机科学中有着广泛的应用，例如二叉查找树、二叉堆、表达式树等。</li></ul> 
<p><strong>4.形象比喻</strong></p> 
<ul><li>树可以想象成一棵树木，每个节点代表一个树枝，子节点代表树枝的分叉。树枝可以任意分叉，没有左右之分。</li><li>二叉树可以想象成一棵只有左右两个分支的树，每个节点代表一个树枝，左子节点代表树枝的左边分支，右子节点代表树枝的右边分支。</li></ul> 
<h2><strong>六 总结：</strong></h2> 
<p>树和二叉树都是重要的数据结构，但它们在子节点数量、子节点顺序和应用场景等方面存在着差异。选择哪种数据结构取决于具体的应用需求。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72908f938877a62cc9de79efa1a37cbd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt Creator（2）【如何在Qt Creator中创建新工程】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fff74203ff65b3218716683600755d87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI模型 YOLOv8在工业中的应用案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>