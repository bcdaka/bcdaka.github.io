<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java LeetCode篇-深入了解二叉树经典解法（三种方式实现：获取二叉树的最大深度） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f8f159909362646789309c1fe6747423/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java LeetCode篇-深入了解二叉树经典解法（三种方式实现：获取二叉树的最大深度）">
  <meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 对称二叉树
1.1 判断对称二叉树实现思路
1.2 代码实现：判断对称二叉树
2.0 二叉树的最大深度
2.1 使用递归实现获取二叉树的最大深度思路
2.2 代码实现：使用递归实现获取二叉树的最大深度
2.3 使用非递归实现获取二叉树的最大深度思路
2.4 代码实现：使用非递归实现获取二叉树的最大深度
2.5 使用层序遍历实现获取二叉树的最大深度
2.6 代码实现：使用层序遍历实现获取二叉树的最大深度
3.0 二叉树的最小深度
3.1 使用递归实现获取二叉树的最小深度思路
3.2 代码实现：使用递归实现获取二叉树最小深度
3.3 使用层序遍历实现获取二叉树的最小深度思路
3.4 代码实现：使用层序遍历实现获取二叉树的最小深度
4.0 翻转二叉树
4.1 使用实现递归翻转二叉树思路
4.2 代码实现：使用递归翻转二叉树
5.0 二叉树经典解法的完整代码
1.0 对称二叉树 题目：
给你一个二叉树的根节点 root ， 检查它是否轴对称。
示例 1：
输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：
输入：root = [1,2,2,null,3,null,3] 输出：false OJ链接：
101. 对称二叉树
1.1 判断对称二叉树实现思路 假设该树的图： 具体思路为：如果当前节点的左子树的值等于当前节点的右子树时，可以说目前为止还是对称的，不能直接下结论，因为不能保证之后的节点是否对称。比如：当前节点的值为 1 ，它的左孩子的值为 2 ，它的右孩子的值为 2，此时可以说暂时是对称的，还需要接着向下判断。它的左孩子的左孩子的值为 3，它的右孩子的右孩子为 3 ，同理，现在还不能说明该树是否对称，当递归到底的时候，当前的节点的左右孩子都是 null ，此时可以返回 true ，不能足以证明该树对称，因为单单只是判断完外侧的节点，在外层回归的过程中，需要判断内层的节点是否对称，回归到节点值都为 2 的节点，接着进行内层递归，对于在外层判断完左孩子，那么接下来需要判断右孩子，同样，对于在外层判断完右孩子，那么接下来需要判断左孩子。如，刚刚的外层结束递出之后，开始回归，到节点为 2 的节点，对于左边的节点值为 2 的节点的右孩子，与右边的节点值为 2 的节点的左孩子进行比较，如果相同，由于说明不了什么，还得继续往下递出，直到该节点的左右孩子都为 null 时，可以返回 true 。最后返回到节点值为 1 的根节点中，可以得到该树是对称。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-06T12:21:43+08:00">
    <meta property="article:modified_time" content="2023-12-06T12:21:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java LeetCode篇-深入了解二叉树经典解法（三种方式实现：获取二叉树的最大深度）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong>  </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="400" src="https://images2.imgbox.com/2d/c4/HuSXTbSK_o.jpg" width="400"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/37/ca/LkF5vQA4_o.gif"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        1.0 对称二叉树</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" rel="nofollow">1.1 判断对称二叉树实现思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">1.2 代码实现：判断对称二叉树</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6" rel="nofollow">        2.0 二叉树的最大深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF" rel="nofollow">2.1 使用递归实现获取二叉树的最大深度思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6" rel="nofollow">        2.2 代码实现：使用递归实现获取二叉树的最大深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF" rel="nofollow">        2.3 使用非递归实现获取二叉树的最大深度思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6" rel="nofollow">        2.4 代码实现：使用非递归实现获取二叉树的最大深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6" rel="nofollow">        2.5 使用层序遍历实现获取二叉树的最大深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6" rel="nofollow">        2.6 代码实现：使用层序遍历实现获取二叉树的最大深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6" rel="nofollow">        3.0 二叉树的最小深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF" rel="nofollow">        3.1 使用递归实现获取二叉树的最小深度思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6" rel="nofollow">        3.2 代码实现：使用递归实现获取二叉树最小深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF" rel="nofollow">        3.3 使用层序遍历实现获取二叉树的最小深度思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6" rel="nofollow">        3.4 代码实现：使用层序遍历实现获取二叉树的最小深度</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        4.0 翻转二叉树</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E8%B7%AF" rel="nofollow">        4.1 使用实现递归翻转二叉树思路</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        4.2 代码实现：使用递归翻转二叉树</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        5.0 二叉树经典解法的完整代码</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91" style="background-color:transparent;">        1.0 对称二叉树</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</strong></p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="209" src="https://images2.imgbox.com/5a/cd/8Ih9vULs_o.png" width="254"></p> 
 <pre><strong>输入：root = [1,2,2,3,4,4,3]
输出：true
</strong></pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="174" src="https://images2.imgbox.com/d5/89/5CA6sr8D_o.png" width="208"></p> 
 <pre><strong>输入：</strong>root = [1,2,2,null,3,null,3]
<strong>输出：</strong>false
</pre> 
 <p><strong>OJ链接：</strong></p> 
 <p><a href="https://leetcode.cn/problems/symmetric-tree/" rel="nofollow" title="101. 对称二叉树">101. 对称二叉树</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1%20%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">        1.1 判断对称二叉树实现思路</h3> 
<blockquote> 
 <p><strong>     假设该树的图：   </strong></p> 
 <p class="img-center"><img alt="" height="209" src="https://images2.imgbox.com/e9/52/Cc3gxmup_o.png" width="254"></p> 
</blockquote> 
<p>        <strong><span style="color:#fe2c24;">具体思路为</span>：如果当前节点的左子树的值等于当前节点的右子树时，可以说目前为止还是对称的，不能直接下结论，因为不能保证之后的节点是否对称。<span style="color:#fe2c24;">比如：当前节点的值为 1 ，它的左孩子的值为 2 ，它的右孩子的值为 2，此时可以说暂时是对称的，还需要接着向下判断</span>。它的左孩子的左孩子的值为 3，它的右孩子的右孩子为 3 ，同理，现在还不能说明该树是否对称，当递归到底的时候，当前的节点的左右孩子都是 null ，此时可以返回 true ，不能足以证明该树对称，因为单单只是判断完外侧的节点，在外层回归的过程中，需要判断内层的节点是否对称，回归到节点值都为 2 的节点，接着进行内层递归，对于在外层判断完左孩子，那么接下来需要判断右孩子，同样，对于在外层判断完右孩子，那么接下来需要判断左孩子。<span style="color:#fe2c24;">如，刚刚的外层结束递出之后，开始回归，到节点为 2 的节点，对于左边的节点值为 2 的节点的右孩子，与右边的节点值为 2 的节点的左孩子进行比较，如果相同，由于说明不了什么，还得继续往下递出，直到该节点的左右孩子都为 null 时，可以返回 true </span>。最后返回到节点值为 1 的根节点中，可以得到该树是对称。</strong></p> 
<p><strong>        <span style="color:#fe2c24;">在无论是外层递出还是内层递出：</span></strong></p> 
<p>         <span style="color:#fe2c24;"><strong>- 当左右孩子节点的值不相同的时候，就说明了该树时不相等的，直接返回 false ；</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>         - 遇到一个节点的左孩子不为 null 而右孩子为 null 时，可以直接返回 false ，不需要接着往后递出了。同理，遇到一个节点的右孩子不为 null ，而左孩子为 null 时，直接返回 false ；</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>         - 当且仅当，当该节点的左右孩子都为 null 时，返回 true ；</strong></span></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">        1.2 代码实现：判断对称二叉树</h3> 
<blockquote> 
 <pre><code class="language-java">    //判断对称二叉树
    public boolean isSymmetry(TreeNode root) {
        return isSymmetryRecursion(root.left,root.right);
    }

    private boolean isSymmetryRecursion(TreeNode left,TreeNode right) {
        if (left == null &amp;&amp; right == null ) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        return isSymmetryRecursion(left.left,right.right) &amp;&amp; isSymmetryRecursion(left.right,right.left);

    }</code></pre> 
 <p><strong>        大体上的思路跟后序遍历二叉树一致。</strong></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6" style="background-color:transparent;">        2.0 二叉树的最大深度</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        给定一个二叉树 <code>root</code> ，返回其最大深度。</strong></p> 
 <p><strong>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</strong></p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="223" src="https://images2.imgbox.com/0d/f6/yfqebbBt_o.jpg" width="322"></p> 
 <p></p> 
 <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>3

</pre> 
 <p><strong>OJ链接：</strong></p> 
 <p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" rel="nofollow" title="104. 二叉树的最大深度">104. 二叉树的最大深度</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.1%20%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF">         2.1 使用递归实现获取二叉树的最大深度思路</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">先从整体思路出发，得到最大的深度，无非就是比较左右子树的深度，选取较大的值 + 1，返回即可</span>。当遇到的节点为 null 时，返回 0 ，结束递出。比如，节点值为 3 的节点，它的左子树的深度为 1，它的右子树的深度为 2 ,那么选取最大的值为 2 ，最后最大的值再加上 1 ，所以得出的该树的最大深度为 3 。</strong></p> 
<p>        <strong>接下来具体分析每一个节点：<span style="color:#fe2c24;">根节点值为 3 ，先获取左子树的深度：</span>沿着该方向递出，直到遇到当前节点的左右孩子都为 null 时，返回 0 ，所以值为 9 的节点目前返回上一个递归调用的值为 1 ，对于根节点的左子树的深度为 1 ；<span style="color:#fe2c24;">再获取右子树的深度：</span>沿着根节点的右子树递出，这次遇到的节点的左右子树都不为 null 时，对于当前值为 20 的节点来说，需要获取该左右子树的最大的值，<span style="color:#fe2c24;">先获取左子树的深度：</span>沿着该方式递出，直到遇到的节点为 null 时，返回 0，节点值为 15 的节点的左右孩子都为 null ，返回 0 + 1 ，所以对于节点 20 来说，该左子树的深度为 1 ；<span style="color:#fe2c24;">接着继续来获取节点值为 20 的右子树的深度：</span>沿着该方式递出，直到遇到的节点为 null 时，返回 0，节点值为 7 的左右孩子都为 null ，返回 0 + 1。那么选取较大的值 + 1，就是节点值为 20 的深度为 2 。相对与根节点来说已经得到了左右子树的深度了，分别为 1 与 2 ，选取最大的值 2 再加 1 就是该树的最大深度为 3 。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">        2.2 代码实现：使用递归实现获取二叉树的最大深度</h3> 
<blockquote> 
 <pre><code class="language-java">    //用递归方式求树的最大深度
    public int maximumDepthRecursion(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int l = maximumDepth(node.left);
        int r = maximumDepth(node.right);
        return Math.max(l,r) + 1;

    }</code></pre> 
 <p><strong>        大体上思路跟后序遍历思路大致相同。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%20%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF">        2.3 使用非递归实现获取二叉树的最大深度思路</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">在之前讲到使用非递归实现后序遍历的思路，跟这里的思路大致一致</span>。简单再讲一下思路，根节点从左孩子开始出发，在到下一个节点之前，需要先把该节点压入栈中，直到 node == null 时，不再继续下去，按照原路返回。由于需要完成对右节点的操作后，需要返回该节点，所以不能直接把栈顶元素弹出，先查找栈顶元素，查看该右孩子是否为 null 或者已经完成对右孩子的相关操作之后，这才能弹出栈顶元素。如果以上情况都不符合，需要对右孩子进行处理。以上就是使用非递归实现后序循环，那么结合该题求树的最大深度，即什么时候栈的元素达到最大的时候，这时候就是树的最大深度。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">        2.4 代码实现：使用非递归实现获取二叉树的最大深度</h3> 
<blockquote> 
 <pre><code class="language-java">    //用非递归方式求树的最大深度
    public int maximumDepth(TreeNode root) {
        TreeNode curr = root;
        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        int max = 0;
        TreeNode pop = null;
        while (curr != null || !stack.isEmpty()) {
            if (curr != null) {
                stack.push(curr);
                curr = curr.left;
                if (max &lt; stack.size()) {
                    max = stack.size();
                }
            } else {
                TreeNode peek = stack.peek();
                if ( peek.right == null || peek.right == pop ) {
                    pop = stack.pop();
                }else {
                    curr = peek.right;
                }
            }
        }
        return max;
    }</code></pre> 
 <p>       <strong> 当然，这个时间复杂度比使用递归实现的要大，效率不如使用递归的实现二叉树最大深度。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.5%20%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">        2.5 使用层序遍历实现获取二叉树的最大深度</h3> 
<p>        <strong>先了解层序遍历：顾名思义，<span style="color:#fe2c24;">按照层级进行依次访问节点。将每个节点压入队列中，按照先进先出的顺序依次访问队列中的节点。具体来说，我们从根节点开始，将根节点压入队列中，然后依次从队列中取出节点，将其左右子节点（如果存在）压入队列中</span>。</strong></p> 
<p><strong>        需要准备队列来存储节点，根据该数据结构的特性：先进先出，一开始先让根节点压入队列中，接着从队列中弹出来，如果弹出来的节点的左孩子不为 null 时，将其压入队列中；如果左孩子为 null 时，不需要压入队列中；同理，如果弹出来节点的右孩子不为 null 时，将其压入队列中。循环结束条件为：当队列中的元素个数为 0 时，退出循环。</strong></p> 
<p><strong>        <span style="color:#fe2c24;">再结合该题的逻辑，该二叉树的最大深度就是树的层级数量。那么怎么才能得出 int depth 层级数量呢？再嵌套一个内层循环，每一层遍历结束之后，depth++ 。内层循环的次数为：当前的队列的元素的个数</span>。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.6%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">        2.6 代码实现：使用层序遍历实现获取二叉树的最大深度</h3> 
<blockquote> 
 <pre><code class="language-java">    //使用层序遍历求树的最大深度
    public int sequenceMaxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        int depth = 0;
        while ( !queue.isEmpty()) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                TreeNode tp = queue.poll();
                if (tp.left != null) {
                    queue.offer(tp.left);
                }
                if (tp.right != null) {
                    queue.offer(tp.right);
                }
                //System.out.print(tp.val + " ");
            }
            //System.out.println();
            depth++;
        }
        return depth;
    }</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6" style="background-color:transparent;">        3.0 二叉树的最小深度</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        给定一个二叉树，找出其最小深度。</strong></p> 
 <p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong></p> 
 <p><strong>说明：叶子节点是指没有子节点的节点。</strong></p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/57/56/GpTMo1J2_o.jpg" width="332"></p> 
 <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>2
</pre> 
 <p><strong>OJ链接：</strong></p> 
 <p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" rel="nofollow" title="111. 二叉树的最小深度">111. 二叉树的最小深度</a></p> 
</blockquote> 
<p>        <strong><span style="color:#fe2c24;">二叉树的最小深度是指从根节点到最近叶子节点的最短路径上的节点数量。换句话说，最小深度是从根节点到最近的叶子节点的路径长度。</span></strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF">        3.1 使用递归实现获取二叉树的最小深度思路</h3> 
<p>       <strong> 具体思路为：思路大体跟或去最大深度的思路差不太多，当比较前节点的左右子树，获取最小的值 + 1 ，则为当前节点的深度。获取最小深度相较于获取最大深度，<span style="color:#fe2c24;">多了一个判断条件，如果当前节点为 0 时，不应该参与比较</span>。</strong></p> 
<blockquote> 
 <p><strong>如图例，该树的深度应该为 2 ，如果不加额外的条件来判断左右孩子节点是否为 null 时，那么此时根节点的右孩子为 null ，所以右子树为深度为 0 ；左孩子不为 null ，接着递归下去，直到 node == null 为止，从图可知，该根节点的左子树的深度为 1，因此用 1 与 0 来比较，获取最小的值为 0 ，再加上 1 ,最后结果为 1 。很明显不符合要求。所以，一定要加条件来判断，查看该节点的左右孩子是否为 null ，如果为 null ，需要返回另一个节点 + 1 当作当前节点的深度。</strong></p> 
 <p class="img-center"><img alt="" height="149" src="https://images2.imgbox.com/e7/f0/x6tFRU00_o.png" width="212"></p> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">        3.2 代码实现：使用递归实现获取二叉树最小深度</h3> 
<blockquote> 
 <pre><code class="language-java">    //使用递归求树的最小深度
    public int minDepth(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int l = minDepth(node.left);
        int r = minDepth(node.right);
        if (l == 0) {
            return r + 1;
        }
        if (r == 0) {
            return l + 1;
        }

        return Math.min(l,r) + 1;

    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%B7%AF">        3.3 使用层序遍历实现获取二叉树的最小深度思路</h3> 
<p>       <strong> 具体思路为：<span style="color:#fe2c24;">当带一个遇到的叶子节点时，当前的层数就是该树的最小深度</span>。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">        3.4 代码实现：使用层序遍历实现获取二叉树的最小深度</h3> 
<blockquote> 
 <pre><code class="language-java">    //使用层序遍历求得树的最小深度
    public int sequenceMinDepth(TreeNode root) {
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        int depth = 0;
        while (!queue.isEmpty()) {
            depth++;
            int size = queue.size();
            for (int i = 0; i &lt; size ; i++) {
                TreeNode poll = queue.poll();
                if (poll.right == null &amp;&amp; poll.left == null) {
                    return depth;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return depth;
    }</code></pre> 
 <p></p> 
</blockquote> 
<p>        </p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91" style="background-color:transparent;">        4.0 翻转二叉树</h2> 
<blockquote> 
 <p><strong>题目：</strong></p> 
 <p><strong>        给定一棵二叉树的根节点 <code>root</code>，请左右翻转这棵二叉树，并返回其根节点。</strong></p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="159" src="https://images2.imgbox.com/1a/0d/oyzIUiT4_o.png" width="425"></p> 
 <pre><strong>输入：</strong>root = [5,7,9,8,3,2,4]
<strong>输出：</strong>[5,9,7,4,2,3,8]

</pre> 
 <p><strong>OJ链接：</strong></p> 
 <p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof" rel="nofollow" title="LCR 144. 翻转二叉树">LCR 144. 翻转二叉树</a></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E8%B7%AF">        4.1 使用实现递归翻转二叉树思路</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">从整体来看，将当前节点的左右节点进行翻转，每一个节点都是如此，递归结束条件为 node == null 时，结束递出。回归到每一个节点的右子树进行翻转</span>。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">        4.2 代码实现：使用递归翻转二叉树</h3> 
<blockquote> 
 <pre><code class="language-java">    //翻转二叉树
    public void rollbackRecursion(TreeNode node) {
        if (node == null) {
            return;
        }
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;

        rollbackRecursion(node.left);
        rollbackRecursion(node.right);
    }
</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        5.0 二叉树经典解法的完整代码</h2> 
<p><strong>回顾本章代码，进一步巩固：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class TreeNode {

    private TreeNode left;
    private int val;
    private TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(TreeNode left, int val, TreeNode right) {
        this.left = left;
        this.val = val;
        this.right = right;
    }

    //递归实现前序遍历
    public void prevRecursion(TreeNode node) {
        if (node == null) {
            return;
        }
        System.out.print(node.val + " ");
        prevRecursion(node.left);
        prevRecursion(node.right);
    }


    //递归实现中序遍历
    public void midRecursion(TreeNode node) {
        if (node == null) {
            return;
        }
        midRecursion(node.left);
        System.out.print(node.val + " ");
        midRecursion(node.right);
    }


    //递归实现后序遍历
    public void postRecursion(TreeNode node) {

        if (node == null) {
            return;
        }
        postRecursion(node.left);
        postRecursion(node.right);
        System.out.print(node.val + " ");
    }

    //非递归实现前序遍历
    public List&lt;Integer&gt; prev(TreeNode root) {
        TreeNode node = root;
        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                stack.push(node);
                list.add(node.val);
                node = node.left;
            }else {
                TreeNode tp = stack.pop();
                node = tp.right;
            }
        }
        return list;
    }

    //非递归实现中序遍历
    public void mid(TreeNode root) {
        TreeNode node = root;
        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();

        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                stack.push(node);

                node = node.left;
            }else {
                TreeNode tp = stack.pop();
                System.out.print(tp.val + " ");
                node = tp.right;
            }
        }
        System.out.println();

    }

    //非递归实现后序遍历
    public List&lt;Integer&gt; post(TreeNode root) {
        TreeNode node = root;
        TreeNode pop = null;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        while ( node != null || !stack.isEmpty()) {
            if (node != null) {
                stack.push(node);
                node = node.left;
            }else {
                TreeNode tp = stack.peek();
                if (tp.right == null || tp.right == pop) {
                    pop = stack.pop();
                    list.add(pop.val);
                }else {
                    node = tp.right;
                }
            }
        }
        return list;
    }

    //判断对称二叉树
    public boolean isSymmetry(TreeNode root) {
        return isSymmetryRecursion(root.left,root.right);
    }

    private boolean isSymmetryRecursion(TreeNode left,TreeNode right) {
        if (left == null &amp;&amp; right == null ) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        return isSymmetryRecursion(left.left,right.right) &amp;&amp; isSymmetryRecursion(left.right,right.left);

    }

    //用递归方式求树的最大深度
    public int maximumDepthRecursion(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int l = maximumDepth(node.left);
        int r = maximumDepth(node.right);
        return Math.max(l,r) + 1;

    }

    //用非递归方式求树的最大深度
    public int maximumDepth(TreeNode root) {
        TreeNode curr = root;
        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        int max = 0;
        TreeNode pop = null;
        while (curr != null || !stack.isEmpty()) {
            if (curr != null) {
                stack.push(curr);
                curr = curr.left;
                if (max &lt; stack.size()) {
                    max = stack.size();
                }
            } else {
                TreeNode peek = stack.peek();
                if ( peek.right == null || peek.right == pop ) {
                    pop = stack.pop();
                }else {
                    curr = peek.right;
                }
            }
        }
        return max;
    }

    //使用层序遍历求树的最大深度
    public int sequenceMaxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        int depth = 0;
        while ( !queue.isEmpty()) {
            int size = queue.size();
            for (int j = 0; j &lt; size; j++) {
                TreeNode tp = queue.poll();
                if (tp.left != null) {
                    queue.offer(tp.left);
                }
                if (tp.right != null) {
                    queue.offer(tp.right);
                }
                //System.out.print(tp.val + " ");
            }
            //System.out.println();
            depth++;
        }
        return depth;
    }

    //使用递归求树的最小深度
    public int minDepth(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int l = minDepth(node.left);
        int r = minDepth(node.right);
        if (l == 0) {
            return r + 1;
        }
        if (r == 0) {
            return l + 1;
        }

        return Math.min(l,r) + 1;

    }

    //使用层序遍历求得树的最小深度
    public int sequenceMinDepth(TreeNode root) {
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        int depth = 0;
        while (!queue.isEmpty()) {
            depth++;
            int size = queue.size();
            for (int i = 0; i &lt; size ; i++) {
                TreeNode poll = queue.poll();
                if (poll.right == null &amp;&amp; poll.left == null) {
                    return depth;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return depth;
    }

    //翻转二叉树
    public void rollbackRecursion(TreeNode node) {
        if (node == null) {
            return;
        }
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;

        rollbackRecursion(node.left);
        rollbackRecursion(node.right);
    }


}</code></pre> 
 <p></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6a/c1/N4gZAnIV_o.gif"></p> 
<p style="text-align:center;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31371133e1b4a4a97e372870e803c292/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Nodejs使用mysql2操作数据库【完整讲解】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2d3ee2a2cd44125cae28670a09ae376/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL库的操作『增删改查 ‖ 编码问题 ‖ 备份与恢复』</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>