<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C/排序算法】：归并排序和计数排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ab0fb76b23a2c31e77c188195ad37dc7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C/排序算法】：归并排序和计数排序">
  <meta property="og:description" content="目录 1. 归并排序2. 计数排序 1. 归并排序 归并排序是一种效率仅次于快速排序的排序算法。它有非递归和递归两种实现方式(本文只讲述递归实现，非递归实现以后有专门的文章)。
其实，归并排序也叫外排序。它不仅可以对内存中的数据进行排序，还能对文件里的数据排序。
比如：假设有10G的数据放在硬盘的文件中，要排序，如何排呢？
我们知道，内存里的空间远远没有10G，假设有1G内存可用。首先我们可以把10G的文件切分成10个1G的文件，再依次读文件，每次把1G的数据读入内存的数组中，接着利用快排对其进行排序，再把排好序的那1G的数据写到硬盘的一个文件，再继续读下一个1G的数据……当10个文件里的数据都分别有序时，再利用归并排序进行两两归并，最终使10G的数据有序。
1.算法思想：
归并排序采用分治法。首先假设一组数据的左半区间有序，右半区间有序，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
若将两个有序表合并成一个有序表，称为二路归并。
所谓 归并，就是将两组有序的数据合成为一组有序的数据。 例如有如下两个有序数组，将两个有序数组归并为一个有序数组，这就是一次归并操作。
2.归并操作的工作原理如下：
第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。
第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。
第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。
重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。
归并排序类似于二叉树的后序遍历，即先将左右的区间都排为有序后，然后才开始进行归并操作，因为归并必须要满足两个数组是有序的。
例如有如下数组。需要先将该数组每次都分割为两个区间，直到最后每个区间都只有一个值，此时比较两个值大小，然后将该两个值归并到一个数组中，此时就得到一个有两个元素的有序数组，然后再与另一个有两个元素的有序数组进行归并，然后就得到了一个有四个元素的有序数组，然后再与另一个有四个元素的有序数组进行归并，就得到了一个有八个元素的有序数组。就这样依次递归归并，直到最后目标数组为有序数组。
3.归并排序的代码实现如下：
//把数组分成区间 void _MergrSort(int* arr,int left,int right,int* tmp) { //当区间内只有一个元素时，认为有序，递归结束，开始归并 if (left == right) return ; //右移1位右除以2的效果，用来把数组分成两个区间 int mid = (left &#43; right) &gt;&gt; 1; //假设[left mid] [mid&#43;1 right]有序，就可以归并 _MergrSort(arr, left, mid, tmp); _MergrSort(arr, mid &#43; 1, right, tmp); //每次归并的过程 int begin1 = left; int end1 = mid; int begin2 = mid &#43; 1; int end2 = right; //注意：这里的index不要给0，因为在递归过程中left不一定等于0 int index = left; //有一个区间结束就停止 while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (arr[begin1] &lt;= arr[begin2]) { tmp[index&#43;&#43;] = arr[begin1&#43;&#43;]; } else { tmp[index&#43;&#43;] = arr[begin2&#43;&#43;]; } } //当其中有一个区间结束时，另一个有序区间的数据直接拷贝进临时数组里 while (begin1 &lt;= end1) { tmp[index&#43;&#43;] = arr[begin1&#43;&#43;]; } while (begin2 &lt;= end2) { tmp[index&#43;&#43;] = arr[begin2&#43;&#43;]; } //最后把临时数组里面的数据拷贝回原数组 //注意：这里拷贝时有可能是局部区间拷贝，要加 begin memcpy(arr&#43;begin, tmp&#43;begin, sizeof(int) * (end -begin &#43;1)); //也可以这样写 //for(int i = left; i &lt;= right; i&#43;&#43;) //	arr[i] = tmp[i]; } void MergrSort(int* arr, int sz) { //创建临时数组存放数据 int* tmp = (int*)malloc(sizeof(int) * sz); if (tmp == NULL) { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-05T23:07:43+08:00">
    <meta property="article:modified_time" content="2024-07-05T23:07:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C/排序算法】：归并排序和计数排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 归并排序</a></li><li><a href="#2__126" rel="nofollow">2. 计数排序</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 归并排序</h2> 
<p>归并排序是一种效率仅次于快速排序的排序算法。它有<strong>非递归</strong>和<strong>递归</strong>两种实现方式(<strong>本文只讲述递归实现，非递归实现以后有专门的文章</strong>)。</p> 
<blockquote> 
 <p><em><strong>其实，归并排序也叫外排序。它不仅可以对内存中的数据进行排序，还能对文件里的数据排序。</strong></em></p> 
 <p>比如：假设有10G的数据放在硬盘的文件中，要排序，如何排呢？<br> 我们知道，内存里的空间远远没有10G，假设有1G内存可用。首先我们可以把10G的文件切分成10个1G的文件，再依次读文件，每次把1G的数据读入内存的数组中，接着利用快排对其进行排序，再把排好序的那1G的数据写到硬盘的一个文件，再继续读下一个1G的数据……当10个文件里的数据都分别有序时，再利用归并排序进行两两归并，最终使10G的数据有序。</p> 
</blockquote> 
<p><strong>1.算法思想：</strong></p> 
<p><strong>归并排序采用分治法。首先假设一组数据的左半区间有序，右半区间有序，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</strong></p> 
<p><strong>若将两个有序表合并成一个有序表，称为二路归并</strong>。</p> 
<p>所谓 <strong>归并，就是将两组有序的数据合成为一组有序的数据。</strong> 例如有如下两个有序数组，将两个有序数组归并为一个有序数组，这就是一次归并操作。</p> 
<p><img src="https://images2.imgbox.com/dd/bb/kV6BB2p3_o.png" alt="在这里插入图片描述"></p> 
<p><strong>2.归并操作的工作原理如下：</strong></p> 
<p><strong>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</strong></p> 
<p><strong>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置。</strong></p> 
<p><strong>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</strong></p> 
<p><strong>重复步骤3直到某一指针超出序列尾，将另一序列剩下的所有元素直接复制到合并序列尾。</strong></p> 
<p>归并排序<strong>类似于二叉树的后序遍历</strong>，<strong>即先将左右的区间都排为有序后，然后才开始进行归并操作</strong>，因为归并必须要满足两个数组是有序的。</p> 
<p>例如有如下数组。需要先将该数组每次都分割为两个区间，直到最后每个区间都只有一个值，此时比较两个值大小，然后将该两个值归并到一个数组中，此时就得到一个有两个元素的有序数组，然后再与另一个有两个元素的有序数组进行归并，然后就得到了一个有四个元素的有序数组，然后再与另一个有四个元素的有序数组进行归并，就得到了一个有八个元素的有序数组。就这样依次递归归并，直到最后目标数组为有序数组。</p> 
<p><img src="https://images2.imgbox.com/8b/d3/wAocueVo_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3.归并排序的代码实现如下：</strong></p> 
<pre><code class="prism language-c">
<span class="token comment">//把数组分成区间</span>
<span class="token keyword">void</span> <span class="token function">_MergrSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> tmp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//当区间内只有一个元素时，认为有序，递归结束，开始归并</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token punctuation">;</span>
		
     <span class="token comment">//右移1位右除以2的效果，用来把数组分成两个区间</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token comment">//假设[left mid] [mid+1 right]有序，就可以归并</span>
	<span class="token function">_MergrSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">_MergrSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">//每次归并的过程</span>
	<span class="token keyword">int</span> begin1 <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>
	<span class="token keyword">int</span> begin2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end2 <span class="token operator">=</span> right<span class="token punctuation">;</span>
	
	<span class="token comment">//注意：这里的index不要给0，因为在递归过程中left不一定等于0</span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> left<span class="token punctuation">;</span>
	
	<span class="token comment">//有一个区间结束就停止</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//当其中有一个区间结束时，另一个有序区间的数据直接拷贝进临时数组里</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		tmp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//最后把临时数组里面的数据拷贝回原数组</span>
	<span class="token comment">//注意：这里拷贝时有可能是局部区间拷贝，要加 begin</span>
	<span class="token function">memcpy</span><span class="token punctuation">(</span>arr<span class="token operator">+</span>begin<span class="token punctuation">,</span> tmp<span class="token operator">+</span>begin<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span>begin <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//也可以这样写</span>
	<span class="token comment">//for(int i = left; i &lt;= right; i++)</span>
	<span class="token comment">//	arr[i] = tmp[i];</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">MergrSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//创建临时数组存放数据</span>
	<span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token function">_MergrSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	tmp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>排序结果如下：<br> <img src="https://images2.imgbox.com/c3/63/Y8IuywxG_o.png" alt="在这里插入图片描述"></p> 
<p><strong>4.归并排序的时间复杂度和稳定性分析：</strong></p> 
<p><strong>1.归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题</strong>。</p> 
<p><strong>2. 时间复杂度：O(N*logN)</strong><br> <strong>3. 空间复杂度：O(N)</strong><br> <strong>4. 稳定性：稳定</strong></p> 
<h2><a id="2__126"></a>2. 计数排序</h2> 
<p>计数排序是一种非比较排序，即不需要直接比较数据之间的大小来进行排序。</p> 
<p><strong>1.算法思想：</strong></p> 
<p><strong>计数排序，是通过统计每一个数字出现的次数，并把它映射到与它自己本身数值相同的下标处，再遍历映射的数组使原数组有序的一种排序方法</strong>。</p> 
<p>计数排序的本质是一种哈希算法，也就是通过建立映射关系来达到排序的目的。</p> 
<p><strong>2.映射过程的图解如下：</strong></p> 
<p><strong>基本思路：</strong></p> 
<p>先开辟一个映射数组，然后遍历原数组，<strong>数组中的元素是几就在开辟的的映射数组下标为几的位置+1</strong>，得到的这个映射数组就包含了原数组中所有元素的映射关系，<strong>最后遍历一遍映射数组找出原数组中出现过的数即可</strong>。</p> 
<p><img src="https://images2.imgbox.com/c5/d2/1uKzPr9e_o.png" alt="在这里插入图片描述"><br> <strong>如图所示，原数组中有一个8，那么在映射数组的下标为8的位置记为1；原数组中有两个5，在映射数组的下标为5的位置记为2……以此类推。</strong></p> 
<p>但是这样映射也面临着一个问题，<strong>那就是我们开辟的数组到底要开多大的空间呢？</strong> 显然，我们在上述例子中开辟了10个整形空间的数组，但是可以看到，有5个位置都是空的，也就是说有五个位置的数都是没出现过的，这样子开辟空间显然是有些浪费了，我们上面的写法是一种<strong>绝对映射</strong>的写法，<strong>绝对映射就是这个数本身是多少就映射到下标为多少的位置</strong>，但是如果我给出以下这个数组让你排序呢？</p> 
<p><img src="https://images2.imgbox.com/94/15/7Ir5oAx9_o.png" alt="在这里插入图片描述"></p> 
<p>显然，以上数字的最大值是109，也就是说如果用绝对映射的方法那我们至少需要开110个空间，因为109要映射到下标为109的位置，下标从0开始，0-109就是110个数。但是仔细观察你会发现，这些数都是在100-109之间的，换句话说如果你开辟110个空间，那么前100个位置都是0，没有数映射，所以就等于是白白浪费了100个整形的空间，这显然是不能接受的。</p> 
<p>所以有人就想出来了一种<strong>相对映射</strong>的方法，<strong>把100映射到0的位置，把109映射到9的位置，其它的也以此类推</strong>，每个数在映射的时候都减去100，等到取出数据的时候在加上100就能得到原来的数了。这样一来，我们需要开10个整形的空间就可以了，大大减少了内存的消耗。</p> 
<p>那么真正开辟的空间该如何计算呢？</p> 
<blockquote> 
 <p><strong>开辟的空间的大小=最大元素-最小元素+1</strong><br> 例如上面的例子就是：开辟空间的大小=109-100+1=10<br> 为什么要+1？因为数组下标是从0开始的，如果不+1，那就是开辟9个空间，那么109就没法映射到109-100=9的位置了。</p> 
</blockquote> 
<p><strong>3.计数排序的代码实现如下：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">CountSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token comment">//找出最大值和最小值</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//求出范围，就是要开辟的空间的大小</span>
	<span class="token keyword">int</span> range <span class="token operator">=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> 

	<span class="token keyword">int</span><span class="token operator">*</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>range<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"calloc fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//统计每个数字出现的次数，相对映射到开辟的数组中</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//把数据进行排序，放回原数组中</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> range<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
		    <span class="token comment">//后置++，先用后加</span>
			arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> min<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token function">free</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
	count <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>排序结果如下：</p> 
<p><img src="https://images2.imgbox.com/46/bb/dEX4xI8F_o.png" alt="在这里插入图片描述"></p> 
<p><strong>4.归并排序的时间复杂度和稳定性分析：</strong></p> 
<p>1.计数排序的局限性在于它更加适用于<strong>范围集中的一组整型数据</strong>的排序，这时效率非常高，如果<strong>数据的范围较大(就是代码中的 range )，或是排序其他类型的数据</strong>，就可能不太适用。<br> <strong>2.时间复杂度：O(N+range)</strong><br> <strong>3.空间复杂度：O(range)</strong><br> <strong>4.稳定性：稳定</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e760d2b48d560f7a55c3c25712221014/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux 端口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2d8c89ca382ba9bb702e49355b8cfff5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">240705_昇思学习打卡-Day17-基于 MindSpore 实现 BERT 对话情绪识别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>