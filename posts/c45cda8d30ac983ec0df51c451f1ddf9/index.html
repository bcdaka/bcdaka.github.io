<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大数据知识总结（七）：Spark重要知识汇总 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c45cda8d30ac983ec0df51c451f1ddf9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="大数据知识总结（七）：Spark重要知识汇总">
  <meta property="og:description" content="文章目录
Spark重要知识汇总
一、Spark 是什么
二、Spark 四大特点
三、Spark框架模块介绍
3.1、Spark Core的RDD详解
3.1.1、什么是RDD
3.1.2、RDD是怎么理解的
四、Spark 运行模式
4.1、Spark本地模式介绍
4.2、Spark集群模式 Standalone
4.3、Spark集群模式 Standalone HA
4.4、Spark集群模式 Spark on YARN介绍
4.5、Spark On Yarn两种模式总结
五、Spark应用架构基本介绍
Spark重要知识汇总 一、Spark 是什么 大规模数据处理的统一分析引擎，也可说是分布式内存迭代计算框架。
二、Spark 四大特点 速度快（内存计算）易于使用（支持了包括 Java、Scala、Python 、R和SQL语言在内的多种语言）通用性强（提供了包括Spark SQL、Spark Streaming、MLib 及GraphX在内的多个工具库）运行方式多（包括在 Hadoop 和 Mesos 上，也支持 Standalone的独立运行模式，同时也可以运行在云Kubernetes（Spark 2.3开始支持）上） 三、Spark框架模块介绍 Spark Core（实现了 Spark 的基本功能，包含RDD、任务调度、内存管理、错误恢复、与存储系统交互等模块。数据结构：RDD）Spark SQL（可以使用 SQL操作数据。数据结构：Dataset/DataFrame = RDD &#43; Schema）Spark Streaming（用来操作数据流的 API。 数据结构：DStream = Seq[RDD]）Spark MLlib（提供常见的机器学习(ML)功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据导入等额外的支持功能。 数据结构：RDD或者DataFrame）Spark GraphX（用于图计算的API，性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。数据结构：RDD或者DataFrame）Structured Streaming（结构化流处理模块，针对流式结构化数据封装到DataFrame中进行分析） 3.1、Spark Core的RDD详解 3.1.1、什么是RDD RDD（Resilient Distributed Dataset）弹性分布式数据集，是Spark中最基本的数据抽象，代表一个不可变、可分区、里面的元素可并行计算的集合。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-02T11:07:23+08:00">
    <meta property="article:modified_time" content="2024-09-02T11:07:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据知识总结（七）：Spark重要知识汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/97/74/XJZvwI3v_o.jpg"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="Spark%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-toc" style="margin-left:0px;"><a href="#Spark%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB" rel="nofollow">Spark重要知识汇总</a></p> 
<p id="%E4%B8%80%E3%80%81Spark%20%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81Spark%20%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">一、Spark 是什么</a></p> 
<p id="%E4%BA%8C%E3%80%81Spark%20%E5%9B%9B%E5%A4%A7%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81Spark%20%E5%9B%9B%E5%A4%A7%E7%89%B9%E7%82%B9" rel="nofollow">二、Spark 四大特点</a></p> 
<p id="%E4%B8%89%E3%80%81Spark%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81Spark%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D" rel="nofollow">三、Spark框架模块介绍</a></p> 
<p id="3.1%E3%80%81Spark%20Core%E7%9A%84RDD%E8%AF%A6%E8%A7%A3-toc" style="margin-left:80px;"><a href="#3.1%E3%80%81Spark%20Core%E7%9A%84RDD%E8%AF%A6%E8%A7%A3" rel="nofollow">3.1、Spark Core的RDD详解</a></p> 
<p id="3.1.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRDD-toc" style="margin-left:120px;"><a href="#3.1.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRDD" rel="nofollow">3.1.1、什么是RDD</a></p> 
<p id="3.1.2%E3%80%81RDD%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84-toc" style="margin-left:120px;"><a href="#3.1.2%E3%80%81RDD%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84" rel="nofollow">3.1.2、RDD是怎么理解的</a></p> 
<p id="%E5%9B%9B%E3%80%81Spark%20%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81Spark%20%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F" rel="nofollow">四、Spark 运行模式</a></p> 
<p id="4.1%E3%80%81Spark%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#4.1%E3%80%81Spark%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D" rel="nofollow">4.1、Spark本地模式介绍</a></p> 
<p id="4.2%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Standalone-toc" style="margin-left:80px;"><a href="#4.2%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Standalone" rel="nofollow">4.2、Spark集群模式 Standalone</a></p> 
<p id="4.3%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Standalone%20HA-toc" style="margin-left:80px;"><a href="#4.3%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Standalone%20HA" rel="nofollow">4.3、Spark集群模式 Standalone HA</a></p> 
<p id="4.4%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Spark%20on%20YARN%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#4.4%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Spark%20on%20YARN%E4%BB%8B%E7%BB%8D" rel="nofollow">4.4、Spark集群模式 Spark on YARN介绍</a></p> 
<p id="4.5%E3%80%81Spark%20On%20Yarn%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#4.5%E3%80%81Spark%20On%20Yarn%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93" rel="nofollow">4.5、Spark On Yarn两种模式总结</a></p> 
<p id="%E4%BA%94%E3%80%81Spark%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81Spark%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" rel="nofollow">五、Spark应用架构基本介绍</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2><strong>Spark重要知识汇总</strong></h2> 
<h3 id="%E4%B8%80%E3%80%81Spark%20%E6%98%AF%E4%BB%80%E4%B9%88"><strong>一、Spark 是什么</strong></h3> 
<p>大规模数据处理的统一分析引擎，也可说是分布式内存迭代计算框架。</p> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81Spark%20%E5%9B%9B%E5%A4%A7%E7%89%B9%E7%82%B9"><strong>二、Spark 四大特点</strong></h3> 
<ul><li><strong>速度快</strong>（内存计算）</li><li><strong>易于使用</strong>（支持了包括 Java、Scala、Python 、R和SQL语言在内的多种语言）</li><li><strong>通用性强</strong>（提供了包括Spark SQL、Spark Streaming、MLib 及GraphX在内的多个工具库）</li><li><strong>运行方式多</strong>（包括在 Hadoop 和 Mesos 上，也支持 Standalone的独立运行模式，同时也可以运行在云Kubernetes（Spark 2.3开始支持）上）</li></ul> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81Spark%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D">三、Spark框架模块介绍</h3> 
<ul><li><strong>Spark Core</strong>（实现了 Spark 的基本功能，包含RDD、任务调度、内存管理、错误恢复、与存储系统交互等模块。数据结构：RDD）</li><li><strong>Spark SQL</strong>（可以使用 SQL操作数据。数据结构：Dataset/DataFrame = RDD + Schema）</li><li><strong>Spark Streaming</strong>（用来操作数据流的 API。 数据结构：DStream = Seq[RDD]）</li><li><strong>Spark MLlib</strong>（提供常见的机器学习(ML)功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据导入等额外的支持功能。 数据结构：RDD或者DataFrame）</li><li><strong>Spark GraphX</strong>（用于图计算的API，性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。数据结构：RDD或者DataFrame）</li><li><strong>Structured Streaming</strong>（结构化流处理模块，针对流式结构化数据封装到DataFrame中进行分析）</li></ul> 
<p></p> 
<h4 id="3.1%E3%80%81Spark%20Core%E7%9A%84RDD%E8%AF%A6%E8%A7%A3"><strong>3.1、Spark Core的RDD详解</strong></h4> 
<h5 id="3.1.1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRDD"><strong>3.1.1、什么是RDD</strong></h5> 
<p>RDD（Resilient Distributed Dataset）弹性分布式数据集，是Spark中最基本的数据抽象，代表一个<strong>不可变、可分区、里面的元素可并行计算的集合</strong>。</p> 
<p></p> 
<h5 id="3.1.2%E3%80%81RDD%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84"><strong>3.1.2、RDD是怎么理解的</strong></h5> 
<p><strong>1、概念：</strong>RDD是弹性分布式数据集（Resilient Distributed Dataset）</p> 
<p><strong>2、RDD有五大特性：</strong></p> 
<p><strong>分区列表（A List of Partitions）</strong></p> 
<ol><li> <p>一组分片(Partition)/一个分区(Partition)列表，即数据集的基本组成单位。</p> </li><li> <p>对于RDD来说，每个分片都会被一个计算任务处理，分片数决定并行度。</p> </li><li> <p>用户可以在创建RDD时指定RDD的分片个数，如果没有指定，那么就会采用默认值。</p> </li></ol> 
<p><strong>计算函数（A Function for Computing Each Partition)</strong></p> 
<ol><li> <p>一个函数会被作用在每一个分区。</p> </li><li> <p>Spark中RDD的计算是以分片为单位的，compute函数会被作用到每个分区上。</p> </li></ol> 
<p><strong>依赖关系（Lineage/Dependency）</strong></p> 
<ol><li> <p>一个RDD会依赖于其他多个RDD。</p> </li><li> <p>RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算（Spark的容错机制）。</p> </li></ol> 
<p><strong>分区函数（Partitioner for Key-Value RDDs，可选）</strong></p> 
<ol><li> <p>可选项,对于KeyValue类型的RDD会有一个Partitioner，即RDD的分区函数。</p> </li><li> <p>当前Spark中实现了两种类型的分区函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。</p> </li><li> <p>只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。</p> </li><li> <p>Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。</p> </li><li> <p>对key-value的类型RDD的默认分区HashPartitoner。</p> </li></ol> 
<p><strong>位置优先性（Location Preference，可选）</strong></p> 
<ol><li> <p>可选项，一个列表，存储存取每个Partition的优先位置(preferred location)。</p> </li><li> <p>对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。</p> </li><li> <p>按照"移动数据不如移动计算"的理念，Spark在进行任务调度的时候，会尽可能选择那些存有数据的worker节点来进行任务计算。（数据本地性）</p> </li></ol> 
<p><img alt="" height="393" src="https://images2.imgbox.com/73/5f/3ai4oIuh_o.png" width="832"></p> 
<p><strong>WordCount中RDD</strong></p> 
<pre><code class="language-Scala">sc.textFile().flatmap().map().reduceByKey()</code></pre> 
<p>在内部，每个RDD都有五个主要特性：</p> 
<ol><li> <p>分区列表：每个RDD都有会分区的概念，类似于HDFS的分块, 分区的目的:提高并行度。</p> </li><li> <p>用于计算每个分区的函数:用函数来操作各个分区中的数据。</p> </li><li> <p>对其他RDD的依赖列表:后面的RDD需要依赖前面的RDD。</p> </li><li> <p>可选地，键值RDDs的分区器。（例如，reduceByKey中的默认的Hash分区器）</p> </li><li> <p>可选地，计算每个分区的首选位置列表/最佳位置。（例如HDFS文件）</p> </li></ol> 
<p><img alt="" height="480" src="https://images2.imgbox.com/21/0f/XL6tB1nr_o.png" width="1200"></p> 
<p><strong>3、RDD的宽依赖和窄依赖：</strong></p> 
<p><strong>窄依赖定义：</strong></p> 
<p>窄依赖指的是每一个父RDD的Partition（分区）最多被子RDD的一个Partition使用。这种依赖关系形象地比喻为“独生子女”，即一个父RDD的分区只对应一个子RDD的分区（或几个父RDD的分区对应一个子RDD的分区，但仍然是“一对一”的关系）。</p> 
<p><strong>特点：</strong></p> 
<ol><li> <p>高效执行：窄依赖支持在一个节点上管道化执行，例如，在filter之后可以直接执行map操作，无需移动数据。</p> </li><li> <p>快速容错：当子RDD的某个分区数据丢失时，只需要重新计算对应的父RDD分区即可，不需要重新计算整个RDD。</p> </li><li> <p>操作类型：常见的窄依赖操作包括map、filter、union（特定条件下）等。</p> </li></ol> 
<p><strong>宽依赖定义：</strong></p> 
<p>宽依赖指的是多个子RDD的Partition会依赖同一个父RDD的Partition。这种依赖关系形象地比喻为“超生”，即一个父RDD的分区会被多个子RDD的分区所使用。</p> 
<p><strong>特点：</strong></p> 
<ol><li> <p>Shuffle操作：宽依赖通常涉及Shuffle操作，即数据需要在不同节点间重新分布。Shuffle操作是耗时的，因为它涉及磁盘I/O、数据序列化和网络I/O。</p> </li><li> <p>低效容错：当子RDD的某个分区数据丢失时，由于宽依赖的特性，可能需要重新计算父RDD的所有分区才能恢复数据。</p> </li><li> <p>操作类型：常见的宽依赖操作包括groupByKey、reduceByKey、sortByKey、join（输入未协同划分）等。</p> </li></ol> 
<p><strong>注意：</strong>根据父RDD有一个或多个子RDD对应，因为窄依赖可以在任务间并行，宽依赖会发生Shuffle，并不是所有的bykey算子都会产生shuffle？需要注意的是（1）分区器一致（2）分区个数一致</p> 
<p></p> 
<p><strong>4、RDD血缘关系linage：</strong></p> 
<p>linage会记录当前RDD依赖于上一个RDD，如果一个RDD失效可以重建RDD，容错关键。</p> 
<p><strong>RDD血缘关系的作用</strong></p> 
<ul><li> <p>容错机制：RDD血缘关系的主要作用是支持Spark的容错机制。由于RDD是不可变的，并且只支持粗粒度转换（即在大量记录上执行的单个操作），因此当RDD的某个分区数据丢失时，Spark可以根据血缘关系图重新计算丢失的数据分区，而无需重新计算整个RDD。</p> </li><li> <p>优化执行计划：Spark的执行引擎可以利用RDD血缘关系来优化作业的执行计划。例如，通过识别窄依赖和宽依赖，Spark可以决定如何切分作业为不同的阶段（Stages），并在不同的节点上并行执行这些阶段。</p> </li></ul> 
<p><strong>RDD的缓存：</strong>cache和persist，cache会将数据缓存在内存中，persist可以指定多种存储级别，cache底层调用的是persist。</p> 
<ul><li> <p>cache()方法：这是RDD缓存的简化形式，它等价于调用<code>persist(StorageLevel.MEMORY_ONLY)</code>。即，将数据以未序列化的Java对象形式存储在JVM的堆内存中。</p> </li><li> <p>persist()方法：这是一个更通用的方法，允许用户指定缓存的级别。通过传递一个<code>StorageLevel</code>对象作为参数，用户可以控制数据是存储在内存中、磁盘上，还是两者都存储，以及是否进行序列化等。</p> </li></ul> 
<p><strong>缓存级别</strong></p> 
<p>Spark提供了以下几种缓存级别（<code>StorageLevel</code>）：</p> 
<ul><li> <p>MEMORY_ONLY：将RDD以未序列化的Java对象形式存储在JVM的堆内存中。如果内存不足，则某些分区可能不会被缓存，而是会在需要时重新计算。</p> </li><li> <p>MEMORY_AND_DISK：将RDD以未序列化的Java对象形式存储在JVM的堆内存中。如果内存不足，则将未缓存的分区存储在磁盘上。</p> </li><li> <p>MEMORY_ONLY_SER：将RDD以序列化的Java对象形式存储（每个分区为一个字节数组）。这种方式比未序列化的对象更节省空间，但读取时会增加CPU的负担。</p> </li><li> <p>MEMORY_AND_DISK_SER：类似于MEMORY_ONLY_SER，但如果内存不足，则将溢出的分区存储在磁盘上。</p> </li><li> <p>DISK_ONLY：将RDD仅存储在磁盘上。</p> </li><li> <p>OFF_HEAP：将数据存储在堆外内存中，这通常涉及额外的配置和可能的内存管理问题。</p> </li></ul> 
<p></p> 
<p><strong>5、RDD的检查点机制：</strong></p> 
<p><strong>Checkpoint</strong>会截断所有的血缘关系，而缓存会将血缘的关系全部保存在内存或磁盘中。</p> 
<p><strong>5.1、检查点机制的基本概念</strong></p> 
<p>检查点机制允许用户将RDD的中间结果持久化到可靠的文件系统（如HDFS）中，以便在出现节点故障或数据丢失时，能够快速地恢复RDD的状态，而不需要重新计算整个RDD的依赖链。这可以大大减少数据恢复的时间和计算资源的消耗。</p> 
<p><strong>5.2、检查点机制的工作流程</strong></p> 
<ul><li> <p>设置检查点目录：首先，需要使用<code>SparkContext</code>的<code>setCheckpointDir()</code>方法设置一个检查点目录，该目录用于存储检查点数据。这个目录应该是可靠的文件系统，如HDFS。</p> </li><li> <p>标记RDD为检查点：然后，使用需要持久化的RDD的<code>checkpoint()</code>方法将该RDD标记为检查点。此时，并不会立即执行检查点操作，而是会在遇到第一个行动操作（如<code>collect()</code>、<code>count()</code>等）时触发。</p> </li><li> <p>执行检查点操作：当遇到第一个行动操作时，Spark会启动一个新的作业来计算被标记为检查点的RDD，并将其结果写入之前设置的检查点目录中。同时，Spark会移除该RDD的所有依赖关系，因为在未来需要恢复该RDD时，可以直接从检查点目录中读取数据，而不需要重新计算依赖链。</p> </li><li> <p>数据恢复：如果在后续的计算过程中出现了节点故障或数据丢失，Spark可以根据需要从检查点目录中恢复RDD的状态，从而继续执行后续的计算任务。</p> </li></ul> 
<p><strong>5.3、检查点机制的优点</strong></p> 
<ul><li> <p>提高容错性：通过将RDD的中间结果持久化到可靠的文件系统中，可以在出现节点故障或数据丢失时快速恢复RDD的状态，从而提高Spark作业的容错性。</p> </li><li> <p>减少计算开销：在宽依赖的RDD上设置检查点可以显著减少计算开销，因为当需要恢复宽依赖的RDD时，只需要重新计算从检查点开始的部分，而不是整个RDD的依赖链。</p> </li><li> <p>优化性能：通过将经常使用的RDD持久化到外部存储中，可以避免在多次计算中重复计算相同的RDD，从而优化Spark作业的性能。</p> </li></ul> 
<p></p> 
<h3 id="%E5%9B%9B%E3%80%81Spark%20%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><strong>四、Spark 运行模式</strong></h3> 
<ul><li><strong>本地模式-Local Mode</strong>（Task运行在一个本地JVM Process进程中，通常开发测试使用）</li><li><strong>集群模式-Cluster Mode</strong>（Hadoop YARN集群，Spark 自身集群Standalone及Apache Mesos集群）</li><li><strong>Kubernetes 云服务模式-Cloud</strong>（AWS 阿里云 腾讯云 等等云平台都提供了 EMR产品）</li></ul> 
<p></p> 
<h4 id="4.1%E3%80%81Spark%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D">4.1<strong>、Spark本地模式介绍</strong></h4> 
<p>两类角色：</p> 
<p>一个是Master类似Namenode做管理</p> 
<p>一个是Worker类似DataNode是干活的</p> 
<p>Local模式就是，以一个JVM进程，去模拟整个Spark的运行环境，就是讲Master和Worker角色以线程的形式运行在这个进程中。</p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/ae/c8/GJvq6rEY_o.png" width="708"></p> 
<p>WEB UI监控页面，默认端口号 4040</p> 
<p></p> 
<h4 id="4.2%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Standalone">4.2、Spark集群模式 Standalone</h4> 
<p>Standalone模式是真实地在多个机器之间搭建Spark集群的环境，完全可以利用该模式搭建多机器集群，用于实际的大数据处理</p> 
<p>两个角色：master和worker</p> 
<p>架构：</p> 
<p>Standalone集群使用了分布式计算中的master-slave模型，master是集群中含有Master进程的节点，slave是集群中的Worker节点含有Executor进程。</p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/ca/d3/pTSsygf2_o.png" width="715"></p> 
<p>WEB UI页面<strong> 8080</strong></p> 
<p>SparkContext web UI <strong>4040</strong></p> 
<p>Master的IP和提交任务的通信端口 <strong>7077</strong></p> 
<p></p> 
<h4 id="4.3%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Standalone%20HA">4.3、Spark集群模式 Standalone HA</h4> 
<p><strong>高可用HA</strong></p> 
<p>文件系统的单点恢复（Single-Node Recovery with Local File System）只能用于开发或测试环境</p> 
<p>基于zookeeper的Standby Masters（Standby Masters with ZooKeeper）可以用于生产环境</p> 
<p class="img-center"><img alt="" height="532" src="https://images2.imgbox.com/35/88/V78nCEC5_o.png" width="1160"></p> 
<p class="img-center"><img alt="" height="275" src="https://images2.imgbox.com/51/fe/KoQ38vam_o.png" width="619"></p> 
<p></p> 
<h4 id="4.4%E3%80%81Spark%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%20Spark%20on%20YARN%E4%BB%8B%E7%BB%8D"><strong>4.4、Spark集群模式 Spark on YARN介绍</strong></h4> 
<p><strong>Spark</strong>运行在YARN上是有2个模式的， 1个叫<strong> Client模式</strong> 一个叫<strong>Cluster模式</strong></p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/03/c4/lKaiyRgQ_o.png" width="952"></p> 
<p>Spark HistoryServer服务WEB UI页面端口 <strong>18080</strong></p> 
<p><strong>总结:</strong></p> 
<p>Spark On Yarn 不需要搭建Spark集群，只需要:Yarn+单机版Spark，当然还要一些配置。</p> 
<p></p> 
<h4 id="4.5%E3%80%81Spark%20On%20Yarn%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">4.5、Spark On Yarn两种模式总结</h4> 
<p><strong>cluster和client模式最最本质的区别是：</strong><strong>Driver程序运行在哪里</strong></p> 
<p>而Driver程序运行的位置可以通过--deploy-mode 来指定</p> 
<p>企业实际生产环境中使用<strong>cluster</strong></p> 
<p><strong>client 模式</strong></p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/4a/7f/Q506d8B6_o.png" width="699"></p> 
<p><strong>cluster 模式</strong></p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/b0/6f/4XM2PkHP_o.png" width="673"></p> 
<p><strong>Client模式：学习测试时使用，开发不用，了解即可</strong></p> 
<ul><li> <p>Driver运行在Client上，和集群的通信成本高</p> </li><li> <p>Driver输出结果会在客户端显示</p> </li></ul> 
<p><strong>Cluster模式：生产环境中使用该模式</strong></p> 
<ul><li> <p>Driver程序在Yarn集群中，和集群的通信成本低</p> </li><li> <p>Driver输出结果不能在客户端显示</p> </li><li> <p>该模式下Driver运行ApplicattionMaster这个节点上，由Yarn管理，如果出现问题，Yarn会重启ApplicattionMaster（Driver）</p> </li></ul> 
<p></p> 
<h3 id="%E4%BA%94%E3%80%81Spark%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">五<strong>、Spark应用架构基本介绍</strong></h3> 
<p><img alt="" height="588" src="https://images2.imgbox.com/09/09/KckMmpy6_o.png" width="1200"></p> 
<p><strong>用户程序从最开始的提交到最终的计算执行，需要经历以下几个阶段：</strong></p> 
<ol><li> <p>用户程序创建 SparkContext 时，新创建的 SparkContext 实例会连接到 ClusterManager。 Cluster Manager 会根据用户提交时设置的 CPU 和内存等信息为本次提交分配计算资源，启动 Executor。</p> </li><li> <p>Driver会将用户程序划分为不同的执行阶段Stage，每个执行阶段Stage由一组完全相同Task组成，这些Task分别作用于待处理数据的不同分区。在阶段划分完成和Task创建后， Driver会向Executor发送 Task。</p> </li><li> <p>Executor在接收到Task后，会下载Task的运行时依赖，在准备好Task的执行环境后，会开始执行Task，并且将Task的运行状态汇报给Driver。</p> </li><li> <p>Driver会根据收到的Task的运行状态来处理不同的状态更新。 Task分为两种：一种是Shuffle Map Task，它实现数据的重新洗牌，洗牌的结果保存到Executor 所在节点的文件系统中；另外一种是Result Task，它负责生成结果数据；</p> </li><li> <p>Driver 会不断地调用Task，将Task发送到Executor执行，在所有的Task 都正确执行或者超过执行次数的限制仍然没有执行成功时停止。</p> </li></ol> 
<p></p> 
<p><strong>Job、DAG和Stage：</strong></p> 
<p>一个Spark Application中，包含多个Job，每个Job有多个Stage组成，每个Job执行按照DAG图进行的，其中每个Stage中包含多个Task任务，每个Task以线程Thread方式执行，需要1Core CPU。</p> 
<p><img alt="" height="628" src="https://images2.imgbox.com/88/a0/c8lZYhm7_o.png" width="649"></p> 
<p><strong>Spark Application程序运行时三个核心概念：Job、Stage、Task，说明如下：</strong></p> 
<p><strong>Task：</strong>被分配到各个 Executor 的单位工作内容，它是 Spark 中的最小执行单位，一般来说有多少个 Paritition，就会有多少个 Task，每个 Task 只会处理单一分支上的数据。</p> 
<p><strong>Job：</strong>由多个 Task 的并行计算部分，一般 Spark 中的 action 操作（如 save、collect），会生成一个 Job。</p> 
<p><strong>Stage：</strong>Job 的组成单位，一个 Job 会切分成多个 Stage，Stage 彼此之间相互依赖顺序执行，而每个 Stage 是多个 Task 的集合，类似 map 和 reduce stage。</p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/0a/08/ksxySNc2_o.png" width="754"></p> 
<hr> 
<ul><li> <p>📢博客主页：<a href="https://lansonli.blog.csdn.net/" rel="nofollow" title="https://lansonli.blog.csdn.net">https://lansonli.blog.csdn.net</a></p> </li></ul> 
<ul><li> <p>📢欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！</p> </li></ul> 
<ul><li> <p>📢本文由 Lansonli 原创，首发于 CSDN博客🙉</p> </li><li> <p>📢停下休息的时候不要忘了别人还在奔跑，希望大家抓紧时间学习，全力奔赴更美好的生活✨</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4ca4622187cfb874c27eb22423b69f8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">中兴-ZSRV2路由器-任意文件读取</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b8688d73dd79ae3f2508feb9af853881/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——9.模板进阶</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>