<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[动态规划]---part2 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e3bd7f738ee9bbf2d2087e316f540a5c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[动态规划]---part2">
  <meta property="og:description" content="前言
作者：小蜗牛向前冲
专栏：小蜗牛算法之路
专栏介绍：&#34;蜗牛之道，攀登大厂高峰，让我们携手学习算法。在这个专栏中，将涵盖动态规划、贪心算法、回溯等高阶技巧，不定期为你奉上基础数据结构的精彩算法之旅。一同努力，追逐技术的星辰大海。&#34;
目录
一、不同路径II（medium）
a、解题思路 b、代码
二、礼物的最⼤价值（medium）
a、解题思路 b、代码
三、 下降路径最⼩和（medium）
a、解题思路 b、代码
四、 最⼩路径和（medium）
a、解题思路 b、代码
五、地下城游戏（hard） a、解题思路 b、代码
本期：继续手撕动态规划：不同路径II（medium），礼物的最⼤价值（medium），下降路径最⼩和（medium），最⼩路径和（medium），地下城游戏（hard）
继续刷动态规划相关算法题，如果不清楚什么是动态规划的可以看这里：[动态规划]---part1
一、不同路径II（medium） 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
示例 1：
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T08:49:22+08:00">
    <meta property="article:modified_time" content="2024-03-07T08:49:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[动态规划]---part2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>前言</strong></p> 
 <p><img alt="" height="28" src="https://images2.imgbox.com/43/43/WQ7Yim6x_o.png" width="28"><strong><span style="color:#956fe7;">作者</span>：小蜗牛向前冲</strong></p> 
 <p><img alt="" height="28" src="https://images2.imgbox.com/22/6c/9v59MFxv_o.png" width="28"><strong><span style="color:#956fe7;">专栏</span>：</strong><strong>小蜗牛算法之路</strong></p> 
 <p> <img alt="" height="28" src="https://images2.imgbox.com/15/e2/u1BBZMaY_o.png" width="28"><strong>专栏介绍：<span style="color:#fe2c24;">"蜗牛之道，攀登大厂高峰，让我们携手学习算法。在这个专栏中，将涵盖动态规划、贪心算法、回溯等高阶技巧，不定期为你奉上基础数据结构的精彩算法之旅。一同努力，追逐技术的星辰大海。</span>"</strong></p> 
 <p><strong> </strong><img alt="" height="471" src="https://images2.imgbox.com/70/62/qEeSFfoI_o.png" width="1114"></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%EF%BC%88medium%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%EF%BC%88medium%EF%BC%89" rel="nofollow">一、不同路径II（medium）</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:40px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E2%BC%A4%E4%BB%B7%E5%80%BC%EF%BC%88medium%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E2%BC%A4%E4%BB%B7%E5%80%BC%EF%BC%88medium%EF%BC%89" rel="nofollow">二、礼物的最⼤价值（medium）</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:40px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<p id="%E4%B8%89%E3%80%81%C2%A0%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E2%BC%A9%E5%92%8C%EF%BC%88medium%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%C2%A0%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E2%BC%A9%E5%92%8C%EF%BC%88medium%EF%BC%89" rel="nofollow">三、 下降路径最⼩和（medium）</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:40px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<p id="%E5%9B%9B%E3%80%81%20%E6%9C%80%E2%BC%A9%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88medium%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%20%E6%9C%80%E2%BC%A9%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88medium%EF%BC%89" rel="nofollow">四、 最⼩路径和（medium）</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:40px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%EF%BC%88hard%EF%BC%89%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%EF%BC%88hard%EF%BC%89%C2%A0" rel="nofollow">五、地下城游戏（hard） </a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:40px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<hr id="hr-toc"> 
<p>本期：继续手撕动态规划：不同路径II（medium），礼物的最⼤价值（medium），下降路径最⼩和（medium），最⼩路径和（medium），地下城游戏（hard）</p> 
<p>继续刷动态规划相关算法题，如果不清楚什么是动态规划的可以看这里：<a class="link-info" href="https://blog.csdn.net/qq_61552595/article/details/136394945?spm=1001.2014.3001.5502" title="[动态规划]---part1">[动态规划]---part1</a></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%EF%BC%88medium%EF%BC%89">一、<a class="link-info" href="https://leetcode.cn/problems/unique-paths-ii/description/" rel="nofollow" title="不同路径II（medium）">不同路径II（medium）</a></h2> 
<blockquote> 
 <p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p> 
 <p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p> 
 <p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p> 
 <p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/ad/6c/m7sQKbc3_o.jpg" width="242"></p> 
 <pre><strong>输入：</strong>obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
<strong>输出：</strong>2
<strong>解释：</strong>3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 <code>2</code> 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/15/c4/fwPAkDrC_o.jpg" width="162"></p> 
 <pre><strong>输入：</strong>obstacleGrid = [[0,1],[0,0]]
<strong>输出：</strong>1
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul> 
</blockquote> 
<pre><code class="language-cpp">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {

    }
};</code></pre> 
<h3 id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0">a、解题思路 </h3> 
<p>这道题和同路径I的解题思路非常相似，但是就是在机器人找 到终点的过程中，会有障碍物。</p> 
<p><strong>1、转态表示</strong></p> 
<p>首先我们想以i，j位置为结尾表示什么</p> 
<p>dp[i][j表示：以i,j位置结尾的时候，机器人到这里有多少条路径</p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分：</p> 
<blockquote> 
 <p>当前位置有障碍物：</p> 
 <p>返回0</p> 
 <p>当前位置没有障碍物：</p> 
 <p>dp[i][j] = dp[i-1][j]+dp[i][j-1];</p> 
</blockquote> 
<p><img alt="" height="195" src="https://images2.imgbox.com/bb/8a/qIa0MXSZ_o.png" width="1022"></p> 
<p>大家可能会想，我要是在[i-1][j]或者[i][j-1]遇到障碍物了，状态转态方程还可以相加吗?</p> 
<p>其实是可能的，因为我在遇到障碍物是返回0的，而0对相加的结果是没有影响的。 </p> 
<p>3、初始化</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/a2/da/H3Ck2F0L_o.png" width="1043"></p> 
<p>这里我们要初始化，就是在二维数组多开一行和一列，但我们要思路多开的行列填什么呢（一切都是为了填表走服务）？，很明显，机器人是在[1,1]位置开始走的，也就说[1,1]位置肯定要为1（当最特色情况起点就是中点），所以我们只要保证，dp[1][0]==1或者dp[0][1]==1即可。其他位置看情况决定。</p> 
<p>这里除了要注意填表的初始化，还要注意下标映射关心的改变：</p> 
<blockquote> 
 <p> obstacleGrid[0][0]--------&gt;映射dp[1][1];</p> 
 <p> obstacleGrid[2][3]--------&gt;映射dp[3][4];</p> 
 <p>也就是横着纵坐标都要加1</p> 
</blockquote> 
<p>4、 填表顺序</p> 
<p>从上往下填写每一行，每一行都是从左往又开始填写 </p> 
<p>5、返回值</p> 
<p>dp[m][n]</p> 
<h3 id="b%E3%80%81%E4%BB%A3%E7%A0%81">b、代码</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid)
    {
        int m = obstacleGrid.size();//有多少行
        int n = obstacleGrid[0].size();//有多少列

        //创建dp表
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));

        //初始化
        dp[1][0] = 1;

        //填表
        for (int i = 1; i &lt;= m; i++)
        {
            for (int j = 1; j &lt;= n; j++)
            {
                if (obstacleGrid[i - 1][j - 1] == 1)
                {
                    dp[i][j] = 0;
                }
                else
                {
                    dp[i][j] = dp[i][j - 1] + dp[i-1][j];
                }
            }
        }

        //返回
        return dp[m][n];

    }
};</code></pre> 
<p> <strong>Leetcode 测试结果： </strong> <img alt="" height="663" src="https://images2.imgbox.com/da/91/EWl4F22e_o.png" width="903"> </p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E2%BC%A4%E4%BB%B7%E5%80%BC%EF%BC%88medium%EF%BC%89">二、礼物的最⼤价值（medium）</h2> 
<blockquote> 
 <p>现有一个记作二维矩阵 <code>frame</code> 的珠宝架，其中 <code>frame[i][j]</code> 为该位置珠宝的价值。拿取珠宝的规则为：</p> 
 <ul><li>只能从架子的左上角开始拿珠宝</li><li>每次可以移动到右侧或下侧的相邻位置</li><li>到达珠宝架子的右下角时，停止拿取</li></ul> 
 <p>注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 <code>frame = [[0]]</code>。</p> 
 <p></p> 
 <p><strong>示例 1:</strong></p> 
 <pre><strong>输入:</strong> frame = [[1,3,1],[1,5,1],[4,2,1]]
<strong>输出:</strong> <code>12
</code><strong>解释:</strong> 路径 1→3→5→2→1 可以拿到最高价值的珠宝</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>0 &lt; frame.length &lt;= 200</code></li><li><code>0 &lt; frame[0].length &lt;= 200</code></li></ul> 
</blockquote> 
<p></p> 
<pre><code class="language-cpp">class Solution {
public:
    int jewelleryValue(vector&lt;vector&lt;int&gt;&gt;&amp; frame) {

    }
};</code></pre> 
<h3>a、解题思路 </h3> 
<p>这种路径题目极大可能用动态规划求解</p> 
<p><strong>1、转态表示</strong><img alt="" height="228" src="https://images2.imgbox.com/18/00/45Pj6PEZ_o.png" width="1200"></p> 
<p>首先我们想以i，j位置为结尾表示什么</p> 
<p>dp[i][j表示：以i,j位置结尾的时候，此时礼物的最大值</p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分：</p> 
<blockquote> 
 <p>从[i-1][j]------&gt;[i][j]：</p> 
 <p>那礼物的不就是dp[i-1][j]+frmae[i-1][j-1];（frmae的坐标是映射过的）</p> 
 <p>从[i][jj-1]------&gt;[i][j]：</p> 
 <p>那礼物的不就是dp[i][j-1]+frmae[i-1][j-1];</p> 
</blockquote> 
<p>但是我们要求的是拿到礼物的最大值：</p> 
<p> <strong>状态转移方程：dp[i][jj = max(</strong>dp[i-1][j],dp[i][j-1])+frmae[i][j];</p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/4d/c2/InqlDZRK_o.png" width="1200"></p> 
<p></p> 
<p>3、初始化</p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/e0/7e/fKEDL8PW_o.png" width="1187"></p> 
<p>这里的初始化就非常简单了，对应[1][1]位置我们肯定是要保证他在填表的时候不变的，那么[1][0]和[0][1]位置肯定是0,至于0行，0列后面的，按理来说是要初始化为负无穷的，但因为礼物值&gt;=0，所以初始化为0也可以。(这里就不用我们初始化了，因为vector是有初始化功能的)</p> 
<p>4、 填表顺序</p> 
<p>从上往下填写每一行，每一行都是从左往又开始填写 </p> 
<p>5、返回值</p> 
<p>dp[m][n]</p> 
<h3>b、代码</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int jewelleryValue(vector&lt;vector&lt;int&gt;&gt;&amp; frame)
    {
        int m = frame.size();//行
        int n = frame[0].size();//列

        //创建dp表
        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1));

        //初始化，vector已经完成

        //填表
        for(int i = 1;i&lt;=m;i++)
        {
            for(int j = 1;j&lt;=n;j++)
            {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + frame[i-1][j-1];
            }
        }
        return dp[m][n];

    }
};</code></pre> 
<p>  <strong>Leetcode 测试结果： </strong> <img alt="" height="605" src="https://images2.imgbox.com/9a/f9/scC0NLBr_o.png" width="928"></p> 
<h2 id="%E4%B8%89%E3%80%81%C2%A0%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E2%BC%A9%E5%92%8C%EF%BC%88medium%EF%BC%89">三、 <a class="link-info" href="https://leetcode.cn/problems/minimum-falling-path-sum/description/" rel="nofollow" title="下降路径最⼩和（medium）">下降路径最⼩和（medium）</a></h2> 
<blockquote> 
 <p>给你一个 <code>n x n</code> 的<strong> 方形 </strong>整数数组 <code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong><em> </em>的<strong> </strong><strong>最小和</strong> 。</p> 
 <p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="525" src="https://images2.imgbox.com/18/72/jhRR8iet_o.jpg" width="524"></p> 
 <pre><strong>输入：</strong>matrix = [[2,1,3],[6,5,4],[7,8,9]]
<strong>输出：</strong>13
<strong>解释：</strong>如图所示，为和最小的两条下降路径
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="365" src="https://images2.imgbox.com/d8/45/xZtqjE39_o.jpg" width="164"></p> 
 <pre><strong>输入：</strong>matrix = [[-19,57],[-40,-5]]
<strong>输出：</strong>-59
<strong>解释：</strong>如图所示，为和最小的下降路径
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul> 
</blockquote> 
<pre><code class="language-cpp">class Solution {
public:
    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {

    }
};</code></pre> 
<p></p> 
<h3>a、解题思路 </h3> 
<p>上面我们刚刚做完最大价值，现在来做最小和，二者思路非常相似，但是我们这里要仔细读题。</p> 
<p><strong>1、转态表示</strong></p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/1a/92/mjB5WrOl_o.png" width="1200"></p> 
<p>dp[i][j]表示：到达[i,j]位置时，最小的下降路径</p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分：</p> 
<blockquote> 
 <p>从[i-1][j-1]------&gt;[i][j]：</p> 
 <p>那最小的下降路径不就是dp[i-1][j-1]+m[i][j;</p> 
 <p>从[i][jj-1]------&gt;[i][j]：</p> 
 <p>那最小的下降路径不就是dp[i-1][j]+m[i][j;</p> 
 <p>从[i]-1[jj]------&gt;[i][j]：</p> 
 <p>那最小的下降路径不就是dp[i-1][j+1]+m[i][j;</p> 
</blockquote> 
<p><img alt="" height="373" src="https://images2.imgbox.com/a7/6f/GDWaVBQ2_o.png" width="1200"></p> 
<p>但是我们要求的是最小的下降路径</p> 
<p> <strong>状态转移方程：dp[i][jj = min(x,y,z</strong>)+m[i][j];</p> 
<p></p> 
<p>3、初始化</p> 
<p>这里的初始化和前面有点不同，所以我希望大家在做这种类型题目的时候，不要无脑初始化，一定要先进行分析。</p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/53/e8/hFnnbD4Z_o.png" width="1120"></p> 
<blockquote> 
 <ul><li>首先我们肯定是其想是第一行位置的值， 肯定是其本身（最小的下降路径），根据转态转移方程，我们肯定是不能让我们新添加的行影响结果，所以把<strong>第一行初始化为0</strong>。</li><li>在选择dp[1][2]进行观测(不一定非要选择这个位置，合适就好)，根据转态转移方程，我们肯定是不能让我们新添加的列影响结果，所以要把<strong>第一列初始化为正无穷（第一行元素除外）</strong></li><li>在选择dp[1][3]进行观察，，根据转态转移方程，我们肯定是不能让我们新添加的列影响结果所以要把<strong>最后一列初始化为正无穷（第一行元素除外）</strong></li></ul> 
</blockquote> 
<p></p> 
<p>4、 填表顺序</p> 
<p>从上往下填写，值到最后一行</p> 
<p>5、返回值</p> 
<p>返回最后一行的最小值</p> 
<h3>b、代码</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int get_min(int x,int y,int z)
    {
        int tmp = min(x,y);
        return min(tmp,z);
    }
    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)
    {
        int m = matrix.size();
        int n = matrix[0].size();

        int max = INT_MAX;//相当与正无穷
        //创建dp表
        vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+2,max));

        //初始化 这里初始化第一行就好
        for(int i = 0;i&lt;n+2;i++)
        {
            dp[0][i] = 0;
        }

        //填表
        for(int i = 1;i&lt;=m;i++)
        {
            for(int j =1;j&lt;=n;j++)
            {
                dp[i][j] = get_min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+matrix[i-1][j-1];
            }
        }
        //遍历最后一行找出最小值返回
        int min = max;
        for(int i = 1;i&lt;=n;i++)
        {
            if(dp[m][i]&lt;min) min = dp[m][i];

        }
        return min;
    }
};</code></pre> 
<p>  <strong>Leetcode 测试结果： </strong>  </p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/f6/b4/31xFUypQ_o.png" width="884"></p> 
<h2 id="%E5%9B%9B%E3%80%81%20%E6%9C%80%E2%BC%A9%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88medium%EF%BC%89">四、 <a class="link-info" href="https://leetcode.cn/problems/minimum-path-sum/description/" rel="nofollow" title="最⼩路径和（medium）">最⼩路径和（medium）</a></h2> 
<blockquote> 
 <p>给定一个包含非负整数的 <code><em>m</em> x <em>n</em></code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p> 
 <p><strong>说明：</strong>每次只能向下或者向右移动一步。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/5b/32/raiOb69J_o.jpg" width="242"></p> 
 <pre><strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]
<strong>输出：</strong>7
<strong>解释：</strong>因为路径 1→3→1→1→1 的总和最小。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>grid = [[1,2,3],[4,5,6]]
<strong>输出：</strong>12
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 200</code></li></ul> 
</blockquote> 
<pre><code class="language-cpp">class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {

    }
};</code></pre> 
<h3>a、解题思路 </h3> 
<p>又是这种路径的问题，我相信如果大家，认真做了前面的题，这题思路就非常清晰了</p> 
<p><strong>1、转态表示</strong></p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/f0/1a/dpz4c0lN_o.png" width="1167"></p> 
<p>dp[i][j]表示：到达[i,j]位置时，最小的路径路径和</p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分：</p> 
<blockquote> 
 <p>从[i-1][j]------&gt;[i][j]：</p> 
 <p>那最小路径和不就是dp[i-1][j]+g[i][j];</p> 
 <p>从[i][jj-1]------&gt;[i][j]：</p> 
 <p>那最小的下降路径不就是dp[i][j-1]+g[i][j];</p> 
 <p></p> 
</blockquote> 
<p><img alt="" height="433" src="https://images2.imgbox.com/89/f6/UWI30Z8g_o.png" width="1200"></p> 
<p>但是我们要求的是最小的下降路径</p> 
<p> <strong>状态转移方程：</strong> dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];</p> 
<p></p> 
<p>3、初始化</p> 
<p>还先分析第一个位置，那么dp[0][1]和dp[1][0]就要初始化为0，其他位置，我们想现在可以总结一下了：</p> 
<blockquote> 
 <ul><li>当求最小值    就初始化为正无尽</li><li>当求最大值   就初始化为负无尽</li></ul> 
</blockquote> 
<p><img alt="" height="268" src="https://images2.imgbox.com/b0/39/7tIQjPwp_o.png" width="1200"></p> 
<p>4、 填表顺序</p> 
<p>从上往下填写，在从左往右。</p> 
<p>5、返回值</p> 
<p>dp[m][n]</p> 
<h3>b、代码</h3> 
<pre><code class="language-cpp">class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid)
    {
        int m = grid.size();
        int n = grid[0].size();

        //创建dp
          vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,INT_MAX));
        //初始化
        dp[1][0] = dp[0][1] = 0;

        //填表
        for(int i = 1;i&lt;=m;i++)
        {
            for(int j = 1;j&lt;=n;j++)
            {
                dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];
            }
        }
        
        //返回
        return dp[m][n];
    }
};</code></pre> 
<p>  <strong>Leetcode 测试结果： </strong>   </p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/80/df/SEnOcxnX_o.png" width="916"></p> 
<h2 id="%E4%BA%94%E3%80%81%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%EF%BC%88hard%EF%BC%89%C2%A0" style="background-color:transparent;">五、<a class="link-info" href="https://leetcode.cn/problems/dungeon-game/description/" rel="nofollow" title="地下城游戏（hard） ">地下城游戏（hard） </a></h2> 
<blockquote> 
 <p>恶魔们抓住了公主并将她关在了地下城 <code>dungeon</code> 的 <strong>右下角</strong> 。地下城是由 <code>m x n</code> 个房间组成的二维网格。我们英勇的骑士最初被安置在 <strong>左上角</strong> 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p> 
 <p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p> 
 <p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p> 
 <p>为了尽快解救公主，骑士决定每次只 <strong>向右</strong> 或 <strong>向下</strong> 移动一步。</p> 
 <p>返回确保骑士能够拯救到公主所需的最低初始健康点数。</p> 
 <p><strong>注意：</strong>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="253" src="https://images2.imgbox.com/d5/5e/orYmpkhH_o.jpg" width="253"></p> 
 <pre><strong>输入：</strong>dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
<strong>输出：</strong>7
<strong>解释：</strong>如果骑士遵循最佳路径：右 -&gt; 右 -&gt; 下 -&gt; 下 ，则骑士的初始健康点数至少为 7 。</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>dungeon = [[0]]
<strong>输出：</strong>1</pre> 
 <p></p> 
</blockquote> 
<pre><code class="language-cpp">class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) {

    }
};</code></pre> 
<h3>a、解题思路 </h3> 
<p>大家遇到这种文字多的题目，不要害怕，如果读不明白，就带这例题去推就好了。</p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/df/fa/McLrX0Cm_o.png" width="1200"></p> 
<p><strong>1、转态表示</strong></p> 
<p><img alt="" height="462" src="https://images2.imgbox.com/6b/99/GjAmUqwz_o.png" width="1200"></p> 
<p>大家可能非常想到是<strong>以某一个位置结尾推出</strong>： </p> 
<p></p> 
<p>dp[i][j]表示：到达[i,j]位置时，所需的最低血量点数。但这是不正确的，因为我们不仅仅在[i][j]位置受到前面位置的影响，其实我们还会受到后面位置的影响，所以这样的状态表示是不可取的。</p> 
<p>但是我们还可以想 一下<strong>以某位置为起点来推</strong>：</p> 
<p>dp[i][j]表示从[i,j]位置出发，到达终点所要的最低健康血量</p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分：</p> 
<blockquote> 
 <p>往右走那最低血量应该是：dp[i][j+1] -d[i][j]</p> 
 <p>往下走那最低血量应该是：dp[i]+1[j] -d[i][j]</p> 
 <p>但是我们还要注意当d[i][j]此时非常大的时候，dp[i][j]可能出现负值，但是这样是不符合常理的，所以我们要处理一下：dp[i][j] = max(1,dp[i][j]);</p> 
</blockquote> 
<p><img alt="" height="524" src="https://images2.imgbox.com/40/b6/zAFYO9KQ_o.png" width="1200"></p> 
<p>到达终点所要的最低健康血量</p> 
<p> <strong>状态转移方程：</strong> dp[i][j] = min(dp[i][j+1],dp[i+1][j])-d[i][j];</p> 
<p>3、初始化</p> 
<p>这里我们填表因为是从后往前面填的，所以我们要关注最后一个位置，当我们救出公主的时候，肯定要保证自己的血量不为0，所以在[<strong>m][n-1]和[m-1][n]位置填1就好，</strong>其他位置为不影响 <strong>状态转移方程应该都初始化为正无穷。</strong></p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/73/41/pSjSnJNa_o.png" width="1200"></p> 
<p>4、 填表顺序</p> 
<p>从下往上填写，在从右往左。</p> 
<p>5、返回值</p> 
<p>dp[0][0]</p> 
<h3>b、代码</h3> 
<pre><code class="language-cpp">class Solution
{
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon)
    {
        int m = dungeon.size(), n = dungeon[0].size();
        // 建表 + 初始化
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX));
        dp[m][n - 1] = dp[m - 1][n] = 1;
        // 填表
        for (int i = m - 1; i &gt;= 0; i--)
            for (int j = n - 1; j &gt;= 0; j--)
            {
                dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];
                dp[i][j] = max(1, dp[i][j]);
            }
        // 返回结果
        return dp[0][0];
    }
};</code></pre> 
<p>   <strong>Leetcode 测试结果： </strong> </p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/cd/63/b9RmS6Mt_o.png" width="1006"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27674254fd5d5a771d335f87608b5993/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java | 字符串数组的创建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84ccedebc9ff0bceeb7af227abf27f06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JDK 22 和 JDK 23：到目前为止我们所知道的</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>