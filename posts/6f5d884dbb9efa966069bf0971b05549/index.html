<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HiveSQL题——collect_set()/collect_list()聚合函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6f5d884dbb9efa966069bf0971b05549/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="HiveSQL题——collect_set()/collect_list()聚合函数">
  <meta property="og:description" content="一、collect_set() /collect_list()介绍 collect_set()函数与collect_list()函数属于高级聚合函数（行转列），将分组中的某列转换成一个数组返回，常与concat_ws()函数连用实现字段拼接效果。
collect_list：收集并形成list集合，结果不去重
collect_set：收集并形成set集合，结果去重 二、collect_set() /collect_list()有序性 0 问题描述 有一张用户关注表table20，需求：根据用户user_id分组，按照粉丝关注的时间升序排序，输出粉丝id数组和粉丝关注的时间数组，并保障两个数组的数据能一一对应。
1 数据准备 create table if not exists table20 ( user_id int comment &#39;用户id&#39;, follow_user_id int comment &#39;粉丝id&#39;, update_time string comment &#39;粉丝关注的时间&#39; ) comment &#39;用户关注表&#39;; insert overwrite table table20 values (1, 101,&#39;2021-09-30 10:12:00&#39;), (1, 103,&#39;2021-10-01 11:00:00&#39;), (1, 104,&#39;2021-11-02 10:00:00&#39;), (1, 103,&#39;2021-11-28 10:22:00&#39;), (2, 104,&#39;2021-11-02 10:11:00&#39;), (2, 100,&#39;2021-11-03 10:21:00&#39;), (1, 99,&#39;2021-11-23 12:28:00&#39;); 2 数据分析 方式一： row_number() over(partition by .. order by..) as rn 排序，然后再使用collect_list()/collect_set()进行聚合.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-04T13:21:20+08:00">
    <meta property="article:modified_time" content="2024-02-04T13:21:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HiveSQL题——collect_set()/collect_list()聚合函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、collect_set() /collect_list()介绍</h2> 
<p>       collect_set()函数与collect_list()函数属于高级聚合函数（行转列），将分组中的某列转换成一个数组返回，常与concat_ws()函数连用实现字段拼接效果。</p> 
<ul><li> <p><span style="color:#494949;">collect_list：收集并形成list集合，结果不去重</span></p> </li><li><span style="color:#494949;">collect_set：收集并形成set集合，结果去重</span></li></ul> 
<h2>二、collect_set() /collect_list()有序性</h2> 
<h4 id="0%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">0 问题描述</h4> 
<p>  有一张用户关注表table20，需求：根据用户user_id分组，按照粉丝关注的时间升序排序，输出<strong>粉丝id数组</strong>和<strong>粉丝关注的时间数组</strong>，并保障两个数组的<strong>数据能一一对应</strong>。</p> 
<h4 id="1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><a name="t2"></a><a name="t12"></a>1 数据准备</h4> 
<pre><code class="language-sql">create table if not exists table20 (
    user_id int comment '用户id',
    follow_user_id int comment '粉丝id',
    update_time string comment '粉丝关注的时间'
) comment  '用户关注表';

insert overwrite table table20 values
(1, 101,'2021-09-30 10:12:00'),
(1, 103,'2021-10-01 11:00:00'),
(1, 104,'2021-11-02 10:00:00'),
(1, 103,'2021-11-28 10:22:00'),
(2, 104,'2021-11-02 10:11:00'),
(2, 100,'2021-11-03 10:21:00'),
(1, 99,'2021-11-23 12:28:00');</code></pre> 
<h4 id="2%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">2 数据分析</h4> 
<p>方式一： row_number() over(partition by .. order by..) as rn 排序，然后再使用collect_list()/collect_set()进行聚合.</p> 
<pre><code class="language-sql">select
    user_id,
    concat_ws('|', collect_list(cast(follow_user_id as string))) as fui,
    concat_ws('|', collect_list(update_time))  as ut
      from (select
                user_id,
                follow_user_id,
                update_time,
                row_number() over (partition by user_id order by update_time) rn
            from table20) tmp1
group by user_id;</code></pre> 
<p><img alt="" height="115" src="https://images2.imgbox.com/bf/6d/giwnyDua_o.png" width="1200"></p> 
<p><strong><span style="color:#fe2c24;">发现问题：</span>ut数组内的时间并没有按照升序排序输出。</strong></p> 
<p><strong><span style="color:#fe2c24;">原因分析：</span></strong></p> 
<ul><li><strong>HiveSQL执行时，底层转换成MR任务执行，当同时开启多个mapper任务</strong>时，mapper1可能处理的user_id是 1，update_time排名为1，2，3的数据,mapper2可能处理的user_id是1，update_time排名为4，5的数据。</li><li>collect_list()的底层是arrayList 来实现的，当put到arrayList集合时，<strong>无法知道是哪个mapper先计算完，所以可能会出现ArrayList集合中的数据顺序与原来数据插入的顺序不对齐的情况</strong>。因此：row_number() over(partition by .. order by ..) 与collect_list一起使用的时候，<strong><span style="color:#fe2c24;">只能是实现局部有序（单个mapper的数据有序），不能实现全局有序。</span></strong></li></ul> 
<p><span style="color:#fe2c24;"><strong>解决方案：</strong></span></p> 
<p><span style="color:#494949;"><strong>方案一：</strong></span><strong>使用</strong><strong>distribute by + order by</strong></p> 
<pre><code class="language-sql">select
    user_id,
    concat_ws('|', collect_list(cast(follow_user_id as string))) as fui_list,
    concat_ws('|', collect_list(update_time))                    as ut_list
from (select
          user_id,
          follow_user_id,
          update_time,
          row_number() over (partition by user_id order by update_time ) as rn
      from (
               select
                   user_id,
                   follow_user_id,
                   update_time
               from table20
                   distribute by user_id sort by update_time
           ) tmp1) tmp2
group by user_id
order by user_id;</code></pre> 
<h4><img alt="" height="161" src="https://images2.imgbox.com/35/69/xHRivPCQ_o.png" width="466"></h4> 
<p><img alt="" height="142" src="https://images2.imgbox.com/33/12/TKQpapK9_o.png" width="1200"></p> 
<p><strong> 上述代码用到的函数：</strong></p> 
<pre><code class="language-sql">(1)concat_ws：带分隔符的字符串连接
   语法: concat_ws(string SEP, string A, string B…)
         select concat_ws('-','abc','def') // abc-def


(2)collect_list：收集并形成list集合，结果不去重
   语法:select id, collect_list(likes) from student group by id;


(2)collect_set：收集并形成set集合，结果去重
   语法:select id, collect_set(likes) from student group by id;
</code></pre> 
<p><span style="color:#494949;"><strong>方案二：</strong></span><strong>sort_array(只支持升序)</strong></p> 
<pre><code class="language-sql">select
    user_id,
    concat_ws(',', collect_list(cast(follow_user_id as string)))   as fui,
    concat_ws(',', sort_array(collect_list
        (concat_ws('|', lpad(cast(rn as string), 2, '0'), update_time)))) as middle,
    regexp_replace(concat_ws(',', sort_array(collect_list
        (concat_ws('|', lpad(cast(rn as string), 2, '0'), update_time)))), '\\d+\\|', '') as ut
from (select
          user_id,
          follow_user_id,
          update_time,
          rn
      from (
               select
                   user_id,
                   follow_user_id,
                   update_time,
                   row_number() over (partition by user_id order by update_time ) as rn
               from table20
           ) tmp1
      order by rn) tmp2
group by user_id
order by user_id
</code></pre> 
<h4><img alt="" height="156" src="https://images2.imgbox.com/fa/22/xWIA0SYx_o.png" width="487"></h4> 
<p>middle字段值的结果：</p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/ef/03/iVRyVtHu_o.png" width="786"></p> 
<p>ut字段值的结果：</p> 
<h4><img alt="" height="159" src="https://images2.imgbox.com/e4/3e/YhgblN7N_o.png" width="1049"></h4> 
<pre><code class="language-sql">select regexp_replace('04|','\\d+\\|','*')  --&gt; *
正则表达式：\\d+代表所有数字字符</code></pre> 
<p><strong>上述代码用到的函数：</strong></p> 
<pre><code class="language-sql">（一）lpad / rpad：左/右补足函数
语法：lpad(string str, int len,string pad) / rpad(string str, int len, string pad)
参数说明：
第一个参数：要补齐的字符串
第二个参数：补齐之后字符串的总位数
第三个参数：从左边/右边填充的字符， lpad代表从左边填充；rpad代表从右边填充

举例：
select lpad('abc',5,'fg')  --&gt; fgabc
select rpad('abc',7,'df') --&gt; abcdfdf

因为sort_array 是按照顺序对字符进行排序(例如11会排在2前面)，所以可以使用函数lpad补位(将原来的1,2,3,4 转换成 01,02,03,04),然后再正常排序


（二）regexp_replace : 字符串替换
语法：regexp_replace(string initial_string, string pattern, string  replacement)
参数说明：
 initial_string为要替换的字符串，
 pattern为匹配字符串的正则表达式，
 replacement为要替换为的字符串。
简述： regexp_replace (StrA,StrB,StrC) 函数：将字符串A中的符合java正则表达式B的部分替换成C


（三）sort_array : 数组排序函数
 语法：sort_array(array, [asc|desc]) ： 按照指定的排序规则对数组进行排序，并返回一个排好序的新数组
 参数说明：
  第一个参数：array为需要排序的数组，
  第二个参数：asc为可选参数，如果设置为true则按升序排序；desc为可选参数，如果设置为true，则按降序排序。如果既不设置asc也不设置desc，则按升序排序

 举例：
select sort_array(array(2, 5, 3, 1)) as sorted_array; ---&gt; [1,2,3,5]
select sort_array(array(2, 5, 3, 1), true, true) as sorted_array; ---&gt; [5,3,2,1]

</code></pre> 
<h4>3 小结</h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b443d8d8a8290abbcfbfaf00d9a4586b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 应用添加系统签名权限的几种方式实现介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb93c9b51f6b35c0f685506fb666636b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【学习笔记】树上差分总结(点差分/边差分)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>