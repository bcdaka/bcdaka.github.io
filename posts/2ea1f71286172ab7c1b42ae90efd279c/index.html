<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划-----最长公共子序列（及其衍生问题） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2ea1f71286172ab7c1b42ae90efd279c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="动态规划-----最长公共子序列（及其衍生问题）">
  <meta property="og:description" content="目录
一.最长公共子序列的基本概念：
解决动态规划问题的一般思路（三大步骤）：
二.最长公共子序列题目：
三.字符串的删除操作：
四.最小 ASCII 删除和：
一.最长公共子序列的基本概念： 首先需要科普一下，最长公共子序列（longest common sequence）和最长公共子串（longest common substring）不是一回事儿。什么是子序列呢？即一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。什么是子串呢？给定串中任意个连续的字符组成的子序列称为该串的子串。给一个图再解释一下：
最长公共子序列，顾名思义，就是求两个字符串中子序列的最长的公共部分，返回这个最大的长度，比如说输入 s1 = &#34;zabcde&#34;, s2 = &#34;acez&#34;，它俩的最长公共子序列是 lcs = &#34;ace&#34;，长度为 3，所以算法返回 3。
🐻🐻🐻对于两个字符串求子序列的问题，都是用两个指针 i 和 j 分别在两个字符串上移动，大概率是动态规划思路。
解决动态规划问题的一般思路（三大步骤）： 动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤:
🧐 步骤一:定义dp数组元素的含义🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程)🧐第三步骤：找出初始值（base case） 接下来的题目我们会按照这三个步骤来解释说明
二.最长公共子序列题目： 计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，力扣第 1143 题「最长公共子序列open in new window」就是这个问题：
对应的函数签名如下：
步骤一：按我上面的步骤说的，首先我们来定义 dp数组的含义，题目要我们求两个字符串的最长公共子序列，给出 对应dp[][] 数组的定义：dp[i][j] 表示串 s1[0..i] 和 s2[0..j] 最长公共子序列的长度步骤二:找到数组元素之间的关系式(也就是我们所熟知的状态转移方程) 这里咱不要看 s1 和 s2 两个字符串，而是要具体到每一个字符，思考每个字符该做什么：
①.如果我们只看 s1[i] 和 s2[j]，如果 s1[i] == s2[j]，说明这个字符一定在 lcs 中： 根据dp数组定义可得此时状态转移方程为：dp[ i ][ j ] = 1 &#43; dp[ i - 1 ][ j - 1 ]">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-25T13:16:48+08:00">
    <meta property="article:modified_time" content="2024-03-25T13:16:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划-----最长公共子序列（及其衍生问题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">一.最长公共子序列的基本概念：</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF%EF%BC%88%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF%EF%BC%88%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%89%EF%BC%9A" rel="nofollow">解决动态规划问题的一般思路（三大步骤）：</a></p> 
<p id="%E4%BA%8C.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%A2%98%E7%9B%AE%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%A2%98%E7%9B%AE%EF%BC%9A" rel="nofollow">二.最长公共子序列题目：</a></p> 
<p id="%E4%B8%89.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">三.字符串的删除操作：</a></p> 
<p id="%E5%9B%9B.%E6%9C%80%E5%B0%8F%20ASCII%20%E5%88%A0%E9%99%A4%E5%92%8C%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E6%9C%80%E5%B0%8F%20ASCII%20%E5%88%A0%E9%99%A4%E5%92%8C%EF%BC%9A" rel="nofollow">四.最小 ASCII 删除和：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A">一.最长公共子序列的基本概念：</h2> 
<p>首先需要科普一下，最长公共子序列（longest common sequence）和最长公共子串（longest common substring）不是一回事儿。什么是子序列呢？即一个给定的序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。什么是子串呢？给定串中任意个连续的字符组成的子序列称为该串的子串。给一个图再解释一下：</p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/e4/9b/9uZKy5sz_o.png" width="465"></p> 
<p>最长公共子序列，顾名思义，就是求两个字符串中子序列的最长的公共部分，返回这个最大的长度，比如说输入 <strong><em><code>s1 = "zabcde", s2 = "acez"</code></em></strong>，它俩的最长公共子序列是<strong> <code>lcs = "ace"</code></strong>，长度为 3，所以算法返回 3。</p> 
<p><strong><span style="background-color:#ffd900;">🐻🐻🐻对于两个字符串求子序列的问题，都是用两个指针 </span><code><span style="background-color:#ffd900;">i</span></code><span style="background-color:#ffd900;"> 和 </span><code><span style="background-color:#ffd900;">j</span></code><span style="background-color:#ffd900;"> 分别在两个字符串上移动，大概率是动态规划思路</span></strong><span style="background-color:#ffd900;">。</span></p> 
<h3 id="%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%9D%E8%B7%AF%EF%BC%88%E4%B8%89%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%89%EF%BC%9A">解决动态规划问题的一般思路（三大步骤）：</h3> 
<p>动态规划，无非就是利用<strong>历史记录</strong>，来避免我们的重复计算。而这些<strong>历史记录</strong>，我们得需要一些<strong>变量</strong>来保存，一般是用<strong>一维数组</strong>或者<strong>二维数组</strong>来保存。下面我们先来讲下做动态规划题很重要的三个步骤:</p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐 步骤一:</span></strong><span style="background-color:#ffd900;">定义dp</span><strong><span style="background-color:#ffd900;">数组元素的含义</span></strong></li><li><strong><span style="background-color:#ffd900;">🧐步骤二:</span></strong><span style="background-color:#ffd900;">找出</span><strong><span style="background-color:#ffd900;">数组元素之间的关系式(也就是我们所熟知的状态转移方程)</span></strong></li><li><strong><span style="background-color:#ffd900;">🧐第三步骤</span></strong><span style="background-color:#ffd900;">：找出</span><strong><span style="background-color:#ffd900;">初始值（base case）</span></strong></li></ul> 
<p>接下来的题目我们会按照这三个步骤来解释说明</p> 
<h2 id="%E4%BA%8C.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%A2%98%E7%9B%AE%EF%BC%9A" style="background-color:transparent;">二.最长公共子序列题目：</h2> 
<p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，力扣第 1143 题「<a href="https://leetcode.cn/problems/longest-common-subsequence/" rel="nofollow" title="最长公共子序列open in new window">最长公共子序列open in new window</a>」就是这个问题：</p> 
<p>对应的函数签名如下：</p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/11/ff/REv5ZXbw_o.png" width="1200"></p> 
<ul><li><strong>步骤一：</strong>按我上面的步骤说的，首先我们来定义 dp数组的含义，题目要我们求两个字符串的最长公共子序列，给出 对应<strong><code><span style="background-color:#ffd900;">dp[][]</span></code><span style="background-color:#ffd900;"> 数组的定义：</span><code><span style="background-color:#ffd900;">dp[i][j]</span></code><span style="background-color:#ffd900;"> 表示串 </span><code><span style="background-color:#ffd900;">s1[0..i]</span></code><span style="background-color:#ffd900;"> 和 </span><code><span style="background-color:#ffd900;">s2[0..j]</span></code><span style="background-color:#ffd900;"> 最长公共子序列的长度</span></strong></li><li><strong>步骤二</strong>:找到<strong><span style="background-color:#ffd900;">数组元素之间的关系式(也就是我们所熟知的状态转移方程)</span></strong></li></ul> 
<p>这里<strong>咱不要看 <code>s1</code> 和 <code>s2</code> 两个字符串，而是要具体到每一个字符，思考每个字符该做什么：</strong></p> 
<p>①.如果我们只看<strong> <code>s1[i]</code> 和 <code>s2[j]</code></strong>，<strong>如果 <code>s1[i] == s2[j]</code>，说明这个字符一定在 <code>lcs</code> 中</strong>： </p> 
<p><img alt="" height="339" src="https://images2.imgbox.com/94/1b/Kyo8tYct_o.png" width="610"></p> 
<p><strong><span style="background-color:#ffd900;">根据dp数组定义可得此时状态转移方程为：dp[ i ][ j ] = 1 + dp[ i - 1 ][ j - 1 ]</span></strong></p> 
<p><strong><code>②.如果s[i] != s2[j]</code> 意味着，<code>s1[i]</code> 和 <code>s2[j]</code> 中至少有一个字符不在 <code>lcs</code> 中</strong>：</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/94/1b/VFx3xiYq_o.png" width="598"></p> 
<p>因为是求最长的公共子序列，所以我们求出对应上述的三种情况的最大值即可，由于情况三被一和二所包（因为我们在求最大值嘛，情况三在计算 <code>s1[i+1..]</code> 和 <code>s2[j+1..]</code> 的 <code>lcs</code> 长度，这个长度肯定是小于等于情况二 <code>s1[i..]</code> 和 <code>s2[j+1..]</code> 中的 <code>lcs</code> 长度的，因为 <code>s1[i+1..]</code> 比 <code>s1[i..]</code> 短嘛，那从这里面算出的 <code>lcs</code> 当然也不可能更长嘛）所以可得：</p> 
<p><strong><span style="background-color:#ffd900;">根据dp数组定义可得此时状态转移方程为：dp[ i ][ j ] = Math.max( dp [ i - 1][ j ],dp[ i ] [ j - 1 ])</span></strong></p> 
<ul><li><strong> 步骤三</strong>：找出初始值（base case）：这里当字符串为空时，没有最大公共子序列，对应的值为0。</li></ul> 
<p>我们以ABCB  和 BDCA 为例-----》填dp表：</p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/f1/f8/xos75wGS_o.png" width="489"></p> 
<p><strong>按照上述的状态转移方程，我们可以将表填完整：</strong></p> 
<p><img alt="" height="373" src="https://images2.imgbox.com/c1/0d/zjNIbmu3_o.png" width="454"></p> 
<p><strong>最后，完成上述过程后，动态规划完整代码：</strong></p> 
<pre><code class="language-java">class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(),n = text2.length();
       // base case: dp[0][..] = dp[..][0] = 0
        int dp[][] = new int[m + 1][n + 1];
        for(int i = 1;i &lt;= m;i++){
            for(int j = 1;j &lt;= n;j++){
                if(text1.charAt(i - 1) == text2.charAt(j - 1)){
                 // text1[i-1] 和 text2[j-1] 必然在 lcs 中
                    dp[i][j] = 1 + dp[i - 1][j -1];
                }else{
                  // text1[i-1] 和 text2[j-1] 至少有一个不在 lcs 中
                    dp[i][j] = Math.max(dp[i - 1][j],dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}</code></pre> 
<p><strong>这里还有一种带备忘录的递归式解法,与上面的方法类似：</strong></p> 
<pre><code class="language-java">class Solution {
    // 备忘录，消除重叠子问题
    int[][] memo;

    /* 主函数 */
    public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 备忘录值为 -1 代表未曾计算
        memo = new int[m][n];
        for (int[] row : memo) 
            Arrays.fill(row, -1);
        // 计算 s1[0..] 和 s2[0..] 的 lcs 长度
        return dp(s1, 0, s2, 0);
    }

    // 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度
    int dp(String s1, int i, String s2, int j) {
        // base case
        if (i == s1.length() || j == s2.length()) {
            return 0;
        }
        // 如果之前计算过，则直接返回备忘录中的答案
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 根据 s1[i] 和 s2[j] 的情况做选择
        if (s1.charAt(i) == s2.charAt(j)) {
            // s1[i] 和 s2[j] 必然在 lcs 中
            memo[i][j] = 1 + dp(s1, i + 1, s2, j + 1);
        } else {
            // s1[i] 和 s2[j] 至少有一个不在 lcs 中
            memo[i][j] = Math.max(
                dp(s1, i + 1, s2, j),
                dp(s1, i, s2, j + 1)
            );
        }
        return memo[i][j];
    }
}</code></pre> 
<p>「最长公共子序列」问题基本都是要求返回一个最值即可，但是有时候面试官喜欢不按常理出牌，让你输出最长公共子序列：</p> 
<p>我们可以通过构造出来的二维 <code>dp</code> 数组来得到最长公共子序列。如下图所示，从最后一个点开始往左上角的方向遍历 ：</p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/79/4c/KUG2Lthg_o.png" width="897"></p> 
<p>如果 <code>s1[i] = s2[j]</code>，那么当前字符肯定在最长公共子序列中；否在我们就向左或者向上遍历，至于选择「向左」还是「向上」的方向，这就要和构造 <code>dp</code> 的时候联系起来。我们是挑了一个最大值，所以遍历的方向也是谁大就往谁的方向遍历 ，具体代码：</p> 
<pre><code class="language-java">public static int lcs(String s1,String s2){
       //最长公共子序列框架
        int m = s1.length(),n = s2.length();
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 1;i &lt;= m;i++){
            for(int j = 1;j &lt;=n;j++){
                if(s1.charAt(i - 1) == s2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else{
                    dp[i][j] = Math.max(
                            dp[i - 1][j],
                            dp[i][j - 1]
                    );
                }
            }
        }
        //打印最长公共子序列
        int i  = m,j = n;
        StringBuffer sb = new StringBuffer();
        while(i &gt; 0 &amp;&amp; j &gt; 0){
            char c1 = s1.charAt(i - 1);
            char c2 = s2.charAt(j - 1);
            if(c1 == c2){
                sb.append(c1);
             // 向左上角遍历
                i--;
                j--;
            }else{
              // 向上
                if(dp[i - 1][j] &gt; dp[i][j - 1]) i--;
               // 向左
                else j--;
            }
        }
      //最后将得到的字符串反转一下，就是我们要的答案了
        System.out.println(sb.reverse());
        return dp[m][n];
    }</code></pre> 
<p>有了上面的对最长公共子序列的一定了解，下面，来看两道和最长公共子序列相似的两道题目</p> 
<h2 id="%E4%B8%89.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%9A">三.字符串的删除操作：</h2> 
<p>这是力扣第 583 题「<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/" rel="nofollow" title="两个字符串的删除操作open in new window">两个字符串的删除操作open in new window</a>」，看下题目：</p> 
<p>给定两个单词 <code>s1</code> 和 <code>s2</code> ，返回使得 <code>s1</code> 和 <code>s2</code> 相同所需的最小步数。每步可以删除任意一个字符串中的一个字符。比如输入 <code>s1 = "sea" s2 = "eat"</code>，算法返回 2，第一步将 <code>"sea"</code> 变为 <code>"ea"</code> ，第二步将 <code>"eat"</code> 变为 <code>"ea"</code>。</p> 
<p>函数签名如下：</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/3b/d9/ZDAH6pBc_o.png" width="1094"></p> 
<p>题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？删除的结果不就是它俩的最长公共子序列嘛！那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：<strong>word1.len - LCS + word2.len - LCS </strong></p> 
<p><strong>与上面的解答类似：</strong></p> 
<pre><code class="language-java">class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(),n = word2.length();
        int longest = lcs(word1,word2);
      //推导出的公式
        return m - longest + n - longest;
    }
    int lcs(String s1,String s2){
       //基本最长公共子序列的框架不变
        int m = s1.length(),n = s2.length();
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 1;i &lt;= m;i++){
            for(int j = 1;j &lt;= n;j++){
                if(s1.charAt(i - 1) == s2.charAt(j - 1)){
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                }else{
                    dp[i][j] = Math.max(
                        dp[i - 1][j],
                        dp[i][j - 1]
                    );
                }
            }
        }
        return dp[m][n];
    }
}</code></pre> 
<h2 id="%E5%9B%9B.%E6%9C%80%E5%B0%8F%20ASCII%20%E5%88%A0%E9%99%A4%E5%92%8C%EF%BC%9A" style="background-color:transparent;">四.最小 ASCII 删除和：</h2> 
<p>这是力扣第 712 题「<a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/" rel="nofollow" title="两个字符串的最小 ASCII 删除和open in new window">两个字符串的最小 ASCII 删除和open in new window</a>」，题目和上一道题目类似，只不过上道题要求删除次数最小化，这道题要求删掉的字符 ASCII 码之和最小化。</p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/40/cc/Ra0FKqEq_o.png" width="1200"></p> 
<p>对应函数签名：</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/db/ad/B6gT0Dex_o.png" width="1029"></p> 
<p><strong>其实这个题目的底层也是「最长公共子序列」，只是问法稍微变化了一点：</strong></p> 
<p><strong><span style="background-color:#ffd900;">🧐🧐🧐「需要被删除的字符 = 原字符串 - 最长公共子序列」</span></strong></p> 
<ul><li><strong>步骤一:</strong>结合这个题目我们把 <code>dp[][]</code> 数组的定义稍微改改：<code>dp[i][j]</code> 表示子串 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 最小 ASCII 删除和</li><li><strong>步骤二</strong>:状态转移方程:</li></ul> 
<p><span style="background-color:#ffd900;">①.如果 </span><code><span style="background-color:#ffd900;">s1[i] = s2[j]</span></code><span style="background-color:#ffd900;">，</span><code><span style="background-color:#ffd900;">dp[i][j] = dp[i - 1][j - 1]</span></code><span style="background-color:#ffd900;"> (不需要被删除)</span></p> 
<p><span style="background-color:#ffd900;">②.如果 s1[i] != s2[j]，dp[i][j] = Math.min(dp[i - 1][j] + s1[i], dp[i][j - 1] + s2[j])</span></p> 
<ul><li><strong>步骤三</strong>:初始化（base case）:<img alt="" height="353" src="https://images2.imgbox.com/a7/e7/Xx5ZzIfM_o.png" width="490"></li></ul> 
<p>如上图粉色标记出来的就是 base case，<code>e</code> 表示 e 的 ASCII 值</p> 
<p> 至此，我们完成了其推导过程，动态规划解法代码：</p> 
<pre><code class="language-java">class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        int m = s1.length(),n = s2.length();
      //创建dp表
        int[][] dp = new int[m + 1][n + 1];
      //初始化dp表
        dp[0][0] = 0;
        for(int i = 1;i &lt;= m;i++){
            dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);
        }
        for(int j = 1;j &lt;= n;j++){
            dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);
        }
        //填表
        for(int i = 1;i &lt;= m;i++){
           for(int j = 1;j &lt;= n;j++){
            //相等情况
            if(s1.charAt(i - 1) == s2.charAt(j - 1)){
                dp[i][j] = dp[i - 1][j - 1];
            }else{
                //不相等情况
                dp[i][j] = Math.min(
                   s1.charAt(i - 1) + dp[i - 1][j],
                   s2.charAt(j - 1) + dp[i][j - 1]
                );
            }
           }
        }
      //返回值
        return dp[m][n];
    }
}</code></pre> 
<blockquote> 
 <p>参考文章：《labuladong的算法笔记》,<a href="https://blog.csdn.net/hollis_chuang/article/details/103045322?spm=1001.2014.3001.5506" title="告别动态规划，连刷40道动规算法题，我总结了动规的套路-CSDN博客">告别动态规划，连刷40道动规算法题，我总结了动规的套路-CSDN博客</a></p> 
</blockquote> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固自己的知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/39/5b/plWefv09_o.png" width="450"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/caaede7f4c881ef3803009fd3a6160b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jdk22&#43;maven环境配置教程&#43;idea的maven环境配置(Windows系统)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/060b573223613e30146160fc0e3008f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【网络爬虫】(2) requests模块，案例：网络图片爬取，附Python代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>