<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的集合（详细） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4cb3c1a969e03b26ef06a1ad2bf0483e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中的集合（详细）">
  <meta property="og:description" content="前言 java中自带一些集合类，可以帮助我们更方便地写程序，其中所有的集合类都在java.util包下。
集合有很多有优点，首先它的大小是可以变化的，不像数组一样大小不可变。再者集合可以存储引用数据类型。
HashSet 1.HashSet集合的特点
2.HashSet常用方法
①：add(Object o)：向Set集合中添加元素，不允许添加重复数据。
②：size()：返回Set集合中的元素个数
注意:不会按照保存的顺序存储数据（顺序不定），遍历时不能保证下次结果和上次相同。且向HashSet集合中添加元素，HashSet add方法实质是map全局变量调用了put方法，将数据存到了key，因为HashMap的 key不允许，所以HashSet添加的元素也不允许重复。
③.remove(Object o)： 删除Set集合中的obj对象，删除成功返回true，否则返回false。
④.isEmpty()：如果Set不包含元素，则返回 true。
⑤.clear()： 移除此Set中的所有元素。
⑥.iterator()：返回在此Set中的元素上进行迭代的迭代器。
⑦.contains(Object o)：判断集合中是否包含obj元素。
⑧：加强for循环遍历Set集合：
public class Test { public static void main(String[] args) { HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&#34;青城&#34;); set.add(&#34;博雅&#34;); for (String name : set) { //使用foreach进行遍历。 System.out.println(name); } } } LinkedHashSet LinkedHashSet集合的特点
TreeSet 1.TreeSet集合的特点
2.TreeSet的基本使用
①.插入是按字典序排序的
public class Test { public static void main(String[] args) { TreeSet ts=new TreeSet(); ts.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-30T19:48:25+08:00">
    <meta property="article:modified_time" content="2024-03-30T19:48:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的集合（详细）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>java中自带一些集合类，可以帮助我们更方便地写程序，其中所有的<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88%E7%B1%BB&amp;spm=1001.2101.3001.7020" title="集合类">集合类</a>都在java.util包下。</p> 
<p>集合有很多有优点，首先它的大小是可以变化的，不像数组一样大小不可变。再者集合可以存储引用数据类型。</p> 
<h3>HashSet</h3> 
<p>1.HashSet集合的特点</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/9a/46/PCQirNhM_o.png" width="853"></p> 
<p>2.HashSet常用方法</p> 
<p>①：add(Object o)：向Set集合中添加元素，不允许添加重复数据。</p> 
<p>②：size()：返回Set集合中的元素个数</p> 
<p>注意:不会按照保存的顺序存储数据（顺序不定），遍历时不能保证下次结果和上次相同。且向HashSet集合中添加元素，HashSet add方法实质是map全局变量调用了put方法，将数据存到了key，因为HashMap的 key不允许，所以HashSet添加的元素也不允许重复。</p> 
<p>③.remove(Object o)： 删除Set集合中的obj对象，删除成功返回true，否则返回false。</p> 
<p>④.isEmpty()：如果Set不包含元素，则返回 true。</p> 
<p>⑤.clear()： 移除此Set中的所有元素。</p> 
<p>⑥.iterator()：返回在此Set中的元素上进行迭代的迭代器。</p> 
<p>⑦.contains(Object o)：判断集合中是否包含obj元素。</p> 
<p>⑧：加强for循环遍历Set集合：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();
        set.add("青城");
        set.add("博雅");
        for (String name : set) {   //使用foreach进行遍历。
            System.out.println(name);
        }
    }
}</code></pre> 
<h3>LinkedHashSet</h3> 
<p>LinkedHashSet集合的特点</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/24/be/shUDINk1_o.png" width="985"></p> 
<h3>TreeSet</h3> 
<p>1.TreeSet集合的特点</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/7a/b3/vllttADh_o.png" width="911"></p> 
<p>2.TreeSet的基本使用</p> 
<p>①.插入是按字典序排序的</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        TreeSet ts=new TreeSet();
        ts.add("agg");
        ts.add("abcd");
        ts.add("ffas");
        Iterator it=ts.iterator();
        while(it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
</code></pre> 
<p>输出 ： 按照字典序排序的方式进行排序</p> 
<p>abcd</p> 
<p>agg</p> 
<p>ffas</p> 
<p>②.如果插入的是自定义对象 需要让类实现 Comparable 接口并且必须要重写compareTo</p> 
<pre><code class="language-java">class Person implements Comparable{
    
    String name;
    int age;
    Person(String name,int age)
    {
        this.name=name;
        this.age=age;
    }

    @Override
    public int compareTo(Object o) {
        Person p=(Person)o;
        //先对姓名字典序比较 如果相同 比较年龄
        if(this.name.compareTo(p.name)!=0) {
            return this.name.compareTo(p.name);
        }
        else
        {
            if(this.age&gt;p.age) return 1;
            else if(this.age&lt;p.age) return -1;
        }
        return 0;
    }

}

public class Test {
    public static void main(String args[])
    {
        TreeSet ts=new TreeSet();
        ts.add(new Person("agg",21));
        ts.add(new Person("abcd",12));
        ts.add(new Person("ffas",8));
        ts.add(new Person("agg",12));
        Iterator it=ts.iterator();
        while(it.hasNext())
        {
            Person p=(Person)it.next();
            System.out.println(p.name+":"+p.age);
        }
    }
}</code></pre> 
<p>输出</p> 
<p>abcd:12</p> 
<p>agg:12</p> 
<p>agg:21</p> 
<p>ffas:8</p> 
<h3>HashSet、LinkedHashSet、TreeSet的使用场景</h3> 
<p>HashSet:HashSet的性能基本上比LinkedHashSet和TreeSet要好，特别是添加和查询，这也是用的最多的两个操作</p> 
<p>LinkedHashSet：LinkedHashSet的查询稍慢一些，但是他可以维持元素的添加顺序。所以只有要求当插入顺序和取出顺序一致的时候 才使用LinkedHashSet。</p> 
<p>TreeSet:只有在需要对元素进行排序时使用</p> 
<p></p> 
<h3>数组（ArrayList)</h3> 
<p>1.ArrayList集合的特点</p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/13/ad/OX6V1FCr_o.png" width="1002"></p> 
<p>2.ArrayList集合的一些方法</p> 
<p>①.add(Object element) 向列表的尾部添加指定的元素。</p> 
<p>②.size() 返回列表中的元素个数。</p> 
<p>③.get(int index) 返回列表中指定位置的元素，index从0开始。</p> 
<p>④.add(int index, Object element) 在列表的指定位置（从0开始）插入指定元素</p> 
<p>⑤.set(int i, Object element) 使用元素element替换索引i位置的元素，并返回替换元素。</p> 
<p>⑥.clear() 从列表中移除所有元素。</p> 
<p>⑦.isEmpty() 判断列表是否包含元素，不包含元素则返回 true，否则返回false。</p> 
<p>⑧.contains(Object o) 如果列表包含指定的元素，则返回 true。</p> 
<p>⑨.remove(int index) 移除列表中指定位置的元素，并返回被删元素，删除位置后面的元素（如果有）向前移动。</p> 
<p>⑩.remove(Object o) 从List集合中移除第一次出现的指定元素，移除成功返回true，否则返回false。当且仅当List集合中含有满(o==null ? get(i)==null : o.equals(get(i)))条件的最低索引i的元素时才会返回true。</p> 
<h3>链表(Linkedlist)</h3> 
<p>1.LinkedList集合的特点<img alt="" height="214" src="https://images2.imgbox.com/28/b3/ZfeNwsqR_o.png" width="771"></p> 
<p>2.LinkedList的一些方法</p> 
<p>①.添加</p> 
<p>boolean add（Object element） 它将元素附加到列表的末尾。</p> 
<p>boolean add（int index,Object element） 指定位置插入。 void addFirst(E element) 元素附加到列表的头部 void addLast(E element) 元素附加到列表的尾部</p> 
<p>②：获取数据</p> 
<p>Object get(int index) 根据下标获取数据</p> 
<p>Object getFirst（） 它返回链表的第一个元素。</p> 
<p>Object getLast（） 它返回链接列表的最后一个元素。</p> 
<p>③.查询</p> 
<p>boolean contains（Object element）如果元素存在于列表中，则返回true。</p> 
<p>④.修改</p> 
<p>Object set（int index，Object element）它用于用新元素替换列表中的现有元素</p> 
<p>⑤.删除</p> 
<p>remove() 删除第一个元素</p> 
<p>remove(int location) 删除指定位置的元素</p> 
<p>removeFirst() 删除并返回链接列表的头部一个元素</p> 
<p>removeLast() 删除并返回链接列表的尾部一个元素</p> 
<p>6. 清空</p> 
<p>.clear（）：它删除列表中的所有元素。</p> 
<h3>HashMap</h3> 
<p>1.HashMap示意图</p> 
<p><img alt="" height="456" src="https://images2.imgbox.com/4c/02/LI16TpRr_o.png" width="487"></p> 
<p>2.HashMap的特点</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/54/c4/OY9umEFY_o.png" width="963"></p> 
<p>3.HashMap的常用方法</p> 
<p>①.put(K key, V value) 将键（key）/值（value）映射存放到Map集合中</p> 
<p>②.get(Object key) 返回指定键所映射的值，没有该key对应的值则返回 null，即获取key对应的value。</p> 
<p>③. size()  返回Map集合中数据数量，准确说是返回key-value的组数。</p> 
<p>④：clear() 清空Map集合</p> 
<p>⑤：isEmpty () 判断Map集合中是否有数据，如果没有则返回true，否则返回false</p> 
<p>⑥：remove(Object key) 删除Map集合中键为key的数据并返回其所对应value值。</p> 
<p>⑦：containsKey(Object key) Hashmap判断是否含有key</p> 
<p>⑧：containsValue(Object value) Hashmap判断是否含有value：</p> 
<p>⑨：Hashmap添加另一个同一类型的map下的所有数据</p> 
<p>⑩：Hashmap替换这个key的value</p> 
<h3>栈(Stack)</h3> 
<p>以下是栈的基本用法：</p> 
<p>创建栈对象</p> 
<pre><code class="language-java">Stack&lt;String&gt; stack = new Stack&lt;&gt;();</code></pre> 
<p>添加元素到栈顶</p> 
<pre><code class="language-java">stack.push("element1");
stack.push("element2");</code></pre> 
<p>获取并移除栈顶元素</p> 
<pre><code class="language-java">String element = stack.pop();</code></pre> 
<p>取但不移除栈顶元素：</p> 
<pre><code class="language-java">String element = stack.peek();</code></pre> 
<p>判断栈是否为空</p> 
<pre><code class="language-java">boolean isEmpty = stack.isEmpty();</code></pre> 
<p>获取栈中元素的个数</p> 
<pre><code class="language-java">int size = stack.size();</code></pre> 
<p>遍历栈中的元素</p> 
<pre><code class="language-java">for (String element : stack) {
    System.out.println(element);
}</code></pre> 
<p></p> 
<h3>队列（Queue）</h3> 
<p></p> 
<p>创建队列对象</p> 
<pre><code class="language-java">Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</code></pre> 
<p>压入元素(添加)：add()、offer()</p> 
<p>相同：未超出容量，从队尾压入元素，返回压入的那个元素。</p> 
<p>区别：在超出容量时，add()方法会对抛出异常，offer()返回false</p> 
<p>弹出元素(删除)：remove()、poll()</p> 
<p>相同：容量大于0的时候，删除并返回队头被删除的那个元素。</p> 
<p>区别：在容量为0的时候，remove()会抛出异常，poll()返回false</p> 
<p>获取队头元素(不删除)：element()、peek()</p> 
<p>相同：容量大于0的时候，都返回队头元素。但是不删除。</p> 
<p>区别：容量为0的时候，element()会抛出异常，peek()返回null。</p> 
<p>获取队列中元素的个数</p> 
<pre><code class="language-java">int size = queue.size();</code></pre> 
<p>判断队列是否为空：</p> 
<pre><code class="language-java">boolean isEmpty = queue.isEmpty();</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ae48e88fe65c29eceee6917c1289073/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android ImageView 的scaleType 属性图解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/79a030bfe532bf43c86e071ce8ff4a17/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pycharm无法添加Conda新建的虚拟环境，点击没反应。日志中报错：Can‘t find python path to use, will use conda run instead</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>