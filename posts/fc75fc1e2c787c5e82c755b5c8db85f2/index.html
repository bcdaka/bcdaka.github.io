<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;初阶学习第五弹——类与对象（下）——类与对象的收官战 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fc75fc1e2c787c5e82c755b5c8db85f2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;初阶学习第五弹——类与对象（下）——类与对象的收官战">
  <meta property="og:description" content="类与对象（上）：C&#43;&#43;初阶学习第三弹——类与对象（上）——初始类与对象-CSDN博客
类与对象（中）：C&#43;&#43;初阶学习第四弹——类与对象（中）——刨析类与对象的核心点-CSDN博客
前言：
在前面我们已经学习了C&#43;&#43;类与对象的关键操作——默认成员函数，今天我们对之前的内容进行一些补充，同时再来学习几个新的知识点Static成员、友元和内部类
目录
一、构造函数进阶
1.1 构造函数的赋值化
1.2 构造函数的初始化
1.3 explicit关键字
二、static成员
三、友元
3.1 友元函数
3.2 友元类
四、内部类
五、总结
一、构造函数进阶 1.1 构造函数的赋值化 在前面，我们说对一个自定义类型的变量，当我们定义时可以通过构造函数默认初始化，操作如下：
class Date { public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; int main() { Date d1(); return 0; } 实际上这样的操作并不叫作初始化，更确切的说应该叫赋值化，因为初始化只能有一次，而这个操作却可以多次赋值
比如：
Date(int year, int month, int day) { _year = year; _month = month; _day = day; _year = 3; } 这里就对_year进行了两次赋值，所以这个操作不能称之为初始化，而应该称之为赋值">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T22:49:27+08:00">
    <meta property="article:modified_time" content="2024-05-06T22:49:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;初阶学习第五弹——类与对象（下）——类与对象的收官战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong> 类与对象（上）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/138199637?spm=1001.2014.3001.5502" title="C++初阶学习第三弹——类与对象（上）——初始类与对象-CSDN博客">C++初阶学习第三弹——类与对象（上）——初始类与对象-CSDN博客</a></p> 
<p><strong>类与对象（中）：</strong><a href="https://blog.csdn.net/2301_80220607/article/details/138326096?spm=1001.2014.3001.5502" title="C++初阶学习第四弹——类与对象（中）——刨析类与对象的核心点-CSDN博客">C++初阶学习第四弹——类与对象（中）——刨析类与对象的核心点-CSDN博客</a></p> 
<p><strong>前言：</strong></p> 
<blockquote> 
 <p>在前面我们已经学习了C++类与对象的关键操作——默认成员函数，今天我们对之前的内容进行一些补充，同时再来学习几个新的知识点Static成员、友元和内部类</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6" rel="nofollow">一、构造函数进阶</a></p> 
<p id="1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B5%8B%E5%80%BC%E5%8C%96-toc" style="margin-left:40px;"><a href="#1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B5%8B%E5%80%BC%E5%8C%96" rel="nofollow">1.1 构造函数的赋值化</a></p> 
<p id="1.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#1.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">1.2 构造函数的初始化</a></p> 
<p id="1.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97-toc" style="margin-left:40px;"><a href="#1.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97" rel="nofollow">1.3 explicit关键字</a></p> 
<p id="%E4%BA%8C%E3%80%81static%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81static%E6%88%90%E5%91%98" rel="nofollow">二、static成员</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8F%8B%E5%85%83-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8F%8B%E5%85%83" rel="nofollow">三、友元</a></p> 
<p id="3.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0" rel="nofollow">3.1 友元函数</a></p> 
<p id="3.2%20%E5%8F%8B%E5%85%83%E7%B1%BB-toc" style="margin-left:40px;"><a href="#3.2%20%E5%8F%8B%E5%85%83%E7%B1%BB" rel="nofollow">3.2 友元类</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB" rel="nofollow">四、内部类</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">五、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6">一、构造函数进阶</h2> 
<h3 id="1.1%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B5%8B%E5%80%BC%E5%8C%96">1.1 构造函数的赋值化</h3> 
<p>在前面，我们说对一个自定义类型的变量，当我们定义时可以通过构造函数默认初始化，操作如下：</p> 
<pre><code class="language-cpp">class Date
{
public:
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1();
	return 0;
}</code></pre> 
<blockquote> 
 <p>实际上这样的操作并不叫作初始化，更确切的说应该叫赋值化，因为初始化只能有一次，而这个操作却可以多次赋值</p> 
</blockquote> 
<p><strong>比如：</strong></p> 
<pre><code class="language-cpp">	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
		_year = 3;
	}
</code></pre> 
<blockquote> 
 <p>这里就对<span style="color:#fe2c24;"><strong>_year</strong></span>进行了两次赋值，所以这个操作不能称之为初始化，而应该称之为赋值</p> 
</blockquote> 
<h3 id="1.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">1.2 构造函数的初始化</h3> 
<p>构造函数的初始化应该是这样一种形式：</p> 
<pre><code class="language-cpp">class Date
{
public:
	Date(int year, int month, int day)
		:_year(year),
		_month(month),
		_day(day)
	{

	}	
private:
	int _year;
	int _month;
	int _day;
};
</code></pre> 
<p>有这样几个注意事项：</p> 
<blockquote> 
 <p>1、类中成员初始化时一定要按照它们声明的顺序来进行，尽量不要跳跃</p> 
 <p>2、每个成员只能在初始化列表中出现一次（初始化只能是一次）</p> 
 <p><span style="background-color:#ffd900;">3、</span><strong><span style="color:#777777;"><span style="background-color:#ffd900;">类中包含以下成员，必须放在初始化列表位置进行初始化： </span></span></strong></p> 
 <p><strong><span style="color:#777777;"><span style="background-color:#ffd900;">     ·  引用成员变量</span></span></strong></p> 
 <p><strong><span style="color:#777777;"><span style="background-color:#ffd900;">     ·  const成员变量 </span></span></strong></p> 
 <p><strong><span style="color:#777777;"><span style="background-color:#ffd900;">     ·  自定义类型成员(</span></span><span style="color:#777777;"><span style="background-color:#ffd900;">且该类没有默认构造函数时</span></span><span style="color:#777777;"><span style="background-color:#ffd900;">)</span></span></strong></p> 
</blockquote> 
<p><img alt="" height="476" src="https://images2.imgbox.com/a0/b3/9cuCVcFv_o.png" width="872"></p> 
<p>上面提到的一定要注意对于<strong>引用成员变量、const成员变量、自定义类型成员</strong>一定要在初始化列表中进行初始化：</p> 
<pre><code class="language-cpp">class A
{
public:
	A(int a)
		:_a(a)
	{}
private:
	int _a;
};
class B
{
public:
	B(int a, int ref)
		:_aobj(a)
		, _ref(ref)
		, _n(10)
	{}
private:
	A _aobj; // 没有默认构造函数
	int&amp; _ref; // 引用
	const int _n; // const 
};</code></pre> 
<h3 id="1.3%20explicit%E5%85%B3%E9%94%AE%E5%AD%97">1.3 explicit关键字</h3> 
<blockquote> 
 <p>对于接受单个参数的构造函数，不仅具有初始化的功能，还具有隐式转换的功能</p> 
</blockquote> 
<p>下面这三种都属于只接受单个参数的：</p> 
<blockquote> 
 <p><strong>1、构造函数只有一个参数</strong></p> 
 <p><strong>2、构造函数有多个参数，但是只有一个没有默认值</strong></p> 
 <p><strong>3、全缺省构造函数</strong></p> 
</blockquote> 
<pre><code class="language-cpp">class Date
{
public:
	// 1. 单参构造函数，没有使用explicit修饰，具有类型转换作用
	// explicit修饰构造函数，禁止类型转换---explicit去掉之后，代码可以通过编译
	explicit Date(int year)
		:_year(year)
	{}
	/*
	// 2. 虽然有多个参数，但是创建对象时后两个参数可以不传递，没有使用explicit修饰，具有类型转
   换作用
	// explicit修饰构造函数，禁止类型转换
	explicit Date(int year, int month = 1, int day = 1)
	: _year(year)
	, _month(month)
	, _day(day)
	{}
	*/
	Date&amp; operator=(const Date&amp; d)
	{
		if (this != &amp;d)
		{
			_year = d._year;
			_month = d._month;
			_day = d._day;
		}
		return *this;
	}
private:
	int _year;
	int _month;
	int _day;
};
void Test()
{
	Date d1(2022);
	// 用一个整形变量给日期类型对象赋值
	// 实际编译器背后会用2023构造一个无名对象，最后用无名对象给d1对象进行赋值
	d1 = 2023;
	// 将1屏蔽掉，2放开时则编译失败，因为explicit修饰构造函数，禁止了单参构造函数类型转换的作
//	用
}</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81static%E6%88%90%E5%91%98">二、static成员</h2> 
<p>用<span style="color:#fe2c24;"><strong>static</strong></span>修饰的成员变量就是类中的<strong>静态成员变量，</strong>用<span style="color:#fe2c24;"><strong>static</strong></span>修饰的成员函数就是<strong>静态成员函数</strong></p> 
<p><strong>我们需要注意的是静态成员变量一定要在类外进行初始化</strong></p> 
<pre><code class="language-cpp">class A
{
private:
	static int _a;
};

//在类外对_a进行初始化
int A::_a = 0;

int main()
{
	return 0;
}</code></pre> 
<p>注意事项：</p> 
<blockquote> 
 <p>1、静态成员存放在静态区，为所有类成员共享</p> 
 <p>2、静态成员必须在类外定义（初始化），类中只是声明</p> 
 <p>3、静态成员访问方式：<strong>类名：：静态成员</strong>或者<strong>对象.静态成员</strong></p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E5%8F%8B%E5%85%83"><strong>三、友元</strong></h2> 
<blockquote> 
 <p>友元是一种突破类封装的一种方法，在特定的情况下使用会有意想不到的好处，但是类存在的意义就是进行封装，所以友元的使用会破坏耦合性，所以我们平时要尽量减少使用友元</p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">友元有两种：友元类和友元函数</span></strong></p> 
<h3 id="3.1%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0">3.1 友元函数</h3> 
<p>对于一些函数而言，并不适合将它封装在类中，比如<strong>operator&lt;&lt;流输出函数</strong></p> 
<p>我们一般是这样用这个函数的：</p> 
<pre><code class="language-cpp">int main()
{
	cout &lt;&lt; d1 &lt;&lt; endl;
	return 0;
}</code></pre> 
<blockquote> 
 <p>而在将这个函数写在类中的时候，由于类中函数this指针默认的是第一个操作数（也就是左操作数），所以这样输出是不行的</p> 
</blockquote> 
<p><strong>需要这样才能保证：</strong></p> 
<pre><code class="language-cpp">int main()
{
	d1 &lt;&lt; cout;
	//或者
	d1.cout;
	return 0;
}</code></pre> 
<blockquote> 
 <p>但这样又违背常理，所以我们往往就需要在类外写一个全局函数来实现这个功能，但是在类外的话就不能直接访问类中的私有化成员，所以就有了友元函数的出现</p> 
</blockquote> 
<p><strong>友元函数实现上述功能的操作如下：</strong></p> 
<pre><code class="language-cpp">class Date
{
	friend ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d);
	friend istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d);
public:
	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}

private:
	int _year;
	int _month;
	int _day;
};
ostream&amp; operator&lt;&lt;(ostream&amp; _cout, const Date&amp; d)
{
	_cout &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day;
	return _cout;
}
istream&amp; operator&gt;&gt;(istream&amp; _cin, Date&amp; d)
{
	_cin &gt;&gt; d._year;
	_cin &gt;&gt; d._month;
	_cin &gt;&gt; d._day;
	return _cin;
}
int main()
{
	Date d;
	cin &gt;&gt; d;
	cout &lt;&lt; d &lt;&lt; endl;
	return 0;
}</code></pre> 
<h3 id="3.2%20%E5%8F%8B%E5%85%83%E7%B1%BB">3.2 友元类</h3> 
<blockquote> 
 <p>友元类跟上面的友元函数很想，也是间接访问一个类中私有化成员的一种方法</p> 
</blockquote> 
<p>比如一个时间类Time和一个日期类Date，我们就可以通过在时间类中声明日期类为时间类的友元类从而直接访问时间类中的私有成员变量</p> 
<pre><code class="language-cpp">class Time
{
	friend class Date;     //声明Date为友元类
private:
	int _hour;
	int _min;
};
class Date
{
public:
	void test(int hour, int min)
	{
		_t._hour = hour;       //可以在Date类中直接引用Time类私有成员变量
		_t._min = min;
	}
private:
	int _year;
	int _month;
	int _day;
	Time _t;
};</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB">四、内部类</h2> 
<blockquote> 
 <p>如果一个类定义在另一个类的内部，那么这个类就叫做那个类的内部类</p> 
</blockquote> 
<p><strong>重点：</strong></p> 
<blockquote> 
 <p><strong>1、内部类和外部类实际上还是两个完全独立的类，完全可以将它们两个分开写</strong></p> 
 <p><strong>2、内部类是外部类的友元类，可以访问外部类的私有成员，但外部类不是内部类的友元类</strong></p> 
 <p><strong>3、内部类可以直接访问外部类的静态成员，不需要外部类的对象名或者类名</strong></p> 
</blockquote> 
<p><strong>例如：</strong></p> 
<pre><code class="language-cpp">class A
{
public:
	class B
	{
	public:
		void Test(const A&amp; a)
		{
			cout &lt;&lt; k &lt;&lt; endl;    //静态变量可以直接访问
			cout &lt;&lt; a.h &lt;&lt; endl;
		}
	};
private:
	static int k;
	int h;
};
int A::k = 1;
int main()
{
	A::B b;
	b.Test(A());
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/70/3e/Tcbc9hlJ_o.png" width="742"></p> 
<h2 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">五、总结</h2> 
<blockquote> 
 <p>以上就是C++类与对象的全部内容了，这三期基本就把类与对象所有知识点全部囊括了，如果有不理解的地方，欢迎在评论区中指出或者与我私信交流！！！</p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">感谢各位大佬观看，创作不易，还请各位大佬点赞支持！！！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c5608ae1f658cf7ca8e8f11ca28fbef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年前端最新DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】(1)，面试经历分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56f40d5caaf1126df2c77fb27897a03f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】--- 深入剖析二叉树（中篇）--- 认识堆&amp;&amp;堆排序&amp;&amp;Topk</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>