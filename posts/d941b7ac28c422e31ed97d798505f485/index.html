<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构选择题（期末） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d941b7ac28c422e31ed97d798505f485/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构选择题（期末）">
  <meta property="og:description" content="1.给定N×N的二维数组A，则在不改变数组的前提下，查找最大元素的时间复杂度是（A）：
A.O(N2)
B.O(NlogN)
C.O(N)
D.O(N2logN)
两重循环即O(N2)的时间复杂度
2.与数据元素本身的形式、内容、相对位置、个数无关的是数据的（C ）。
A.存储结构
B.存储实现
C.逻辑结构
D.运算实现
逻辑结构是数据元素之间的关系，与数据元素本身无关
3.通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（B ）。 A.数据在同一范围内取值 B.不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致
C.每个数据元素都一样 D.数据元素所包含的数据项的个数要相等
4.下面代码段的时间复杂度是（D）。
s=0;
for ( i=0; i&lt;n; i&#43;&#43; )
for( j=0; j&lt;n; j&#43;&#43; )
s&#43;=B[i][j];
sum=s;
A.O(1)
B.O(log2n) C.O(n)
D.O(n2)
两重for循环，均为从0到n-1，所以是n*n，即O（n2）
5.下面代码段的时间复杂度是（D）。
i=1;
while( i&lt;=n )
i=i*3;
A.O(n)
B.O(n2)
C.O(1) D.O(log3n)
6.下面代码段的时间复杂度是（B）。
x=0;
for( i=1; i&lt;n; i&#43;&#43; )
for ( j=1; j&lt;=n-i; j&#43;&#43; )
x&#43;&#43;;
A.O(n)
B.O(n2) C.O(n3) D.O(2n)
7.要判断一个整数N（&gt;10）是否素数，我们需要检查3到 根号N 之间是否存在奇数可以整除N。则这个算法的时间复杂度是：(B)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-21T23:28:16+08:00">
    <meta property="article:modified_time" content="2024-05-21T23:28:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构选择题（期末）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.给定N×N的二维数组A，则在不改变数组的前提下，查找最大元素的时间复杂度是（A）：<br>  <br> A.O(N2)<br> B.O(NlogN)<br> C.O(N)<br> D.O(N2logN)</p> 
<p><span style="color:#fe2c24;"><strong>两重循环即O(N2)的时间复杂度</strong></span></p> 
<p><br> 2.与数据元素本身的形式、内容、相对位置、个数无关的是数据的（C ）。<br> A.存储结构<br> B.存储实现<br> C.逻辑结构<br> D.运算实现</p> 
<p><strong><span style="color:#fe2c24;">逻辑结构是数据元素之间的关系，与数据元素本身无关</span></strong></p> 
<p>3.通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（B ）。 <br> A.数据在同一范围内取值 <br> B.不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致<br> C.每个数据元素都一样 <br> D.数据元素所包含的数据项的个数要相等</p> 
<p>4.下面代码段的时间复杂度是（D）。<br> s=0;<br> for ( i=0; i&lt;n; i++ )<br>     for( j=0; j&lt;n; j++ )<br>         s+=B[i][j];<br> sum=s;<br>  <br> A.O(1)<br> B.O(log2n) <br> C.O(n)<br> D.O(n2)</p> 
<p><span style="color:#fe2c24;"><strong>两重for循环，均为从0到n-1，所以是n*n，即O（n2</strong></span><span style="color:#fe2c24;"><strong>）</strong></span></p> 
<p>5.下面代码段的时间复杂度是（D）。<br> i=1;<br> while( i&lt;=n )<br>     i=i*3;<br>  <br> A.O(n)<br> B.O(n2)<br> C.O(1) <br> D.O(log3n)</p> 
<p><img alt="" height="125" src="https://images2.imgbox.com/67/95/Vi5fmp82_o.png" width="954"></p> 
<p>6.下面代码段的时间复杂度是（B）。<br> x=0;<br> for( i=1; i&lt;n; i++ )<br>     for ( j=1; j&lt;=n-i; j++ )<br>         x++;<br>  <br> A.O(n)<br> B.O(n2) <br> C.O(n3) <br> D.O(2n)</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/8f/b9/ouCB16sP_o.png" width="761"></p> 
<p>7.要判断一个整数N（&gt;10）是否素数，我们需要检查3到 根号N 之间是否存在奇数可以整除N。则这个算法的时间复杂度是：(B)<br> A.O(N/2) <br> B.O(根号N) <br> C.O(NlogN)<br> D.O(0.5logN)</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/ac/3b/PLeVOcPt_o.png" width="1090"></p> 
<p>8.下面的程序段违反了算法的（A）原则。<br> void sam()<br> {  int n=2;<br>    while (n%2==0)    n+=2;<br>    printf(“%d”,n);<br> }<br>  <br> A.有穷性 <br> B.确定性<br> C.可行性<br> D.健壮性</p> 
<p><span style="color:#fe2c24;"><strong>死循环</strong></span></p> 
<p>9.下列对顺序存储的有序表（长度为 n）实现给定操作的算法中，平均时间复杂度为 O(1) 的是(D)：<br> A.查找包含指定值元素的算法 <br> B.插入包含指定值元素的算法<br> C.删除第 i（1≤i≤n）个元素的算法<br> D.获取第 i（1≤i≤n）个元素的算法</p> 
<p></p> 
<p>10.数组A[1..5,1..6]每个元素占5个单元，将其按行优先次序存储在起始地址为1000的连续的内存单元中，则元素A[5,5]的地址为(C)：<br> A.1120<br> B.1125<br> C.1140<br> D.1145</p> 
<p><span style="color:#fe2c24;"><strong>数组A[1..5,1..6]是5行6列的二维数组，下标不是从0开始，而是从1开始</strong></span></p> 
<p>11.对于顺序存储的长度为N的线性表，访问结点和增加结点的时间复杂度为(B)：<br> A.O(1), O(1)<br> B.O(1), O(N)<br> C.O(N), O(1)<br> D.O(N), O(N)</p> 
<p><span style="color:#fe2c24;"><strong>访问：下标索引，为O（1）</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>增加：在不同位置增加1个节点需要后移的元素个数不同，分别为：0，1，2······n，取平均值为：（n+1）/ 2，即为 O（n）</strong></span></p> 
<p>12.线性表若采用链式存储结构时，要求内存中可用存储单元的地址(B)<br>  <br> A.必须是连续的 <br> B.连续或不连续都可以 <br> C.部分地址必须是连续的<br> D.一定是不连续的</p> 
<p>13.对于一个具有N个结点的单链表，在给定值为x的结点后插入一个新结点的时间复杂度为(C)<br> A.O(1)<br> B.O(N/2)<br> C.O(N)<br> D.O(N2)</p> 
<p><span style="color:#fe2c24;"><strong>查找次数分别为：0，1，2······n，取平均值为：（n+1）/ 2，即为 O（n）</strong></span></p> 
<p>14.链表不具有的特点是：(B)<br> A.插入、删除不需要移动元<br> B.方便随机访问任一元素<br> C.不必事先估计存储空间<br> D.所需空间与线性长度成正比</p> 
<p>15.设h为不带头结点的单向链表。在h的头上插入一个新结点t的语句是(D)：<br> A.h=t; t-&gt;next=h-&gt;next;<br> B.t-&gt;next=h-&gt;next; h=t;<br> C.h=t; t-&gt;next=h;<br> D.t-&gt;next=h; h=t;</p> 
<p>16.在单链表中，若p所指的结点不是最后结点，在p之后插入s所指结点，则执行(C)<br> A.s-&gt;next=p; p-&gt;next=s;<br> B.s-&gt;next=p-&gt;next; p=s;<br> C.s-&gt;next=p-&gt;next; p-&gt;next=s;<br> D.p-&gt;next=s; s-&gt;next=p;</p> 
<p><br> 17.带头结点的单链表h为空的判定条件是：(B)<br>  <br> A.h == NULL;<br> B.h-&gt;next == NULL;<br> C.h-&gt;next == h;<br> D.h != NULL;</p> 
<p>18.设一个堆栈的入栈顺序是1、2、3、4、5。若第一个出栈的元素是4，则最后一个出栈的元素必定是(D)： <br> A.1<br> B.3<br> C.5<br> D.1或者5</p> 
<p><span style="color:#fe2c24;"><strong>由这一句话“若第一个出栈的元素是4”知道了 栈里面压入了1，2，3</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>当4出栈后5入栈，出栈，然后1，2，3依次出栈，最后一个出栈的是1</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>当4出栈后1，2，3依次出栈，然后5入栈，出栈，最后一个出栈的是5</strong></span></p> 
<p>19.若top为指向栈顶元素的指针，判定栈S（最多容纳m个元素）为空的条件是(B)：<br> A.S-&gt;top == 0<br> B.S-&gt;top == -1<br> C.S-&gt;top != m-1<br> D.S-&gt;top == m-1</p> 
<p><strong><span style="color:#fe2c24;">栈为空时：S-&gt;top = -1</span></strong></p> 
<p>20.若栈采用顺序存储方式存储，现两栈共享空间V[m]：top[i]代表第i（i=1或2）个栈的栈顶；栈1的底在V[0]，栈2的底在V[m-1]，则栈满的条件是(D)：<br> A.|top[2]-top[1]|==0<br> B.top[1]+top[2]==m<br> C.top[1]==top[2]<br> D.top[1]+1==top[2]</p> 
<p>21.为解决计算机主机与打印机之间速度不匹配问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是？(B)<br> A.堆栈<br> B.队列<br> C.树<br> D.图</p> 
<p>22.若用大小为6的数组来实现循环队列，且当前front和rear的值分别为0和4。当从队列中删除两个元素，再加入两个元素后，front和rear的值分别为多少？(A)<br> A.2和0<br> B.2和2<br> C.2和4<br> D.2和6</p> 
<p>23.顺序表中第一个元素的存储地址是100，每个元素的长度为2，则第5个元素的地址是（ C）。<br> A.100<br> B.105<br> C.108<br> D.110</p> 
<p>24.设栈S和队列Q的初始状态均为空，元素{1, 2, 3, 4, 5, 6, 7}依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是{2, 5, 6, 4, 7, 3, 1}，则栈S的容量至少是：(D)<br> A.1<br> B.2<br> C.3<br> D.4</p> 
<p>25.给定一个堆栈的入栈序列为{ 1, 2, ⋯, n }，出栈序列为{ p1, p2, ⋯, pn }。如果p2=n，则存在多少种不同的出栈序列？(C)<br> A.1<br> B.2<br> C.n−1<br> D.n</p> 
<p><span style="color:#fe2c24;"><strong>已知第2个出栈的一定是n，假如n=4，那么可能的情况：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>1入栈，出栈，然后2，3，4入栈，最后依次出栈</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>1入栈，2入栈，出栈，然后3，4入栈，最后依次出栈</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>1，2入栈，3入栈，出栈，然后4入栈，最后依次出栈</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>当n=4时共3种情况</strong></span></p> 
<p></p> 
<p>26.现有队列 Q 与栈 S，初始时 Q 中的元素依次是{ 1, 2, 3, 4, 5, 6 }（1在队头），S 为空。若允许下列3种操作：（1）出队并输出出队元素；（2）出队并将出队元素入栈；（3）出栈并输出出栈元素，则不能得到的输出序列是：(C)<br> A.1, 2, 5, 6, 4, 3<br> B.2, 3, 4, 5, 6, 1<br> C.3, 4, 5, 6, 1, 2<br> D.6, 5, 4, 3, 2, 1</p> 
<p>27.循环队列的引入，目的是为了克服(A )。<br> A.假溢出问题<br> B.真溢出问题<br> C.空间不够用<br> D.操作不方便</p> 
<p><strong><span style="color:#fe2c24;">假溢出：</span></strong></p> 
<p><strong><span style="color:#fe2c24;">队列的假溢出通常是指在队列的存储空间尚未完全充满的情况下，由于特定的存储结构或算法导致的溢出现象。</span></strong><strong><span style="color:#fe2c24;">这通常发生在顺序队列中，其中队尾指针已经指向数组的最后一个位置，而队头指针并未指向数组的起始位置，这时如果进行入队操作，会显示队列已满，但实际上队列中仍有存储空间未被利用。</span></strong></p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/bd/9b/J42hPNYv_o.png" width="983"></p> 
<p></p> 
<p>28.用S表示入栈操作，X表示出栈操作，若元素入栈的顺序为1234，为了得到1342出栈顺序,相应的S和X的操作串为( D)。<br> A.SXSSSXXX<br> B.SXSXSXSX<br> C.SSSSXXXX<br> D.SXSSXSXX</p> 
<p>29.循环队列的队满条件为 ( C)。<br> A.(sq.rear+1) % maxsize ==(sq.front+1) % maxsize<br> B.(sq.front+1) % maxsize ==sq.rear<br> C.(sq.rear+1) % maxsize ==sq.front<br> D.sq.rear ==sq.front</p> 
<p><strong><span style="color:#fe2c24;">判空：rear==front</span></strong></p> 
<p><strong><span style="color:#fe2c24;">判满：（rear+1) % maxsize ==front</span></strong></p> 
<p>30.栈和队列的共同点是（ C）。<br> A.都是先进先出<br> B.都是先进后出<br> C.只允许在端点处插入和删除元素<br> D.没有共同点</p> 
<p>31.若某线性表最常用的操作是在表尾进行插入和删除，则利用哪种存储方式最合适？(A)<br> A.数组<br> B.单链表<br> C.双向链表<br> D.广义表</p> 
<p>32.若某线性表最常用的操作是在表头进行插入和删除，则利用哪种存储方式最合适？(A)<br> A.单链表<br> B.双向链表<br> C.数组<br> D.广义表</p> 
<p>33.树最适合于用来表示(D)<br> A.有序数据元素<br> B.无序数据元素<br> C.元素之间无联系的数据<br> D.元素之间具有分支层次关系的数据</p> 
<p>34.如果二叉树的后序遍历结果是FDEBGCA，中序遍历结果是FDBEACG，那么该二叉树的前序遍历结果是什么？(C)<br> A.ABCDEFG<br> B.ABDFEGC<br> C.ABDFECG<br> D.ABDEFCG</p> 
<p>35.在下述结论中，正确的是：(A)<br> ①只有一个结点的二叉树的度为0;<br> ②二叉树的度为2；<br> ③二叉树的左右子树可任意交换；<br> ④深度为K的完全二叉树的结点个数小于或等于深度相同的满二叉树。<br> A.①④<br> B.②④<br> C.①②③<br> D.②③④</p> 
<p>36.任何一棵二叉树的叶结点在先序、中序和后序遍历序列中的相对次序(B)<br> A.发生改变<br> B.不发生改变<br> C.不能确定<br> D.以上都不对</p> 
<p><span style="color:#fe2c24;"><strong>因为三种遍历序列均按照左右次序</strong></span></p> 
<p>37.按照二叉树的定义，具有3个结点的二叉树有几种？(C)<br> A.3<br> B.4<br> C.5<br> D.6</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/e0/15/WyGbzW5B_o.png" width="977"></p> 
<p>38.二叉树中第5层（根的层号为1）上的结点个数最多为：(C)<br> A.8<br> B.15<br> C.16<br> D.32</p> 
<p>39.先序遍历图示二叉树的结果为(B)</p> 
<p></p> 
<p class="img-center"><img alt="" height="164" src="https://images2.imgbox.com/a4/80/rFiFeK7o_o.png" width="212"></p> 
<p><br> A.A，B，C，D，H，E，I，F，G<br> B.A，B，D，H，I，E，C，F，G<br> C.H，D，I，B，E，A，F，C，G<br> D.H，I，D，B，E，F，G，A，C</p> 
<p>40.对二叉搜索树进行什么遍历可以得到从小到大的排序序列？(C)<br> A.前序遍历<br> B.后序遍历<br> C.中序遍历<br> D.层次遍历</p> 
<p><strong><span style="color:#fe2c24;">二叉搜索树：若它的左子树不空，则左子树上所有结点的值均小于它的根节点</span><span style="color:#fe2c24;">的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</span></strong></p> 
<p>41.在有N个结点且为完全二叉树的二叉搜索树中查找一个键值，其平均比较次数的数量级为(A)<br> A.O(logN)<br> B.O(N)<br> C.O(NlogN)<br> D.O(N2)</p> 
<p><strong><span style="color:#fe2c24;">寻找可能的次数：1，2······logN，求平均值：(logN)/2+1/2，即 O（logN）</span></strong></p> 
<p>42.已知8个数据元素为（34，76，45，18，26，54，92，65），按照依次插入结点的方法生成一棵二叉搜索树后，最后两层上的结点总数为：(B)<br> A.1 <br> B.2<br> C.3<br> D.4</p> 
<p>43.具有65个结点的完全二叉树其深度为（根的深度为1）：(B)<br> A.8<br> B.7<br> C.6<br> D.5</p> 
<p>44.堆的形状是一棵：(D)<br> A.二叉搜索树<br> B.满二叉树<br> C.非二叉树<br> D.完全二叉树</p> 
<p>45.对N（N≥2）个权值均不相同的字符构造哈夫曼树。下列关于该哈夫曼树的叙述中，错误的是： (D)<br> A.树中一定没有度为1的结点<br> B.树中两个权值最小的结点一定是兄弟结点<br> C.树中任一非叶结点的权值一定不小于下一层任一结点的权值<br> D.该树一定是一棵完全二叉树</p> 
<p>46.设一段文本中包含字符{a, b, c, d, e}，其出现频率相应为{3, 2, 5, 1, 1}。则经过哈夫曼编码后，文本所占字节数为：(C)<br>  <br> A.40<br> B.36<br> C.25<br> D.12</p> 
<p><img alt="" height="462" src="https://images2.imgbox.com/96/24/m0xhQAxn_o.png" width="224"></p> 
<p><span style="color:#fe2c24;"><strong>结果=频率（黑色的数）*路径长度 求和</strong></span></p> 
<p>47.由分别带权为9、2、5、7的四个叶子结点构成一棵哈夫曼树，该树的带权路径长度为：(C)<br> A.23<br> B.37<br> C.44<br> D.46</p> 
<p>48.如果二叉树的前序遍历结果是12345，后序遍历结果是32541，那么该二叉树的中序遍历结果是什么？(D)<br> A.23145<br> B.23154<br> C.24135<br> D.无法确定</p> 
<p><span style="color:#fe2c24;"><strong>已知前序，后序无法确定</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>已知前序，中序唯一确定</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>已知后序，中序唯一确定</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>因为中序可以把左右子树分开，从中序里面能知道左子树有哪些，右子树有哪些。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>前序，后序都没有这个功能</strong></span></p> 
<p>49.有一个四叉树，度2的结点数为2，度3的结点数为3，度4的结点数为4。问该树的叶结点个数是多少？(D)<br> A.10<br> B.12<br> C.20<br> D.21</p> 
<p><span style="color:#fe2c24;"><strong>N0+N2+N3+N4=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2*N2+3*N3+4*N4+1=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>带入得：No+2+3+4=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>            2*2+3*3+4*4+1=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>得No=21</strong></span></p> 
<p></p> 
<p>50.若一棵二叉树的前序遍历序列是{ 4, 2, 1, 3, 6, 5, 7 }，中序遍历序列是{ 1, 2, 3, 4, 5, 6, 7 }，则下列哪句是错的？(D)<br> A.这是一棵完全二叉树<br> B.所有的奇数都在叶子结点上<br> C.这是一棵二叉搜索树<br> D.2是5的父结点</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/4d/19/RRoo4Hix_o.png" width="241"></p> 
<p>51.具有1102个结点的完全二叉树一定有__个叶子结点。(B)<br> A.79<br> B.551<br> C.1063<br> D.不确定</p> 
<p>52.若一棵二叉树的后序遍历序列是{ 1, 3, 2, 6, 5, 7, 4 }，中序遍历序列是{ 1, 2, 3, 4, 5, 6, 7 }，则下列哪句是错的？(A)<br> A.这是一棵完全二叉树<br> B.2是1和3的父结点<br> C.这是一棵二叉搜索树<br> D.7是5的父结点</p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/ab/3d/NDzqdFBy_o.png" width="202"></p> 
<p>53.已知一棵二叉树的树形如下图所示，其后序序列为{ e, a, c, b, d, g, f }。树中与结点a同层的结点是：(B)</p> 
<p></p> 
<p class="img-center"><img alt="" height="103" src="https://images2.imgbox.com/e3/bc/F68LErak_o.png" width="93"></p> 
<p><br> A.c<br> B.d<br> C.f<br> D.g</p> 
<p>54.已知字符集{ a, b, c, d, e, f }，若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是：(A)<br> A.00, 1011, 01, 1010, 11, 100<br> B.00, 100, 110, 000, 0010, 01<br> C.10, 1011, 11, 0011, 00, 010<br> D.0011, 10, 11, 0010, 01, 000</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/49/11/LAPM6kLc_o.png" width="259"></p> 
<p><span style="color:#fe2c24;"><strong>左0右1</strong></span></p> 
<p>55.若将一棵树 T 转化为对应的二叉树 BT，则下列对 BT 的遍历中，其遍历序列与 T 的后根遍历序列相同的是：(B)<br> A.先序遍历<br> B.中序遍历<br> C.后序遍历<br> D.按层遍历</p> 
<p>56.对 n 个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有 115 个结点，则 n 的值是：(C)<br> A.56<br> B.57<br> C.58<br> D.60</p> 
<p><span style="color:#fe2c24;"><strong>数字分为2部分，一部分是n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>另一部分是n-1</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>n+n-1=115</strong></span></p> 
<p>57.以二叉链表作为二叉树的存储结构，在具有 n 个结点的二叉链表中（n&gt;0），空链域的个数为 __(A)<br> A.n+1<br> B.n<br> C.n−1<br> D.无法确定</p> 
<p><span style="color:#fe2c24;"><strong>二叉树空链域：2n-（n-1）=n+1</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>x叉树空链域：xn-（n-1）=（x-1）n+1</strong></span></p> 
<p>58.已知二叉树的前序遍历序列为 ABDCEFG，中序遍历序列为 DBCAFEG，则后序遍历序列为 __(B)<br> A.BDACEFG<br> B.DCBFGEA<br> C.ABCDEFG<br> D.GFEDCBA</p> 
<p>59.利用过滤法将关键字序列 { 37, 66, 48, 29, 31, 75 } 建成的最大堆为 __(C)<br> A.75, 66, 48, 37, 31, 29<br> B.75, 37, 66, 29, 31, 48<br> C.75, 66, 48, 29, 31, 37<br> D.75, 48, 66, 37, 29, 31</p> 
<p><a href="https://blog.csdn.net/2301_80484340/article/details/137755872?spm=1001.2014.3001.5501" title="最大堆创建（过滤法）用c++编译运行-CSDN博客">最大堆创建（过滤法）用c++编译运行-CSDN博客</a></p> 
<p>60.在一棵度为 3 的树中，度为 2 的结点个数是 1，度为 0 的结点个数是 6，则度为 3 的结点个数是 __(A)<br> A.2<br> B.3<br> C.4<br> D.无法确定</p> 
<p><span style="color:#fe2c24;"><strong>方程组为：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>No+N2+N3=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2 * N2+3*N3+1=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>带入得：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>6+1+N3=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2*1+3*N3+1=n</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>解得N3=2</strong></span></p> 
<p>61.一棵有47个结点的树一定有______条边。(B)<br> A.47<br> B.46<br> C.92<br> D.23</p> 
<p>62.与表达式 x+y*(z-u)/v 等价的后缀表达式是（A）<br> A.xyzu-*v/+<br> B.xyzu-v/*+<br> C.+x/*y-zuv<br> D.+x*y/-zuv</p> 
<p>63.具有5个顶点的有向完全图有多少条弧？(C)<br> A.10<br> B.16<br> C.20<br> D.25</p> 
<p><span style="color:#fe2c24;"><strong>有向完全图：n*(n-1)</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>无向完全图：n*(n-1) / 2</strong></span></p> 
<p>64.对于一个具有N个顶点的无向图，要连通所有顶点至少需要多少条边？(A)<br> A.N−1<br> B.N<br> C.N+1<br> D.N/2</p> 
<p>65.具有N（N&gt;0）个顶点的无向图至多有多少个连通分量？(D)<br> A.0<br> B.1<br> C.N−1<br> D.N</p> 
<p><span style="color:#fe2c24;"><strong>每一个顶点都可以是一个连通分量</strong></span></p> 
<p>66.如果G是一个有28条边的非连通无向图，那么该图顶点个数最少为多少？(C)<br> A.7<br> B.8<br> C.9<br> D.10</p> 
<p><span style="color:#fe2c24;"><strong>如果求顶点个数最少，即该图由一个完全无向图与一个顶点（不与任何顶点相连）构成的一个图</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>一个含有n个顶点的无向图最多有n(n-1)/2个边（完全无向图）</strong></span></p> 
<p>67.对于有向图，其邻接矩阵表示比邻接表表示更易于：(A)<br> A.求一个顶点的入度<br> B.求一个顶点的出边邻接点<br> C.进行图的深度优先遍历<br> D.进行图的广度优先遍历</p> 
<p>68.对于一个具有N个顶点的无向图，若采用邻接矩阵表示，则该矩阵的大小是：(D)<br> A.N−1<br> B.N<br> C.(N−1)2<br> D.N2</p> 
<p>69.若一个有向图用邻接矩阵表示，则第i个结点的入度就是：(C)<br> A.第i行的元素个数<br> B.第i行的非零元素个数<br> C.第i列的非零元素个数<br> D.第i列的零元素个数</p> 
<p>70.关于图的邻接矩阵，下列哪个结论是正确的？(B)<br> A.有向图的邻接矩阵总是不对称的<br> B.有向图的邻接矩阵可以是对称的，也可以是不对称的<br> C.无向图的邻接矩阵总是不对称的<br> D.无向图的邻接矩阵可以是不对称的，也可以是对称的</p> 
<p>71.在任一有向图中，所有顶点的入度之和与所有顶点的出度之和的关系是：(A)<br> A.相等<br> B.大于等于<br> C.小于等于<br> D.不确定</p> 
<p>72.下列说法不正确的是：(D)<br> A.图的遍历是从给定的源点出发每一个顶点仅被访问一次<br> B.遍历的基本算法有两种：深度遍历和广度遍历<br> C.图的深度遍历是一个递归过程<br> D.图的深度遍历不适用于有向图</p> 
<p>73.图的深度优先遍历类似于二叉树的：(A)<br> A.先序遍历<br> B.中序遍历<br> C.后序遍历<br> D.层次遍历</p> 
<p><span style="color:#fe2c24;"><strong>DFS和先序遍历均是一条路走到黑，遇到死路再回退，然后重复此操作</strong></span></p> 
<p>74.在用邻接表表示有N个结点E条边的图时，深度优先遍历算法的时间复杂度为：(B)<br> A.O(N)<br> B.O(N+E)<br> C.O(N2)<br> D.O(N2×E)</p> 
<p><span style="color:#fe2c24;"><strong>邻接矩阵：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>DFS：O(V2)            BFS：O(V2)</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>邻接表：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>DFS：O(N+E)              BFS：O(N+E)</strong></span></p> 
<p>75.在图中自d点开始进行深度优先遍历算法可能得到的结果为： (C)</p> 
<p></p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/51/39/89mZgtH0_o.png" width="190"></p> 
<p><br> A.d,a,c,f,e,b<br> B.d,a,e,b,c,f<br> C.d,e,a,c,f,b<br> D.d,f,c,e,a,b</p> 
<p>76.给定无向图G，从V0出发进行深度优先遍历访问的边集合为： {(V0,V1), (V0,V4), (V1,V2), (V1,V3), (V4,V5), (V5,V6)}。则下面哪条边不可能出现在G中？(C)<br> A.(V0,V2)<br> B.(V0,V6)<br> C.(V1,V5)<br> D.(V4,V6)</p> 
<p>77.给定一有向图的邻接表如下。从顶点V1出发按深度优先搜索法进行遍历，则得到的一种顶点序列为：(B)</p> 
<p></p> 
<p class="img-center"><img alt="" height="134" src="https://images2.imgbox.com/fd/79/0anPW0bX_o.png" width="220"></p> 
<p><br> A.V1,V2,V3,V5,V4<br> B.V1,V3,V4,V5,V2<br> C.V1,V4,V3,V5,V2<br> D.V1,V2,V4,V5,V3</p> 
<p><a href="https://blog.csdn.net/2301_80484340/article/details/137964992?spm=1001.2014.3001.5502" title="DFS有向图（用c++编译运行）-CSDN博客">DFS有向图（用c++编译运行）-CSDN博客</a></p> 
<p>78.在图中自c点开始进行广度优先遍历算法可能得到的结果为：(C)</p> 
<p></p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/15/af/gj0RmHR2_o.png" width="190"></p> 
<p><br> A.c,a,b,e,f,d<br> B.c,a,f,d,e,b<br> C.c,f,a,d,e,b<br> D.c,f,a,b,d,e</p> 
<p><a href="https://blog.csdn.net/2301_80484340/article/details/138022449?spm=1001.2014.3001.5502" title="BFS（用C++编译运行）-CSDN博客">BFS（用C++编译运行）-CSDN博客</a></p> 
<p>79.给定一有向图的邻接表如下。从顶点V1出发按广度优先搜索法进行遍历，则得到的一种顶点序列为：(C)</p> 
<p></p> 
<p class="img-center"><img alt="" height="134" src="https://images2.imgbox.com/df/38/kEuhczVd_o.png" width="220"></p> 
<p><br> A.V1,V2,V3,V4,V5<br> B.V1,V2,V3,V5,V4<br> C.V1,V3,V2,V4,V5<br> D.V1,V4,V3,V5,V2</p> 
<p>80.我们用一个有向图来表示航空公司所有航班的航线。下列哪种算法最适合解决找给定两城市间最经济的飞行路线问题？(A)<br> A.Dijkstra算法<br> B.Kruskal算法<br> C.深度优先搜索<br> D.拓扑排序算法</p> 
<p>81.数据结构中Dijkstra算法用来解决哪个问题？(B)<br> A.关键路径<br> B.最短路径<br> C.拓扑排序<br> D.字符串匹配</p> 
<p>82.给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：(D)</p> 
<p></p> 
<p class="img-center"><img alt="" height="143" src="https://images2.imgbox.com/87/7e/jcM0aK4b_o.png" width="150"></p> 
<p><br> A.10<br> B.11<br> C.12<br> D.14</p> 
<p>83.下图为一个AOV网，其可能的拓扑有序序列为：（D）</p> 
<p></p> 
<p class="img-center"><img alt="" height="152" src="https://images2.imgbox.com/9a/e6/ZE81PtLK_o.png" width="250"></p> 
<p><br> A.ACBDEF<br> B.ABCEFD<br> C.ABCDFE<br> D.ABCEDF</p> 
<p>84.在AOE网中，什么是关键路径？(D)<br> A.最短回路<br> B.最长回路<br> C.从第一个事件到最后一个事件的最短路径<br> D.从第一个事件到最后一个事件的最长路径</p> 
<p>85.在拓扑排序算法中用堆栈和用队列产生的结果会不同吗？(C)<br> A.是的肯定不同<br> B.肯定是相同的<br> C.有可能会不同<br> D.以上全不对</p> 
<p>86.下面给出的有向图中，有__个强连通分量。(C)</p> 
<p></p> 
<p class="img-center"><img alt="" height="110" src="https://images2.imgbox.com/86/6d/Ditnl0Xr_o.png" width="125"></p> 
<p><br> A.1 ({0,1,2,3,4})<br> B.1 ({1,2,3,4})<br> C.2 ({1,2,3,4}, {0})<br> D.5 ({0}, {1}, {2}, {3}, {4})</p> 
<p>87.下面给出的有向图中，各个顶点的入度和出度分别是：(A)</p> 
<p class="img-center"><img alt="" height="110" src="https://images2.imgbox.com/f1/03/XjzsVjAY_o.png" width="125"></p> 
<p><br> A.入度: 0, 2, 3, 1, 2; 出度: 3, 2, 1, 1, 1<br> B.入度: 3, 2, 1, 1, 1; 出度: 0, 2, 3, 1, 2<br> C.入度: 3, 4, 4, 2, 3; 出度: 3, 4, 4, 2, 3<br> D.入度: 0, 1, 2, 1, 1; 出度: 3, 2, 1, 1, 1</p> 
<p>88.给定一个有向图的邻接表如下图，则该图有__个强连通分量。（B）</p> 
<p></p> 
<p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/7a/0a/U5HlHJ24_o.png" width="168"></p> 
<p><br> A.4 {<!-- -->{0, 1, 5}, {2}, {3}, {4}}<br> B.3 {<!-- -->{2}, {4}, {0, 1, 3, 5}}<br> C.1 {0, 1, 2, 3, 4, 5}<br> D.1 {0, 5, 1, 3}</p> 
<p>89.使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是：(B)</p> 
<p></p> 
<p class="img-center"><img alt="" height="164" src="https://images2.imgbox.com/77/31/A6ogL39D_o.png" width="308"></p> 
<p><br> A.5, 2, 3, 4, 6<br> B.5, 2, 3, 6, 4<br> C.5, 2, 4, 3, 6<br> D.5, 2, 6, 3, 4</p> 
<p>90.给定有向图的邻接矩阵如下： </p> 
<p></p> 
<p class="img-center"><img alt="" height="99" src="https://images2.imgbox.com/3b/23/zE2AXMBN_o.png" width="98"></p> 
<p><br> 顶点2（编号从0开始）的出度和入度分别是：（C）<br> A.3, 1<br> B.1, 3<br> C.0, 2<br> D.2, 0</p> 
<p>91.给定有权无向图如下。关于其最小生成树，下列哪句是对的？（A）</p> 
<p></p> 
<p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/79/69/OY6HpSst_o.png" width="278"></p> 
<p><br> A.最小生成树不唯一，其总权重为23<br> B.最小生成树唯一，其总权重为20<br> C.边(B, F)一定在树中，树的总权重为23<br> D.边(H, G)一定在树中，树的总权重为20</p> 
<p>92.拓扑排序<br> ▁▁▁▁▁ 是下面 AOV 网的一个拓扑序列。(B)</p> 
<p></p> 
<p class="img-center"><img alt="题图.jpg" height="160" src="https://images2.imgbox.com/ac/b0/UvgMb3Qa_o.jpg" width="280"></p> 
<p><br> A.BDACFEG<br> B.ACBDFEG<br> C.ABDCFEG<br> D.CDEABFG</p> 
<p>93.下图是一个有 10 个活动的 AOE 网，时间余量最大的活动是：(B)</p> 
<p></p> 
<p class="img-center"><img alt="AOE网.png" height="182" src="https://images2.imgbox.com/fb/df/xs4Ca0hw_o.png" width="487"></p> 
<p><br> A.c<br> B.g<br> C.h <br> D.j</p> 
<p>94.下列排序算法中，哪种算法可能出现：在最后一趟开始之前，所有的元素都不在其最终的位置上？（设待排元素个数N&gt;2）(B)<br> A.冒泡排序<br> B.插入排序<br> C.堆排序<br> D.快速排序</p> 
<p><a href="https://blog.csdn.net/2301_80484340/article/details/138122770?spm=1001.2014.3001.5502" title="插入 排序-CSDN博客">插入 排序-CSDN博客</a></p> 
<p>95.就排序算法所用的辅助空间而言，堆排序、快速排序、归并排序的关系是：(C)<br>  <br> A.堆排序 &lt; 归并排序 &lt; 快速排序<br> B.堆排序 &gt; 归并排序 &gt; 快速排序<br> C.堆排序 &lt; 快速排序 &lt; 归并排序<br> D.堆排序 &gt; 快速排序 &gt; 归并排序</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6f/8a/dTZZazhh_o.jpg"></p> 
<p>96.对N个不同的数据采用冒泡算法进行从大到小的排序，下面哪种情况下肯定交换元素次数最多？(A)<br> A.从小到大排好的<br> B.从大到小排好的<br> C.元素无序<br> D.元素基本有序</p> 
<p>97.对于序列{ 49，38，65，97，76，13，27，50 }，按由小到大进行排序，下面哪一个是初始步长为4的希尔排序法第一趟的结果？(B)<br> A.13,27,38,49,50,65,76,97<br> B.49,13,27,50,76,38,65,97<br> C.49,76,65,13,27,50,97,38<br> D.97,76,65,50,49,38,27,13</p> 
<p><a href="https://blog.csdn.net/2301_80484340/article/details/138161914?spm=1001.2014.3001.5502" title="希尔排序 （最后附完整代码）-CSDN博客">希尔排序 （最后附完整代码）-CSDN博客</a></p> 
<p>98.给定初始待排序列{ 15，9，7，8，20，-1，4 }。如果希尔排序第一趟结束后得到序列为{ 15，-1，4，8，20，9，7 }，则该趟增量为：(D)<br> A.1<br> B.2<br> C.3<br> D.4</p> 
<p><a href="https://blog.csdn.net/2301_80484340/article/details/138161914?spm=1001.2014.3001.5502" title="希尔排序 （最后附完整代码）-CSDN博客">希尔排序 （最后附完整代码）-CSDN博客</a></p> 
<p>99.对大部分元素已有序的数组进行排序时，直接插入排序比简单选择排序效率更高，其原因是：(A)<br> •    (I). 直接插入排序过程中元素之间的比较次数更少<br> •    (II). 直接插入排序过程中所需要的辅助空间更少<br> •    (III). 直接插入排序过程中元素的移动次数更少<br> A.仅 I<br> B.仅 III<br> C.仅 I、II<br> D.I、II 和 III</p> 
<p>100.在下列查找的方法中，平均查找长度与结点个数无关的查找方法是：(C)<br> A.顺序查找 <br> B.二分法<br> C.利用哈希（散列）表<br> D.利用二叉搜索树</p> 
<p>101.假定有K个关键字互为同义词，若用线性探测法把这K个关键字存入散列表中，至少要进行多少次探测？(D)<br> A.K−1<br> B.K<br> C.K+1<br> D.K(K+1)/2</p> 
<p><span style="color:#fe2c24;"><strong>1+2+3+·····+k = K(K+1)/2</strong></span></p> 
<p>102.将元素序列{18，23，11，20，2，7，27，33，42，15}按顺序插入一个初始为空的、大小为11的散列表中。散列函数为：H(Key)=Key%11，采用线性探测法处理冲突。问：当第一次发现有冲突时，散列表的装填因子大约是多少？(B)<br> A.0.27<br> B.0.45<br> C.0.64<br> D.0.73</p> 
<p>103.给定散列表大小为11，散列函数为H(Key)=Key%11。采用平方探测法处理冲突：hi(k)=(H(k)±i2)%11将关键字序列{ 6，25，39，61 }依次插入到散列表中。那么元素61存放在散列表中的位置是：(A)<br> A.5 <br> B.6<br> C.7 <br> D.8</p> 
<p>104.现有长度为 7、初始为空的散列表HT，散列函数H(k)=k%7，用线性探测再散列法解决冲突。将关键字 22, 43, 15 依次插入到HT后，查找成功的平均查找长度是：(C)<br> A.1.5<br> B.1.6<br> C.2<br> D.3</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/91ac78a7e3cc9cc570795c9152869712/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最简单的方式解决android studio 模拟器无法联网的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2db4423deeb9370321f2050e19be03bd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字符串函数（二）：strlen(求长度)，strstr(查找子串)，strtok(分割)，strerror(打印错误信息)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>