<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Springboot利用CompletableFuture异步执行线程（有回调和无回调） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/88a5e31580471ad45c6d32a9c8b5e690/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Springboot利用CompletableFuture异步执行线程（有回调和无回调）">
  <meta property="og:description" content="目录
背景
实现
一、异步线程配置类
二、自定义异步异常统一处理类
三、实现调用异步（无回调-runAsync()）
四、实现调用异步（有回调-supplyAsync()） 五、异步执行错误异常示例
背景 项目中总会有需要异步执行来避免浪费时间资源的情况，这就需要异步操作。异步又分两种：
1、无回调：有一些执行过程对用户而言不需要反馈回调，只需要自己执行即可，且执行过程时间较长（某些第三方接口，如发送短信验证码、查取ip属地等等），如果同步执行，势必会影响到用户体验，这时候就可以使用CompletableFuture.runAsync()方法了。
2、有回调：在执行异步操作结束后，需要获得异步方法返回的值，然后再回调给用户展示，这时候就需要用到CompletableFuture.supplyAsync()方法了。
实现 一、异步线程配置类 /** * 异步线程配置类 */ @EnableAsync @Configuration public class AsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 设置核心线程数 executor.setCorePoolSize(8); // 设置最大线程数 executor.setMaxPoolSize(20); // 设置队列大小 executor.setQueueCapacity(Integer.MAX_VALUE); // 设置线程活跃时间(秒) executor.setKeepAliveSeconds(60); // 设置线程名前缀&#43;分组名称 executor.setThreadNamePrefix(&#34;AsyncOperationThread-&#34;); executor.setThreadGroupName(&#34;AsyncOperationGroup&#34;); // 所有任务结束后关闭线程池 executor.setWaitForTasksToCompleteOnShutdown(true); // 初始化 executor.initialize(); return executor; } /** * 自定义异步异常 * @return */ @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new AsyncException(); } } 二、自定义异步异常统一处理类 /** * 异步请求异常错误 */ public class AsyncException implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException(Throwable throwable, Method method, Object.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-15T10:46:14+08:00">
    <meta property="article:modified_time" content="2024-01-15T10:46:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Springboot利用CompletableFuture异步执行线程（有回调和无回调）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%83%8C%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E8%83%8C%E6%99%AF" rel="nofollow">背景</a></p> 
<p id="%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0" rel="nofollow">实现</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%B1%BB" rel="nofollow">一、异步线程配置类</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E5%BC%82%E5%B8%B8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E5%BC%82%E5%B8%B8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E7%B1%BB" rel="nofollow"> 二、自定义异步异常统一处理类</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5" rel="nofollow">三、实现调用异步（无回调-runAsync()）</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E6%9C%89%E5%9B%9E%E8%B0%83-supplyAsync()%EF%BC%89%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E6%9C%89%E5%9B%9E%E8%B0%83-supplyAsync%28%29%EF%BC%89%C2%A0%C2%A0" rel="nofollow">四、实现调用异步（有回调-supplyAsync()）  </a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%E7%A4%BA%E4%BE%8B" rel="nofollow">五、异步执行错误异常示例</a></p> 
<h3 id="%E8%83%8C%E6%99%AF">背景</h3> 
<p>项目中总会有需要异步执行来避免浪费时间资源的情况，这就需要异步操作。异步又分两种：</p> 
<p><strong>1、无回调</strong>：有一些执行过程对用户而言不需要反馈回调，只需要自己执行即可，且执行过程时间较长（某些第三方接口，如发送短信验证码、查取ip属地等等），如果同步执行，势必会影响到用户体验，这时候就可以使用<strong>CompletableFuture.<span style="color:#fe2c24;">run</span>Async()</strong>方法了。</p> 
<p><strong>2、有回调</strong>：在执行异步操作结束后，需要获得异步方法返回的值，然后再回调给用户展示，这时候就需要用到<strong>CompletableFuture.<span style="color:#fe2c24;">supply</span>Async()</strong>方法了。</p> 
<h3 id="%E5%AE%9E%E7%8E%B0">实现</h3> 
<h4 id="%E4%B8%80%E3%80%81%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%B1%BB">一、异步线程配置类</h4> 
<pre><code class="language-java">/**
 * 异步线程配置类
 */
@EnableAsync
@Configuration
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 设置核心线程数
        executor.setCorePoolSize(8);
        // 设置最大线程数
        executor.setMaxPoolSize(20);
        // 设置队列大小
        executor.setQueueCapacity(Integer.MAX_VALUE);
        // 设置线程活跃时间(秒)
        executor.setKeepAliveSeconds(60);
        // 设置线程名前缀+分组名称
        executor.setThreadNamePrefix("AsyncOperationThread-");
        executor.setThreadGroupName("AsyncOperationGroup");
        // 所有任务结束后关闭线程池
        executor.setWaitForTasksToCompleteOnShutdown(true);
        // 初始化
        executor.initialize();
        return executor;
    }

    /**
     * 自定义异步异常
     * @return
     */
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncException();
    }
}</code></pre> 
<h4 id="%C2%A0%E4%BA%8C%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E5%BC%82%E5%B8%B8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E7%B1%BB"> 二、自定义异步异常统一处理类</h4> 
<pre><code class="language-java">/**
 * 异步请求异常错误
 */
public class AsyncException  implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable throwable, Method method, Object... obj) {
        System.out.println("--------------------异步请求异常捕获---------------------------------");
        System.out.println("Exception message - " + throwable.getMessage());
        System.out.println("Method name - " + method.getName());
        for (Object param : obj) {
            System.out.println("Parameter value - " + param);
        }
        System.out.println("---------------------异步请求异常捕获---------------------------------");
    }
}</code></pre> 
<h4 id="%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5">三、实现调用异步（无回调-<strong><span style="color:#fe2c24;">run</span>Async()</strong>）</h4> 
<p>在需要异步的方法前加上@Async再调用即可如下，在service层中新建一个方法，模拟第三方接口请求延时3秒（异步方法和调用方法一定要写在<strong>不同的类中</strong> ,如果写在一个类中,是<strong>没有效果的</strong>！）</p> 
<pre><code class="language-java">@Service
public class LoginLogServiceImpl extends ServiceImpl&lt;LoginLogMapper, LoginLog&gt; implements ILoginLogService {

    // 无回调
    @Async
    public CompletableFuture&lt;Void&gt; test() {
        return CompletableFuture.runAsync(() -&gt; {

            // 模拟第三方请求加载时间
            Thread.sleep(3000);

            System.out.println("保存成功登录日志");
        });
    }
}</code></pre> 
<p> 然后在controller层中调用该方法，</p> 
<pre><code class="language-java">    @PostMapping("/login")
    public Result login() throws InterruptedException {

        System.out.println("登录验证成功");

        // 异步操作
        iLoginLogService.test();

        System.out.println("登录接口请求返回用户成功");

        // 正常返回结果
        return Result.success(200, "登录成功");
    }</code></pre> 
<p>执行完成后，我们打开控制台，可以看到， 异步请求在接口执行正常，在接口返回结果后执行完成。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/27/02/WRyY3vip_o.png"></p> 
<h4 id="%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E6%9C%89%E5%9B%9E%E8%B0%83-supplyAsync()%EF%BC%89%C2%A0%C2%A0">四、实现调用异步（有回调-<strong><span style="color:#fe2c24;">supply</span>Async()</strong>）  </h4> 
<p>这里我们多采用3个异步线程来模拟实际效果，且延迟时间为1 6 3，看下他们的异步执行输出顺序是否和我们模拟的执行时间相同，如下：</p> 
<pre><code class="language-java">@Service
public class LoginLogServiceImpl extends ServiceImpl&lt;LoginLogMapper, LoginLog&gt; implements ILoginLogService {

    // 有返回值的异步方法CompletableFuture.supplyAsync()
    public CompletableFuture&lt;String&gt; test1() {
        return CompletableFuture.supplyAsync(() -&gt; {
            ThreadUtil.sleep(1000);
            System.out.println("test1异步请求结果有返回");
            return "aaa";
        });
    }

    public CompletableFuture&lt;String&gt; test2() {
        return CompletableFuture.supplyAsync(() -&gt; {
            ThreadUtil.sleep(6000);
            System.out.println("test2异步请求结果有返回");
            return "bbb";
        });
    }

    public CompletableFuture&lt;String&gt; test3() {
        return CompletableFuture.supplyAsync(() -&gt; {
            ThreadUtil.sleep(3000);
            System.out.println("test3异步请求结果有返回");
            return "ccc";
        });
    }
}</code></pre> 
<p> 在controller层中利用CompletableFuture的get()方法获取数据，但是要加上try/catch捕获异常</p> 
<pre><code class="language-java">@PostMapping("/login")
    public Result login() {

        System.out.println("登录验证成功");

        // 异步保存登录成功日志
        CompletableFuture&lt;String&gt; future1 = iLoginLogService.test1();
        CompletableFuture&lt;String&gt; future2 = iLoginLogService.test2();
        CompletableFuture&lt;String&gt; future3 = iLoginLogService.test3();

        System.out.println("模拟正常执行的方法");

        String result1 = "111";
        String result2 = "222";
        String result3 = "333";
        String result = "";
        
        // 需要用try/catch来获取异步返回值
        try {
            
            // get()方法获取返回值，并设置10秒超时就放弃，直接报错
            result1 = future1.get(10, TimeUnit.SECONDS);
            result2 = future2.get(10, TimeUnit.SECONDS);
            result3 = future3.get(10, TimeUnit.SECONDS);

            System.out.println("返回结果为：" + result1);
            System.out.println("返回结果为：" + result2);
            System.out.println("返回结果为：" + result3);

            result = result1 + result2 + result3;

            // 正常返回结果
            return Result.success(200, "登录成功", result);
        } catch (Exception e) {
            System.out.println(e);
            return Result.success(501, "登录失败，异常错误");
        }
    }</code></pre> 
<p> 结果可以看到如下图所示，异步线程同时执行，但最后返回结果是等所有线程执行完成后，再返回，这就是有回调的异步操作：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/24/1b/QADYvnvs_o.png"></p> 
<h4 id="%E5%9B%9B%E3%80%81%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%E7%A4%BA%E4%BE%8B">五、异步执行错误异常示例</h4> 
<pre><code class="language-java">
    // 无回调
    @Async
    public CompletableFuture&lt;Void&gt; test() {
        return CompletableFuture.runAsync(() -&gt; {

            // 模拟第三方请求加载时间
            Thread.sleep(1000);
        
            // 异常错误模拟
            Integer test = 1/0;

            System.out.println("异步请求开始执行完成");
        });
    }</code></pre> 
<p> 结果就是完全不影响接口执行，且打印出报错信息，如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bc/00/ut52jJ8e_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ac4f71b7c00f7a3791b1613699bcbf3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">万元预算打造高质量13B私有模型，Colossal-AI LLaMA-2 开源方案再升级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e6c54f56865316e2c03c3c3a236ee5e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python安卓开发——kivy打包安卓APK逐步教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>