<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024蓝桥杯国赛C&#43;&#43;研究生组游记&#43;个人题解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/845ebef0f4f6efa844b009d17a573043/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="2024蓝桥杯国赛C&#43;&#43;研究生组游记&#43;个人题解">
  <meta property="og:description" content="Day0 开始复习，过了一遍大部分板子
本来打算再学一遍SAM，但是想到去年考了字符串大题今年应该不会再考了吧。。
过了一遍数据结构和图论，就1点了
两点的时候还没睡着，舍友打游戏好像打到2点过。。
Day1 相当困
第一题： 数田字有多少条直线可以只经过两个点，12条
第二题： 求长度42的置换中，周期恰好为2024的置换个数
首先2024=8*11*23，然后8&#43;11&#43;23=42，然后就是组合数C(42,8)*C(34,11)
结果赛后复盘的时候发现不对劲，想简单了，还有环内部的顺序需要计算，应该还要乘上每个环长度的欧拉函数值（？
第三题： 限流器，T条访问记录，每条访问记录有一个时间戳，每n个时间单位作为一个限流区间，每个区间最多能提供m次访问机会。求成功访问的次数。
由于时间给的很小（&lt;=1000），直接除一下n，放桶里，最后和m取min再求和。
第四题： 给一个数组a[i]，求把所有数加上x再mod k之后，小于等于t的数最多能有多少个
先对所有a[i] mod一下k，变成求一段长度为t&#43;1的区间最多能够覆盖多少值，由于这个问题是环形的，我们套路地把数组a[i]的每个值加上k的复制一段在后面，转化为区间问题。
贪心一下，我们选取的区间左端点一定是某个a[i]值，否则就可以让区间更靠后，以此获取更多覆盖的区域。
two-pointers扫一遍就可以知道结果了。注意边界条件判断。
当然，数据范围比较温和，二分查找logn也可以过。
此时9：34。
第五题： 小模拟，模拟vim指令编辑字符串，n^3
发现insert是中文引号，很诡异，但是不影响结果
这题写了我一个小时，厉害吧，我是真的唐啊
写完10：24了
第六题： 一个字符串，定义一个合法划分：划分中任意两个相邻的子串不能有公共字符。求该字符串中所有长度为1~5的本质不同的子串，这些子串在任意一个合法划分中都没有出现，请将他们按字典序输出。
首先，合法划分必然存在（怎么有点像绕口令），ababaabb可分为a|b|a|b|aa|bb
考虑一个串能在合法划分中出现，例如abcde，那么他的两端必然没有与a、b、c、d、e这五个字符相同的字符，否则这个子串就不能被划分出来。
于是我们枚举所有长度1~5的串，判断他是否能在合法划分中出现，能的话就给他的哈希值打上一个标记，因为字符串长度只有5，map&#43;long long就可以过。
然后我们第二次，扫描所有长度为1~5的子串，看哈希值是否被标记过，如果没有就加入答案的集合。
最后对答案集合进行排序、去重就结束了。
ps：为什么不直接求不合法的子串，因为一段字符串中，aabaccaba，例如aba实际上是可以在合法划分中出现的，划分为：aa|b|a|cc|aba，但是如果直接求的话，a|aba|cc|a|b|a就发现前面这里的aba实际上不合法。
写完调完直接11：00
第七题： 一个带权有向图n个点（n&lt;=50），给出邻接矩阵，m次查询（m&lt;=1000），查询u点到v点恰好经过c条边的最短路径，并且可以将路径上的一条边边权减半（但是多次经过的话只能减半一次）。
一眼就是倍增floyd，再加上一个求路径max，同样可以倍增做。
不过时间复杂度非常逆天O(m*n^3*logc)，考虑怎么优化
发现我不会，70分遗憾离场。
此时11：32，很急，后面还有三道大题没看。
第八题： 给一段序列，它来源于对一棵树的先序遍历的节点深度，已知该序列的一部分（未知的部分用-1
代替），求这个序列一共有多少种可能。
首先发现，先序遍历的深度序列任意一个值都满足a[i]&lt;=a[i-1]&#43;1（i&gt;1）
然后，对于每一段-1，我们都可以对其进行计数。
设f[i][j]为第i位的值为j时，序列1~i构成的方案数
f[i][j]=f[i-1][j-1]&#43;f[i-1][j]&#43;f[i-1][j&#43;1]&#43;……&#43;f[i-1][i-1]，即对前一个f[i-1]的一个后缀和，再向后平移一位
假设这一段-1（区间为[l,r]）的前一个数为x，后一个数为y，那么设f[l-1][x]=1
最终答案为f[r&#43;1][y]
最后把每段的答案乘起来就是最终答案。
考虑如何优化这个后缀和
发现我不会，30分遗憾离场。
做完之后12：15，顿时觉得可以开摆了。
赛后复盘其实觉得不应该放弃这一点的，毕竟初值只有一个1，后面也只查询一个点，应该是可以用数学公式推出来的。
第九题： n个点，每两个点i,j之间有一条边，若i*j为完全平方数则边权为1，否则为0。
特殊生成树定义为任意一个点都必定有一条边连接一个比自己权值小的点。
对每个k，求边权为k（k=0~n-1）的特殊生成树有多少个。
首先，这个特殊的性质规定了生成树的产生方式：顺序枚举1~n点，依次加入生成树，并且只能选择1~i-1的其中一个点进行连接。
于是乎，我们维护的n-1个点的答案数组f[i]，表示边权为i的生成树有多少个，
在加入点n之后f[i]=cnt*f[i-1]&#43;(n-1-cnt)*f[i]，cnt表示n与1~n-1中乘积为完全平方数的个数。
这样就可以n^2拿到60分
至于85分就是分治NTT，模数还正好是998244353，相当于求一下乘积Π(i-1-cnti&#43;cnti*x)的多项式系数。 最后的100分应该是NTT过程中其实可以优化，因为cnti可能为0，这样可以在常数上小一点，然后n(logn)^2过掉。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T22:30:45+08:00">
    <meta property="article:modified_time" content="2024-06-01T22:30:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024蓝桥杯国赛C&#43;&#43;研究生组游记&#43;个人题解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Day0</h2> 
<p>开始复习，过了一遍大部分板子</p> 
<p>本来打算再学一遍SAM，但是想到去年考了字符串大题今年应该不会再考了吧。。</p> 
<p>过了一遍数据结构和图论，就1点了</p> 
<p>两点的时候还没睡着，舍友打游戏好像打到2点过。。</p> 
<h2>Day1</h2> 
<p>相当困</p> 
<h4>第一题：</h4> 
<p>数田字有多少条直线可以只经过两个点，12条</p> 
<h4>第二题：</h4> 
<p>求长度42的置换中，周期恰好为2024的置换个数</p> 
<p>首先2024=8*11*23，然后8+11+23=42，然后就是组合数C(42,8)*C(34,11)</p> 
<p>结果赛后复盘的时候发现不对劲，想简单了，还有环内部的顺序需要计算，应该还要乘上每个环长度的欧拉函数值（？</p> 
<h4>第三题：</h4> 
<p>限流器，T条访问记录，每条访问记录有一个时间戳，每n个时间单位作为一个限流区间，每个区间最多能提供m次访问机会。求成功访问的次数。</p> 
<p>由于时间给的很小（&lt;=1000），直接除一下n，放桶里，最后和m取min再求和。</p> 
<h4>第四题：</h4> 
<p>给一个数组a[i]，求把所有数加上x再mod k之后，小于等于t的数最多能有多少个</p> 
<p>先对所有a[i] mod一下k，变成求一段长度为t+1的区间最多能够覆盖多少值，由于这个问题是环形的，我们套路地把数组a[i]的每个值加上k的复制一段在后面，转化为区间问题。</p> 
<p>贪心一下，我们选取的区间左端点一定是某个a[i]值，否则就可以让区间更靠后，以此获取更多覆盖的区域。</p> 
<p>two-pointers扫一遍就可以知道结果了。注意边界条件判断。</p> 
<p>当然，数据范围比较温和，二分查找logn也可以过。</p> 
<p>此时9：34。</p> 
<h4>第五题：</h4> 
<p>小模拟，模拟vim指令编辑字符串，n^3</p> 
<p>发现insert是中文引号，很诡异，但是不影响结果</p> 
<p>这题写了我一个小时，<s>厉害吧，我是真的唐啊</s></p> 
<p><s>写完10：24了</s></p> 
<h4>第六题：</h4> 
<p>一个字符串，定义一个合法划分：划分中任意两个相邻的子串不能有公共字符。求该字符串中所有长度为1~5的本质不同的子串，这些子串在任意一个合法划分中都没有出现，请将他们按字典序输出。</p> 
<p>首先，合法划分必然存在<s>（怎么有点像绕口令）</s>，ababaabb可分为a|b|a|b|aa|bb</p> 
<p>考虑一个串能在合法划分中出现，例如abcde，那么他的两端必然没有与a、b、c、d、e这五个字符相同的字符，否则这个子串就不能被划分出来。</p> 
<p>于是我们枚举所有长度1~5的串，判断他是否能在合法划分中出现，能的话就给他的哈希值打上一个标记，因为字符串长度只有5，map+long long就可以过。</p> 
<p>然后我们第二次，扫描所有长度为1~5的子串，看哈希值是否被标记过，如果没有就加入答案的集合。</p> 
<p>最后对答案集合进行排序、去重就结束了。</p> 
<p>ps：为什么不直接求不合法的子串，因为一段字符串中，aabaccaba，例如aba实际上是可以在合法划分中出现的，划分为：aa|b|a|cc|aba，但是如果直接求的话，a|aba|cc|a|b|a就发现前面这里的aba实际上不合法。</p> 
<p>写完调完直接11：00</p> 
<h4>第七题：</h4> 
<p>一个带权有向图n个点（n&lt;=50），给出邻接矩阵，m次查询（m&lt;=1000），查询u点到v点恰好经过c条边的最短路径，并且可以将路径上的一条边边权减半（但是多次经过的话只能减半一次）。</p> 
<p>一眼就是倍增floyd，再加上一个求路径max，同样可以倍增做。</p> 
<p>不过时间复杂度非常逆天O(m*n^3*logc)，考虑怎么优化</p> 
<p>发现我不会，70分遗憾离场。</p> 
<p>此时11：32，很急，后面还有三道大题没看。</p> 
<h4>第八题：</h4> 
<p>给一段序列，它来源于对一棵树的先序遍历的节点深度，已知该序列的一部分（未知的部分用-1</p> 
<p>代替），求这个序列一共有多少种可能。</p> 
<p>首先发现，先序遍历的深度序列任意一个值都满足a[i]&lt;=a[i-1]+1（i&gt;1）</p> 
<p>然后，对于每一段-1，我们都可以对其进行计数。</p> 
<p>设f[i][j]为第i位的值为j时，序列1~i构成的方案数</p> 
<p>f[i][j]=f[i-1][j-1]+f[i-1][j]+f[i-1][j+1]+……+f[i-1][i-1]，即对前一个f[i-1]的一个后缀和，再向后平移一位</p> 
<p>假设这一段-1（区间为[l,r]）的前一个数为x，后一个数为y，那么设f[l-1][x]=1</p> 
<p>最终答案为f[r+1][y]</p> 
<p>最后把每段的答案乘起来就是最终答案。</p> 
<p>考虑如何优化这个后缀和</p> 
<p>发现我不会，30分遗憾离场。</p> 
<p>做完之后12：15，顿时觉得可以开摆了。</p> 
<p>赛后复盘其实觉得不应该放弃这一点的，毕竟初值只有一个1，后面也只查询一个点，应该是可以用数学公式推出来的。</p> 
<h4>第九题：</h4> 
<p>n个点，每两个点i,j之间有一条边，若i*j为完全平方数则边权为1，否则为0。</p> 
<p>特殊生成树定义为任意一个点都必定有一条边连接一个比自己权值小的点。</p> 
<p>对每个k，求边权为k（k=0~n-1）的特殊生成树有多少个。</p> 
<p>首先，这个特殊的性质规定了生成树的产生方式：顺序枚举1~n点，依次加入生成树，并且只能选择1~i-1的其中一个点进行连接。</p> 
<p>于是乎，我们维护的n-1个点的答案数组f[i]，表示边权为i的生成树有多少个，</p> 
<p>在加入点n之后f[i]=cnt*f[i-1]+(n-1-cnt)*f[i]，cnt表示n与1~n-1中乘积为完全平方数的个数。</p> 
<p>这样就可以n^2拿到60分</p> 
<p>至于85分就是分治NTT，模数还正好是998244353，相当于求一下乘积Π(i-1-cnti+cnti*x)的多项式系数。 </p> 
<p>最后的100分应该是NTT过程中其实可以优化，因为cnti可能为0，这样可以在常数上小一点，然后n(logn)^2过掉。</p> 
<p>只可惜时间不够，但即便是时间够，我也不会写NTT了。。。。</p> 
<p>真的很菜欸。。60分遗憾离场了。</p> 
<p>至于cnt的求法，先把n分解质因数，对每个质因子次数ai，如果是偶数就凑(0、2、4、……、ai)</p> 
<p>如果是奇数就凑（1、3、5、……、ai），也就是(ai+1)/2种凑法。然后把每个质因子凑法乘起来再-1（减掉本身）就是cnt了。复杂度O(n*sqrt(n))</p> 
<p>如果不去掉本身的话，似乎还是个积性函数，应该可以线性筛筛出来？（这个纯口胡，有错的话还请大佬指正）</p> 
<h4>第十题：</h4> 
<p>真的不会一点啊</p> 
<p>一排格子1~T，每个格子上最多有一个小球，可以没有，每个小球有一个数值ai，每个时刻，每个小球都有1/2的概率向右走一步，若一个小球走到T处则记录它的数值，并且把它拿走。</p> 
<p>当有一个小球追上另一个小球时，两个小球会合并成一个新的小球，新的小球的数值为原来两个小球的乘积。</p> 
<p>求在T处所记录的小球数值的和的期望。</p> 
<p>T&lt;=100, ai&lt;=100</p> 
<p>没时间做，也不会做。（23333</p> 
<p>隐隐约约感觉是一个O(n^3)期望DP，不过我是真的不会。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba2500ce8cca7ca5273cc9de3e262dee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新版AndroidStudio使用switch-case语句时出现Constant expression required错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/01ed3872366b093bac96a1791e4bd81a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HR青睐的数据库热门考题——事务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>