<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>day23-测试自动化之Appium的滑动和拖拽事件、高级手势ActionChains、手机操作API - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4468df10678bf2e91738fd99dbcb667d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="day23-测试自动化之Appium的滑动和拖拽事件、高级手势ActionChains、手机操作API">
  <meta property="og:description" content="目录
一、滑动和拖拽事件
1.1.应用场景
1.2.swipe滑动事件
1.3.scroll滑动事件
1.4.drag_and_drop拖拽事件
1.5.滑动和拖拽事件的选择
二、高级手势ActionChains
2.1.应用场景
2.2.使用步骤
2.3.注意点
2.4.方法
1).手指轻敲操作 (掌握)
2).手势按下和抬起操作(掌握）
3).等待操作 (掌握)
4).长按操作 (掌握)
5).手指移动操作（掌握）
三、手机操作API
3.1.获取手机分辨率 (掌握)
3.2.手机截图 (掌握)
3.3.获取和设置手机网络 (掌握)
3.4.发送键到设备 (掌握)
3.5.操作手机通知栏 (掌握)
四、今日学习思维导图
一、滑动和拖拽事件 1.1.应用场景 我们在做自动化测试的时候，有些按钮是需要滑动几次屏幕后才会出现，此时，我们需要使用代码来模拟手指的滑动，也就是我们将要学习的滑动和拖拽事件
1.2.swipe滑动事件 1).概念
从一个坐标位置滑动到另一个坐标位置，只能是两个点之间的滑动。
2).方法
2.1).start_x:起点x轴坐标
2.2).start_y：起点Y轴坐标
2.3).end_x:终点x轴坐标
2.4).end_y:终点Y轴坐标
2.5).duration：清动这个操作一共持续的时间长度，单位：mS
2.6).driver.swipe(start_x,start_y,end_x, end_y.,duration=None)
3).核心代码
driver.swipe(100,2000,100,1000)
4).特点
4.1).参数是坐标点
4.2).持续时间短，惯性大
4.3).持续时间长，惯性小
5).代码
import unittest from time import sleep from appium import webdriver from selenium.webdriver.common.by import By # 打开相册 capabilities = {} capabilities[&#39;platformName&#39;] = &#39;Android&#39; capabilities[&#39;automationName&#39;] = &#39;uiautomator2&#39; capabilities[&#39;deviceName&#39;] = &#39;Android&#39; capabilities[&#39;appPackage&#39;] = &#39;com.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-17T10:53:30+08:00">
    <meta property="article:modified_time" content="2024-08-17T10:53:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">day23-测试自动化之Appium的滑动和拖拽事件、高级手势ActionChains、手机操作API</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E6%BB%91%E5%8A%A8%E5%92%8C%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%BB%91%E5%8A%A8%E5%92%8C%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6" rel="nofollow">一、滑动和拖拽事件</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        1.1.应用场景</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2.swipe%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2.swipe%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6" rel="nofollow">        1.2.swipe滑动事件</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.3.scroll%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.3.scroll%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6" rel="nofollow">        1.3.scroll滑动事件</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.4.drag_and_drop%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.4.drag_and_drop%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6" rel="nofollow">        1.4.drag_and_drop拖拽事件</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.5.%E6%BB%91%E5%8A%A8%E5%92%8C%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.5.%E6%BB%91%E5%8A%A8%E5%92%8C%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9" rel="nofollow">        1.5.滑动和拖拽事件的选择</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%AB%98%E7%BA%A7%E6%89%8B%E5%8A%BFActionChains-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%AB%98%E7%BA%A7%E6%89%8B%E5%8A%BFActionChains" rel="nofollow">二、高级手势ActionChains</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        2.1.应用场景</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4" rel="nofollow">        2.2.使用步骤</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3.%E6%B3%A8%E6%84%8F%E7%82%B9-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3.%E6%B3%A8%E6%84%8F%E7%82%B9" rel="nofollow">        2.3.注意点</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4.%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4.%E6%96%B9%E6%B3%95" rel="nofollow">        2.4.方法</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201).%E6%89%8B%E6%8C%87%E8%BD%BB%E6%95%B2%E6%93%8D%E4%BD%9C%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201%29.%E6%89%8B%E6%8C%87%E8%BD%BB%E6%95%B2%E6%93%8D%E4%BD%9C%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">                1).手指轻敲操作 (掌握)</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202).%E6%89%8B%E5%8A%BF%E6%8C%89%E4%B8%8B%E5%92%8C%E6%8A%AC%E8%B5%B7%E6%93%8D%E4%BD%9C(%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202%29.%E6%89%8B%E5%8A%BF%E6%8C%89%E4%B8%8B%E5%92%8C%E6%8A%AC%E8%B5%B7%E6%93%8D%E4%BD%9C%28%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">                2).手势按下和抬起操作(掌握）</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203).%E7%AD%89%E5%BE%85%E6%93%8D%E4%BD%9C%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203%29.%E7%AD%89%E5%BE%85%E6%93%8D%E4%BD%9C%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">                3).等待操作 (掌握)</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204).%E9%95%BF%E6%8C%89%E6%93%8D%E4%BD%9C%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204%29.%E9%95%BF%E6%8C%89%E6%93%8D%E4%BD%9C%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">                4).长按操作 (掌握)</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205).%E6%89%8B%E6%8C%87%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205%29.%E6%89%8B%E6%8C%87%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89" rel="nofollow">                5).手指移动操作（掌握）</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%89%8B%E6%9C%BA%E6%93%8D%E4%BD%9CAPI-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%89%8B%E6%9C%BA%E6%93%8D%E4%BD%9CAPI" rel="nofollow">三、手机操作API</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">        3.1.获取手机分辨率 (掌握)</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2.%E6%89%8B%E6%9C%BA%E6%88%AA%E5%9B%BE%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2.%E6%89%8B%E6%9C%BA%E6%88%AA%E5%9B%BE%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">        3.2.手机截图 (掌握)</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3.%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%89%8B%E6%9C%BA%E7%BD%91%E7%BB%9C%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3.%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%89%8B%E6%9C%BA%E7%BD%91%E7%BB%9C%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">        3.3.获取和设置手机网络 (掌握)</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.4.%E5%8F%91%E9%80%81%E9%94%AE%E5%88%B0%E8%AE%BE%E5%A4%87%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.4.%E5%8F%91%E9%80%81%E9%94%AE%E5%88%B0%E8%AE%BE%E5%A4%87%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">        3.4.发送键到设备 (掌握)</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5.%E6%93%8D%E4%BD%9C%E6%89%8B%E6%9C%BA%E9%80%9A%E7%9F%A5%E6%A0%8F%20(%E6%8E%8C%E6%8F%A1)-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5.%E6%93%8D%E4%BD%9C%E6%89%8B%E6%9C%BA%E9%80%9A%E7%9F%A5%E6%A0%8F%20%28%E6%8E%8C%E6%8F%A1%29" rel="nofollow">        3.5.操作手机通知栏 (掌握)</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BB%8A%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%BB%8A%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE" rel="nofollow">四、今日学习思维导图</a></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%BB%91%E5%8A%A8%E5%92%8C%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6">一、滑动和拖拽事件</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">        1.1.应用场景</h3> 
<p>                我们在做自动化测试的时候，有些按钮是需要滑动几次屏幕后才会出现，此时，我们需要使用代码来模拟手指的滑动，也就是我们将要学习的滑动和拖拽事件</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.2.swipe%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6">        1.2.swipe滑动事件</h3> 
<p>                1).概念</p> 
<p>                        从一个坐标位置滑动到另一个坐标位置，只能是两个点之间的滑动。</p> 
<p>                2).方法</p> 
<p>                        2.1).start_x:起点x轴坐标</p> 
<p>                        2.2).start_y：起点Y轴坐标</p> 
<p>                        2.3).end_x:终点x轴坐标</p> 
<p>                        2.4).end_y:终点Y轴坐标</p> 
<p>                        2.5).duration：清动这个操作一共持续的时间长度，单位：mS</p> 
<p>                        2.6).driver.swipe(start_x,start_y,end_x, end_y.,duration=None)</p> 
<p>                3).核心代码</p> 
<p>                        driver.swipe(100,2000,100,1000)</p> 
<p>                4).特点</p> 
<p>                        4.1).参数是坐标点</p> 
<p>                        4.2).持续时间短，惯性大</p> 
<p>                        4.3).持续时间长，惯性小</p> 
<p>                5).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep

from appium import webdriver
from selenium.webdriver.common.by import By

# 打开相册
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url,capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 向下滑动一段距离
        # 获取窗口的宽和高
        height = self.driver.get_window_size().get('height')
        weight = self.driver.get_window_size().get('width')
        # 执行滑动操作
        self.driver.swipe(start_x=weight * 0.5,
                          start_y=height * 0.8,
                          end_x=weight * 0.5,
                          end_y=height * 0.2, duration=2000)


if __name__ == '__main__':
    unittest.main()
</code></pre> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.3.scroll%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6">        1.3.scroll滑动事件</h3> 
<p>                1).概念</p> 
<p>                        从一个元素滑动到另一个元素，直到页面自动停止。</p> 
<p>                2).方法</p> 
<p>                        2.1).origin_el:滑动开始的元素</p> 
<p>                        2.2).destination_el：滑动结束的元素</p> 
<p>                        2.3).driver.scroll(origin_el, destination_el)</p> 
<p>                3).核心代码</p> 
<p>                        save_button=driver.find_element_by_xpath(//°[@text='存f者']")more_button =driver.find_element_by_xpath("//*[@text='更多']")driver.scro11(save_button,more_button)</p> 
<p>                4).小结</p> 
<p>                        4.1).参数是元素</p> 
<p>                        4.2).不能设置持续时间，惯性很大</p> 
<p>                5).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep

from appium import webdriver
from selenium.webdriver.common.by import By

# 打开相册
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url,capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(2)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 向下滑动一段距离
        # 获取battery
        Battery = self.driver.find_element(By.XPATH, '//*[@text="Battery"]')
        Storage = self.driver.find_element(By.XPATH, '//*[@text="Storage"]')
        self.driver.scroll(Storage,Battery)


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.4.drag_and_drop%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6">        1.4.drag_and_drop拖拽事件</h3> 
<p>                1).概念</p> 
<p>                        从一个元素滑动到另一个元素，第二个元素替代第一个元素原本屏幕上的位置。</p> 
<p>                2).方法</p> 
<p>                        2.1).origin_el:滑动开始的元素</p> 
<p>                        2.2).destination_el：滑动结束的元素</p> 
<p>                        2.3).driver.drag_and_drop(origin_el,destination_el)</p> 
<p>                3).核心代码</p> 
<p>                        save_button = driver.find_element_by_xpath(//[@text='存f’]")more_button =driver.find_element_by_xpath("//*[@text='更多’]")driver.drag_and_drop(save_button,more_button)</p> 
<p>                4).小结</p> 
<p>                        4.1).参数是元素</p> 
<p>                        4.2).不能设置持续时间，没有惯性</p> 
<p>                5).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep

from appium import webdriver
from selenium.webdriver.common.by import By

# 打开相册
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url,capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(2)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 向下滑动一段距离
        # 获取battery
        Battery = self.driver.find_element(By.XPATH, '//*[@text="Battery"]')
        Storage = self.driver.find_element(By.XPATH, '//*[@text="Storage"]')
        self.driver.drag_and_drop(Storage,Battery)


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.5.%E6%BB%91%E5%8A%A8%E5%92%8C%E6%8B%96%E6%8B%BD%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9">        1.5.滑动和拖拽事件的选择</h3> 
<p>                1).滑动和拖拽无非就是考虑是否有“惯性”，以及传递的参数是“元素”还是“坐标”。</p> 
<p>                2).可以分成以下四种情况</p> 
<p>                        2.1).有“惯性”，传入“元素”---&gt;scroll</p> 
<p>                        2.2).无“惯性”，传入“元素”"----&gt; drag_and_drop</p> 
<p>                        2.3).有“惯性”，传入“坐标”-”----&gt;Swipe，并且设置较短的duration时间</p> 
<p>                        2.4).无“惯性”，传入“坐标”----&gt;swipe，并且设置较长的duration时间</p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%AB%98%E7%BA%A7%E6%89%8B%E5%8A%BFActionChains">二、高级手势ActionChains</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">        2.1.应用场景</h3> 
<p>                ActionChains可以实现一些针对手势的操作，比如滑动、长按、拖动等。我们可以将这些基本手势组合成一个相对复杂的手势。比如，我们解锁手机或者一些应用软件都有手势解锁的这种方式。</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2.%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">        2.2.使用步骤</h3> 
<p>                1).创建ActionChains对象</p> 
<p>                2).通过对象调用想执行的手势</p> 
<p>                3).通过perform()执行动作</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3.%E6%B3%A8%E6%84%8F%E7%82%B9">        2.3.注意点</h3> 
<p>                所有手势都要通过执行perform（）函数才会运行。</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4.%E6%96%B9%E6%B3%95">        2.4.方法</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201).%E6%89%8B%E6%8C%87%E8%BD%BB%E6%95%B2%E6%93%8D%E4%BD%9C%20(%E6%8E%8C%E6%8F%A1)">                1).手指轻敲操作 (掌握)</h4> 
<p>                        1.1).应用场景</p> 
<p>                                模拟手指对某个元素或坐标按下并快速抬起。比如，固定点击（100，100）的位置。</p> 
<p>                        1.2).方法</p> 
<p>                                1.element:元素</p> 
<p>                                2.X：X坐标</p> 
<p>                                3.y:y坐标</p> 
<p>                                4.ActionChains(driver).click(element=None,x=None,y=None).perform()</p> 
<p>                        1.3).核心代码</p> 
<p>                                1.e1 = driver.find_element_by_xpath("//*[contains(@text, *wLAn')]")</p> 
<p>                                2.ActionChains(driver).click(e1).perform()</p> 
<p>                        1.4).代码 </p> 
<pre><code class="language-python">import unittest
from appium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        capabilities = {
            'platformName': 'Android',
            'automationName': 'uiautomator2',
            'deviceName': 'Android',
            'appPackage': 'com.android.settings',
            'appActivity': '.Settings',
            'language': 'en',
            'locale': 'US',
            'browserName': '',  # 添加这一行
        }
        appium_server_url = 'http://localhost:4723'
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    # 其他代码保持不变

    def test_find_battery(self) -&gt; None:
        # 创建touchaction对象
        el = self.driver.find_element(By.XPATH, '//*[@text="Battery"]')
        actions = ActionChains(self.driver)  # 使用ActionChains替换TouchAction
        actions.click(el).perform()  # 使用actions.tap()替换TouchAction().tap()</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202).%E6%89%8B%E5%8A%BF%E6%8C%89%E4%B8%8B%E5%92%8C%E6%8A%AC%E8%B5%B7%E6%93%8D%E4%BD%9C(%E6%8E%8C%E6%8F%A1%EF%BC%89">                2).手势按下和抬起操作(掌握）</h4> 
<p>                        2.1).应用场景</p> 
<p>                                模拟手指一直按下，模拟指抬起。可以用来组合成轻敲或长按的操作</p> 
<p>                        2.2).方法</p> 
<p>                                1.按下操作----&gt;ActionChains(driver).click_and_hold(el=None,x=None,y=None).perform()</p> 
<p>                                2.抬起操作----&gt;ActionChains(driver).release().perform()</p> 
<p>                        2.3).核心代码</p> 
<p>                                1.ActionChains(driver).click_and_hold(x=650,y=650).perform()</p> 
<p>                                2.time.sleep(2)</p> 
<p>                                3.ActionChains(driver) .press(x=650, y=650).perform()</p> 
<p>                        2.4).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(2)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 创建touchaction对象
        el = self.driver.find_element(By.XPATH, '//*[@text="Battery"]')
        tc = ActionChains(self.driver)
        # 使用click_and_hold方法按住元素并保持
        tc.click_and_hold(el)
        # 使用pause方法指定按住的停顿时间2s
        tc.pause(2)
        # 使用release方法松开
        tc.release()
        # 最后使用perform方法执行以上操作。
        tc.perform()


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203).%E7%AD%89%E5%BE%85%E6%93%8D%E4%BD%9C%20(%E6%8E%8C%E6%8F%A1)">                3).等待操作 (掌握)</h4> 
<p>                        3.1).应用场景</p> 
<p>                                模拟手指等待</p> 
<p>                        3.2).方法</p> 
<p>                                ActionChains(driver).pause(time)---&gt;time:秒</p> 
<p>                        3.3).核心代码</p> 
<p>                                ActionChains(driver).pause(2)</p> 
<p>                        3.4).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(2)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 创建touchaction对象
        el = self.driver.find_element(By.XPATH, '//*[@text="Battery"]')
        tc = ActionChains(self.driver)
        # 使用click_and_hold方法按住元素并保持
        tc.click_and_hold(el)
        # 使用pause方法指定按住的停顿时间2s
        tc.pause(2)
        # 使用release方法松开
        tc.release()
        # 最后使用perform方法执行以上操作。
        tc.perform()


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204).%E9%95%BF%E6%8C%89%E6%93%8D%E4%BD%9C%20(%E6%8E%8C%E6%8F%A1)">                4).长按操作 (掌握)</h4> 
<p>                        4.1).应用场景</p> 
<p>                                模拟手指对元素或坐标的长按操作。比如，长按某个按钮弹出菜单。</p> 
<p>                        4.2).方法</p> 
<p>                                ActionChains(driver).click_and_hold(e1=None, x=None, y=None, duration=1000) .perform()</p> 
<p>                        4.3).核心代码</p> 
<p>                                1.ActionChains(driver).click_and_hold(el=None,x=None,y=None).perform()</p> 
<p>                                2.time.sleep(2)</p> 
<p>                                3.AtionChains(driver).click_and_hold(el=None,x=None,y=None).release.perform()</p> 
<p>                        4.4).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(2)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 创建touchaction对象
        el = self.driver.find_element(By.XPATH, '//*[@text="Battery"]')
        tc = ActionChains(self.driver)
        # 使用click_and_hold方法按住元素并保持
        tc.click_and_hold(el)
        tc.perform()


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205).%E6%89%8B%E6%8C%87%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8E%8C%E6%8F%A1%EF%BC%89">                5).手指移动操作（掌握）</h4> 
<p>                        5.1).应用场景</p> 
<p>                                模拟手指移动操作，比如，手势解锁需要先按下，再移动</p> 
<p>                        5.2).方法</p> 
<p>                                ActionChains(driver).move_to_element_with_offset (x=None,y=None)</p> 
<p>                        5.3).核心代码</p> 
<p>                                AtionChains(driver).move_to_element_with_offset (x=None,y=None)</p> 
<h2 id="%E4%B8%89%E3%80%81%E6%89%8B%E6%9C%BA%E6%93%8D%E4%BD%9CAPI">三、手机操作API</h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87%20(%E6%8E%8C%E6%8F%A1)">        3.1.获取手机分辨率 (掌握)</h3> 
<p>                1).应用场景</p> 
<p>                        自动化测试可能会需要根据当前设置的屏幕分辨率来计算一些点击或者滑动的坐标</p> 
<p>                2).方法</p> 
<p>                        driver.get_window_size()</p> 
<p>                3).核心代码</p> 
<p>                        print(self.driver.get_window_size())</p> 
<p>                4).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(2)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 获取手机分辨率
        print(self.driver.get_window_size())


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2.%E6%89%8B%E6%9C%BA%E6%88%AA%E5%9B%BE%20(%E6%8E%8C%E6%8F%A1)">        3.2.手机截图 (掌握)</h3> 
<p>                1).应用场景</p> 
<p>                        有些自动化的操作可能没有反应，但并不报错，此时我们就可以将操作过后的关键情况，截图留存，后期也可以根据图片发现问题</p> 
<p>                2).方法</p> 
<p>                        driver.get_screenshot_as_file(filename)---&gt;filename 指定路径下，指定格式的图片</p> 
<p>                3).核心代码</p> 
<p>                        driver.get_screenshot_as_file(./phone.png")</p> 
<p>                4).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(2)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 等待两秒钟
        sleep(2)
        # 截图
        self.driver.get_screenshot_as_file('./phone.png')


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3.%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%89%8B%E6%9C%BA%E7%BD%91%E7%BB%9C%20(%E6%8E%8C%E6%8F%A1)">        3.3.获取和设置手机网络 (掌握)</h3> 
<p>                1).应用场景</p> 
<p>                        视频应用在使用流量看视频的时候，大部分都会提示用户正在是否继续播放。作为测试人员，我们可能需要用自动化的形式来判断是否有对应的提示。即，用流量的时候应该有提示，不用流量的时候应该没有提示。</p> 
<p>                2).获取手机网络</p> 
<p>                        2.1).方法</p> 
<p>                                driver.network_connection</p> 
<p>                        2.2).核心代码</p> 
<p>                                print(driver.network_connection)</p> 
<p>                        2.3).底层数字表示</p> 
<p></p> 
<p class="img-center"><img alt="" height="400" id="uc9467975" src="https://images2.imgbox.com/78/e8/qxXoRPsB_o.png" width="772"></p> 
<p>                3).设置手机网络</p> 
<p>                        3.1).方法</p> 
<p>                                driver.set_network_connection(connection)</p> 
<p>                        3.2).核心代码</p> 
<p>                                driver.set_network_connection(2)</p> 
<p>                4).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 获取手机网络
        print(self.driver.network_connection)
        # 设置手机网络
        self.driver.set_network_connection(2)
        print(self.driver.network_connection)


if __name__ == '__main__':
    unittest.main()</code></pre> 
<p>               5).注意</p> 
<p>                        5.1).网络的类型，建议使用系统提供的类型</p> 
<p>                        5.2).fromappium.webdriver.connectiontype import ConnectionType</p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.4.%E5%8F%91%E9%80%81%E9%94%AE%E5%88%B0%E8%AE%BE%E5%A4%87%20(%E6%8E%8C%E6%8F%A1)">        3.4.发送键到设备 (掌握)</h3> 
<p>                1).应用场景</p> 
<p>                        模拟按“返回键”“home键”等等操作，比如，很多应用有按两次返回键退出应用的功能，如果这个功能需要我们做自动化，那么一定会用到这个方法</p> 
<p>                2).方法</p> 
<p>                        2.1).driver.press_keycode(keycode,metastate=None)</p> 
<p>                        2.2).keycode:发送给设备的关键代码</p> 
<p>                        2.3).metastate：关于被发送的关键代码的元信息，一般为默认值</p> 
<p>                3).注意</p> 
<p>                        按键对应的编码可以搜索androidkeycode</p> 
<p>                4).核心代码</p> 
<p>                        4.1).driver.press_keycode(24)</p> 
<p>                        4.2).driver.press_keycode(24)</p> 
<p>                        4.3).driver.press_keycode(24)</p> 
<p>                        4.4).driver.press_keycode(4)</p> 
<p>                        4.5).driver.press_keycode(25)</p> 
<p>                        4.6).driver.press_keycode(25)</p> 
<p>                5).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(5)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 点击三次音量加，再点击返回，再点击两次音量减
        self.driver.press_keycode(24)
        self.driver.press_keycode(24)
        self.driver.press_keycode(24)
        sleep(2)
        self.driver.press_keycode(4)
        sleep(2)
        self.driver.press_keycode(25)
        self.driver.press_keycode(25)


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5.%E6%93%8D%E4%BD%9C%E6%89%8B%E6%9C%BA%E9%80%9A%E7%9F%A5%E6%A0%8F%20(%E6%8E%8C%E6%8F%A1)">        3.5.操作手机通知栏 (掌握)</h3> 
<p>                1).应用场景</p> 
<p>                        测试即时通信类软件的时候，如果A给B发送一条消息，B的通知栏肯定会显示对应的消息。我们想通过通知栏来判断B是否收到消息，一定要先操作手机的通知栏</p> 
<p>                2).方法</p> 
<p>                        driver.open_notifications()</p> 
<p>                3).注意点</p> 
<p>                        appium官方并没有为我们提供关闭通知的api，那么现实生活中怎么关闭，就怎样操作就行，比如，手指从下往上滑动，或者，按返回键</p> 
<p>                4).核心代码</p> 
<p>                        4.1).driver.open_notifications()---&gt;打开通知栏</p> 
<p>                        4.2).driver.press_keycode(4)----&gt;关闭通知栏</p> 
<p>                5).代码</p> 
<pre><code class="language-python">import unittest
from time import sleep
from appium import webdriver
from appium.webdriver.common.touch_action import TouchAction
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 打开设置
capabilities = {}
capabilities['platformName'] = 'Android'
capabilities['automationName'] = 'uiautomator2'
capabilities['deviceName'] = 'Android'
capabilities['appPackage'] = 'com.android.settings'
capabilities['appActivity'] = '.Settings'
capabilities['language'] = 'en'
capabilities['locale'] = 'US'
capabilities['browserName'] = ''

appium_server_url = 'http://localhost:4723'


class TestAppium(unittest.TestCase):

    def setUp(self) -&gt; None:
        # 获取driver
        self.driver = webdriver.Remote(appium_server_url, capabilities)
        self.driver.implicitly_wait(30)

    def tearDown(self) -&gt; None:
        if self.driver:
            # 退出程序
            sleep(5)
            self.driver.quit()

    def test_find_battery(self) -&gt; None:
        # 打开通知栏
        self.driver.open_notifications()
        # 等待两秒钟
        sleep(2)
        # 关闭通知栏
        self.driver.press_keycode(4)


if __name__ == '__main__':
    unittest.main()</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E4%BB%8A%E6%97%A5%E5%AD%A6%E4%B9%A0%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE">四、今日学习思维导图</h2> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a9/6b/y4WcurnD_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3e/d6/v9mkOBdl_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/b3/zARTMwuU_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7849e938c6f46dde3128c25a39e3dc95/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python实现水果忍者（开源）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2770463825b1ec7b49f6269f3a3c1d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在 Vue 2.0 中集成 Markdown 编辑器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>