<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划-----背包类问题（0-1背包与完全背包）详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d929c02622383de1153500cd593d121c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="动态规划-----背包类问题（0-1背包与完全背包）详解">
  <meta property="og:description" content="目录
什么是背包问题？
动态规划问题的一般解决办法：
0-1背包问题：
0 - 1背包类问题 分割等和子集： 完全背包问题： 完全背包类问题 零钱兑换II:
什么是背包问题？ 背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkle和Hellman提出的。
动态规划问题的一般解决办法： 动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤:
🧐 步骤一:定义dp数组元素的含义🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程)🧐第三步骤：找出初始值（base case） 接下来的题目我们会按照这三个步骤来解释说明
前言：本文包含动态规划中的经典背包问题，有关背包问题的描述如下：
在动态规划中，背包问题是一个经典的优化问题，它可以分为0-1背包问题和完全背包问题两种类型。下面我们就来看看这两个问题：
0-1背包问题： 问题描述：
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]。现在让你用这个背包装物品，每个物品只能用一次，在不超过被包容量的前提下，最多能装的价值是多少？
🧐 步骤一:定义dp数组元素的含义： 由于状态有两个，就是「背包的容量」和「可选择的物品」，这里我们就需要用到一个二维的dp
数组，如下为dp数组的定义：
🦉🦉🦉dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]
🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程) 1.如果你没有把这第 i 个物品装入背包，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果(翻译一下就是不装入第i个物品，相当于对前 i - 1 个物品进行选择，对应此时的背包容量w)。即此时的状态转移方程是：dp[ i ][ w ] = dp[ i - 1 ][ w ]
2.如果你把这第 i 个物品装入了背包,此时背包剩余容量为 w - wt[ i - 1 ](wt数组下标是从0开始的, wt[ i - 1 ] 相当于第 i 个物品的重量，val 也一样)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-31T20:15:17+08:00">
    <meta property="article:modified_time" content="2024-03-31T20:15:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划-----背包类问题（0-1背包与完全背包）详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F" rel="nofollow">什么是背包问题？</a></p> 
<p id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A" rel="nofollow">动态规划问题的一般解决办法：</a></p> 
<p id="0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A-toc" style="margin-left:0px;"><a href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A" rel="nofollow">0-1背包问题：</a></p> 
<p id="0%20-%201%E8%83%8C%E5%8C%85%E7%B1%BB%E9%97%AE%E9%A2%98%C2%A0%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#0%20-%201%E8%83%8C%E5%8C%85%E7%B1%BB%E9%97%AE%E9%A2%98%C2%A0%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%EF%BC%9A%C2%A0" rel="nofollow">0 - 1背包类问题  分割等和子集： </a></p> 
<p id="%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%C2%A0" rel="nofollow">完全背包问题： </a></p> 
<p id="%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%B1%BB%E9%97%AE%E9%A2%98%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II%3A-toc" style="margin-left:40px;"><a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%B1%BB%E9%97%AE%E9%A2%98%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II%3A" rel="nofollow">完全背包类问题 零钱兑换II:</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F">什么是背包问题？</h2> 
<p><strong>背包问题(Knapsack problem)是一种组合优化的NP完全问题。</strong>问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkle和Hellman提出的。</p> 
<h3 id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A">动态规划问题的一般解决办法：</h3> 
<p>动态规划，无非就是利用<strong>历史记录</strong>，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是<strong>用一维数组或者二维数组来保存</strong>。下面我们先来讲下做动态规划题很重要的三个步骤:</p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐 步骤一:定义dp数组元素的含义</span></strong></li><li><strong><span style="background-color:#ffd900;">🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程)</span></strong></li><li>🧐<strong><span style="background-color:#ffd900;">第三步骤：找出初始值（base case）</span></strong></li></ul> 
<p>接下来的题目我们会按照这三个步骤来解释说明</p> 
<p><strong>前言：本文包含动态规划中的经典背包问题，有关背包问题的描述如下：</strong></p> 
<p>在动态规划中，背包问题是一个经典的优化问题，它可以分为0-1背包问题和完全背包问题两种类型。下面我们就来看看这两个问题：</p> 
<h2 id="0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A" style="background-color:transparent;">0-1背包问题：</h2> 
<p>问题描述：</p> 
<p>给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>。现在让你用这个背包装物品，每个物品只能用一次，在不超过被包容量的前提下，最多能装的价值是多少？</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/04/99/0xBYaCMK_o.png" width="363"></p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐 步骤一:定义dp数组元素的含义：</span></strong></li></ul> 
<p><strong>由于状态有两个，就是「背包的容量」和「可选择的物品」，这里我们就需要用到一个二维的dp</strong></p> 
<p><strong>数组，如下为dp数组的定义：</strong></p> 
<p><strong><code><span style="background-color:#ffd900;">🦉🦉🦉dp[i][w]</span></code><span style="background-color:#ffd900;"> 的定义如下：对于前 </span><code><span style="background-color:#ffd900;">i</span></code><span style="background-color:#ffd900;"> 个物品，当前背包的容量为 </span><code><span style="background-color:#ffd900;">w</span></code><span style="background-color:#ffd900;">，这种情况下可以装的最大价值是 </span><code><span style="background-color:#ffd900;">dp[i][w]</span></code></strong></p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程)</span></strong></li></ul> 
<p>1.<strong>如果你没有把这第 <code>i</code> 个物品装入背包</strong>，那么很显然，最大价值 <code>dp[i][w]</code> 应该等于 <code>dp[i-1][w]</code>，继承之前的结果(翻译一下就是不装入第i个物品，相当于对前 i - 1 个物品进行选择，对应此时的背包容量w)。即此时的<strong><span style="background-color:#38d8f0;">状态转移方程是：dp[ i ][ w ] = dp[ i - 1 ][ w ]</span></strong></p> 
<p>2.<strong>如果你把这第 <code>i</code> 个物品装入了背包,此时背包剩余容量为 w - wt[ i - 1 ](wt数组下标是从0开始的, wt[ i - 1 ] 相当于第 i 个物品的重量，val 也一样)</strong></p> 
<p><strong><span style="background-color:#38d8f0;">则此时的状态转移方程是：</span></strong><strong><span style="background-color:#38d8f0;">dp[ i ][ w ] = dp[ i - 1 ][ w - wt[ i - 1] ] + val[ i - 1 ]</span></strong></p> 
<ul><li>🧐<strong><span style="background-color:#ffd900;">第三步骤：找出初始值（base case）：</span></strong></li></ul> 
<p>这题的base case 相对简单，当物品个数为0或则背包当前容量为0时，dp[ i ][ w ] 都等于0</p> 
<p>按照上述的状态转移方程，我们可以填出对应dp表格（以图中的例子为例）：</p> 
<p><img alt="" height="1049" src="https://images2.imgbox.com/02/6c/0YWsTrWq_o.png" width="1200"></p> 
<p>有了上述铺垫后，动态规划的代码就很好实现了，具体代码如下：</p> 
<pre><code class="language-java">int knapsack(int W, int N, int[] wt, int[] val) {
    assert N == wt.length;
    // base case 已初始化，数组自动全部初始化为0
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i &lt;= N; i++) {
        for (int w = 1; w &lt;= W; w++) {
            if (w - wt[i - 1] &lt; 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = Math.max(
                    dp[i - 1][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                );
            }
        }
    }
    
    return dp[N][W];
}
</code></pre> 
<p>有了上面的一定了解后，我们来看看0 - 1背包的类似题：</p> 
<h3 id="0%20-%201%E8%83%8C%E5%8C%85%E7%B1%BB%E9%97%AE%E9%A2%98%C2%A0%20%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%EF%BC%9A%C2%A0" style="background-color:transparent;">0 - 1背包类问题  分割等和子集： </h3> 
<p>看一下力扣第 416 题「<a href="https://leetcode.cn/problems/partition-equal-subset-sum/" rel="nofollow" title="分割等和子集open in new window">分割等和子集open in new window</a>」：</p> 
<p>题目描述：输入一个只包含正整数的非空数组 <code>nums</code>，请你写一个算法，判断这个数组是否可以被分割成两个子集，使得两个子集的元素和相等。对应函数签名如下：</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/1c/a1/a5ZN95PT_o.png" width="657"></p> 
<p>我们可以将这个问题转化为0 - 1背包问题，具体做法：</p> 
<p><strong>这个问题相当于给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为 <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？按照上述解题思路就是：</p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐 步骤一:定义dp数组元素的含义：</span></strong></li></ul> 
<p><strong><code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品（<code>i</code> 从 1 开始计数），当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满，若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满</strong>。</p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程)</span></strong></li></ul> 
<p>与上面类似，这里就直接给出来了：</p> 
<p>1.<strong>不把这第 <code>i</code> 个物品装入背包：dp[ i ][ j ] = dp[ i - 1 ][ j ]</strong></p> 
<p><strong>2.把这第i个物品装入背包：dp[ i ][ j ] = dp[ i - 1][ j - nums[ i - 1 ] ]</strong></p> 
<ul><li>🧐<strong><span style="background-color:#ffd900;">第三步骤：找出初始值（base case）：</span></strong></li></ul> 
<p>当背包容量为0时（sum / 2= 0）这时无论物体有多少个都可以满足条件，就是什么都不装嘛</p> 
<p>ok，接下来看完整代码：</p> 
<pre><code class="language-java">boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合
    if (sum % 2 != 0) return false;
    int n = nums.length;
    sum = sum / 2;
    boolean[][] dp = new boolean[n + 1][sum + 1];
    // base case
    for (int i = 0; i &lt;= n; i++)
        dp[i][0] = true;

    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= sum; j++) {
            if (j - nums[i - 1] &lt; 0) {
                // 背包容量不足，不能装入第 i 个物品
                dp[i][j] = dp[i - 1][j];
            } else {
                // 装入或不装入背包
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[n][sum];
}
</code></pre> 
<h2 id="%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%C2%A0">完全背包问题： </h2> 
<p>完全背包问题与0-1背包问题类似，但不同之处在于每个物品可以选择放入背包多次（数量无限），即每个物品的选择是一个无限的选择。我们给出对应的解题方法：</p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐 步骤一:定义dp数组元素的含义：</span></strong></li></ul> 
<p>若只使用前 <code>i</code> 个物品（可以重复使用），当背包容量为 <code>j</code> 时，能装入背包的最大价值为<code>dp[i][w]</code> </p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程)</span></strong></li></ul> 
<p>1.不将第i个物品装入背包，此时：dp[ i ][ w ] = dp[ i - 1 ][ w ]</p> 
<p>2.将第i个物品装入背包，此时:dp[ i ][ w ] = dp[ i ][ w -wt[ i - 1] ] + val[ i - 1 ] </p> 
<ul><li>🧐<strong><span style="background-color:#ffd900;">第三步骤：找出初始值（base case）：</span></strong></li></ul> 
<p>这题与0 - 1的bas背包的base case 一致，当物品个数为0或者背包当前容量为0时，dp[ i ][ w ] 都等于0</p> 
<p>对应的动态规划代码为：</p> 
<pre><code class="language-java">int fullBackpack(int W, int N, int[] wt, int[] val) {
    assert N == wt.length;
    // base case 已初始化，数组自动全部初始化为0
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i &lt;= N; i++) {
        for (int w = 1; w &lt;= W; w++) {
            if (w - wt[i - 1] &lt; 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = Math.max(
                    dp[i][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                );
            }
        }
    }
    
    return dp[N][W];
}
</code></pre> 
<h3 id="%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%B1%BB%E9%97%AE%E9%A2%98%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II%3A">完全背包类问题 零钱兑换II:</h3> 
<p>这是力扣第 518 题「<a href="https://leetcode.cn/problems/coin-change-ii/" rel="nofollow" title="零钱兑换 IIopen in new window">零钱兑换 IIopen in new window</a>」，题目描述：</p> 
<p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>，写一个函数来计算可以凑成总金额的硬币组合数。<strong>假设每一种面额的硬币有无限个</strong>。对应函数签名如下：</p> 
<p><img alt="" height="131" src="https://images2.imgbox.com/01/0a/oz2kTwzk_o.png" width="1008"></p> 
<p><strong>我们可以把这个问题转化为完全背包问题的描述形式</strong>：</p> 
<p>有一个背包，最大容量为 <code>amount</code>，有一系列物品 <code>coins</code>，每个物品的重量为 <code>coins[i]</code>，<strong>每个物品的数量无限</strong>。请问有多少种方法，能够把背包恰好装满？按照动态规划三步走：</p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐 步骤一:定义dp数组元素的含义：</span></strong></li></ul> 
<p><code>dp[i][j]</code> 的定义如下：若只使用前 <code>i</code> 个物品（可以重复使用），当背包容量为 <code>j</code> 时，有 <code>dp[i][j]</code> 种方法可以装满背包。</p> 
<ul><li><strong><span style="background-color:#ffd900;">🧐步骤二:找出数组元素之间的关系式(也就是我们所熟知的状态转移方程)</span></strong></li></ul> 
<p><strong>1.如果你不把这第 <code>i</code> 个物品装入背包</strong>，也就是说你不使用 <code>coins[i-1]</code> 这个面值的硬币，那么凑出面额 <code>j</code> 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果</p> 
<p><strong><span style="background-color:#38d8f0;">即状态转移方程为：dp[ i ][ j ] = dp[ i -1 ][ j ]</span></strong></p> 
<p>2.<strong>如果你把这第 <code>i</code> 个物品装入了背包</strong>，也就是说你使用 <code>coins[i-1]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。</p> 
<p><strong><span style="background-color:#38d8f0;">即状态转移方程为：dp[ i ][ j ] = dp[ i ][ j - coins[ i - 1] ]</span></strong></p> 
<ul><li>🧐<strong><span style="background-color:#ffd900;">第三步骤：找出初始值（base case）：</span></strong></li></ul> 
<p>base case 为 <code>dp[0][..] = 0, dp[..][0] = 1</code>。<code>i = 0</code> 代表不使用任何硬币面值，这种情况下显然无法凑出任何金额；<code>j = 0</code> 代表需要凑出的目标金额为 0，那么什么都不做就是唯一的一种凑法。</p> 
<p>写出动态规划代码：</p> 
<pre><code class="language-java">int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = int[n + 1][amount + 1];
    // base case
    for (int i = 0; i &lt;= n; i++) 
        dp[i][0] = 1;

    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= amount; j++)
           //装入背包或者不装入，加起来
            if (j - coins[i-1] &gt;= 0)
                dp[i][j] = dp[i - 1][j] 
                         + dp[i][j - coins[i-1]];
            else // &lt; 0 只能选择不装入背包
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}
</code></pre> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固自己的知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p><img alt="" height="390" src="https://images2.imgbox.com/47/c3/jckO0lgy_o.png" width="392"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02a35dd0b195a1990f194c713f2eea7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">dm8修改sysdba用户的密码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/564246f11229a597b620a61c6e70d414/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于rabbitmq的prefetch机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>