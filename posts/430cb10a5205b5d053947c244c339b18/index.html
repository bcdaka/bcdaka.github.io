<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高阶数据结构(一)】并查集详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/430cb10a5205b5d053947c244c339b18/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【高阶数据结构(一)】并查集详解">
  <meta property="og:description" content="💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:高阶数据结构专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多Go语言知识
🔝🔝
高阶数据结构 1. 前言2. 并查集的原理3. 并查集的实现4. 并查集的应用5. 总结以及拓展 1. 前言 本系列会带大家走进高阶数据结构的学习, 其中包括并查集,图论, LRU cache, B树, B&#43;树, B*树, 跳表. 其中, 图论中讲解的时间最长, 包括邻接表, 邻接矩阵, 广度优先遍历, 深度优先遍历, 最小生成树, 以及prim算法, dijkstra算法, bellman-Ford算法, Floyd-wars hall算法. 高阶数据结构属于拓展内容, 建议把基础掌握好后再学
本章重点:
本篇文章着重讲解并查集的原理, 并查集的实现(CPP),以及并查集的应用
2. 并查集的原理 在一些应用问题中，需要将n个不同的元素划分成一些不相交的集合。开始时，每个元素自成一个单元素集合，然后按一定的规律将归于同一组元素的集合合并。在此过程中要反复用到查询某一个元素归属于那个集合的运算。适合于描述这类问题的抽象数据类型称为并查集(union-find set)。
比如, 公司招的10个人当中有4人是北京的,三人是上海的,3人是深圳的. 那么他们就可以被分为三个不同的集合. 现在将他们进行编号(0~9),然后来看看如何将他们进行分组(为什么初始值为-1,后面再解释)
北京学生: 0,6,7,8.上海学生: 1,4,9.深圳学生: 2,3,5
假如选出0,1,2号学生作为小组的组长
现在需要在数组中,表示三个分组, 不卖关子,直接讲解并查集的原理. 当组长的人的位置的值是负数,-n代表这个组有n个人. 而非组长的成员的位置的值存储的是组长的下标,这样说可能有点抽象,下面来画个图看看
北京小组的组长是0,它的值是-4代表此小组有四个人.6,7,8是0的组员,所以它们存储的值是0,也就是组长的下标. 所以刚开始初始值为-1,代表每一个数都自成一个集合
现在出现一个情况, 由于北京的同学和上海的同学经常在一起玩耍, 所以久而久之他们就很熟了,就想着将这两个分组合并.于是出现了以下的情况:
此时,下标为1的位置应该存储它的父亲,也就是0,下标为4.9的位置不能直接存储0,而是应该存储1,因为1才是他们的直系父亲. 可以用下图来表示:
你可以窥探到,下标为0的值从-4变为-7,而下标为1的值从-3变为0,实际上就为我们后面的手撕并查集提供了思路
3. 并查集的实现 在进行并查集实现时,应该要拥有这几个基础功能函数: 找到一个下标的根, 合并两个集合, 判断两个树是否在同一个集合.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-06T09:15:00+08:00">
    <meta property="article:modified_time" content="2024-05-06T09:15:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高阶数据结构(一)】并查集详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>💓博主CSDN主页:<a href="https://blog.csdn.net/m0_61982936?spm=1000.2115.3001.5343">杭电码农-NEO</a>💓<br>   <br> ⏩专栏分类:<a href="https://blog.csdn.net/m0_61982936/category_12660316.html?spm=1001.2014.3001.5482">高阶数据结构专栏</a>⏪<br>   <br> 🚚代码仓库:<a href="https://gitee.com/NEO_kou" rel="nofollow">NEO的学习日记</a>🚚<br>   <br> 🌹关注我🫵带你学习更多Go语言知识<br>   🔝🔝</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/f8/32/wDYRDZG4_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>高阶数据结构</h4> 
 <ul><li><a href="#1__16" rel="nofollow">1. 前言</a></li><li><a href="#2__24" rel="nofollow">2. 并查集的原理</a></li><li><a href="#3__56" rel="nofollow">3. 并查集的实现</a></li><li><a href="#4__158" rel="nofollow">4. 并查集的应用</a></li><li><a href="#5__174" rel="nofollow">5. 总结以及拓展</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__16"></a>1. 前言</h2> 
<p>本系列会带大家走进高阶数据结构的学习, 其中包括并查集,图论, LRU cache, B树, B+树, B*树, 跳表. 其中, 图论中讲解的时间最长, 包括邻接表, 邻接矩阵, 广度优先遍历, 深度优先遍历, 最小生成树, 以及prim算法, dijkstra算法, bellman-Ford算法, Floyd-wars hall算法. 高阶数据结构属于拓展内容, 建议把基础掌握好后再学</p> 
<p><mark>本章重点:</mark></p> 
<blockquote> 
 <p><font color="purple"><strong>本篇文章着重讲解并查集的原理, 并查集的实现(CPP),以及并查集的应用</strong></font></p> 
</blockquote> 
<hr> 
<h2><a id="2__24"></a>2. 并查集的原理</h2> 
<blockquote> 
 <p><font color="orange"><strong>在一些应用问题中，需要将n个不同的元素划分成一些不相交的集合。开始时，每个元素自成一个单元素集合，然后按一定的规律将归于同一组元素的集合合并。在此过程中要反复用到查询某一个元素归属于那个集合的运算。适合于描述这类问题的抽象数据类型称为并查集(union-find set)。</strong></font></p> 
</blockquote> 
<p>比如, 公司招的10个人当中有4人是北京的,三人是上海的,3人是深圳的. 那么他们就可以被分为三个不同的集合. 现在将他们进行编号(0~9),然后来看看如何将他们进行分组(为什么初始值为-1,后面再解释)</p> 
<p><img src="https://images2.imgbox.com/2e/03/Xl9YIzY1_o.png" alt="在这里插入图片描述"></p> 
<p>北京学生: 0,6,7,8.上海学生: 1,4,9.深圳学生: 2,3,5<br> 假如选出0,1,2号学生作为小组的组长</p> 
<p><img src="https://images2.imgbox.com/18/28/ev18FgsI_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="gree"><strong>现在需要在数组中,表示三个分组, 不卖关子,直接讲解并查集的原理. 当组长的人的位置的值是负数,-n代表这个组有n个人. 而非组长的成员的位置的值存储的是组长的下标,这样说可能有点抽象,下面来画个图看看</strong></font></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c1/c6/xsc7IRN0_o.png" alt="在这里插入图片描述"></p> 
<p>北京小组的组长是0,它的值是-4代表此小组有四个人.6,7,8是0的组员,所以它们存储的值是0,也就是组长的下标. 所以刚开始初始值为-1,代表每一个数都自成一个集合</p> 
<blockquote> 
 <p><strong>现在出现一个情况, 由于北京的同学和上海的同学经常在一起玩耍, 所以久而久之他们就很熟了,就想着将这两个分组合并.于是出现了以下的情况:</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a8/74/WfdeHusl_o.png" alt="在这里插入图片描述"></p> 
<p>此时,下标为1的位置应该存储它的父亲,也就是0,下标为4.9的位置不能直接存储0,而是应该存储1,因为1才是他们的直系父亲. 可以用下图来表示:</p> 
<p><img src="https://images2.imgbox.com/98/53/6MPeS3NX_o.png" alt="在这里插入图片描述"></p> 
<p><strong><code>你可以窥探到,下标为0的值从-4变为-7,而下标为1的值从-3变为0,实际上就为我们后面的手撕并查集提供了思路</code></strong></p> 
<hr> 
<h2><a id="3__56"></a>3. 并查集的实现</h2> 
<p>在进行并查集实现时,应该要拥有这几个基础功能函数: 找到一个下标的根, 合并两个集合, 判断两个树是否在同一个集合. 计算此并查集一共有几个集合.</p> 
<p><mark>并查集的本质是数组,所以可以这样定义结构:</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFindSet</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">UnionFindSet</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_ufs</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//初始化数组,初始值设为-1</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> _ufs<span class="token punctuation">;</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><mark>首先可以先实现,找到一个下标的根,后续的函数可以复用它:</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">FindRoot</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token comment">//找到一个下标的根</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> parent <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>_ufs<span class="token punctuation">[</span>parent<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		parent <span class="token operator">=</span> _ufs<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//路径压缩.下次查找时效率就高了(压缩当前节点以及它的父亲节点)</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>_ufs<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> tmp <span class="token operator">=</span> _ufs<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
		_ufs<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">;</span>
		x <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> parent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><font color="purple"><strong>这份代码可以分为两步,第一步就是在找它的根,就是一直向前找直到遇见负数.第二部分的代码在进行路径压缩工作,若是有多个集合进行合并,那么我们的树可能就会很高,查找最下面的树的根时,就会出现效率低下的问题,所以进行路径压缩很有必要. 关于路径压缩的原理如下:</strong></font></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/af/78/tfA1wm9Q_o.png" alt="在这里插入图片描述"><br> <strong><code>下次再查找4的时候,就优化了时间</code></strong></p> 
<p><mark>接下来的代码就简单了:</mark></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">UnionFindSet</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">UnionFindSet</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_ufs</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">)</span> <span class="token comment">//合并两个集合</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> root1 <span class="token operator">=</span> <span class="token function">FindRoot</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> root2 <span class="token operator">=</span> <span class="token function">FindRoot</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> root2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_ufs<span class="token punctuation">[</span>root1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> _ufs<span class="token punctuation">[</span>root2<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_ufs<span class="token punctuation">[</span>root1<span class="token punctuation">]</span> <span class="token operator">+=</span> _ufs<span class="token punctuation">[</span>root2<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_ufs<span class="token punctuation">[</span>root2<span class="token punctuation">]</span> <span class="token operator">=</span> root1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			_ufs<span class="token punctuation">[</span>root2<span class="token punctuation">]</span> <span class="token operator">+=</span> _ufs<span class="token punctuation">[</span>root1<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_ufs<span class="token punctuation">[</span>root1<span class="token punctuation">]</span> <span class="token operator">=</span> root2<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> <span class="token function">FindRoot</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token comment">//找到一个下标的根</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> parent <span class="token operator">=</span> x<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>_ufs<span class="token punctuation">[</span>parent<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
			parent <span class="token operator">=</span> _ufs<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token comment">//路径压缩.下次查找时效率就高了(压缩当前节点以及它的父亲节点</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>_ufs<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> tmp <span class="token operator">=</span> _ufs<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			_ufs<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">;</span>
			x <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> parent<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">bool</span> <span class="token function">SameSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span> <span class="token keyword">int</span> x2<span class="token punctuation">)</span><span class="token comment">//判断这两个数是否在同一个集合</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">FindRoot</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">FindRoot</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	size_t <span class="token function">SetSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//这个并查集一共有几个集合</span>
	<span class="token punctuation">{<!-- --></span>
		size_t size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> _ufs<span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
				size<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> size<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> _ufs<span class="token punctuation">;</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><font color="orange"><strong>判断两个数是否在同一集合,以及一共有几个集合,这两个函数比较简单,不做讲解. 合并两个集合先要找到这两个数的根,如果这两个数有相同的根就直接返回,否则就开始合并.合并的逻辑也非常简单,其中的if,else语句不是必须的</strong></font></p> 
</blockquote> 
<hr> 
<h2><a id="4__158"></a>4. 并查集的应用</h2> 
<p>由于我是学生,所以我先给大家看看并查集在校招中考察的多不多,这道题: <a href="https://leetcode.cn/problems/bLyHh0/description/" rel="nofollow">省份数量</a>是19年美团笔试的原题,并且今年24年的笔试疑似也出现过并查集解题. 除此之外, 华为考察算法和数据结构也比较厉害.其中的考点之一就有并查集:</p> 
<p><img src="https://images2.imgbox.com/81/96/Qnh8sl0b_o.png" alt="在这里插入图片描述"></p> 
<p>并查集往往用于解决图上的问题，并查集只有两个操作，“并” 和 “查”，但是通过这两个操作可以派生出一些其他的应用：</p> 
<ul><li>图的连通性问题</li><li>集合的个数</li><li>集合中元素的个数</li></ul> 
<blockquote> 
 <p><font color="gree"><strong>并且在后面学习图论的过程中,也会涉及到并查集的知识,会复用并查集的代码. 这也是我优先讲并查集的原因之一, 如果你没有学过并查集直接去搞图论,可能会十分吃力</strong></font></p> 
</blockquote> 
<hr> 
<h2><a id="5__174"></a>5. 总结以及拓展</h2> 
<p>并查集只是高阶数据结构中的开胃菜,后面的数据结构会越来越难,请大家耐心学习</p> 
<hr> 
<center>
  🔎 
 <font color="#4b0080"> 下期预告:图论 </font>🔍 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d8881496f79bc31f25668ad7a440aa6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springAI框架学习总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64c91bcfacd12e42f5116b3e21889aa1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL:Error on observer while running replication hoot ‘before_commit‘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>