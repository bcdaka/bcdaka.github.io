<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【爱上C&#43;&#43;】vector模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9a7dc4d384614fc30706033bc3bc52b6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【爱上C&#43;&#43;】vector模拟实现">
  <meta property="og:description" content="文章目录 前言一：基本框架1.结构的定义2.构造函数①.详解 const T&amp; val = T()②.为什么要多加一个int类的带参构造？】 3.析构函数4.size()和capacity()5.push_back尾插6.operator[]operator[]的返回类型为T&amp;有以下几个原因： 二：迭代器的实现1.begin()和end()2.迭代器区间构造 三：reserve 引发的相关问题1.内部迭代器失效2.外部迭代器失效3.正确的实现_start 指针的作用 _start[i] 的含义 4.memcpy带来的问题 四：insert 引发的相关问题1.内部迭代器失效2.外部迭代器失效 五：erase 引发的相关问题修改后的执行过程 六：其他操作resize赋值运算符重载现代写法的思路为什么现代写法传参数时不能传引用？现代写法传参为什么不能传引用的具体原因： 七：完整代码 前言 上一节我们讲了vector的基本使用，现在我们讲解vector的模拟实现，其中有三大重难点：
1.vector是如何进行设计与封装的
2.迭代器失效问题
3.memcpy,memmove导致的浅拷贝问题
一：基本框架 1.结构的定义 #include &lt;iostream&gt; #include &lt;assert.h&gt; using namespace std; namespace myvector { template&lt;class T&gt; class vector { public: // Vector的迭代器是一个原生指针 typedef T* iterator; typedef const T* const_iterator; private: iterator _start; // 开始位置 iterator _finish;	// 结束位置 iterator _endofstorage;	// end of storage }; } 在 vector 类中，我们通常会使用_指针_来表示迭代器，因为指针天然支持指针算术运算和解引用操作，可以方便地遍历和访问元素。使用 typedef 定义迭代器类型可以使代码更加灵活和可维护。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T09:59:56+08:00">
    <meta property="article:modified_time" content="2024-07-15T09:59:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【爱上C&#43;&#43;】vector模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#_8" rel="nofollow">一：基本框架</a></li><li><ul><li><a href="#1_10" rel="nofollow">1.结构的定义</a></li><li><a href="#2_58" rel="nofollow">2.构造函数</a></li><li><ul><li><a href="#_const_T_val__T_83" rel="nofollow">①.详解 const T&amp; val = T()</a></li><li><a href="#int_90" rel="nofollow">②.为什么要多加一个int类的带参构造？】</a></li></ul> 
   </li><li><a href="#3_111" rel="nofollow">3.析构函数</a></li><li><a href="#4sizecapacity_123" rel="nofollow">4.size()和capacity()</a></li><li><a href="#5push_back_137" rel="nofollow">5.push_back尾插</a></li><li><a href="#6operator_158" rel="nofollow">6.operator[]</a></li><li><ul><li><a href="#operatorT_174" rel="nofollow">operator[]的返回类型为T&amp;有以下几个原因：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_190" rel="nofollow">二：迭代器的实现</a></li><li><ul><li><ul><li><a href="#1beginend_192" rel="nofollow">1.begin()和end()</a></li><li><a href="#2_245" rel="nofollow">2.迭代器区间构造</a></li></ul> 
  </li></ul> 
  </li><li><a href="#reserve__279" rel="nofollow">三：reserve 引发的相关问题</a></li><li><ul><li><a href="#1_281" rel="nofollow">1.内部迭代器失效</a></li><li><a href="#2_337" rel="nofollow">2.外部迭代器失效</a></li><li><a href="#3_376" rel="nofollow">3.正确的实现</a></li><li><ul><li><ul><li><a href="#_start__418" rel="nofollow">_start 指针的作用</a></li></ul> 
    </li><li><a href="#_starti__421" rel="nofollow">_start[i] 的含义</a></li></ul> 
   </li><li><a href="#4memcpy_427" rel="nofollow">4.memcpy带来的问题</a></li></ul> 
  </li><li><a href="#insert__447" rel="nofollow">四：insert 引发的相关问题</a></li><li><ul><li><a href="#1_469" rel="nofollow">1.内部迭代器失效</a></li><li><a href="#2_506" rel="nofollow">2.外部迭代器失效</a></li></ul> 
  </li><li><a href="#erase__587" rel="nofollow">五：erase 引发的相关问题</a></li><li><ul><li><ul><li><a href="#_713" rel="nofollow">修改后的执行过程</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_727" rel="nofollow">六：其他操作</a></li><li><ul><li><a href="#resize_729" rel="nofollow">resize</a></li><li><a href="#_761" rel="nofollow">赋值运算符重载</a></li><li><ul><li><a href="#_799" rel="nofollow">现代写法的思路</a></li><li><a href="#_806" rel="nofollow">为什么现代写法传参数时不能传引用？</a></li><li><a href="#_816" rel="nofollow">现代写法传参为什么不能传引用的具体原因：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_827" rel="nofollow">七：完整代码</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>上一节我们讲了vector的基本使用，现在我们讲解vector的模拟实现，其中有<strong>三大重难点</strong>：<br>1.vector是如何进行设计与封装的<br>2.<strong>迭代器失效问题</strong><br>3.memcpy,memmove导致的浅拷贝问题</p> 
<hr> 
<p></p> 
<h2><a id="_8"></a>一：基本框架</h2> 
<p></p> 
<h3><a id="1_10"></a>1.结构的定义</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">namespace</span> myvector
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token comment">// Vector的迭代器是一个原生指针</span>
		<span class="token keyword">typedef</span> T<span class="token operator">*</span> iterator<span class="token punctuation">;</span>
		<span class="token keyword">typedef</span> <span class="token keyword">const</span> T<span class="token operator">*</span> const_iterator<span class="token punctuation">;</span>


	<span class="token keyword">private</span><span class="token operator">:</span>
		iterator _start<span class="token punctuation">;</span>        <span class="token comment">// 开始位置</span>
		iterator _finish<span class="token punctuation">;</span>		<span class="token comment">// 结束位置</span>
		iterator _endofstorage<span class="token punctuation">;</span>	<span class="token comment">// end of storage</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在 vector 类中，我们通常会使用_指针_来表示迭代器，因为指针天然支持指针算术运算和解引用操作，可以方便地遍历和访问元素。使用 typedef 定义迭代器类型可以使代码更加灵活和可维护。</p> 
<p>使用 iterator 类型有以下几个原因：</p> 
<ol><li><strong>可读性和维护性</strong>： 使用 iterator 使得代码更具可读性。例如，当看到 iterator 类型时，很容易理解这是一个指向容器元素的指针，而不是其他类型的指针。</li><li><strong>灵活性</strong>： 如果将来需要更改迭代器的实现方式，只需要修改 typedef 定义，而不需要修改所有使用迭代器的代码。例如，如果将来决定使用自定义的迭代器类，而不是原始指针，只需要修改 typedef 语句。</li><li><strong>与 STL 接口一致</strong>： 这使得 vector 类的接口与标准模板库（STL）容器的接口一致，便于用户使用和理解。例如，STL 容器如 std::vector 也使用迭代器来遍历和操作元素。</li></ol> 
<p><strong>_start</strong>：</p> 
<ul><li>这是一个指针，指向分配的内存空间中的第一个元素。</li><li>在 vector 类中，_start 指向当前存储的第一个元素的位置。</li></ul> 
<p><strong>_finish</strong>：</p> 
<ul><li>这是一个指针，指向当前存储的最后一个元素之后的位置。</li><li>在 vector 类中，_finish 指向最后一个元素的下一个位置。即，有效元素的范围是从 _start 到 _finish-1。</li></ul> 
<p><strong>_endofstorage</strong>：</p> 
<ul><li>这是一个指针，指向分配的内存空间的末尾位置。</li><li>在 vector 类中，_endofstorage 指向当前分配的内存空间的末尾，即容器可以存储元素的最大位置。</li></ul> 
<p><img src="https://images2.imgbox.com/51/16/I0D8Iqkq_o.png" alt="image.png"><br>所以由图我们可以知道：<br><code>_size=_finish-_start</code><br><code>_capacity=_endofstorage-_start</code><br> </p> 
<h3><a id="2_58"></a>2.构造函数</h3> 
<p>构造函数有三类：无参构造函数，带参构造，迭代器区间构造放在 二：迭代器的实现 中讲述。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//无参默认构造</span>
<span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token operator">:</span><span class="token function">_start</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token function">_finish</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token function">_endofstorage</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>

<span class="token comment">// 带参构造函数，创建包含 n 个 val 值的 vector</span>
<span class="token function">vector</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//带参构造（int）</span>
<span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p></p> 
<h4><a id="_const_T_val__T_83"></a>①.详解 const T&amp; val = T()</h4> 
<p>关于 const T&amp; value = T() 作为默认参数的详细解释，我们需要理解以下几个概念：默认参数、匿名对象、以及如何结合使用它们。<br><strong>默认参数</strong><br>默认参数允许函数在调用时省略某些参数。编译器会使用提供的默认值来填补这些被省略的参数。对于构造函数来说，默认参数提供了一种灵活的初始化方式。<br><strong>匿名对象</strong><br>匿名对象是指没有绑定到任何变量的临时对象。在 C++ 中，可以通过直接调用构造函数来创建匿名对象。例如，<strong>T()</strong> 就是一个创建类型为 T 的默认构造对象的表达式。<br>const T&amp; value = T()<br>现在，让我们将这些概念结合起来看 const T&amp; value = T() 是如何工作的。</p> 
<ol><li><strong>默认参数的使用</strong><br>在构造函数定义中：<br>vector(int n, const T&amp; value = T())<br>value 是一个默认参数，其默认值是一个匿名对象 T()。</li><li><strong>匿名对象的创建</strong><br>T() 表达式创建了一个类型为 T 的匿名对象。对于基础类型 int，T() 等价于 0。对于用户定义的类型 T，它调用 T 的默认构造函数创建一个默认初始化的对象。</li><li><strong>引用绑定</strong><br>const T&amp; value = T() 意味着默认参数 value 是一个对匿名对象的常量引用。这里引用了临时对象，但因为是常量引用，所以该临时对象在整个函数调用过程中是有效的（临时对象的生命周期延长至引用的生命周期结束）。<br> </li></ol> 
<h4><a id="int_90"></a>②.为什么要多加一个int类的带参构造？】</h4> 
<p>思考一下，如果不加vector(int n, const T&amp; val = T())，下面这个代码是否有问题？</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v1<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v2<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> 
<p>上面这个代码看似没问题，如果没有vector(int n, const T&amp; val = T())就会报错<br><img src="https://images2.imgbox.com/2d/ea/l56uaAdz_o.png" alt="image.png"><br>原因如下图:<br><img src="https://images2.imgbox.com/1f/5a/tenrxDXH_o.png" alt="image.png"><br>v2优先匹配上迭代器构造，此时会造成 <em>非法间接寻址</em> 错误</p> 
<p>再举另外一个例子<br><code>vector&lt;int&gt; v(10, 5);</code><br>编译器在编译时，认为T已经被实例化为int，而10和5编译器会默认其为int类型<br>就不会走vector(size_t n, const T&amp; value = T())这个构造方法，最终选择的是：vector(InputIterator first, InputIterator last)。<br>因为编译器觉得区间构造两个参数类型一致，因此编译器就会将InputIterator实例化为int，但是10和5根本不是一个区间，编译时就报错了，故需要增加该构造方法</p> 
<p></p> 
<h3><a id="3_111"></a>3.析构函数</h3> 
<pre><code class="prism language-cpp"><span class="token operator">~</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_start<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
        _start <span class="token operator">=</span> _finish <span class="token operator">=</span> _endofstorage <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h3><a id="4sizecapacity_123"></a>4.size()和capacity()</h3> 
<pre><code class="prism language-cpp">size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> _finish <span class="token operator">-</span> _start<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

size_t <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> _endofstorage <span class="token operator">-</span> _start<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>根据上面的图，很容易的理解size()和capacity()<br> </p> 
<h3><a id="5push_back_137"></a>5.push_back尾插</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_finish <span class="token operator">==</span> _endofstorage<span class="token punctuation">)</span><span class="token comment">//如果满了则要扩容</span>
    <span class="token punctuation">{<!-- --></span>
        size_t  newcapacity <span class="token operator">=</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">//如果 capacity() == 0,则让 capacity()=4，</span>
        <span class="token comment">//如果 capacity() !=0 ,则让 capacity()=capacity()*2</span>
        <span class="token function">reserve</span><span class="token punctuation">(</span>newcapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>_finish <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token operator">++</span>_finish<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">--</span>_finish<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h3><a id="6operator_158"></a>6.operator[]</h3> 
<pre><code class="prism language-cpp">
<span class="token comment">//返回 T&amp; 是因为 operator[] 旨在提供对容器元素的直接访问和修改能力，而不仅仅是读取元素的值。</span>
T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> _start<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t pos<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> _start<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h4><a id="operatorT_174"></a>operator[]的返回类型为T&amp;有以下几个原因：</h4> 
<ol><li><strong>方便读写操作</strong>： 
  <ul><li>返回T&amp;（T的引用）可以同时支持读和写操作。如果返回的是值（T），你只能读取值，不能修改。</li></ul> </li></ol> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 可以通过 T&amp; 引用修改值</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读取值</span>
</code></pre> 
<ol start="2"><li><strong>避免不必要的拷贝</strong>： 
  <ul><li>返回引用避免了拷贝，提升了性能。如果返回值（T），每次访问元素时都会进行拷贝，这在处理大对象时会显著影响性能。</li><li>例如，返回引用只需要获取对象的地址，而不需要实际拷贝对象的数据。</li></ul> </li><li><strong>一致性和习惯用法</strong>： 
  <ul><li>标准库中的std::vector和其他容器都采用这种设计。遵循这种设计可以确保自定义容器的接口和行为与标准容器一致，减少学习和使用上的障碍。<br> </li></ul> </li></ol> 
<h2><a id="_190"></a>二：迭代器的实现</h2> 
<p></p> 
<h4><a id="1beginend_192"></a>1.begin()和end()</h4> 
<p><img src="https://images2.imgbox.com/a0/97/WVU6gMHl_o.png" alt="image.png"></p> 
<pre><code class="prism language-cpp">  		<span class="token comment">//普通对象的迭代器：提供对容器元素的读写访问。</span>
		<span class="token comment">//begin</span>
		iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _start<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//end</span>
		iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _finish<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//常量对象的迭代器：提供对容器元素的只读访问。</span>
		const_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _start<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		const_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _finish<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

</code></pre> 
<p>测试一下</p> 
<pre><code class="prism language-cpp">    <span class="token keyword">void</span> <span class="token function">test_vector10</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
			it<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//注意不要写成*it++</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9d/c9/6mOGslEX_o.png" alt="image.png"><br> </p> 
<h4><a id="2_245"></a>2.迭代器区间构造</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputInterator</span><span class="token operator">&gt;</span>
<span class="token function">vector</span><span class="token punctuation">(</span>InputInterator first<span class="token punctuation">,</span>InputIterator last<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>first<span class="token operator">!=</span>last<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>first<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>详细讲解：</p> 
<ol><li>模板参数 InputIterator:<br>InputIterator 是一个模板参数，表示输入迭代器的类型。可以是指针、标准库迭代器（如std::vector::iterator）或者用户定义的迭代器。<br>通过使用模板，这个构造函数可以处理各种类型的迭代器，从而支持不同的容器和数据结构。</li><li>参数 first 和 last:<br>first 和 last 是两个迭代器，表示要复制的元素区间的起始和结束位置。<br>这个区间是半开区间 [first, last)，即包含 first 指向的元素，但不包含 last 指向的元素。</li><li>构造函数主体:<br>构造函数通过遍历 [first, last) 区间，将每个元素插入到当前vector对象中。</li><li>操作步骤:<br>初始化:<br>InputIterator first, last 定义了两个迭代器，分别指向待复制元素的起始位置和结束位置。<br>循环:<br>while (first != last) 循环遍历从 first 到 last 的区间。<br>在每次循环中，通过 *first 解引用 first 指向的元素，并使用 push_back(*first) 将其添加到vector对象的末尾。<br>使用 ++first 将 first 移动到下一个元素。</li></ol> 
<p>举个例子应用一下：</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">void</span> <span class="token function">test_vector10</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token function">v1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v1<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果如下：<br><img src="https://images2.imgbox.com/75/06/iAmffOUy_o.png" alt="image.png"><br>此时的first就是arr,last就是arr+5<br> </p> 
<h2><a id="reserve__279"></a>三：reserve 引发的相关问题</h2> 
<p></p> 
<h3><a id="1_281"></a>1.内部迭代器失效</h3> 
<p>在动态数组的 reserve 函数中，如果新预留的空间 n 大于当前的容量 capacity()，则需要进行扩容操作。代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">reserve</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//1.申请新空间</span>
        T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//2.将原有数据拷贝到新空间当中</span>
        <span class="token function">memmove</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> _start<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//3.释放原有空间</span>
        <span class="token keyword">delete</span> _start<span class="token punctuation">;</span>
        <span class="token comment">//4.指向新空间</span>
        _start <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        _finish <span class="token operator">=</span> _start <span class="token operator">+</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _endOfStorage <span class="token operator">=</span> _start <span class="token operator">+</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>乍一看，这段代码似乎是正确的，然而实际上存在一个严重的问题：<strong>野指针问题</strong>。在扩容之后，_finish 和 _endOfStorage 仍然指向旧空间的对应位置。 <br>问题分析:<br>我们来详细分析这段代码的执行过程：</p> 
<ol><li><strong>申请新空间</strong>：T* tmp = new T[n];</li><li><strong>拷贝数据</strong>：memmove(tmp, _start, sizeof(T) * size());</li><li><strong>释放旧空间</strong>：delete _start;</li><li><strong>更新指针</strong>：_start = tmp; 然后 _finish 和 _endOfStorage 指向新空间的位置。</li></ol> 
<p>问题出在第四步，虽然 _start 更新到了新空间，但 _finish 和 _endOfStorage 指向的是新空间中的不正确位置，因为它们是基于旧空间的 size 和 capacity 计算的。<br><img src="https://images2.imgbox.com/33/cf/FtBQ9RLB_o.png" alt="image.png"><br>解决方法:<br>我们需要在释放旧空间之前保存旧空间的 size，并在新空间中重新计算 _finish 和 _endOfStorage。<br>正确的实现:<br>下面是修改后的 reserve 函数，解决了野指针问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">reserve</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//1.保存原有空间的size</span>
        size_t oldSize <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2.开辟新空间</span>
        T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//3.将原有空间的数据拷贝到新空间当中</span>
        <span class="token function">memmove</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> _start<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">*</span> oldSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//4.释放旧空间</span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
        <span class="token comment">//5.指向新空间</span>
        _start <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        _finish <span class="token operator">=</span> _start <span class="token operator">+</span> oldSize<span class="token punctuation">;</span>
        _endOfStorage <span class="token operator">=</span> _start <span class="token operator">+</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>详细步骤：</p> 
<ol><li><strong>保存原有空间的 size</strong>：size_t oldSize = size();</li><li><strong>开辟新空间</strong>：T* tmp = new T[n];</li><li><strong>拷贝数据到新空间</strong>：memmove(tmp, _start, sizeof(T) * oldSize);</li><li><strong>释放旧空间</strong>：delete[] _start;</li><li><strong>更新指针指向新空间</strong>：_start = tmp;，_finish = _start + oldSize;，_endOfStorage = _start + n;<br> </li></ol> 
<h3><a id="2_337"></a>2.外部迭代器失效</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">reserve</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//1.保存原有空间的size</span>
        size_t oldSize <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2.开辟新空间</span>
        T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//3.将原有空间的数据拷贝到新空间当中</span>
        <span class="token function">memmove</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> _start<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">*</span> oldSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//4.释放旧空间</span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
        <span class="token comment">//5.指向新空间</span>
        _start <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        _finish <span class="token operator">=</span> _start <span class="token operator">+</span> oldSize<span class="token punctuation">;</span>
        _endOfStorage <span class="token operator">=</span> _start <span class="token operator">+</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这段代码在处理内置类型（如 <code>int</code>）时没有问题，但当处理自定义类型（如 <code>std::string</code>）时会导致浅拷贝问题，进而引发内存管理错误。<br>问题分析：<br><strong>浅拷贝问题：</strong><br>浅拷贝是指直接拷贝对象的内存内容，而不考虑对象中的指针和动态分配的内存。这在处理内置类型时通常是安全的，但对于包含指针或动态内存的自定义类型，会导致多个对象指向同一块内存，从而引发多次释放同一内存的问题。<br>例如，当 <code>vector</code> 存储 <code>std::string</code> 类型时：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test_vector10</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"def"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"exd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> v1<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在 <code>reserve</code> 扩容后，浅拷贝会导致同一块内存被多个 <code>string</code> 对象引用，最终导致程序崩溃和断言错误。<br>解释如图（放大观看）：<br><img src="https://images2.imgbox.com/94/40/s12TER70_o.png" alt="image.png"><br><strong>解决方法</strong><br>我们需要避免浅拷贝，确保在扩容时进行深拷贝。对于自定义类型，使用赋值运算符重载来实现深拷贝是关键。<br> </p> 
<h3><a id="3_376"></a>3.正确的实现</h3> 
<p>下面是修改后的 <code>reserve</code> 函数，解决了浅拷贝问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">reserve</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 提前保存偏移量oldSize</span>
        size_t oldSize <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1.申请新空间</span>
        T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.将原有空间中的数据拷贝到新空间当中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> _start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token comment">// 内置类型直接赋值，自定义类型调用赋值运算符重载，进行深拷贝</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 3.释放原有空间</span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
        <span class="token comment">// 4.将_start, _finish, _endOfStorage都指向到新空间</span>
        _start <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        _finish <span class="token operator">=</span> _start <span class="token operator">+</span> oldSize<span class="token punctuation">;</span>
        _endOfStorage <span class="token operator">=</span> _start <span class="token operator">+</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>详细步骤</strong></p> 
<ol><li>**保存原有空间的 **<code>size</code>：<code>size_t oldSize = size();</code></li><li><strong>开辟新空间</strong>：<code>T* tmp = new T[n];</code></li><li><strong>拷贝数据到新空间</strong>：使用赋值运算符进行深拷贝：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> oldSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> _start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li><strong>释放旧空间</strong>：<code>delete[] _start;</code></li><li><strong>更新指针指向新空间</strong>：<code>_start = tmp;</code>，<code>_finish = _start + oldSize;</code>，<code>_endOfStorage = _start + n;</code></li></ol> 
<blockquote> 
 <p></p> 
</blockquote> 
<h5><a id="_start__418"></a>_start 指针的作用</h5> 
<blockquote> 
 <p>_start 是指向动态数组首元素的指针。我们可以通过下标运算符（[]）来访问动态数组中的元素。例如，_start[i] 表示数组中的第 i 个元素。指针和数组在 C++ 中有很多相似之处，特别是在内存访问上。<br> </p> 
</blockquote> 
<h4><a id="_starti__421"></a>_start[i] 的含义</h4> 
<blockquote> 
 <p>当我们使用 _start[i] 时，相当于对指针进行偏移访问。这是因为 T* _start 是指向类型 T 的指针，_start[i] 等价于 *(_start + i)，即访问 T 类型数组的第 i 个元素。</p> 
</blockquote> 
<p></p> 
<h3><a id="4memcpy_427"></a>4.memcpy带来的问题</h3> 
<p>假设模拟实现的vector中的reserve接口中，使用memcpy进行的拷贝，以下代码会发生什么问题？</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
myvector<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>myvector<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"2222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"3333"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>问题分析：</strong></p> 
<ol><li>memcpy是内存的二进制格式拷贝，将一段内存空间中内容原封不动的拷贝到另外一段内存空间中</li><li>如果拷贝的是内置类型的元素，memcpy既高效又不会出错，但如果拷贝的是自定义类型元素，并且<br>自定义类型元素中涉及到资源管理时，就会出错，因为memcpy的拷贝实际是浅拷贝。</li></ol> 
<p><img src="https://images2.imgbox.com/e7/f3/k31CyHq4_o.png" alt="image.png"><img src="https://images2.imgbox.com/e6/dc/2uWBoIDD_o.png" alt="image.png"><img src="https://images2.imgbox.com/5a/e9/RPB4tT38_o.png" alt="image.png"><img src="https://images2.imgbox.com/24/db/B21UKNJq_o.png" alt="image.png"><br><strong>结论</strong>：如果对象中涉及到资源管理时，千万不能使用memcpy进行对象之间的拷贝，因为memcpy是浅拷贝，否则可能会引起内存泄漏甚至程序崩溃。<br> </p> 
<h2><a id="insert__447"></a>四：insert 引发的相关问题</h2> 
<p>先看看insert的代码</p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start <span class="token operator">&amp;&amp;</span> pos <span class="token operator">&lt;=</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保插入位置合法</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_finish <span class="token operator">==</span> _endofstorage<span class="token punctuation">)</span> <span class="token comment">// 如果存储空间已满</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">reserve</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩充存储空间</span>
			<span class="token punctuation">}</span>
			iterator end <span class="token operator">=</span> _finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化end为最后一个元素的位置</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> pos<span class="token punctuation">)</span> <span class="token comment">// 从后向前移动元素，直到插入位置</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token operator">*</span><span class="token punctuation">(</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>end<span class="token punctuation">;</span> <span class="token comment">// 将元素向后移动一位</span>
				end<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 继续向前移动</span>
			<span class="token punctuation">}</span>
			<span class="token operator">*</span>pos <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 在插入位置插入新元素</span>
			<span class="token operator">++</span>_finish<span class="token punctuation">;</span> <span class="token comment">// 更新_finish指针</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>我们来测试一下：<br><img src="https://images2.imgbox.com/61/8b/GXCKMDqN_o.png" alt="image.png"><br>结果如下：<br><img src="https://images2.imgbox.com/30/74/sOC3h5D2_o.png" alt="image.png"><br>为什么呢?<br> </p> 
<h3><a id="1_469"></a>1.内部迭代器失效</h3> 
<blockquote> 
 <p><strong>内部迭代器失效</strong>指的是，当容器进行某些操作（例如内存重新分配）时，容器内部的迭代器（即正在被容器使用或操作的迭代器）由于这些操作而失效。在你的代码中，pos 作为插入操作中的一个内部迭代器，在调用 reserve 扩充存储空间时，可能会因为内存重新分配而失效。这种失效主要发生在容器的实现内部，开发者需要在实现容器操作时特别注意。</p> 
</blockquote> 
<p><strong>迭代器失效问题</strong>：</p> 
<ul><li>当 _finish == _endofstorage 时，调用 reserve 可能会重新分配内存并复制现有元素到新的存储位置。此时，所有指向旧存储位置的迭代器（包括 pos 和 end）都会失效。</li></ul> 
<p><strong>解决办法</strong><br>在调用 reserve 之后，重新计算 pos 和 end 的位置，确保插入操作在新的存储位置上进行。使用更通用和安全的方法来处理迭代器操作。</p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 检查是否需要增容</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_finish <span class="token operator">==</span> _endofstorage<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 扩容会导致迭代器失效，扩容需要更新一下 pos</span>
				size_t len <span class="token operator">=</span> pos <span class="token operator">-</span> _start<span class="token punctuation">;</span>
				<span class="token function">reserve</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				pos <span class="token operator">=</span> _start <span class="token operator">+</span> len<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 移动数据</span>
			iterator end <span class="token operator">=</span> _finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token operator">*</span><span class="token punctuation">(</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>
				end<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 插入数据</span>
			<span class="token operator">*</span>pos <span class="token operator">=</span> x<span class="token punctuation">;</span>
			_finish<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>我们运行一下看看<br><img src="https://images2.imgbox.com/f0/05/K9Swnvei_o.png" alt="image.png"><br>这样就没问题啦！<br>但是！这段代码其实还是存在问题的</p> 
<p></p> 
<h3><a id="2_506"></a>2.外部迭代器失效</h3> 
<blockquote> 
 <p><strong>外部迭代器失效</strong>指的是，容器外部的代码在使用容器的迭代器时，由于容器内部发生了某些操作（如内存重新分配、元素删除等），导致这些外部使用的迭代器变得无效。这通常发生在用户代码中，当用户在迭代容器并同时对容器进行修改时，外部的迭代器会失效。</p> 
</blockquote> 
<p>看看下面这个测试函数能不能通过？</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">void</span> <span class="token function">test_vector10</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插入 99</span>
		v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再插入 111</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>调试一下<br><img src="https://images2.imgbox.com/7d/c8/TpvJa5aG_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/99/b9/dV1RfvX2_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/39/2c/8dFq0ozc_o.png" alt="image.png"><br><strong>详细解释</strong></p> 
<ol><li><strong>向量扩容前的情况</strong>： 
  <ul><li>初始容量为0，第一次调用 <code>push_back</code> 时会将容量扩展为4。</li><li>插入10、20、30、40后，向量状态如下：</li></ul> </li></ol> 
<pre><code class="prism language-cpp">容量<span class="token operator">:</span> <span class="token number">4</span>
内容<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>
</code></pre> 
<ol start="2"><li><strong>插入新元素99</strong>： 
  <ul><li>调用 <code>v.insert(it, 99)</code> 时，<code>it</code> 是 <code>v.begin()</code>，即指向10的位置。</li><li><code>insert</code> 过程中，如果容量不够，会调用 <code>reserve</code> 增加容量（假设容量增加到8）。</li><li>扩容后，<code>it</code> 仍然指向新分配内存中的位置，但是**外部的 **<code>**it**</code> 迭代器并没有被更新，它仍然指向旧的内存位置，这就导致了 <code>it</code> 成为野指针。</li><li>插入操作成功后，向量状态如下：</li></ul> </li></ol> 
<pre><code class="prism language-cpp">容量<span class="token operator">:</span> <span class="token number">8</span>
内容<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>
</code></pre> 
<ol start="3"><li><strong>再次插入新元素111</strong>： 
  <ul><li>调用 <code>v.insert(it + 1, 111)</code> 时，<code>it + 1</code> 是一个野指针，指向旧内存位置，这会导致未定义行为，程序可能崩溃或插入失败。</li></ul> </li></ol> 
<p><strong>解决问题</strong><br>返回有效迭代器<br>在 <code>insert</code> 方法中返回插入位置的新迭代器，并在调用代码中使用返回的迭代器进行后续操作。</p> 
<pre><code class="prism language-cpp"><span class="token comment">/* 插入 */</span>
iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token comment">// 检查是否需要增容</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_finish <span class="token operator">==</span> _endofstorage<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 扩容会导致迭代器失效，扩容需要更新一下 pos</span>
		size_t len <span class="token operator">=</span> pos <span class="token operator">-</span> _start<span class="token punctuation">;</span>
		<span class="token function">reserve</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
		pos <span class="token operator">=</span> _start <span class="token operator">+</span> len<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
 
	<span class="token comment">// 移动数据</span>
	iterator end <span class="token operator">=</span> _finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span><span class="token punctuation">(</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
			
	<span class="token comment">// 插入数据</span>
	<span class="token operator">*</span>pos <span class="token operator">=</span> x<span class="token punctuation">;</span>
	_finish<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>调用代码使用返回的迭代器<br><img src="https://images2.imgbox.com/d3/cf/fcu3HG4E_o.png" alt="image.png"></p> 
<p>总结<br>通过在 <code>insert</code> 方法中返回有效的迭代器，并在调用代码中使用返回的迭代器，可以有效避免迭代器失效问题。这种方法确保即使容器内部进行了扩容操作，外部代码仍然可以使用有效的迭代器进行后续操作，从而避免未定义行为和潜在错误。<br> </p> 
<h2><a id="erase__587"></a>五：erase 引发的相关问题</h2> 
<p>erase 代码：</p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start<span class="token punctuation">)</span><span class="token punctuation">;</span>
			iterator begin <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> _finish<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token operator">*</span><span class="token punctuation">(</span>begin <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>begin<span class="token punctuation">;</span>
				begin<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			_finish<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>问题分析<br>在原始的 <code>erase</code> 函数中，当我们删除一个元素时，容器会重新排列后续的元素以填补被删除元素的位置。这种操作会使得原本指向删除位置的迭代器 <code>pos</code> 失效。失效的迭代器在后续操作中继续使用，可能会导致程序出现未预期的行为。<br>具体来说，在下面的测试函数 <code>test_vector8</code> 中：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test_vector10</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//删除所有偶数</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>it <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>it<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>删除偶数的过程中，存在以下几种情况：</p> 
<ol><li>数据 <code>[1, 2, 3, 4, 5]</code>：程序运行正常，但这只是一个巧合，因为被删除的元素后面恰巧是一个非偶数。</li><li>数据 <code>[1, 2, 3, 4]</code>：程序崩溃。删除最后一个偶数后，迭代器 <code>pos</code> 已经失效，再次 <code>pos++</code> 可能导致迭代器越界。</li><li>数据 <code>[1, 2, 4, 5]</code>：程序结果不正确。删除一个偶数后，迭代器 <code>pos</code> 指向了下一个元素，此时由于连续的偶数，第二个偶数没有被判断和删除。</li></ol> 
<p><strong>分析具体情况</strong></p> 
<ul><li>数据 <code>[1, 2, 3, 4, 5]</code>：在第一次删除 <code>2</code> 后，容器重新排列，<code>3</code> 移到原本 <code>2</code> 的位置，迭代器 <code>pos</code> 失效，但因为 <code>pos++</code> 后指向了 <code>3</code>（新位置），后续操作没有影响，这种情况是巧合。</li><li>数据 <code>[1, 2, 3, 4]</code>：删除 <code>2</code> 后，<code>3</code> 移到原来 <code>2</code> 的位置，再次 <code>pos++</code> 指向了 <code>4</code>。删除 <code>4</code> 后，迭代器指向了 <code>_finish</code>，再 <code>pos++</code> 会越过容器的边界，导致程序崩溃。</li><li>数据 <code>[1, 2, 4, 5]</code>：删除 <code>2</code> 后，<code>4</code> 移到原来 <code>2</code> 的位置，再次 <code>pos++</code> 指向了 <code>5</code>，跳过了 <code>4</code>，导致 <code>4</code> 未被删除。</li></ul> 
<p><strong>根本原因</strong></p> 
<ol><li><strong>迭代器失效</strong>：<code>erase(pos)</code> 操作后，<code>pos</code> 不再指向有效的位置。容器内存重新排列后，<code>pos</code> 的位置已经失效，继续使用失效的迭代器会导致未定义行为。</li><li><strong>迭代器的无效递增</strong>：在删除元素后，<code>pos</code> 应该被更新为指向下一个有效的位置，而不是简单地递增 <code>pos++</code>。直接递增失效的迭代器会导致逻辑错误和潜在的崩溃。</li><li><strong>容器的内存管理</strong>：一些 <code>vector</code> 实现可能会在 <code>erase</code> 操作中进行内存的重新分配（虽然大多数实现不会），这会导致所有迭代器失效，操作失效的迭代器会引发更严重的问题。</li></ol> 
<p>通过修改 <code>erase</code> 函数使其返回删除操作后下一个有效的迭代器，并在删除操作后更新迭代器来解决这些问题，可以确保程序正确运行。</p> 
<pre><code class="prism language-cpp">iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span>

    iterator begin <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> _finish<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span><span class="token punctuation">(</span>begin <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>begin<span class="token punctuation">;</span>
        begin<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    _finish<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过这种方式，我们可以确保在删除元素后，迭代器始终指向下一个有效的位置，从而避免迭代器失效导致的未定义行为和程序崩溃。</p> 
<pre><code class="prism language-cpp">iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    iterator begin <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> _finish<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token operator">*</span><span class="token punctuation">(</span>begin <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>begin<span class="token punctuation">;</span>
        begin<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _finish<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> pos<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">test_vector10</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除所有偶数</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>it <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>it<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p></p> 
<h4><a id="_713"></a>修改后的执行过程</h4> 
<ol><li>it 指向 1，不是偶数，it++。</li><li>it 指向 2，是偶数，调用 it = v.erase(it)，v 变为 [1, 3, 4, 4, 5]，it 指向 3。</li><li>it 指向 3，不是偶数，it++。</li><li>it 指向 4，是偶数，调用 it = v.erase(it)，v 变为 [1, 3, 4, 5]，it 指向 4。</li><li>it 指向 4，是偶数，调用 it = v.erase(it)，v 变为 [1, 3, 5]，it 指向 5。</li><li>it 指向 5，不是偶数，it++，此时 it 到达 v.end()，循环结束。</li></ol> 
<p>最终结果为 [1, 3, 5]，正确删除所有偶数，问题解决。</p> 
<p></p> 
<h2><a id="_727"></a>六：其他操作</h2> 
<p></p> 
<h3><a id="resize_729"></a>resize</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token comment">//如果没传实参，就是一个半缺省，缺省值就是一个匿名对象，那就看默认构造的是什么</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">reserve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>_finish<span class="token operator">&lt;</span>_start<span class="token operator">+</span>n<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
             <span class="token operator">*</span>_finish<span class="token operator">=</span>val<span class="token punctuation">;</span>
             <span class="token operator">++</span>_finish<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span><span class="token comment">//直接改变_finish  相当于删除</span>
        _finish<span class="token operator">=</span>_start<span class="token operator">+</span>n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>	

<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>为什么缺省参数要这样写？<br> 兼容模板<br> 在模板类中，成员函数需要适应各种类型的参数。默认构造函数 T() 适用于大多数类型，因此能够确保 resize 函数可以正确处理不同类型的对象。例如：<br> 对于基本类型（如 int），T() 将初始化为 0。<br> 对于自定义类型，如果提供了默认构造函数，T() 将调用该构造函数。<br> 对于指针类型，T() 将初始化为 nullptr。<br> 缺省参数的灵活性<br> 缺省参数 val = T() 允许用户在调用 resize 函数时选择性地提供填充值。如果用户没有提供，resize 函数将使用 T() 作为默认值，这样可以简化函数调用，并使代码更具通用性。</p> 
</blockquote> 
<p></p> 
<h3><a id="_761"></a>赋值运算符重载</h3> 
<p><strong>传统写法</strong>：</p> 
<pre><code class="prism language-cpp">        <span class="token comment">//1.开空间 2.拷贝数据 3。释放原有空间 4.指向新空间</span>
		vector <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>_start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">//_start 是一个指向动态分配数组首元素的指针。这个指针类似于数组的首地址，因此可以通过索引访问数组中的元素，就像使用数组一样</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
				_start <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
				_finish <span class="token operator">=</span> _start <span class="token operator">+</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				_endofstorage <span class="token operator">=</span> _start <span class="token operator">+</span> v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p><strong>现代写法</strong></p> 
<pre><code class="prism language-cpp">		<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_start<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_finish<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_endofstroage<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_endofstroage<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		vector <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre> 
<p>现代写法主要采用了一个名为“拷贝并交换”（copy and swap）的惯用法。这个方法简化了赋值运算符的实现，使代码更易于编写和维护，同时也提高了代码的异常安全性。让我们详细解释一下现代写法的思路以及为什么传参时不能使用引用。<br> </p> 
<h4><a id="_799"></a>现代写法的思路</h4> 
<p><strong>步骤解释：</strong></p> 
<ol><li><strong>构造临时对象</strong>：在赋值运算符中，传递的是一个值（而不是引用），这会导致在调用时先复制一份参数 <code>v</code>，然后在函数体内操作这个副本。这会自动调用 <code>vector</code> 的拷贝构造函数来创建一个临时对象。</li><li><strong>交换数据</strong>：使用 <code>swap</code> 函数交换当前对象和临时对象的内部数据指针。这样做的好处是交换操作只涉及指针交换（通常是常量时间操作），而不会涉及到实际数据的移动或拷贝。</li><li><strong>销毁临时对象</strong>：由于临时对象在函数退出时会被销毁，它会自动释放原对象的数据内存。<br> </li></ol> 
<h4><a id="_806"></a>为什么现代写法传参数时不能传引用？</h4> 
<p><strong>1. 异常安全性：</strong><br>现代写法通过值传递来确保异常安全性。在值传递的过程中，会调用拷贝构造函数。如果这个拷贝构造函数抛出异常，赋值操作会被终止，并且不会改变现有对象的状态。这样可以避免资源泄漏或部分更新对象状态的不一致问题。<br><strong>2. 确保交换的对象是副本：</strong><br>通过值传递，在进入赋值运算符函数时，会创建一个参数对象的副本。如果我们使用引用传递，我们将直接操作原对象，这可能导致未定义的行为。比如，如果 <code>v</code> 和 <code>this</code> 引用的是同一个对象，<code>swap(v)</code> 将会交换同一个对象的数据，导致不可预测的行为。<br><strong>3. 简化代码：</strong><br>这种方法使得赋值运算符实现更加简洁，只需关注如何交换对象的内部数据，而不需要手动管理内存分配和释放。这也减少了代码出错的机会。<br><strong>示例：</strong><br>假设我们有如下对象：</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v2 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span> <span class="token comment">// 调用赋值运算符</span>
</code></pre> 
<p>在赋值运算符内部，会创建一个 <code>v2</code> 的副本，然后 <code>v1</code> 的数据与这个副本进行交换。最终，<code>v1</code> 拥有 <code>v2</code> 的数据，临时副本在交换后被销毁，释放原 <code>v1</code> 的数据。<br> </p> 
<h4><a id="_816"></a>现代写法传参为什么不能传引用的具体原因：</h4> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">tmp</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建v的副本</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换当前对象与临时副本的数据</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果传递的是引用，那么传递的就是原对象。假设在某个操作中发生异常，可能导致原对象 <code>v</code> 状态不一致或资源泄漏。而通过值传递，创建一个临时副本，即使发生异常，临时副本的资源管理和释放都由其自身处理，原对象 <code>v</code> 不会受到影响。<br>综上所述，现代写法的主要思想是利用“拷贝并交换”技术，通过值传递参数来确保异常安全性、简化代码实现，并避免资源管理的复杂性。</p> 
<p></p> 
<h2><a id="_827"></a>七：完整代码</h2> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;assert.h&gt;</span></span>
<span class="token comment">//底层实现 +做题</span>
<span class="token comment">//02:22:12    题7. 电话号码字母组合OJ</span>



<span class="token keyword">namespace</span> myvector
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">vector</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">typedef</span> T<span class="token operator">*</span> iterator<span class="token punctuation">;</span>
		<span class="token keyword">typedef</span> <span class="token keyword">const</span> T<span class="token operator">*</span> const_iterator<span class="token punctuation">;</span>
		
		<span class="token comment">//无参默认构造</span>
		<span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
			<span class="token operator">:</span><span class="token function">_start</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_finish</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
			<span class="token punctuation">,</span> <span class="token function">_endofstorage</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>

		<span class="token punctuation">}</span>

		<span class="token comment">//析构</span>
		<span class="token operator">~</span><span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_start<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
				_start <span class="token operator">=</span> _finish <span class="token operator">=</span> _endofstorage <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

		<span class="token punctuation">}</span>


		<span class="token comment">//拷贝构造-两种写法</span>
		<span class="token comment">//1.</span>
		<span class="token comment">//vector(const vector&lt;T&gt;&amp; v)</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	_start = new T[v.capacity()];</span>
		<span class="token comment">//	memcpy(_start, v._start, v.size() * sizeof(T));</span>
		<span class="token comment">//	_finish = _start + v.size(); </span>
		<span class="token comment">//	....</span>
		<span class="token comment">//}</span>
		<span class="token comment">//2.</span>
		<span class="token comment">//v2(v1);</span>
		<span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">reserve</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先给v2 开和v1同样大的空间</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token comment">//取v里面的值依次赋值给e，加引用深拷贝，更好</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//赋值运算符重载</span>
		<span class="token comment">//传统写法：</span>
		<span class="token comment">//1.开空间 2.拷贝数据 3。释放原有空间 4.指向新空间</span>
		vector <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>_start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">//_start 是一个指向动态分配数组首元素的指针。这个指针类似于数组的首地址，因此可以通过索引访问数组中的元素，就像使用数组一样</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
				_start <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
				_finish <span class="token operator">=</span> _start <span class="token operator">+</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				_endofstorage <span class="token operator">=</span> _start <span class="token operator">+</span> v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//现代写法</span>
		<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_start<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_finish<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_endofstroage<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_endofstroage<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		vector <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//迭代器区间构造.</span>
<span class="token comment">//构造函数允许你用任何支持迭代器的区间（例如其他容器中的元素）来初始化一个 vector 对象。</span>
		<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">&gt;</span>
		<span class="token function">vector</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> last<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">++</span>first<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">带参构造</span>
		<span class="token function">vector</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">带参构造（int）</span>
		<span class="token function">vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//赋值-现代写法      </span>
		<span class="token comment">//v1=v3;</span>
		<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_start<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_finish<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>_endofstorage<span class="token punctuation">,</span> v<span class="token punctuation">.</span>_endofstorage<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">=</span>  <span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v<span class="token punctuation">)</span>   <span class="token comment">//为什么那里不能用引用，仔细想.02:06:13  </span>
		<span class="token punctuation">{<!-- --></span>							<span class="token comment">//如果用了引用就是 v1和v3交换，而不是v1和v3带来的那个临时变量v 交换</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		<span class="token comment">//普通对象的迭代器：提供对容器元素的读写访问。</span>
		<span class="token comment">//begin</span>
		iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _start<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//end</span>
		iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _finish<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//常量对象的迭代器：提供对容器元素的只读访问。</span>
		const_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _start<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		const_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _finish<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _finish <span class="token operator">-</span> _start<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		size_t <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> _endofstorage <span class="token operator">-</span> _start<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>



		<span class="token comment">//这里注意还是要判断n&gt;capacity，因为reserve 也可能单独使用，不能搞成缩容了</span>
		<span class="token comment">//void reserve</span>
		<span class="token keyword">void</span> <span class="token function">reserve</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				size_t old <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//保存当前大小,返回的size()是新的</span>
				T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//分配新的内存</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>_start<span class="token punctuation">)</span><span class="token comment">//复制旧数据到新内存</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">//memcpy(tmp, _start, old * sizeof(T));  memcpy会出问题，是一种浅拷贝test7(),02:03:28</span>
					<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> old<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
					<span class="token punctuation">{<!-- --></span>
						tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> _start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _start<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
<span class="token comment">//当你重新分配内存时，_finish 和 _endofstorage 的值会基于 size() 和 capacity() 更新</span>
				<span class="token comment">//更新指针</span>
				_start <span class="token operator">=</span> tmp<span class="token punctuation">;</span> 
				_finish <span class="token operator">=</span> _start <span class="token operator">+</span> old<span class="token punctuation">;</span> <span class="token comment">//将 _finish重新设置为旧大小的位置</span>
				<span class="token comment">//_finish=_start+size();   错的</span>
				<span class="token comment">//删除 old 后，_finish 指针将指向新容量的末尾，而不是当前元素的末尾。这意味着 _finish 会指向一个未初始化的位置，导致对向量的操作（如 push_back）出现未定义行为。</span>
				_endofstorage <span class="token operator">=</span> _start <span class="token operator">+</span> n<span class="token punctuation">;</span> <span class="token comment">// 将 _endofstorage 设置为新容量的位置</span>
				<span class="token comment">//_endofstorage=_start+capacity();</span>

			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>



		<span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> T val <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

		<span class="token punctuation">{<!-- --></span><span class="token comment">//三种情况假设有5个数据，容量为10.则有resize(3),resize(7),resize(14)三种情况</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">reserve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>_finish <span class="token operator">&lt;</span> _start <span class="token operator">+</span> n<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token operator">*</span>_finish <span class="token operator">=</span> val<span class="token punctuation">;</span>
					<span class="token operator">++</span>_finish<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{<!-- --></span>
				_finish <span class="token operator">=</span> _start <span class="token operator">+</span> n<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span> 
		<span class="token comment">//为什么缺省参数能这样写？</span>
		<span class="token comment">//兼容模板</span>
		<span class="token comment">//	在模板类中，成员函数需要适应各种类型的参数。默认构造函数 T() 适用于大多数类型，因此能够确保 resize 函数可以正确处理不同类型的对象。例如：</span>
		<span class="token comment">//	对于基本类型（如 int），T() 将初始化为 0。</span>
		<span class="token comment">//	对于自定义类型，如果提供了默认构造函数，T() 将调用该构造函数。</span>
		<span class="token comment">//	对于指针类型，T() 将初始化为 nullptr。</span>
		<span class="token comment">//缺省参数的灵活性</span>
		<span class="token comment">//	缺省参数 val = T() 允许用户在调用 resize 函数时选择性地提供填充值。如果用户没有提供，resize 函数将使用 T() 作为默认值，这样可以简化函数调用，并使代码更具通用性。</span>
		<span class="token comment">//  </span>


		<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_finish <span class="token operator">==</span> _endofstorage<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				size_t  newcapacity <span class="token operator">=</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
				<span class="token comment">//如果 capacity() == 0,则让 capacity()=4，</span>
				<span class="token comment">//如果 capacity() !=0 ,则让 capacity()=capacity()*2</span>
				<span class="token function">reserve</span><span class="token punctuation">(</span>newcapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token operator">*</span>_finish <span class="token operator">=</span> x<span class="token punctuation">;</span>
			<span class="token operator">++</span>_finish<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token operator">--</span>_finish<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		<span class="token comment">//vector 不支持头插  头删</span>

		<span class="token comment">//pos位置之前插入x</span>

		<span class="token comment">//下面这个代码多次运行会失效，原因：迭代器失效。 pos扩容后失效，及时更新即可。</span>
		<span class="token comment">//</span>
		<span class="token comment">//void insert(iterator pos, const T&amp; x)</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	assert(pos &gt;= _start &amp;&amp; pos &lt;= _finish); // 确保插入位置合法</span>
		<span class="token comment">//	if (_finish == _endofstorage) // 如果存储空间已满</span>
		<span class="token comment">//	{<!-- --></span>
		<span class="token comment">//		reserve(capacity() == 0 ? 4 : capacity() * 2); // 扩充存储空间</span>
		<span class="token comment">//	}</span>
		<span class="token comment">//	iterator end = _finish - 1; // 初始化end为最后一个元素的位置</span>
		<span class="token comment">//	while (end &gt;= pos) // 从后向前移动元素，直到插入位置</span>
		<span class="token comment">//	{<!-- --></span>
		<span class="token comment">//		*(end + 1) = *end; // 将元素向后移动一位</span>
		<span class="token comment">//		end--; // 继续向前移动</span>
		<span class="token comment">//	}</span>
		<span class="token comment">//	*pos = x; // 在插入位置插入新元素</span>
		<span class="token comment">//	++_finish; // 更新_finish指针</span>
		<span class="token comment">//}</span>


		<span class="token comment">/* 插入 */</span>
		<span class="token comment">//void insert(iterator pos, const T&amp; x) {<!-- --></span>
		<span class="token comment">//	assert(pos &gt;= _start);</span>
		<span class="token comment">//	assert(pos &lt;= _finish);</span>

		<span class="token comment">//	// 检查是否需要增容</span>
		<span class="token comment">//	if (_finish == _endofstorage) {<!-- --></span>
		<span class="token comment">//		// 扩容会导致迭代器失效，扩容需要更新一下 pos</span>
		<span class="token comment">//		size_t len = pos - _start;</span>
		<span class="token comment">//		reserve(capacity() == 0 ? 4 : capacity() * 2);</span>

		<span class="token comment">//		pos = _start + len;</span>
		<span class="token comment">//	}</span>

		<span class="token comment">//	// 移动数据</span>
		<span class="token comment">//	iterator end = _finish - 1;</span>
		<span class="token comment">//	while (end &gt;= pos) {<!-- --></span>
		<span class="token comment">//		*(end + 1) = *end;</span>
		<span class="token comment">//		end--;</span>
		<span class="token comment">//	}</span>

		<span class="token comment">//	// 插入数据</span>
		<span class="token comment">//	*pos = x;</span>
		<span class="token comment">//	_finish++;</span>
		<span class="token comment">//}</span>


		<span class="token comment">//解决： </span>
		<span class="token comment">/* 插入 */</span>
		iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">// 检查是否需要增容</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_finish <span class="token operator">==</span> _endofstorage<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">// 扩容会导致迭代器失效，扩容需要更新一下 pos</span>
				size_t len <span class="token operator">=</span> pos <span class="token operator">-</span> _start<span class="token punctuation">;</span>
				<span class="token function">reserve</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

				pos <span class="token operator">=</span> _start <span class="token operator">+</span> len<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 移动数据</span>
			iterator end <span class="token operator">=</span> _finish <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;=</span> pos<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token operator">*</span><span class="token punctuation">(</span>end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>end<span class="token punctuation">;</span>
				end<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>

			<span class="token comment">// 插入数据</span>
			<span class="token operator">*</span>pos <span class="token operator">=</span> x<span class="token punctuation">;</span>
			_finish<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> pos<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

			<span class="token comment">//注意是 从pos起始位置往后的所有数据，挪到pos+1上</span>
			<span class="token comment">//memmove(pos + 1, pos, sizeof(T) * (_finish - pos));</span>



		<span class="token comment">//删除pos位置数据</span>
		<span class="token comment">//void erase(iterator pos)</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	assert(pos &gt;= _start &amp;&amp; pos &lt; _finish);</span>
		<span class="token comment">//	memmove(pos, pos + 1, sizeof(T) * (_finish - pos));</span>
		<span class="token comment">//	--_finish;</span>
		<span class="token comment">//}</span>

		<span class="token comment">//void erase(iterator pos)</span>
		<span class="token comment">//{<!-- --></span>
		<span class="token comment">//	assert(pos &lt;= _finish);</span>
		<span class="token comment">//	assert(pos &gt;= _start);</span>
		<span class="token comment">//	iterator begin = pos + 1;</span>
		<span class="token comment">//	while (begin &lt; _finish)</span>
		<span class="token comment">//	{<!-- --></span>
		<span class="token comment">//		*(begin - 1) = *begin;</span>
		<span class="token comment">//		begin++;</span>
		<span class="token comment">//	}</span>
		<span class="token comment">//	_finish--;</span>
		<span class="token comment">//}</span>



		iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&gt;=</span> _start <span class="token operator">&amp;&amp;</span> pos <span class="token operator">&lt;</span> _finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
			iterator it <span class="token operator">=</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">&lt;</span> _finish<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token operator">*</span><span class="token punctuation">(</span>it <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>
				<span class="token operator">++</span>it<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			_finish<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> pos<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>



		<span class="token comment">//[]访问</span>
		<span class="token comment">//返回可修改的引用，支持读写操作</span>
		T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t pos<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> _start<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//支持读取操作但不能修改。</span>
		<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>size_t pos<span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> _start<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token comment">//返回类型为T&amp;有以下几个原因：</span>
<span class="token comment">//方便读写操作</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		iterator _start<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//这个成员变量指向动态数组中第一个实际存储元素的内存位置。[</span>
		iterator _finish<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//指向当前已填充元素的末尾，即最后一个有效元素的下一个位置。)</span>
		iterator _endofstorage<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//指向动态数组的末尾，即分配的内存块的最后一个位置。</span>
		<span class="token comment">// 1    2    3     4     空    空 </span>
		<span class="token comment">// ↑_start				↑	   ↑：_endofstorage</span>
		<span class="token comment">//					_finish</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>


	<span class="token keyword">void</span> <span class="token function">print_vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//此处为什么不能用范围for？   </span>
		<span class="token comment">//因为const vector&lt;int&gt;&amp; v 是const，迭代器也要用const的，所以要有const的begin和end</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span> 
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/8f/2f/bOrCtleo_o.png" alt="在这里插入图片描述"><br> 📜 [ 声明 ] 由于作者水平有限，本文有错误和不准确之处在所难免，<br> 本人也很想知道这些错误，恳望读者批评指正！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c5976b058e232a5e06b1f5a6566d85db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">单例模式-＞饿汉模式-＞懒汉模式-＞阻塞队列-＞模拟实现阻塞队列-＞生产者消费者模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10e1b1a3e6e1a52dd381a8b44b193948/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">丽江生态旅游元宇宙：探索虚拟世界的旅游新体验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>