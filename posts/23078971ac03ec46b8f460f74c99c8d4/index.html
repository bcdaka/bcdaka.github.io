<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】带你轻松掌握算法的复杂度 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/23078971ac03ec46b8f460f74c99c8d4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】带你轻松掌握算法的复杂度">
  <meta property="og:description" content="引入： 哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。
1.算法 什么是算法呢？算法是描述解决问题的方法。 算法一词最早出现在波斯数学家阿勒•花刺子密在公元825年（相当于我们的唐朝时代）所写的《印度数字算术》。如今普遍认可的算法的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。算法是数据结构的基础，用于操作和组织数据的各种方法和技巧。算法可以描述为一串指令，用于在有限时间内执行给定任务。在数据结构中，算法用于操作和处理不同类型的数据，例如数组、链表、树等。算法的设计和实现是数据结构的关键组成部分，可以通过选择合适的算法来提高代码的效率和性能。
2.算法的特性 算法具有五个基本特性：输入、输出、有穷性、确定性和可执行性。
2.1输入和输出 输入输出特性比较容易理解，输入是指算法的初始数据，输出是指算法运行结束后的结果。算法的输入和输出是比较重要的两个特性，算法的输入可以是各种不同类型的数据，例如数字、字符、布尔值、数组、链表等等。输入的特性决定了算法对数据的处理方式。有些算法只接受特定类型的输入，而有些算法可以处理多种不同类型的输入。算法的输出也可以是各种不同类型的数据，取决于算法的具体目标。输出可以是单个值，也可以是一组值，甚至是一个数据结构。输出的特性通常与输入和算法的目标密切相关。
2.2有穷性 有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。现实中经常会写出死循环的代码，这就是不满足有穷性。当然啦，在这里的有穷的概念并不是纯数学意义的，而是在实际应用中合理的、可以接受的“边界”。算法的有穷性是算法设计时必须考虑的重要因素之一。如果一个算法没有有穷性，即无法在有限的时间内停止执行，那么它就无法被应用于实际问题中。你说你写一个算法，计算机需要计算几十年，它也一定会结束，他就在数学的意义上是有穷了，那这样算法的意义也就不大了。
2.3确定性 确定性：算法的每一步骤都具有确定的意义，不会出现其他意义。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。在确定性算法中，每一步操作都是事先确定好的，不受随机因素的影响。这意味着，无论何时何地运行该算法，只要输入相同，输出结果也将是相同的。确定性算法的执行结果可以通过数学推导和逻辑推理来验证和预测，这使得算法的可靠性和正确性能得到保证。
2.4可行性 可行性：算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限次数结束。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。一个可行的算法应该具有较低的时间和空间复杂度，同时能够正确处理各种输入情况，并具备良好的可扩展性。
3.算法的效率 如何衡量一个算法的好坏呢？就比如计算斐波那契数列的代码：
long long Fib(int n) { if(n&lt;=2) return 1; return Fib(n-1)&#43;Fib(n-2); } 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？我们设计算法肯定是为了提高效率，这里的效率大都指算法在解决问题时所需的时间和空间资源的消耗。算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
我们在刷题时也常会看到时间复杂度和空间复杂度的限制，那么什么是时间复杂度和空间复杂度呢？
4.时间复杂度 4.1算法时间复杂度的定义 在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。请计算一下下面代码中的&#43;&#43;count运行了多少次：
void Func(int n) { int count=0; for(int i=0;i&lt;n;i&#43;&#43;) { for(int j=0;i&lt;n;j&#43;&#43;) { &#43;&#43;count; } } for(int k=0;k&lt;2*n;k&#43;&#43;) { &#43;&#43;count; } int a=10; while(a--) { &#43;&#43;count; } } 函数Func的执行次数和传入的参数n形成一个函数关系：
实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。
4.2大O渐进表示法 大O符号是用于描述函数渐进行为的数学符号。推导大O阶的方法：
用常数1取代运行时间中所有加法常数。在修改后的运行次数函数中，只保留最高阶项。如果最高阶项存在且系数不是1，则去除与这个阶项相乘的系数，得到的结果就是大O阶。 上面的代码使用了大O的渐进表示法后，函数Func的时间复杂度为O（）。通过上面我们会发现大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。另外有些算法的时间复杂度存在最好、平均和最坏情况：
最好情况：任意输入规模的最小运行次数平均情况：任意输入规模的期望运行次数最坏情况：任意输入规模的最大运行次数 在实际中一般情况关注的是算法的最坏运行情况，所以我们在一个数组中搜索一个数据时的时间复杂度为O(n)。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-07T12:11:54+08:00">
    <meta property="article:modified_time" content="2024-05-07T12:11:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】带你轻松掌握算法的复杂度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>引入：</h2> 
<blockquote> 
 <p>哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。</p> 
</blockquote> 
<h2>1.算法 </h2> 
<p>什么是算法呢？算法是描述解决问题的方法。 算法一词最早出现在波斯数学家阿勒•花刺子密在公元825年（相当于我们的唐朝时代）所写的《印度数字算术》。如今普遍认可的算法的定义是：<strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</strong>算法是数据结构的基础，用于操作和组织数据的各种方法和技巧。算法可以描述为一串指令，用于在有限时间内执行给定任务。在数据结构中，算法用于操作和处理不同类型的数据，例如数组、链表、树等。算法的设计和实现是数据结构的关键组成部分，可以通过选择合适的算法来提高代码的效率和性能。</p> 
<h2>2.算法的特性</h2> 
<p>算法具有五个基本特性：输入、输出、有穷性、确定性和可执行性。</p> 
<h3>2.1输入和输出</h3> 
<p>输入输出特性比较容易理解，输入是指算法的初始数据，输出是指算法运行结束后的结果。算法的输入和输出是比较重要的两个特性，算法的输入可以是各种不同类型的数据，例如数字、字符、布尔值、数组、链表等等。输入的特性决定了算法对数据的处理方式。有些算法只接受特定类型的输入，而有些算法可以处理多种不同类型的输入。算法的输出也可以是各种不同类型的数据，取决于算法的具体目标。输出可以是单个值，也可以是一组值，甚至是一个数据结构。输出的特性通常与输入和算法的目标密切相关。</p> 
<h3>2.2有穷性</h3> 
<p>有穷性：<strong>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</strong>现实中经常会写出死循环的代码，这就是不满足有穷性。当然啦，在这里的有穷的概念并不是纯数学意义的，而是在实际应用中合理的、可以接受的“边界”。算法的有穷性是算法设计时必须考虑的重要因素之一。如果一个算法没有有穷性，即无法在有限的时间内停止执行，那么它就无法被应用于实际问题中。你说你写一个算法，计算机需要计算几十年，它也一定会结束，他就在数学的意义上是有穷了，那这样算法的意义也就不大了。</p> 
<h3>2.3确定性</h3> 
<p>确定性：<strong>算法的每一步骤都具有确定的意义，不会出现其他意义</strong>。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。在确定性算法中，每一步操作都是事先确定好的，不受随机因素的影响。这意味着，无论何时何地运行该算法，只要输入相同，输出结果也将是相同的。确定性算法的执行结果可以通过数学推导和逻辑推理来验证和预测，这使得算法的可靠性和正确性能得到保证。</p> 
<h3>2.4可行性</h3> 
<p>可行性：<strong>算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限次数结束</strong>。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。一个可行的算法应该具有较低的时间和空间复杂度，同时能够正确处理各种输入情况，并具备良好的可扩展性。</p> 
<h2>3.算法的效率</h2> 
<p>如何衡量一个算法的好坏呢？就比如计算斐波那契数列的代码：</p> 
<pre><code class="language-cpp">long long Fib(int n)
{
  if(n&lt;=2)
    return 1;
  return Fib(n-1)+Fib(n-2);
}</code></pre> 
<p>斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？我们设计算法肯定是为了提高效率，这里的效率大都指算法在解决问题时所需的时间和空间资源的消耗。算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/18/b7/5UOrQQNn_o.png"></p> 
<p><br> 我们在刷题时也常会看到时间复杂度和空间复杂度的限制，那么什么是时间复杂度和空间复杂度呢？</p> 
<h2>4.时间复杂度</h2> 
<h3>4.1算法时间复杂度的定义</h3> 
<p>在计算机科学中，<strong>算法的时间复杂度是一个函数</strong>，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，<strong>算法中的基本操作的执行次数，为算法的时间复杂度。</strong>即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。请计算一下下面代码中的++count运行了多少次：</p> 
<pre><code class="language-cpp">void Func(int n)
{
  int count=0;
  for(int i=0;i&lt;n;i++)
   {
     for(int j=0;i&lt;n;j++)
      {
        ++count;
      }
   }
  for(int k=0;k&lt;2*n;k++)
   {
     ++count;
   }
  int a=10;
  while(a--)
   {
      ++count;
   }
}</code></pre> 
<p>函数Func的执行次数和传入的参数n形成一个函数关系：</p> 
<p style="text-align:center;"><strong><img alt="f(n)=n^{2}+2*n+10" class="mathcode" src="https://images2.imgbox.com/94/fc/qTZGrjVB_o.png"></strong></p> 
<p> 实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。</p> 
<h3>4.2大O渐进表示法</h3> 
<p>大O符号是用于描述函数渐进行为的数学符号。推导大O阶的方法：</p> 
<ol><li><strong>用常数1取代运行时间中所有加法常数。</strong></li><li><strong>在修改后的运行次数函数中，只保留最高阶项。</strong></li><li><strong>如果最高阶项存在且系数不是1，则去除与这个阶项相乘的系数，得到的结果就是大O阶。</strong></li></ol> 
<p>上面的代码使用了大O的渐进表示法后，函数Func的时间复杂度为O（<img alt="n^{2}" class="mathcode" src="https://images2.imgbox.com/a2/48/GCG1BNpz_o.png">）。通过上面我们会发现大O的渐进表示法去掉了那些对结果影响不大的项，简洁明了的表示出了执行次数。另外有些算法的时间复杂度存在最好、平均和最坏情况：</p> 
<ol><li><strong>最好情况：任意输入规模的最小运行次数</strong></li><li><strong>平均情况：任意输入规模的期望运行次数</strong></li><li><strong>最坏情况：任意输入规模的最大运行次数</strong></li></ol> 
<p> 在实际中一般情况关注的是算法的最坏运行情况，所以我们在一个数组中搜索一个数据时的时间复杂度为O(n)。</p> 
<h3>4.3常见的时间复杂度举例</h3> 
<h4>4.3.1常数阶</h4> 
<p>首先算一下下面代码的时间复杂度：</p> 
<pre><code class="language-cpp">void Func(int n)
{
  int count = 0;
  for (int k = 0; k &lt; 100; ++ k)
   {
     ++count;
   }
  printf("%d\n", count);
}</code></pre> 
<p>这个算法的运行次数函数f(n)=100。根据我们推导大O阶的方法，第一步就是把常数项100改为1。在保留最高阶项时发现，他根本就没有最高阶项，所以这个算法的时间复杂度是O(1)。这种与问题的大小（n的大小）无关，执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。不管这个常数是多少，我们都记作O(1)。对于分支结构而言，无论真假，执行次数都是恒定的，不会随着传入的参数的值变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是O(1)。<strong>常数阶时间复杂度的特点是算法中只包含固定数量的操作，无论数据的规模如何变化，都不会对算法的执行时间造成影响。</strong></p> 
<h4>4.3.2线性阶</h4> 
<p>先来算一下下面函数的时间复杂度：</p> 
<pre><code class="language-cpp">void Func(int N)
{
  int count = 0;
  for (int k = 0; k &lt; 2 * N ; ++ k)
   {
     ++count;
   }
  int M = 10;
  while (M--)
   {
     ++count;
   }
  printf("%d\n", count);
}</code></pre> 
<p>这个算法的运行次数函数f(n)=2*n。根据我们推导的大O阶的方法，保留最高项的时候，我们发现它的最高项是n，这时候我们要去除这个最高项之前的系数，所以这个函数的时间复杂度是O(n)。<strong>线性阶时间复杂度（O(n)）是指算法的执行时间随着输入规模的增加而线性增加的情况。也就是说，算法的执行时间与问题规模n成正比。当算法的时间复杂度为线性阶时，随着输入规模n的增加，算法的执行时间将按照一个固定的速度增长。</strong>我们再来算一下下面这段代码的时间复杂度：</p> 
<pre><code class="language-cpp">void Func(int N, int M)
{
  int count = 0;
  for (int k = 0; k &lt; M; ++ k)
   {
    ++count;
   }
  for (int k = 0; k &lt; N ; ++ k)
   {
    ++count;
   }
  printf("%d\n", count);
}</code></pre> 
<p>执行了M+N次，又因为有两个未知数，所以函数Func的时间复杂度是O(M+N)。</p> 
<h4>4.3.3对数阶</h4> 
<p>老样子，先算一下下面这段代码的时间复杂度：</p> 
<pre><code class="language-cpp">void Func(int n)
{
  int count=1;
  while(count&lt;n)
   {
     count=count*2;
   }
}</code></pre> 
<p>由于每次count扩大2倍之后，就距离n更近了一步，也就是说，有多少个2相乘之后大于n，就会退出循环。由<img alt="2^{x}=n" class="mathcode" src="https://images2.imgbox.com/96/5e/6YYMCMtT_o.png">求解之后得到<img alt="x=\log n" class="mathcode" src="https://images2.imgbox.com/68/54/GYim5qwX_o.png">，所以这个函数的时间复杂度是O(<img alt="\log n" class="mathcode" src="https://images2.imgbox.com/6e/1c/E0CpeiSN_o.png">)。<strong>对数阶时间复杂度（O(log n)）是表示算法的时间复杂度随输入规模n的增长而以对数的速度增加。</strong>这里大家是不是好奇我为什么要写<img alt="\log n" class="mathcode" src="https://images2.imgbox.com/94/19/Pa1DAGJC_o.png">而不是<img alt="\log_{2}n" class="mathcode" src="https://images2.imgbox.com/b8/d1/piRWVy1x_o.png">呢？<strong>在对数阶时间复杂度中，通常使用logn来表示，其中log表示以2为底的对数。这是因为在计算机科学中，对数底数通常是2，因为计算机内部的数据是以二进制表示的。因此，当我们分析算法的时间复杂度时，以2为底的对数更为常见和方便。另外，对数底数的选择并不会改变时间复杂度的增长趋势，因此我们可以忽略底数，直接用logn来表示对数阶时间复杂度。</strong>二分查找是常见的对数阶时间复杂度的算法。</p> 
<h4>4.3.4平方阶</h4> 
<p>算一下下面这段代码的时间复杂度：</p> 
<pre><code class="language-cpp">void Func(int n)
{
  int i,j;
  for(i=0;i&lt;n;i++)
   {
     for(j=0;j&lt;n;j++)
       ++count;
   }
}</code></pre> 
<p>这是一个循环嵌套，它的内循环我们可以轻松算出它的时间复杂度为O(n)。而对于外层的循环，不过是内部的循环语句再循环n次，所以这段代码的时间复杂度为O(<img alt="n^{_{2}}" class="mathcode" src="https://images2.imgbox.com/c0/27/MmtQIEEk_o.png">)。如果外循环的次数变成了m，时间复杂度就是O(m*n)。所以我们可以得出结论：<strong>循环的时间复杂度等于循环体的时间复杂度乘以该循环运行的次数。</strong>那么下面这个嵌套循环的时间复杂度是多少呢？</p> 
<pre><code class="language-cpp">void Func(int n)
{
  int i,j;
  for(i=0;i&lt;n;i++)
   {
     for(j=i;j&lt;n;j++)
       ++count;
   }
}</code></pre> 
<p>当i=0时，内循环执行了n次，当i=1时，内循环执行了n-1次....当i=n-1时，内循环执行了1次。所以总的执行次数为：</p> 
<p style="text-align:center;"><img alt="n+(n-1)+(n-2)+.....+1=\frac{n(n+1)}{2}=\frac{n^{2}}{2}+\frac{n}{2}" class="mathcode" src="https://images2.imgbox.com/9c/16/LI1rAZZs_o.png"></p> 
<p>用我们推导大O阶的方法，没有常数项不考虑，接着只保留最高阶项<img alt="\frac{n^{2}}{2}" class="mathcode" src="https://images2.imgbox.com/d3/48/v8bzaiPS_o.png">，然后去除与这个项相乘的常数，最终这段代码的时间复杂度是O(<img alt="n^{2}" class="mathcode" src="https://images2.imgbox.com/63/a3/RHN1TG7P_o.png">) 。在平方阶时间复杂度的算法中，通常会存在两重嵌套的循环。每当遍历一次外层循环，内层循环都要遍历一次。由于平方阶的时间复杂度增长非常快，当输入规模较大时，会导致算法的执行时间非常长。因此，尽量避免使用平方阶的算法，或者在实际使用时进行优化。</p> 
<h4>4.3.4常见的时间复杂度</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:175px;">函数执行次数</td><td style="width:223px;">阶</td><td style="width:201px;">非正式术语</td></tr><tr><td style="width:175px;">520</td><td style="width:223px;">O(1)</td><td style="width:201px;">常数阶</td></tr><tr><td style="width:175px;">3n+4</td><td style="width:223px;">O(n)</td><td style="width:201px;">线性阶</td></tr><tr><td style="width:175px;">3n^2+5n+9</td><td style="width:223px;">O(n^2)</td><td style="width:201px;">平方阶</td></tr><tr><td style="width:175px;">3logn+2</td><td style="width:223px;">O(logn)</td><td style="width:201px;">对数阶</td></tr><tr><td style="width:175px;">n+4n*longn+5</td><td style="width:223px;">O(n*logn)</td><td style="width:201px;">n*logn阶</td></tr><tr><td style="width:175px;">n^3+3n+4</td><td style="width:223px;">O(n^3)</td><td style="width:201px;">立方阶</td></tr><tr><td style="width:175px;">2^n</td><td style="width:223px;">O(2^n)</td><td style="width:201px;">指数阶</td></tr></tbody></table> 
<h2>5.空间复杂度</h2> 
<p>空间的复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少空间，因为这个也没太大意义，所以<u><strong>空间复杂度算的是变量的个数。</strong></u>空间复杂度计算规则基本跟实践复杂度类似，也使用大O渐进表示法。通常我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常指的都是时间复杂度。在算法中，有时可以通过使用更多的空间来换取更高效的时间复杂度。这种做法被称为空间换时间。一种常见的应用是使用额外的数据结构来存储一些中间结果，以便在后续的计算中可以更快地访问。空间换时间的做法可以在某些情况下显著提高算法的性能，但也会增加内存消耗。因此，在应用空间换时间时需要权衡时间和空间的需求，并选择合适的策略。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/311cf9672b6fd8288da81a7be27cb89d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Springai入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/109588d6952bb4b9620553e3607d5e8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024年再见，Java 8！Java 17 终于免费了，史上最快的 JDK。。(1)，跟谁学java技术面试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>