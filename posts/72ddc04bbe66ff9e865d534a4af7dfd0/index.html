<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【练习】链表题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/72ddc04bbe66ff9e865d534a4af7dfd0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【练习】链表题">
  <meta property="og:description" content="🎥 个人主页：Dikz12🔥个人专栏：算法(Java)📕格言：吾愚多不敏，而愿加学欢迎大家👍点赞✍评论⭐收藏 目录
两数相加 题目描述 题解 代码实现 两两交换链表中的节点 题目描述 题解
代码实现 重排链表
题目描述
​编辑 题解
代码实现
合并 K 个升序链表
题目描述 题解
代码实现
链表常用技巧 1. 画图. -&gt; 更加直观和形象.
2. 引入虚拟头结点.
更便于处理边界情况.更方便对于链表的操作. 3. 快慢双指针.
判环找链表中环的入口找链表中倒数第n个结点 链表中常用操作 1. 头插. -&gt; 逆序链表
2. 尾插.
两数相加 源自leetcode的第二题，如果大家是按顺序刷题的话，可能在第二题就怀疑人生了.
题目描述 题解 解法：模拟两数相加过程即可. 两个链表都是逆序存储数字的，即两个链表的个位数、⼗位数等都已经对应，可以直接相加。（如果不是逆序链表，那就需要手动逆序了） 在相加过程中，我们要注意是否产⽣进位，产⽣进位时需要将进位和链表数字⼀同相加。如果产⽣进 位的位置在链表尾部，即答案位数⽐原链表位数⻓⼀位，还需要再 new ⼀个结点储存最⾼位。
代码实现 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode cur1 = l1, cur2 = l2; //指向两个链表的头节点 ListNode newHead = new ListNode(0); //虚拟头节点 ListNode prev = newHead; //进行尾插操作的指针 int ret = 0; //表示进位 while(cur1 !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T19:30:08+08:00">
    <meta property="article:modified_time" content="2024-07-20T19:30:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【练习】链表题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="255" src="https://images2.imgbox.com/43/95/7RavsCvQ_o.png" width="595"></p> 
<ul><li>🎥 个人主页：<a href="https://blog.csdn.net/m0_65465009?type=blog" title="Dikz12">Dikz12</a></li><li>🔥个人专栏：<a href="https://blog.csdn.net/m0_65465009/category_12612113.html?spm=1001.2014.3001.5482" title="算法(Java)">算法(Java)</a></li><li>📕格言：吾愚多不敏，而愿加学</li><li>欢迎大家👍点赞✍评论⭐收藏</li></ul> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%C2%A0" rel="nofollow">两数相加 </a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%C2%A0" rel="nofollow">题目描述 </a></p> 
<p id="%E9%A2%98%E8%A7%A3%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3%C2%A0" rel="nofollow">题解 </a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">代码实现 </a></p> 
<p id="%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0" rel="nofollow">两两交换链表中的节点 </a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%C2%A0" rel="nofollow">题目描述 </a></p> 
<p id="%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3" rel="nofollow">题解</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">代码实现 </a></p> 
<p id="%C2%A0%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%C2%A0%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8" rel="nofollow"> 重排链表</a></p> 
<p id="%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0" rel="nofollow"> 题目描述</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E9%A2%98%E8%A7%A3" rel="nofollow">​编辑 题解</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow"> 代码实现</a></p> 
<p id="%C2%A0%C2%A0%E5%90%88%E5%B9%B6%20K%20%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%C2%A0%C2%A0%E5%90%88%E5%B9%B6%20K%20%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">  合并 K 个升序链表</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%C2%A0" rel="nofollow">题目描述 </a></p> 
<p id="%C2%A0%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%C2%A0%E9%A2%98%E8%A7%A3" rel="nofollow"> 题解</a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow"> 代码实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><strong>链表常用技巧 </strong></p> 
<p>1. 画图. -&gt; 更加直观和形象.<br> 2. 引入虚拟头结点.</p> 
<ul><li>更便于处理边界情况.</li><li>更方便对于链表的操作.</li></ul> 
<p>3. 快慢双指针.</p> 
<ul><li>判环</li><li>找链表中环的入口</li><li>找链表中倒数第n个结点</li></ul> 
<p><strong>链表中常用操作 </strong></p> 
<p>1. 头插. -&gt; 逆序链表</p> 
<p>2. 尾插.</p> 
<h2 id="%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%C2%A0"><a class="link-info" href="https://leetcode.cn/problems/add-two-numbers/" rel="nofollow" title="两数相加 ">两数相加 </a></h2> 
<blockquote> 
 <p> 源自leetcode的第二题，如果大家是按顺序刷题的话，可能在第二题就怀疑人生了.</p> 
 <p class="img-center"><img alt="" height="145" src="https://images2.imgbox.com/13/3e/Dayp6QXk_o.png" width="208"></p> 
</blockquote> 
<h3 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%C2%A0">题目描述 </h3> 
<p><img alt="" height="169" src="https://images2.imgbox.com/d8/10/dnZtvCXt_o.png" width="835"> <img alt="" class="left" height="320" src="https://images2.imgbox.com/f9/69/J8hoUief_o.png" width="440"></p> 
<h3 id="%E9%A2%98%E8%A7%A3%C2%A0">题解 </h3> 
<p>解法：<span style="color:#fe2c24;">模拟两数相加过程即可. </span></p> 
<p><span style="color:#1f2329;">两个链表都是</span><span style="color:#fe2c24;">逆序</span><span style="color:#1f2329;">存储数字的，即两个链表的个位数、⼗位数等都已经对应，可以直接相加。（如果不是逆序链表，那就需要手动逆序了）</span> <span style="color:#1f2329;">在相加过程中，我们要注意是否产⽣进位，产⽣进位时需要将进位和链表数字⼀同相加。如果产⽣进 位的位置在链表尾部，即答案位数⽐原链表位数⻓⼀位，还需要再 new </span><span style="color:#1f2329;">⼀个结点储存最⾼位。</span></p> 
<p class="img-center"><img alt="" height="490" src="https://images2.imgbox.com/36/a2/0QscCbw2_o.jpg" width="578"></p> 
<h3 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0">代码实现 </h3> 
<pre><code class="hljs">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {

        ListNode cur1 = l1, cur2 = l2; //指向两个链表的头节点
        ListNode newHead = new ListNode(0); //虚拟头节点
        ListNode prev = newHead; //进行尾插操作的指针
        int ret = 0; //表示进位

        while(cur1 != null || cur2 != null || ret != 0) {
            if(cur1 != null) {
                ret +=  cur1.val;
                cur1 = cur1.next;
            }
            if(cur2 != null) {
                ret += cur2.val;
                cur2 = cur2.next;
            }
            prev.next = new ListNode(ret % 10);
            prev = prev.next;
            ret /= 10;
        }
        return newHead.next;
    }</code></pre> 
<h2 id="%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%C2%A0" style="background-color:transparent;"><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" rel="nofollow" title="两两交换链表中的节点">两两交换链表中的节点</a> </h2> 
<h3>题目描述 </h3> 
<p><img alt="" height="392" src="https://images2.imgbox.com/93/0f/GoPE6dvu_o.png" width="831"> </p> 
<h3 id="%E9%A2%98%E8%A7%A3">题解</h3> 
<p><span style="color:#fe2c24;">解法一: </span>模拟. -&gt; 画图</p> 
<p class="img-center"><img alt="" height="647" src="https://images2.imgbox.com/95/85/VnubAUjV_o.jpg" width="619"></p> 
<p>解法二：<span style="color:#fe2c24;">递归.</span> </p> 
<ol><li><span style="color:#1f2329;">递归函数的含义：交给你⼀个链表，将这个链表两两交换⼀下，然后返回交换后的头结点； </span></li><li><span style="color:#1f2329;">函数体：先去处理⼀下第⼆个结点往后的链表，然后再把当前的两个结点交换⼀下，连接上后⾯处</span><span style="color:#1f2329;">理后的链表； </span></li><li><span style="color:#1f2329;">递归出⼝：当前结点为空或者当前只有⼀个结点的时候，不⽤交换，直接返回。</span></li></ol> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/96/f2/R0EiR6yU_o.jpg" width="1200"> </p> 
<h3>代码实现 </h3> 
<pre><code class="hljs">    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode newHead = new ListNode(0); // 虚拟头节点
        ListNode prev = newHead;
        ListNode cur = head;
        ListNode next = cur.next;
        ListNode nnext = next.next;
        //模拟循环过程
        while(cur != null &amp;&amp; next != null) {
            //交换节点
            cur.next = nnext;
            next.next = cur;
            prev.next = next;
            //修改指针
            prev = cur;
            cur = nnext;
            if(cur != null) {
                next = cur.next;
            }
            if(next != null)
            nnext = next.next;
        }
        return newHead.next;
    }</code></pre> 
<p>递归代码： </p> 
<pre><code class="hljs">    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode tmp = swapPairs(head.next.next);
        ListNode cur = head.next;
        cur.next = head;
        head.next = tmp;
        return cur;
    }</code></pre> 
<h2 id="%C2%A0%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"> <a href="https://leetcode.cn/problems/reorder-list/" rel="nofollow" title="重排链表">重排链表</a></h2> 
<h3 id="%C2%A0%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"> 题目描述</h3> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E9%A2%98%E8%A7%A3"><img alt="" height="257" src="https://images2.imgbox.com/74/24/V7FYrhr7_o.png" width="807"> 题解</h3> 
<div> 
 <span style="color:#1f2329;">算法思路： </span> 
</div> 
<ol><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">找中间节点； </span></li><li><span style="color:#1f2329;">中间部分往后的逆序； </span></li><li><span style="color:#1f2329;">合并两个链表 </span></li></ol> 
<p class="img-center"><img alt="" height="570" src="https://images2.imgbox.com/67/8e/wy7tdFx2_o.jpg" width="522"></p> 
<h3 id="%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"> 代码实现</h3> 
<pre><code class="hljs">    public void reorderList(ListNode head) {
        // 特殊情况
        if(head == null || head.next == null || head.next.next == null) {
            return ;
        }
        ListNode fast = head;
        ListNode slow = head;
        // 1.找中间节点
        while(fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // 2.后面部分逆序(头插法)
        ListNode newHead = new ListNode(0);
        ListNode cur = slow.next;
        slow.next = null; //分割两个链表
        while(cur != null) {
            ListNode curNext = cur.next;
            cur.next = newHead.next;
            newHead.next = cur;
            cur = curNext;
        }
        // 3.合并两个链表
        ListNode cur1 = head, cur2 = newHead.next;
        ListNode head2 = new ListNode(0);
        ListNode prev = head2;
        while(cur1 != null) {
            prev.next = cur1;
            prev = prev.next;
            cur1 = cur1.next;
            if(cur2 != null) {
                prev.next = cur2;
                prev = prev.next;
                cur2 = cur2.next;
            }
        }
    }</code></pre> 
<h2 id="%C2%A0%C2%A0%E5%90%88%E5%B9%B6%20K%20%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8" style="background-color:transparent;">  <a href="https://leetcode.cn/problems/merge-k-sorted-lists/" rel="nofollow" title="合并 K 个升序链表">合并 K 个升序链表</a></h2> 
<h3>题目描述 </h3> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/d1/f4/79fVUYeL_o.png" width="389"></p> 
<h3 id="%C2%A0%E9%A2%98%E8%A7%A3"> 题解</h3> 
<p><strong>解法一：</strong><span style="color:#fe2c24;"> 利用优先级队列做优化. </span></p> 
<div> 
 <span style="color:#1f2329;">把所有的头结点放进⼀个⼩根堆中，这样就能快速的找到每次 </span> 
 <span style="color:#1f2329;">K </span> 
 <span style="color:#1f2329;">个链表中，最⼩的元素是哪 </span> 
</div> 
<div> 
 <span style="color:#1f2329;">个。</span> 
</div> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/83/cf/EMtYbdAx_o.jpg" width="1200"></p> 
<blockquote> 
 <p>还有一种解法就是用递归的方式，就跟归并差不多. </p> 
</blockquote> 
<h3> 代码实现</h3> 
<pre><code class="hljs">    public ListNode mergeKLists(ListNode[] lists) {
        //1.创建一个小根堆
        PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;((head1,head2) -&gt; head1.val - head2.val);

        //2.将所有的头结点放到小根堆中
        for(ListNode head : lists) {
            if(head != null) {
                heap.offer(head);
            }
        }
        //3. 合并链表
        ListNode newHead = new ListNode(0);
        ListNode cur = newHead;
        while(!heap.isEmpty()) {
            ListNode tmp = heap.poll();
            cur.next = tmp;
            cur = tmp;
            //把tmp的下一个节点放到小根堆中
            if(tmp.next != null) {
                heap.offer(tmp.next);
            }
        }
        return newHead.next;
    }</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8153edbaceee49de2e53e1175a768fd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中的Heap（堆）（如果想知道Java中有关堆的知识点，那么只看这一篇就足够了！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c90fa055511f5f65ab74f976029c7a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Perl并发编程秘籍：线程间通信的艺术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>