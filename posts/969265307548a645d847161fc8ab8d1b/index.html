<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c# 开发串口调试助手 Visual Studio 2019 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/969265307548a645d847161fc8ab8d1b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c# 开发串口调试助手 Visual Studio 2019">
  <meta property="og:description" content="一、串口调试工具作用 串口调试助手是用于在开发、测试和调试串口通信应用程序时进行串口数据的监视和交互的工具。它通常具有以下功能：
1. 串口参数设置：允许用户设置串口的波特率、数据位、校验位、停止位等参数。
2. 串口连接管理：允许用户打开、关闭串口连接。
3. 数据发送：允许用户手动输入或从文件中加载数据，并通过串口发送到目标设备。
4. 数据接收：显示从串口接收到的数据，并支持数据的解析和显示。
5. 数据记录：允许用户将接收到的数据保存到文件中以供后续分析和查看。
6. 数据分析：提供数据格式化、解析和显示的功能，便于用户理解和分析串口通信数据。
7. 数据监视：实时监视串口通信数据，包括发送和接收的数据量、速率等信息。
8. 自定义操作：支持用户自定义脚本或命令，以便执行特定的串口操作或测试。
总的来说，串口调试助手是串口通信开发过程中的一个重要辅助工具，能够帮助开发人员进行串口通信的测试、调试和分析。
二、开发工具 语言：C# 开发环境：Visual Studio 2019
三、开发步骤 1. 界面设计
- 使用 Windows Forms 或 WPF 进行界面设计。
- 设计包含串口参数设置、数据发送、数据接收、数据显示等功能的用户界面。
2. 串口通信
- 使用 `System.IO.Ports` 命名空间中的 `SerialPort` 类进行串口通信。
- 实现串口的打开、关闭、参数设置等功能。
- 监听串口数据的接收事件，并进行相应的处理。
3. 数据发送
- 提供文本框或其他输入控件，允许用户手动输入待发送的数据。
- 实现发送按钮点击事件，将数据通过串口发送。
4. 数据接收与显示
- 使用串口的 DataReceived 事件来监听串口数据的接收。
- 将接收到的数据显示在界面上的文本框或数据显示控件中。
- 可以对接收到的数据进行解析、格式化，方便用户阅读。
5. 数据记录与保存
- 提供数据记录功能，允许用户将接收到的数据保存到文件中。
- 实现保存按钮点击事件，将接收到的数据写入到指定的文件中。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-11T10:59:52+08:00">
    <meta property="article:modified_time" content="2024-04-11T10:59:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c# 开发串口调试助手 Visual Studio 2019</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E4%B8%80%E3%80%81%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%9C%E7%94%A8">一、串口调试工具作用</h4> 
<p>串口调试助手是用于在开发、测试和调试串口通信应用程序时进行串口数据的监视和交互的工具。它通常具有以下功能：</p> 
<p>1. 串口参数设置：允许用户设置串口的波特率、数据位、校验位、停止位等参数。<br> 2. 串口连接管理：允许用户打开、关闭串口连接。<br> 3. 数据发送：允许用户手动输入或从文件中加载数据，并通过串口发送到目标设备。<br> 4. 数据接收：显示从串口接收到的数据，并支持数据的解析和显示。<br> 5. 数据记录：允许用户将接收到的数据保存到文件中以供后续分析和查看。<br> 6. 数据分析：提供数据格式化、解析和显示的功能，便于用户理解和分析串口通信数据。<br> 7. 数据监视：实时监视串口通信数据，包括发送和接收的数据量、速率等信息。<br> 8. 自定义操作：支持用户自定义脚本或命令，以便执行特定的串口操作或测试。</p> 
<p>总的来说，串口调试助手是串口通信开发过程中的一个重要辅助工具，能够帮助开发人员进行串口通信的测试、调试和分析。</p> 
<h4 id="%E4%BA%8C%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">二、开发工具</h4> 
<p>语言：C#        开发环境：Visual Studio 2019</p> 
<h4 id="%E4%B8%89%E3%80%81%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4">三、开发步骤</h4> 
<p>1. 界面设计<br> - 使用 Windows Forms 或 WPF 进行界面设计。<br> - 设计包含串口参数设置、数据发送、数据接收、数据显示等功能的用户界面。</p> 
<p>2. 串口通信<br> - 使用 `System.IO.Ports` 命名空间中的 `SerialPort` 类进行串口通信。<br> - 实现串口的打开、关闭、参数设置等功能。<br> - 监听串口数据的接收事件，并进行相应的处理。</p> 
<p>3. 数据发送<br> - 提供文本框或其他输入控件，允许用户手动输入待发送的数据。<br> - 实现发送按钮点击事件，将数据通过串口发送。</p> 
<p>4. 数据接收与显示<br> - 使用串口的 DataReceived 事件来监听串口数据的接收。<br> - 将接收到的数据显示在界面上的文本框或数据显示控件中。<br> - 可以对接收到的数据进行解析、格式化，方便用户阅读。</p> 
<p>5. 数据记录与保存<br> - 提供数据记录功能，允许用户将接收到的数据保存到文件中。<br> - 实现保存按钮点击事件，将接收到的数据写入到指定的文件中。</p> 
<p>6. 其他功能<br> - 支持设置串口的波特率、数据位、校验位、停止位等参数。<br> - 提供数据的清除、停止接收、清空接收缓存等功能。<br> - 支持用户自定义脚本或命令，执行特定的串口操作。</p> 
<h4 id="%E5%9B%9B%E3%80%81%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B">四、开发流程</h4> 
<h5 id="1.%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B">1.创建工程</h5> 
<p><img alt="" height="1039" src="https://images2.imgbox.com/b8/e1/q3JOyxyX_o.png" width="1200"></p> 
<h5 id="2.%E6%B7%BB%E5%8A%A0Panel%E6%8E%A7%E4%BB%B6">2.添加Panel控件</h5> 
<p>①.添加容器Panel,将页面分为6个页面，分别为串口配置窗口、接收区配置窗口、发送区配置窗口、接收数据显示窗口、发送数据编辑窗口、数据接收发送字节大小窗口。</p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/d6/dc/7eoGZaaQ_o.png" width="895"></p> 
<p>②.实际运行效果，你会发现并没有边界线，这样后续视觉效果就会很差。</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/b0/c8/eOTvRtOG_o.png" width="752"></p> 
<p>将添加边界线程序加在对应容器函数里面即可，记得修改panelx,x对应的是容器编号。</p> 
<pre><code>ControlPaint.DrawBorder(e.Graphics, panel1.ClientRectangle,
            Color.Black, 1, ButtonBorderStyle.Solid, //左边
            Color.Black, 1, ButtonBorderStyle.Solid, //上边
            Color.Black, 1, ButtonBorderStyle.Solid, //右边
            Color.Black, 1, ButtonBorderStyle.Solid);//底边</code></pre> 
<p>加上边界线程序效果如下: </p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/78/56/vYvCOHrq_o.png" width="752"></p> 
<h5 id="3.%E6%B7%BB%E5%8A%A0%E6%8E%A7%E4%BB%B6label%E5%92%8CcomboBox">3.添加控件label和comboBox</h5> 
<p><img alt="" height="538" src="https://images2.imgbox.com/4e/de/0qoxawJ9_o.png" width="847"></p> 
<p>添加下拉数据：</p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/a7/21/pqi5mvrC_o.png" width="1200"></p> 
<p>同理在数据位下拉列表里面添加5、6、7、8；在校验位下拉列表里面添加无、奇校验、偶校验；在停止位下拉列表里面添加1、1.5、2；</p> 
<h5 id="4.%E6%B7%BB%E5%8A%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A8%8B%E5%BA%8F">4.添加初始化程序</h5> 
<p>双击窗口，在Form2_Load函数里面添加初始化程序</p> 
<pre><code>private void Form2_Load(object sender, EventArgs e)
        {
            string[] ports = System.IO.Ports.SerialPort.GetPortNames();//获取电脑上可用串口号
            comboBox1.Items.AddRange(ports);//给comboBox1添加数据
            comboBox1.SelectedIndex = comboBox1.Items.Count &gt; 0 ? 0 : -1;//如果里面有数据,显示第0个

            comboBox2.Text = "115200";/*默认波特率:115200*/
            comboBox3.Text = "1";/*默认停止位:1*/
            comboBox4.Text = "8";/*默认数据位:8*/
            comboBox5.Text = "无";/*默认奇偶校验位:无*/
        }</code></pre> 
<h5 id="5.%E6%B7%BB%E5%8A%A0%E4%B8%B2%E5%8F%A3%E6%8E%A7%E4%BB%B6">5.添加串口控件</h5> 
<p><img alt="" height="851" src="https://images2.imgbox.com/68/09/2skWpA9q_o.png" width="1200"></p> 
<p>6.添加打开串口控件程序</p> 
<p>双击打开串口按键，添加程序</p> 
<pre><code>private void button1_Click(object sender, EventArgs e)
        {
            if (button1.Text == "打开串口")
            {//如果按钮显示的是打开串口
                try
                {//防止意外错误
                    serialPort1.PortName = comboBox1.Text;//获取comboBox1要打开的串口号
                    serialPort1.BaudRate = int.Parse(comboBox2.Text);//获取comboBox2选择的波特率
                    serialPort1.DataBits = int.Parse(comboBox4.Text);//设置数据位
                    /*设置停止位*/
                    if (comboBox3.Text == "1") { serialPort1.StopBits = StopBits.One; }
                    else if (comboBox3.Text == "1.5") { serialPort1.StopBits = StopBits.OnePointFive; }
                    else if (comboBox3.Text == "2") { serialPort1.StopBits = StopBits.Two; }
                    /*设置奇偶校验*/
                    if (comboBox5.Text == "无") { serialPort1.Parity = Parity.None; }
                    else if (comboBox5.Text == "奇校验") { serialPort1.Parity = Parity.Odd; }
                    else if (comboBox5.Text == "偶校验") { serialPort1.Parity = Parity.Even; }

                    serialPort1.Open();//打开串口
                    button1.BackColor = Color.FromArgb(194, 178, 128);
                    button1.Text = "关闭串口";//按钮显示关闭串口
                }
                catch (Exception err)
                {
                    MessageBox.Show("打开失败" + err.ToString(), "提示!");//对话框显示打开失败
                }
            }
            else
            {//要关闭串口
                try
                {//防止意外错误
                    serialPort1.Close();//关闭串口
                }
                catch (Exception) { }
                button1.Text = "打开串口";//按钮显示打开
                button1.BackColor = Color.Transparent;

            }
        }</code></pre> 
<p>运行效果如下图</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/3d/99/xeB2SMd4_o.png" width="752"></p> 
<h5 id="6.%E6%B7%BB%E5%8A%A0%E6%8E%A5%E6%94%B6%E5%8C%BA%E6%8E%A7%E4%BB%B6textBox%EF%BC%8C%E5%8B%BE%E9%80%89MultiLine%EF%BC%8C%E5%8B%BE%E9%80%89%E5%90%8E%EF%BC%8C%E6%8B%96%E6%8B%BD%E4%B8%BA%E5%90%88%E9%80%82%E7%9A%84%E5%A4%A7%E5%B0%8F">6.添加接收区控件textBox，勾选MultiLine，勾选后，拖拽为合适的大小</h5> 
<p><img alt="" height="309" src="https://images2.imgbox.com/41/ad/fEOhOZOz_o.png" width="734"></p> 
<h5 id="%C2%A07.%E9%80%89%E6%8B%A9serialPort1%20-%3E%20%E9%80%89%E6%8B%A9%E4%BA%8B%E4%BB%B6%20-%3E%20%E5%8F%8C%E5%87%BBDataReceived"> 7.选择serialPort1 -&gt; 选择事件 -&gt; 双击DataReceived</h5> 
<p><img alt="" height="728" src="https://images2.imgbox.com/a2/af/j9TOAluX_o.png" width="1163"></p> 
<p>在函数serialPort1_DataReceived添加接收数据程序</p> 
<pre><code>private void serialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            int len = serialPort1.BytesToRead;//获取可以读取的字节数
            byte[] buff = new byte[len];//创建缓存数据数组
            serialPort1.Read(buff, 0, len);//把数据读取到buff数组
            string str = Encoding.Default.GetString(buff);//Byte值根据ASCII码表转为 String
            Invoke((new Action(() =&gt; //C# 3.0以后代替委托的新方法
            {
                textBox1.AppendText(str);//对话框追加显示数据
            })));
        }</code></pre> 
<p> 接下来就可以测试一下，我这里是通过虚拟串口工具（<strong>Virtual Serial Port Driver</strong>）添加了两个虚拟串口，我这里是添加的COM9和COM10；测试效果如下</p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/cf/5b/6sS594IC_o.png" width="1200"></p> 
<p>但是会发现发送HEX数据会出现乱码的现象</p> 
<p><img alt="" height="800" src="https://images2.imgbox.com/4f/78/kmBOmYXO_o.png" width="1200"></p> 
<p>出现乱码是因为这里接收的是ASCII，ASCII码表中显示的字符是乱码 ，所以这里需要加一个将字节转换为HEX函数</p> 
<pre><code>public static string byteToHexStr(byte[] bytes)
        {
            string returnStr = "";
            try
            {
                if (bytes != null)
                {
                    for (int i = 0; i &lt; bytes.Length; i++)
                    {
                        returnStr += bytes[i].ToString("X2");
                        returnStr += " ";//两个16进制用空格隔开,方便看数据
                    }
                }
                return returnStr;
            }
            catch (Exception)
            {
                return returnStr;
            }
        }</code></pre> 
<h5 id="8.%E6%B7%BB%E5%8A%A0ASCII%E5%92%8CHEX%E6%8E%A5%E6%94%B6%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6radioButton">8.添加ASCII和HEX接收选择控件radioButton</h5> 
<p>将ASCII控件默认勾选Checked-&gt;true</p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/6c/ad/HVW2oS58_o.png" width="858"></p> 
<p>添加获取时间程序</p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/8f/21/0MKXY8ac_o.png" width="451"></p> 
<pre><code>private DateTime current_time = new DateTime();</code></pre> 
<p>在serialPort1_DataReceived函数中添加选择ASCII和HEX控件和显示数据接收时间程序</p> 
<pre><code>private void serialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            int len = serialPort1.BytesToRead;//获取可以读取的字节数
            byte[] buff = new byte[len];//创建缓存数据数组
            serialPort1.Read(buff, 0, len);//把数据读取到buff数组
            string str = Encoding.Default.GetString(buff);//Byte值根据ASCII码表转为 String
            Invoke((new Action(() =&gt; //C# 3.0以后代替委托的新方法
            {
                current_time = System.DateTime.Now;
                if (radioButton2.Checked)
                {
                    if (checkBox1.Checked)
                    {
                        textBox1.AppendText("[" + current_time.ToString("yyyy-MM-dd HH:mm:ss") + "]收→" + byteToHexStr(buff) + "\r\n");//对话框追加显示数据
                    }
                    else
                    {
                        textBox1.AppendText(byteToHexStr(buff) + "\r\n");
                    }
                }
                else if (radioButton1.Checked)
                {
                    if (checkBox1.Checked)
                    {
                        textBox1.AppendText("[" + current_time.ToString("yyyy-MM-dd HH:mm:ss") + "]收→" + Encoding.Default.GetString(buff));
                    }
                    else
                    {
                        textBox1.AppendText(Encoding.Default.GetString(buff));
                    }

                }
            })));
        }</code></pre> 
<p>测试效果如下图</p> 
<p><img alt="" height="747" src="https://images2.imgbox.com/74/7e/FqvRoZ1X_o.png" width="1200"></p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/4d/6d/dV9pWSNw_o.png" width="1200"></p> 
<p>9.添加清除接收程序</p> 
<p>双击清除接收控件</p> 
<pre><code>private void button3_Click(object sender, EventArgs e)
        {
            textBox1.Clear();
        }</code></pre> 
<p>10.添加发送控件</p> 
<p><img alt="" height="555" src="https://images2.imgbox.com/3b/15/hn6hE3jH_o.png" width="926"></p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/4f/f4/pgcBewZ5_o.png" width="1200"></p> 
<p>双击发送控件，添加发送函数</p> 
<pre><code>private void button2_Click(object sender, EventArgs e)
        {
            String Str = textBox2.Text.ToString();//获取发送文本框里面的数据
            try
            {
                if (Str.Length &gt; 0)
                {
                    serialPort1.Write(Str);//串口发送数据
                }
            }
            catch (Exception) { }
        }</code></pre> 
<p>测试效果如下图</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/41/db/ufTQT5mG_o.png" width="1200"></p> 
<p>但是发送HEX还是会出现乱码的现象，现在添加一个将字符串转为HEX程序</p> 
<pre><code>private static byte[] strToToHexByte(String hexString)
        {
            int i;
            hexString = hexString.Replace(" ", "");//清除空格
            if ((hexString.Length % 2) != 0)//奇数个
            {
                byte[] returnBytes = new byte[(hexString.Length + 1) / 2];
                try
                {
                    for (i = 0; i &lt; (hexString.Length - 1) / 2; i++)
                    {
                        returnBytes[i] = Convert.ToByte(hexString.Substring(i * 2, 2), 16);
                    }
                    returnBytes[returnBytes.Length - 1] = Convert.ToByte(hexString.Substring(hexString.Length - 1, 1).PadLeft(2, '0'), 16);
                }
                catch
                {
                    MessageBox.Show("含有非16进制字符", "提示");
                    return null;
                }
                return returnBytes;
            }
            else
            {
                byte[] returnBytes = new byte[(hexString.Length) / 2];
                try
                {
                    for (i = 0; i &lt; returnBytes.Length; i++)
                    {
                        returnBytes[i] = Convert.ToByte(hexString.Substring(i * 2, 2), 16);
                    }
                }
                catch
                {
                    MessageBox.Show("含有非16进制字符", "提示");
                    return null;
                }
                return returnBytes;
            }
        }</code></pre> 
<p>添加选择发送ASCII、HEX、发送新行控件程序</p> 
<pre><code>private void button2_Click(object sender, EventArgs e)
        {
            String Str = textBox2.Text.ToString();//获取发送文本框里面的数据
            try
            {
                if (Str.Length &gt; 0)
                {
                    if (radioButton3.Checked)
                    {
                        serialPort1.Write(Str);//串口发送数据
                        textBox1.AppendText("发→" + Str + "\r\n");
                    }
                    else if (radioButton4.Checked)
                    {
                        byte[] byt = strToToHexByte(Str);
                        serialPort1.Write(byt, 0, byt.Length);
                        string hexString = BitConverter.ToString(byt).Replace("-", " ");
                        textBox1.AppendText("发→" + hexString + Environment.NewLine);
                    }

                }
            }
            catch (Exception) { }
        }</code></pre> 
<p>测试效果如下图</p> 
<p><img alt="" height="759" src="https://images2.imgbox.com/bd/ac/IVaTtRvR_o.png" width="1200"></p> 
<h5 id="9.%E6%B7%BB%E5%8A%A0%E4%B8%B2%E5%8F%A3%E7%8A%B6%E6%80%81%E6%A0%8F%E6%98%BE%E7%A4%BA%E3%80%81%E6%8E%A5%E6%94%B6%E5%AD%97%E8%8A%82%E4%B8%AA%E6%95%B0%E5%92%8C%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82%E4%B8%AA%E6%95%B0%EF%BC%8C%E6%B7%BB%E5%8A%A0%E6%8E%A7%E4%BB%B6label%EF%BC%8C%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%96%87%E6%9C%AC%E9%BB%98%E8%AE%A4%E5%86%85%E5%AE%B9">9.添加串口状态栏显示、接收字节个数和发送字节个数，添加控件label，并修改文本默认内容</h5> 
<p><img alt="" height="572" src="https://images2.imgbox.com/22/e5/m5DrzisU_o.png" width="939"></p> 
<p>定义接收和发送字节个数变量</p> 
<pre><code>private long receive_count = 0, send_count = 0;//接收字节数</code></pre> 
<p><img alt="" height="259" src="https://images2.imgbox.com/82/0d/I3etj1DU_o.png" width="561"></p> 
<p>在接收数据函数加水接收字节个数程序</p> 
<pre><code>private void serialPort1_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            int len = serialPort1.BytesToRead;//获取可以读取的字节数
            byte[] buff = new byte[len];//创建缓存数据数组

            receive_count += len;

            serialPort1.Read(buff, 0, len);//把数据读取到buff数组
            
            Invoke((new Action(() =&gt; //C# 3.0以后代替委托的新方法
            {
                current_time = System.DateTime.Now;
                if(radioButton2.Checked)
                {
                    if (checkBox1.Checked)
                    {
                        textBox1.AppendText("[" + current_time.ToString("yyyy-MM-dd HH:mm:ss") + "]收→" + byteToHexStr(buff) + "\r\n");//对话框追加显示数据
                    }
                    else
                    {
                        textBox1.AppendText(byteToHexStr(buff) + "\r\n");
                    }
                }
                else if(radioButton1.Checked)
                {
                    if(checkBox1.Checked)
                    {
                        textBox1.AppendText("[" + current_time.ToString("yyyy-MM-dd HH:mm:ss") + "]收→" + Encoding.Default.GetString(buff));
                    }
                    else
                    {
                        textBox1.AppendText(Encoding.Default.GetString(buff));
                    }
                    
                }
                label6.Text = "Rx:" + receive_count.ToString() + "Bytes";
                
            })));
        }</code></pre> 
<p><img alt="" height="749" src="https://images2.imgbox.com/c9/ab/xU17pOcP_o.png" width="1200"></p> 
<p> 在发送函数添加发送字节个数显示程序</p> 
<pre><code>private void button2_Click(object sender, EventArgs e)
        {
            String Str = textBox2.Text.ToString();//获取发送文本框里面的数据
            send_count += Str.Length;
            try
            {
                if (Str.Length &gt; 0)
                {
                    if(radioButton3.Checked)
                    {
                        serialPort1.Write(Str);//串口发送数据
                        textBox1.AppendText("发→" + Str + "\r\n");
                    }
                    else if (radioButton4.Checked)
                    {
                        byte[] byt = strToToHexByte(Str);
                        serialPort1.Write(byt, 0, byt.Length);
                        string hexString = BitConverter.ToString(byt).Replace("-", " ");
                        textBox1.AppendText("发→" + hexString + Environment.NewLine);
                    }

                    label7.Text = "Tx:" + send_count.ToString() + "Bytes";
                }
            }
            catch (Exception) { }
        }</code></pre> 
<p><img alt="" height="518" src="https://images2.imgbox.com/a4/e6/b896l1cC_o.png" width="800"></p> 
<p>测试效果如下图</p> 
<h5 id="%E2%80%8B%E7%BC%96%E8%BE%9110.%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E5%8A%9F%E8%83%BD%EF%BC%88%E5%AE%9A%E6%97%B6%E6%8E%A7%E4%BB%B6%EF%BC%89"><img alt="" height="804" src="https://images2.imgbox.com/96/eb/mKJS8Mtq_o.png" width="1200">10.添加定时发送功能（定时控件）</h5> 
<p> <img alt="" height="782" src="https://images2.imgbox.com/20/49/wloyR4Jm_o.png" width="1200"></p> 
<p>双击自动发送控件checkBox3，添加定时函数，首先获取控件numericUpDown1设置的时间数据（单位ms）</p> 
<pre><code>private void checkBox3_CheckedChanged(object sender, EventArgs e)
        {
            if (checkBox3.Checked)
            {
                if(flag == 1)
                {
                    //自动发送功能选中,开始自动发送
                    numericUpDown1.Enabled = false;     //失能时间选择
                    timer1.Interval = (int)numericUpDown1.Value;     //定时器赋初值
                    timer1.Start();     //启动定时器
                    label8.Text = "串口已打开" + " 自动发送中...";
                    label8.ForeColor = Color.Red; // 设置文本颜色为红色
                }
                else
                {
                    checkBox3.Checked = false;
                    MessageBox.Show("未打开串口!");
                }
                
            }
            else
            {
                //自动发送功能未选中,停止自动发送
                numericUpDown1.Enabled = true;     //使能时间选择
                timer1.Stop();     //停止定时器
                if(flag == 0)
                {
                    label8.Text = "串口未打开";
                }
                else
                {
                    label8.Text = "串口已打开";
                }      
                label8.ForeColor = SystemColors.ControlText;
            }

        }</code></pre> 
<p>双击定时器控件，调用发送数据函数</p> 
<pre><code>private void timer1_Tick(object sender, EventArgs e)
        {
            //定时时间到
            button2_Click(button2, new EventArgs());    //调用发送按钮回调函数
        }</code></pre> 
<p>测试效果如下图</p> 
<p><img alt="" height="780" src="https://images2.imgbox.com/ec/c9/uFCXwawg_o.png" width="1200"></p> 
<h5 id="11.%E6%B8%85%E7%A9%BA%E6%8C%89%E9%94%AE%E6%B7%BB%E5%8A%A0%E6%B8%85%E7%A9%BA%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82%E4%B8%AA%E6%95%B0">11.清空按键添加清空接收和发送字节个数</h5> 
<pre><code>private void button3_Click(object sender, EventArgs e)
        {
            textBox1.Clear();
            receive_count = 0;
            send_count = 0;
            label6.Text = "Rx:" + receive_count.ToString() + "Bytes";
            label7.Text = "Tx:" + send_count.ToString() + "Bytes";
        }</code></pre> 
<h4 id="%E4%BA%94%E3%80%81%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93">五、开发总结</h4> 
<p>首先是开发这个工具，会帮助我们对C#上位机开发流程进一步熟悉，其次就是让我们可以深入了解串口通信的原理、常见问题和解决方案，实践数据解析与处理和锻炼问题排查与调试能力等等。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/141582e897b7a6a61342cddf492eb894/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决前端笔记本电脑屏幕显示缩放比例125%、150%对页面大小的影响问题--数据可视化大屏</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b0d1738bd26554c756f750d5888c908/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Chrome浏览器插件之 JSON View（json数据格式化显示)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>