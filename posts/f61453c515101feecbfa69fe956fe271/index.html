<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FloodFill-----洪水灌溉算法（DFS例题详解） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f61453c515101feecbfa69fe956fe271/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="FloodFill-----洪水灌溉算法（DFS例题详解）">
  <meta property="og:description" content="目录
一.图像渲染：
代码详解：
二.岛屿数量：
代码详解：
三.岛屿的最大面积：
代码详解：
四.被围绕的区域：
代码详解：
五.太平洋大西洋水流问题：
代码详解：
FloodFill算法简介：FloodFill（泛洪填充）算法是一种图像处理的基本算法，用于填充连通区域。该算法通常从一个种子点开始，沿着种子点的相邻像素进行填充，直到遇到边界或者其他指定的条件为止。FloodFill 算法的主要应用是在图像编辑软件中实现填充操作，以及在计算机图形学、计算机视觉等领域中进行区域填充。
下面我们通过一些题目来理解这个算法思想：
一.图像渲染： 题目链接：733. 图像渲染 - 力扣（LeetCode）题目描述： 有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。
你也被给予三个整数 sr , sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。
为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。
最后返回 经过上色渲染后的图像 。 ​
对应函数签名如下： 思路：我们从给定的起点开始，进行深度优先搜索（上下左右四个方向）。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。这里我们设置初始方格为target. 代码详解： 解法一：
class Solution { //记录走过的路径，防止走回头路 boolean[][] used; int target; public int[][] floodFill(int[][] image, int sr, int sc, int color) { int m = image.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-04T20:36:03+08:00">
    <meta property="article:modified_time" content="2024-05-04T20:36:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FloodFill-----洪水灌溉算法（DFS例题详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%EF%BC%9A" rel="nofollow">一.图像渲染：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A" rel="nofollow">代码详解：</a></p> 
<p id="%E4%BA%8C.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%EF%BC%9A" rel="nofollow">二.岛屿数量：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A" rel="nofollow">代码详解：</a></p> 
<p id="%E4%B8%89.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%EF%BC%9A" rel="nofollow">三.岛屿的最大面积：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A" rel="nofollow">代码详解：</a></p> 
<p id="%E5%9B%9B.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%9A" rel="nofollow">四.被围绕的区域：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A" rel="nofollow">代码详解：</a></p> 
<p id="%E4%BA%94.%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98%EF%BC%9A" rel="nofollow">五.太平洋大西洋水流问题：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A" rel="nofollow">代码详解：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>FloodFill算法简介：<span style="background-color:#ffd900;">FloodFill（泛洪填充）算法是一种图像处理的基本算法，用于填充连通区域</span>。该算法通常从一个种子点开始，沿着种子点的相邻像素进行填充，直到遇到边界或者其他指定的条件为止。FloodFill 算法的主要应用是在图像编辑软件中实现填充操作，以及在计算机图形学、计算机视觉等领域中进行区域填充。</p> 
<p>下面我们通过一些题目来理解这个算法思想：</p> 
<h2 id="%E4%B8%80.%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93%EF%BC%9A" style="background-color:transparent;">一.图像渲染：</h2> 
<ul><li>题目链接：<a href="https://leetcode.cn/problems/flood-fill/description/" rel="nofollow" title="733. 图像渲染 - 力扣（LeetCode）">733. 图像渲染 - 力扣（LeetCode）</a></li><li>题目描述：</li></ul> 
<p>有一幅以 <code>m x n</code> 的二维整数数组表示的图画 <code>image</code> ，其中 <code>image[i][j]</code> 表示该图画的像素值大小。</p> 
<p>你也被给予三个整数 <code>sr</code> ,  <code>sc</code> 和 <code>newColor</code> 。你应该从像素 <code>image[sr][sc]</code> 开始对图像进行 上色<strong>填充</strong> 。</p> 
<p>为了完成<strong> 上色工作</strong> ，从初始像素开始，记录初始坐标的 <strong>上下左右四个方向上</strong> 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 <strong>四个方向上</strong> 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 <code>newColor</code> 。</p> 
<p>最后返回 <em>经过上色渲染后的图像 </em>。 ​<img alt="" height="1036" src="https://images2.imgbox.com/da/1b/qZeFRqUj_o.png" width="1200"></p> 
<ul><li><strong>对应函数签名如下：</strong></li></ul> 
<p><img alt="" height="230" src="https://images2.imgbox.com/a5/eb/D6LPjZa5_o.png" width="1200"></p> 
<blockquote> 
 <ul><li><strong> 思路：我们从给定的起点开始，进行深度优先搜索（上下左右四个方向）。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。这里我们设置初始方格为target.</strong></li></ul> 
</blockquote> 
<h3 id="%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%9A"><strong>代码详解：</strong></h3> 
<p><strong>解法一：</strong></p> 
<pre><code class="language-java">class Solution {
    //记录走过的路径，防止走回头路
    boolean[][] used;
    int target;
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        int m = image.length,n = image[0].length;
        used = new boolean[m][n];
        target = image[sr][sc];
        dfs(image,sr,sc,color);
        return image;
    }
    public void dfs(int[][] image,int i,int j,int color){
        int m = image.length,n = image[0].length;
        //剪枝，越界直接返回
        if(i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n){
            return ;
        }
        //使用过的位置也直接返回
        if(used[i][j]) return ;
      
        if(image[i][j] == target){
            //上下左右去深搜，符合条件的都标记为color
               image[i][j] = color;
               used[i][j] = true;
             dfs(image,i - 1,j,color);
             dfs(image,i + 1,j,color);
             dfs(image,i,j - 1,color);
             dfs(image,i,j + 1,color);
        }
       
    }
}</code></pre> 
<p><strong>解法二：基于解法一，我们可以通过定义两个数组来表示方向：dx[ ],dy[ ]，其中dx[ ],dy[ ]的位置要一一对应,具体操作如下：</strong></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/93/eb/vnj2n4jC_o.png" width="1195"></p> 
<p><strong> 代码详解：</strong></p> 
<pre><code class="language-java">class Solution {
    boolean[][] used;
    int target;
    int[] dx = {-1,1,0,0};
    int[] dy = {0,0,1,-1};
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        int m = image.length,n = image[0].length;
        used = new boolean[m][n];
        target = image[sr][sc];
        dfs(image,sr,sc,color);
        return image;
    }
    public void dfs(int[][] image,int i,int j,int color){
        int m = image.length,n = image[0].length;
        //每次进入都进行标记，并将该位置值改为color
        used[i][j] = true;
        image[i][j] = color;
        //相当于上下左右四个方向进行深搜
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k],y = j + dy[k];
            //所有不符合条件的都不能进入深搜
            if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n
            &amp;&amp; !used[x][y] &amp;&amp; image[x][y] == target){
                dfs(image,x,y,color);
            }
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="291" src="https://images2.imgbox.com/21/ed/vDUM6dUM_o.png" width="550"></p> 
<h2 id="%E4%BA%8C.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%EF%BC%9A" style="background-color:transparent;">二.岛屿数量：</h2> 
<ul><li>题目链接：<a href="https://leetcode.cn/problems/number-of-islands/description/" rel="nofollow" title="200. 岛屿数量 - 力扣（LeetCode）">200. 岛屿数量 - 力扣（LeetCode）</a></li><li>题目描述：</li></ul> 
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p> 
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p> 
<p>此外，你可以假设该网格的四条边均被水包围。</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/f4/03/y8PYMydX_o.png" width="303"></p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/3b/77/WrPVev4b_o.png" width="475"></p> 
<ul><li> 对应函数签名如下：</li></ul> 
<p><img alt="" height="150" src="https://images2.imgbox.com/82/0c/gsRQ3DEl_o.png" width="613"></p> 
<blockquote> 
 <ul><li>思路：</li><li>遍历整个矩阵，每次找到「⼀块陆地」的时候：</li><li> 说明<span style="background-color:#ffd900;">找到「⼀个岛屿」，记录到最终结果 res⾥⾯</span>；</li><li><span style="background-color:#ffd900;">并且将这个陆地相连的所有陆地，也就是这块「岛屿」，全部「变成海洋」</span>。这样的话，我们下次 遍历到这块岛屿的时候，它「已经是海洋」了，不会影响最终结果。</li><li> 其中「变成海洋」的操作，可以利⽤「深搜」来解决</li></ul> 
</blockquote> 
<h3 style="background-color:transparent;">代码详解：</h3> 
<p> 解法一：与上面一样，两种解法（类似）：</p> 
<pre><code class="language-java">class Solution {
    int res = 0;
    public int numIslands(char[][] grid) {
        int m = grid.length,n = grid[0].length;
        for(int i = 0;i &lt; m;i++){
            for(int j = 0;j &lt; n;j++){
                if(grid[i][j] == '1'){
                   //每次找到一个岛屿记录一下，再将这个岛屿淹没
                    res++;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }
    public void dfs(char[][] grid,int i,int j){
        int m = grid.length,n = grid[0].length;
        //处理边界情况
        if(i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n){
            return ;
        }
        if(grid[i][j] == '0') return ;
        grid[i][j] = '0'; 
        //上下左右去淹没这个岛屿
        dfs(grid,i - 1,j);
        dfs(grid,i + 1,j);
        dfs(grid,i,j - 1);
        dfs(grid,i,j + 1);
    }
}</code></pre> 
<p>解法二：</p> 
<pre><code class="language-java">class Solution {
    int res = 0;
    int[] dx = {0,0,-1,1};
    int[] dy = {1,-1,0,0};
    public int numIslands(char[][] grid) {
        int m = grid.length,n = grid[0].length;
        for(int i = 0;i &lt; m;i++){
            for(int j = 0;j &lt; n;j++){
                if(grid[i][j] == '1'){
                   //说明找到「⼀个岛屿」，记录到最终结果 res⾥⾯
                    res++;
                    dfs(grid,i,j);//将这个岛屿淹没
                }
            }
        }
        return res;
    }
    public void dfs(char[][] grid,int i,int j){
        int m = grid.length,n = grid[0].length;
       
        grid[i][j] = '0'; 
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k],y = j + dy[k];
            if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n
            &amp;&amp; grid[x][y] != '0'){
                dfs(grid,x,y);
            }
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/1b/50/1g1pelR5_o.png" width="564"> </p> 
<h2 id="%E4%B8%89.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%EF%BC%9A" style="background-color:transparent;">三.岛屿的最大面积：</h2> 
<ul><li>题目链接：<a href="https://leetcode.cn/problems/max-area-of-island/description/" rel="nofollow" title="695. 岛屿的最大面积 - 力扣（LeetCode）">695. 岛屿的最大面积 - 力扣（LeetCode）</a></li><li>题目描述： <p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p> <p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p> <p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p> <p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> </p> </li></ul> 
<p><img alt="" height="558" src="https://images2.imgbox.com/09/1a/SUmbfcMP_o.png" width="603"></p> 
<ul><li>对应函数签名：</li></ul> 
<p><img alt="" height="222" src="https://images2.imgbox.com/d5/9c/XTqfSysi_o.png" width="966"></p> 
<blockquote> 
 <p>算法思路：</p> 
 <p>• 遍历整个矩阵，<span style="background-color:#ffd900;">每当遇到⼀块⼟地的时候，就⽤「深搜」或者「宽搜」将与这块⼟地相连的「整个 岛屿」的⾯积计算出来</span>。</p> 
 <p>• 然后<span style="background-color:#ffd900;">在搜索得到的「所有的岛屿⾯积」求⼀个「最⼤值」即可</span>。</p> 
 <p>• 在搜索过程中，为了「防⽌搜到重复的⼟地」：</p> 
 <p>◦ 可以开⼀个同等规模的「布尔数组」，标记⼀下这个位置是否已经被访问过；</p> 
 <p>◦ 也可以将原始矩阵的 1 修改成 0 ，但是这样操作会修改原始矩阵。 </p> 
</blockquote> 
<h3>代码详解：</h3> 
<p> 解法一：</p> 
<pre><code class="language-java">class Solution {
    int maxArea = 0;
    int count;
    boolean[][] used;
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length,n = grid[0].length;
        used = new boolean[m][n];
        for(int i = 0;i &lt; m;i++){
            for(int j = 0;j &lt; n;j++){
                if(grid[i][j] == 1){
                    //每次找到一个岛屿都要重置计数
                    count = 0;
                    dfs(grid,i,j);
                    maxArea = Math.max(maxArea,count);
                }
            }
        }
        return maxArea;
    }

    public void dfs(int[][] grid,int i,int j){
        int m = grid.length,n = grid[0].length;
        //处理边界情况
        if(i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n){
            return ;
        }
        if(grid[i][j] == 0) return ;
        if(used[i][j]) return ;

        used[i][j] = true;
        count++;
        dfs(grid,i - 1,j);
        dfs(grid,i + 1,j);
        dfs(grid,i,j - 1);
        dfs(grid,i,j + 1);
    }
}</code></pre> 
<p>解法二：</p> 
<pre><code class="language-java">class Solution {
    int maxArea = 0;
    int count = 0;
    int[] dx = {0,0,-1,1};
    int[] dy = {1,-1,0,0};
    boolean[][] used;
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length,n = grid[0].length;
        used = new boolean[m][n];
        for(int i = 0;i &lt; m;i++){
            for(int j = 0;j &lt; n;j++){
                if(grid[i][j] == 1){
                    //每次找到一个岛屿都要重置计数
                    count = 0;
                    dfs(grid,i,j);
                    maxArea = Math.max(maxArea,count);
                }
            }
        }
        return maxArea;
    }

    public void dfs(int[][] grid,int i,int j){
        int m = grid.length,n = grid[0].length;

        used[i][j] = true;
        count++;
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k],y = j + dy[k];
            //处理不满足条件的情况
            if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n 
            &amp;&amp; !used[x][y] &amp;&amp; grid[x][y] != 0){
                dfs(grid,x,y);
            }
        }

    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/6f/69/t9MkGSKv_o.png" width="556"></p> 
<h2 id="%E5%9B%9B.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%9A" style="background-color:transparent;">四.被围绕的区域：</h2> 
<ul><li>题目链接:<a href="https://leetcode.cn/problems/surrounded-regions/description/" rel="nofollow" title="130. 被围绕的区域 - 力扣（LeetCode）">130. 被围绕的区域 - 力扣（LeetCode）</a></li><li>题目描述：给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</li></ul> 
<p><img alt="" height="1058" src="https://images2.imgbox.com/dd/d9/Yh2Idaab_o.png" width="1200"></p> 
<ul><li>对应函数签名：</li></ul> 
<p><img alt="" height="212" src="https://images2.imgbox.com/61/51/VSraL6v2_o.png" width="925"></p> 
<blockquote> 
 <ul><li>算法思路： </li><li>正难则反。 可以先利⽤ dfs 将与边缘相连的 '0' 区域做上标记，然后重新遍历矩阵，将没有标记过的 '0' 修改成 'X' 即可。</li></ul> 
</blockquote> 
<p><img alt="" height="277" src="https://images2.imgbox.com/1c/94/qJnw2hRn_o.png" width="346"> </p> 
<h3 style="background-color:transparent;">代码详解：</h3> 
<pre><code class="language-java">class Solution {
    boolean[][] used;
    public void solve(char[][] board) {
        int m = board.length,n = board[0].length;
        used = new boolean[m][n];
        //分别对应上下左右,标记外围的'O'
        for(int i = 0;i &lt; n;i++){
            dfs2(board,0,i);
            dfs2(board,m - 1,i);
        }
        for(int j = 0;j &lt; m;j++){
            dfs2(board,j,0);
            dfs2(board,j,n - 1);
        }

        for(int i = 0;i &lt; m;i++){
            for(int j = 0;j &lt; n;j++){
                if(board[i][j] != 'X' &amp;&amp; !used[i][j]){
                    dfs(board,i,j);
                }
            }
        }
        
    }
    //将内部的'O'全部标记为'X'
     public void dfs(char[][] board,int i,int j){
        int m = board.length,n = board[0].length;
        if(i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n){
            return ;
        }
        if(board[i][j] == 'X') return;
        if(used[i][j]) return ;


        used[i][j] = true;

        board[i][j] = 'X';

        dfs(board,i - 1,j);
        dfs(board,i + 1,j);
        dfs(board,i,j - 1);
        dfs(board,i,j + 1);
    }
   //将外围的位置标记为true，后续不会对其进行操作
    public void dfs2(char[][] board,int i,int j){
        int m = board.length,n = board[0].length;
        if(i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n){
            return ;
        }
        if(board[i][j] == 'X') return;
        if(used[i][j]) return ;
        used[i][j] = true;
        dfs2(board,i - 1,j);
        dfs2(board,i + 1,j);
        dfs2(board,i,j - 1);
        dfs2(board,i,j + 1);
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/c7/d2/rZujwd7K_o.png" width="511"></p> 
<h2 id="%E4%BA%94.%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98%EF%BC%9A" style="background-color:transparent;">五.太平洋大西洋水流问题：</h2> 
<ul><li>题目链接：<a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/description/" rel="nofollow" title="417. 太平洋大西洋水流问题 - 力扣（LeetCode）">417. 太平洋大西洋水流问题 - 力扣（LeetCode）</a></li><li>题目描述：</li></ul> 
<p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和 <strong>大西洋</strong> 相邻。 <strong>“太平洋” </strong>处于大陆的左边界和上边界，而 <strong>“大西洋”</strong> 处于大陆的右边界和下边界。</p> 
<p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵 <code>heights</code> ， <code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格 <strong>高于海平面的高度</strong> 。</p> 
<p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p> 
<p>返回网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中 <code>result[i] = [ri, ci]</code> 表示雨水从单元格 <code>(ri, ci)</code> 流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/19/aa/qLFIENBm_o.png" width="1200"></p> 
<ul><li>对应函数标签： </li></ul> 
<p><img alt="" height="220" src="https://images2.imgbox.com/f7/51/AogLJeAd_o.png" width="1200"></p> 
<blockquote> 
 <ul><li> 算法思路：</li></ul> 
 <p>正难则反。 如果直接去判断某⼀个位置是否既能到⼤西洋也能到太平洋，会重复遍历很多路径。 我们反着来，从⼤西洋沿岸开始反向 dfs ，这样就能找出那些点可以流向⼤西洋；同理，从太平洋沿 岸也反向 dfs ，这样就能找出那些点可以流向太平洋。那么，被标记两次的点，就是我们要找的结果</p> 
</blockquote> 
<p><img alt="" height="337" src="https://images2.imgbox.com/f5/dc/QcGzg91f_o.png" width="390"> </p> 
<h3>代码详解：</h3> 
<pre><code class="language-java">class Solution {
    int m ,n;
    int[] dx = {0,0,1,-1};
    int[] dy = {1,-1,0,0};
    public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] heights) {
        m = heights.length;
        n = heights[0].length;
        boolean[][] pac = new boolean[m][n];
        boolean[][] atl = new boolean[m][n];

        //先搞太平洋
        for(int j = 0;j &lt; n;j++) dfs(heights,0,j,pac);
        for(int i = 0;i &lt; m;i++) dfs(heights,i,0,pac);

        //在搞大西洋
        for(int i = 0;i &lt; m;i++) dfs(heights,i,n - 1,atl);
        for(int j  = 0;j &lt; n;j++) dfs(heights,m - 1,j,atl);

        //再提取结果：
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for(int i = 0;i &lt; m;i++){
            for(int j = 0;j &lt; n;j++){
                if(pac[i][j] &amp;&amp; atl[i][j]){
                    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();
                    temp.add(i);temp.add(j);
                    res.add(temp);
                }
            }
        }
        return res;
    }

    public void dfs(int[][] heights,int i,int j,boolean[][] used){
        used[i][j] = true;
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k],y = j + dy[k];
            if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n 
            &amp;&amp; !used[x][y] &amp;&amp; heights[x][y] &gt;= heights[i][j]){
                dfs(heights,x,y,used);
            }
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/9b/ad/82WnihKl_o.png" width="591"> </p> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p style="text-align:center;"><strong><img alt="" height="289" src="https://images2.imgbox.com/a9/8a/5T1jKKXu_o.jpg" width="289"></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c70c2b9a0e985b0f068b4cad1eb6db2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ZooKeeper以及DolphinScheduler的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ffa0b5e43fe702e01e1e12c7c2a5ecc6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">llama-factory SFT 系列教程 (四)，lora sft 微调后，使用vllm加速推理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>