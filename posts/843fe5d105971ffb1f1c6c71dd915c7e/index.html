<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】第十九弹---C语言实现冒泡排序算法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/843fe5d105971ffb1f1c6c71dd915c7e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】第十九弹---C语言实现冒泡排序算法">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1、冒泡排序基本思想
2、代码的初步实现
3、代码的优化
4、代码的测试
5、时空复杂度分析
6、模拟实现qsort
6.1、冒泡排序函数
6.2、交换数据函数
6.3、比较函数
总结
1、冒泡排序基本思想 冒泡排序法：（Bubble sort）是一种基础的交换排序。对数组进行遍历，每次对相邻两个进行比较大小，若大的数值在前面则交换位置（升序），完成一趟遍历后数组中最大的数值到了数组的末尾位置，再对前面n-1个数值进行相同的遍历，完成n-1次遍历则排序完成。
1. 第一趟对0~n-1遍历，依次对比前后的大小，若是不满足前小后大就交换，此时最大的数就被挪到了最后一个位置。
2. 对0~n-2遍历，继续比较前后大小，此时前n-2个数中最大的数就到了倒数第二个位置。
3. 重复上述动作继续遍历，每一次都将最大的数向后挤，直到遍历完毕排序成功。
2、代码的初步实现 对int 类型的数进行升序排序。
//交换函数 void Swap(int* p1, int* p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } void BubbleSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i&#43;&#43;)//遍历n-1次 { for (int j = 0; j &lt; n - 1 - i; j&#43;&#43;)//相邻两个数进行比较 { if (a[j] &gt; a[j &#43; 1])//前面的值大于后面的值则交换 { Swap(&amp;a[j], &amp;a[j &#43; 1]); } } } } 3、代码的优化 如果一次遍历，没有数据进行交换，则证明数组已经排好了顺序，不需要继续遍历，则引入exchange变量标志记录第一次遍历是否有数据交换。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-22T11:30:31+08:00">
    <meta property="article:modified_time" content="2024-06-22T11:30:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】第十九弹---C语言实现冒泡排序算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/0c/2c/GOVf0uZv_o.jpg"></p> 
<p style="text-align:center;"> ✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏：</span> <a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<p style="text-align:center;"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">1、冒泡排序基本思想</a></p> 
<p id="2%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0" rel="nofollow">2、代码的初步实现</a></p> 
<p id="3%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96" rel="nofollow">3、代码的优化</a></p> 
<p id="4%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B5%8B%E8%AF%95" rel="nofollow">4、代码的测试</a></p> 
<p id="5%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">5、时空复杂度分析</a></p> 
<p id="6%E3%80%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0qsort-toc" style="margin-left:0px;"><a href="#6%E3%80%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0qsort" rel="nofollow">6、模拟实现qsort</a></p> 
<p id="6.1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0" rel="nofollow">6.1、冒泡排序函数</a></p> 
<p id="6.2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0" rel="nofollow">6.2、交换数据函数</a></p> 
<p id="6.3%E3%80%81%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.3%E3%80%81%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0" rel="nofollow">6.3、比较函数</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">1、冒泡排序基本思想</h2> 
<p></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">冒泡排序法：</span>（Bubble sort）是一种基础的<strong><span style="color:#fe2c24;">交换排序</span></strong>。对数组进行遍历，<span style="color:#ff9900;">每次对相邻两个进行比较大小，若大的数值在前面则交换位置（升序）</span>，完成一趟遍历后数组中最大的数值到了数组的末尾位置，再对前面n-1个数值进行相同的遍历，完成n-1次遍历则排序完成。</p> 
</blockquote> 
<p><span style="color:#fe2c24;">1. 第一趟对<code>0~n-1</code>遍历，依次对比前后的大小，若是不满足前小后大就交换，此时最大的数就被挪到了最后一个位置。</span></p> 
<p><img alt="" height="670" src="https://images2.imgbox.com/92/9f/noTpKZvl_o.png" width="568"></p> 
<p><span style="color:#fe2c24;">2. 对<code>0~n-2</code>遍历，继续比较前后大小，此时前<code>n-2</code>个数中最大的数就到了倒数第二个位置。</span></p> 
<p><img alt="" height="642" src="https://images2.imgbox.com/54/3f/yH7Nj8cT_o.png" width="546"></p> 
<p><span style="color:#fe2c24;">3. 重复上述动作继续遍历，每一次都将最大的数向后挤，直到遍历完毕排序成功。</span></p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/92/06/h42IS7Yq_o.png" width="581"></p> 
<p></p> 
<h2 id="2%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0">2、代码的初步实现</h2> 
<p><strong><span style="color:#fe2c24;">对int 类型的数进行升序排序。</span></strong></p> 
<pre><code>//交换函数
void Swap(int* p1, int* p2)
{
	int tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}
void BubbleSort(int* a, int n)
{
	for (int i = 0; i &lt; n - 1; i++)//遍历n-1次
	{
		for (int j = 0; j &lt; n - 1 - i; j++)//相邻两个数进行比较
		{
			if (a[j] &gt; a[j + 1])//前面的值大于后面的值则交换
			{
				Swap(&amp;a[j], &amp;a[j + 1]);
			}
		}
	}
}</code></pre> 
<p></p> 
<h2 id="3%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E5%8C%96">3、代码的优化</h2> 
<p><strong><span style="color:#0d0016;">如果一次遍历，没有数据进行交换，则证明数组已经排好了顺序，不需要继续遍历，则引入exchange变量标志记录第一次遍历是否有数据交换。</span></strong></p> 
<pre><code>void BubbleSort(int* a, int n)
{
	for (int i = 0; i &lt; n - 1; i++)
	{
		bool exchange = false;//默认false，值没变则没有交换
		for (int j = 0; j &lt; n - 1 - i; j++)//遍历n-1次
		{
			if (a[j] &gt; a[j + 1])//相邻两个数进行比较
			{
				Swap(&amp;a[j], &amp;a[j + 1]);//前面的值大于后面的值则交换
				exchange = true;
			}
		}
		if (exchange == false)//值没变则退出内循环
			break;
	}
}</code></pre> 
<h2 id="4%E3%80%81%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B5%8B%E8%AF%95">4、代码的测试</h2> 
<p><strong><span style="color:#0d0016;">测试代码：</span></strong></p> 
<pre><code>//测试冒泡排序
int main()
{
	int a[] = { 9,8,7,6,5,4,3,2,1,0 };//给一组数据
	int sz = sizeof(a) / sizeof(a[0]);//计算数组元素个数
	printf("排序前：\n");
	ArrayPrint(a, sz);
	BubbleSort(a, sz);
	printf("排序后：\n");
	ArrayPrint(a, sz);
	return 0;
}</code></pre> 
<p><strong><span style="color:#0d0016;">测试结果： </span></strong></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/37/bc/GbkrSdEC_o.png" width="915"></p> 
<p></p> 
<h2 id="5%E3%80%81%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">5、时空复杂度分析</h2> 
<p><strong><span style="color:#0d0016;">时间复杂度：</span></strong></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">最坏情况：</span></strong></p> 
 <p>当我们需要排升序的时候，原数组为降序，则为最坏情况。此时每次交换操作需要比较的次数从 n-1 次减少到 1 次，总共的比较次数是 (n-1) + (n-2) + … + 1 = n(n-1)/2，这是一个二次函数，因此<strong><span style="color:#0d0016;">时间复杂度为 O(n^2)。</span></strong></p> 
 <p><strong><span style="color:#fe2c24;">最好情况：</span></strong></p> 
 <p>当我们需要排升序时，原数组也是升序，我们只需要循环n次则可以判断结束，此时<strong><span style="color:#0d0016;">时间复杂度为O(N)。</span></strong></p> 
</blockquote> 
<p><strong><span style="color:#38d8f0;">由于时间复杂度取决于最坏情况，因此冒泡排序的时间复杂度为O(N^2)。</span></strong></p> 
<p></p> 
<p><strong><span style="color:#0d0016;">空间复杂度：</span></strong></p> 
<p><span style="color:#38d8f0;"><strong>冒泡排序是一种原地排序算法，除了输入数组外，它只需要有限的几个变量（比如，交换标记和循环计数器）。因此，它的空间复杂度为常数空间O(1)。</strong></span></p> 
<p></p> 
<h2 id="6%E3%80%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0qsort">6、模拟实现qsort</h2> 
<p>C语言中<strong><span style="color:#fe2c24;">库函数 <code>qsort</code></span></strong>是通过<strong><span style="color:#fe2c24;">函数指针<code>cmp</code></span></strong>传入数据类型的比较方式，实现<span style="background-color:#fbd4d0;">对各种数据类型都能进行排序</span>的功能。</p> 
<p>我们将<strong><span style="color:#ff9900;">模仿<code>qsort</code>函数使用冒泡排序算法实现对各种数据类型都能进行排序的函数</span></strong>，并且使用<code>const</code>关键字严格限制参的属性，达到很高的健壮性要求。</p> 
<h3 id="6.1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0"><strong><span style="color:#0d0016;">6.1、冒泡排序函数</span></strong></h3> 
<p><strong><span style="color:#0d0016;">库函数qsort()函数接口：</span></strong></p> 
<pre><code>void qsort (void* base, size_t num, size_t size,
            int (*com)(const void*,const void*));</code></pre> 
<p><strong><span style="color:#0d0016;">模拟实现的函数接口：</span></strong></p> 
<pre><code>void bubble_sort(void* base, //待排序数组首元素地址
                 size_t num, //待排序数组元素个数
                 size_t size,//待排序数组元素类型大小，单位为字节
                 int (*com)(const void*,const void*)//函数指针 如何进行比较函数
);
</code></pre> 
<p></p> 
<h3 id="6.2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0">6.2、交换数据函数</h3> 
<pre><code>void swap(char* buf1, char* buf2, size_t size);</code></pre> 
<p>思想：</p> 
<p><span style="background-color:#fbd4d0;">以1个字节为单位对两个指针指向的内容进行交换</span>，<span style="background-color:#ffd900;">交换size次</span>即可。</p> 
<p></p> 
<p></p> 
<p><strong><span style="color:#0d0016;">参数：</span></strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">buf1：</span><span style="background-color:#fbd4d0;">被交换的数据的地址。</span><br><span style="color:#fe2c24;">buf2：</span><span style="background-color:#fbd4d0;">被交换的数据的地址。</span><br><span style="color:#fe2c24;">size：</span><span style="background-color:#fbd4d0;">被交换数据类型的字节大小。</span></p> 
</blockquote> 
<pre><code>void swap(char* buf1, char* buf2, size_t size)
{
	assert(buf1 &amp;&amp; buf2);//断言，指针不为空才能交换
	size_t i = 0;
	for (i = 0; i &lt; size; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}</code></pre> 
<p></p> 
<h3 id="6.3%E3%80%81%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0">6.3、比较函数</h3> 
<pre><code>int cmp(const void* e1, const void* e2);
</code></pre> 
<p><strong><span style="color:#fe2c24;"> void*是一个空类型的指针，可以存放任意类型的指针。</span></strong></p> 
<blockquote> 
 <p>此处就用到了void*,<span style="background-color:#fbd4d0;">void*为空指针，不能直接使用</span>，<span style="background-color:#fbd4d0;">但是可以强转为其他的任何类型，</span>那么此处我们应该强转成什么类型呢？直接强转成int*？很显然，如果强转为int*，那么char*,short*就不好进行转化了，因此<span style="background-color:#fbd4d0;">此处转化为char*</span>，如果要用到其他的类型，<span style="background-color:#d4e9d5;">我们通过+数据类型大小就可以得到</span>。<strong><span style="color:#0d0016;">因此我们需要将指针转换成char*，依次按照字节进行交换。</span></strong></p> 
</blockquote> 
<p></p> 
<p><strong><span style="color:#0d0016;">返回值：</span></strong></p> 
<blockquote> 
 <p>大于0，e1大；等于0，一样大；小于0，e2大。</p> 
</blockquote> 
<p><strong><span style="color:#0d0016;">参数：</span></strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">e1：</span>被比较的数据的地址，由void*指针接收，由const限制不能改变指针指向，但<strong><span style="color:#0d0016;">可以改变指针指向的内容。</span></strong><br><span style="color:#fe2c24;">e1：</span>被比较的数据的地址，由void*指针接收，由const限制不能改变指针指向，但<strong><span style="color:#0d0016;">可以改变指针指向的内容。</span></strong></p> 
</blockquote> 
<p><strong><span style="color:#0d0016;">函数体：</span></strong></p> 
<blockquote> 
 <p>由<span style="background-color:#fbd4d0;">用户自定义实现数值的比较规则。</span></p> 
</blockquote> 
<p><strong><span style="color:#0d0016;">传参：</span></strong></p> 
<blockquote> 
 <p>1.<span style="background-color:#fbd4d0;"> 被比较数值的地址由void*指针接收。</span></p> 
 <p>2.<span style="background-color:#fbd4d0;"> 数值在数组中第 i 个位置</span>：将void*转换成char指针，<code><span style="background-color:#fbd4d0;">(char*)base + i*size 。</span></code></p> 
</blockquote> 
<p><strong><span style="color:#0d0016;">一些规则的演示:</span></strong></p> 
<pre><code>//int类型数据比较（升序）
int cmp(const void* e1, const void* e2)
{
    return *(int*)e1 - *(int*)e2;
}

//int类型数据比较（降序）
int cmp(const void* e1, const void* e2)
{
    return *(int*)e2 - *(int*)e1;	//降序就是把e1，e2的位置交换一下
}

//字符串比较（按字母升序）
#include &lt;string.h&gt;
int cmp(const void* e1, const void* e2)
{
    return strcmp((char*)e1, (char*)e2);	//字符串比较函数，与前面的比较规则一致
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>冒泡排序法的实现</strong>：</span></p> 
<pre><code>#include &lt;assert.h&gt;		//引入头文件&lt;assert.h&gt;，使用assert函数断言

//交换数据
void swap(char* buf1, char* buf2, size_t size)
{
	assert(buf1 &amp;&amp; buf2);//断言，指针不为空才能交换
	size_t i = 0;
	for (i = 0; i &lt; size; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}

//冒泡排序法
void bubble_sort(void* base,size_t num,size_t size,int (*cmp)(const void* e1,const void* e2))
{
	size_t i = 0;
	for (i = 0; i &lt; num - 1; i++)
	{
		size_t j = 0;
		for (j = 0; j &lt; num - 1 - i; j++)
		{
			//if (arr[j] &gt; arr[j + 1])
			//(char*)base+j*size,(char*)base+(j+1)*size
			if(cmp((char*)base + j * size, (char*)base + (j + 1) * size)&gt;0)
			{
				swap((char*)base + j * size, (char*)base + (j + 1) * size,size);
			}
		}
	}
}
</code></pre> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>1.整型数组降序排序的演示</strong>：</span></p> 
<pre><code>//整型降序比较函数
int cmp_int(void* e1, void* e2)
{
	return *((int*)e2) - *((int*)e1);
}

void test1()
{
	int arr[] = { 0,1,2,3,4,5,6,7,8,9 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	print_arr(arr, sz);//打印数组元素
	bubble_sort(arr, sz, sizeof(arr[0]), cmp_int);
	print_arr(arr, sz);//打印数组元素
}
</code></pre> 
<p><strong><span style="color:#0d0016;">测试结果： </span></strong></p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/d0/ef/KDFXxasu_o.png" width="890"></p> 
<p><strong><span style="color:#fe2c24;">2.结构体演示 </span></strong></p> 
<pre><code>struct Stu
{
	char name[20];
	int age;
};

int cmp_stu_by_age(const void* e1,const void* e2)
{
	return ((struct Stu*)e1)-&gt;age - ((struct Stu*)e2)-&gt;age;
}

void test2()
{
	struct Stu arr[] = { {"zhangsan",18},{"lisi",32},{"wangwu",20} };
	int sz = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, sz, sizeof(arr[0]), cmp_stu_by_age);
}
</code></pre> 
<p><strong><span style="color:#0d0016;">测试结果： </span></strong></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/e3/d3/3LbRRskG_o.png" width="841"></p> 
<p></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p><br> 本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6af5bee93469b5be26c0298d0423585/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">某程序员：30岁了，老婆管钱，背着我买了50万股票，亏了20w，强制她清仓后又买了36万</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea231a40b0c5cbfb9c167cd7abb433e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43; 设计模式 的课本范例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>