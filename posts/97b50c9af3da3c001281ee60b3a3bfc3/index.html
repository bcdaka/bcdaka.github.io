<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】深入理解指针（一篇让你完全搞懂指针） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/97b50c9af3da3c001281ee60b3a3bfc3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C语言】深入理解指针（一篇让你完全搞懂指针）">
  <meta property="og:description" content="一、什么是指针？ 1.1指针概念 本质上指针就是地址，口语中所说的指针，其实就是指针变量，指针变量是用来存放地址的一个指针。
我们知道计算机上CPU（中央处理器）在处理数据的时候，需要的数据是内存中读取的，处理后的数据也会放回内存中。
电脑上内存是8CB/16GB/32GB等，这些内存空间如何高效的管理？
其实就是把内存划分成一个一个的内存单元，每个内存单元的大小取1字节，每个内存单元都有一个编号。
有了内存单元的编号，CPU就可以快速找到一个内存空间。
内存单元的编号 == 地址 == 指针
二、指针变量和地址 2.1 取地址操作符（&amp;） 在C语言中，创建变量其实就是向内存申请空间
上述代码创建整型变量a，向内存申请了4个字节，用于存放整数10，其中每个字节都有地址，上图中4个字节地址分别是：
0x00F5FCEC 0x00F5FCED 0x00F5FCEE 0x00F5FCEF
那我们如何得到a的地址？ 这里就用到取地址操作符（&amp;）
#include &lt;stdio.h&gt; int main() { int a = 10; &amp;a; printf(&#34;%p\n&#34;, &amp;a); return 0; } 上述代码，运行之后，打印：0x00F5FCEC &amp;a取出来的是a所占4个字节中地址最小的字节的地址。
2.2 指针变量和解引用操作符（*） 2.2.1 指针变量 我们通过取地址操作符（&amp;）拿到的地址是一个数组，比如：0x00F5FCEC，这个数组有时候需要存储起来，方便后期使用，那我们就可以把地址值存放在指针变量中。
总结：变量a和指针变量pa都有各自的地址，只是把变量a的地址存放在指针变量pa里。
指针变量也是一种变量，这种变量就是用来存放地址的，存放在指针变量中的值都会理解为地址
2.2.2 解引用操作符（*） #include &lt;stdio.h&gt; int main() { int a = 10; int* pa = &amp;a;//取出a地址，并存放在指针变量中 //①int说明pa指向的对象是int类型 ②*说明pa是指针变量 *pa=100; printf(&#34;%d&#34;,*pa); return 0; } 输出：100">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T19:54:23+08:00">
    <meta property="article:modified_time" content="2024-03-07T19:54:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】深入理解指针（一篇让你完全搞懂指针）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、什么是指针？</h2> 
<h3>1.1指针概念</h3> 
<blockquote> 
 <p>本质上<strong>指针就是地址</strong>，口语中所说的<strong>指针</strong>，其实就是<strong>指针变量</strong>，指针变量是用来存放地址的一个指针。</p> 
</blockquote> 
<p> 我们知道计算机上CPU（中央处理器）在处理数据的时候，需要的数据是内存中读取的，处理后的数据也会放回内存中。</p> 
<p>电脑上内存是8CB/16GB/32GB等，这些内存空间如何高效的管理？</p> 
<p>其实就是<strong>把内存划分成一个一个的内存单元</strong>，每个内存单元的大小取1字节，<strong>每个内存单元都有一个编号</strong>。</p> 
<p>有了内存单元的编号，CPU就可以快速找到一个内存空间。</p> 
<p><span style="color:#fe2c24;"><strong>内存单元的编号 == 地址 == 指针</strong></span></p> 
<p></p> 
<h2>二、指针变量和地址</h2> 
<h4>2.1 取地址操作符（&amp;）</h4> 
<p>在C语言中，创建变量其实就是向内存申请空间</p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/7f/50/bFQYaZ9E_o.png" width="1200"></p> 
<p> 上述代码创建整型变量a，向内存申请了4个字节，用于存放整数10，其中每个字节都有地址，上图中4个字节地址分别是：</p> 
<blockquote> 
 <p>0x00F5FCEC <br> 0x00F5FCED <br> 0x00F5FCEE <br> 0x00F5FCEF</p> 
</blockquote> 
<p><strong> 那我们如何得到a的地址？</strong>   </p> 
<p>这里就用到取地址操作符（&amp;）</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
	int a = 10;
	&amp;a;
	printf("%p\n", &amp;a);
	return 0;
}</code></pre> 
<p> 上述代码，运行之后，打印：0x00F5FCEC </p> 
<p>&amp;a取出来的是a所占4个字节中地址最小的字节的地址。</p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/19/be/6zFGAGwm_o.png" width="1179"></p> 
<h3> 2.2 指针变量和解引用操作符（*）</h3> 
<h4>2.2.1 指针变量</h4> 
<p>我们通过取地址操作符（&amp;）拿到的地址是一个数组，比如：0x00F5FCEC，这个数组有时候需要存储起来，方便后期使用，那我们就可以<span style="color:#fe2c24;">把地址值存放在<strong>指针变量</strong>中</span>。</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/21/7d/6AWnx8aP_o.png" width="1200"></p> 
<p><span style="color:#0d0016;"> </span><strong><span style="color:#0d0016;">总结：</span><span style="color:#fe2c24;">变量a和指针变量pa都有各自的地址，只是把变量a的地址存放在指针变量pa里。</span></strong></p> 
<blockquote> 
 <p><strong> 指针变量也是一种变量</strong>，这种变量就是用来存放地址的，存放在指针变量中的值都会理解为地址</p> 
</blockquote> 
<h5> </h5> 
<h4>2.2.2 解引用操作符（*）</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
	int a = 10;
	int* pa = &amp;a;//取出a地址，并存放在指针变量中
	//①int说明pa指向的对象是int类型 ②*说明pa是指针变量
    *pa=100;
    printf("%d",*pa);
	return 0;
}</code></pre> 
<p> 输出：100</p> 
<blockquote> 
 <p><strong>①*</strong>的作用是引用指针指向的变量值，<strong>引用其实就是引用该变量的地址</strong>，<strong>“解”就是把该地址对应的东西解开</strong>，解出来，就像打开一个包裹一样，<strong>那就是该变量的值了</strong>，所以称为“解引用”。 也就是说，<span style="color:#fe2c24;"><strong>解引用是返回内存地址中对应的对象</strong></span>。</p> 
 <p>解引用也可以改变该变量的数值。</p> 
 <p></p> 
 <p>②需要注意的是，在变量声明的时候，*不能当做解引用使用，只是表示你声明的变量是一个指针类型。</p> 
</blockquote> 
<p> </p> 
<h4>2.3 指针变量的大小</h4> 
<p><img alt="" height="943" src="https://images2.imgbox.com/19/fe/cfACLO9V_o.png" width="1149"></p> 
<blockquote> 
 <p><strong>指针变量的大小取决于地址的大小</strong></p> 
 <p>①32平台下地址是32bit位，指针变量大小是4字节</p> 
 <p>②64平台下地址是64bit位，指针变量大小是8字节</p> 
 <p>注意：指针变量的大小和类型无关，只要指针类型的变量，在相同平台下，大小都是相同的。</p> 
</blockquote> 
<p> </p> 
<h2>三、指针类型变量的意义</h2> 
<h3>3.1 指针解引用</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
	int n = 0x11223344;
	int* p1 = &amp;n;
	*p1 = 0;
	return 0;
}</code></pre> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
	int n = 0x11223344;
	char* p2 = (char *) &amp; n;
	*p2 = 0;
	return 0;
}</code></pre> 
<p></p> 
<p><strong>任务：</strong>上面两段代码，调试观察内存的变化，对比发现了什么？</p> 
<p><strong>发现：</strong>第一段代码会将n的4个字节全部改为0；但是第二段代码只是将n的第一个字节改为0。</p> 
<blockquote> 
 <p>结论：指针类型决定了对指针解引用的时候有多大权限（一次可以操作几个字节）。</p> 
 <p>比如：char*的指针解引用只能访问一个字节，而int*的指针解引用就可以访问4个字节。</p> 
</blockquote> 
<h3> 3.2 指针 +- 整数</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
	int n = 10;
	char* pc = (char*)&amp;n;
	int* pi = &amp;n;
	printf("&amp;n   = %p\n", &amp;n);
	printf("pc   = %p\n", pc);
	printf("pc+1 = %p\n", pc+1);
	printf("pi   = %p\n", pi);
	printf("pi+1 = %p\n", pi+1);
}</code></pre> 
<p> 运行结果：</p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/33/12/oyE8t3Fn_o.png" width="772"></p> 
<blockquote> 
 <p> 结论：指针类型决定了指针向前或者向后走一步有多大（距离)。</p> 
</blockquote> 
<h3> 3.3 void* 指针</h3> 
<blockquote> 
 <p>void* 类型，无具体类型的指针（泛型指针），void* 类型的指针大部分使用在<strong>函数参数的部分</strong>，用来接收不同类型数据的地址。</p> 
 <p></p> 
 <p>但是void* 类型的指针不能直接进行指针的+-整数和解引用运算。</p> 
</blockquote> 
<p> </p> 
<h2>四、const修饰指针</h2> 
<blockquote> 
 <p><img alt="" height="25" src="https://images2.imgbox.com/b5/50/6buS4bRH_o.png" width="25">在C语言中，const是constant的缩写，翻译是“恒定不变的”。它是定义只读变量的关键字。或者说const是定义常变量的关键字</p> 
 <p><img alt="" height="25" src="https://images2.imgbox.com/ef/4f/7x3my3XP_o.png" width="25">const修饰的变量被称为常变量，<strong>具有常属性，但是本质上还是变量</strong>。</p> 
 <p><img alt="" height="25" src="https://images2.imgbox.com/6e/bc/rSosSvzs_o.png" width="25">保护被修饰的东西，防止被意外修改，<strong>增强程序的健壮性</strong>。</p> 
 <p><img alt="" height="25" src="https://images2.imgbox.com/21/84/heyEu7BG_o.png" width="25"><strong>提高程序的运行效率</strong>。编译器通常不为普通const常量分配存储空间，而是将他们保护在符号表中，使得它成为一个编译期间的常量，没有存储和读取内存的操作，使得它的运行效率也很高。</p> 
</blockquote> 
<h3> 4.1 const int* p (int const *p)和int *const p的区别</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
void test1()
{
	int n = 10;
	int m = 10;
    /* const放在*左边，修饰的是*p，表示的是指针指向的内容，不能通过指针来改变，
    但是指针变量本身是可以被修改的 */
	const int* p = &amp;n;//const放在*的左边
	*p = 20;//err   *p不可改变(指针指向的内容不能被修改)
	p = &amp;m; //ok    指针变量p可以修改
}
void test1()
{
	int n = 10;
	int m = 10;
    /* const放在*右边，修饰的是指针变量p本身，表示的是指针变量不可以被修改，
    但是指针指向的内容是可以被修改的 */
	int* const p = &amp;n;//const放在*的右边
	*p = 20;//ok     //指针指向的内容可以被修改
	p = &amp;m; //err    p不可改变（指针变量p不能被修改）
}
int main()
{
	test1();//const放在*的右边
	test2();//const放在*的左边
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong> 总结：</strong></p> 
 <p>①const int* p (int const *p)：const放在*的左边。<strong>修饰的是*p，*p（指针指向的内容）不能修改</strong>；p(指针变量本身)可以修改</p> 
 <p>②int * const p :const放在*的右边。<strong>修饰的是p，p(指针变量本身)不可以修改</strong>；*p（指针指向的内容）可以修改。</p> 
 <p>③int const * const p (const int * const p)：*的左右两边都有const，<strong>修饰的是*p和p，所以*p和p都不能被修改</strong>。</p> 
</blockquote> 
<p> </p> 
<h2>五、指针运算 </h2> 
<h3>5.1 指针 +- 整数</h3> 
<p>数组在内存中是连续存放的，只要知道第一个元素的地址，顺藤摸瓜就可以找到后面所有元素。</p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/45/e8/RHwRzgM5_o.png" width="1200"></p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
	int* p = arr[0];
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i &lt; sz; i++)
	{
		printf("%d ", *(p + i)); //p+i 这就是指针的+-整数  *(p+i)相当于arr[i]
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p> <strong>指针p+i，表示指针向后移动i个单位</strong>（每个单位为指针p的类型所占的字节数），指向原先指向的元素后的第i个元素。若p指向arr[0]，则p+i指向arr[i]；</p> 
</blockquote> 
<h3>5.2 指针 - 指针</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int my_strlen(char* s)
{
	//指针-指针
	char* p = s;
	while (*p != '\0')
		p++;
	return p - s;  //返回结束指针地址-开始指针地址 的差值     得到的就是指针之间元素的个数
	
}
int main()
{
	printf("%d\n", my_strlen("abc"));
	return 0;
}</code></pre> 
<blockquote> 
 <p> 两个指针相减，得到的就是指针之间的元素个数。指针s是字符串首地址，第一次p=s,随着p++，p指向最后一个字符后面的位置。所以p-s，就得到字符串的个数。</p> 
</blockquote> 
<h3>5.3 指针的关系运算</h3> 
<pre><code class="language-cs">int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
	int* p = &amp;arr[0];
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	while (p &lt; arr + sz) //指针的大小比较
	{
		printf("%d ", *p);
		p++;
	}
	return 0;
}
</code></pre> 
<blockquote> 
 <p> 指针的比较，依赖于指针所指向的两个元素的相对位置，若指针p指向arr[i]，指针q指向arr[j],p和q的结果由i和j的大小决定。</p> 
</blockquote> 
<h3>5.4 指针运算笔试题</h3> 
<p>C语言的间接寻址运算符<code>*</code>常和<code>++</code>或<code>--</code>运算符一起使用，具有以下四种不同的形式：</p> 
<table border="1" cellpadding="1" cellspacing="1"><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>*p++   或   *(p++)</td><td>首先计算表达式的值为*p，然后p自增1</td></tr><tr><td>(*p)++</td><td>首先计算表达式的值为*p，然后*p自增1</td></tr><tr><td>*++p  或  *(++p)</td><td>首先p自增1，然后计算*p</td></tr><tr><td>++*p  或  ++(*p)</td><td>首先*p自增1，然后计算表达式的值为(*p)</td></tr></tbody></table> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#define N 10
int main()
{
    int a[10] = {0,1,2,3,4,5,6,7,8,9};
    int temp = 0;
 
    int *p = a;
    printf("p的初始值为%p, *p值为%d\n", p, *p);
    temp = *p++;
    printf("*p++的值为%d, 运算后p的值为%p, *p的值为%d\n\n", temp, p, *p);
 
    printf("p的初始值为%p, *p值为%d\n", p, *p);
    temp = *(p++);
    printf("*(p++)的值为%d, 运算后p的值为%p, *p的值为%d\n\n", temp, p, *p);
 
    printf("p的初始值为%p, *p值为%d\n", p, *p);
    temp = (*p)++;
    printf("(*p)++的值为%d, 运算后p的值为%p, *p的值为%d\n\n", temp, p, *p);
 
    printf("p的初始值为%p, *p值为%d\n", p, *p);
    temp = *++p;
    printf("*++p的值为%d, 运算后p的值为%p, *p的值为%d\n\n", temp, p, *p);
 
    printf("p的初始值为%p, *p值为%d\n", p, *p);
    temp = *(++p);
    printf("*(++p)的值为%d, 运算后p的值为%p, *p的值为%d\n\n", temp, p, *p);
 
    printf("p的初始值为%p, *p值为%d\n", p, *p);
    temp = ++*p;
    printf("++*p的值为%d, 运算后p的值为%p, *p的值为%d\n\n", temp, p, *p);
 
    printf("p的初始值为%p, *p值为%d\n", p, *p);
    temp = ++(*p);
    printf("++(*p)的值为%d, 运算后p的值为%p, *p的值为%d\n\n", temp, p, *p);
 
    return 0;
}</code></pre> 
<p>运行结果示例：</p> 
<blockquote> 
 <p>p的初始值为005AFE5C, *p值为0<br> *p++的值为0, 运算后p的值为005AFE60, *p的值为1</p> 
 <p></p> 
 <p>p的初始值为005AFE60, *p值为1<br> *(p++)的值为1, 运算后p的值为005AFE64, *p的值为2</p> 
 <p></p> 
 <p>p的初始值为005AFE64, *p值为2<br> (*p)++的值为2, 运算后p的值为005AFE64, *p的值为3</p> 
 <p></p> 
 <p>p的初始值为005AFE64, *p值为3<br> *++p的值为3, 运算后p的值为005AFE68, *p的值为3</p> 
 <p></p> 
 <p>p的初始值为005AFE68, *p值为3<br> *(++p)的值为4, 运算后p的值为005AFE6C, *p的值为4</p> 
 <p></p> 
 <p>p的初始值为005AFE6C, *p值为4<br> ++*p的值为5, 运算后p的值为005AFE6C, *p的值为5</p> 
 <p></p> 
 <p>p的初始值为005AFE6C, *p值为5<br> ++(*p)的值为6, 运算后p的值为005AFE6C, *p的值为6</p> 
</blockquote> 
<p></p> 
<h2>六、野指针</h2> 
<blockquote> 
 <p>概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p> 
</blockquote> 
<h3> 6.1 野指针的成因</h3> 
<blockquote> 
 <p>① 指针未初始化</p> 
 <p>② 指针越界访问</p> 
 <p>③ 指针指向的空间释放</p> 
</blockquote> 
<h3> 6.2 如何规避野指针</h3> 
<blockquote> 
 <p>① 指针初始化</p> 
 <p>② 小心指针越界</p> 
 <p>③ 指针变量不再使用，及时置NULL，指针使用之前检查有效性</p> 
 <p>④ 避免返回局部变量的地址</p> 
</blockquote> 
<p></p> 
<h2>七、指针的使用和传址调用</h2> 
<h3>7.1 strlen的模拟实现</h3> 
<p>库函数strlen的功能是求字符串长度，统计的是字符串\0之前的字符个数。</p> 
<p>库函数原型：</p> 
<blockquote> 
 <p>size_t strlen ( const char* str );</p> 
</blockquote> 
<p> 模拟实现，从起始地址开始向后逐个字符的遍历，只要不是\0字符，计算器就+1，直到\0就停止。</p> 
<pre><code class="language-cs">int my_strlen(const char* s)
{
	int count = 0;
	while (*s != '\0')
	{
		count++;
		s++;
	}
	return count++;
}
int main()
{
	int len = my_strlen("abcdef");
	printf("%d\n", len);
	return 0;
}</code></pre> 
<h3>7.2 传值调用和传址调用</h3> 
<p><strong>任务：</strong>写一个函数，交换两个变量的值</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
void Swap(int x, int y)
{
	int tmp = x;
	x = y;
	y = tmp;
}
int main()
{
	int a = 10;
	int b = 20;
	printf("交换之前a = %d b = %d\n", a, b);
	Swap(a, b);
	printf("交换之后a = %d b = %d\n", a, b);
}</code></pre> 
<p> 运行结果，如下：<img alt="" height="150" src="https://images2.imgbox.com/31/6b/aLOeLVLR_o.png" width="1060"></p> 
<blockquote> 
 <p>结论：实参传递给形参的时候，形参会单独创建一份临时空间来接收实参，对形参修改不影响实参。</p> 
 <p>所以Swap()失败了。</p> 
</blockquote> 
<p><strong> 答案：</strong>使用指针，在main函数中将a和b的地址传递给Swap函数，Swap函数里通过地址间接的操作main函数中的a和b，并达到交换的效果。</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
void Swap(int *x, int *y)
{
	int tmp = 0;
	tmp = *x;
	*x = *y;
	*y = tmp;
}
int main()
{
	int a = 10;
	int b = 20;
	printf("交换之前a = %d b = %d\n", a, b);
	Swap(&amp;a, &amp;b);
	printf("交换之后a = %d b = %d\n", a, b);
}</code></pre> 
<p>运行结果，如下：</p> 
<p><img alt="" height="104" src="https://images2.imgbox.com/fa/f1/Q6xMXG23_o.png" width="902"></p> 
<p> 将变量的地址传给函数，这种函数调用方式叫：<strong>传址调用</strong>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/504ce31b6b44ffea58a3b635da29808d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spark概述及Scala搭建操作步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/407fbc2a3d25e97edee8c6afc4889048/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】string类的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>