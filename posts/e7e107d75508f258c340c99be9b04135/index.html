<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手撕Python之序列类型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e7e107d75508f258c340c99be9b04135/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="手撕Python之序列类型">
  <meta property="og:description" content="1.列表---list 索引的使用 当我们有一个数据的时候，我们怎么将这个数据存储到程序呢？
我们定义一个变量，将数据存储在变量中
那么如果有100个数据呢？要定义100个变量吗？
我们是可以用列表这个东西进行多个数据的存放
列表的定义：[ ]
空列表：[ ]
列表：[元素1，元素2，元素3 ]
列表中的内容叫做元素，元素与元素之间要用逗号进行分隔
#编辑模式 li=[]#空列表 print(type(li)) #交互模式 &lt;class &#39;list&#39;&gt;#列表的意思 存放多个数据的列表：
li=[1234,&#39;abcd&#39;,12.45] print(type(li)) 那么我们现在如何从这个列表里面拿取我们想要的元素呢？
我们可以通过列表的索引来取得对应位置上的值
使用方式：列表序列[索引]
注意：
1.索引值是从0开始的
2.负索引值就是从列表尾部往前数
3.索引取值超过长度就会报错
这个索引在C/C&#43;&#43;中就是下标
列表对应C/C&#43;&#43;就是数组
索引值的使用方式：
#编辑模式 li=[1234,&#39;abcd&#39;,12.45] print(type(li)) print(li[0]) print(li[1]) print(li[2]) #交互模式 &lt;class &#39;list&#39;&gt; 1234 abcd 12.45 除了正索引我们还有负索引
负索引是怎么使用的呢？
我们是从右往左开始进行的
如果使用负索引的话，最右边的下标是-1
然后从左到右一次减小1位
负索引的使用：
#编辑模式： li=[1234,&#39;abcd&#39;,12.45] print(type(li)) print(&#34;正索引&#34;) print(li[0]) print(li[1]) print(li[2]) print(&#34;负索引&#34;) print(li[-1]) print(li[-2]) print(li[-3]) #交互模式 正索引 1234 abcd 12.45 负索引 12.45 abcd 1234 正索引：从左往右（从0开始，依次变大）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-02T18:12:42+08:00">
    <meta property="article:modified_time" content="2024-09-02T18:12:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手撕Python之序列类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a href="https://flowus.cn/5ef52c82-8665-41c6-8d28-2dc9be9fd69e" rel="nofollow" title="1.列表---list"><img alt="" src="https://images2.imgbox.com/95/e3/VkxvRUW3_o.gif"><br> 1.列表---list</a></h2> 
<h3>索引的使用</h3> 
<p>当我们有一个数据的时候，我们怎么将这个数据存储到程序呢？</p> 
<p>我们定义一个变量，将数据存储在变量中</p> 
<p>那么如果有100个数据呢？要定义100个变量吗？</p> 
<p>我们是可以用列表这个东西进行多个数据的存放</p> 
<p>列表的定义：[ ]</p> 
<p>空列表：[ ]</p> 
<p>列表：[元素1，元素2，元素3 ]</p> 
<p>列表中的内容叫做元素，元素与元素之间要用逗号进行分隔</p> 
<pre><code>#编辑模式
li=[]#空列表
print(type(li))
#交互模式
&lt;class 'list'&gt;#列表的意思
</code></pre> 
<p>存放多个数据的列表：</p> 
<pre><code>li=[1234,'abcd',12.45]
print(type(li))
</code></pre> 
<p>那么我们现在如何从这个列表里面拿取我们想要的元素呢？</p> 
<p>我们可以通过列表的索引来取得对应位置上的值</p> 
<p>使用方式：列表序列[索引]</p> 
<p>注意：</p> 
<p>1.索引值是从0开始的</p> 
<p>2.负索引值就是从列表尾部往前数</p> 
<p>3.索引取值超过长度就会报错</p> 
<p>这个索引在C/C++中就是下标</p> 
<p>列表对应C/C++就是数组</p> 
<p>索引值的使用方式：</p> 
<pre><code>#编辑模式
li=[1234,'abcd',12.45]
print(type(li))

print(li[0])
print(li[1])
print(li[2])
#交互模式
&lt;class 'list'&gt;
1234
abcd
12.45
</code></pre> 
<p>除了正索引我们还有负索引</p> 
<p>负索引是怎么使用的呢？</p> 
<p>我们是从右往左开始进行的</p> 
<p>如果使用负索引的话，最右边的下标是-1</p> 
<p>然后从左到右一次减小1位</p> 
<p>负索引的使用：</p> 
<pre><code>#编辑模式：
li=[1234,'abcd',12.45]
print(type(li))
print("正索引")
print(li[0])
print(li[1])
print(li[2])

print("负索引")
print(li[-1])
print(li[-2])
print(li[-3])
#交互模式
正索引
1234
abcd
12.45
负索引
12.45
abcd
1234
</code></pre> 
<p>正索引：从左往右（从0开始，依次变大）</p> 
<p>负索引：从右往左（-1开始，依次减小）</p> 
<p>对于这个列表中的12.45我们是有两种方式进行获取的</p> 
<p>li[2] li[-1] 这两种表达都是指向12.45</p> 
<p>正索引一般是拿比较靠前的元素的数据</p> 
<p>负索引一般是拿比较靠后的元素的数据</p> 
<p>通过len(序列)我们能查看序列的元素个数</p> 
<h3 id="index">index获取列表中对应元素的索引值</h3> 
<p>但是对于数组多的元素我们能不能通过代码的方式找到我么想要的那个元素的索引值呢？</p> 
<p>我们可以通过index来寻找对应元素的索引值</p> 
<p>index的使用方式：</p> 
<pre><code>#编辑模式
li=[1234,'abcd',12.45]
print(li.index("abcd"))
print(li.index(12.45))
#交互模式
1
2
</code></pre> 
<p>通过这种方式能返回对应元素的索引值</p> 
<p>这么我们就能在一个数组中进行元素的寻找了</p> 
<p>返回的是列表中我们想要查找的元素的索引值</p> 
<h3 id="-1" style="background-color:transparent;">列表的切片--获取列表中一定范围的元素</h3> 
<p>通过上面的方法我们能进行一个元素的寻找</p> 
<p>但是假如我们想一次拿多个元素怎么办呢？还是按照这样一个一个进行查找吗？</p> 
<p>其实列表式可以根据一个范围来取值的，这称为切片</p> 
<p>使用方式：列表名[开始索引：结束索引：步长]</p> 
<p>开始索引默认值是0</p> 
<p>结束索引默认值到最后一个元素</p> 
<p>步长默认为1</p> 
<p>注意：</p> 
<p>1.切片是两个范围之间取值，且后面的数取不到</p> 
<p>2.切片时范围超过也没有关系</p> 
<p>3.切片时还可以指定步长，不指定时，步长默认为1</p> 
<p>我们定义了结束索引值，我们取到的值是不包含结束索引值指向的元素的</p> 
<p>[开始索引值，结束索引值)</p> 
<p>因为这个开始索引值和结束索引值存在默认值</p> 
<p>那么我们可以是不写这两个的，我们光写个结束索引值就行了</p> 
<p>但是一开始的开始索引值和结束索引值之间的冒号不能省略了</p> 
<p>切片获取列表中某个范围的元素：</p> 
<pre><code>#从列表中获取多个元素，我们通过切片

li=[1,2,3,4,5,6,7,8,9]

print(li[0:3:1])
#[1, 2, 3]
#我们这里只获取了1，1，2这三个元素，没有获取到4
#但是4的索引值是3啊
#为什么我们没有获取到呢？

#因为我们在取这个范围的元素的时候，我们是不包含这个结束索引指向的元素的

print(li[:3])

#步长的使用
#现在我们想获取1 3 5 7 9
#我们是可以通过步长进行获取的
print(li[:8:2])

#[1, 3, 5, 7]

#但是我们这里仅仅获取到了7，并没有拿到结束索引值指向的9
print(li[:9:2])

#[1, 3, 5, 7, 9]

#但是我们将这个结束索引值进行增加我们就拿到了最后的那个值9

#这里的步长就是元素与元素之间的间隔大小，我们这里的是2

#我们使用切片的时候结束索引超出了是没问题的
#但是我们直接使用索引的话，索引超出了范围是会报错的


print(li[::2])
#我们这里的话不写开头和结尾的索引值的话，我们也是能拿到这个列表中满足步长为2的元素的
#[1, 3, 5, 7, 9]
</code></pre> 
<p>我们使用切片的时候结束索引超出了是没问题的</p> 
<p>但是我们直接使用索引的话，索引超出了范围是会报错的</p> 
<p>我们使用默认开始索引和结束索引我们也是能获取到这个列表中满足步长的元素的</p> 
<p>对于获取一个范围没有规律的元素的方法：</p> 
<pre><code>#现在我们想获取1 3 4 6
#这种就没有什么规律了，那么我们怎么进行获取呢？
#但是分开看的话，1和3分隔2，4和6分隔2
#我们可以使用加号进行拼接，列表+列表是拼接，字符串+字符串是拼接
print(li[0:3:2])#通过这个我们能拿到[1, 3]
print(li[3:6:2])#通过这个我们拿到了[4, 6]

#那么我们现在如何进行拼接操作呢？
print(li[0:3:2]+li[3:6:2])#因为列表+列表是拼接，那么我们将两个获取到的直接进行相加
</code></pre> 
<p>对于我们获取一个范围内分布有规律的元素我们可以设置步长</p> 
<p>但是我们获取一个范围内排布没有规律的元素</p> 
<p>我们可以将这个范围进行分割，分割为多个小范围列表，然后进行拼接，就能得到我们想要的列表了</p> 
<h3 id="-2">列表的方法</h3> 
<p>列表的方法包括增删查改</p> 
<h4 id="-3">列表的增</h4> 
<p>对于列表的增，我们存在三种方法：append extend insert</p> 
<p>append的中文就是追加的意思</p> 
<p>就是在列表的末尾进行元素的追加</p> 
<p>entend就是扩展</p> 
<p>insert就是插入的意思，在某一个地方进行元素的插入</p> 
<h5 id="1append">1.append的使用方法</h5> 
<p>列表.append()</p> 
<p>append的使用方法---追加：</p> 
<pre><code>li=['苹果']
#append直接在列表的尾部进行元素的插入的    就是追加
li.append("香蕉")
print(li)
#['苹果', '香蕉']
li.append("西瓜")
print(li)
['苹果', '香蕉', '西瓜']
</code></pre> 
<h5 id="insert">insert的使用方法</h5> 
<p>列表.insert(插入位置的索引值，要插入的元素)----进行元素的插入，插队</p> 
<p>insert的使用方法---插入到给定的索引值对应的元素的前面：</p> 
<pre><code>#现在我想将桃子查到香蕉的前面
li.insert(1,"桃子")
print(li)
#['苹果', '桃子', '香蕉', '西瓜']
#这里的元素索引就是我们要插入的位置的后面的那个元素的索引
#我们使用insert将元素插入到我们想要的元素的前面
</code></pre> 
<h5 id="extend">extend(序列类型)</h5> 
<p>不能是数字或者是浮点数</p> 
<p>extend的作用是将序列拆开，一个内容为一个元素进行添加</p> 
<p>主要是将一个我们指定的队列追加到这个队列后面去</p> 
<p>extend的使用方法：</p> 
<pre><code>li.extend("飞机")
print(li)
#['苹果', '桃子', '香蕉', '西瓜', '飞', '机']
#我们这里的飞机从一个元素变成了两个元素

#其实extend的作用是将序列拆开，一个内容为一个元素进行添加
#而且我们这里非要在里面添加序列类型
#不能是数字，一定要是序列类型
#序列类型是可以迭代的，但是整型是不可以的
#li.extend(12)，这种写法就会报错

#extend后面能添加的序列类型有：字符串、列表、元组
#数字整型浮点型是不能写入括号的


li.extend(li)
print(li)
#['苹果', '桃子', '香蕉', '西瓜', '飞', '机', '苹果', '桃子', '香蕉', '西瓜', '飞', '机']
</code></pre> 
<h4 id="-4">列表的改</h4> 
<p>列表[索引]=新值</p> 
<p>将列表中对应的索引对应的值进行新的赋值</p> 
<p>列表元素的修改：</p> 
<pre><code>li=['苹果', '桃子', '香蕉', '西']
#现在我们想将西这个字符进行修改，修改为“西瓜”
li[-1]="西瓜"
print(li)
#['苹果', '桃子', '香蕉', '西瓜']

print(li.index("西瓜"))
</code></pre> 
<h4 id="-5">列表的查</h4> 
<p>列表名.index("要查找的数据")</p> 
<p>使用index进行元素的索引的查找：</p> 
<pre><code>#如果我们现在想将桃子改成飞机，但是我们不知道桃子在哪里
#我们使用index进行查找
print(li.index("桃子"))
li[li.index("桃子")]="飞机"
print(li)

#1   桃子的索引值
#['苹果', '飞机', '香蕉', '西瓜']
</code></pre> 
<p>通过索引值我们能找到元素</p> 
<p>通过列表的切片操作我们能找到一定范围的元素</p> 
<p>通过我们的index我们能找到对应元素的索引值</p> 
<h4 id="-6">列表的删</h4> 
<h5 id="1pop">1.列表.pop(索引)</h5> 
<p>删除列表中指定索引的值</p> 
<p>我们根据对应的索引值将这个元素进行删除</p> 
<p>列表.pop(对应元素的索引值）：</p> 
<pre><code>#将4删除（如果存在多个的话我们只能删除最前面的）
li=[1,2,3,4,5,1,2,3,4,5]
li.pop(li.index(4))
print(li)
#[1, 2, 3, 1, 2, 3, 4, 5]
li.pop()
print(li)#我们这里没有指定索引，那么就是删除最后一个
#[1, 2, 3, 1, 2, 3, 4,]
</code></pre> 
<p>我们不指定索引值的话，那么默认就是将最后一个元素删除掉</p> 
<h5 id="2remove">2.列表.remove(元素)</h5> 
<p>删除列表中指定的值（如果存在多个的话我们是只能删除最前面的这个值，不能你全部删除掉）</p> 
<p>列表.remove(对应的元素)：</p> 
<pre><code>li=[1,2,3,4,5,1,2,3,4,5]
li.remove(5)
print(li)
#[1, 2, 3, 4, 1, 2, 3, 4, 5]
</code></pre> 
<h5 id="3del">3.del 序列</h5> 
<p>直接将序列从内存中删除掉</p> 
<p>如果我们再想找到这个序列的话是找不到了</p> 
<p>也是无法打印的，就说我们未定义</p> 
<pre><code>del li
print(li)
'''
Traceback (most recent call last):
  File "C:\Users\27890\Desktop\序列类型（列表、元组）.py", line 158, in &lt;module&gt;
    print(li)
NameError: name 'li' is not defined
'''
</code></pre> 
<h5 id="4">4.列表的清空操作</h5> 
<p>列表.clear()---直接清空列表中的元素，得到一个空列表</p> 
<p>clear的使用：</p> 
<pre><code>li1=[1,2,3,4,5,1,2,3,4,5]
li1.clear()
print(li1)
#[]
</code></pre> 
<h4 id="-7">列表的嵌套---二维列表</h4> 
<p>二维列表元素的获取：</p> 
<pre><code>li=[[12,"小明"],[13,"小红"],[15,"凯子"]]
for i in li:#这个循环后面的序列
    print(i)#每次打印列表中的一个元素

#我们现在想要获取小明怎么写代码呢？
print(li[0][1])
#小明
</code></pre> 
<p>列表中还存在多个列表就是列表的嵌套</p> 
<h4 id="-8">列表中的一些适用的方法：</h4> 
<h5 id="1index">1.列表.index()----查找某个元素的索引值</h5> 
<h5 id="2count">2.列表.count()----计算列表中某个元素的个数</h5> 
<pre><code>li=['苹果', '飞机', '香蕉', '西瓜']
print(li.count("西瓜"))
#1
</code></pre> 
<h5 id="3len">3.len(序列)----计算出某个列表的元素的个数</h5> 
<pre><code>li=['苹果', '飞机', '香蕉', '西瓜']

print(len(li))
#4
</code></pre> 
<p>下面的两个找最大最小值的函数一定要保证序列的里面的元素是一样的</p> 
<h5 id="4max">4.max(序列)---获取序列中的最大值</h5> 
<h5 id="5min">5.min(序列)---获取序列中的最小值</h5> 
<pre><code>li2=[1,5,6,8,9,1,20,56]

print(max(li2))
print(min(li2))
#56
#1
</code></pre> 
<h5 id="6reverse">6.reverse---倒序</h5> 
<p>列表.reverse()</p> 
<pre><code>li=[1, 1, 4, 5, 5, 5, 6, 8, 46]
li.reverse()
print(li)
#[46, 8, 6, 5, 5, 5, 4, 1, 1]
</code></pre> 
<h5 id="7sort">7.sort列表的排序功能</h5> 
<p>要确保列表中的类型都是同一个类型，不是一个类型的数据怎么比？比不了的</p> 
<p>默认的是从小到大的排序---升序</p> 
<pre><code>li=[1,5,6,8,4,1,5,46,5]
li.sort()
print(li)
#[1, 1, 4, 5, 5, 5, 6, 8, 46]
</code></pre> 
<p>如果想要降序的操作话，只需要两步</p> 
<p>第一步就是将数组进行排序--默认是升序</p> 
<p>然后我们使用reverse进行列表的元素的颠倒，然后就得到了降序的列表</p> 
<p>但是我们还有一种方式更快捷</p> 
<p>列表.sort(reverse=True/False)</p> 
<p>我们可以对reverse的调整，调整为这个列表倒不倒序</p> 
<p>因为sort的排序是从小到大的</p> 
<p>所以reverse的值默认是False</p> 
<p>那么我们就需要将reverse改成True</p> 
<p>在sort中对reverse进行调整实现倒序：</p> 
<pre><code>li=[1, 1, 4, 5, 5, 5, 6, 8, 46]
li.sort(reverse=True)
print(li)
#[46, 8, 6, 5, 5, 5, 4, 1, 1]
</code></pre> 
<p>当sort里面的reverse为True的时候就是我同意你去倒序了</p> 
<h5 id="8sorted">8.sorted</h5> 
<p>这个是临时排序</p> 
<p>我们的sort是永久排序，在列表上直接进行修改，对列表产生实质的永久的影响</p> 
<p>我们这里也是可以设置这个reverse参数</p> 
<p>不设置的话就是False</p> 
<p>这个sorted是不会在原列表上进行修改的</p> 
<p>是会生成一个新的列表</p> 
<p>这个新的列表就是基于原列表的修改的列表</p> 
<pre><code>li=[46, 8, 6, 5, 5, 5, 4, 1, 1]
li3=sorted(li,reverse=False)#这里默认是升序的
print(li3)
</code></pre> 
<p>临时排序默认打印出来的也是升序的列表</p> 
<p>临时排序sorted不会对排序的列表直接进行修改，而且生成一个新的列表</p> 
<p>永久排序sort会对排序的列表直接进行修改</p> 
<p>两种排序默认都是从小到大，升序</p> 
<p>如果想要变成降序的话，我们需要将reverse的参数进行修改，将默认的False改成True</p> 
<p>对于这些函数来说</p> 
<p>max min sum len 都是在括号内写序列的</p> 
<p>其他的就是在函数前面加上函数名+.然后就能进行调用了</p> 
<h2 style="background-color:transparent;"><a href="https://flowus.cn/165e70a5-c0a2-4b71-a424-8612a53e18e5" rel="nofollow" title="2.元组">2.元组</a></h2> 
<p>元组的定义</p> 
<p>空元组：（）</p> 
<p>有数据的元组：（元素1，元素2，元素3）</p> 
<p>有数据的列表：[元素1，元素2，元素3]</p> 
<p>元组和列表唯一的区别是外面的括号</p> 
<p>元组被称为不可以改变的列表</p> 
<p>我们存储多个数据的时候，这些数据是不能修改的数据，那么我们就能将这些数据存储在元组中</p> 
<pre><code>t=(1,2,3,4,5)
print(type(t))
#&lt;class 'tuple'&gt;
</code></pre> 
<p>如果只在元组只存在一个元素的时候，如果我们括号内只有一个元素的话</p> 
<p>那么我们打印这个元组的类型就是这个唯一一个元素的类型</p> 
<p>为了表示出这个是元组，我们需要在这个数据的后面加上逗号,</p> 
<p>加上了逗号就表示出这个类型是元组</p> 
<pre><code>t=(1,2,3,4,5)
print(type(t))
t1=(12)
#&lt;class 'tuple'&gt;
print(type(t1))
#&lt;class 'int'&gt;
t2=(12,)
print(type(t2))
#&lt;class 'tuple'&gt;
</code></pre> 
<p>如果元组里面仅有一个元素的话，我们一定要额外加一个逗号表示这个是元组</p> 
<p>不然编译器会认为我们只是将这个元素当度框出来</p> 
<p>因为元组和列表一样都是序列</p> 
<p>那么都存在索引以及切片操作</p> 
<p>元组的索引以及切片操作：</p> 
<pre><code>#切片
#序列[开始索引:结束索引:步长]
print(t[::2])
#(1, 3, 5)
</code></pre> 
<p>元组的数据是不能进行修改的</p> 
<p>如果强行修改的话会报错的</p> 
<p>如果一定要改怎么办呢？</p> 
<p>将元组转换为列表，进行修改，再转换回元组</p> 
<pre><code>li[0]='12'
t=tuple(li)
print(t)
#('12', 2, 3, 4, 5)
</code></pre> 
<h5>元组的拆包</h5> 
<p>元组可以同时赋值给多个变量，只要变量个数不超过元组长度，变量前面加上* 号则可以将多于元素都接受，并组成一个列表</p> 
<p>元素和变量个数要一致，不然会出现报错的</p> 
<pre><code>#拆包的过程：将元组拆开，将里面的元素分配给左边的变量
a,b,c=(1,2,3)
print(a,b,c,sep="\n")

#而且我们在拆包的过程中我们需要保证元祖中元素的个数和左边变量的个数要达到一致
#不然是会匹配不上从而出现报错

#元素个数和变量个数要一致，拆包的顺序也是从左到右
</code></pre> 
<p>我们在变量的前面加上*，那么这个变量就能接受元组中的多个数据</p> 
<p>并且是以列表类型进行存放的</p> 
<pre><code>a,b,*c=(1,2,3,4,5)
print(a,b,c,sep="\n")
'''
1
2
[3, 4, 5]

'''
</code></pre> 
<p>元祖没有增删改</p> 
<p>只有查找的方法</p> 
<p>反正涉及到改变元组的话的方法我们就不能使用</p> 
<h4>小题目</h4> 
<p>定义一个列表，存储分数</p> 
<p>分数分别有5位评委进行输入，去掉最高分，去掉最低分，求这位选手的平均值</p> 
<pre><code>'''
定义一个列表，存储分数
分数分别有5位评委进行输入，去掉最高分，去掉最低分，求这位选手的平均值
'''
scores=[]#定义一个空列表
for i in range(1,6):#循环将评委的分数写入
    score=eval(input(f'请输入第{i}位评委的分数：'))
    #将获取的分数append到列表中
    scores.append(score)
#每次循环就对score进行赋值，然后我们将这个值追加到之前创建的空列表里面

print("所有评委的分数为",scores)

#去掉最高分
scores.remove(max(scores))

#去掉最低分
scores.remove(min(scores))


avg=sum(scores)/len(scores)

print(f"选手的平均分是：{avg:.2f}")

#添加的方法有3种
'''
append--追加
insert---在指定位置插入元素
extend--添加序列
'''
'''
去掉最高分，去掉最低分
方法一：先排序，删除第一元素和最后一个元素
方法二：max()获取最高分，min()获取最低分

我们上面使用的就是方法二

那我们下面使用方法一进行操作下
'''

scores.sort()#排序
print(li)
li.pop(0)#删除第一个
li.pop(-1)#删除最后一个
print(li)
#我们现在已经去掉最低分和最高分了

#pop是删除索引对应的位置
#而remove是删除列表中值为这个数的数字


#平均值=总和/数量
'''
1.求总和
    1.通过循环遍历列表中的数据
    2.通过sum这个函数进行求和的操作
'''
sum_b=0
for i in scores:
    sum_b+=i

print(sum_b)
#那么我们现在就拿到了总和了

#后面就能进行平均值的求了
#我们通过len函数获取序列元素的个数
</code></pre> 
<h2><a href="https://flowus.cn/2a37088a-3157-4d39-9319-b054dc3ae234" rel="nofollow" title="3.字符串">3.字符串</a></h2> 
<h3>字符串基础操作</h3> 
<p>字符串也是属于列表的</p> 
<p>那么字符串也是有索引切片的操作的</p> 
<p>字符串索引切片的操作:</p> 
<pre><code>s="pyhton"
#索引---序列[索引]
print(s[-1])
#n

#切片---序列[开始索引：结束索引：步长]   不包含步长的
print(s[::2])
#pho
</code></pre> 
<p>字符串是不能进行修改的：</p> 
<pre><code>#能否将字符串中的数据进行修改呢？
s[0]='P'
print(s)
'''
Traceback (most recent call last):
  File "C:\Users\27890\Desktop\7.序列类（字符串）、散列类型（字典）.py", line 84, in &lt;module&gt;
    s[0]='P'
TypeError: 'str' object does not support item assignment
'''
#很明显是会报错的
#那么就说明字符串是不能进行修改的，和元组一样的
</code></pre> 
<h3>字符串的一些小操作</h3> 
<h4 id="replace">替换字符串内的数据--replace</h4> 
<p>如果真的需要对字符串进行修改的话</p> 
<p>方法是有的，但是所有的字符串的修改方式都是不会在原来的字符串上进行修改，都是返回一个新的字符串</p> 
<p>如果需要修改字符串，我们需要调用字符串内置的方法并且重新赋值</p> 
<p>replace 方法是字符串修改常用的方法，可替换原字符串中的字符，但是并不会修改原字符，只是会返回一个新的对象，字符串所有的修改方法都是如此，不会改变原字符串，会返回一个新的字符串</p> 
<p>replace的基础用法：</p> 
<p>replace(旧字符，新字符，替换次数)</p> 
<pre><code>#replace(旧字符，新字符，替换次数)
s.replace("p","P")
print(s)
#我们打印这个字符串发现并没有任何的修改

#因为这个修改的话是不对原字符串进行任何操作的
#仅仅是返回一个新的字符串，这个字符串就是被修改了的
b=s.replace("p","P")

print(b)
#Pyhton
#那么现在就是修改成功了
#对s进行重新赋值的操作
s=b
print(s)
#那么现在s里面的内容就被修改了
</code></pre> 
<p>如果我们没有设置替换次数的话，编译器会默认修改所有要替换的字符</p> 
<p>没有指定替换次数，那么编译器就会将这个字符串中我们提出要替换的字符的所有相同的字符都进行替换了</p> 
<p>默认是替换全部</p> 
<p>如果指定次数，那么就替换指定的次数</p> 
<p>对指定的次数进行替换：</p> 
<pre><code>s1="hahaha".replace("a","i")
print(s1)
#hihihi
#我们这里发现所有的a都被改成i了

#如果我们没有设置替换次数的话，编译器会默认修改所有要替换的字符

s2="hahaha".replace("a","i",1)
print(s2)
#hihaha
#我么还能规定了替换次数之后，那么编译器就仅仅只替换了第一个
</code></pre> 
<h4>字母的操作</h4> 
<h5 id="1title">1.title()---字符串中每个单词的首字母大写---标题形式</h5> 
<p>使用方法：字符串.title()</p> 
<p>title的使用方法，将字符串中每个单词的首字母进行大写的操作：</p> 
<pre><code>print("hi, my name is xiaoming".title())
#Hi, My Name Is Xiaoming
#title的使用方法：  字符串.title()
#将字符串中每个单词的首字母进行大写的操作
</code></pre> 
<h5 id="2upper">2.upper()---字符串中字母全部进行大写的操作</h5> 
<p>使用方法：字符串.upper()</p> 
<pre><code>print("Hi,name,123".upper())
#HI,NAME,123
</code></pre> 
<h5 id="3lower">3.lower()---字符串中字母全部进行小写的操作</h5> 
<p>使用方法：字符串.lower()</p> 
<pre><code>print("HI,NAME,123".lower())
#hi,name,123
</code></pre> 
<h5 id="4capitalize">4.capitalize()--将字符串中首元素的首字母进行大写的操作</h5> 
<pre><code>print("hi,name,123".capitalize())
#Hi,name,123
</code></pre> 
<h4>字符串中的对字母的判断操作</h4> 
<p>上面的操作都是对单词开头或者所有字母进行大小写的操作</p> 
<p>那么我们这里就是判断字符串中字母的操作实现了没</p> 
<p>下面的操作中一般都会有逗号，如果是判断字符串中是否全是字母的话，那么就会返回False</p> 
<p>因为逗号不是字母，逗号也是这个字符串的一员，也是这个字符串内的一个元素</p> 
<p>那么我们在判断的时候就会算上这个逗号</p> 
<h5 id="1isupper">1.isupper---判断字符串中字母是否进行大写的操作</h5> 
<pre><code>print("Hi,name,123".isupper())
#False
#因为这个字符串里面存在小写的字母，那么就说明这个字符串并没有进行大写的操作
</code></pre> 
<p>如果都是大写的话，那么就会返回True,如果存在小写的字母的话，那么就会返回False</p> 
<h5 id="2islower">2.islower()---判断字符串中字母是否全部进行了小写的操作</h5> 
<pre><code>print("HI,NAME,123".islower())
#False
</code></pre> 
<h5 id="3isdigit">3.isdigit()---判断字符串中的字符是否都是数字</h5> 
<pre><code>print("HI,NAME,123".isdigit())
#False
</code></pre> 
<h5 id="4isalpha">4.isalpha()---判断字符串中的字符是否都是字母</h5> 
<pre><code>print("HI,NAME".isalpha())
#False

print("HINAME".isalpha())
#True
</code></pre> 
<h3>字符串的切割</h3> 
<h4 id="1strip">1.strip--删除字符串左右两边指定的元素</h4> 
<p>strip(字符)---在字符串的左右两边删除指定字符，默认是空白字符</p> 
<pre><code>s=" hahaha"#这个字符串的开头有一个空格
print(s)
s1=s.strip()
print(s1)
#默认将左右两边的空格进行删除
'''
 hahaha
hahaha

'''
s1=s.strip("a")
print(s1)
'''
 hahah
我们这里没有删除空格，我们将左右两边的a进行删除了

我们的操作都是左右两边，不会对字符中间进行处理的
'''
</code></pre> 
<h4 id="2split">2.split---以字符串中的元素为基点来进行拆分</h4> 
<p>split可以对字符串进行切割，默认是以空格来作为分割符，切割之后的元素会放在一个列表当中</p> 
<p>默认是以空格为切割点的进行拆分</p> 
<pre><code>#split(字符，拆分次数)---按照指定字符对字符串进行拆分，默认是空白字符

print("my name is xiaoming".split())
'''
['my', 'name', 'is', 'xiaoming']
'''
#我们的这个函数是什么参数都没进行添加的
#那么默认就是按照空格进行拆分

#我们这里的句子是有三个空格的，那么通过这个拆分函数进行拆分之后
#那么就拆分成了四个元素组成的列表
</code></pre> 
<p>规定拆分的次数的情况：</p> 
<pre><code>print("my name is xiaoming".split(" ",2))
'''
['my', 'name', 'is xiaoming']
我们在这里设置了分隔符为空格，拆分的次数为2
然后最后面的那个空格就没有进行拆分了
我们拆了两次拿到了3个元素
'''

s="www.baidu.com"
#以点进行拆分，并且加以拆分次数
print(s.split(".",2))
'''
['www', 'baidu', 'com']
'''
s1="www.baidu.cn.com"
print(s1.split("."))#不加拆分次数，默认全部拆
'''
['www', 'baidu', 'cn', 'com']
'''
</code></pre> 
<p>不加拆分次数，默认全部拆</p> 
<h4 id="3join">3.join--拆分后的列表内的字符串的拼接以及列表中元素拼接成字符串的操作</h4> 
<p>通常拆分完之后我们可以使用join函数来指定特殊符号进行列表中字符串元素的拼接</p> 
<pre><code>#使用join进行拼接，使用我们指定的符号进行拆分后元素的拼接
print('*'.join(s1.split(".")))

'''
www*baidu*cn*com
'''
#使用方法就是："指定的符号".join(拆分好的列表)
</code></pre> 
<p>使用方法就是："指定的符号".join(拆分好的列表)</p> 
<p>对于列表中元素拼接成字符串的操作</p> 
<pre><code>#字符串转列表，修改元素之后再变回字符串的操作
s="hahahaha"
li=list(s)
print(li)
'''
['h', 'a', 'h', 'a', 'h', 'a', 'h', 'a']
字符串转列表的话会将每个字符转换为一个元素
'''

li[3]="p"
print(li)
'''
['h', 'a', 'h', 'p', 'h', 'a', 'h', 'a']
我们直接利用索引就能进行对应数据的修改了
'''
##s=str(li)
##print(s)
'''
交互模式下
s
"['h', 'a', 'h', 'p', 'h', 'a', 'h', 'a']"
说明我们已经转换成功了
'''

'''
我们利用类型的转换，将字符串先转换为列表，
然后之前字符串的每个字符就变成了列表的元素了
然后我们利用列表的索引值对元素进行修改的操作
修改完之后我们将这个列表转换为字符串
发现仅仅只是在这个列表外面加了一层引号，并没有做出什么实质性的改变
那么我们应该怎么做才能将修改后的列表变为原先那样的字符串呢？
'''
'''
这里我们提到了join函数这个概念
"连接符".join(序列)
作用就是将序列的元素用连接符连接成一个字符串
'''
s="".join(li)#因为原先的字符串内的字符之间是没有符号的，我们这里使用空字符
print(s)
'''
hahphaha
'''
#通过这种方法我们在改变数据之后我们就不需要再进行类型的转换的操作了

#我们直接将列表中的单个元素拼接在一起形成一个字符串

#我们也是可以用其他的符号进行连接的
</code></pre> 
<p>我们先将字符串转类型为列表，然后利用索引对元素进行修改</p> 
<p>因为字符串是不能对数据进行修改的</p> 
<p>我们在修改完数据之后</p> 
<p>我们利用join函数对列表中的单个字符元素进行拼接</p> 
<p>我们可以选择指定的符号进行拼接，拼接完成之后这个类型就变成了字符串了</p> 
<p>对于这里我们选择的是空字符，，就是字符和字符之间是没有符号的，所以选择空字符</p> 
<h3>字符串的查找</h3> 
<h4 id="find">find</h4> 
<pre><code>#find(字符，开始索引，结束索引)---在指定的范围中查找字符，
#默认的话是在整个字符串中进行查找
#个人感觉像列表的切片操作

#我们这里打印的是返回值
print("python".find("p"))
#0
print("python".find("P"))
#-1

#如果找到了的话就返回0，没有找到的话就返回-1
#我们这里没找到的话是不会进行报错的


#index没有找到对应的数据的时候是会进行报错的
print("python".index("p"))
#0
print("python".index("P"))
#报错
</code></pre> 
<p>find没有在字符串中寻找数据的话是不会进行报错的</p> 
<p>但是index没有找到的话是会进行报错的</p> 
<p>find如果找到的话是会返回0</p> 
<p>没有找到的话返回-1</p> 
<p>index找到就返回0</p> 
<p>没有找到就报错</p> 
<pre><code>#交互模式
"python".find("o",1)
4
"python".find("o",2)
4
"python".find("o",5)
-1
</code></pre> 
<p>第二个参数就是我们寻找我们指定数据的开始位置的索引</p> 
<p>我们从这个索引对应的位置开始寻找我们要找的元素</p> 
<p>找到了就返回这个元素索引值</p> 
<p>没有找到就返回-1</p> 
<h3>字符串的转义</h3> 
<p>格式：以反斜杠（\）开头，后面跟一个或者几个字符</p> 
<p>意义：具有一些特殊含义，不同与字符原有的意义</p> 
<p>我们之前使用到了\n \t</p> 
<p>\n是换行</p> 
<p>\t是制表符</p> 
<pre><code>print("abcd\tefg")
'''
abcd    efg
中间的空格就是一个Tab的大小
'''
print("w\t*")
print("ww\t*")
print("www\t*")
print("wwww\t*")
print("wwwww\t*")


'''
w    *
ww    *
www    *
wwww    *
wwwww    *
\t会自动帮我们进行对齐，进行排版
'''
</code></pre> 
<p>自动对齐</p> 
<p>\---转义之后就是\</p> 
<p>\'以及\"的用法</p> 
<pre><code>'''
\' ----  '
\"----  "
在下面这种单引号包裹着双引号，双引号包裹着单引号的情况下，我们可以使用这种方式
进行隔离，保证不会因为引号匹配错误导致报错
'''

print('my name is \'xiaoming\'')
#my name is 'xiaoming'

print('my \'name\' is \'xiaoming\'')
my 'name' is 'xiaoming'
</code></pre> 
<p>\-----\</p> 
<pre><code>print("C:\\Temp\\BT_DFU_FW\\10\\DFU_SOP.pdf")

#我们这里的\本来表示的就是一个单纯的\
#但是可能会和后面的字母组合成为转义字符
#为了避免这种可能，我们在字符串引号前面加上一个字符r
#那么就会将这个字符串的转义给去掉

#还有一种方法就是上面的在原本的\前面再加上一个\
#\\   两个右斜杠转义过来就是一个\   那么就不会存在\与后面的字母进行配对成转义字符的情况了
</code></pre> 
<p>或者在字符串的引号前面加上r，那么这个字符串就会取消字符串的转义效果了</p> 
<p><img alt="" height="666" src="https://images2.imgbox.com/9c/66/DbHmReuf_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e5f9cd32a2bda5ba14dbf9da9942363/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【原创】edge-tts与基于mpv的edge-playback，使命令行和Python的Text To Speech唾手可得</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bcb64bc991238cfad8aab5efaad09b08/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">读懂以太坊源码(1)-目录结构说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>