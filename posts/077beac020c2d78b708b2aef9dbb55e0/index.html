<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React Query：高效管理API请求与缓存 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/077beac020c2d78b708b2aef9dbb55e0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="React Query：高效管理API请求与缓存">
  <meta property="og:description" content="React Query 是一个强大的状态管理库，专门用于处理数据获取、缓存和更新，尤其适合与 API 交互。它提供了许多高级特性，如自动缓存、离线状态管理、数据过期和重新获取等。
安装： npm install react-query 导入并配置 React Query： 在你的应用中，你需要导入 useQuery Hook 并设置配置对象。
import { useQuery } from &#39;react-query&#39;; const queryClient = new QueryClient(); 可以通过 QueryClientProvider 将 queryClient 包裹在你的根组件周围，以便在整个应用中使用。
import { QueryClient, QueryClientProvider } from &#39;react-query&#39;; const queryClient = new QueryClient(); function App() { return ( &lt;QueryClientProvider client={queryClient}&gt; {/* Your application */} &lt;/QueryClientProvider&gt; ); } 使用 useQuery Hook： 使用 useQuery 来发起 API 请求并管理响应数据。
function MyComponent() { const { data, status, error } = useQuery(&#39;myQueryKey&#39;, () =&gt; fetch(&#39;https://api.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-02T16:00:49+08:00">
    <meta property="article:modified_time" content="2024-06-02T16:00:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React Query：高效管理API请求与缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>React Query 是一个强大的状态管理库，专门用于处理数据获取、缓存和更新，尤其适合与 API 交互。它提供了许多高级特性，如自动缓存、离线状态管理、数据过期和重新获取等。</p> 
<h4><a id="_2"></a>安装：</h4> 
<pre><code class="prism language-bash">   <span class="token function">npm</span> <span class="token function">install</span> react-query
</code></pre> 
<h4><a id="_React_Query_8"></a>导入并配置 React Query：</h4> 
<p>在你的应用中，你需要导入 <code>useQuery Hook</code> 并设置配置对象。</p> 
<pre><code class="prism language-jsx">   import { useQuery } from 'react-query';

   const queryClient = new QueryClient();
</code></pre> 
<p>可以通过 <code>QueryClientProvider</code> 将 <code>queryClient</code> 包裹在你的根组件周围，以便在整个应用中使用。</p> 
<pre><code class="prism language-jsx">   import { QueryClient, QueryClientProvider } from 'react-query';
   
   const queryClient = new QueryClient();

   function App() {
     return (
       &lt;QueryClientProvider client={queryClient}&gt;
         {/* Your application */}
       &lt;/QueryClientProvider&gt;
     );
   }
</code></pre> 
<h4><a id="_useQuery_Hook_34"></a>使用 useQuery Hook：</h4> 
<p>使用 <code>useQuery</code> 来发起 API 请求并管理响应数据。</p> 
<pre><code class="prism language-jsx">   function MyComponent() {
     const { data, status, error } = useQuery('myQueryKey', () =&gt; fetch('https://api.example.com/data'));

     if (status === 'loading') return 'Loading...';
     if (error) return 'An error occurred.';
     return &lt;div&gt;{data}&lt;/div&gt;;
   }
</code></pre> 
<p>这里，<code>myQueryKey</code> 是查询的唯一标识符，<code>fetch('https://api.example.com/data')</code> 是实际的 API 调用。</p> 
<h4><a id="_50"></a>配置选项：</h4> 
<p><code>useQuery</code> 接受一个配置对象，可以设置缓存策略、重试逻辑等。</p> 
<pre><code class="prism language-jsx">   const { data } = useQuery(
     'myQueryKey',
     () =&gt; fetch('https://api.example.com/data'),
     {
       staleTime: 60000, // 数据在多久后被视为过期并重新获取
       retry: 3, // 重试次数
       refetchOnWindowFocus: false, // 窗口聚焦时是否重新获取数据
     }
   );
</code></pre> 
<h4><a id="_66"></a>手动操作：</h4> 
<p>你可以手动触发数据的重新获取、取消或设置为错误状态。</p> 
<pre><code class="prism language-jsx">   const { refetch, reset, isFetching } = useQuery('myQueryKey', fetchData);

   // 重新获取数据
   refetch();

   // 清除查询状态和数据
   reset();

   // 检查是否正在获取数据
   if (isFetching) console.log('Data is being fetched');
</code></pre> 
<h4><a id="_83"></a>订阅更新：</h4> 
<p>你可以通过 <code>useQuery</code> 的返回值订阅查询状态变化。</p> 
<pre><code class="prism language-jsx">   const { status, data, error } = useQuery('myQueryKey', fetchData);
   useEffect(() =&gt; {
     if (status === 'success') console.log('Data updated:', data);
   }, [status, data]);
</code></pre> 
<h4><a id="_94"></a>分页：</h4> 
<p>React Query 支持分页，你可以通过 <code>useInfiniteQuery</code> Hook 实现无限滚动。</p> 
<pre><code class="prism language-jsx">   import { useInfiniteQuery } from 'react-query';

   function MyInfiniteList() {
     const { data, isFetching, hasNextPage, fetchNextPage } = useInfiniteQuery(
       'myInfiniteQuery',
       async ({ pageParam = 1 }) =&gt; {
         const response = await fetch(`https://api.example.com/data?page=${pageParam}`);
         return response.json();
       },
       {
         getNextPageParam: (lastPage) =&gt; lastPage.nextPageToken || false,
       }
     );

     return (
       &lt;div&gt;
         {data.pages.map((page, index) =&gt; (
           &lt;ul key={index}&gt;{page.items.map(item =&gt; &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;)}&lt;/ul&gt;
         ))}
         {hasNextPage &amp;&amp; !isFetching &amp;&amp; (
           &lt;button onClick={fetchNextPage}&gt;Load More&lt;/button&gt;
         )}
       &lt;/div&gt;
     );
   }
</code></pre> 
<p>这里，<code>getNextPageParam</code> 函数用于从上一页的响应中提取下一页的标识符。</p> 
<h4><a id="_128"></a>缓存更新：</h4> 
<p>当 API 数据更新时，React Query 可以自动更新缓存中的数据，例如在使用 <code>Mutation</code> 时。</p> 
<pre><code class="prism language-jsx">   import { useMutation } from 'react-query';

   const [updateItem] = useMutation(async (updatedItem) =&gt; {
     await fetch('https://api.example.com/items/' + updatedItem.id, {
       method: 'PUT',
       body: JSON.stringify(updatedItem),
     });
   });

   // 更新数据并自动刷新相关查询
   updateItem.mutate(updatedItem);
</code></pre> 
<h4><a id="_146"></a>错误处理：</h4> 
<p>React Query 提供了内置的错误处理机制，你可以通过 <code>error</code> 属性来捕获错误。</p> 
<pre><code class="prism language-jsx">   const { data, error } = useQuery('myQueryKey', fetchData);

   if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
</code></pre> 
<h4><a id="_156"></a>查询缓存清理：</h4> 
<p>你可以根据需要清理特定查询的缓存。</p> 
<pre><code class="prism language-jsx">    queryClient.removeQueries('myQueryKey'); // 清理所有匹配的查询
    queryClient.cancelQueries('myQueryKey'); // 取消匹配的查询
</code></pre> 
<h4><a id="_165"></a>自定义中间件：</h4> 
<p>通过自定义中间件，你可以扩展 React Query 的功能，例如添加日志、性能监控等。</p> 
<pre><code class="prism language-jsx">    import { QueryClient, QueryClientProvider } from 'react-query';

    const queryClient = new QueryClient({
      queryCache: new QueryCache({
        middlewares: [
          // 自定义中间件
          myCustomMiddleware,
        ],
      }),
    });
</code></pre> 
<h4><a id="Prefetching_182"></a>预取数据（Prefetching）：</h4> 
<p>React Query 允许你在组件渲染之前预取数据，提升用户体验。</p> 
<pre><code class="prism language-jsx">    import { usePrefetch } from 'react-query';

    function MyComponent() {
      const prefetchData = usePrefetch('myQueryKey');

      useEffect(() =&gt; {
        // 在组件挂载时预取数据
        prefetchData();
      }, []);

      // ...其他逻辑
    }
</code></pre> 
<h4><a id="Optimistic_Updates_201"></a>乐观更新（Optimistic Updates）：</h4> 
<p>在用户触发变更操作时立即更新 UI，然后再等待服务器确认，这能提供即时反馈，提升交互体验。</p> 
<pre><code class="prism language-jsx">    import { useMutation } from 'react-query';

    const [updateTodo, { optimisticData }] = useMutation(updateTodoMutation, {
      onMutate: (newTodo) =&gt; {
        // 乐观地更新客户端缓存
        queryClient.setQueryData(['todos', newTodo.id], newTodo);
        return { previousTodo: queryClient.getQueryData(['todos', newTodo.id]) };
      },
      onError: (err, newTodo, context) =&gt; {
        // 如果发生错误，回滚到之前的值
        queryClient.setQueryData(['todos', newTodo.id], context.previousTodo);
      },
      onSettled: () =&gt; {
        // 查询已解决时，可以做清理工作
        queryClient.invalidateQueries('todos');
      },
    });

    function handleUpdate(todo) {
      updateTodo({ ...todo, completed: !todo.completed });
    }
</code></pre> 
<h4><a id="_229"></a>并发控制：</h4> 
<p>有时，你需要控制同时运行的查询数量，特别是当调用多个 API 或有大量并发请求时。</p> 
<pre><code class="prism language-jsx">    const { data } = useQuery(['concurrentQuery', { limit: 10 }], fetchItems, {
      staleTime: Infinity, // 防止数据过期自动重试
      refetchInterval: false, // 关闭自动轮询
      refetchOnWindowFocus: false, // 不在窗口聚焦时自动重试
      retry: false, // 失败时不重试
      useErrorBoundary: true, // 错误边界，避免组件树崩溃
      concurrency: 2, // 最大并发数
    });
</code></pre> 
<h4><a id="_244"></a>依赖注入：</h4> 
<p>如果你的查询逻辑依赖于外部参数，可以通过 <code>useQueries</code> 来并行执行多个查询，每个查询可以有不同的配置。</p> 
<pre><code class="prism language-jsx">    import { useQueries } from 'react-query';

    function MyComponent({ ids }) {
      const queries = useQueries(
        ids.map(id =&gt; ({
          queryKey: ['item', id],
          queryFn: () =&gt; fetchItem(id),
        }))
      );

      return (
        &lt;div&gt;
          {queries.map(query =&gt; (
            &lt;div key={query.queryKey[1]}&gt;
              {query.isLoading ? 'Loading...' : query.data?.title}
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      );
    }
</code></pre> 
<p>React Query 的设计考虑到了现代 Web 应用的各种复杂场景，通过上述功能，开发者可以轻松实现数据管理和状态同步，同时保持应用的高性能和良好的用户体验。</p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MjM3MDkzNw==&amp;mid=2649460515&amp;idx=1&amp;sn=319604ea7faa4a02ef956aa9790ef151&amp;chksm=88710db5bf0684a3b5d093a49be1f541127ecc9be56edd2f2de9d0d42b646049304a17b15db6#rd" rel="nofollow"><strong>2500G计算机入门到高级架构师开发资料超级大礼包免费送！</strong></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2e392a3108c5f7bc037b6aeec520f91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在 JavaScript 中实现数据加密与解密：Web Cryptography API 与 CryptoJS详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba9add33ebe8dbc810c185f69838fe7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搭建大型分布式服务（三十九）SpringBoot 整合多个kafka数据源-支持Aware模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>