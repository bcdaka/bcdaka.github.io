<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>合并K个升序链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bf4a8e355008ae46be48ee90e70a33e0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="合并K个升序链表">
  <meta property="og:description" content=" 题目 解法一 优先级队列
思想 将每个链表中的一个节点存放到优先级队列中，本题采用小根堆，将小根堆中的根节点取出，插入到最终的链表中，并且将该节点在原链表中的下一个节点插入小根堆中（需要向下调整），直到堆中没有节点为止（即所以链表都已经合并完）。
代码 class Solution { public: struct Less{ bool operator()(ListNode* l1,ListNode* l2){ return l1-&gt;val &gt; l2-&gt;val; } }; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { ListNode* node=new ListNode(0); ListNode* cur=node; priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,Less&gt; q; for(auto&amp; it:lists){ if(it) q.push(it); } while(!q.empty()){ ListNode* tmp=q.top(); q.pop(); cur-&gt;next=tmp; if(tmp-&gt;next) q.push(tmp-&gt;next); cur=cur-&gt;next; } return node-&gt;next; } }; 解法二 归并/分治
思想 将链表两两进行合并，直到合并为一个链表为止。
代码 class Solution { public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { return mergeL(lists,0,lists.size()-1); } ListNode* mergeL(vector&lt;ListNode*&gt;&amp; lists,int l,int r){ if(l&gt;r) return nullptr; if(l==r) return lists[l]; int mid=(l&#43;r)&gt;&gt;1; ListNode* l1=mergeL(lists,l,mid); ListNode* l2=mergeL(lists,mid&#43;1,r); return merge2L(l1,l2); } ListNode* merge2L(ListNode* l1,ListNode* l2){ if(l1==nullptr) return l2; if(l2==nullptr) return l1; if(l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next=merge2L(l1-&gt;next,l2); return l1; } else{ l2-&gt;next=merge2L(l1,l2-&gt;next); return l2; } } }; ">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-24T22:46:23+08:00">
    <meta property="article:modified_time" content="2024-05-24T22:46:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">合并K个升序链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h5>题目</h5> 
<p><img alt="" height="403" src="https://images2.imgbox.com/92/83/X631s5rP_o.png" width="387"></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/b3/77/30wrqYuL_o.png" width="370"></p> 
<h5>解法一</h5> 
<p>优先级队列</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/cf/19/6vIrFtHb_o.png" width="283"></p> 
<h6>思想</h6> 
<p>将每个链表中的一个节点存放到优先级队列中，本题采用小根堆，将小根堆中的根节点取出，插入到最终的链表中，并且将该节点在原链表中的下一个节点插入小根堆中（需要向下调整），直到堆中没有节点为止（即所以链表都已经合并完）。</p> 
<h6>代码</h6> 
<pre><code class="language-cpp">class Solution {
public:
    struct Less{
        bool operator()(ListNode* l1,ListNode* l2){
            return l1-&gt;val &gt; l2-&gt;val;
        }
    };

    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        ListNode* node=new ListNode(0);
        ListNode* cur=node;
        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,Less&gt; q;
        for(auto&amp; it:lists){
            if(it) q.push(it);
        }
        while(!q.empty()){
            ListNode* tmp=q.top();
            q.pop();
            cur-&gt;next=tmp;
            if(tmp-&gt;next) q.push(tmp-&gt;next);
            cur=cur-&gt;next;
        }
        return node-&gt;next;
    }
};</code></pre> 
<h5>解法二</h5> 
<p>归并/分治</p> 
<h6>思想</h6> 
<p><img alt="" height="225" src="https://images2.imgbox.com/29/fe/wzcYJihO_o.png" width="540"></p> 
<p>将链表两两进行合并，直到合并为一个链表为止。</p> 
<h6>代码</h6> 
<pre><code class="language-cpp">class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        return mergeL(lists,0,lists.size()-1);
    }

    ListNode* mergeL(vector&lt;ListNode*&gt;&amp; lists,int l,int r){
        if(l&gt;r) return nullptr;
        if(l==r) return lists[l];
        int mid=(l+r)&gt;&gt;1;
        ListNode* l1=mergeL(lists,l,mid);
        ListNode* l2=mergeL(lists,mid+1,r);
        return merge2L(l1,l2);
    }

    ListNode* merge2L(ListNode* l1,ListNode* l2){
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;
        if(l1-&gt;val &lt; l2-&gt;val){
            l1-&gt;next=merge2L(l1-&gt;next,l2);
            return l1;
        }
        else{
            l2-&gt;next=merge2L(l1,l2-&gt;next);
            return l2;
        }
    }
};</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b5c90eb3085493d04c022b92b2d56bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过C语言实现三种版本的快速排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98844f6c7a5d9ed484262f91a8ab7c7d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">html--瀑布效果</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>