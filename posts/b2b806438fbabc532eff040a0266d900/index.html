<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】结构体（及位段） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b2b806438fbabc532eff040a0266d900/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C语言】结构体（及位段）">
  <meta property="og:description" content="你好！感谢支持孔乙己的新作，本文就结构体与大家分析我的思路。
希望能大佬们多多纠正及支持 ！！！
个人主页：爱摸鱼的孔乙己-CSDN博客 欢迎 互粉哦🙈🙈！
目录
1. 声明结构体
1.1. 结构体的声明
1.2. 结构体变量的创建与初始化
1.3. 结构体的特殊声明
1.4. 结构体的自引用
2. 结构体内存对齐
2.1. 对齐规则
2.1.1. 常规内存对齐
2.1.2. 嵌套结构体内存对齐
2.2. 为什么存在结构体对齐
2.2.1. 平台原因（移植原因）
2.2.2. 性能原因
2.2.3. 改善方法
2.3. 修改默认对齐数
3. 结构体实现传参
4 . 位段
4.1. 什么是位段
4.2. 位段的内存分配
4.3. 位段的跨平台问题
4.4. 位段的应用
4.5. 位段注意事项
1. 声明结构体 Leading ~~ 结构体（struct）是一种用户自定义的数据类型，它可以包含多个不同数据类型的成员变量，这些成员变量可以根据需要进行组合，形成一个新的数据类型。结构体可以用来表示现实世界中的复杂数据结构，比如表示一个学生或者一辆车的信息等。
1.1. 结构体的声明 结构体是⼀些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。 例如，描述一个学生的信息：
struct student { char name[20];//姓名 int age;//年龄 char sex[9];//性别 char number[20];//学号 }; 其中，包含学生的姓名、年龄、性别、学号这些字符数组，整形数据等等不同数据类型的成员变量。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-05T17:51:20+08:00">
    <meta property="article:modified_time" content="2024-06-05T17:51:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】结构体（及位段）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>               你好！感谢支持孔乙己的新作，本文就<strong>结构体</strong>与大家分析我的思路。</p> 
 <p style="text-align:center;">希望能大佬们多多纠正及支持 ！！！</p> 
 <p><img alt="7edab4be0868428c9c0a750f6d39f83d.jpeg" src="https://images2.imgbox.com/df/12/FYhAmkST_o.jpg"></p> 
 <p style="text-align:center;">个人主页：<a href="https://blog.csdn.net/2301_81348661?" title="爱摸鱼的孔乙己-CSDN博客 ">爱摸鱼的孔乙己-CSDN博客 </a> 欢迎 互粉哦🙈🙈！</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:0px;"><a href="#1.%20%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">1. 声明结构体</a></p> 
<p id="%C2%A01.1.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E-toc" style="margin-left:40px;"><a href="#%C2%A01.1.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E" rel="nofollow">1.1. 结构体的声明</a></p> 
<p id="1.2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#1.2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">1.2. 结构体变量的创建与初始化</a></p> 
<p id="1.3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A3%B0%E6%98%8E-toc" style="margin-left:40px;"><a href="#1.3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A3%B0%E6%98%8E" rel="nofollow">1.3. 结构体的特殊声明</a></p> 
<p id="1.4.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.4.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8" rel="nofollow">1.4. 结构体的自引用</a></p> 
<p id="2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-toc" style="margin-left:0px;"><a href="#2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90" rel="nofollow">2. 结构体内存对齐</a></p> 
<p id="%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.1.%20%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.1.%20%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99" rel="nofollow"> 2.1. 对齐规则</a></p> 
<p id="%C2%A0%202.1.1.%20%E5%B8%B8%E8%A7%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-toc" style="margin-left:80px;"><a href="#%C2%A0%202.1.1.%20%E5%B8%B8%E8%A7%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90" rel="nofollow">         2.1.1. 常规内存对齐</a></p> 
<p id="2.1.2.%20%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-toc" style="margin-left:80px;">         <a href="#2.1.2.%20%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90" rel="nofollow">2.1.2. 嵌套结构体内存对齐</a></p> 
<p id="%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90-toc" style="margin-left:40px;"> <a href="#%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90" rel="nofollow">2.2. 为什么存在结构体对齐</a></p> 
<p id="2.2.1.%20%E5%B9%B3%E5%8F%B0%E5%8E%9F%E5%9B%A0%EF%BC%88%E7%A7%BB%E6%A4%8D%E5%8E%9F%E5%9B%A0%EF%BC%89-toc" style="margin-left:80px;">         <a href="#2.2.1.%20%E5%B9%B3%E5%8F%B0%E5%8E%9F%E5%9B%A0%EF%BC%88%E7%A7%BB%E6%A4%8D%E5%8E%9F%E5%9B%A0%EF%BC%89" rel="nofollow">2.2.1. 平台原因（移植原因）</a></p> 
<p id="2.2.2.%20%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0-toc" style="margin-left:80px;">         <a href="#2.2.2.%20%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0" rel="nofollow">2.2.2. 性能原因</a></p> 
<p id="2.2.3.%20%E6%94%B9%E5%96%84%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;">         <a href="#2.2.3.%20%E6%94%B9%E5%96%84%E6%96%B9%E6%B3%95" rel="nofollow">2.2.3. 改善方法</a></p> 
<p id="%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.3.%20%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AF%B9%E9%BD%90%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.3.%20%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AF%B9%E9%BD%90%E6%95%B0" rel="nofollow"> 2.3. 修改默认对齐数</a></p> 
<p id="3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BC%A0%E5%8F%82-toc" style="margin-left:0px;"><a href="#3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BC%A0%E5%8F%82" rel="nofollow">3. 结构体实现传参</a></p> 
<p id="4%20.%20%E4%BD%8D%E6%AE%B5-toc" style="margin-left:0px;"><a href="#4%20.%20%E4%BD%8D%E6%AE%B5" rel="nofollow">4 . 位段</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A04.1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E6%AE%B5-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A04.1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E6%AE%B5" rel="nofollow">  4.1. 什么是位段</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A04.2.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A04.2.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" rel="nofollow">  4.2. 位段的内存分配</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A04.3.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A04.3.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%97%AE%E9%A2%98" rel="nofollow">  4.3. 位段的跨平台问题</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A04.4.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A04.4.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">  4.4. 位段的应用</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A04.5.%20%E4%BD%8D%E6%AE%B5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A04.5.%20%E4%BD%8D%E6%AE%B5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">  4.5. 位段注意事项</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<p style="text-align:center;"> <img alt="e9ee10e11cde440d977cf2cb49399912.jpeg" src="https://images2.imgbox.com/cf/be/0d0516Ao_o.jpg"></p> 
<p style="text-align:center;"><img alt="7a4f0716e2a04268bb0c64386067a51e.gif" src="https://images2.imgbox.com/17/c7/AxsTvHAS_o.gif"></p> 
<hr> 
<h2 id="1.%20%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E4%BD%93" style="background-color:transparent;"><strong>1. 声明结构体</strong></h2> 
<hr> 
<p> Leading  ~~   结构体（struct）是一种用户自定义的数据类型，它可以包含<strong>多个不同数据类型</strong>的成员变量，这些成员变量可以根据需要进行组合，形成一个新的数据类型。结构体可以用来表示现实世界中的复杂数据结构，比如表示一个学生或者一辆车的信息等。</p> 
<p></p> 
<h3 id="%C2%A01.1.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E"> 1.1. 结构体的声明</h3> 
<div>
          结构体是⼀些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。   
</div> 
<p>     例如，描述一个学生的信息：</p> 
<pre><code class="language-cpp">struct student  
{
	char name[20];//姓名
	int age;//年龄
	char sex[9];//性别
	char number[20];//学号

}; </code></pre> 
<p>         其中，包含学生的姓名、年龄、性别、学号这些字符数组，整形数据等等不同数据类型的成员变量。</p> 
<p></p> 
<h3 id="1.2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96">1.2. 结构体变量的创建与初始化</h3> 
<p>          创建结构体变量，对其进行初始化，可以依次进行赋值（输入数据），也可以使用<strong>“ . +成员变量名 ”</strong>来指定顺序赋值（输入数据 ）。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
struct Stu
{
 char name[20];//名字
 int age;//年龄
 char sex[5];//性别
 char id[20];//学号
};
int main()
{
 //按照结构体成员的顺序初始化
 struct Stu s = { "张三", 20, "男", "20230818001" };
 printf("name: %s\n", s.name);
 printf("age : %d\n", s.age);
 printf("sex : %s\n", s.sex);
 printf("id : %s\n", s.id);
 
 //按照指定的顺序初始化
 struct Stu s2 = { .age = 18, .name = "lisi", .id = "20230818002", .sex = 
"⼥" };
 printf("name: %s\n", s2.name);
 printf("age : %d\n", s2.age);
 printf("sex : %s\n", s2.sex);
 printf("id : %s\n", s2.id);
 return 0;
}</code></pre> 
<p></p> 
<h3 id="1.3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A3%B0%E6%98%8E">1.3. 结构体的特殊声明</h3> 
<p>          在声明结构体的时候，可以不完全的声明。当然，这样声明的结构体<strong>只能在创建的时候</strong>对其      进行赋值（输入数据）。</p> 
<pre><code class="language-cpp">//创建匿名结构体变量
struct {
	char name[20];
	int age;
	double height;
} S = { "李四", 23, 1.82 };
</code></pre> 
<p>   <strong>       <span style="color:#fe2c24;">如果要再次使用，必须要对结构体类型重命名（使用typedef对其重命名）</span>，</strong>如下：</p> 
<pre><code class="language-cpp">//对匿名结构体重命名
typedef struct Stu 
{
	char name[20];
	int age;
	double height;
}Stu;
</code></pre> 
<p></p> 
<h3 id="1.4.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8">1.4. 结构体的自引用</h3> 
<div>
         在结构中包含⼀个类型为该结构本⾝的成员是否可以？ ⽐如，定义⼀个链表的节点，如下： 
</div> 
<pre><code class="language-cpp">struct Node
{
 int data;
 struct Node next;
};</code></pre> 
<p>      究其根本，其实是行不通的，毕竟在一个结构体中再包含<strong>一个同类型的结构体变量</strong>，内存就会   变得无穷大，我们可以采取<strong>指针</strong>的方式进行自引用，如下：</p> 
<pre><code class="language-cpp">struct Node
{
 int data;
 struct Node* next;
};</code></pre> 
<div>
         在结构体自引⽤使用的过程中，夹杂了 
 <strong><span style="color:#fe2c24;"> typedef</span></strong> 对匿名结构体类型重命名，也容易引⼊问题，    看看下面的代码，可⾏吗？ 
</div> 
<div> 
 <pre><code class="language-cpp">typedef struct
{
 int data;
 Node* next;
} Node;</code></pre> 
</div> 
<div>
          答案是不行的，因为Node是对前⾯的匿名结构体类型的重命名产⽣的，但是在匿名结构体内部提前使用Node类型来创建成员变量，这是不行的。 
</div> 
<div></div> 
<div>
  解决方案如下： 
 <strong><span style="color:#fe2c24;">定义结构体不要使⽤匿名结构体了 ！</span></strong> 
</div> 
<div> 
 <pre><code class="language-cpp">typedef struct Node
{
 int data;
 struct Node* next;
} Node;</code></pre> 
 <hr> 
 <p><img alt="268d4e462d664d0f99e9588e4bd4be46.jpeg" src="https://images2.imgbox.com/ab/78/21BPXwpd_o.jpg"></p> 
</div> 
<hr> 
<h2 id="2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><strong>2. 结构体内存对齐</strong></h2> 
<hr> 
<h3 id="%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.1.%20%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99">       2.1. 对齐规则</h3> 
<p>              首先，我们来了解一下<strong>结构体内存对齐规则</strong>，如下：</p> 
<table border="3" cellpadding="2" cellspacing="1" style="width:600px;"><tbody><tr><td><strong>1.  结构体的第一个成员对齐到结构体变量起始位置偏移量为0的地址。</strong></td></tr><tr><td><strong>2.  其他成员变量要对齐到对齐数的整数倍的地址处。</strong></td></tr><tr><td> 
    <ul><li><strong>     对齐数 = 编译器默认的一个对齐数与该成员变量大小的较小值</strong></li></ul></td></tr><tr><td> 
    <ul><li><strong>     Visual Stdio 2022中默认值为8（字节）</strong></li></ul></td></tr><tr><td> 
    <ul><li><strong>     Linux中gcc没有对齐数，因此对齐数就是成员自身的大小</strong></li></ul></td></tr><tr><td><strong>3. 结构体总大小为最大对齐数 （结构体中每个成员变量都有⼀个对齐数，所有对齐数中最⼤        的）的整数倍。</strong></td></tr><tr><td> 
    <div> 
     <strong>4. 如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，</strong> 
    </div> </td></tr><tr><td> 
    <div> 
     <strong>    结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍。</strong> 
    </div> </td></tr></tbody></table> 
<p>          我们通过一些例题具体分析结构体对齐的场景，如下：</p> 
<h4 id="%C2%A0%202.1.1.%20%E5%B8%B8%E8%A7%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">  2.1.1. 常规内存对齐</h4> 
<pre><code class="language-cpp">struct s1
{
	char c1;
	int i;
	char c2;
};</code></pre> 
<p> 在s1结构体中，有char类型的c1，int类型的i以及char类型的c2，如果仅仅从类型字节大小来说，这里应该占用1+4+1=6（字节），但由于结构体中存在内存对齐，结果却是12（字节）。<img alt="" height="313" src="https://images2.imgbox.com/bd/2c/UMOxshMD_o.png" width="657"></p> 
<p>究其原因， 我们分析一下这些变量在内存中的排布情况：</p> 
<p> <img alt="" height="536" src="https://images2.imgbox.com/4f/9a/bl7jfhM6_o.png" width="571"></p> 
<p>        首先，结构体的第一个成员对齐到<strong>结构体变量起始位置偏移量为0的地址</strong>,所以我们将char <span style="color:#1c7331;"><strong>（绿色区块）</strong></span>放在起始位置偏移量为0的地址。对于int  i （占用4个字节）要对齐到对齐数的整数倍（VS中默认对齐数是8，int是4，因此对齐数取4）的地址处，也就是偏移量为4的地址处，因此前3个字节将会被浪费。紧接着char c2<strong><span style="color:#ffd900;">（黄色区块）</span></strong>默认对齐数是1，又根据“ <strong>结构体总大小为最大对齐数 （结构体中每个成员变量都有⼀个对齐数，所有对齐数中最⼤的）的整数倍</strong>”，也就是4的整数倍（12），因此也会损耗3个字节空间。</p> 
<p></p> 
<h4 id="2.1.2.%20%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90" style="background-color:transparent;">2.1.2. 嵌套结构体内存对齐</h4> 
<p>    根据上述结果推算出struct S3在内存中占用16个字节，将其<strong>嵌套</strong>在struct S4中结果会是多少呢</p> 
<pre><code class="language-cpp">struct S3
{
	double d;
	char c;
	int i;
};

struct S4
{
	char c1;
	struct S3 s3;
	double d;
};
int main() {
	//printf("%d\n", sizeof(struct S3));
	printf("%zd\n", sizeof(struct S4));
	return 0;
}</code></pre> 
<p>这里我们就要注意对齐的最后一条规则：</p> 
<table border="3" cellpadding="2" cellspacing="1" style="width:600px;"><tbody><tr><td> 
    <div> 
     <strong>4. 如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，</strong> 
    </div> </td></tr><tr><td> 
    <div> 
     <strong>    结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍。</strong> 
    </div> </td></tr></tbody></table> 
<p> 从上述源码中，不难看出嵌套结构体成员（struct S3）的最大对齐数就是8，以及S4中最大对齐数也是8，因此结构体（struct S4）的大小就8的整数倍，从内存排列情况如下：<img alt="" height="690" src="https://images2.imgbox.com/d1/63/AtZVoQX5_o.png" width="586"></p> 
<p>      <strong>  结果，无疑就是占用32个字节 ！ ！！</strong></p> 
<p>        <img alt="" height="427" src="https://images2.imgbox.com/50/bf/QJd6QFXk_o.png" width="527"></p> 
<p> </p> 
<h3 id="%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.2.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90">       2.2. 为什么存在结构体对齐</h3> 
<h4 id="2.2.1.%20%E5%B9%B3%E5%8F%B0%E5%8E%9F%E5%9B%A0%EF%BC%88%E7%A7%BB%E6%A4%8D%E5%8E%9F%E5%9B%A0%EF%BC%89" style="background-color:transparent;">2.2.1. 平台原因（移植原因）</h4> 
<p>         毕竟，不是所有硬件平台都能访问任意地址上的任意数据，对于某些硬件平台只能在某些地址处取某些特特定类型的数据，否则会发生硬件异常。</p> 
<h4 id="2.2.2.%20%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0">2.2.2. 性能原因</h4> 
<p>         数据结构（尤其是栈）应该尽可能在自然边界对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存仅需要一次访问。假如一个处理器总是从内存中取8个字节，则地址必须是8的倍数。假如我们能保证所有的double类型的数据的地址都对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中。</p> 
<p> <strong><span style="color:#1f2329;">总体来说：结构体的内存对齐是拿</span><span style="color:#fe2c24;">空间</span><span style="color:#1f2329;">来换取</span><span style="color:#fe2c24;">时间</span><span style="color:#1f2329;">的做法。</span></strong></p> 
<p></p> 
<h4 id="2.2.3.%20%E6%94%B9%E5%96%84%E6%96%B9%E6%B3%95" style="background-color:transparent;"><span style="color:#1f2329;">2.2.3. 改善方法</span></h4> 
<p>         我们在设计结构体的时候，我们既需要满足对齐，又要节省空间，因此，我们可以在创建结构体的时候，让<strong><span style="color:#fe2c24;">占用空间小的成员集中在一起</span></strong>，如下：</p> 
<pre><code class="language-cpp">struct S1
{
	char c;
	int i;
	char b;
};
</code></pre> 
<pre><code class="language-cpp">struct S1
{
	char b;
	char c;
	int i;
};</code></pre> 
<p> <img alt="" height="209" src="https://images2.imgbox.com/7d/75/rozSojET_o.png" width="350"><img alt="" height="194" src="https://images2.imgbox.com/d3/d0/omtNgZB6_o.png" width="359"></p> 
<p>         在这两组数据中，我们可以发现，他们的成员变量是一致的，但由于在创建时先后顺序不一致，致使他们在内存中存储情况不相同。</p> 
<h3 id="%C2%A0%C2%A0%20%C2%A0%20%C2%A0%202.3.%20%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AF%B9%E9%BD%90%E6%95%B0">       2.3. 修改默认对齐数</h3> 
<p><strong>            #pragma 这个预处理指令，可以改变编译器的默认对⻬数。</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#pragma pack(1)//设置默认对⻬数为1
struct S
{
 char c1;
 int i;
 char c2;
};
#pragma pack()//取消设置的对⻬数，还原为默认
int main()
{
 //输出的结果是什么？
 printf("%d\n", sizeof(struct S));
 return 0;
}</code></pre> 
<p> </p> 
<hr> 
<h2 id="3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BC%A0%E5%8F%82"><strong>3. 结构体实现传参</strong></h2> 
<hr> 
<p>我们在传入参数的时候，有两种形式，一种是“传值输入”，另一种是“<strong>传址输入</strong>”。</p> 
<pre><code class="language-cpp">struct S
{
 int data[1000];
 int num;
};
struct S s = {<!-- -->{1,2,3,4}, 1000};

//结构体传参
void print1(struct S s)
{
 printf("%d\n", s.num);
}

//结构体地址传参
void print2(const struct S* ps)
{
 printf("%d\n", ps-&gt;num);
}
int main()
{
 print1(s); //传结构体
 print2(&amp;s); //传地址
 return 0;
}</code></pre> 
<p><strong>通过实践说明 ，print2相对于print1，会更加优越，原因如下：</strong></p> 
<table border="3" cellpadding="1" cellspacing="1" style="width:570px;"><tbody><tr><td><span style="color:#0d0016;"><strong>        1.   函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销</strong></span></td></tr><tr><td><span style="color:#0d0016;"><strong>         2 . 如果传递⼀个结构体对象的时候，结构体过⼤，</strong></span></td></tr><tr><td><span style="color:#0d0016;"><strong>         参数压栈的的系统开销⽐较⼤，所以会导致性能的下降</strong></span></td></tr></tbody></table> 
<p><strong>总而言之， 结构体传参的时候，我们要传递结构体的<span style="color:#fe2c24;">地址。</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/33/66/mReZEDsL_o.jpg"> </p> 
<hr> 
<h2 id="4%20.%20%E4%BD%8D%E6%AE%B5"><strong>4 . 位段</strong></h2> 
<hr> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A04.1.%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E6%AE%B5">     4.1. 什么是位段</h3> 
<p>我们可以定义一个结构体中的字段使用的<strong>位数(bit位)</strong>。这样可以在存储数据时更加灵活和节省空间。接着我们分析一下位段与结构体的一些差异，如下：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td><strong><span style="color:#646a73;">    1 . 位段的成员必须是 int</span><span style="color:#646a73;">、</span><span style="color:#646a73;">unsigned int </span><span style="color:#646a73;">或</span><span style="color:#646a73;">signed int </span><span style="color:#646a73;">，在C99中位段成员的类型也可以选择其他类型</span></strong></td></tr><tr><td><strong><span style="color:#646a73;">    2 .  位段的成员名后边有⼀个冒号和⼀个数字</span></strong></td></tr></tbody></table> 
<div> 
 <pre><code class="language-cpp">struct A
{
 int _a:2;
 int _b:5;
 int _c:10;
 int _d:30;
};</code></pre> 
</div> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A04.2.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">     4.2. 位段的内存分配</h3> 
<table border="2" cellpadding="1" cellspacing="1" style="width:640px;"><tbody><tr><td><strong><span style="color:#1456f0;">          1. </span><span style="color:#1f2329;">位段的成员可以是 </span><span style="color:#1f2329;">int unsigned int signed int </span><span style="color:#1f2329;">或者是 </span><span style="color:#1f2329;">char </span><span style="color:#1f2329;">等类型</span></strong></td></tr><tr><td><strong><span style="color:#1456f0;">          2. </span><span style="color:#1f2329;">位段的空间上是按照需要以4个字节（ </span><span style="color:#1f2329;">int </span><span style="color:#1f2329;">）或者1个字节（ </span><span style="color:#1f2329;">char </span><span style="color:#1f2329;">）的⽅式来开辟的。</span></strong></td></tr><tr><td><strong><span style="color:#1456f0;">          3. </span><span style="color:#1f2329;">位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使⽤位段。</span></strong></td></tr></tbody></table> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
int main() {
	struct S s = { 0 };
	s.a = 10;
	s.b = 12;
	s.c = 3;
	s.d = 4;
	printf("%zd", sizeof(struct S ));
	return 0;
}
</code></pre> 
<p> <img alt="" height="273" src="https://images2.imgbox.com/4a/f7/kUpW9nnD_o.png" width="596"></p> 
<blockquote> 
 <p>相对比结构体而言，<strong>位段有效地节省了空间大小</strong> ,接下来，我们观察位段在内存中的具体情况</p> 
</blockquote> 
<p><img alt="" height="938" src="https://images2.imgbox.com/88/70/SAqGK99T_o.png" width="1200"> </p> 
<div>
           
</div> 
<p> </p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A04.3.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%97%AE%E9%A2%98">     4.3. 位段的跨平台问题</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:580px;"><tbody><tr><td><strong>1 .  int 位段被当成有符号数还是无符号数是不确定的</strong></td></tr><tr><td><strong>2 . 位段中最大位的数目不能确定（16位机器最大16,32位机器上最大32）</strong></td></tr><tr><td><strong>3 . 位段中的成员在内存中从左向右分配，还是反之，标准尚未定义</strong></td></tr><tr><td><strong>4 . 当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余的位时</strong></td></tr><tr><td><strong>     是选择舍弃还是继续利用，也是不确定的</strong></td></tr></tbody></table> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A04.4.%20%E4%BD%8D%E6%AE%B5%E7%9A%84%E5%BA%94%E7%94%A8">     4.4. 位段的应用</h3> 
<blockquote> 
 <div> 
  <span style="color:#1f2329;">        下图是⽹络协议中，IP数据报的格式，我们可以看到其中很多的属性只需要⼏个bit位就能描述，这⾥ 使⽤位段，能够实现想要的效果，也节省了空间，这样⽹络传输的数据报⼤⼩也会较⼩⼀些，对⽹络 的畅通是有帮助的。 </span> 
 </div> 
</blockquote> 
<p> </p> 
<div> 
 <img alt="" height="343" src="https://images2.imgbox.com/ce/6e/4T632sTd_o.png" width="715"> 
</div> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A04.5.%20%E4%BD%8D%E6%AE%B5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">     4.5. 位段注意事项</h3> 
<blockquote> 
 <p>        因为位段中的成员变量有可能在同一个字节上，因此有些成员的起始地址并不是某个字节的地址，那么这些位置其实就是没有地址的，再者说，内存中每个字节分配一个地址，故而一个字节内部的bit位是没有地址的。<span style="color:#1f2329;">所以<strong>不能对位段的成员使⽤&amp;操作符</strong>，这样就不能使⽤scanf直接给位段的成员输⼊值，只能是先⼊放在⼀个变量中，然后赋值给位段的成员。</span></p> 
</blockquote> 
<pre><code class="language-cpp">struct A
{
 int _a : 2;
 int _b : 5;
 int _c : 10;
 int _d : 30;
};
int main()
{
 struct A sa = {0};
 scanf("%d", &amp;sa._b);//这是错误的
 
 //正确的⽰范
 int b = 0;
 scanf("%d", &amp;b);
 sa._b = b;
 return 0;
}</code></pre> 
<hr> 
<p style="text-align:center;"><img alt="d8385f1a0ee54905b83ab0e6bd609e36.jpeg" src="https://images2.imgbox.com/12/e1/hENtslRM_o.jpg"></p> 
<p style="text-align:center;"> <img alt="8fb80a710692409b946db9d128e02434.gif" src="https://images2.imgbox.com/ad/79/6ZTGSg75_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d724b5fcc0207d3a427c9160987710e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT4-QT5升级（3）GBK-UTF-8-乱码“常量中有换行符”</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5504aad56f2365011b0816045bf47bd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超级详细Spring AI运用Ollama大模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>