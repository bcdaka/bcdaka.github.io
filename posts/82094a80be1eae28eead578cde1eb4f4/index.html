<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;修行之道】类和对象（二）类的6个默认成员函数、构造函数、析构函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/82094a80be1eae28eead578cde1eb4f4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;修行之道】类和对象（二）类的6个默认成员函数、构造函数、析构函数">
  <meta property="og:description" content="目录
一、类的6个默认成员函数
二、构造函数
2.1 概念
2.2 特性
2.2.5 自动生成默认构造函数
不进行显示定义的隐患：
2.2.6 自动生成的构造函数意义何在？
两个栈实现一个队列
2.2.7 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。
2.4 一般情况，建议每个类，都可以写一个全缺省的构造（好用）
三、析构函数
3.1 概念
3.2 特性
3.3 C&#43;&#43;实现括号匹配和C语言的不同
一、类的6个默认成员函数 如果一个类中什么成员都没有，简称为空类。
空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。
默认成员函数：用户没有显式实现，编译器会自动生成（半自动化）的成员函数称为默认成员函数。
class Date {}; 二、构造函数 2.1 概念 对于以下Date类：
class Date { public: void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; &#34;-&#34; &lt;&lt; _month &lt;&lt; &#34;-&#34; &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; d1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-30T19:08:48+08:00">
    <meta property="article:modified_time" content="2024-05-30T19:08:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;修行之道】类和对象（二）类的6个默认成员函数、构造函数、析构函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">一、类的6个默认成员函数</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">二、构造函数</a></p> 
<p id="2.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%20%E6%A6%82%E5%BF%B5" rel="nofollow">2.1 概念</a></p> 
<p id="2.2%20%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#2.2%20%E7%89%B9%E6%80%A7" rel="nofollow">2.2 特性</a></p> 
<p id="2.2.5%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.2.5%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">2.2.5 自动生成默认构造函数</a></p> 
<p id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E9%9A%90%E6%82%A3%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E9%9A%90%E6%82%A3%EF%BC%9A" rel="nofollow">不进行显示定义的隐患：</a></p> 
<p id="2.2.6%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%84%8F%E4%B9%89%E4%BD%95%E5%9C%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#2.2.6%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%84%8F%E4%B9%89%E4%BD%95%E5%9C%A8%EF%BC%9F" rel="nofollow">2.2.6 自动生成的构造函数意义何在？</a></p> 
<p id="%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97-toc" style="margin-left:120px;"><a href="#%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97" rel="nofollow">两个栈实现一个队列</a></p> 
<p id="%C2%A02.2.7%C2%A0%E6%97%A0%E5%8F%82%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E7%BC%BA%E7%9C%81%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%83%BD%E7%A7%B0%E4%B8%BA%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A02.2.7%C2%A0%E6%97%A0%E5%8F%82%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E7%BC%BA%E7%9C%81%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%83%BD%E7%A7%B0%E4%B8%BA%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E3%80%82" rel="nofollow">2.2.7 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。</a></p> 
<p id="2.4%C2%A0%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%AF%8F%E4%B8%AA%E7%B1%BB%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E7%BC%BA%E7%9C%81%E7%9A%84%E6%9E%84%E9%80%A0%EF%BC%88%E5%A5%BD%E7%94%A8%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.4%C2%A0%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%AF%8F%E4%B8%AA%E7%B1%BB%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E7%BC%BA%E7%9C%81%E7%9A%84%E6%9E%84%E9%80%A0%EF%BC%88%E5%A5%BD%E7%94%A8%EF%BC%89" rel="nofollow">2.4 一般情况，建议每个类，都可以写一个全缺省的构造（好用）</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">三、析构函数</a></p> 
<p id="3.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#3.1%20%E6%A6%82%E5%BF%B5" rel="nofollow">3.1 概念</a></p> 
<p id="3.2%20%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#3.2%20%E7%89%B9%E6%80%A7" rel="nofollow">3.2 特性</a></p> 
<p id="3.3%20C%2B%2B%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8D%E5%90%8C-toc" style="margin-left:40px;"><a href="#3.3%20C%2B%2B%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8D%E5%90%8C" rel="nofollow">3.3 C++实现括号匹配和C语言的不同</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%B1%BB%E7%9A%846%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">一、类的6个默认成员函数</h2> 
<p>如果一个类中什么成员都没有，简称为空类。<br> 空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。<br> 默认成员函数：用户没有<strong>显式实现</strong>，<strong>编译器会自动生成（半自动化）</strong>的成员函数称为默认成员函数。</p> 
<pre><code>class Date {};</code></pre> 
<p><img alt="" height="262" src="https://images2.imgbox.com/81/25/CO7w6R3u_o.png" width="827"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">二、构造函数</h2> 
<h3 id="2.1%20%E6%A6%82%E5%BF%B5">2.1 概念</h3> 
<p>对于以下Date类：</p> 
<pre><code class="language-cpp">class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1;

	d1.Print();
	Date d2;

	d2.Print();
	return 0;
}</code></pre> 
<p>对于Date类，可以通过 Init 公有方法给对象设置日期，但如果每次创建对象时都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？<img alt="" height="342" src="https://images2.imgbox.com/24/72/UDRHrjyE_o.png" width="576"></p> 
<p><strong>构造函数</strong>是一个特殊的<strong>成员函数</strong>，名字与类名相同,<strong>创建类类型对象时由编译器自动调用</strong>，以保证每个数据成员都有 一个合适的初始值，并且<strong>在对象整个生命周期内只调用一次</strong>。</p> 
<h3 id="2.2%20%E7%89%B9%E6%80%A7">2.2 特性</h3> 
<p><strong>构造函数</strong>是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务<strong>并不是开空间创建对象，而是初始化对象</strong>。<br> 其特征如下：</p> 
<ol><li>函数名与类名相同。</li><li>无返回值。 </li><li><strong>对象实例化时</strong>编译器<strong>自动调用</strong>对应的构造函数。</li><li>构造函数可以重载。</li></ol> 
<p><img alt="" height="611" src="https://images2.imgbox.com/a0/1d/8MD1xAco_o.png" width="987"></p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/2c/76/DO3Lj3dm_o.png" width="910"></p> 
<pre><code class="language-cpp">class Date
{
public:
	// 1.无参构造函数
	Date()
	{}

	// 2.带参构造函数
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};

void TestDate()
{
	Date d1; // 调用无参构造函数
	Date d2(2015, 1, 1); // 调用带参的构造函数

	// 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明
	// 以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象
	// warning C4930: “Date d3(void)”: 未调用原型函数(是否是有意用变量定义的?)
	Date d3();
}</code></pre> 
<p>在C++中，当编译器看到一个像Date d3();这样的声明时，它会根据语法规则将其解析为一个函数声明，而不是一个对象定义。这是因为C++的语法允许这样的歧义，而且<strong>函数声明的优先级高于对象定义</strong>。因此，即使你本意是想创建一个对象，编译器也会将其视为一个函数声明。为了避免这种歧义，最好不要在对象定义时使用空括号。 </p> 
<h4 id="2.2.5%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">2.2.5 <strong>自动生成默认构造函数</strong></h4> 
<p> 如果类中没有显式定义构造函数，则C++编译器会<strong>自动生成一个无参的默认构造函数</strong>，一旦用户显式定义编译器将不再生成。</p> 
<pre><code class="language-cpp">class Date
{
public:
	/*
	// 如果用户显式定义了构造函数，编译器将不再生成
	Date(int year, int month, int day)
	{
	_year = year;
	_month = month;
	_day = day;
	}
	*/

	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	// 将Date类中构造函数屏蔽后，代码可以通过编译，因为编译器生成了一个无参的默认构造函数
	// 将Date类中构造函数放开，代码编译失败，因为一旦显式定义任何构造函数，编译器将不再	生成
	// 无参构造函数，放开后报错：error C2512: “Date”: 没有合适的默认构造函数可用
	Date d1;
	
	return 0;
}</code></pre> 
<p>在这个Date类的定义中，<strong>并没有显式定义任何构造函数</strong>。编译器会自动生成一个默认的无参构造函数。这个自动生成的构造函数不会进行任何实质性的初始化操作。</p> 
<h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E9%9A%90%E6%82%A3%EF%BC%9A">不进行显示定义的隐患：</h4> 
<pre><code class="language-cpp">class A
{
public:
	A()
	{
		_a = 0;
	}
private:
	int _a;
};

class Time {
public:

private:
	int  _hour;
	int _minute;
	int _second;
	A _aa;
};

class Date
{
public:
	void Print() {
		cout &lt;&lt; _year &lt;&lt; _month &lt;&lt; _day &lt;&lt; endl;
	}
private:
	// 默认生成构造函数
	// 内置类型没有规定要处理(可处理，可不处理，看编译器)
	int _year;
	int _month;
	int _day;

	// 自定义类型调用默认构造函数
	Time _t;
};

int main()
{
	//Date d1(2024, 4, 9);
	//d1.Print();

	Date d2;
	d2.Print();

	return 0;
}</code></pre> 
<p><img alt="" height="540" src="https://images2.imgbox.com/e5/5b/LfO7RFgY_o.png" width="529"></p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/2a/2f/jUZQG9M2_o.png" width="1081"></p> 
<h4 id="2.2.6%20%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%84%8F%E4%B9%89%E4%BD%95%E5%9C%A8%EF%BC%9F">2.2.6 自动生成的构造函数意义何在？</h4> 
<p>关于编译器生成的默认成员函数，很多童鞋会有疑惑：不实现构造函数的情况下，编译器会生成默认的构造函数。但是<strong>看起来默认构造函数又没什么用</strong>？d对象调用了编译器生成的默认构造数，但是d对象_year/_month/_day，依旧是随机值。也就说在这里编译器生成的默认构造函数并没有什么用？<br> 解答：C++把类型分成<strong>内置类型(基本类型)和自定义类型</strong>。内置类型就是语言提供的数据类型，如：int/char...，自定义类型就是我们使用class/struct/union等自己定义的类型，看看下面的程序，就会发现编译器<strong>生成默认的构造函数会对自定类型成员_t调用的它的默认成员函数</strong>。</p> 
<pre><code class="language-cpp">class Time
{
public:
	Time()
	{
		cout &lt;&lt; "Time()" &lt;&lt; endl;
		_hour = 0;
		_minute = 0;
		_second = 0;
	}
private:
	int _hour;
	int _minute;
	int _second;
};
class Date
{
private:
	// 基本类型(内置类型)
	int _year = 1970;
	int _month = 1;
	int _day = 1;
	// 自定义类型
	Time _t;
};
int main()
{
	Date d;
	return 0;
}</code></pre> 
<blockquote> 
 <p>注意：C++11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：<strong>内置类型成员变量在类中声明时可以给默认值。</strong></p> 
 <p>在实际应用中，通常建议在类的构造函数中初始化这些成员，以确保对象的状态是确定的<strong>。</strong></p> 
</blockquote> 
<p><img alt="" height="802" src="https://images2.imgbox.com/aa/7d/fla29pre_o.png" width="1003"></p> 
<h5 id="%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><strong>两个栈实现一个队列</strong></h5> 
<pre><code class="language-cpp">typedef int DataType;
class Stack
{
public:
	Stack(size_t capacity = 10)
	{
		_array = (DataType*)malloc(capacity * sizeof(DataType));
		if (nullptr == _array)
		{
			perror("malloc申请空间失败");
			return;
		}
		_size = 0;
		_capacity = capacity;
	}
	void Push(const DataType&amp; data)
	{
		// CheckCapacity();
		_array[_size] = data;
		_size++;
	}
	~Stack()
	{
		if (_array)
		{
			free(_array);
			_array = nullptr;
			_capacity = 0;
			_size = 0;
		}
	}
private:
	DataType* _array;
	size_t _size;
	size_t _capacity;
};
// 自动生成的构造函数意义何在？
class MyQueue
{
private:
	Stack _pushst;
	Stack _popst;
};

int main()
{
	

	MyQueue q;

	return 0;
}</code></pre> 
<p><img alt="" height="352" src="https://images2.imgbox.com/8b/bc/CxLJiCvK_o.png" width="879"></p> 
<p>自动生成的构造函数意义何在？ </p> 
<ul><li>确保成员变量的正确初始化：<span style="color:#fe2c24;">自动生成的构造函数会调用成员变量的默认构造函数</span>，确保 MyQueue 中的两个 Stack 对象在 MyQueue 对象创建时被正确初始化。</li><li>简化代码：由于 MyQueue 类在这个例子中没有特殊的初始化需求，因此不需要手动编写构造函数。</li><li>如果类中没有需要特别处理的初始化逻辑，那么<strong>自动生成的构造函数可以简化代码，避免不必要的冗余</strong>。这样，开发者可以专注于类的其他功能和逻辑，而不必担心基本的初始化问题。 </li></ul> 
<h4 id="%C2%A02.2.7%C2%A0%E6%97%A0%E5%8F%82%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E7%BC%BA%E7%9C%81%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%83%BD%E7%A7%B0%E4%B8%BA%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E3%80%82">2.2.7 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。</h4> 
<p>注意：无参构造函数、全缺省构造函数、<strong>我们没写编译器默认生成的构造函数</strong>，都可以认为是默认构造函数。</p> 
<pre><code class="language-cpp">class Date
{
public:
	Date()
	{
		_year = 1900;
		_month = 1;
		_day = 1;
	}
	Date(int year = 1900, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
// 以下测试函数能通过编译吗？
void Test()
{
	Date d1;
}</code></pre> 
<p><img alt="" height="677" src="https://images2.imgbox.com/8d/ab/u6SHr5C5_o.png" width="817"></p> 
<h3 id="2.4%C2%A0%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%AF%8F%E4%B8%AA%E7%B1%BB%EF%BC%8C%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E7%BC%BA%E7%9C%81%E7%9A%84%E6%9E%84%E9%80%A0%EF%BC%88%E5%A5%BD%E7%94%A8%EF%BC%89">2.4 一般情况，建议每个类，都可以写一个全缺省的构造（好用）</h3> 
<pre><code class="language-cpp">class Date
{
public:
	// 他们俩构成函数重载，但是无参调用时会存在歧义
	/*Date()
	{
		_year = 1;
		_month = 1;
		_day = 1;
	}*/

	// 一般情况，建议每个类，都可以写一个全缺省的构造（好用）
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	//void Init(int year, int month, int day)
	//{
	//	_year = year;
	//	_month = month;
	//	_day = day;
	//}

	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}

private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};
 

int main()
{
	//Date d1();  无法跟函数声明区分开
	Date d1;
	d1.Print();

	Date d2(2024, 4, 2);// 对象(参数列表)
	d2.Print();

	Date d3(2024);
	d3.Print();

	Date d4(2024, 4);
	d4.Print();

	return 0;
}</code></pre> 
<p><img alt="" height="401" src="https://images2.imgbox.com/86/c9/GTNktTh5_o.png" width="640"></p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">三、析构函数</h2> 
<h3 id="3.1%20%E6%A6%82%E5%BF%B5">3.1 概念</h3> 
<p>通过前面构造函数的学习，我们知道一个对象是怎么来的，那一个对象又是怎么没呢的？<strong>析构函数：与构造函数功能相反</strong>，<span style="color:#fe2c24;">析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的</span>。而对象在销毁时会自动调用析构函数，完成对象中资源的清理工作。</p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/12/b0/cCx2IoNv_o.png" width="1078"></p> 
<h3 id="3.2%20%E7%89%B9%E6%80%A7">3.2 特性</h3> 
<p><img alt="" height="562" src="https://images2.imgbox.com/25/30/WD0LqzfO_o.png" width="1004"></p> 
<p>析构函数是特殊的成员函数，其特征如下： </p> 
<ol><li>析构函数名是<strong>在类名前加上字符 ~</strong>。 </li><li>无参数无返回值类型。 </li><li>一个类只能有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。注意：<strong>析构函数不能重载</strong></li><li>对象生命周期结束时，C++编译系统系统<strong>自动调用析构函数</strong>。</li></ol> 
<pre><code class="language-cpp">typedef int DataType;

class Stack
{
public:
	Stack(size_t capacity = 3)
	{
		cout &lt;&lt; "Stack(size_t capacity = 3)" &lt;&lt; endl;

		_array = (DataType*)malloc(sizeof(DataType) * capacity);
		if (NULL == _array)
		{
			perror("malloc申请空间失败!!!");
			return;
		}
		_capacity = capacity;
		_size = 0;
	}

	void Push(DataType data)
	{
		// CheckCapacity();
		_array[_size] = data;
		_size++;
	}

	// 其他方法...
	~Stack()
	{
		cout &lt;&lt; "~Stack()" &lt;&lt; endl;

		if (_array)
		{
			free(_array);
			_array = NULL;
			_capacity = 0;
			_size = 0;
		}
	}
private:
	DataType* _array;
	int _capacity;
	int _size;
};

int main()
{
	Stack st;

	return 0;
}
</code></pre> 
<p><img alt="" height="509" src="https://images2.imgbox.com/75/43/lCGaGLps_o.png" width="572"></p> 
<p>5. 关于编译器自动生成的析构函数，是否会完成一些事情呢？<strong>下面的程序我们会看到，编译器生成的默认析构函数，对自定类型成员调用它的析构函数</strong>。</p> 
<pre><code class="language-cpp">class Time
{
public:
	~Time()
	{
		cout &lt;&lt; "~Time()" &lt;&lt; endl;
	}
private:
	int _hour;
	int _minute;
	int _second;
};
class Date
{
private:
	// 基本类型(内置类型)
	int _year = 1970;
	int _month = 1;
	int _day = 1;
	// 自定义类型
	Time _t;
};
int main()
{
	Date d;
	return 0;
}
</code></pre> 
<p>程序运行结束后输出：~Time()<br> 在main方法中根本没有直接创建Time类的对象，为什么最后会调用Time类的析构函数？</p> 
<p>因为：main方法中创建了Date对象d，而d中包含4个成员变量，<span style="color:#fe2c24;">其中_year, _month, _day三个是内置类型成员，销毁时不需要资源清理，最后系统直接将其内存回收即可</span>；而_t是Tim类对象，所以在d销毁时，要将其内部包含的Time类的_t对象销毁，所以要调用Time类的析构函数。但是：main函数中不能直接调用Time类的析构函数，实际要释放的是Date类对象，所以编译器会调用Date类的析构函数，<strong>而Date没有显式提供，则编译器会给Date类生成一个默认的析构函数。</strong></p> 
<p>目的是：在其内部调用Time类的析构函数，即当Date对象销毁时，<span style="color:#fe2c24;">要保证其内部每个自定义对象都可以正确销毁</span>，<strong>main函数中并没有直接调用Time类析构函数，而是显式调用编译器为Date类生成的默认析构函数</strong></p> 
<p>注意：<span style="color:#fe2c24;">创建哪个类的对象则调用该类的析构函数，销毁那个类的对象则调用该类的析构函数 </span></p> 
<p></p> 
<p>6. 如果类中<strong>没有申请资源时，析构函数可以不写</strong>，直接使用编译器生成的默认析构函数，比如Date类；有资源申请时，一定要写，否则会造成资源泄漏，比如Stack类。</p> 
<h3 id="3.3%20C%2B%2B%E5%AE%9E%E7%8E%B0%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8D%E5%90%8C">3.3 C++实现括号匹配和C语言的不同</h3> 
<p> 可以明显的看出，C++对应C语言来说简化了不少，对C语言进行了一定的优化。</p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/f5/0d/PCAsp5rZ_o.png" width="639"></p> 
<p>今天就先到这了！！！</p> 
<p><img alt="" height="871" src="https://images2.imgbox.com/ce/f1/QkVtA9zz_o.png" width="1200"></p> 
<p>看到这里了还不给博主扣个：<br> ⛳️ 点赞☀️收藏 ⭐️ 关注！</p> 
<p>你们的点赞就是博主更新最大的动力！<br> 有问题可以评论或者私信呢秒回哦。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1dd858064b2353aecf10ea056124ea2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Cloud Gateway通过配置文件方式提供路由服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4539ea16db51b31121204bba10a35f79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 如何传递参数给webView的h5页面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>