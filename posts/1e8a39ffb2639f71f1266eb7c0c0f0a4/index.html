<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;学习 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1e8a39ffb2639f71f1266eb7c0c0f0a4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="c&#43;&#43;学习">
  <meta property="og:description" content="关键字 continue continue 关键字用于控制循环语句的执行流程。当continue 语句被执行时，它会跳过当前循环迭代中剩余的代码，并立即开始下一次迭代。continue 通常用于 for、while 和 do-while 循环中。
#include &lt;iostream&gt; using namespace std; int main() { for (int i = 0; i &lt; 10; i&#43;&#43;) { if (i % 2 == 0) { continue; // 跳过本次循环剩余的代码，继续下一次循环 } cout &lt;&lt; i &lt;&lt; &#34; &#34;; } return 0; } 在这个例子中，continue 语句会使程序跳过 i 为偶数的情况，因此只会打印奇数：1 3 5 7 9。 static static 关键字在C&#43;&#43;中有多种用途，分别可以应用于变量、函数和成员变量或成员函数。 1.静态局部变量 ：静态局部变量是在函数内部定义的，但它们的生命周期跨越整个程序的运行时间。它们在第一次执行时初始化，并且其值在函数调用之间保持不变。
#include &lt;iostream&gt; void demo() { static int count = 0; // 静态局部变量 count&#43;&#43;; std::cout &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-09T11:41:10+08:00">
    <meta property="article:modified_time" content="2024-08-09T11:41:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>关键字</h3> 
<h4>continue</h4> 
<p><code>continue</code> 关键字用于控制循环语句的执行流程。当<code>continue</code> 语句被执行时，它会跳过当前循环迭代中剩余的代码，并立即开始下一次迭代。<code>continue</code> 通常用于 <code>for</code>、<code>while</code> 和 <code>do-while</code> 循环中。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    for (int i = 0; i &lt; 10; i++) {
        if (i % 2 == 0) {
            continue;  // 跳过本次循环剩余的代码，继续下一次循环
        }
        cout &lt;&lt; i &lt;&lt; " ";
    }
    return 0;
}
在这个例子中，continue 语句会使程序跳过 i 为偶数的情况，因此只会打印奇数：1 3 5 7 9。</code></pre> 
<h4>static</h4> 
<p><code>static</code> 关键字在C++中有多种用途，分别可以应用于变量、函数和成员变量或成员函数。 </p> 
<p>1.静态局部变量 ：静态局部变量是在函数内部定义的，但它们的生命周期跨越整个程序的运行时间。它们在第一次执行时初始化，并且其值在函数调用之间保持不变。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
void demo() {
    static int count = 0;  // 静态局部变量
    count++;
    std::cout &lt;&lt; "Count: " &lt;&lt; count &lt;&lt; std::endl;
}

int main() {
    demo();  // 输出: Count: 1
    demo();  // 输出: Count: 2
    demo();  // 输出: Count: 3
    return 0;
}
</code></pre> 
<p> 2.静态全局变量：在文件作用域内，静态全局变量的作用域限制在定义它的文件内，其他文件不能访问它。这在多文件项目中非常有用，因为它避免了命名冲突。</p> 
<pre><code class="language-cpp">// File1.cpp
static int globalVar = 10;  // 静态全局变量

void printVar() {
    std::cout &lt;&lt; globalVar &lt;&lt; std::endl;
}

// File2.cpp
extern void printVar();

int main() {
    printVar();  // 输出: 10
    return 0;
}
</code></pre> 
<p>3. 静态成员变量：静态成员函数只能访问静态成员变量和静态成员函数。它们不依赖于类的实例，可以直接通过类名调用。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

class MyClass {
public:
    static void staticFunc() {
        std::cout &lt;&lt; "This is a static function." &lt;&lt; std::endl;
    }
};

int main() {
    MyClass::staticFunc();  // 通过类名调用静态成员函数
    return 0;
}
</code></pre> 
<p> 静态成员函数：静态成员函数只能访问静态成员变量和静态成员函数。它们不依赖于类的实例，可以直接通过类名调用。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

class MyClass {
public:
    static void staticFunc() {
        std::cout &lt;&lt; "This is a static function." &lt;&lt; std::endl;
    }
};

int main() {
    MyClass::staticFunc();  // 通过类名调用静态成员函数
    return 0;
}
</code></pre> 
<p>静态变量在命名空间：在命名空间内声明静态变量也会使其仅在该编译单元中可见。</p> 
<pre><code class="language-cpp">namespace MyNamespace {
    static int namespaceVar = 42;
}

int main() {
    std::cout &lt;&lt; MyNamespace::namespaceVar &lt;&lt; std::endl;  // 输出: 42
    return 0;
}
</code></pre> 
<h4>虚函数</h4> 
<p>虚函数（Virtual Function）是面向对象编程中的一个概念，主要用于实现<strong>多态性</strong>（polymorphism）。它是基类（父类）中的一个函数，可以被子类（派生类）重写（override）。当使用基类的指针或引用来调用虚函数时，实际调用的是子类中重写的版本，而不是基类中的版本。这个过程称为<strong>动态绑定</strong>（dynamic binding）或<strong>后期绑定</strong>（late binding）。</p> 
<p>虚函数特点：</p> 
<ul><li> <p><strong>定义</strong>：在基类中用 <code>virtual</code> 关键字修饰的函数就是虚函数。</p> </li><li> <p><strong>重写</strong>：子类可以选择性地重写基类中的虚函数，即子类可以提供自己版本的函数实现。</p> </li><li> <p><strong>动态绑定</strong>：通过基类的指针或引用调用虚函数时，实际调用的是指向对象的实际类型（运行时的类型）中的函数，而不是编译时类型的函数。</p> </li><li> <p><strong>虚函数表</strong>：编译器为每个定义了虚函数的类维护一个虚函数表（V-Table），这个表中存储了虚函数的地址。当通过基类指针或引用调用虚函数时，程序会根据虚函数表找到实际要调用的函数地址。</p> </li></ul> 
<p></p> 
<p>虚函数使用背景</p> 
<p>虚函数的主要作用是通过基类接口实现多态。假设你有一个基类 <code>Animal</code>，以及从它派生的 <code>Dog</code> 和 <code>Cat</code> 类。你可以在 <code>Animal</code> 中定义一个虚函数 <code>speak()</code>，然后在 <code>Dog</code> 和 <code>Cat</code> 中重写这个函数</p> 
<pre><code class="language-cpp">class Animal {
public:
    virtual void speak() {
        std::cout &lt;&lt; "Animal speaks" &lt;&lt; std::endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {
        std::cout &lt;&lt; "Woof!" &lt;&lt; std::endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        std::cout &lt;&lt; "Meow!" &lt;&lt; std::endl;
    }
};
#现在，假设你有一个 Animal 类型的指针，指向 Dog 对象：
Animal* animal = new Dog();
animal-&gt;speak();
#在这里，尽管 animal 是 Animal 类型的指针，但由于 speak() 是虚函数，实际调用的是 Dog 类中重写的 speak() 方法。因此，输出结果将是 Woof! 而不是 Animal speaks。</code></pre> 
<h4> 全局变量</h4> 
<p> 全局变量通常在文件的开头（在任何函数或类定义的外面）定义</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

int globalVar = 10;  // 定义一个全局变量

int main() {
    std::cout &lt;&lt; "Global variable: " &lt;&lt; globalVar &lt;&lt; std::endl;
    return 0;
}
#在这个例子中，globalVar 是一个全局变量，它可以在 main() 函数中访问。</code></pre> 
<p>全局变量的特点 </p> 
<p> </p> 
<ul><li> <p><strong>作用域</strong>：</p> 
  <ul><li>全局变量的作用域是从定义点到程序结束。它可以在定义之后的任何函数或代码块中被访问。</li></ul></li><li> <p><strong>生命周期</strong>：</p> 
  <ul><li>全局变量的生命周期从程序开始到程序结束。因此，它们在整个程序的执行过程中始终存在。</li></ul></li><li> <p><strong>初始值</strong>：</p> 
  <ul><li>全局变量如果未显式初始化，默认会被初始化为0（对于整数类型）、0.0（对于浮点类型）或空指针（对于指针类型）。</li></ul></li><li> <p><strong>多文件中的全局变量</strong>：</p> 
  <ul><li>如果在多文件中使用全局变量，可能会遇到重定义问题。为了避免这种问题，可以使用 <code>extern</code> 关键字声明全局变量，这样在其他文件中可以引用同一个全局变量。</li></ul></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9840b64e047070239e5229990ee8bd7c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">血泪教训：QT子窗体不显示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/579e2be640429c406e245fa2dc46220a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">初次运行android studio 报错-Installed Build Tools revision 35.0.0 is corrupted. Remove and install again u</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>