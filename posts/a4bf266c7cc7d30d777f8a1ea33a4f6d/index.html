<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL优化：12种提升SQL执行效率的有效方法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a4bf266c7cc7d30d777f8a1ea33a4f6d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MySQL优化：12种提升SQL执行效率的有效方法">
  <meta property="og:description" content="在数据库管理和优化的世界里，MySQL作为一个流行的关系型数据库管理系统，其性能优化是任何数据密集型应用成功的关键。优化MySQL数据库不仅可以显著提高SQL查询的效率，还能确保数据的稳定性和可靠性。
在本文中，我将介绍12种提升SQL执行效率的有效方法，并通过实用的代码示例来具体展示如何实施这些优化策略。
本文，已收录于，我的技术网站 ddkk.com，有大厂完整面经，工作技术，架构师成长之路，等经验分享
1、使用索引优化查询 使用场景：当你的数据库表中有大量数据，而你需要频繁进行搜索查询时，索引是提高查询效率的关键。
代码示例：
-- 假设我们有一个员工表 employees CREATE TABLE employees ( id INT AUTO_INCREMENT, name VARCHAR(100), department_id INT, PRIMARY KEY (id) ); -- 为department_id字段创建索引 CREATE INDEX idx_department ON employees(department_id); -- 使用索引进行查询 SELECT * FROM employees WHERE department_id = 5; 代码解释：
第一步是创建一个包含id, name, department_id字段的employees表。
然后为department_id字段创建一个索引idx_department。这个操作会让基于department_id的查询更快。
最后，我们执行一个查询，利用创建的索引，从而提高查询效率。
最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。这是大佬写的， 七千页的BAT大佬写的刷题笔记，让我offer拿到手软
2、优化查询语句 使用场景：避免使用高成本的SQL操作，如**SELECT ***，尽量指定需要的列，减少数据传输和处理时间。
代码示例：
-- 不推荐的查询方式 SELECT * FROM employees; -- 推荐的查询方式 SELECT id, name FROM employees; 代码解释：
第一个查询语句使用了**SELECT ***，它会获取所有列，这在数据量大时非常低效。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-09T14:54:26+08:00">
    <meta property="article:modified_time" content="2024-01-09T14:54:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL优化：12种提升SQL执行效率的有效方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在数据库管理和优化的世界里，MySQL作为一个流行的关系型数据库管理系统，其性能优化是任何数据密集型应用成功的关键。优化MySQL数据库不仅可以显著提高SQL查询的效率，还能确保数据的稳定性和可靠性。</p> 
<p>在本文中，我将介绍12种提升SQL执行效率的有效方法，并通过实用的代码示例来具体展示如何实施这些优化策略。</p> 
<p>本文，已收录于，我的技术网站 <a href="https://www.ddkk.com/#zh" rel="nofollow">ddkk.com</a>，有大厂完整面经，工作技术，架构师成长之路，等经验分享</p> 
<h3><a id="1_6"></a>1、使用索引优化查询</h3> 
<p><strong>使用场景</strong>：当你的数据库表中有大量数据，而你需要频繁进行搜索查询时，索引是提高查询效率的关键。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 假设我们有一个员工表 employees</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    department_id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 为department_id字段创建索引</span>
<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_department <span class="token keyword">ON</span> employees<span class="token punctuation">(</span>department_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 使用索引进行查询</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>第一步是创建一个包含<strong>id</strong>, <strong>name</strong>, <strong>department_id</strong>字段的<strong>employees</strong>表。</p> 
<p>然后为<strong>department_id</strong>字段创建一个索引<strong>idx_department</strong>。这个操作会让基于<strong>department_id</strong>的查询更快。</p> 
<p>最后，我们执行一个查询，利用创建的索引，从而提高查询效率。</p> 
<p>最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。这是大佬写的， 七千页的BAT大佬写的<a href="https://www.ddkk.com/zhuanlan/share/index.html" rel="nofollow">刷题笔记</a>，让我offer拿到手软</p> 
<h3><a id="2_38"></a>2、优化查询语句</h3> 
<p><strong>使用场景</strong>：避免使用高成本的SQL操作，如**SELECT ***，尽量指定需要的列，减少数据传输和处理时间。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 不推荐的查询方式</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>

<span class="token comment">-- 推荐的查询方式</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>第一个查询语句使用了**SELECT ***，它会获取所有列，这在数据量大时非常低效。</p> 
<p>第二个查询仅请求需要的<strong>id</strong>和<strong>name</strong>列，减少了数据处理的负担。</p> 
<h3><a id="3_58"></a>3、使用查询缓存</h3> 
<p><strong>使用场景</strong>：当相同的查询被频繁执行时，使用查询缓存可以避免重复的数据库扫描。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 启用查询缓存</span>
<span class="token keyword">SET</span> <span class="token keyword">global</span> query_cache_size <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> <span class="token keyword">global</span> query_cache_type <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- 执行查询</span>
<span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>通过设置<strong>query_cache_size</strong>和<strong>query_cache_type</strong>，我们启用了查询缓存。</p> 
<p>当我们执行查询时，MySQL会检查缓存中是否已经有了该查询的结果，如果有，则直接返回结果，避免了重复的数据库扫描。</p> 
<h3><a id="4_79"></a>4、避免全表扫描</h3> 
<p><strong>使用场景</strong>：当表中数据量巨大时，全表扫描会非常耗时。通过使用合适的查询条件来避免全表扫描，可以显著提高查询效率。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 假设我们需要查询员工表中特定部门的员工</span>
<span class="token comment">-- 不推荐的查询方式，会导致全表扫描</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">'%张%'</span><span class="token punctuation">;</span>

<span class="token comment">-- 推荐的查询方式</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">AND</span> name <span class="token operator">LIKE</span> <span class="token string">'%张%'</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>第一个查询使用了模糊匹配<strong>LIKE</strong>，但缺乏有效的过滤条件，可能导致全表扫描。</p> 
<p>第二个查询在<strong>name</strong>字段的模糊匹配前，增加了对<strong>department_id</strong>的条件过滤，这样就可以先缩小查找范围，避免全表扫描。</p> 
<h3><a id="5JOIN_100"></a>5、使用JOIN代替子查询</h3> 
<p><strong>使用场景</strong>：在需要关联多个表的复杂查询中，使用JOIN代替子查询可以提高查询效率。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 假设我们有一个部门表 departments</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> departments <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 不推荐的子查询方式</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> department_id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> departments <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">'IT'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 推荐的JOIN查询方式</span>
<span class="token keyword">SELECT</span> employees<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">JOIN</span> departments <span class="token keyword">ON</span> employees<span class="token punctuation">.</span>department_id <span class="token operator">=</span> departments<span class="token punctuation">.</span>id <span class="token keyword">WHERE</span> departments<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'IT'</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>第一个查询使用了子查询，这在执行时可能效率较低，特别是当子查询或主查询的结果集较大时。</p> 
<p>第二个查询使用了<strong>JOIN</strong>操作，这通常比子查询更有效，尤其是在处理大型数据集时。</p> 
<h3><a id="6_127"></a>6、合理分页</h3> 
<p><strong>使用场景</strong>：在处理大量数据的列表展示时，合理的分页策略可以减少单次查询的负担，提高响应速度。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 假设我们需要分页显示员工信息</span>
<span class="token comment">-- 不推荐的分页方式，尤其是当offset值很大时</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">LIMIT</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">;</span>

<span class="token comment">-- 推荐的分页方式，使用更高效的条件查询</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">10000</span> <span class="token keyword">LIMIT</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>第一个查询使用了<strong>LIMIT</strong>和较大的偏移量<strong>offset</strong>，在大数据集上执行时会逐行扫描跳过大量记录，效率低下。</p> 
<p>第二个查询通过在<strong>WHERE</strong>子句中添加条件来避免不必要的扫描，从而提高分页效率。</p> 
<p>最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。这是大佬写的， 七千页的BAT大佬写的<a href="https://www.ddkk.com/zhuanlan/share/index.html" rel="nofollow">刷题笔记</a>，让我offer拿到手软</p> 
<h3><a id="7_150"></a>7、利用分区提高性能</h3> 
<p><strong>使用场景</strong>：对于大型表，特别是那些行数以百万计的表，使用分区可以提高查询性能和数据管理效率。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 假设我们需要对一个大型的订单表 orders 进行分区</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> orders <span class="token punctuation">(</span>
    order_id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    order_date <span class="token keyword">DATE</span><span class="token punctuation">,</span>
    customer_id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    amount <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_id<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>order_date<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p2020 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2021</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2021 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2022</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2022 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2023</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 查询特定年份的订单</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders <span class="token keyword">WHERE</span> order_date <span class="token operator">BETWEEN</span> <span class="token string">'2021-01-01'</span> <span class="token operator">AND</span> <span class="token string">'2021-12-31'</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>我们为<strong>orders</strong>表创建了基于<strong>order_date</strong>字段的年份范围分区。</p> 
<p>查询特定年份的数据时，MySQL只会在相关分区中搜索，提高了查询效率。</p> 
<h3><a id="8IO_180"></a>8、利用批处理减少I/O操作</h3> 
<p><strong>使用场景</strong>：在进行大量数据插入或更新时，批处理可以减少数据库的I/O操作次数，从而提高性能。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 批量插入数据</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees <span class="token punctuation">(</span>name<span class="token punctuation">,</span> department_id<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> 
    <span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">'李四'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">'王五'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">-- 更多记录</span>
<span class="token punctuation">;</span>

<span class="token comment">-- 批量更新数据</span>
<span class="token keyword">UPDATE</span> employees
<span class="token keyword">SET</span> department_id <span class="token operator">=</span> <span class="token keyword">CASE</span> name
    <span class="token keyword">WHEN</span> <span class="token string">'张三'</span> <span class="token keyword">THEN</span> <span class="token number">3</span>
    <span class="token keyword">WHEN</span> <span class="token string">'李四'</span> <span class="token keyword">THEN</span> <span class="token number">2</span>
    <span class="token comment">-- 更多条件</span>
<span class="token keyword">END</span>
<span class="token keyword">WHERE</span> name <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">,</span> <span class="token comment">-- 更多名称);</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>在批量插入示例中，我们一次性插入多条记录，而不是对每条记录进行单独的插入操作。</p> 
<p>在批量更新示例中，我们使用<strong>CASE</strong>语句一次性更新多条记录，这比单独更新每条记录更有效率。</p> 
<h3><a id="9_212"></a>9、使用临时表优化复杂查询</h3> 
<p><strong>使用场景</strong>：对于复杂的多步骤查询，使用临时表可以存储中间结果，从而简化查询并提高性能。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 创建一个临时表来存储中间结果</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TEMPORARY</span> <span class="token keyword">TABLE</span> temp_employees
<span class="token keyword">SELECT</span> department_id<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> emp_count
<span class="token keyword">FROM</span> employees
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department_id<span class="token punctuation">;</span>

<span class="token comment">-- 使用临时表进行查询</span>
<span class="token keyword">SELECT</span> departments<span class="token punctuation">.</span>name<span class="token punctuation">,</span> temp_employees<span class="token punctuation">.</span>emp_count
<span class="token keyword">FROM</span> departments
<span class="token keyword">JOIN</span> temp_employees <span class="token keyword">ON</span> departments<span class="token punctuation">.</span>id <span class="token operator">=</span> temp_employees<span class="token punctuation">.</span>department_id<span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>首先，我们通过聚合查询创建了一个临时表<strong>temp_employees</strong>，用于存储每个部门的员工计数。</p> 
<p>然后，我们将这个临时表与部门表<strong>departments</strong>进行连接查询，这样的查询通常比直接在原始表上执行复杂的聚合查询要高效。</p> 
<h3><a id="10_237"></a>10、优化数据类型</h3> 
<p><strong>使用场景</strong>：在设计数据库表时，选择合适的数据类型对性能有显著影响。优化数据类型可以减少存储空间，提高查询效率。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 原始表结构</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> example <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    description <span class="token keyword">TEXT</span><span class="token punctuation">,</span>
    created_at <span class="token keyword">DATETIME</span><span class="token punctuation">,</span>
    is_active <span class="token keyword">BOOLEAN</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 优化后的表结构</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> optimized_example <span class="token punctuation">(</span>
    id <span class="token keyword">MEDIUMINT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    description <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    created_at <span class="token keyword">DATE</span><span class="token punctuation">,</span>
    is_active <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>在原始表中，使用了<strong>INT</strong>和<strong>TEXT</strong>这样的宽泛类型，这可能会占用更多的存储空间。</p> 
<p>在优化后的表中，<strong>id</strong>字段改为<strong>MEDIUMINT</strong>，<strong>description</strong>改为长度有限的<strong>VARCHAR(255)</strong>，<strong>created_at</strong>只存储日期，而<strong>is_active</strong>使用**TINYINT(1)**来表示布尔值。这样的优化减少了每行数据的大小，提高了存储效率。</p> 
<h3><a id="11_269"></a>11、避免使用函数和操作符</h3> 
<p><strong>使用场景</strong>：在WHERE子句中避免对列使用函数或操作符，可以让MySQL更有效地使用索引。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 不推荐的查询方式，使用了函数</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>birth_date<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1980</span><span class="token punctuation">;</span>

<span class="token comment">-- 推荐的查询方式</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> birth_date <span class="token operator">BETWEEN</span> <span class="token string">'1980-01-01'</span> <span class="token operator">AND</span> <span class="token string">'1980-12-31'</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>在第一个查询中，使用 <strong>YEAR()</strong> 函数会导致MySQL无法利用索引，因为它必须对每行数据应用函数。</p> 
<p>第二个查询直接使用日期范围，这样MySQL可以有效利用<strong>birth_date</strong>字段的索引。</p> 
<h3><a id="12_289"></a>12、合理使用正规化和反正规化</h3> 
<p><strong>使用场景</strong>：数据库设计中的正规化可以减少数据冗余，而反正规化可以提高查询效率。合理平衡这两者，可以获得最佳性能。</p> 
<p><strong>代码示例</strong>：</p> 
<pre><code class="prism language-sql"><span class="token comment">-- 正规化设计</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> departments <span class="token punctuation">(</span>
    department_id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>department_id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    department_id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>department_id<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> departments<span class="token punctuation">(</span>department_id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 反正规化设计</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees_denormalized <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    department_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>代码解释</strong>：</p> 
<p>在正规化设计中，<strong>departments</strong>和<strong>employees</strong>表被分开，减少了数据冗余，但可能需要JOIN操作来获取完整信息。</p> 
<p>在反正规化设计中，<strong>employees_denormalized</strong>表通过直接包含部门信息来简化查询，提高读取性能，但可能会增加数据冗余和更新成本。</p> 
<h4><a id="_326"></a>项目文档&amp;视频：</h4> 
<p><a href="https://www.ddkk.com#github-doc" rel="nofollow">开源：项目文档 &amp; 视频 Github-Doc</a></p> 
<h3><a id="_330"></a>总结</h3> 
<p>以上提到的优化方法只是众多MySQL优化技术中的一小部分。在实际应用中，应根据具体的数据模式和查询需求灵活选择最合适的优化策略。数据库优化是一个持续的过程，定期的性能评估和调优是保持数据库高效运行的关键。通过实践这些优化技巧，你可以显著提升数据库的性能和响应速度。</p> 
<p>本文，已收录于，我的技术网站 <a href="https://www.ddkk.com/#zh" rel="nofollow">ddkk.com</a>，有大厂完整面经，工作技术，架构师成长之路，等经验分享</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f35576b12ae8da8535c39d5b856e224/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript中实现页面跳转的多种方法【通俗易懂】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/958eef9c231e299a2f55993b393e25dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mariadb和mysql数据库的区别和相同之处</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>