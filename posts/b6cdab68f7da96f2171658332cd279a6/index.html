<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文教你在k8s中部署单机版kafka（保姆级教程） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b6cdab68f7da96f2171658332cd279a6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="一文教你在k8s中部署单机版kafka（保姆级教程）">
  <meta property="og:description" content="🐇明明跟你说过：个人主页
🏅个人专栏：《洞察之眼：ELK监控与可视化》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、Kafka简介
2、为什么在Kubernetes中部署Kafka
3、单机版Kafka与集群版Kafka的对比
二、Kubernetes基础知识
1、Kubernetes简介
2、Pods、Deployments、Services等概念介绍
三、准备Kafka部署环境 1、选择Kubernetes集群与配置 2、获取Kafka镜像 四、部署单机版Kafka
1、部署zookeeper
2、部署Kafka
五、测试
1、访问Kafka服务
2、创建第一个Topic 3、kafka-topics.sh工具介绍
一、引言 1、Kafka简介 Kafka是一个分布式流处理平台，最初由LinkedIn开发，随后开源并捐献给了Apache基金会。Kafka的主要设计目标是处理和存储大规模的实时数据流。
Kafka的核心概念
Producer（生产者）：生产者是向Kafka主题（topic）发送消息的客户端应用程序。生产者发布的数据消息被称为记录（records）。Consumer（消费者）：消费者是从Kafka主题中读取消息的客户端应用程序。消费者从指定的主题订阅并消费消息。Topic（主题）：主题是Kafka中的一个逻辑通道，生产者将消息发布到主题，消费者从主题订阅和消费消息。每个主题可以有多个分区（partition），以实现更高的并行处理能力。Partition（分区）：主题中的数据分为多个分区，每个分区是一个有序的、不可变的记录序列。分区通过分布在集群中的不同Kafka代理（broker）上来实现负载均衡和并行处理。Broker（代理）：Kafka集群中的每个服务器节点被称为一个代理。代理负责存储分区数据，并处理来自生产者和消费者的请求。Consumer Group（消费者组）：消费者组是一组协同工作的消费者。每个消费者组订阅一个或多个主题，并分担消费这些主题中的消息。每条消息只会被消费者组中的一个消费者处理。ZooKeeper：Kafka使用Apache ZooKeeper来管理集群配置、选举代理领导以及进行分布式协调。ZooKeeper确保集群的高可用性和一致性。 Kafka的特点
高吞吐量：Kafka可以在低延迟下处理大量的数据流，适合实时大数据处理和流数据分析。可扩展性：Kafka通过添加更多的代理节点来水平扩展集群，支持大规模数据处理。容错性：Kafka通过数据复制机制保证消息的高可用性和容错能力，即使在代理节点故障的情况下，也能继续处理消息。持久化：Kafka将消息持久化到磁盘，确保数据的持久存储和可靠传递。流处理：Kafka Streams API提供了强大的流处理功能，可以在消息流上传输和处理数据，进行实时计算和分析。 Kafka的典型应用场景
日志收集：Kafka可以从不同的应用程序和系统中收集日志，并将它们统一存储和处理。实时分析：通过Kafka将数据实时传输到流处理系统或实时分析平台，进行实时数据分析和监控。事件源：使用Kafka构建事件源架构，实现事件驱动的微服务通信和数据同步。数据管道：Kafka作为数据管道的核心组件，可以将数据从源系统传输到目标系统，如数据库、数据仓库、数据湖等。消息传递：Kafka可以作为消息中间件，处理高吞吐量、低延迟的消息传递需求。 关于更多Kafka的介绍，请参考《大数据领域的重要基础设施——Kafka入门篇（诞生背景与主要特点介绍）》 这篇文章
2、为什么在Kubernetes中部署Kafka 1. 自动化管理和编排
Kubernetes 提供了自动化的部署、扩展和运维管理，这使得管理复杂的分布式系统如Kafka更加容易。Kubernetes可以自动处理容器的启动、停止和重启，确保Kafka集群的高可用性和稳定性。 2. 弹性扩展
Kubernetes具有强大的扩展能力，可以根据需要动态地增加或减少Kafka节点的数量。这种弹性扩展能力对于应对流量波动和负载变化非常重要，能够确保Kafka在高峰期仍然能够高效地处理数据。 3. 高可用性
Kubernetes的自愈功能可以自动检测和恢复故障节点，确保Kafka服务的高可用性。通过Pod的重启和重新调度，Kubernetes能有效应对节点故障和网络问题，保证Kafka集群的持续运行。 4. 资源隔离和管理
Kubernetes的资源管理能力能够确保Kafka集群的资源需求得到满足。通过使用Kubernetes的资源配额和限制，管理员可以确保Kafka实例拥有足够的CPU、内存和存储资源，从而提高系统的性能和稳定性。 5. 部署一致性
Kubernetes的声明式配置使得Kafka的部署变得更加一致和可重复。使用Kubernetes配置文件（YAML/JSON），可以定义Kafka集群的所需状态，Kubernetes会自动将系统调节到该状态。这种声明式配置简化了部署流程，减少了人为错误的可能性。 6. 便捷的服务发现和负载均衡
Kubernetes内置的服务发现和负载均衡功能可以简化Kafka集群的网络配置。Kubernetes服务（Service）可以为Kafka代理提供一个稳定的网络端点，消费者和生产者可以通过该端点访问Kafka集群，而不必关心具体的Pod IP地址。 3、单机版Kafka与集群版Kafka的对比 1. 可靠性
单机版Kafka：在单机环境下运行，如果这台机器发生故障或崩溃，那么Kafka服务将不可用，导致数据丢失或不可用。因此，单机版Kafka的可靠性相对较低。集群版Kafka：通过多台机器组成的集群来运行Kafka，数据会被复制到多个Broker上，实现数据的冗余存储。即使集群中的某个Broker发生故障，其他Broker仍然可以提供服务，确保数据的可靠性和服务的可用性。 2. 可扩展性
单机版Kafka：受限于单台机器的资源（如CPU、内存、磁盘等），单机版Kafka的可扩展性较差。当数据量或并发量增长时，可能会遇到性能瓶颈。集群版Kafka：集群版Kafka可以通过添加更多的Broker来扩展集群的容量和性能。当数据量或并发量增长时，可以通过水平扩展来应对这些挑战，保持系统的稳定性和性能。 3. 性能
单机版Kafka：虽然单机版Kafka在小型应用或测试环境中可能表现出较好的性能，但在处理大规模数据和高并发场景时，其性能可能会受到限制。集群版Kafka：集群版Kafka通过分布式处理和负载均衡来提高整体性能。多个Broker可以并行处理数据，从而提高吞吐量。此外，集群版Kafka还支持数据分区和复制，进一步提高数据处理能力和容错能力。 4. 容错能力">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-05T07:15:00+08:00">
    <meta property="article:modified_time" content="2024-06-05T07:15:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文教你在k8s中部署单机版kafka（保姆级教程）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1080" src="https://images2.imgbox.com/2f/13/FQySYMiU_o.jpg" width="1200"></p> 
<p style="text-align:center;">🐇明明跟你说过：<a href="https://blog.csdn.net/weixin_53269650?spm=1011.2415.3001.5343" title="个人主页">个人主页</a></p> 
<p style="text-align:center;">🏅个人专栏：<a href="https://blog.csdn.net/weixin_53269650/category_12664280.html?spm=1001.2014.3001.5482" title="《洞察之眼：ELK监控与可视化》">《洞察之眼：ELK监控与可视化》</a>🏅</p> 
<p style="text-align:center;">🔖行路有良友，便是天堂🔖</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80" rel="nofollow">一、引言</a></p> 
<p id="1%E3%80%81Kafka%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81Kafka%E7%AE%80%E4%BB%8B" rel="nofollow">1、Kafka简介</a></p> 
<p id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Kubernetes%E4%B8%AD%E9%83%A8%E7%BD%B2Kafka-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Kubernetes%E4%B8%AD%E9%83%A8%E7%BD%B2Kafka" rel="nofollow">2、为什么在Kubernetes中部署Kafka</a></p> 
<p id="3%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88Kafka%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%89%88Kafka%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88Kafka%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%89%88Kafka%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">3、单机版Kafka与集群版Kafka的对比</a></p> 
<p id="%E4%BA%8C%E3%80%81Kubernetes%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Kubernetes%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" rel="nofollow">二、Kubernetes基础知识</a></p> 
<p id="1%E3%80%81Kubernetes%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81Kubernetes%E7%AE%80%E4%BB%8B" rel="nofollow">1、Kubernetes简介</a></p> 
<p id="2%E3%80%81Pods%E3%80%81Deployments%E3%80%81Services%E7%AD%89%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#2%E3%80%81Pods%E3%80%81Deployments%E3%80%81Services%E7%AD%89%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D" rel="nofollow">2、Pods、Deployments、Services等概念介绍</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%87%86%E5%A4%87Kafka%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%87%86%E5%A4%87Kafka%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%C2%A0" rel="nofollow">三、准备Kafka部署环境 </a></p> 
<p id="1%E3%80%81%E9%80%89%E6%8B%A9Kubernetes%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%85%8D%E7%BD%AE%C2%A0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%80%89%E6%8B%A9Kubernetes%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%85%8D%E7%BD%AE%C2%A0" rel="nofollow">1、选择Kubernetes集群与配置 </a></p> 
<p id="2%E3%80%81%E8%8E%B7%E5%8F%96Kafka%E9%95%9C%E5%83%8F%C2%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%8E%B7%E5%8F%96Kafka%E9%95%9C%E5%83%8F%C2%A0" rel="nofollow">2、获取Kafka镜像 </a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%83%A8%E7%BD%B2%E5%8D%95%E6%9C%BA%E7%89%88Kafka-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%83%A8%E7%BD%B2%E5%8D%95%E6%9C%BA%E7%89%88Kafka" rel="nofollow">四、部署单机版Kafka</a></p> 
<p id="1%E3%80%81%E9%83%A8%E7%BD%B2zookeeper-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%83%A8%E7%BD%B2zookeeper" rel="nofollow">1、部署zookeeper</a></p> 
<p id="2%E3%80%81%E9%83%A8%E7%BD%B2Kafka-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E9%83%A8%E7%BD%B2Kafka" rel="nofollow">2、部署Kafka</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95" rel="nofollow">五、测试</a></p> 
<p id="1%E3%80%81%E8%AE%BF%E9%97%AEKafka%E6%9C%8D%E5%8A%A1-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%AE%BF%E9%97%AEKafka%E6%9C%8D%E5%8A%A1" rel="nofollow">1、访问Kafka服务</a></p> 
<p id="2%E3%80%81%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AATopic%C2%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AATopic%C2%A0" rel="nofollow">2、创建第一个Topic </a></p> 
<p id="3%E3%80%81kafka-topics.sh%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#3%E3%80%81kafka-topics.sh%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D" rel="nofollow">3、kafka-topics.sh工具介绍</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80">一、引言</h2> 
<h3 id="1%E3%80%81Kafka%E7%AE%80%E4%BB%8B">1、Kafka简介</h3> 
<blockquote> 
 <p>Kafka是一个分布式流处理平台，最初由LinkedIn开发，随后开源并捐献给了Apache基金会。Kafka的主要设计目标是处理和存储大规模的实时数据流。</p> 
</blockquote> 
<p><strong>Kafka的核心概念</strong></p> 
<p></p> 
<ul><li><strong>Producer（生产者）：</strong>生产者是向Kafka主题（topic）发送消息的客户端应用程序。生产者发布的数据消息被称为记录（records）。</li><li><strong>Consumer（消费者）：</strong>消费者是从Kafka主题中读取消息的客户端应用程序。消费者从指定的主题订阅并消费消息。</li><li><strong>Topic（主题）：</strong>主题是Kafka中的一个逻辑通道，生产者将消息发布到主题，消费者从主题订阅和消费消息。每个主题可以有多个分区（partition），以实现更高的并行处理能力。</li><li><strong>Partition（分区）：</strong>主题中的数据分为多个分区，每个分区是一个有序的、不可变的记录序列。分区通过分布在集群中的不同Kafka代理（broker）上来实现负载均衡和并行处理。</li><li><strong>Broker（代理）：</strong>Kafka集群中的每个服务器节点被称为一个代理。代理负责存储分区数据，并处理来自生产者和消费者的请求。</li><li><strong>Consumer Group（消费者组）：</strong>消费者组是一组协同工作的消费者。每个消费者组订阅一个或多个主题，并分担消费这些主题中的消息。每条消息只会被消费者组中的一个消费者处理。</li><li><strong>ZooKeeper：</strong>Kafka使用Apache ZooKeeper来管理集群配置、选举代理领导以及进行分布式协调。ZooKeeper确保集群的高可用性和一致性。</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="778" src="https://images2.imgbox.com/80/77/4Iong2nV_o.png" width="1200"></p> 
<p></p> 
<p><strong>Kafka的特点</strong></p> 
<p></p> 
<ol><li> <strong>高吞吐量：</strong>Kafka可以在低延迟下处理大量的数据流，适合实时大数据处理和流数据分析。</li><li><strong>可扩展性：</strong>Kafka通过添加更多的代理节点来水平扩展集群，支持大规模数据处理。</li><li><strong>容错性：</strong>Kafka通过数据复制机制保证消息的高可用性和容错能力，即使在代理节点故障的情况下，也能继续处理消息。</li><li><strong>持久化：</strong>Kafka将消息持久化到磁盘，确保数据的持久存储和可靠传递。</li><li><strong>流处理：</strong>Kafka Streams API提供了强大的流处理功能，可以在消息流上传输和处理数据，进行实时计算和分析。 </li></ol> 
<p class="img-center"><img alt="" height="541" src="https://images2.imgbox.com/80/78/hGi6vEZB_o.png" width="1200"></p> 
<p></p> 
<p><strong>Kafka的典型应用场景</strong></p> 
<p></p> 
<ol><li><strong>日志收集：</strong>Kafka可以从不同的应用程序和系统中收集日志，并将它们统一存储和处理。</li><li><strong>实时分析：</strong>通过Kafka将数据实时传输到流处理系统或实时分析平台，进行实时数据分析和监控。</li><li><strong>事件源：</strong>使用Kafka构建事件源架构，实现事件驱动的微服务通信和数据同步。</li><li><strong>数据管道：</strong>Kafka作为数据管道的核心组件，可以将数据从源系统传输到目标系统，如数据库、数据仓库、数据湖等。</li><li><strong>消息传递：</strong>Kafka可以作为消息中间件，处理高吞吐量、低延迟的消息传递需求。</li></ol> 
<p>关于更多Kafka的介绍，请参考<a class="link-info" href="https://blog.csdn.net/weixin_53269650/article/details/139119762?spm=1001.2014.3001.5501" title="《大数据领域的重要基础设施——Kafka入门篇（诞生背景与主要特点介绍）》">《大数据领域的重要基础设施——Kafka入门篇（诞生背景与主要特点介绍）》</a> 这篇文章</p> 
<h3 id="2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8Kubernetes%E4%B8%AD%E9%83%A8%E7%BD%B2Kafka">2、为什么在Kubernetes中部署Kafka</h3> 
<p></p> 
<p><strong>1. 自动化管理和编排</strong></p> 
<p></p> 
<ul><li>Kubernetes 提供了自动化的部署、扩展和运维管理，这使得管理复杂的分布式系统如Kafka更加容易。Kubernetes可以自动处理容器的启动、停止和重启，确保Kafka集群的高可用性和稳定性。</li></ul> 
<p><strong>2. 弹性扩展</strong></p> 
<p></p> 
<ul><li>Kubernetes具有强大的扩展能力，可以根据需要动态地增加或减少Kafka节点的数量。这种弹性扩展能力对于应对流量波动和负载变化非常重要，能够确保Kafka在高峰期仍然能够高效地处理数据。</li></ul> 
<p><strong>3. 高可用性</strong></p> 
<p></p> 
<ul><li>Kubernetes的自愈功能可以自动检测和恢复故障节点，确保Kafka服务的高可用性。通过Pod的重启和重新调度，Kubernetes能有效应对节点故障和网络问题，保证Kafka集群的持续运行。</li></ul> 
<p><strong>4. 资源隔离和管理</strong></p> 
<p></p> 
<ul><li>Kubernetes的资源管理能力能够确保Kafka集群的资源需求得到满足。通过使用Kubernetes的资源配额和限制，管理员可以确保Kafka实例拥有足够的CPU、内存和存储资源，从而提高系统的性能和稳定性。</li></ul> 
<p><strong>5. 部署一致性</strong></p> 
<p></p> 
<ul><li>Kubernetes的声明式配置使得Kafka的部署变得更加一致和可重复。使用Kubernetes配置文件（YAML/JSON），可以定义Kafka集群的所需状态，Kubernetes会自动将系统调节到该状态。这种声明式配置简化了部署流程，减少了人为错误的可能性。</li></ul> 
<p><strong>6. 便捷的服务发现和负载均衡</strong></p> 
<p></p> 
<ul><li>Kubernetes内置的服务发现和负载均衡功能可以简化Kafka集群的网络配置。Kubernetes服务（Service）可以为Kafka代理提供一个稳定的网络端点，消费者和生产者可以通过该端点访问Kafka集群，而不必关心具体的Pod IP地址。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="558" src="https://images2.imgbox.com/4e/6c/WARk5E3P_o.png" width="1200"></p> 
<h3 id="3%E3%80%81%E5%8D%95%E6%9C%BA%E7%89%88Kafka%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%89%88Kafka%E7%9A%84%E5%AF%B9%E6%AF%94">3、单机版Kafka与集群版Kafka的对比</h3> 
<p><strong>1. 可靠性</strong></p> 
<p></p> 
<ul><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">单机版Kafka：</span></span>在单机环境下运行，如果这台机器发生故障或崩溃，那么Kafka服务将不可用，导致数据丢失或不可用。因此，单机版Kafka的可靠性相对较低。</li><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">集群版Kafka：</span></span>通过多台机器组成的集群来运行Kafka，数据会被复制到多个Broker上，实现数据的冗余存储。即使集群中的某个Broker发生故障，其他Broker仍然可以提供服务，确保数据的可靠性和服务的可用性。</li></ul> 
<p></p> 
<p><strong>2. 可扩展性</strong></p> 
<p></p> 
<ul><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">单机版Kafka：</span></span>受限于单台机器的资源（如CPU、内存、磁盘等），单机版Kafka的可扩展性较差。当数据量或并发量增长时，可能会遇到性能瓶颈。</li><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">集群版Kafka：</span></span>集群版Kafka可以通过添加更多的Broker来扩展集群的容量和性能。当数据量或并发量增长时，可以通过水平扩展来应对这些挑战，保持系统的稳定性和性能。</li></ul> 
<p><br><strong>3. 性能</strong></p> 
<p></p> 
<ul><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">单机版Kafka：</span></span>虽然单机版Kafka在小型应用或测试环境中可能表现出较好的性能，但在处理大规模数据和高并发场景时，其性能可能会受到限制。</li><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">集群版Kafka：</span></span>集群版Kafka通过分布式处理和负载均衡来提高整体性能。多个Broker可以并行处理数据，从而提高吞吐量。此外，集群版Kafka还支持数据分区和复制，进一步提高数据处理能力和容错能力。</li></ul> 
<p><br><strong>4. 容错能力</strong></p> 
<p></p> 
<ul><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">单机版Kafka：</span></span>由于单机版Kafka没有冗余存储和备份机制，因此其容错能力较差。一旦机器发生故障或崩溃，数据将可能丢失。</li><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">集群版Kafka：</span></span>集群版Kafka通过数据复制和分区容错机制来提高容错能力。即使某个Broker发生故障，其他Broker仍然可以提供服务，并确保数据的可靠性和完整性。此外，集群版Kafka还支持数据备份和恢复机制，以应对更严重的故障情况。</li></ul> 
<p></p> 
<p><strong>5. 部署和维护</strong></p> 
<p></p> 
<ul><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">单机版Kafka：</span></span>部署和维护相对简单，只需要关注单台机器的状态和性能即可。</li><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">集群版Kafka：</span></span>集群版Kafka的部署和维护相对复杂一些，需要关注整个集群的状态、性能、负载均衡以及故障恢复等方面。同时，还需要考虑网络延迟、数据同步等问题对集群性能的影响。</li></ul> 
<p>  <img alt="" height="609" src="https://images2.imgbox.com/c1/1c/XxknZx8M_o.png" width="1171"> </p> 
<h2 id="%E4%BA%8C%E3%80%81Kubernetes%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">二、Kubernetes基础知识</h2> 
<h3 id="1%E3%80%81Kubernetes%E7%AE%80%E4%BB%8B">1、Kubernetes简介</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;">Kubernetes（常简称为K8s）</span>是一个开源的容器编排平台，最初由Google开发，后来捐赠给了Cloud Native Computing Foundation（CNCF）进行维护。它旨在简化部署、扩展和管理容器化应用程序的任务。</p> 
</blockquote> 
<p><strong>Kubernetes的主要特点：</strong></p> 
<p><br><strong>1. 自动化部署与扩展：</strong></p> 
<p></p> 
<ul><li>Kubernetes可以自动化地部署和管理容器化应用程序，实现无缝的扩展。它可以根据应用程序的需求自动调整容器数量，并确保它们在集群中均匀地分布。</li></ul> 
<p><strong>2. 自我修复：</strong></p> 
<p></p> 
<ul><li>Kubernetes具有自我修复的能力，能够自动检测并替换失败的容器实例或节点，确保应用程序的高可用性。</li></ul> 
<p><strong>3. 服务发现与负载均衡：</strong></p> 
<p></p> 
<ul><li>Kubernetes提供了内置的服务发现和负载均衡功能，可以将请求动态地路由到可用的容器实例，确保应用程序的稳定性和可靠性。</li></ul> 
<p><strong>4. 自动装箱（Pod）：</strong></p> 
<p></p> 
<ul><li>Kubernetes使用Pod作为最小部署单元，一个Pod可以包含一个或多个相关的容器，并共享网络和存储资源。这种抽象简化了应用程序的部署和管理。</li></ul> 
<p><strong>5. 存储编排：</strong></p> 
<p></p> 
<ul><li>Kubernetes支持多种存储解决方案，并提供了存储卷（Volume）和持久卷（PersistentVolume）等资源，以便应用程序可以方便地访问持久化存储。</li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="687" src="https://images2.imgbox.com/ed/85/t2qmrmUT_o.png" width="1200"></p> 
<h3 id="2%E3%80%81Pods%E3%80%81Deployments%E3%80%81Services%E7%AD%89%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D">2、Pods、Deployments、Services等概念介绍</h3> 
<p><strong>1. Pods（Pod）</strong></p> 
<p><br><strong>Pod是Kubernetes中最小的可部署单元。</strong>它是一个或多个相关容器的组合，它们共享网络和存储空间，并被放置在同一主机上。Pod通常包含一个主应用程序容器，以及辅助容器（如日志收集器、监控代理等）。Pod提供了一种抽象层，使应用程序和服务能够独立于底层的基础设施运行，并具有一定的隔离性。</p> 
<p><strong>2. Deployments（部署）</strong></p> 
<p><br><strong>Deployment是用于定义和管理Pod部署的对象。</strong>它描述了应用程序的期望状态，并负责确保集群中的Pod按照定义的副本数进行部署和维护。Deployment具有自我修复和自动扩展的能力，可以实现滚动更新和回滚操作，保证应用程序的稳定性和可靠性。通过Deployment，开发团队可以轻松地进行应用程序的部署和管理，而无需手动管理Pod实例。</p> 
<p><strong>3. Services（服务）</strong></p> 
<p><br><strong>Service是Kubernetes中用于定义一组Pod的访问入口。</strong>它为一组Pod提供了一个统一的网络终结点，并负责将请求路由到可用的Pod实例。Service可以通过标签选择器来选择相关的Pod，并实现负载均衡和服务发现。Kubernetes支持多种类型的Service，如ClusterIP、NodePort、LoadBalancer等，以满足不同的应用场景和需求。</p> 
<p class="img-center"><img alt="" height="976" src="https://images2.imgbox.com/62/f9/qmBYA9Z7_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%87%86%E5%A4%87Kafka%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%C2%A0">三、准备Kafka部署环境 </h2> 
<h3 id="1%E3%80%81%E9%80%89%E6%8B%A9Kubernetes%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%85%8D%E7%BD%AE%C2%A0">1、选择Kubernetes集群与配置 </h3> 
<p>K8s集群版本 1.23，也可以是其他版本，这里以1.23为例</p> 
<p class="img-center"><img alt="" height="157" src="https://images2.imgbox.com/37/d5/p8qMLAq6_o.png" width="706"></p> 
<h3 id="2%E3%80%81%E8%8E%B7%E5%8F%96Kafka%E9%95%9C%E5%83%8F%C2%A0">2、获取Kafka镜像 </h3> 
<p>在k8s Node节点上执行以下命令</p> 
<pre><code>[root@node1 ~]# docker pull zookeeper:3.8
[root@node1 ~]# docker pull kafka:3.1.0
[root@node2 ~]# docker pull zookeeper:3.8
[root@node2 ~]# docker pull kafka:3.1.0
[root@node3 ~]# docker pull zookeeper:3.8
[root@node3 ~]# docker pull kafka:3.1.0</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E9%83%A8%E7%BD%B2%E5%8D%95%E6%9C%BA%E7%89%88Kafka">四、部署单机版Kafka</h2> 
<h3 id="1%E3%80%81%E9%83%A8%E7%BD%B2zookeeper">1、部署zookeeper</h3> 
<p><strong>为什么部署kafka前要部署zookeeper？</strong></p> 
<p>Kafka依赖Zookeeper来实现分布式协调和配置管理。在Kafka集群中，Zookeeper扮演着多种角色，包括：</p> 
<ol><li><strong>配置管理：</strong>Kafka集群的配置信息和元数据存储在Zookeeper中，包括主题（topics）、分区（partitions）、副本（replicas）等配置信息。</li><li><strong>Leader选举：</strong>Kafka的分区（partitions）被分布式存储在集群中的多个Broker上，每个分区都有一个Leader和多个Follower。Zookeeper负责Leader选举，确保每个分区都有一个活跃的Leader。</li><li><strong>Broker注册：</strong>Kafka Broker在启动时会向Zookeeper注册自己的信息，包括地址、ID等，以便其他Broker和客户端发现和连接。</li><li><strong>健康监测：</strong>Zookeeper监控Kafka集群中各个节点的健康状态，并在节点出现故障或宕机时触发相应的处理操作。</li></ol> 
<p>因此，在部署Kafka之前，需要先部署Zookeeper，确保Kafka集群正常运行所需的分布式协调和配置管理功能可用。没有Zookeeper，Kafka无法正常运行，并且无法实现高可用性、数据一致性和故障容错等特性。</p> 
<p>编写部署zookeeper的YAML文件，如下</p> 
<pre><code>[root@master ~]# vim zook.yaml 
#输入如下内容
apiVersion: apps/v1
kind: Deployment
metadata:
  name: zookeeper-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: zookeeper
  template:
    metadata:
      labels:
        app: zookeeper
    spec:
      containers:
      - name: zookeeper
        image: zookeeper:3.8
        ports:
        - containerPort: 2181
---
apiVersion: v1
kind: Service
metadata:
  name: zookeeper-service
spec:
  selector:
    app: zookeeper
  ports:
    - protocol: TCP
      port: 2181
      targetPort: 2181
      nodePort: 32181  # NodePort设置为32181
  type: NodePort</code></pre> 
<p>部署zookeeper</p> 
<pre><code>[root@master ~]# kubectl apply -f  zook.yaml</code></pre> 
<p>查看状态</p> 
<p> <img alt="" height="279" src="https://images2.imgbox.com/db/57/z6Ti28wU_o.png" width="1086"> </p> 
<h3 id="2%E3%80%81%E9%83%A8%E7%BD%B2Kafka">2、部署Kafka</h3> 
<p>编写部署kafka的YAML文件</p> 
<pre><code>[root@master ~]# cat kafka.yaml 
# 输入如下内容
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      containers:
      - name: kafka
        image: kafka:3.1.0
        ports:
        - containerPort: 9092
        command:
        - sh 
        - -c 
        - "exec /app/kafka/bin/kafka-server-start.sh /app/kafka/config/server.properties --override broker.id=0 \
          --override listeners=PLAINTEXT://:9092 \
          --override advertised.listeners=PLAINTEXT://192.168.40.181:30092 \
          --override zookeeper.connect=192.168.40.181:32181/kafka \
          --override auto.create.topics.enable=true \
          --override zookeeper.session.timeout.ms=6000 \
          --override zookeeper.set.acl=false" 
        env:
        - name: MY_POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name  
        - name: ALLOW_PLAINTEXT_LISTENER
          value: "yes"
        - name: KAFKA_HEAP_OPTS
          value : "-Xms1g -Xmx1g" 
---
apiVersion: v1
kind: Service
metadata:
  name: kafka-service
spec:
  type: NodePort
  ports:
  - port: 30092
    targetPort: 9092
    nodePort: 30092
  selector:
    app: kafka
</code></pre> 
<p>部署kafka</p> 
<pre><code>[root@master ~]# kubectl apply -f  kafka.yaml</code></pre> 
<p>查看状态</p> 
<p> <img alt="" height="273" src="https://images2.imgbox.com/8b/4f/TUha2gNA_o.png" width="1066"> </p> 
<h2 id="%E4%BA%94%E3%80%81%E6%B5%8B%E8%AF%95">五、测试</h2> 
<h3 id="1%E3%80%81%E8%AE%BF%E9%97%AEKafka%E6%9C%8D%E5%8A%A1">1、访问Kafka服务</h3> 
<p>进入到kafka的pod中，使用自带的命令行客户端工具</p> 
<pre><code>[root@master ~]# kubectl exec -it kafka-deployment-6ff7ff6b5b-g22r7 -- /bin/bash</code></pre> 
<p class="img-center"><img alt="" height="405" src="https://images2.imgbox.com/75/81/fwKy1xZF_o.png" width="1200"></p> 
<h3 id="2%E3%80%81%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AATopic%C2%A0">2、创建第一个Topic </h3> 
<pre><code>bash-5.0# ./kafka-topics.sh --bootstrap-server 192.168.40.181:30092 --create --topic test --partitions 1 --replication-factor 1
</code></pre> 
<p>查看详情</p> 
<pre><code>bash-5.0# ./kafka-topics.sh --bootstrap-server 192.168.40.181:30092 --describe --topic test</code></pre> 
<p> <img alt="" height="249" src="https://images2.imgbox.com/1b/72/ClMAVSmc_o.png" width="1200"> </p> 
<h3 id="3%E3%80%81kafka-topics.sh%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D">3、kafka-topics.sh工具介绍</h3> 
<blockquote> 
 <p>kafka-topics.sh 是 Apache Kafka 提供的一个命令行工具，用于管理 Kafka 集群中的主题（topics）。我们可以使用它来创建、列出、描述、修改或删除主题。</p> 
</blockquote> 
<p><strong>1. 列出所有主题</strong><br>  </p> 
<pre><code>bin/kafka-topics.sh --list --bootstrap-server &lt;kafka_connect_string&gt;</code></pre> 
<p></p> 
<p><strong>2. 创建主题</strong></p> 
<pre><code>bin/kafka-topics.sh --create --bootstrap-server &lt;kafka_connect_string&gt; --replication-factor &lt;replication_factor&gt; --partitions &lt;num_partitions&gt; --topic &lt;topic_name&gt;</code></pre> 
<p><br> 其中：</p> 
<ul><li><strong>* `--replication-factor` </strong>是每个分区的副本数量。  </li><li><strong>* `--partitions` </strong>是主题中的分区数量。  </li><li><strong>* `--topic` </strong>是要创建的主题的名称。</li></ul> 
<p><strong>3. 描述主题</strong></p> 
<pre><code>bin/kafka-topics.sh --describe --bootstrap-server &lt;kafka_connect_string&gt; --topic &lt;topic_name&gt;</code></pre> 
<p><br> 这会显示关于主题的详细信息，如分区、副本、领导者等。</p> 
<p><strong>4. 删除主题</strong></p> 
<p><br> 默认情况下，Kafka 不会自动删除主题。但是，如果Kafka 集群启用了 delete.topic.enable 配置（在 server.properties 中），可以使用以下命令来删除主题：</p> 
<pre><code>bin/kafka-topics.sh --delete --bootstrap-server &lt;kafka_connect_string&gt;  --topic &lt;topic_name&gt;</code></pre> 
<p><br> 但是，请注意，即使删除了主题，Kafka 也会保留与该主题相关的日志文件，除非也配置了日志删除策略。</p> 
<p style="text-align:center;"> <img alt="" height="853" src="https://images2.imgbox.com/81/61/TQgyVva4_o.png" width="1200"> </p> 
<blockquote> 
 <p>💕💕💕每一次的分享都是一次成长的旅程，感谢您的陪伴和关注。希望这些关于Kafka的文章能陪伴您走过技术的一段旅程，共同见证成长和进步！😺😺😺</p> 
 <p></p> 
 <p>🧨🧨🧨让我们一起在技术的海洋中探索前行，共同书写美好的未来！！！ </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84c4e194ed437fa7f5d8bdb76ebb39e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot中实现规则引擎源码教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6461aeaa95eec88a33ef02bef8a036ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【微信小程序开发】小程序中的上滑加载更多，下拉刷新是如何实现的？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>