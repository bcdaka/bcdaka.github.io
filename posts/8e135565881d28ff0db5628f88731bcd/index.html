<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL 死锁问题排查与分析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8e135565881d28ff0db5628f88731bcd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MySQL 死锁问题排查与分析">
  <meta property="og:description" content="在数据库管理系统中，死锁是一个常见且棘手的问题。当两个或多个事务相互等待对方释放资源时，就会发生死锁，导致事务无法继续执行，严重时甚至会影响整个系统的稳定性。MySQL作为广泛使用的关系型数据库管理系统，也不例外。本文将详细介绍在遇到MySQL死锁问题时，如何进行排查和分析，帮助读者快速定位问题并采取有效措施解决死锁问题。
1. 死锁的基本概念 1.1 死锁的定义 死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种僵持状态，若无外力作用，这些事务将无法继续执行。
1.2 死锁的四个必要条件 死锁的发生必须满足以下四个必要条件：
互斥条件：资源不能被共享，只能由一个事务占用。请求与保持条件：事务已经占用了至少一个资源，同时又在请求其他资源。不剥夺条件：资源不能被强制剥夺，只能由占用资源的事务主动释放。循环等待条件：存在一个事务的循环链，链中的每个事务都在等待下一个事务占用的资源。 2. 死锁的常见原因 2.1 事务并发控制不当 事务并发控制不当是导致死锁的常见原因之一。例如，事务的隔离级别设置不当、锁的粒度过大或过小、锁的持有时间过长等。
2.2 事务顺序不一致 当多个事务以不同的顺序请求相同的资源时，容易导致死锁。例如，事务A先请求资源1再请求资源2，而事务B先请求资源2再请求资源1。
2.3 资源竞争激烈 在高并发的场景下，多个事务同时请求相同的资源，容易导致资源竞争激烈，从而引发死锁。
2.4 事务设计不合理 事务设计不合理也是导致死锁的原因之一。例如，事务中包含过多的操作、事务的逻辑过于复杂、事务的执行时间过长等。
3. 死锁的排查方法 3.1 查看死锁日志 MySQL提供了详细的死锁日志，可以通过查看死锁日志来获取死锁的相关信息。死锁日志通常包含以下内容：
死锁发生的时间：死锁日志中会记录死锁发生的具体时间。死锁涉及的事务：死锁日志中会记录涉及死锁的事务ID。死锁涉及的资源：死锁日志中会记录涉及死锁的资源，包括表、行等。死锁的详细信息：死锁日志中会记录死锁的详细信息，包括事务的执行语句、锁的类型、锁的持有时间等。 3.1.1 启用死锁日志 在MySQL配置文件中启用死锁日志：
[mysqld] innodb_print_all_deadlocks = 1 3.1.2 查看死锁日志 死锁日志通常存储在MySQL的错误日志文件中，可以通过以下命令查看：
tail -f /var/log/mysql/error.log 3.2 使用SHOW ENGINE INNODB STATUS SHOW ENGINE INNODB STATUS命令可以显示InnoDB存储引擎的状态信息，包括最近发生的死锁信息。
3.2.1 执行SHOW ENGINE INNODB STATUS SHOW ENGINE INNODB STATUS; 3.2.2 分析死锁信息 在输出结果中，找到LATEST DETECTED DEADLOCK部分，可以查看最近发生的死锁信息。死锁信息通常包含以下内容：
死锁涉及的事务：包括事务ID、事务的执行语句、锁的类型等。死锁涉及的资源：包括表、行等。死锁的详细信息：包括锁的持有时间、锁的等待时间等。 3.3 使用Performance Schema MySQL的Performance Schema提供了丰富的性能监控信息，包括锁的等待信息。可以通过Performance Schema来排查死锁问题。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-01T14:06:48+08:00">
    <meta property="article:modified_time" content="2024-07-01T14:06:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL 死锁问题排查与分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在数据库管理系统中，死锁是一个常见且棘手的问题。当两个或多个事务相互等待对方释放资源时，就会发生死锁，导致事务无法继续执行，严重时甚至会影响整个系统的稳定性。MySQL作为广泛使用的关系型数据库管理系统，也不例外。本文将详细介绍在遇到MySQL死锁问题时，如何进行排查和分析，帮助读者快速定位问题并采取有效措施解决死锁问题。</p> 
<h3>1. 死锁的基本概念</h3> 
<h4>1.1 死锁的定义</h4> 
<p>死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种僵持状态，若无外力作用，这些事务将无法继续执行。</p> 
<h4>1.2 死锁的四个必要条件</h4> 
<p>死锁的发生必须满足以下四个必要条件：</p> 
<ul><li><strong>互斥条件</strong>：资源不能被共享，只能由一个事务占用。</li><li><strong>请求与保持条件</strong>：事务已经占用了至少一个资源，同时又在请求其他资源。</li><li><strong>不剥夺条件</strong>：资源不能被强制剥夺，只能由占用资源的事务主动释放。</li><li><strong>循环等待条件</strong>：存在一个事务的循环链，链中的每个事务都在等待下一个事务占用的资源。</li></ul> 
<h3>2. 死锁的常见原因</h3> 
<h4>2.1 事务并发控制不当</h4> 
<p>事务并发控制不当是导致死锁的常见原因之一。例如，事务的隔离级别设置不当、锁的粒度过大或过小、锁的持有时间过长等。</p> 
<h4>2.2 事务顺序不一致</h4> 
<p>当多个事务以不同的顺序请求相同的资源时，容易导致死锁。例如，事务A先请求资源1再请求资源2，而事务B先请求资源2再请求资源1。</p> 
<h4>2.3 资源竞争激烈</h4> 
<p>在高并发的场景下，多个事务同时请求相同的资源，容易导致资源竞争激烈，从而引发死锁。</p> 
<h4>2.4 事务设计不合理</h4> 
<p>事务设计不合理也是导致死锁的原因之一。例如，事务中包含过多的操作、事务的逻辑过于复杂、事务的执行时间过长等。</p> 
<h3>3. 死锁的排查方法</h3> 
<h4>3.1 查看死锁日志</h4> 
<p>MySQL提供了详细的死锁日志，可以通过查看死锁日志来获取死锁的相关信息。死锁日志通常包含以下内容：</p> 
<ul><li><strong>死锁发生的时间</strong>：死锁日志中会记录死锁发生的具体时间。</li><li><strong>死锁涉及的事务</strong>：死锁日志中会记录涉及死锁的事务ID。</li><li><strong>死锁涉及的资源</strong>：死锁日志中会记录涉及死锁的资源，包括表、行等。</li><li><strong>死锁的详细信息</strong>：死锁日志中会记录死锁的详细信息，包括事务的执行语句、锁的类型、锁的持有时间等。</li></ul> 
<h5>3.1.1 启用死锁日志</h5> 
<p>在MySQL配置文件中启用死锁日志：</p> 
<pre><code class="language-bash">[mysqld]
innodb_print_all_deadlocks = 1
</code></pre> 
<h5>3.1.2 查看死锁日志</h5> 
<p>死锁日志通常存储在MySQL的错误日志文件中，可以通过以下命令查看：</p> 
<pre><code class="language-bash">tail -f /var/log/mysql/error.log
</code></pre> 
<h4>3.2 使用SHOW ENGINE INNODB STATUS</h4> 
<p><code>SHOW ENGINE INNODB STATUS</code>命令可以显示InnoDB存储引擎的状态信息，包括最近发生的死锁信息。</p> 
<h5>3.2.1 执行SHOW ENGINE INNODB STATUS</h5> 
<pre><code class="language-sql">SHOW ENGINE INNODB STATUS;
</code></pre> 
<h5>3.2.2 分析死锁信息</h5> 
<p>在输出结果中，找到<code>LATEST DETECTED DEADLOCK</code>部分，可以查看最近发生的死锁信息。死锁信息通常包含以下内容：</p> 
<ul><li><strong>死锁涉及的事务</strong>：包括事务ID、事务的执行语句、锁的类型等。</li><li><strong>死锁涉及的资源</strong>：包括表、行等。</li><li><strong>死锁的详细信息</strong>：包括锁的持有时间、锁的等待时间等。</li></ul> 
<h4>3.3 使用Performance Schema</h4> 
<p>MySQL的Performance Schema提供了丰富的性能监控信息，包括锁的等待信息。可以通过Performance Schema来排查死锁问题。</p> 
<h5>3.3.1 启用Performance Schema</h5> 
<p>在MySQL配置文件中启用Performance Schema：</p> 
<pre><code class="language-bash">[mysqld]
performance_schema = ON
</code></pre> 
<h5>3.3.2 查询锁等待信息</h5> 
<pre><code class="language-sql">SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;
</code></pre> 
<h4>3.4 使用EXPLAIN分析SQL</h4> 
<p>通过<code>EXPLAIN</code>命令可以分析SQL语句的执行计划，帮助排查可能导致死锁的SQL语句。</p> 
<h5>3.4.1 执行EXPLAIN</h5> 
<pre><code class="language-sql">EXPLAIN SELECT * FROM table WHERE condition;
</code></pre> 
<h5>3.4.2 分析执行计划</h5> 
<p>在输出结果中，分析SQL语句的执行计划，包括使用的索引、锁的类型等。</p> 
<h3>4. 死锁的分析方法</h3> 
<h4>4.1 分析死锁日志</h4> 
<p>通过分析死锁日志，可以获取死锁的详细信息，包括涉及的事务、资源、锁的类型等。根据这些信息，可以定位死锁的原因。</p> 
<h4>4.2 分析事务的执行顺序</h4> 
<p>通过分析事务的执行顺序，可以发现事务之间的资源竞争情况。如果多个事务以不同的顺序请求相同的资源，容易导致死锁。</p> 
<h4>4.3 分析锁的粒度和持有时间</h4> 
<p>通过分析锁的粒度和持有时间，可以发现锁的粒度过大或过小、锁的持有时间过长等问题。这些问题都可能导致死锁。</p> 
<h4>4.4 分析SQL语句的执行计划</h4> 
<p>通过分析SQL语句的执行计划，可以发现SQL语句的性能瓶颈，包括使用的索引、锁的类型等。这些问题都可能导致死锁。</p> 
<h3>5. 死锁的解决方法</h3> 
<h4>5.1 优化事务设计</h4> 
<p>优化事务设计是解决死锁问题的根本方法。可以通过以下方式优化事务设计：</p> 
<ul><li><strong>减少事务的粒度</strong>：将大事务拆分为多个小事务，减少锁的持有时间。</li><li><strong>优化事务的执行顺序</strong>：确保多个事务以相同的顺序请求相同的资源。</li><li><strong>减少事务的并发度</strong>：通过调整事务的并发度，减少资源竞争。</li></ul> 
<h4>5.2 优化SQL语句</h4> 
<p>优化SQL语句是解决死锁问题的重要方法。可以通过以下方式优化SQL语句：</p> 
<ul><li><strong>使用合适的索引</strong>：通过使用合适的索引，减少锁的粒度。</li><li><strong>减少锁的持有时间</strong>：通过优化SQL语句，减少锁的持有时间。</li><li><strong>避免全表扫描</strong>：通过避免全表扫描，减少锁的竞争。</li></ul> 
<h4>5.3 调整事务的隔离级别</h4> 
<p>调整事务的隔离级别是解决死锁问题的有效方法。可以通过以下方式调整事务的隔离级别：</p> 
<ul><li><strong>降低隔离级别</strong>：通过降低事务的隔离级别，减少锁的竞争。</li><li><strong>使用乐观锁</strong>：通过使用乐观锁，减少锁的竞争。</li></ul> 
<h4>5.4 使用死锁检测和解决工具</h4> 
<p>使用死锁检测和解决工具是解决死锁问题的辅助方法。可以通过以下方式使用死锁检测和解决工具：</p> 
<ul><li><strong>使用MySQL的死锁检测机制</strong>：MySQL提供了死锁检测机制，可以自动检测和解决死锁问题。</li><li><strong>使用第三方工具</strong>：可以使用第三方工具，如Percona Toolkit，来检测和解决死锁问题。</li></ul> 
<h3>6. 实践案例</h3> 
<h4>6.1 案例1：事务并发控制不当导致的死锁</h4> 
<p>假设有一个电商系统，用户下单时会更新订单表和库存表。由于事务并发控制不当，导致死锁。</p> 
<h5>6.1.1 死锁日志</h5> 
<pre><code class="language-bash">------------------------
LATEST DETECTED DEADLOCK
------------------------
2023-10-01 12:00:00 0x7f8e9a00b700
*** (1) TRANSACTION:
TRANSACTION 123456, ACTIVE 1 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 123, OS thread handle 1234567890, query id 123456789 localhost root updating
UPDATE orders SET status = 'paid' WHERE order_id = 1
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 138 page no 3 n bits 72 index `PRIMARY` of table `test`.`orders` trx id 123456 lock_mode X locks rec but not gap waiting
*** (2) TRANSACTION:
TRANSACTION 123457, ACTIVE 1 sec starting index read
mysql tables in use 1, locked 1
2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 124, OS thread handle 1234567891, query id 1234567892 localhost root updating
UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 1
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 138 page no 3 n bits 72 index `PRIMARY` of table `test`.`orders` trx id 123457 lock mode S locks rec but not gap
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 139 page no 3 n bits 72 index `PRIMARY` of table `test`.`inventory` trx id 123457 lock_mode X locks rec but not gap waiting
*** WE ROLL BACK TRANSACTION (1)
</code></pre> 
<h5>6.1.2 分析死锁日志</h5> 
<p>通过分析死锁日志，可以发现事务1在等待事务2持有的锁，而事务2在等待事务1持有的锁，导致死锁。</p> 
<h5>6.1.3 解决方法</h5> 
<p>通过优化事务设计，减少锁的持有时间，避免死锁。例如，可以将更新订单表和库存表的操作拆分为两个独立的事务。</p> 
<h4>6.2 案例2：事务顺序不一致导致的死锁</h4> 
<p>假设有一个银行转账系统，用户转账时会更新账户表。由于事务顺序不一致，导致死锁。</p> 
<h5>6.2.1 死锁日志</h5> 
<pre><code class="language-bash">------------------------
LATEST DETECTED DEADLOCK
------------------------
2023-10-01 12:00:00 0x7f8e9a00b700
*** (1) TRANSACTION:
TRANSACTION 123456, ACTIVE 1 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 123, OS thread handle 1234567890, query id 1234567893 localhost root updating
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 138 page no 3 n bits 72 index `PRIMARY` of table `test`.`accounts` trx id 123456 lock_mode X locks rec but not gap waiting
*** (2) TRANSACTION:
TRANSACTION 123457, ACTIVE 1 sec starting index read
mysql tables in use 1, locked 1
2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 124, OS thread handle 1234567891, query id 1234567894 localhost root updating
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 138 page no 3 n bits 72 index `PRIMARY` of table `test`.`accounts` trx id 123457 lock mode S locks rec but not gap
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 138 page no 3 n bits 72 index `PRIMARY` of table `test`.`accounts` trx id 123457 lock_mode X locks rec but not gap waiting
*** WE ROLL BACK TRANSACTION (1)
</code></pre> 
<h5>6.2.2 分析死锁日志</h5> 
<p>通过分析死锁日志，可以发现事务1在等待事务2持有的锁，而事务2在等待事务1持有的锁，导致死锁。</p> 
<h5>6.2.3 解决方法</h5> 
<p>通过优化事务设计，确保多个事务以相同的顺序请求相同的资源，避免死锁。例如，可以确保所有转账操作都先更新账户1再更新账户2。</p> 
<h4>6.3 案例3：资源竞争激烈导致的死锁</h4> 
<p>假设有一个社交网络系统，用户发帖时会更新帖子表和用户表。由于资源竞争激烈，导致死锁。</p> 
<h5>6.3.1 死锁日志</h5> 
<pre><code class="language-bash">------------------------
LATEST DETECTED DEADLOCK
------------------------
2023-10-01 12:00:00 0x7f8e9a00b700
*** (1) TRANSACTION:
TRANSACTION 123456, ACTIVE 1 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 123, OS thread handle 1234567890, query id 1234567895 localhost root updating
UPDATE posts SET content = 'new content' WHERE post_id = 1
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 138 page no 3 n bits 72 index `PRIMARY` of table `test`.`posts` trx id 123456 lock_mode X locks rec but not gap waiting
*** (2) TRANSACTION:
TRANSACTION 123457, ACTIVE 1 sec starting index read
mysql tables in use 1, locked 1
2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 124, OS thread handle 1234567891, query id 1234567896 localhost root updating
UPDATE users SET post_count = post_count + 1 WHERE user_id = 1
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 138 page no 3 n bits 72 index `PRIMARY` of table `test`.`posts` trx id 123457 lock mode S locks rec but not gap
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 139 page no 3 n bits 72 index `PRIMARY` of table `test`.`users` trx id 123457 lock_mode X locks rec but not gap waiting
*** WE ROLL BACK TRANSACTION (1)
</code></pre> 
<h5>6.3.2 分析死锁日志</h5> 
<p>通过分析死锁日志，可以发现事务1在等待事务2持有的锁，而事务2在等待事务1持有的锁，导致死锁。</p> 
<h5>6.3.3 解决方法</h5> 
<p>通过优化事务设计，减少锁的持有时间，避免死锁。例如，可以将更新帖子表和用户表的操作拆分为两个独立的事务。</p> 
<h3>7. 结论</h3> 
<p>MySQL死锁问题是数据库管理系统中常见且棘手的问题。通过分析死锁日志、使用<code>SHOW ENGINE INNODB STATUS</code>命令、使用Performance Schema、使用<code>EXPLAIN</code>命令等方法，可以快速定位死锁的原因。通过优化事务设计、优化SQL语句、调整事务的隔离级别、使用死锁检测和解决工具等方法，可以有效解决死锁问题。本文详细介绍了死锁的基本概念、常见原因、排查方法、分析方法和解决方法，并提供了实践案例，希望对读者在实际工作中排查和解决MySQL死锁问题提供有益的参考和指导。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/873fd2983169663e5b916b5c30e2382d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Pandas(全网最详细攻略)（Python）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/851aa2fdfb7e10ade00e5d2f1f7ed71d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【爱上C&#43;&#43;】详解string类2:模拟实现、深浅拷贝</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>