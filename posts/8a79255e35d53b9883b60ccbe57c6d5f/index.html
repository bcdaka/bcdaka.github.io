<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】红黑树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8a79255e35d53b9883b60ccbe57c6d5f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】红黑树">
  <meta property="og:description" content="🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
前言
红黑树的概念
红黑树的性质
节点的定义
红黑树的插入操作 检测操作：
情况一: cur为红，p为红，g为黑，u存在且为红
情况二: cur为红，p为红，g为黑，u不存在/u存在且为黑 Insert 代码
红黑树的验证
红黑树与AVL树的比较
完整代码
前言 💬 hello! 各位铁子们大家好哇。
今日更新了红黑树的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
红黑树的概念 红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或 Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
红黑树的性质 每个结点不是红色就是黑色 根节点是黑色的 如果一个节点是红色的，则它的两个孩子结点是黑色的。(不存在连续的红节点) 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点(每条路径都存在相同数量的黑色节点) 每个叶子结点都是黑色的(此处的叶子结点指的是空结点) 注意：这里的叶子节点指的是空节点，也就是上图中的NIL节点。NIL节点也方便我们数路径，有几个NIL节点，就有几条路径。 最长路径&lt;=最短路径*2 （最长路径就是一红一黑间隔，最短路径就是全黑）
节点的定义 红黑树的插入操作 红黑树是在二叉搜索树的基础上加上其平衡限制条件，因此红黑树的插入可分为两步：
按照二叉搜索的树规则插入新节点检测新节点插入后，红黑树的性质是否造到破坏 新节点的默认颜色是红色，因此：如果其父亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的父亲节点颜色为红色时，就违反了性质三不能有连在一起的红色节点，此时需要对红黑树分情况来讨论。
检测操作： 约定:cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点
情况一: cur为红，p为红，g为黑，u存在且为红 上图是抽象图，a/b/c/d/e代表每条路径有x个黑色节点的红黑子树，且x&gt;=0。 注意：这里所看到的树，可能是一棵完整的树，也可能是一棵子树。
假设此时x==0，cur就是新增节点。
解决方式：将p,u改为黑，g改为红，然后把g当成cur，继续向上调整。
如果g是根节点，调整完成后，将g改成黑色。
如果g是子树，g一定有父亲，如果父亲是红色，就继续往上调整，如果父亲是黑，就结束。
如果x==1，c/d/e就是m/n/p/q四种组合之一。此时新增节点的位置就是a和b的孩子之一。 方法跟上面x==0的情况一样。
情况二: cur为红，p为红，g为黑，u不存在/u存在且为黑 说明：u的情况有两种：
若u不存在，则cur就是新插入节点。因为如果cur不是新插入节点，cur和p一定有一个节点是黑色的，就不满足性质4：每条路径的黑色节点个数相同。若u存在且为黑，则 cur原来的颜色一定是黑的，现在看到是红色是因为cur子树在调整过程中将cur的颜色由黑色改成红色，如下图： 解决方式：
p为g的左孩子，cur为p的左孩子，则进行右单旋转；
相反， p为g的右孩子，cur为p的右孩子，则进行左单旋转
p、g变色--p变黑，g变红
情况二的双旋情况：
解决方法：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-29T16:17:51+08:00">
    <meta property="article:modified_time" content="2024-07-29T16:17:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】红黑树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>🌈个人主页：</strong><a href="https://blog.csdn.net/qinjh_?type=blog" title="秦jh_-CSDN博客">秦jh_-CSDN博客</a><br><strong>🔥 系列专栏：</strong><a href="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482" title="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482">https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482</a></p> 
<p> <img alt="9efbcbc3d25747719da38c01b3fa9b4f.gif" src="https://images2.imgbox.com/f6/80/8urCapx2_o.gif">​ </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">红黑树的概念</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">红黑树的性质</a></p> 
<p id="%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">节点的定义</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">红黑树的插入操作 </a></p> 
<p id="%C2%A0%E6%A3%80%E6%B5%8B%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%A3%80%E6%B5%8B%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow"> 检测操作：</a></p> 
<p id="%E6%83%85%E5%86%B5%E4%B8%80%3A%20cur%E4%B8%BA%E7%BA%A2%EF%BC%8Cp%E4%B8%BA%E7%BA%A2%EF%BC%8Cg%E4%B8%BA%E9%BB%91%EF%BC%8Cu%E5%AD%98%E5%9C%A8%E4%B8%94%E4%B8%BA%E7%BA%A2-toc" style="margin-left:80px;"><a href="#%E6%83%85%E5%86%B5%E4%B8%80%3A%20cur%E4%B8%BA%E7%BA%A2%EF%BC%8Cp%E4%B8%BA%E7%BA%A2%EF%BC%8Cg%E4%B8%BA%E9%BB%91%EF%BC%8Cu%E5%AD%98%E5%9C%A8%E4%B8%94%E4%B8%BA%E7%BA%A2" rel="nofollow">情况一: cur为红，p为红，g为黑，u存在且为红</a></p> 
<p id="%E6%83%85%E5%86%B5%E4%BA%8C%3A%20cur%E4%B8%BA%E7%BA%A2%EF%BC%8Cp%E4%B8%BA%E7%BA%A2%EF%BC%8Cg%E4%B8%BA%E9%BB%91%EF%BC%8Cu%E4%B8%8D%E5%AD%98%E5%9C%A8%2Fu%E5%AD%98%E5%9C%A8%E4%B8%94%E4%B8%BA%E9%BB%91%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%83%85%E5%86%B5%E4%BA%8C%3A%20cur%E4%B8%BA%E7%BA%A2%EF%BC%8Cp%E4%B8%BA%E7%BA%A2%EF%BC%8Cg%E4%B8%BA%E9%BB%91%EF%BC%8Cu%E4%B8%8D%E5%AD%98%E5%9C%A8%2Fu%E5%AD%98%E5%9C%A8%E4%B8%94%E4%B8%BA%E9%BB%91%C2%A0" rel="nofollow">情况二: cur为红，p为红，g为黑，u不存在/u存在且为黑 </a></p> 
<p id="Insert%20%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#Insert%20%E4%BB%A3%E7%A0%81" rel="nofollow">Insert 代码</a></p> 
<p id="%C2%A0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81" rel="nofollow"> 红黑树的验证</a></p> 
<p id="%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:0px;"><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">红黑树与AVL树的比较</a></p> 
<p id="%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow"> 完整代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>    <strong>💬 hello! 各位铁子们大家好哇。</strong></p> 
 <p><strong>             今日更新了红黑树的相关内容</strong><br>     <strong>🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝</strong></p> 
</blockquote> 
<p></p> 
<h2 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">红黑树的概念</h2> 
<p>红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或 Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/6a/79/BGXHkyiq_o.png" width="1200"></p> 
<h2 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">红黑树的性质</h2> 
<ol><li><strong> 每个结点不是红色就是黑色 </strong></li><li><strong> 根节点是黑色的  </strong></li><li><strong> 如果一个节点是红色的，则它的两个孩子结点是黑色的。(不存在连续的红节点)</strong></li><li><strong> 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点(每条路径都存在相同数量的黑色节点)  </strong></li><li><strong>每个叶子结点都是黑色的(此处的叶子结点指的是空结点)</strong></li></ol> 
<blockquote> 
 <p>注意：这里的叶子节点指的是空节点，也就是上图中的NIL节点。NIL节点也方便我们数路径，有几个NIL节点，就有几条路径。 </p> 
 <p>最长路径&lt;=最短路径*2  （最长路径就是一红一黑间隔，最短路径就是全黑）</p> 
</blockquote> 
<h2 id="%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9A%E4%B9%89">节点的定义</h2> 
<p> <img alt="" height="922" src="https://images2.imgbox.com/64/e6/xJhRYknq_o.png" width="632"></p> 
<h2 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%C2%A0">红黑树的插入操作 </h2> 
<p>红黑树是在二叉搜索树的基础上加上其平衡限制条件，因此红黑树的插入可分为两步：</p> 
<ol><li>按照二叉搜索的树规则插入新节点</li><li>检测新节点插入后，红黑树的性质是否造到破坏 </li></ol> 
<blockquote> 
 <p><strong>新节点的默认颜色是红色</strong>，因此：如果其父亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的父亲节点颜色为红色时，就违反了性质三不能有连在一起的红色节点，此时需要对红黑树分情况来讨论。</p> 
</blockquote> 
<h3 id="%C2%A0%E6%A3%80%E6%B5%8B%E6%93%8D%E4%BD%9C%EF%BC%9A"> 检测操作：</h3> 
<p><strong>约定:cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点</strong></p> 
<h4 id="%E6%83%85%E5%86%B5%E4%B8%80%3A%20cur%E4%B8%BA%E7%BA%A2%EF%BC%8Cp%E4%B8%BA%E7%BA%A2%EF%BC%8Cg%E4%B8%BA%E9%BB%91%EF%BC%8Cu%E5%AD%98%E5%9C%A8%E4%B8%94%E4%B8%BA%E7%BA%A2">情况一: cur为红，p为红，g为黑，u存在且为红</h4> 
<p> <img alt="" height="354" src="https://images2.imgbox.com/62/6c/dRrsGyxN_o.png" width="451"></p> 
<blockquote> 
 <p>上图是抽象图，a/b/c/d/e代表每条路径有x个黑色节点的红黑子树，且x&gt;=0。 </p> 
 <p>注意：这里所看到的树，可能是一棵完整的树，也可能是一棵子树。</p> 
</blockquote> 
<p><img alt="" height="373" src="https://images2.imgbox.com/da/db/YULoCrI8_o.png" width="1106"></p> 
<blockquote> 
 <p>假设此时x==0，cur就是新增节点。</p> 
 <p><strong>解决方式：将p,u改为黑，g改为红，然后把g当成cur，继续向上调整。</strong></p> 
 <p>如果g是根节点，调整完成后，将g改成黑色。</p> 
 <p>如果g是子树，g一定有父亲，如果父亲是红色，就继续往上调整，如果父亲是黑，就结束。</p> 
</blockquote> 
<p> <img alt="" height="268" src="https://images2.imgbox.com/5d/88/nlWD8ChS_o.png" width="584"><img alt="" height="458" src="https://images2.imgbox.com/cc/0c/5Fs1KpyB_o.png" width="1200"></p> 
<blockquote> 
 <p>如果x==1，c/d/e就是m/n/p/q四种组合之一。此时新增节点的位置就是a和b的孩子之一。 </p> 
 <p>方法跟上面x==0的情况一样。</p> 
</blockquote> 
<h4 id="%E6%83%85%E5%86%B5%E4%BA%8C%3A%20cur%E4%B8%BA%E7%BA%A2%EF%BC%8Cp%E4%B8%BA%E7%BA%A2%EF%BC%8Cg%E4%B8%BA%E9%BB%91%EF%BC%8Cu%E4%B8%8D%E5%AD%98%E5%9C%A8%2Fu%E5%AD%98%E5%9C%A8%E4%B8%94%E4%B8%BA%E9%BB%91%C2%A0">情况二: cur为红，p为红，g为黑，u不存在/u存在且为黑 </h4> 
<p><img alt="" height="427" src="https://images2.imgbox.com/f1/4a/0swVbTbn_o.png" width="509"></p> 
<blockquote> 
 <p>说明：u的情况有两种：</p> 
 <ol><li>若u不存在，则cur就是新插入节点。因为如果cur不是新插入节点，cur和p一定有一个节点是黑色的，就不满足性质4：每条路径的黑色节点个数相同。</li><li>若u存在且为黑，则 cur原来的颜色一定是黑的，现在看到是红色是因为cur子树在调整过程中将cur的颜色由黑色改成红色，如下图：</li></ol> 
 <p><img alt="" height="569" src="https://images2.imgbox.com/43/3b/VbZKQ58O_o.png" width="1200"></p> 
</blockquote> 
<blockquote> 
 <p><strong>解决方式：</strong></p> 
 <p><strong>p为g的左孩子，cur为p的左孩子，则进行右单旋转；</strong></p> 
 <p><strong>相反， p为g的右孩子，cur为p的右孩子，则进行左单旋转</strong></p> 
 <p><strong>p、g变色--p变黑，g变红</strong></p> 
</blockquote> 
<p><strong>情况二的双旋情况：</strong></p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/25/21/es3QQ9oZ_o.png" width="1052"></p> 
<blockquote> 
 <p><strong>解决方法：</strong></p> 
 <p><strong>p为g的左孩子，cur为p的右孩子，则针对p做左单旋转；</strong></p> 
 <p><strong>相反， p为g的右孩子，cur为p的左孩子，则针对p做右单旋转。则转换成了情况2的单旋情况 ，再按照情况2单旋的方法解决。</strong></p> 
</blockquote> 
<h3 id="Insert%20%E4%BB%A3%E7%A0%81">Insert 代码</h3> 
<pre><code class="language-cpp">bool Insert(const pair&lt;K, V&gt;&amp; kv)
{
	if (_root == nullptr)
	{
		_root = new Node(kv);
		_root-&gt;_col = BLACK;  //根节点默认黑色
		return true;
	}

	Node* cur = _root;
	Node* parent = nullptr;
	while (cur)
	{
		if (cur-&gt;_kv.first &lt; kv.first)
		{
			parent = cur;
			cur = cur-&gt;_right;
		}
		else if (cur-&gt;_kv.first &gt; kv.first)
		{
			parent = cur;
			cur = cur-&gt;_left;
		}
		else
		{
			return false;
		}
	}

	cur = new Node(kv);
	cur-&gt;_col = RED;  //新增节点给红色
	if (parent-&gt;_kv.first &gt; kv.first)
	{
		parent-&gt;_left = cur;
	}
	else
	{
		parent-&gt;_right = cur;
	}
	cur-&gt;_parent = parent;

	// 检测新节点插入后，红黑树的性质是否造到破坏
	//父亲的颜色是黑色也结束
	while (parent &amp;&amp; parent-&gt;_col == RED)
	{
		//关键看叔叔
		Node* grandfather = parent-&gt;_parent;
		if (parent == grandfather-&gt;_left)
		{
			Node* uncle = grandfather-&gt;_right;
			//如果叔叔存在也为红-&gt;变色即可
			if (uncle &amp;&amp; uncle-&gt;_col == RED)
			{
				parent-&gt;_col = uncle-&gt;_col = BLACK;
				grandfather-&gt;_col = RED;

				//继续往上处理
				cur = grandfather;
				parent = cur-&gt;_parent;
			}
			else //叔叔不存在，或者存在且为黑
			{
				if (cur == parent-&gt;_left)
				{
					//      g
					//   p     u
					// c
					//单旋
					RotateR(grandfather);
					parent-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;
				}
				else
				{
					//     g
					//  p     u
					//    c
					//双旋
					RotateL(parent);
					RotateR(grandfather);
					cur-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;
				}
				break;
			}
		}
		else
		{
			Node* uncle = grandfather-&gt;_left; 
			//如果叔叔存在也为红-&gt;变色即可
			if (uncle &amp;&amp; uncle-&gt;_col == RED) 
			{
				parent-&gt;_col = uncle-&gt;_col = BLACK; 
				grandfather-&gt;_col = RED; 

				//继续往上处理
				cur = grandfather; 
				parent = cur-&gt;_parent; 
			}
			else  //叔叔不存在，或者存在且为黑
			{
				//    g
				//  u   p
				//        c
				if (cur == parent-&gt;_right)
				{
					RotateL(grandfather);
					parent-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;
				}
				else
				{
					//      g
					//   u      p
					//        c
					RotateR(parent);
					RotateL(grandfather);
					cur-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;
				}
				break;
			}
		}
	}
	//始终保持根为黑
	_root-&gt;_col = BLACK;

	return true;
}</code></pre> 
<h2 id="%C2%A0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81"> 红黑树的验证</h2> 
<p> 红黑树的检测分为两步：</p> 
<ol><li>检测其是否满足二叉搜索树(中序遍历是否为有序序列）</li><li>检测其是否满足红黑树的性质</li></ol> 
<p></p> 
<pre><code class="language-cpp">	bool IsBalance()
	{
		if (_root-&gt;_col == RED)
		{
			return false;
		}

		int refNum = 0;    //取其中一条路径作为参考值
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_col == BLACK)
			{
				++refNum;
			}
			cur = cur-&gt;_left;
		}

		return Check(_root,0,refNum);
	}

private:
	bool Check(Node* root,int blackNum,const int refNum)
	{
		if (root == nullptr)
		{
			//cout &lt;&lt; blackNum &lt;&lt; endl;
			if (refNum != blackNum)
			{
				cout &lt;&lt; "存在黑色节点数量不相等的路径" &lt;&lt; endl;
				return	false; 
			}
			return true;
		}

		if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; "存在连续的红色节点" &lt;&lt; endl;
			return false;
		}

		if (root-&gt;_col == BLACK)
		{
			blackNum++;
		}

		return Check(root-&gt;_left,blackNum,refNum)
			&amp;&amp; Check(root-&gt;_right,blackNum, refNum);
	}</code></pre> 
<h2 id="%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8EAVL%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83">红黑树与AVL树的比较</h2> 
<p>红黑树和AVL树都是高效的平衡二叉树，增删改查的时间复杂度都是O(logN)，红黑树不追求绝对平衡，其只需保证最长路径不超过最短路径的2倍，相对而言，降低了插入和旋转的次数， 所以在经常进行增删的结构中性能比AVL树更优，而且红黑树实现比较简单，所以实际运用中红 黑树更多。 </p> 
<h2 id="%C2%A0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"> 完整代码</h2> 
<pre><code class="language-cpp">#pragma once 

enum Colour
{
	RED,
	BLACK
};

template&lt;class K,class V&gt;
struct RBTreeNode
{
	RBTreeNode&lt;K, V&gt;* _left;
	RBTreeNode&lt;K, V&gt;* _right;
	RBTreeNode&lt;K, V&gt;* _parent;

	pair&lt;K, V&gt; _kv; 
	Colour _col;

	RBTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _kv(kv)
		, _col(RED)
	{}
};

template&lt;class K,class V&gt;
class RBTree
{
	typedef RBTreeNode&lt;K, V&gt; Node;
public:
	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		if (_root == nullptr)
		{
			_root = new Node(kv);
			_root-&gt;_col = BLACK;  //根节点默认黑色
			return true;
		}

		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		cur = new Node(kv);
		cur-&gt;_col = RED;  //新增节点给红色
		if (parent-&gt;_kv.first &gt; kv.first)
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}
		cur-&gt;_parent = parent;

		// 检测新节点插入后，红黑树的性质是否造到破坏
		//父亲的颜色是黑色也结束
		while (parent &amp;&amp; parent-&gt;_col == RED)
		{
			//关键看叔叔
			Node* grandfather = parent-&gt;_parent;
			if (parent == grandfather-&gt;_left)
			{
				Node* uncle = grandfather-&gt;_right;
				//如果叔叔存在也为红-&gt;变色即可
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					//继续往上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				else //叔叔不存在，或者存在且为黑
				{
					if (cur == parent-&gt;_left)
					{
						//      g
						//   p     u
						// c
						//单旋
						RotateR(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						//     g
						//  p     u
						//    c
						//双旋
						RotateL(parent);
						RotateR(grandfather);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					break;
				}
			}
			else
			{
				Node* uncle = grandfather-&gt;_left; 
				//如果叔叔存在也为红-&gt;变色即可
				if (uncle &amp;&amp; uncle-&gt;_col == RED) 
				{
					parent-&gt;_col = uncle-&gt;_col = BLACK; 
					grandfather-&gt;_col = RED; 

					//继续往上处理
					cur = grandfather; 
					parent = cur-&gt;_parent; 
				}
				else  //叔叔不存在，或者存在且为黑
				{
					//    g
					//  u   p
					//        c
					if (cur == parent-&gt;_right)
					{
						RotateL(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						//      g
						//   u      p
						//        c
						RotateR(parent);
						RotateL(grandfather);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					break;
				}
			}
		}
		//始终保持根为黑
		_root-&gt;_col = BLACK;

		return true;
	}

	void RotateR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR) //节点可能为空
			subLR-&gt;_parent = parent;

		subL-&gt;_right = parent; //旧父节点变成subL的右节点

		Node* ppNode = parent-&gt;_parent;  //该不平衡节点可能不是根节点，所以要找到它的父节点
		parent-&gt;_parent = subL;

		if (parent == _root)   //如果该节点是根节点
		{
			_root = subL;
			_root-&gt;_parent = nullptr;
		}
		else  //不平衡节点只是一棵子树
		{
			if (ppNode-&gt;_left == parent)  //如果旧父节点等于爷爷节点的左节点，新父节点为爷爷节点的左节点
			{
				ppNode-&gt;_left = subL;
			}
			else
			{
				ppNode-&gt;_right = subL;
			}
			subL-&gt;_parent = ppNode;	//新父节点指向爷爷节点。
		}
	}

	void RotateL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		if (subRL)
			subRL-&gt;_parent = parent;

		subR-&gt;_left = parent;
		Node* ppNode = parent-&gt;_parent;

		parent-&gt;_parent = subR;

		if (parent == _root)
		{
			_root = subR;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			if (ppNode-&gt;_right == parent)
			{
				ppNode-&gt;_right = subR;
			}
			else
			{
				ppNode-&gt;_left = subR;
			}
			subR-&gt;_parent = ppNode;
		}
	}

	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}

	bool IsBalance()
	{
		if (_root-&gt;_col == RED)
		{
			return false;
		}

		int refNum = 0;    //取其中一条路径作为参考值
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_col == BLACK)
			{
				++refNum;
			}
			cur = cur-&gt;_left;
		}

		return Check(_root,0,refNum);
	}

private:
	bool Check(Node* root,int blackNum,const int refNum)
	{
		if (root == nullptr)
		{
			//cout &lt;&lt; blackNum &lt;&lt; endl;
			if (refNum != blackNum)
			{
				cout &lt;&lt; "存在黑色节点数量不相等的路径" &lt;&lt; endl;
				return	false; 
			}
			return true;
		}

		if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; "存在连续的红色节点" &lt;&lt; endl;
			return false;
		}

		if (root-&gt;_col == BLACK)
		{
			blackNum++;
		}

		return Check(root-&gt;_left,blackNum,refNum)
			&amp;&amp; Check(root-&gt;_right,blackNum, refNum);
	}


	void _InOrder(Node* root)
	{
		if (root == nullptr)
			return;

		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_kv.first &lt;&lt; ":" &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;
		_InOrder(root-&gt;_right);
	}

private:
	Node* _root = nullptr;
	size_t _size = 0;
};


void RBTreeTest1()
{
	//int a[] = { 8, 3, 1, 10, 6, 4, 7, 14, 13 };
	int a[] = { 4, 2, 6, 1, 3, 5, 15, 7, 16, 14,8, 3, 1, 10, 6, 4, 7, 14, 13 };
	RBTree&lt;int, int&gt; t1;
	for (auto e : a)
	{
		t1.Insert({ e,e });

		//cout &lt;&lt; "Insert:" &lt;&lt; e &lt;&lt; "-&gt;" &lt;&lt; t1.IsBalance() &lt;&lt; endl;
	}

	t1.InOrder();

	cout &lt;&lt; t1.IsBalance() &lt;&lt; endl; 
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88e5e7190cf2c0fcccc354bbbfdeff8e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Stable Diffusion模型训练：从数据准备到模型优化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a77ee53061ba8df3d8205a90ece45100/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Chrome谷歌浏览器Console（控制台）显示文件名及行数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>