<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;|哈希应用-＞布隆过滤器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/791c1f2318990d475821c9a0e7174a91/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;|哈希应用-＞布隆过滤器">
  <meta property="og:description" content="目录
一、概念
二、模拟实现
三、布隆过滤器扩展应用
上一篇章学习了位图的使用，但它只适用于整数，对于要查询字符串是否在不在，位图并不能解决。所以针对这一问题，布隆过滤器可以派上用场，至于布隆过滤器是什么，其实并没有什么神奇的，就是在位图上套了哈希函数罢了，这两者组合起来就是布隆过滤器，而字符串就可以通过哈希函数转换成整数映射到位图当中去。 一、概念 布隆过滤器是由布隆(Burton Howard Bloom)在1970年提出的一种紧凑型的、比较巧妙的概念性数据结构，特点是高效地插入和查询，可以用来告诉你“某样东西一定不存在或者可能存在”，他是用多个哈希函数，将一个数据映射到位图结构中。此种方式不仅可以提升查询效率，也可以节省大量的内存空间。
原理分析： 我们来进行分析，为什么不存在是一定的，而存在是可能的，以及为什么要这样做。
首先来解释为什么要用多个哈希函数。
我们知道，字符串可以通过哈希函数转换成整数，但是哈希冲突是避免不了的，可能存在多个字符串通过哈希函数都得到了一样的整数，所以，为了尽量的减少哈希冲突，可以使用多个哈希函数，让字符串通过多个哈希函数得到多个映射位置，只要不是多个映射位置都相同，就不会冲突，这样大大提高了效率。至于要用几个哈希函数是适合的。
这里有一份研究：（转载详解布隆过滤器的原理，使用场景和注意事项 - 知乎 (zhihu.com)）
其中误报率就是哈希冲突率 其中k、m、n满足：
其中k、m、p满足：
我们可以发现，哈希函数用的越多，哈希冲突率就越低，但是哈希函数到3之后，误报率已经很低了，其次，当哈希函数、插入元素固定，所开空间越大，误报率也越低。
用一张图来表示通过哈希函数映射到位图中：
那么综上，即使采用了多个哈希函数，也依然可能会存在哈希冲突，所以在判断东西在不在时，若返回的是存在，这有可能是误判，说明映射的位置依然可能完全相同，而不存在时，说明映射的位置不完全相同，这是正确的结果，为了确保冲突率，我们在模拟实现的时候就采用3个哈希函数。
二、模拟实现 #include &#34;MyBitSet.h&#34;//在上一篇章已实现 struct BKDRHash { size_t operator()(const string&amp; key) { size_t hash = 0; for (auto e : key) { //BKDR hash *= 31; hash &#43;= e; } return hash; } }; struct APHash { size_t operator()(const string&amp; key) { size_t hash = 0; for (size_t i = 0; i &lt; key.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-05T10:06:56+08:00">
    <meta property="article:modified_time" content="2024-07-05T10:06:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;|哈希应用-＞布隆过滤器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5" rel="nofollow">一、概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">二、模拟实现</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8" rel="nofollow">三、布隆过滤器扩展应用</a></p> 
<hr id="hr-toc"> 
<p> </p> 
<blockquote> 
 <p>上一篇章学习了位图的使用，但它只适用于整数，对于要查询字符串是否在不在，位图并不能解决。所以针对这一问题，布隆过滤器可以派上用场，至于布隆过滤器是什么，其实并没有什么神奇的，就是在位图上套了哈希函数罢了，这两者组合起来就是布隆过滤器，而字符串就可以通过哈希函数转换成整数映射到位图当中去。 </p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5">一、概念</h2> 
<blockquote> 
 <p>布隆过滤器是由布隆(Burton Howard Bloom)在1970年提出的一种紧凑型的、比较巧妙的概念性数据结构，特点是高效地插入和查询，可以用来告诉你“某样东西一定不存在或者可能存在”，他是用多个哈希函数，将一个数据映射到位图结构中。此种方式不仅可以提升查询效率，也可以节省大量的内存空间。</p> 
</blockquote> 
<p><strong>原理分析： </strong></p> 
<p>我们来进行分析，为什么不存在是一定的，而存在是可能的，以及为什么要这样做。</p> 
<p>首先来解释为什么要用多个哈希函数。</p> 
<p>我们知道，字符串可以通过哈希函数转换成整数，但是哈希冲突是避免不了的，可能存在多个字符串通过哈希函数都得到了一样的整数，所以，为了尽量的减少哈希冲突，可以使用多个哈希函数，让字符串通过多个哈希函数得到多个映射位置，只要不是多个映射位置都相同，就不会冲突，这样大大提高了效率。至于要用几个哈希函数是适合的。</p> 
<p>这里有一份研究：（转载<a href="https://zhuanlan.zhihu.com/p/43263751/" rel="nofollow" title="详解布隆过滤器的原理，使用场景和注意事项 - 知乎 (zhihu.com)">详解布隆过滤器的原理，使用场景和注意事项 - 知乎 (zhihu.com)</a>）</p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/54/f6/Af6DD757_o.png" width="888"></p> 
<p>其中误报率就是哈希冲突率 </p> 
<p>其中k、m、n满足：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/c5/47/eOum0rhH_o.png" width="577"></p> 
<p> 其中k、m、p满足：</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/72/7e/kvbEPAuS_o.png" width="522"></p> 
<p>我们可以发现，哈希函数用的越多，哈希冲突率就越低，但是哈希函数到3之后，误报率已经很低了，其次，当哈希函数、插入元素固定，所开空间越大，误报率也越低。</p> 
<p>用一张图来表示通过哈希函数映射到位图中：</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/61/6d/mhdDKAVc_o.png" width="1136"></p> 
<p>那么综上，即使采用了多个哈希函数，也依然可能会存在哈希冲突，所以在判断东西在不在时，若返回的是存在，这有可能是误判，说明映射的位置依然可能完全相同，而不存在时，说明映射的位置不完全相同，这是正确的结果，为了确保冲突率，我们在模拟实现的时候就采用3个哈希函数。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">二、模拟实现</h2> 
<pre><code class="language-cpp">#include "MyBitSet.h"//在上一篇章已实现
struct BKDRHash
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (auto e : key)
		{
			//BKDR
			hash *= 31;
			hash += e;
		}
		return hash;
	}
};


struct APHash
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (size_t i = 0; i &lt; key.size(); i++)
		{
			if ((i &amp; 1) == 0)
			{
				hash ^= ((hash &lt;&lt; 7) ^ key[i] ^ (hash &gt;&gt; 3));
			}
			else
			{
				hash ^= (~((hash &lt;&lt; 11) ^ key[i] ^ (hash &gt;&gt; 5)));
			}
		}
		return hash;
	}
};
struct DJHash
{
	size_t operator()(const string&amp; key)
	{
		
		register size_t hash = 5381;
		for(auto e : key)
		{
			hash += (hash &lt;&lt; 5) + e;
		}
		return hash;
	}
};
namespace bit
{
	template&lt;size_t N, 
		class K = string, //默认输入的是字符串
		class HashFunc1 = BKDRHash,
		class HashFunc2 = APHash,
		class HashFunc3 = DJHash&gt;
	class BloomFilter
	{
	public:
		void set(const K&amp; key)
		{
            //获取三个映射位置
			int hash1 = HashFunc1()(key) % N;
			int hash2 = HashFunc2()(key) % N;
			int hash3 = HashFunc3()(key) % N;

			_blf.set(hash1);
			_blf.set(hash2);
			_blf.set(hash3);

		}

		bool test(const K&amp; key)
		{
			//key不存在是准确的。
			int hash1 = HashFunc1()(key) % N;
			if (_blf.test(hash1) == false)
				return false;

			int hash2 = HashFunc2()(key) % N;
			if (_blf.test(hash2) == false)
				return false;

			int hash3 = HashFunc3()(key) % N;
			if (_blf.test(hash3) == false)
				return false;

			//key存在可能有误判
			return true;
		}
	private:
		bitset&lt;N&gt; _blf;
	};
}

void TestBF1()
{
	bit::BloomFilter&lt;100&gt; bf;
	bf.set("猪八戒");
	bf.set("沙悟净");
	bf.set("孙悟空");
	bf.set("二郎神");

	cout &lt;&lt; bf.test("猪八戒") &lt;&lt; endl;
	cout &lt;&lt; bf.test("沙悟净") &lt;&lt; endl;
	cout &lt;&lt; bf.test("孙悟空") &lt;&lt; endl;
	cout &lt;&lt; bf.test("二郎神") &lt;&lt; endl;
	cout &lt;&lt; bf.test("二郎神1") &lt;&lt; endl;
	cout &lt;&lt; bf.test("二郎神2") &lt;&lt; endl;
	cout &lt;&lt; bf.test("二郎神 ") &lt;&lt; endl;
	cout &lt;&lt; bf.test("太白晶星") &lt;&lt; endl;
}

void TestBF2()
{
	srand(time(0));
	const size_t N = 100000;
	bit::BloomFilter&lt;N * 10&gt; bf;

	std::vector&lt;std::string&gt; v1;
	//std::string url = "https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html";
	std::string url = "猪八戒";

	for (size_t i = 0; i &lt; N; ++i)
	{
		v1.push_back(url + std::to_string(i));
	}

	for (auto&amp; str : v1)
	{
		bf.set(str);
	}

	// v2跟v1是相似字符串集（前缀一样），但是不一样
	std::vector&lt;std::string&gt; v2;
	for (size_t i = 0; i &lt; N; ++i)
	{
		std::string urlstr = url;
		urlstr += std::to_string(9999999 + i);
		v2.push_back(urlstr);
	}

	size_t n2 = 0;
	for (auto&amp; str : v2)
	{
		if (bf.test(str)) // 误判
		{
			++n2;
		}
	}
	cout &lt;&lt; "相似字符串误判率:" &lt;&lt; (double)n2 / (double)N &lt;&lt; endl;

	// 不相似字符串集
	std::vector&lt;std::string&gt; v3;
	for (size_t i = 0; i &lt; N; ++i)
	{
		//string url = "zhihu.com";
		string url = "孙悟空";
		url += std::to_string(i + rand());
		v3.push_back(url);
	}

	size_t n3 = 0;
	for (auto&amp; str : v3)
	{
		if (bf.test(str))
		{
			++n3;
		}
	}
	cout &lt;&lt; "不相似字符串误判率:" &lt;&lt; (double)n3 / (double)N &lt;&lt; endl;
}</code></pre> 
<p>测试：</p> 
<pre><code class="language-cpp">#include &lt;string&gt;
#include "MyBloomFilter.h"


int main()
{

	TestBF2();

	return 0;
}</code></pre> 
<p> 输出结果：</p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/22/6a/MyFD8yxv_o.png" width="502"></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8" style="background-color:transparent;">三、布隆过滤器扩展应用</h2> 
<p>1.给两个文件，分别由100亿个字符串，只有1G内存，如何找到两个文件交集？</p> 
<p>假设每个字符串占50个字节，那么100亿就是5000字节，约等于500G，内存肯定存不下，此时可以采用哈希切分。如图：</p> 
<p> <img alt="" height="1168" src="https://images2.imgbox.com/b6/61/0emLsA1M_o.png" width="1200"></p> 
<p>2.给一个超过100G大小的log file，log中存着IP地址，设计算法找到出现次数最多的IP地址？</p> 
<p>与第一题类似，先进行哈希切分，然后通过map统计每个小文件中IP地址出现的次数进行比较即可。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c9154c26bfd8cb5ed4cf987fb0ec279d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">R&amp;RStudio 下载及安装（详尽版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef5d57623e8cee9260d12b713ea68ff9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">三、分布式软总线的架构设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>