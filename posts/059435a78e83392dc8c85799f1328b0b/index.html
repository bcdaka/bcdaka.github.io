<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>单链表的创建，插入，删除以及查找 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/059435a78e83392dc8c85799f1328b0b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="单链表的创建，插入，删除以及查找">
  <meta property="og:description" content="本文章依据学校的实验作业完成
目录
前言
一、链表是什么？
1.概念
2.链表的分类
二、单链表的创建，插入，删除以及查找
1.单链表的存储结构
2.单链表的创建
3.单链表的插入
4.单链表的删除
5.单链表的查找
6.主函数
7.完整代码
8.编译结果
三、总结
前言 链表是一种物理存储单元上非连续、非顺序的存储结构，由一系列结点组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
一、链表是什么？ 1.概念 链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的。
逻辑上连续是我们想象的连续，并不是真正的连续。
2.链表的分类 单向双向，带头结点不带头结点，循环非循环，组合起来共有8种
二、单链表的创建，插入，删除以及查找 1.单链表的存储结构 typedef int ElemType;	//便于后期的修改 //定义结点类型 typedef struct Node { ElemType data; //单链表中的数据域 struct Node *next; //单链表的指针域 }Node,*LinkedList; 2.单链表的创建 //单链表的建立（头插法） LinkedList ListCreatH() { Node *L; L = (Node *)malloc(sizeof(Node)); //申请头结点空间 L-&gt;next = NULL; //初始化一个空链表 int i=0; ElemType x; //x为链表数据域中的数据 while(i&lt;10) { Node *p; p = (Node *)malloc(sizeof(Node)); //申请新的结点 scanf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-10-22T21:01:29+08:00">
    <meta property="article:modified_time" content="2022-10-22T21:01:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">单链表的创建，插入，删除以及查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>本文章依据学校的实验作业完成</p> 
</blockquote> 
<div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">一、链表是什么？</a></p> 
 <p id="1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E6%A6%82%E5%BF%B5" rel="nofollow">1.概念</a></p> 
 <p id="2.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#2.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">2.链表的分类</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4%E4%BB%A5%E5%8F%8A%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4%E4%BB%A5%E5%8F%8A%E6%9F%A5%E6%89%BE" rel="nofollow">二、单链表的创建，插入，删除以及查找</a></p> 
 <p id="1.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#1.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">1.单链表的存储结构</a></p> 
 <p id="2.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2.单链表的创建</a></p> 
 <p id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">3.单链表的插入</a></p> 
 <p id="4.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#4.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">4.单链表的删除</a></p> 
 <p id="5.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#5.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">5.单链表的查找</a></p> 
 <p id="6.%E4%B8%BB%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#6.%E4%B8%BB%E5%87%BD%E6%95%B0" rel="nofollow">6.主函数</a></p> 
 <p id="7.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#7.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">7.完整代码</a></p> 
 <p id="8.%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#8.%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C" rel="nofollow">8.编译结果</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">三、总结</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
</div> 
<p></p> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，由一系列结点组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p> 
<h2 id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><a id="pandas_16"></a>一、链表是什么？</h2> 
<h3 id="1.%E6%A6%82%E5%BF%B5">1.概念</h3> 
<p>链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的。</p> 
<p>逻辑上连续是我们想象的连续，并不是真正的连续。</p> 
<h3 id="2.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">2.链表的分类</h3> 
<p>单向双向，带头结点不带头结点，循环非循环，组合起来共有8种</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4%E4%BB%A5%E5%8F%8A%E6%9F%A5%E6%89%BE"><a id="_19"></a>二、单链表的创建，插入，删除以及查找</h2> 
<h2 id="1.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><a id="1_20"></a>1.单链表的存储结构</h2> 
<pre><code class="language-cs">typedef int ElemType;	//便于后期的修改 
 
//定义结点类型 
typedef struct Node {
    ElemType data;              //单链表中的数据域 
    struct Node *next;          //单链表的指针域 
}Node,*LinkedList;</code></pre> 
<p></p> 
<h3 id="2.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><a id="2_34"></a>2.单链表的创建</h3> 
<pre><code class="language-cs">	//单链表的建立（头插法）
	
	LinkedList ListCreatH() {
	    Node *L;
	    L = (Node *)malloc(sizeof(Node));   //申请头结点空间
	    L-&gt;next = NULL;                      //初始化一个空链表
	    int i=0;
	    ElemType x;                         //x为链表数据域中的数据
	    while(i&lt;10) {
	        Node *p;
	        p = (Node *)malloc(sizeof(Node));   //申请新的结点 
	        scanf("%d",&amp;x);
	        p-&gt;data = x;                     //结点数据域赋值 
	        p-&gt;next = L-&gt;next;                    //将结点插入到表头L--&gt;|2|--&gt;|1|--&gt;NULL 
	        L-&gt;next = p; 
	        i++;
	    }
	    return L; 
	} 
	 
	 
	//单链表的建立（尾插法）(注：比较常用)
	 
	LinkedList ListCreatT() {
	    Node *L;
		    L = (Node *)malloc(sizeof(Node));   //申请头结点空间
		    L-&gt;next = NULL;                  //初始化一个空链表
		    Node *r;
		    r = L;                          //r始终指向终端结点，开始时指向头结点 
			int i=0   ;                   //x为链表数据域中的数据
		    for(i=0;i&lt;10;i++)
			{ 		
				Node *p;
		        p = (Node *)malloc(sizeof(Node));   //申请新的结点 
		        scanf("%d",&amp;p-&gt;data);
		        r-&gt;next = p;                 //将结点插入到表头L--&gt;|1|--&gt;|2|--&gt;NULL 
		        r = p; 						//将r结点移动到最后一个节点
		    }
		    r-&gt;next = NULL;  				//让r结点的指针域置空(链表创建完成)
		    return L; 
	}</code></pre> 
<h3 id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5">3.单链表的插入</h3> 
<pre><code class="language-cs">//单链表的插入，在链表的第i个位置插入x的元素
/*初始条件：单链表L已存在，1&lt;=i&lt;=ListLength(L)*/
/*在L中第i个位置之前插入新的数据元素e，L的长度加1*/
LinkedList ListInsert(LinkedList L,int i,ElemType x) {
    LinkedList pre;                      //pre为前驱结点 
    pre = L;
    int tempi = 0;
    for (tempi = 1; tempi &lt; i; tempi++) {
    	pre = pre-&gt;next;                 //查找第i个位置的前驱结点 
	}
    Node *p;                                //插入的结点为p
    p = (Node *)malloc(sizeof(Node));
    p-&gt;data = x;             //主要代码
    p-&gt;next = pre-&gt;next;          //主要代码
    pre-&gt;next = p;
    return L;                           
} </code></pre> 
<h3 id="4.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4">4.单链表的删除</h3> 
<pre><code class="language-cs">//单链表的删除，在链表中删除第i个数据元素
/*初始条件：单链表L已存在，1&lt;=i&lt;=ListLength(L)*/
/*操作结果：删除L的第i个数据元素，L的长度减1*/ 
LinkedList ListDelete(LinkedList L,int i)
{
    LinkedList p,q;                   
	int j=2; 
    p = L-&gt;next;
    while(p-&gt;next&amp;&amp;j&lt;i) {              //查找第i个位置 
        p=p-&gt;next;
		++j;
    }
    if(!(p-&gt;next)||j&gt;i)			//第i个元素不存在
		printf("第i个元素不存在\n");
    q=p-&gt;next;				
	p-&gt;next=q-&gt;next;			//将q的后继赋值给p的后继 
    free(q);                    //释放q结点
    return L;
} </code></pre> 
<h3 id="5.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE">5.单链表的查找</h3> 
<pre><code class="language-cs">//单链表的查找
/*初始条件：单链表L已存在，1&lt;=i&lt;=ListLength(L)*/
/*操作结果：用e打印中第i个数据元素的值*/ 
 void GetElem(LinkedList L)
 {
 	int i,j=1;		//j为计数器 
 	int *e;
 	LinkedList p;		//声明一结点p 
 	printf("请输入查找的位置:");
 	scanf("%d",&amp;i);
 	p=L-&gt;next;		//让p指向链表L的第一个结点 
 	while(p&amp;&amp;j&lt;i)        //p不为空且到达i结点
 	{
 		p=p-&gt;next;		//让p指向下一个结点 
 		++j;	
 	}
 	if(!p||j&gt;i)        //链表p为空否则链表长度过短
 		printf("第i个元素不存在");		//第i个元素不存在 
 	*e=p-&gt;data;				//取第i个元素的数据 
 	printf("%d\n",*e);
 }</code></pre> 
<h3 id="6.%E4%B8%BB%E5%87%BD%E6%95%B0">6.主函数</h3> 
<pre><code class="language-cs">int main() {
    LinkedList list,start;
 	printf("请输入单链表的数据：\n"); 
    list = ListCreatT();
    printf("成功创建链表：\n");
    for(start = list-&gt;next; start != NULL; start = start-&gt;next) {
    	printf("%d ",start-&gt;data);
	}
    printf("\n");
    menu();
    int i,option;
    ElemType x;
    do{
		printf("请输入选项：");
		scanf("%d",&amp;option);
		switch(option)
		{
		   	case 1:
			{
			   	printf("请输入插入数据的位置：");
				scanf("%d",&amp;i);
				printf("请输入插入数据的值：");
				scanf("%d",&amp;x);
				ListInsert(list,i,x);
				printf("插入后的链表为：");
				//打印链表 
				for(start = list-&gt;next; start != NULL; start = start-&gt;next)
				{
					printf("%d ",start-&gt;data);
				}
				printf("\n");
					  break;
				}
			case 2:
			{
				int i; 
				printf("请输入删除的位置\n");
				scanf("%d",&amp;i);
				ListDelete(list,i);
				printf("删除后的链表为：");
				//打印链表
				for(start = list-&gt;next; start != NULL; start = start-&gt;next)
				{
					printf("%d ",start-&gt;data);					
				}
				printf("\n");
				break;		
			}
			case 3:GetElem(list);			break;		
			case 0:break;	
			default:printf("输出错误！\n");break;
	   } 		
	}while(option&gt;0);
    return 0;
}</code></pre> 
<h3 id="7.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">7.完整代码</h3> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
typedef int ElemType;	//便于后期的修改 
 
//定义结点类型 
typedef struct Node {
    ElemType data;              //单链表中的数据域 
    struct Node *next;          //单链表的指针域 
}Node,*LinkedList;
 
 
 //建立菜单 
 void menu()
 {
  printf("*****1.单链表的插入*****\n");
  printf("*****2.单链表的删除*****\n");
  printf("*****3.单链表的查找*****\n");
  printf("*****0.     退出   *****\n");
 }
 
//单链表的初始化
 
LinkedList LinkListInit() {
    Node *L;
    L = (Node *)malloc(sizeof(Node));   //申请结点空间 
    if(L == NULL) 	//判断是否有足够的内存空间
	{  
        printf("申请内存空间失败\n");
    }
    L-&gt;next = NULL;                  //将next设置为NULL,初始长度为0的单链表 
 	return L;
}
 
 
	//单链表的建立（头插法）
	 
	 
	LinkedList ListCreatH() {
	    Node *L;
	    L = (Node *)malloc(sizeof(Node));   //申请头结点空间
	    L-&gt;next = NULL;                      //初始化一个空链表
	    int i=0;
	    ElemType x;                         //x为链表数据域中的数据
	    while(i&lt;10) {
	        Node *p;
	        p = (Node *)malloc(sizeof(Node));   //申请新的结点 
	        scanf("%d",&amp;x);
	        p-&gt;data = x;                     //结点数据域赋值 
	        p-&gt;next = L-&gt;next;                    //将结点插入到表头L--&gt;|2|--&gt;|1|--&gt;NULL 
	        L-&gt;next = p; 
	        i++;
	    }
	    return L; 
	} 
	 
	 
	//单链表的建立（尾插法）
	 
	LinkedList ListCreatT() {
	    Node *L;
		    L = (Node *)malloc(sizeof(Node));   //申请头结点空间
		    L-&gt;next = NULL;                  //初始化一个空链表
		    Node *r;
		    r = L;                          //r始终指向终端结点，开始时指向头结点 
			int i=0   ;                   //x为链表数据域中的数据
		    for(i=0;i&lt;10;i++)
			{ 		
				Node *p;
		        p = (Node *)malloc(sizeof(Node));   //申请新的结点 
		        scanf("%d",&amp;p-&gt;data);
		        r-&gt;next = p;                 //将结点插入到表头L--&gt;|1|--&gt;|2|--&gt;NULL 
		        r = p; 						//将r结点移动到最后一个节点
		    }
		    r-&gt;next = NULL;  				//让r结点的指针域置空 
		    return L; 
	}
 
 
//单链表的插入，在链表的第i个位置插入x的元素
/*初始条件：单链表L已存在，1&lt;=i&lt;=ListLength(L)*/
/*在L中第i个位置之前插入新的数据元素e，L的长度加1*/
LinkedList ListInsert(LinkedList L,int i,ElemType x) {
    LinkedList pre;                      //pre为前驱结点 
    pre = L;
    int tempi = 0;
    for (tempi = 1; tempi &lt; i; tempi++) {
    	pre = pre-&gt;next;                 //查找第i个位置的前驱结点 
	}
    Node *p;                                //插入的结点为p
    p = (Node *)malloc(sizeof(Node));
    p-&gt;data = x; 
    p-&gt;next = pre-&gt;next;
    pre-&gt;next = p;
    return L;                           
} 
 
 
//单链表的删除，在链表中删除第i个数据元素
/*初始条件：单链表L已存在，1&lt;=i&lt;=ListLength(L)*/
/*操作结果：删除L的第i个数据元素，L的长度减1*/ 
LinkedList ListDelete(LinkedList L,int i)
{
    LinkedList p,q;                   
	int j=2; 
    p = L-&gt;next;
    while(p-&gt;next&amp;&amp;j&lt;i) {              //查找第i个位置 
        p=p-&gt;next;
		++j;
    }
    if(!(p-&gt;next)||j&gt;i)			//第i个元素不存在
		printf("第i个元素不存在\n");
    q=p-&gt;next;				
	p-&gt;next=q-&gt;next;			//将q的后继赋值给p的后继 
    free(q);
    return L;
} 
 
//单链表的查找
/*初始条件：单链表L已存在，1&lt;=i&lt;=ListLength(L)*/
/*操作结果：用e打印中第i个数据元素的值*/ 
 void GetElem(LinkedList L)
 {
 	int i,j=1;		//j为计数器 
 	int *e;
 	LinkedList p;		//声明一结点p 
 	printf("请输入查找的位置:");
 	scanf("%d",&amp;i);
 	p=L-&gt;next;		//让p指向链表L的第一个结点 
 	while(p&amp;&amp;j&lt;i)
 	{
 		p=p-&gt;next;		//让p指向下一个结点 
 		++j;	
 	}
 	if(!p||j&gt;i)
 		printf("第i个元素不存在");		//第i个元素不存在 
 	*e=p-&gt;data;				//取第i个元素的数据 
 	printf("%d\n",*e);
 }
 
 
int main() {
    LinkedList list,start;
 	printf("请输入单链表的数据：\n"); 
    list = ListCreatT();
    printf("成功创建链表：\n");
    for(start = list-&gt;next; start != NULL; start = start-&gt;next) {
    	printf("%d ",start-&gt;data);
	}
    printf("\n");
    menu();
    int i,option;
    ElemType x;
    do{
		printf("请输入选项：");
		scanf("%d",&amp;option);
		switch(option)
		{
		   	case 1:
			{
			   	printf("请输入插入数据的位置：");
				scanf("%d",&amp;i);
				printf("请输入插入数据的值：");
				scanf("%d",&amp;x);
				ListInsert(list,i,x);
				printf("插入后的链表为：");
				//打印链表 
				for(start = list-&gt;next; start != NULL; start = start-&gt;next)
				{
					printf("%d ",start-&gt;data);
				}
				printf("\n");
					  break;
				}
			case 2:
			{
				int i; 
				printf("请输入删除的位置\n");
				scanf("%d",&amp;i);
				ListDelete(list,i);
				printf("删除后的链表为：");
				//打印链表
				for(start = list-&gt;next; start != NULL; start = start-&gt;next)
				{
					printf("%d ",start-&gt;data);					
				}
				printf("\n");
				break;		
			}
			case 3:GetElem(list);			break;		
			case 0:break;	
			default:printf("输出错误！\n");break;
	   } 		
	}while(option&gt;0);
    return 0;
}</code></pre> 
<h3 id="8.%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C">8.编译结果</h3> 
<p><img alt="" height="525" src="https://images2.imgbox.com/ac/2b/mbzYz63L_o.png" width="578"></p> 
<p></p> 
<p></p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>三、总结</h2> 
<p>常考的知识点：链表的插入，删除的关键语句、在头部插入，中间插入，尾部插入的时间复杂度，以及单链表和顺序表的区别</p> 
<p>在链表尾部添加（addLast()）需要从头遍历，时间复杂度为O(n)<br> 在链表头部添加（addFirst()），时间复杂度为O(1)<br> 在链表任意位置添加(add(int index,E e))，平均情况下为O(n/2)=O(n)</p> 
<p>单链表和顺序表的区别：</p> 
<p style="margin-left:0;text-align:center;"><strong>顺序表的优点：</strong></p> 
<ol><li style="text-align:justify;">元素可以随机存储</li><li style="text-align:justify;">节省存储空间</li><li style="text-align:justify;">元素位置可用一个简单、直观的公式表示并在常量时间内访问</li></ol> 
<p style="margin-left:0;text-align:justify;">                                                                顺序表的缺点：</p> 
<ol><li style="text-align:justify;">在作插入或删除操作时，需要移动大量元素</li></ol> 
<p style="margin-left:0;text-align:center;"><strong>单链表的优点：</strong></p> 
<ol><li style="text-align:justify;"><strong>链表是线性表的链式存储表示</strong></li><li style="text-align:justify;"><strong>链表中逻辑关系相邻的元素不一定在存储位置上相连，用一个链(</strong><strong>指针)</strong><strong>表示元素之间的邻接关系</strong>即：<strong>链表中结点的逻辑顺序和物理顺序不一定相同</strong></li><li style="text-align:justify;"><strong>在插入和删除时，不需要大量移动数据元素，只需找到结点，对该结点做删除和插入的工作即可</strong></li></ol> 
<p style="margin-left:0;text-align:justify;"><strong>                                                                      单链表的缺点：</strong></p> 
<p><strong>在访问第i个位置的元素时，需要遍历链表，不能想顺序表一样直接找到第i个位置。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58dc874efd60b91e2db63a5e04ed1f86/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ERROR 1698 (28000): Access denied for user ‘root‘@‘localhost‘解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a73f99f3f7ed3a768042d65bb06e62db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【工具使用】Keil5软件使用-进阶调试篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>