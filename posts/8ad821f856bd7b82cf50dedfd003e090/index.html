<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法（2）：顺序表与链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8ad821f856bd7b82cf50dedfd003e090/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构与算法（2）：顺序表与链表">
  <meta property="og:description" content="1.前言 哈喽大家好喔，今天博主继续进行数据结构的分享与学习，今天的主要内容是顺序表与链表，是最简单但又相当重要的数据结构，为以后的学习有重要的铺垫，希望大家一起交流学习，互相进步，让我们开始吧。
2.正文 数据结构是计算机科学中非常重要的一部分，用于组织和管理数据以便高效地访问和修改。顺序表和链表是两种常见且基础的数据结构，它们各有特点和适用场景。以下是对这两种数据结构的详细分析：
2.1顺序表 顺序表是在计算机内存中以数组的形式保存的线性表。其有点类似数组，但添加了几个额外的概念。线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中。
这里面有俩个定义顺序表功能的俩个变量：分别是count和size变量，size是用来确定顺序表的存储空间大小的，count是用来标记顺序表中当前元素位置的。
2.1.1结构特点： 物理存储连续性：顺序表中的所有元素在内存中占有一段连续的存储空间。随机访问：顺序表支持通过下标快速访问任意位置的元素，访问时间复杂度为O(1)。空间分配： 静态顺序表：使用定长数组存储元素，适用于数据大小已知的场景，但灵活性较差。动态顺序表：使用动态开辟的数组存储，可以根据需要动态调整存储空间大小，更加灵活。插入和删除操作：由于物理连续性，插入和删除操作需要移动元素，效率较低，时间复杂度为O(n)。 2.1.2结构定义： typedef struct vector { int size, count; int *data; //总大小,元素数量 //指针指向连续的存储区 } vector; //初始化 vector *getNewVector(int n) { vector *p = (vector *)malloc(sizeof(vector)); p-&gt;size = n;//存储上限 p-&gt;count = 0; p-&gt;data = (int *)malloc(sizeof(int) * n); return p; } 2.1.3结构操作： 2.1.3.1插入操作： //插入操作 int insert(vector *v, int pos, int val) { if (pos &lt; 0 || pos &gt; v-&gt;count) return 0; if (v-&gt;size == v-&gt;count &amp;&amp; !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T09:28:24+08:00">
    <meta property="article:modified_time" content="2024-07-18T09:28:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法（2）：顺序表与链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="220" src="https://images2.imgbox.com/fa/3b/w7LnlXCP_o.gif" width="250"></h2> 
<h2><span style="color:#0d0016;">1.前言</span></h2> 
<p><span style="color:#0d0016;">哈喽大家好喔，今天博主继续进行数据结构的分享与学习，今天的主要内容是顺序表与链表，是最简单但又相当重要的数据结构，为以后的学习有重要的铺垫，希望大家一起交流学习，互相进步，让我们开始吧。</span></p> 
<h2><span style="color:#0d0016;">2.正文</span></h2> 
<p><span style="color:#0d0016;">数据结构是计算机科学中非常重要的一部分，用于组织和管理数据以便高效地访问和修改。顺序表和链表是两种常见且基础的数据结构，它们各有特点和适用场景。以下是对这两种数据结构的详细分析：</span></p> 
<h3><span style="color:#0d0016;">2.1顺序表</span></h3> 
<p><span style="color:#0d0016;">顺序表是在计算机内存中以数组的形式保存的线性表。其有点类似数组，但添加了几个额外的概念。线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中。</span></p> 
<p><span style="color:#0d0016;">这里面有俩个定义顺序表功能的俩个变量：分别是count和size变量，size是用来确定顺序表的存储空间大小的，count是用来标记顺序表中当前元素位置的。</span></p> 
<h4><span style="color:#0d0016;">2.1.1结构特点：</span></h4> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><strong>物理存储连续性</strong>：顺序表中的所有元素在内存中占有一段连续的存储空间。</span></li><li><span style="color:#0d0016;"><strong>随机访问</strong>：顺序表支持通过下标快速访问任意位置的元素，访问时间复杂度为O(1)。</span></li><li><span style="color:#0d0016;"><strong>空间分配</strong>：</span> 
   <ul><li><span style="color:#0d0016;"><strong>静态顺序表</strong>：使用定长数组存储元素，适用于数据大小已知的场景，但灵活性较差。</span></li><li><span style="color:#0d0016;"><strong>动态顺序表</strong>：使用动态开辟的数组存储，可以根据需要动态调整存储空间大小，更加灵活。</span></li></ul></li><li><span style="color:#0d0016;"><strong>插入和删除操作</strong>：由于物理连续性，插入和删除操作需要移动元素，效率较低，时间复杂度为O(n)。</span></li></ol> 
</blockquote> 
<h4><span style="color:#0d0016;">2.1.2结构定义：</span></h4> 
<pre><code class="language-cpp">typedef struct vector {
    int size, count;
    int *data;
    //总大小,元素数量
//指针指向连续的存储区
} vector;
//初始化
vector *getNewVector(int n) {
    vector *p = (vector *)malloc(sizeof(vector));
    p-&gt;size = n;//存储上限
    p-&gt;count = 0;
    p-&gt;data = (int *)malloc(sizeof(int) * n);
    return p;
}

</code></pre> 
<h4><span style="color:#0d0016;">2.1.3结构操作：</span></h4> 
<hr> 
<h5><span style="color:#0d0016;">2.1.3.1插入操作：</span></h5> 
<pre><code class="language-cpp">//插入操作
int insert(vector *v, int pos, int val) {
    if (pos &lt; 0 || pos &gt; v-&gt;count) return 0;
    if (v-&gt;size == v-&gt;count &amp;&amp; !expand(v)) return 0;
    for (int i = v-&gt;count - 1; i &gt;= pos; i--) {
        v-&gt;data[i + 1] = v-&gt;data[i];
    }
    v-&gt;data[pos] = val;
    v-&gt;count += 1;
    return 1;
}</code></pre> 
<hr> 
<h5> <span style="color:#0d0016;">2.1.3.2删除操作：</span></h5> 
<pre><code class="language-cpp">//删除操作
void clear(vector *v) {
    if (v == NULL) return ;
    free(v-&gt;data);
    free(v);
    return ;
}</code></pre> 
<hr> 
<h5> <span style="color:#0d0016;">2.1.3.3销毁操作：</span></h5> 
<pre><code class="language-cpp">//销毁操作
int erase(vector *v, int pos) {
    if (pos &lt; 0 || pos &gt;= v-&gt;count) return 0;
    for (int i = pos + 1; i &lt; v-&gt;count; i++) {
        v-&gt;data[i - 1] = v-&gt;data[i];
    }
    v-&gt;count -= 1;
    return 1;
}</code></pre> 
<hr> 
<h5>2.1.3.4自动扩容操作 ：</h5> 
<blockquote> 
 <p>需要顺序表扩容的俩个条件：</p> 
 <ul><li>插入到非法位置，即位置小于0或大于等于size。</li><li>顺序表满了之后如果还需要添加新的元素，就需要扩容。</li></ul> 
</blockquote> 
<hr> 
<blockquote> 
 <p><span style="color:#0d0016;">realloc是 C 标准库中的一个函数，用于调整已经分配的内存块的大小。这个函数常用于动态内存管理，特别是在需要扩展或缩小已经分配的内存时。</span></p> 
 <p><span style="color:#0d0016;">realloc开辟内存的三种情况：</span></p> 
 <ol><li><span style="color:#0d0016;">如果当前内存段后面有足够的空间来满足新的大小要求，<code>realloc</code> 会尝试扩展这段内存空间，并返回原指针。</span></li><li><span style="color:#0d0016;">如果当前内存段后面的空闲字节不够，<code>realloc</code> 会在堆中查找一个能够满足新大小要求的内存块，将原数据复制到新的位置，并释放原来的内存块，然后返回新内存块的首地址。</span></li><li><span style="color:#0d0016;">如果重新分配失败（例如，因为内存不足），<code>realloc</code> 会返回 <code>NULL</code>，但此时原始内存块仍然保持有效。</span></li></ol> 
 <p><span style="color:#fe2c24;"><strong>注意事项：</strong></span></p> 
 <ol><li><span style="color:#0d0016;"><strong>返回值处理</strong>：使用 <code>realloc</code> 时，<span style="background-color:#ffd900;">应始终检查其返回值</span>。如果返回 <code>NULL</code>，表示重新分配失败，此时原始内存块仍然有效，需要适当处理（如释放原始内存块）。</span></li><li><span style="color:#0d0016;"><strong>指针更新</strong>：如果 <code>realloc</code> 成功并返回一个新的地址（不同于原始地址），<span style="background-color:#ffd900;">则需要更新指向该内存块的指针，以避免内存泄漏或野指针问题。</span></span></li><li><span style="color:#0d0016;"><strong>内存释放</strong>：当内存不再使用时，<span style="background-color:#ffd900;">应使用 </span><code><span style="background-color:#ffd900;">free()</span></code><span style="background-color:#ffd900;"> 函数释放内存块</span>。如果 <code>realloc</code> 失败且原始内存块仍需保留，则不应调用 <code>free()</code> 释放它。</span></li><li><span style="color:#0d0016;"><strong>数据保留</strong>：<code>realloc</code> 会保留原始内存块中的数据，并将其复制到新的内存块（如果分配了新的内存块）。<span style="background-color:#ffd900;">但是，如果新大小小于原大小，则超出的数据可能会丢失。</span></span></li></ol> 
</blockquote> 
<pre><code class="language-cpp">//扩容操作
int expand(vector *v) {
    if (v == NULL) return 0;
    printf("expand v from %d to %d\n", v-&gt;size, 2 * v-&gt;size);
    int *p = (int *)realloc(v-&gt;data, sizeof(int) * 2 * v-&gt;size);
    if (p == NULL) return 0;
    v-&gt;data = p;
    v-&gt;size *= 2;
    return 1;
}
</code></pre> 
<hr> 
<h5> 完整调试代码：</h5> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

typedef struct vector {
    int size, count;
    int *data;
    //总大小,元素数量
//指针指向连续的存储区
} vector;
//初始化
vector *getNewVector(int n) {
    vector *p = (vector *)malloc(sizeof(vector));
    p-&gt;size = n;//存储上限
    p-&gt;count = 0;
    p-&gt;data = (int *)malloc(sizeof(int) * n);
    return p;
}

int expand(vector *v) {
    if (v == NULL) return 0;
    printf("expand v from %d to %d\n", v-&gt;size, 2 * v-&gt;size);
    int *p = (int *)realloc(v-&gt;data, sizeof(int) * 2 * v-&gt;size);
    if (p == NULL) return 0;
    v-&gt;data = p;
    v-&gt;size *= 2;
    return 1;
}
//插入操作
int insert(vector *v, int pos, int val) {
    if (pos &lt; 0 || pos &gt; v-&gt;count) return 0;
    if (v-&gt;size == v-&gt;count &amp;&amp; !expand(v)) return 0;
    for (int i = v-&gt;count - 1; i &gt;= pos; i--) {
        v-&gt;data[i + 1] = v-&gt;data[i];
    }
    v-&gt;data[pos] = val;
    v-&gt;count += 1;
    return 1;
}
//销毁操作
int erase(vector *v, int pos) {
    if (pos &lt; 0 || pos &gt;= v-&gt;count) return 0;
    for (int i = pos + 1; i &lt; v-&gt;count; i++) {
        v-&gt;data[i - 1] = v-&gt;data[i];
    }
    v-&gt;count -= 1;
    return 1;
}

void output_vector(vector *v) {
    int len = 0;
    for (int i = 0; i &lt; v-&gt;size; i++) {
        len += printf("%3d", i);
    }
    printf("\n");
    for (int i = 0; i &lt; len; i++) printf("-");
    printf("\n");
    for (int i = 0; i &lt; v-&gt;count; i++) {
        printf("%3d", v-&gt;data[i]);
    }
    printf("\n");
    printf("\n\n");
    return ;
}
//删除操作
void clear(vector *v) {
    if (v == NULL) return ;
    free(v-&gt;data);
    free(v);
    return ;
}

int main() {
    srand(time(0));
    #define MAX_OP 20
    vector *v = getNewVector(2);
    for (int i = 0; i &lt; MAX_OP; i++) {
        int op = rand() % 4, pos, val, ret;
        switch (op) {
            case 0:
            case 1:
            case 2:
                pos = rand() % (v-&gt;count + 2);//为了可以看到插入到非法位置时程序的反应
                val = rand() % 100;
                ret = insert(v, pos, val);
                printf("insert %d at %d to vector = %d\n", 
                    val, pos, ret);
                break;
            case 3:
                pos = rand() % (v-&gt;count + 2);
                ret = erase(v, pos);
                printf("erase item at %d in vector = %d\n", 
                    pos, ret);
                break;
        }
        output_vector(v);
    }
    clear(v);
    return 0;
}</code></pre> 
<hr> 
<h3><span style="color:#0d0016;">2.2链表</span></h3> 
<p><span style="color:#0d0016;">链表是一种物理存储结构上非 连续、非顺序的存储结构，但逻辑上是顺序的。链表由一系列结点（链表中每一个元素称为结点）组成，每个结点包含两个部分：数据域和指针域。数据域用来存储数据，而指针域则用来指向下一个结点。</span></p> 
<h4><span style="color:#0d0016;">2.2.1链表的分类：</span></h4> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><strong>单链表</strong>：每个节点只包含一个指针，指向下一个节点。</span></li><li><span style="color:#0d0016;"><strong>双链表</strong>：每个节点包含两个指针，一个指向前一个节点，另一个指向下一个节点。</span></li><li><span style="color:#0d0016;"><strong>循环链表</strong>：链表的最后一个节点的指针域指向第一个节点，形成一个环。</span></li></ol> 
</blockquote> 
<h4><span style="color:#0d0016;">2.2.2结构特点：</span></h4> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><strong>物理存储非连续性</strong>：链表中的元素可以存储在内存中的任意位置，通过指针链接。</span></li><li><span style="color:#0d0016;"><strong>插入和删除操作高效</strong>：链表的插入和删除操作只需要修改指针指向，不需要移动大量元素，时间复杂度为O(1)。</span></li><li><span style="color:#0d0016;"><strong>不支持随机访问</strong>：链表的访问需要从头节点开始依次遍历到目标节点，访问效率较低。</span></li><li><span style="color:#0d0016;"><strong>空间利用</strong>：链表中的每个节点都需要额外的空间来存储指针，但链表可以动态增长，不需要预分配固定大小的空间。</span></li></ol> 
</blockquote> 
<h4><span style="color:#0d0016;">2.2.3结构定义：</span></h4> 
<pre><code class="language-cpp">typedef struct Lnode
{
	int data;
	struct Lnode *next;
} Lnode, *Linklist;

void InitList (Linklist *L)   //二级指针的目的是地址传递，因为该函数没有返回值，用地址传递带回头节点地址。
{
	Linklist p;
	p = (Linklist)malloc(sizeof(Lnode));
	if(p == NULL)
		cout &lt;&lt; "申请内存空间失败。" &lt;&lt; endl;
	p-&gt;next=NULL;
	*L = p;
	flag++;
}//初始化一个空的链表</code></pre> 
<h4><span style="color:#0d0016;">2.2.4结构操作：</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;">接下来主要介绍几个链表的基础关键操作：</span></p> 
</blockquote> 
<hr> 
<h5><span style="color:#0d0016;">2.2.4.1创建链表操作：</span></h5> 
<pre><code class="language-cpp">void Creatlist(Linklist L,int n)
{
    int i;	
	Lnode *p,*pt;
	pt=L;
	for(i=1;i&lt;=n;i++)
	{	
		p=(Linklist)malloc(sizeof(Lnode));
		if(p==NULL)
			cout &lt;&lt; "申请内存空间失败。" &lt;&lt; endl;
		cout &lt;&lt; "请输入链表中元素：" &lt;&lt; endl;
		cin &gt;&gt; p-&gt;data;		
		p-&gt;next=pt-&gt;next;
		pt-&gt;next=p;
		pt=p;
	}
	//flag++;
}//创建链表</code></pre> 
<hr> 
<h5> <span style="color:#0d0016;">2.2.4.2查找操作：</span></h5> 
<pre><code class="language-cpp">int Getelem(Linklist L, int i)
{
	Lnode *p;
	int e;
	int j;
	p=L-&gt;next;j=1;
	while (p &amp;&amp; j&lt;i)
	{
		p=p-&gt;next;
		++j;
	}
	if(!p || j&gt;i)
		cout &lt;&lt; "该位序不存在。" &lt;&lt; endl;
	else
	{
		e=p-&gt;data;
		cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "个元素为：" &lt;&lt; e &lt;&lt; endl;
	}
	return OK;
}//用e返回L中第i个数据元素的值.</code></pre> 
<hr> 
<h5> <span style="color:#0d0016;">2.2.4.3插入操作：</span></h5> 
<pre><code class="language-cpp">int Listinsert(Linklist L,int i,int e)
{
	int j;
	Lnode *p,*s;
	p=L; j=0;
	while(p &amp;&amp; j&lt;i-1)
	{
		p=p-&gt;next;
		++j;
	}
	if(!p || j&gt;i-1)
		return ERROR;
	s=(Linklist)malloc(sizeof(Lnode));
	if(s==NULL)
		cout &lt;&lt; "申请内存空间失败。" &lt;&lt; endl;
	s-&gt;data=e;
	s-&gt;next=p-&gt;next;
	p-&gt;next=s;
	cout &lt;&lt; "插入的元素是：" &lt;&lt; e &lt;&lt; endl;
	return OK;
}//在第i个位置插入元素e</code></pre> 
<hr> 
<h5><span style="color:#0d0016;">2.2.4.1销毁链表操作：</span></h5> 
<pre><code class="language-cpp">int DestroyList(Linklist L)
{
	Lnode *p;
	p=NULL;
	if(L &amp;&amp; flag!=0)
	{
		while(L)
		{   
			p=L;
			L=L-&gt;next;
			free(p);	
		}
		cout &lt;&lt; "链表已销毁。" &lt;&lt; endl;
	}
	else
		cout &lt;&lt; "链表不存在。" &lt;&lt; endl;
	return OK;
	flag++;
}//销毁链表</code></pre> 
<hr> 
<h3><span style="color:#0d0016;">2.3顺序表和链表的比较：</span></h3> 
<p><span style="color:#0d0016;">这边列举一个表格方便大家对着俩个功能类似的数据结构的特点有更加充分的理解：</span></p> 
<table><thead><tr><th><span style="color:#0d0016;">特点</span></th><th><span style="color:#0d0016;">顺序表</span></th><th><span style="color:#0d0016;">链表</span></th></tr></thead><tbody><tr><td><span style="color:#0d0016;">存储方式</span></td><td><span style="color:#0d0016;">连续存储</span></td><td><span style="color:#0d0016;">非连续存储</span></td></tr><tr><td><span style="color:#0d0016;">随机访问</span></td><td><span style="color:#0d0016;">支持（O(1)）</span></td><td><span style="color:#0d0016;">不支持（需要遍历）</span></td></tr><tr><td><span style="color:#0d0016;">插入/删除操作</span></td><td><span style="color:#0d0016;">效率低（O(n)）</span></td><td><span style="color:#0d0016;">效率高（O(1)）</span></td></tr><tr><td><span style="color:#0d0016;">空间利用</span></td><td><span style="color:#0d0016;">较高（无额外指针空间）</span></td><td><span style="color:#0d0016;">较低（每个节点需额外空间存储指针）</span></td></tr><tr><td><span style="color:#0d0016;">灵活性</span></td><td><span style="color:#0d0016;">较低（需要预分配空间）</span></td><td><span style="color:#0d0016;">较高（可以动态增长）</span></td></tr></tbody></table> 
<h2 style="background-color:transparent;"><span style="color:#0d0016;">3.小结</span></h2> 
<p>今天数据结构第二讲：顺序表与链表到这里就结束了，未来俩天会有链表相关延展问题实现的博客出炉，不要忘了点一手关注再走哦，希望喜欢的朋友多多支持我哦~</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61021e86f105145a51c3213ae3176276/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">李彦宏论AI：技术革新与产业价值的双重驱动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe69f5275b3ef5a93975ce897ebc1172/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">云手机结合自主ADB命令接口 提升海外营销效率</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>