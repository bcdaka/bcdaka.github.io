<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>后端开发刷题 | 面试篇3 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1ac5970d56a4d823473ae698d7488c5f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="后端开发刷题 | 面试篇3">
  <meta property="og:description" content="说一说HashMap的扩容机制 1. 初始容量和加载因子 初始容量（Initial Capacity）：HashMap 在创建时可以指定一个初始容量，它是桶数组（Entry&lt;K,V&gt;[] table）的初始大小。如果没有指定初始容量，则默认为 16。加载因子（Load Factor）：加载因子是 HashMap 在其容量自动增加之前可以达到多满的一个尺度。当 HashMap 中的条目数超过了加载因子与当前容量的乘积时，就会进行扩容。如果没有特别指定，加载因子默认为 0.75。 2. 扩容过程 当 HashMap 中的元素个数超过 容量 * 加载因子 时，就会触发扩容。扩容的过程大致如下：
创建一个新的桶数组：新数组的容量是旧数组容量的两倍（如果旧数组容量是 MAXIMUM_CAPACITY（即 1 &lt;&lt; 30），则不再扩容，因为已经到达最大容量）。
重新计算索引：遍历旧数组中的每个元素，根据每个元素的键重新计算哈希值，并据此确定元素在新数组中的索引位置。这里可能会遇到哈希冲突，但 HashMap 通过链表或红黑树（Java 8 引入）来解决冲突。
复制元素：将旧数组中的元素复制到新数组中对应的位置。如果是链表，则直接整体移动；如果是红黑树，则进行红黑树的复制。
替换桶数组：将 HashMap 的 table 引用指向新的桶数组。
IP协议的首部结构 首部协议一共是20个字节（固定）
第一个4字节： 版本号；首部长度； 服务类型；总长度；
第二个4字节：标识；标志；片偏移；
第三个4字节：生存时间；协议；校验和；
第四个4字节：源ip地址；
第五个4字节：目的ip地址；
说一说进程调度算法有哪些 1. 先来先服务（FCFS，First-Come, First-Served） 描述：按照作业或进程到达任务队列的顺序进行调度。它是一种非抢占式的调度算法，即一旦CPU分配给某个进程，该进程将一直执行，直到完成或发生某种阻塞事件。优点：易于理解且实现简单，只需要一个队列，并且相当公平。缺点：对短作业（进程）不利，可能导致其长时间等待，同时也不利于处理紧急作业。 2. 时间片轮转（RR，Round-Robin） 描述：将CPU处理时间划分为多个时间片，每个进程被分配一个时间片，进程在时间片结束时被抢占，并重新放入队列末尾等待下一次调度。优点：简单易行，平均响应时间短，可以保证每个进程都有机会获得CPU资源，防止长时间运行的进程垄断CPU。缺点：时间片大小需要设置得合适才能实现最好的性能，过大可能导致响应时间过长，过小则会导致频繁的进程切换，增加系统开销。 3. 最短作业优先（SJF，Shortest Job First） 描述：每次从队列中选择预计执行时间最短的作业或进程进行调度。该算法可以是抢占式的，也可以是非抢占式的。优点：可以降低平均等待时间和提高系统吞吐量，优先照顾短作业。缺点：对长作业不友好，可能导致其长时间得不到执行，出现饥饿现象。同时，难以准确估计作业的执行时间，影响调度性能。 4. 最短剩余时间优先（SRTF，Shortest Remaining Time First） 描述：是SJF算法的抢占式版本。每次调度时，选择剩余执行时间最短的进程执行。如果新到达的进程剩余执行时间更短，则抢占当前执行的进程。优点：确保短作业或短进程优先被处理。缺点：由于频繁的抢占和进程切换，系统开销大，实现代价高。 5. 最高响应比优先（HRRN，Highest Response Ratio Next） 描述：根据响应比R=（等待时间&#43;服务时间）/服务时间进行调度。响应比越高，进程优先级越高。优点：既考虑了作业的等待时间，又考虑了作业的执行时间，使得长作业也有机会得到执行。缺点：需要一直计算响应比，增加了系统资源的消耗。 6.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-27T12:34:31+08:00">
    <meta property="article:modified_time" content="2024-08-27T12:34:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">后端开发刷题 | 面试篇3</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>说一说HashMap的扩容机制</h2> 
<blockquote> 
 <h5>1. 初始容量和加载因子</h5> 
 <ul><li><strong>初始容量（Initial Capacity）</strong>：<code>HashMap</code> 在创建时可以指定一个初始容量，它是桶数组（<code>Entry&lt;K,V&gt;[] table</code>）的初始大小。如果没有指定初始容量，则默认为 16。</li><li><strong>加载因子（Load Factor）</strong>：加载因子是 <code>HashMap</code> 在其容量自动增加之前可以达到多满的一个尺度。当 <code>HashMap</code> 中的条目数超过了加载因子与当前容量的乘积时，就会进行扩容。如果没有特别指定，加载因子默认为 0.75。</li></ul> 
 <h5>2. 扩容过程</h5> 
 <p id="">当 <code>HashMap</code> 中的元素个数超过 <code>容量 * 加载因子</code> 时，就会触发扩容。扩容的过程大致如下：</p> 
 <ol><li> <p id=""><strong>创建一个新的桶数组</strong>：新数组的容量是旧数组容量的两倍（如果旧数组容量是 <code>MAXIMUM_CAPACITY</code>（即 <code>1 &lt;&lt; 30</code>），则不再扩容，因为已经到达最大容量）。</p> </li><li> <p id=""><strong>重新计算索引</strong>：遍历旧数组中的每个元素，根据每个元素的键重新计算哈希值，并据此确定元素在新数组中的索引位置。这里可能会遇到哈希冲突，但 <code>HashMap</code> 通过链表或红黑树（Java 8 引入）来解决冲突。</p> </li><li> <p id=""><strong>复制元素</strong>：将旧数组中的元素复制到新数组中对应的位置。如果是链表，则直接整体移动；如果是红黑树，则进行红黑树的复制。</p> </li><li> <p id=""><strong>替换桶数组</strong>：将 <code>HashMap</code> 的 <code>table</code> 引用指向新的桶数组。</p> </li></ol> 
</blockquote> 
<p></p> 
<h2>IP协议的首部结构 </h2> 
<blockquote> 
 <p>首部协议一共是20个字节（固定）</p> 
 <p>第一个4字节： 版本号；首部长度； 服务类型；总长度；</p> 
 <p>第二个4字节：标识；标志；片偏移；</p> 
 <p>第三个4字节：生存时间；协议；校验和；</p> 
 <p>第四个4字节：源ip地址；</p> 
 <p>第五个4字节：目的ip地址；</p> 
</blockquote> 
<p></p> 
<h2>说一说进程调度算法有哪些</h2> 
<blockquote> 
 <h4>1. 先来先服务（FCFS，First-Come, First-Served）</h4> 
 <ul><li><strong>描述</strong>：按照作业或进程到达任务队列的顺序进行调度。它是一种非抢占式的调度算法，即一旦CPU分配给某个进程，该进程将一直执行，直到完成或发生某种阻塞事件。</li><li><strong>优点</strong>：易于理解且实现简单，只需要一个队列，并且相当公平。</li><li><strong>缺点</strong>：对短作业（进程）不利，可能导致其长时间等待，同时也不利于处理紧急作业。</li></ul> 
 <h4>2. 时间片轮转（RR，Round-Robin）</h4> 
 <ul><li><strong>描述</strong>：将CPU处理时间划分为多个时间片，每个进程被分配一个时间片，进程在时间片结束时被抢占，并重新放入队列末尾等待下一次调度。</li><li><strong>优点</strong>：简单易行，平均响应时间短，可以保证每个进程都有机会获得CPU资源，防止长时间运行的进程垄断CPU。</li><li><strong>缺点</strong>：时间片大小需要设置得合适才能实现最好的性能，过大可能导致响应时间过长，过小则会导致频繁的进程切换，增加系统开销。</li></ul> 
 <h4>3. 最短作业优先（SJF，Shortest Job First）</h4> 
 <ul><li><strong>描述</strong>：每次从队列中选择预计执行时间最短的作业或进程进行调度。该算法可以是抢占式的，也可以是非抢占式的。</li><li><strong>优点</strong>：可以降低平均等待时间和提高系统吞吐量，优先照顾短作业。</li><li><strong>缺点</strong>：对长作业不友好，可能导致其长时间得不到执行，出现饥饿现象。同时，难以准确估计作业的执行时间，影响调度性能。</li></ul> 
 <h4>4. 最短剩余时间优先（SRTF，Shortest Remaining Time First）</h4> 
 <ul><li><strong>描述</strong>：是SJF算法的抢占式版本。每次调度时，选择剩余执行时间最短的进程执行。如果新到达的进程剩余执行时间更短，则抢占当前执行的进程。</li><li><strong>优点</strong>：确保短作业或短进程优先被处理。</li><li><strong>缺点</strong>：由于频繁的抢占和进程切换，系统开销大，实现代价高。</li></ul> 
 <h4>5. 最高响应比优先（HRRN，Highest Response Ratio Next）</h4> 
 <ul><li><strong>描述</strong>：根据响应比R=（等待时间+服务时间）/服务时间进行调度。响应比越高，进程优先级越高。</li><li><strong>优点</strong>：既考虑了作业的等待时间，又考虑了作业的执行时间，使得长作业也有机会得到执行。</li><li><strong>缺点</strong>：需要一直计算响应比，增加了系统资源的消耗。</li></ul> 
 <h4>6. 多级反馈队列调度算法（Multilevel Feedback Queue Scheduling）</h4> 
 <ul><li><strong>描述</strong>：设置多个就绪队列，并为每个队列赋予不同的优先级和时间片大小。进程首先进入最高优先级的队列，如果在时间片内未完成，则降入下一级队列，以此类推。仅当高优先级队列为空时，才调度低优先级队列中的进程。</li><li><strong>优点</strong>：公平性好，能够适应多种不同的任务，不必事先知道进程的执行时间。</li><li><strong>缺点</strong>：设计复杂，实现难度较大。</li></ul> 
</blockquote> 
<p></p> 
<h2>介绍一下Java中的IO流</h2> 
<blockquote> 
 <h4>一、IO流的基本概念</h4> 
 <ul><li><strong>流</strong>：是一种抽象的概念，代表数据的无结构化传递。流是一个无结构化的数据组成的序列，以字节或字符形式输入或输出。</li><li><strong>输入流</strong>：数据从外部数据源流入到程序内部的过程。</li><li><strong>输出流</strong>：数据从程序内部向外部流出到数据目的地的过程。</li></ul> 
 <h4>二、IO流的分类</h4> 
 <h5>1. 按处理的数据类型分类</h5> 
 <ul><li><strong>字节流</strong>：以字节（Byte，1Byte=8bit）为单位进行读写操作，可以处理所有类型的数据，如图片、视频等二进制文件。主要类有<code>InputStream</code>和<code>OutputStream</code>。</li><li><strong>字符流</strong>：以字符（通常是16位Unicode字符）为单位进行读写操作，更适合处理文本数据。主要类有<code>Reader</code>和<code>Writer</code>。</li></ul> 
 <h5>2. 按数据的流向分类</h5> 
 <ul><li><strong>输入流</strong>：用于从外部数据源读取数据到程序中，如<code>FileInputStream</code>、<code>BufferedReader</code>等。</li><li><strong>输出流</strong>：用于将程序中的数据输出到外部目的地，如<code>FileOutputStream</code>、<code>BufferedWriter</code>等。</li></ul> 
 <h5>3. 按处理数据功能分类</h5> 
 <ul><li><strong>节点流</strong>（又称实体流）：直接对数据源或目的地进行读写操作，如<code>FileInputStream</code>、<code>FileOutputStream</code>等。</li><li><strong>处理流</strong>（又称装饰流）：不直接连接数据源或目的地，而是对已有的流进行封装，提供额外的功能，如缓冲、转换等。常见的处理流有<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code>等。</li></ul> 
 <h4>三、IO流的主要类和方法</h4> 
 <p id="">Java的IO流体系涉及多个类和接口，但核心类主要包括<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和<code>Writer</code>四个抽象类及其子类。这些类提供了丰富的方法来支持数据的读写操作，如<code>read()</code>、<code>write()</code>、<code>close()</code>等。</p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b30879bee2719e4a11fac8ccb32c361/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最新网站服务器CC压力测试系统源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70319556a4e2ac7fe9e1ef6d36ed6758/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">liunx 上python编译安装| 用Anaconda同时安装运行多个不同版本的python环境| 在CentOS 7上安装Python 3.7| 汉化 python| 均无误，已测试运行成功</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>