<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【AIGC】Llama-3 官方技术报告 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/12011f1a91df021184ac017699d78995/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【AIGC】Llama-3 官方技术报告">
  <meta property="og:description" content="Llama-3 技术报告（中文翻译） 欢迎关注【youcans的AGI学习笔记】原创作品
0. 简介 现代人工智能（AI）系统的核心驱动力来自于基础模型。
本文介绍了一组新的基础模型，称为 Llama 3。它是一个语言模型系列，原生支持多语言性、编码、推理和工具使用。
其中，我们所构建的最大模型是一个密集型的Transformer架构，拥有4050亿个参数，能够处理高达12k tokens的上下文窗口。
本文提供了对Llama 3的广泛实证评估。我们发现，在众多任务中，Llama 3的表现质量与诸如GPT-4这样的领军语言模型相当。我们公开发布了 Llama 3，包括405B 参数语言模型的预训练和后训练版本，以及用于输入和输出安全的 Llama Guard 3 模型。
本文还介绍了我们通过组合方法将图像、视频和语音功能集成到 Llama 3 中的实验结果。我们观察到这种方法在图像、视频和语音识别任务上的表现与最先进的方法不相上下。由于模型仍在开发中，因此尚未广泛发布。
Llama3 简介：
模型：llama 3.1 模型系列：405B（含量化版）、70B、8B， 128k的上下文工具：开源配套的Agent系统网站：https://llama.meta.com/日期: July 23,2024 Llama3的卓越表现源于三大核心要素：
高质量数据：15T tokens的高质量多语言数据。规模性：8B、70B、405B的模型矩阵，通过大模型提升小模型的质量，实现同类最佳效果。简洁性：选择Transformer架构而非MoE架构，采用相对简单的后训练程序，如SFT、RS和DPO，而非复杂的强化学习算法。
报告还分享了Llama3在多模态集成方面的初步实验，展现了其在图像、视频和语音处理方面的潜力。 Llama3的开发历程：预训练与后训练
预训练：在15.6万亿token上预训练了4050亿参数的模型，上下文窗口为8K token。随后进行继续预训练，将上下文窗口扩展至128K token。后训练：通过多轮人类反馈与模型对齐，每轮包括监督式微调（SFT）和直接偏好优化（DPO）。后训练阶段还整合了工具使用等新能力，并在编码和推理等领域取得显著进展。 Llama3的多模态能力：图像、视频和语音的融合
为了赋予Llama3多模态能力，Meta采用了组合方法，引入了图像、视频和语音编码器。具体过程包括：
多模态编码器预训练：分别对图像和语音编码器进行训练，学习视觉和语音信号的表示。视觉适配器训练：将图像编码器融入预训练的语言模型，实现图像表示与语言表示的对齐。在此基础上，训练视频适配器，实现跨帧信息聚合。语音适配器训练：将语音编码器整合到模型中，实现高质量的语音理解。 Llama3 技术报告目录
引言：Llama3成功的三大要素、开发历程、多模态能力概述预训练
预训练数据：数据来源、清洗、去重、过滤等
模型架构：Transformer架构选择、参数设置等
规模定律实验：模型规模对性能的影响
基础设施、扩展和效率：训练硬件、并行策略、优化技巧等
训练方法：初始预训练、长上下文预训练、退火等后期训练
建模：SFT、RM、DPO等技术
后期训练数据：清洗、修剪等
Chat能力：代码、多语言、数学和推理、长文本、工具调用能力，以及如何减少幻觉等效果评估
Base模型：benchmark指标、鲁棒性、对抗性和污染分析
Chat模型：通用知识和指令遵循benchmark指标、人类考试GRE/LSAT/SAT/AP/GMAT等、单项技能测试
人类评估：在几乎所有能力上，Llama 3 405B和GPT-4的胜利率在误差范围内
安全性评估：安全评估基准、预训练和微调效果等推理
流水线并行：推理加速技术
FP8量化：模型量化技术视觉实验
数据：图像和视频数据处理
模型架构：图像编码器、图像适配器、视频适配器语音实验
数据：语音数据处理
模型架构：语音编码器、语音适配器相关工作结论贡献者和致谢 1. 引言 基础模型是语言、视觉、语音或其他模式的通用模型，旨在支持各种人工智能任务。它们构成了许多现代人工智能系统的基础。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T16:02:48+08:00">
    <meta property="article:modified_time" content="2024-07-25T16:02:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【AIGC】Llama-3 官方技术报告</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Llama3__0"></a>Llama-3 技术报告（中文翻译）</h2> 
<p><strong>欢迎关注<a href="https://blog.csdn.net/youcans/category_12244543.html">【youcans的AGI学习笔记】</a>原创作品</strong></p> 
<p><img src="https://images2.imgbox.com/41/95/xdCk6gsD_o.png" alt="在这里插入图片描述"></p> 
<br> 
<h3><a id="0__9"></a>0. 简介</h3> 
<p>现代人工智能（AI）系统的核心驱动力来自于基础模型。<br> 本文介绍了一组新的基础模型，称为 Llama 3。它是一个语言模型系列，原生支持多语言性、编码、推理和工具使用。<br> 其中，我们所构建的最大模型是一个密集型的Transformer架构，拥有4050亿个参数，能够处理高达12k tokens的上下文窗口。<br> 本文提供了对Llama 3的广泛实证评估。我们发现，在众多任务中，Llama 3的表现质量与诸如GPT-4这样的领军语言模型相当。我们公开发布了 Llama 3，包括405B 参数语言模型的预训练和后训练版本，以及用于输入和输出安全的 Llama Guard 3 模型。<br> 本文还介绍了我们通过组合方法将图像、视频和语音功能集成到 Llama 3 中的实验结果。我们观察到这种方法在图像、视频和语音识别任务上的表现与最先进的方法不相上下。由于模型仍在开发中，因此尚未广泛发布。</p> 
<ul><li> <p>Llama3 简介：</p> 
  <ul><li>模型：llama 3.1 模型系列：405B（含量化版）、70B、8B， 128k的上下文</li><li>工具：开源配套的Agent系统</li><li>网站：<a href="https://llama.meta.com/" rel="nofollow">https://llama.meta.com/</a></li><li>日期: July 23,2024</li></ul> </li><li> <p>Llama3的卓越表现源于三大核心要素：</p> 
  <ul><li>高质量数据：15T tokens的高质量多语言数据。</li><li>规模性：8B、70B、405B的模型矩阵，通过大模型提升小模型的质量，实现同类最佳效果。</li><li>简洁性：选择Transformer架构而非MoE架构，采用相对简单的后训练程序，如SFT、RS和DPO，而非复杂的强化学习算法。<br> 报告还分享了Llama3在多模态集成方面的初步实验，展现了其在图像、视频和语音处理方面的潜力。</li></ul> </li><li> <p>Llama3的开发历程：预训练与后训练</p> 
  <ul><li>预训练：在15.6万亿token上预训练了4050亿参数的模型，上下文窗口为8K token。随后进行继续预训练，将上下文窗口扩展至128K token。</li><li>后训练：通过多轮人类反馈与模型对齐，每轮包括监督式微调（SFT）和直接偏好优化（DPO）。后训练阶段还整合了工具使用等新能力，并在编码和推理等领域取得显著进展。</li></ul> </li><li> <p>Llama3的多模态能力：图像、视频和语音的融合<br> 为了赋予Llama3多模态能力，Meta采用了组合方法，引入了图像、视频和语音编码器。具体过程包括：</p> 
  <ul><li>多模态编码器预训练：分别对图像和语音编码器进行训练，学习视觉和语音信号的表示。</li><li>视觉适配器训练：将图像编码器融入预训练的语言模型，实现图像表示与语言表示的对齐。在此基础上，训练视频适配器，实现跨帧信息聚合。</li><li>语音适配器训练：将语音编码器整合到模型中，实现高质量的语音理解。</li></ul> </li><li> <p>Llama3 技术报告目录</p> 
  <ul><li>引言：Llama3成功的三大要素、开发历程、多模态能力概述</li><li>预训练<br> 预训练数据：数据来源、清洗、去重、过滤等<br> 模型架构：Transformer架构选择、参数设置等<br> 规模定律实验：模型规模对性能的影响<br> 基础设施、扩展和效率：训练硬件、并行策略、优化技巧等<br> 训练方法：初始预训练、长上下文预训练、退火等</li><li>后期训练<br> 建模：SFT、RM、DPO等技术<br> 后期训练数据：清洗、修剪等<br> Chat能力：代码、多语言、数学和推理、长文本、工具调用能力，以及如何减少幻觉等</li><li>效果评估<br> Base模型：benchmark指标、鲁棒性、对抗性和污染分析<br> Chat模型：通用知识和指令遵循benchmark指标、人类考试GRE/LSAT/SAT/AP/GMAT等、单项技能测试<br> 人类评估：在几乎所有能力上，Llama 3 405B和GPT-4的胜利率在误差范围内<br> 安全性评估：安全评估基准、预训练和微调效果等</li><li>推理<br> 流水线并行：推理加速技术<br> FP8量化：模型量化技术</li><li>视觉实验<br> 数据：图像和视频数据处理<br> 模型架构：图像编码器、图像适配器、视频适配器</li><li>语音实验<br> 数据：语音数据处理<br> 模型架构：语音编码器、语音适配器</li><li>相关工作</li><li>结论</li><li>贡献者和致谢</li></ul> </li></ul> 
<br> 
<h3><a id="1__72"></a>1. 引言</h3> 
<p>基础模型是语言、视觉、语音或其他模式的通用模型，旨在支持各种人工智能任务。它们构成了许多现代人工智能系统的基础。</p> 
<p>现代基础模型的开发包括两个主要阶段：</p> 
<ol><li>训练前阶段，在这一阶段中，利用下一个单词预测或字幕等简单任务对模型进行大规模训练；</li><li>训练后阶段，在这一阶段中，对模型进行调整，使其遵循指令、符合人类偏好并提高特定能力（例如编码和推理）。</li></ol> 
<p>在本文中，我们提出了一套新的语言基础模型，称为 “Llama 3”。Llama 3 模型群原生支持多语言性、编码、推理和工具使用。我们最大的模型是拥有 405B 个参数的密集变换器（Transformer），可处理多达 128K 标记的上下文窗口中的信息。表 1 列出了语群的每个成员。本文中介绍的所有结果都是针对 Llama 3.1模型的，为简洁起见，我们在全文中将其称为 Llama 3。</p> 
<p>我们认为，在开发高质量基础模型的过程中有三个关键杠杆：数据、规模和复杂性管理。我们力求在开发过程中优化这三个杠杆：</p> 
<ol><li>数据：与之前版本的 Llama（Touvron 等人，2023a,b）相比，我们改进了用于前训练和后训练的数据的数量和质量。这些改进包括为预训练数据开发了更细致的预处理和整理管道，为后训练数据开发了更严格的质量保证和过滤方法。我们在一个包含约 15T 多语言词库的语料库上对 Llama 3 进行了预训练，而 Llama 2 只包含 1.8T 词库。</li><li>规模：我们训练模型的规模远大于之前的 Llama 模型：我们的旗舰语言模型在预训练时使用了 3.8 × 1025 FLOPs，几乎是最大版本 Llama 2 的 50 倍。具体来说，我们在 15.6T 文本标记上预训练了一个拥有 405B 可训练参数的旗舰模型。正如基础模型的缩放规律所预期的那样，我们的旗舰模型优于使用相同程序训练的较小模型。虽然我们的缩放定律表明，对于我们的训练预算来说，旗舰模型的大小近似于最佳计算规模，但我们对较小模型的训练时间也比最佳计算时间要长得多。在推理预算相同的情况下，最终模型的性能比计算最优模型更好。在后期训练中，我们会使用旗舰模型来进一步提高这些较小模型的质量。</li><li>管理复杂性：我们所做的设计选择旨在最大限度地提高模型开发过程的扩展能力。例如，我们选择了标准的密集变形模型架构（Vaswani 等人，2017 年）并稍作调整，而不是专家混合模型（Shazeer 等人，2017 年），以最大限度地提高训练的稳定性。同样，我们采用了基于监督微调（SFT）、拒绝采样（RS）和直接偏好优化（DPO；Rafailov 等人，2023 年）的相对简单的后训练程序，而不是更复杂的强化学习算法（欧阳等人，2022 年；Schulman 等人，2017 年），后者往往稳定性较差且难以扩展。<br> 我们的工作成果是 Llama 3：由三个多语言模型组成，参数分别为 8B、70B 和 405B。</li></ol> 
<p>我们在大量基准数据集上评估了 Llama 3 的性能，这些数据集涵盖了广泛的语言理解任务。此外，我们还进行了广泛的人工评估，将 Llama 3 与竞争对手的模型进行了比较。表 2 列出了旗舰模型 Llama 3 在主要基准上的性能概览。我们的实验评估表明，我们的旗舰模型在各种任务中的表现与 GPT-4 （OpenAI,2023a）等领先语言模型相当，并接近最先进水平。我们的小型模型在同类产品中表现最佳，优于参数数量相似的其他模型（Bai 等人，2023；Jiang 等人，2023）。Llama 3 在有用性和无害性之间的平衡也比其前身好得多（Touvron 等人，2023b）。我们将在第 5.4 节详细分析 Llama 3 的安全性。</p> 
<p>我们将根据更新版的 Llama 3 社区许可证公开发布所有三个 Llama 3 模型；见﻿https://llama.meta.com﻿。这包括我们的 405B 参数语言模型的预训练和后训练版本，以及用于输入和输出安全的新版 LlamaGuard 模型（Inan等，2023年）。我们希望旗舰模型的公开发布能推动研究界的创新浪潮，并加速人工通用智能（AGI）的发展。</p> 
<p>作为 Llama 3 开发过程的一部分，我们还对模型进行了多模态扩展，实现了图像识别、视频识别和语音理解功能。这些模型仍在积极开发中，尚未准备好发布。除了语言建模结果，本文还介绍了我们对这些多模态模型的初步实验结果。</p> 
<h3><a id="2__94"></a>2. 概述</h3> 
<p>Llama 3 的模型架构如图 1 所示。</p> 
<p><img src="https://images2.imgbox.com/9a/5f/V5pKjgS8_o.png" alt="在这里插入图片描述"><br> 图 1 Llama 3 的整体架构和训练示意图</p> 
<p>Llama 3 语言模型的开发主要分为两个阶段：</p> 
<ul><li>语言模型预训练。我们首先将一个大型多语言文本语料库转换为离散的标记，然后在由此产生的数据上预训练一个大型语言模型(LLM)，以执行下一个标记的预测。在语言模型预训练阶段，模型会学习语言结构，并从“阅读”的文本中获取大量有关世界的知识。为了有效地做到这一点，我们进行了大规模的预训练：我们使用8K 标记的上下文窗口，在15.6T 标记上预训练了一个拥有405B 参数的模型。在这一标准预训练阶段之后，我们将继续进行预训练，将支持的上下文窗口增加到128Kkkens。详见第3 节。</li><li>语言模型后训练。预训练后的语言模型对语言有丰富的理解，但还不能按照我们期望的助手方式来执行指令或行为。我们将分几轮根据人类反馈调整模型，每一轮都包括在指令调整数据基础上进行监督微调（SFT）。(SFT）和直接偏好优化（DPO；Rafailov 等人，2024 年）。在训练后阶段，我们还整合了工具使用等新功能，并观察到在编码和推理等其他方面的显著改进。详见第 4 节。最后，在训练后阶段还将安全缓解措施纳入模型中，具体细节将在第 5.4 节中介绍。<br> 由此产生的模型具有丰富的功能。它们至少能用八种语言回答问题、编写高质量的代码、解决复杂的推理问题，并能以开箱即用或 “零 ”使用的方式使用工具。</li></ul> 
<p>我们还进行了实验，采用组合方法为 Llama 3 添加图像、视频和语音功能。我们研究的方法包括图 28 所示的三个附加阶段：</p> 
<ul><li> <p>多模态编码器预训练。我们为图像和语音分别训练编码器。我们在大量图像-文本对上训练图像编码器。这可以让模型了解视觉内容与自然语言描述之间的关系。我们的语音编码器采用自监督方法进行训练，这种方法会屏蔽掉语音输入的部分内容，并尝试通过离散标记表示法重建屏蔽掉的部分内容。因此，该模型可以学习语音信号的结构。有关图像编码器的详细信息，请参见第 7 节；有关语音编码器的详细信息，请参见第 8 节。</p> </li><li> <p>视觉适配器训练。我们会训练一个适配器，将预先训练好的图像编码器集成到预先训练好的语言模型中。适配器由一系列交叉注意层组成，可将图像编码器表征输入语言模型。适配器根据文本-图像对进行训练。这就使图像表征与语言表征保持一致。在适配器训练过程中，我们也会更新图像编码器的参数，但有意不更新语言模型参数。在图像适配器的基础上，我们还在成对的视频-文本数据上训练视频适配器。这使模型能够汇总各帧的信息。详见第 7 节。</p> </li><li> <p>语音适配器训练。最后，我们通过一个适配器将语音编码器集成到模型中，该适配器可将语音编码转换为标记表示，然后直接输入经过微调的语言模型。适配器和编码器的参数在有监督的微调阶段共同更新，以实现高质量的语音理解。在语音适配器训练过程中，我们不会改变语言模型。我们还集成了文本到语音系统。详见第 8 节。</p> </li></ul> 
<p>通过多模态实验，我们建立了能够识别图像和视频内容并支持通过语音界面进行交互的模型。这些模型仍在开发中，尚未准备好发布。</p> 
<br> 
<h3><a id="3__119"></a>3. 预训练</h3> 
<p>语言模型的预训练包括：<br> (1)大规模训练语料的整理和筛选，<br> (2)模型结构的开发和确定模型大小的相应比例法则，<br> (3)大规模高效预训练技术的开发，<br> (4)预训练配方的开发。</p> 
<br> 
<h4><a id="31__128"></a>3.1 预训练数据</h4> 
<p>我们从包含 2023 年底之前知识的各种数据源中创建了用于语言模型预训练的数据集。我们对每个数据源采用了多种去重方法和数据清理机制，以获得高质量的标记。我们删除了包含大量个人身份信息（PII）的域和已知有成人内容的域。</p> 
<h5><a id="311__131"></a>3.1.1 网络数据整理</h5> 
<p>我们使用的大部分数据都来自网络，下文将介绍我们的清理过程。</p> 
<p><strong>PII 和安全过滤。</strong><br> 除其他缓解措施外，我们还实施了过滤器，旨在从可能包含不安全内容或大量 PII 的网站、根据各种 Meta 安全标准被列为有害的域以及已知包含成人内容的域中删除数据。<br> 文本提取和清理。我们对非截断网页文档的原始HTML 内容进行处理，以提取高质量的多样化文本。为此，我们构建了一个自定义解析器，用于提取HTML 内容，并优化模板去除和内容召回的精度。我们在人工评估中评估了我们的解析器的质量，并将其与针对文章类内容进行优化的流行第三方HTML 解析器进行了比较，结果发现我们的解析器表现良好。我们对包含数学和代码内容的HTML 页面进行了仔细处理，以保留这些内容的结构。我们保留了图片的alt 属性文本，因为数学内容通常以预渲染图片的形式呈现，而数学内容也在alt 属性中提供。我们对不同的清理配置进行了实验性评估。与纯文本相比，我们发现标记符对主要在网络数据上训练的模型的性能有害，因此我们删除了所有标记符。去重。我们在 URL、文档和行级应用了多轮重复数据删除：<br> URL级重复数据删除。我们对整个数据集进行URL 级重复数据删除。我们保留每个URL 对应页面的最新版本。<br> 文档级重复数据删除。我们对整个数据集进行全局 MinHash（Broder，1997 年）重复数据删除，以删除近乎重复的文档。<br> 行级重复数据删除。我们执行与ccNet（Wenzeket al.）我们删除了在每个 3000 万文档桶中出现 6 次以上的行。虽然我们的人工定性分析显示，行级重复数据删除不仅会删除各种网站上的残留模板（如导航菜单、cookie警告），还会删除频繁出现的高质量文本，但我们的实证评估结果表明，行级重复数据删除有很大的改进。</p> 
<p><strong>启发式过滤：</strong><br> 我们开发了启发式方法来去除额外的低质量文档、异常值和重复过多的文档。启发式过滤的一些例子包括：<br> 我们使用重复 n-gram 覆盖率（Rae 等人，2021 年）来删除由重复内容（如日志或错误信息）组成的行。这些行可能很长，而且是独一无二的，因此无法用行内删除法进行过滤。<br> 我们使用 “脏字 ”计数（Raffel 等人，2020 年）来过滤域名封锁列表未覆盖的成人网站。<br> 我们使用标记分布 Kullback-Leibler 发散来过滤掉与训练语料库分布相比含有过多离群标记的文档。</p> 
<p><strong>基于模型的质量筛选。</strong><br> 此外，我们还尝试应用各种基于模型的质量分类器来分选高质量的标记。其中包括使用快速分类器，如 fasttext（Joulin 等人，2017 年），训练其识别给定文本是否会被维基百科引用（Touvron 等人，2023a），以及基于 Llama 2 预测训练的计算密集型 Roberta 分类器（Liu 等人，2019a）。为了训练基于 Llama 2 的质量分类器，我们创建了一个经过清理的网络文档训练集，描述了质量要求，并指示 Llama 2 的聊天模型确定文档是否符合这些要求。出于效率考虑，我们使用 DistilRoberta（Sanh 等人，2019 年）为每份文档生成质量分数。我们通过实验评估了各种质量过滤配置的功效。</p> 
<p><strong>代码和推理数据。</strong><br> 与 DeepSeek-AI 等人（2024 年）类似，我们建立了特定领域的管道来提取代码和数学相关网页。具体来说，代码和推理分类器都是在由 Llama 2 标注的网页数据上训练出来的 DistilledRoberta 模型。与上述一般质量分类器不同的是，我们针对包含数学推导、STEM 领域推理以及代码与自然语言交错的网页进行了及时调整。由于代码和数学的标记分布与自然语言的标记分布有很大不同，这些管道实施了特定领域的 HTML 提取、定制文本特征和启发式过滤。</p> 
<p><strong>多语言数据。</strong><br> 与上文所述的英语处理管道类似，我们实施了过滤器，以删除可能包含 PII 或不安全内容的网站数据。我们的多语言文本处理管道有几个独特的功能：<br> 我们使用基于快速文本的语言识别模型将文档归类为 176 种语言。<br> 我们在每种语言的数据中执行文档级和行级重复删除。<br> 我们应用特定语言的启发式方法和基于模型的过滤器来删除低质量文档。<br> 此外，我们还使用基于Llama 2 的多语言分类器对多语言文档进行质量排序，以确保高质量内容得到优先处理。我们通过实验确定预训练中使用的多语言标记数量，平衡模型在英语和多语言基准上的性能。</p> 
<br> #### 3.1.2 确定数据混合 
<p>要获得高质量的语言模型，仔细确定不同数据源在预训练数据混合中的比例至关重要。我们确定此数据混合的主要工具是知识分类和规模定律实验。</p> 
<p>知识分类。我们开发了一个分类器，对我们的网络数据中包含的信息类型进行分类，以更有效地确定数据混合。我们使用这个分类器来降低在网络上过度表示的数据类别，例如艺术和娱乐。</p> 
<p>规模定律的数据混合。为了确定最佳数据混合，我们进行规模定律实验，我们在数据混合上训练几个小型模型，并用它来预测大型模型在该混合上的性能（见第3.2.1节）。我们多次重复这个过程以选择新的数据混合候选。随后，我们在候选数据混合上训练一个更大的模型，并评估该模型在几个关键基准上的性能。</p> 
<p>数据混合摘要。我们最终的数据混合大致包含50%的对应于一般知识标记，25%的数学和推理标记，17%的代码标记，以及8%的多语言标记。</p> 
<br> #### 3.1.3 退火数据 
<p>通过实证，我们发现在小量的高质量代码和数学数据上进行退火（见第3.4.3节）可以提高预训练模型在关键基准上的性能。与Li等人（2024b）类似，我们使用在选定领域上采样高质量数据的数据混合进行退火。我们不在退火数据中包含常用基准的任何训练集。这使我们能够评估Llama 3的真实少次学习能力和领域外泛化能力。</p> 
<p>按照OpenAI（2023a）的做法，我们在GSM8k（Cobbe等人，2021年）和MATH（Hendrycks等人，2021b）训练集上评估了退火的有效性。我们发现，退火将预训练的Llama 3 8B模型在GSM8k和MATH验证集上的性能分别提高了24.0%和6.4%。</p> 
<p>然而，对于405B模型的改进是微不足道的，这表明我们的旗舰模型具有强大的上下文学习和推理能力，不需要特定的领域内训练样本就能获得强大的性能。</p> 
<p>使用退火评估数据质量。与Blakeney等人（2024年）类似，我们发现退火使我们能够判断小的特定领域数据集的价值。我们通过将一个50%训练的Llama 38B模型的学习率在线性地退火到40B标记上的0来衡量这些数据集的价值。在这些实验中，我们将新数据集的权重分配为30%，其余70%的权重分配给默认数据混合。使用退火来评估新数据源比为每个小数据集执行规模定律实验更有效。</p> 
<br> 
<h4><a id="32__184"></a>3.2 模型架构</h4> 
<p>Llama 3使用标准的密集Transformer架构（Vaswani等人，2017年）。与Llama和Llama 2（Touvron等人，2023a，b）在模型架构方面没有显著差异；我们的性能提升主要是由于数据质量和多样性的提高以及训练规模的增加。</p> 
<p>与Llama 3相比，我们做了一些小的修改：</p> 
<p>我们使用分组查询注意力（GQA；Ainslie等人，2023年）和8个键值头来提高推理速度，并在解码过程中减少键值缓存的大小。<br> 我们使用注意力掩码来防止同一序列中的不同文档之间的自注意力。我们发现这种改变在标准预训练期间的影响有限，但在继续对非常长的序列进行预训练时发现它很重要。<br> 我们使用一个包含128K个标记的词汇表。我们的标记词汇表结合了来自tiktoken3分词器的100K个标记和额外增加的28K个标记，以更好地支持非英语语言。与Llama 2分词器相比，我们的新分词器将样本英语数据的压缩率从3.17提高到3.94个字符每个标记。这使得模型在相同的训练计算量下能够“阅读”更多的文本。我们还发现，增加来自选定非英语语言的28K个标记在不影响英语分词的情况下，提高了压缩比和下游性能。<br> 我们增加了RoPE基础频率超参数到500,000。这使我们能够更好地支持更长的上下文；Xiong等人(2023年)表明这个值对于长达32,768的上下文长度是有效的。<br> Llama 3 405B使用了一个具有126层、16384个标记表示维度和128个注意力头的架构；详情见表3。这导致模型大小根据我们数据上的规模定律，对于我们的3.8 × 10^25 FLOPs训练预算来说，大约是计算最优的。</p> 
<br> 
<h5><a id="321__197"></a>3.2.1 规模定律</h5> 
<p>我们制定了规模定律(Hoffmann等人，2022年；Kaplan等人，2020年)来确定我们的旗舰模型的最佳大小，考虑到我们的预训练计算预算。除了确定最佳模型大小之外，另一个主要挑战是预测旗舰模型在下游基准任务上的性能，由于几个问题：(1)现有的规模定律通常只预测下一个标记预测损失，而不是特定的基准性能。(2)规模定律可能会有噪声并且不可靠，因为它们是基于小计算预算进行的预训练运行开发的(Wei等人，2022b)。</p> 
<p>为了应对这些挑战，我们实施了两阶段的方法来制定能够准确预测下游基准性能的规模定律：</p> 
<ol><li>我们首先建立计算最优模型在下游任务上的负对数似然与训练FLOPs之间的相关性。</li><li>接下来，我们将下游任务上的负对数似然与任务准确性相关联，利用规模定律模型和用更高计算FLOPs训练的旧模型。在这一步中，我们特别利用了Llama 2系列模型。<br> 这种方法使我们能够在给定特定数量的训练FLOPs的情况下，预测计算最优模型的下游任务性能。我们使用类似的方法选择我们的预训练数据混合（见第3.4节）。</li></ol> 
<p>规模定律实验。具体来说，我们通过使用6 × 10^18 FLOPs到10^22 FLOPs之间的计算预算来构建我们的规模定律。在每个计算预算下，我们在40M到16B参数的模型范围内进行预训练，每个计算预算使用一组模型大小。在这些训练运行中，我们使用余弦学习率计划，并为2,000个训练步骤进行线性预热。峰值学习率根据模型大小设置在2 × 10^-4到4 × 10^-4之间。我们将余弦衰减设置为峰值的0.1。每一步的权重衰减设置为该步骤学习率的0.1倍。我们为每个计算规模使用固定的批量大小，范围在250K到4M之间。</p> 
<p>我们使用0.95和0.537，A=0.299这样的指标来衡量计算效率。在6 × 10<sup>18到10</sup>22 FLOPs的范围内，我们绘制了IsoFLOPs曲线。这些曲线上的损失是通过在一个独立的验证集上计算负对数似然来衡量的。我们使用二次方程来拟合每个计算规模的测量损失值，并确定每个抛物线的最小值。我们把一个抛物线的最小值称为在相应的预训练计算预算下的计算最优模型。</p> 
<p>这些实验产生了图2中的IsoFLOPs曲线。这些曲线上的损失是在一个单独的验证集上测量的。我们使用二次方程拟合测量到的损失值，并识别每个抛物线的最小值。我们把一个抛物线的最小值称为在相应的预训练计算预算下的计算最优模型。</p> 
<p>我们利用这种方式识别出的计算最优模型来预测特定计算预算下的最佳训练标记数量。为此，我们假设计算预算C和最优训练标记数量N*©之间存在幂律关系：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           N 
          
         
           ∗ 
          
         
        
          ( 
         
        
          C 
         
        
          ) 
         
        
          = 
         
        
          A 
         
         
         
           C 
          
         
           α 
          
         
        
       
         N^*(C)=AC^{\alpha} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7387em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7144em;"></span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7144em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0037em;">α</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>我们使用图2中的数据拟合A和α，发现(α, A) = (0.53, 0.29)；相应的拟合曲线如图3所示。将这个结果的规模定律外推到3.8 × 10^25 FLOPs，建议训练一个有402B参数的模型在16.55T标记上。<br> 一个重要的观察是，随着计算预算的增加，IsoFLOPs曲线在最小值周围的曲率变平。这意味着旗舰模型的性能对于模型大小和训练标记之间权衡的微小变化相对鲁棒。基于这一观察，我们最终决定训练一个有405B参数的旗舰模型。<br> 预测在下游任务上的性能。我们使用生成的计算最优模型来预测旗舰Llama 3模型在基准数据集上的性能。首先，我们线性相关基准测试中正确答案的(标准化)负对数似然和训练FLOPs。在这项分析中，我们只使用在上述数据混合上训练到10^22 FLOPs的规模定律模型。接下来，我们使用规模定律模型和Llama 2模型建立对数似然和准确性之间的S形关系，这些模型是使用Llama 2数据混合和分词器训练的。我们在图4中展示了这项实验的结果。我们发现这种两步规模定律预测非常准确，它只略微低估了旗舰Llama 3模型的最终性能。</p> 
<br> 
<h4><a id="33__221"></a>3.3 基础设施、扩展性和效率</h4> 
<p>我们描述了支持Llama 3 405B大规模预训练的硬件和基础设施，并讨论了几项优化措施，这些措施提高了训练效率。</p> 
<br> 
<h5><a id="331__227"></a>3.3.1 训练基础设施</h5> 
<p>Llama 1和2模型在Meta的AI研究超级集群（Lee和Sengupta，2022）上进行了训练。随着我们进一步扩展，Llama 3的训练迁移到了Meta的生产集群（Lee等人，2024）。此设置优化了生产级别的可靠性，这对于我们扩大训练至关重要。</p> 
<ul><li> <p>计算。<br> Llama 3 405B在高达16K的H100 GPU上进行训练，每个GPU运行在700W TDP下，配备80GB HBM3，使用Meta的Grand Teton AI服务器平台（Matt Bowman，2022）。每个服务器配备有八个GPU和两个CPU。在服务器内部，这八个GPU通过NVLink连接。使用MAST（Choudhury等人，2024），Meta的全球规模训练调度器，来安排训练作业。</p> </li><li> <p>存储。<br> Tectonic（Pan等人，2021），Meta的通用分布式文件系统，用于为Llama 3预训练构建存储网络（Battey和Gupta，2024）。它提供了7,500个配备SSD的服务器上的240PB存储空间，并支持2TB/s的可持续吞吐量和7TB/s的峰值吞吐量。一个主要挑战是支持在短时期间饱和存储网络的高突发性检查点写操作。检查点保存每个GPU的模型状态，每个GPU的范围从1MB到4GB，用于恢复和调试。我们的目标是最小化检查点期间GPU的暂停时间，并增加检查点频率，以减少恢复后丢失的工作量。</p> </li><li> <p>网络。<br> Llama 3 405B使用了基于Arista 7800和Minipack2开放计算项目OCP机架交换机的RDMA over Converged Ethernet (RoCE)网络。Llama 3系列中较小的模型使用Nvidia Quantum2 Infiniband网络进行训练。RoCE和Infiniband集群都在GPU之间利用400Gbps的互连。尽管这些集群的底层网络技术存在差异，但我们调整了它们，以便为这些大型训练工作负载提供等效的性能。由于我们完全拥有RoCE网络的设计，我们将更详细地阐述我们的RoCE网络。</p> 
  <ul><li> <p>网络拓扑。<br> 我们的基于RoCE的AI集群由24K GPU组成，通过三层Clos网络连接（Lee等人，2024）。在底层，每个机架托管16个GPU，分成两台服务器，并通过单个Minipack2机架顶部(ToR)交换机连接。在中层，192个这样的机架通过集群交换机连接，形成一个拥有3,072个GPU的pod，具有完整的双工带宽，确保没有过订。在顶层，同一数据中心大楼内的八个这样的pod通过聚合交换机连接，形成一个24K GPU的集群。然而，在聚合层的网络连接没有保持完整的双工带宽，而是有一个1:7的过订比率。我们的模型并行方法（见第3.3.2节）和训练作业调度器（Choudhury等人，2024）都针对网络拓扑进行了优化，旨在最小化跨pod的网络通信。</p> </li><li> <p>负载均衡。<br> 大型语言模型（LLM）训练产生的网络流量很大，这使得使用传统的如等价成本多路径（ECMP）路由方法在所有可用网络路径上进行负载均衡变得困难。为了应对这一挑战，我们采用了两种技术。首先，我们的集合库创建了16个网络流进行负载均衡。其次，我们增强的ECMP（E-ECMP）协议通过在RoCE数据包头部的额外字段上进行哈希处理，有效地在不同网络路径上平衡了这16个流。</p> </li><li> <p>拥塞控制。我们在主干网上使用了深度缓冲交换机（Gangidi等人，2024年），以适应由集合通信模式引起的瞬态拥塞和缓冲。这种设置有助于限制由慢服务器引起的持续拥塞和网络反压的影响，这在训练中很常见。最后，通过E-ECMP实现的更好的负载均衡显著降低了拥塞的可能性。有了这些优化，我们成功地运行了一个24K GPU集群，而无需使用传统的拥塞控制方法，如数据中心量化拥塞通知（DCQCN）。</p> </li></ul> </li></ul> 
<br> 
<h5><a id="332__248"></a>3.3.2 模型扩展的并行性</h5> 
<p>为了扩展我们最大模型的训练，我们采用了4D并行性——结合四种不同类型的并行方法来切分模型。这种方法有效地在多个GPU之间分配计算，并确保每个GPU的模型参数、优化器状态、梯度和激活能够适应其HBM。我们在图5中展示了4D并行性的实现。它结合了张量并行性（TP；Krizhevsky等人（2012年）；Shoeybi等人（2019年）；Korthikanti等人（2023年））、流水线并行性（PP；Huang等人（2019年）；Narayanan等人（2021年）；Lamy-Poirier（2023年））、上下文并行性（CP；Liu等人（2023年））和数据并行性（DP；Rajbhandari等人（2020年）；Ren等人（2021年）；Zhao等人（2023年））。</p> 
<p>张量并行性将个别权重张量分割成不同设备上的多个块。流水线并行性通过层将模型垂直划分为不同的阶段，以便不同的设备可以并行处理完整模型流水线的不同阶段。上下文并行性将输入上下文分割成段，减少了非常长的序列长度输入的内存瓶颈。我们使用的是完全分片的数据并行性（FSDP；Rajbhandari等人，2020年；Ren等人，2021年；Zhao等人，2023年），它在实现数据并行性的同时，对模型、优化器和梯度进行分片，该数据并行性在多个GPU上并行处理数据，并在每个训练步骤后同步。我们在Llama 3中使用FSDP对优化器状态和梯度进行分片，但对于模型分片，在前向计算后我们不重新分片，以避免在反向传递期间产生额外的全收集通信。</p> 
<p>GPU利用率。通过对并行配置、硬件和软件的精心调整，我们实现了表4所示配置的BF16模型FLOPs利用率（MFU；Chowdhery等人（2023年））为38-43%。在16K GPU上，当DP=128时MFU略有下降至41%，而8K GPU上DP=64时为43%，这是由于在训练期间需要保持每个批次的全局标记数恒定，因此每个DP组的批量大小需要降低。</p> 
<p>流水线并行性改进。我们在使用现有实现时遇到了几个挑战：<br> 批量大小限制。当前实现对每个GPU支持的批量大小有限制，要求它可以被流水线阶段的数量整除。例如，在图6中的流水线并行性的深度优先调度（DFS）中（Narayanan等人，2021年），需要N = PP = 4，而广度优先调度（BFS；Lamy-Poirier（2023年））需要N = M，其中M是微批次的总数，N是同一阶段的前向或后向的连续微批次的数量。然而，预训练通常需要调整批量大小的灵活性。<br> 内存不平衡。现有的流水线并行性实现导致资源消耗不平衡。第一阶段由于嵌入和热身微批次而消耗更多的内存。<br> 计算不平衡。在模型的最后一层之后，我们需要计算输出和损失，使这个阶段成为执行延迟的瓶颈。<br> 图片</p> 
<p>为解决这些问题，我们修改了流水线调度计划，如图6所示，该计划允许灵活设置N——在本例中N=5，可以在每个批次中运行任意数量的微批次。这允许我们执行：(1) 当我们在大规模时有批量大小限制时，运行的微批次少于阶段数；或者(2) 运行更多的微批次以隐藏点对点通信，寻找DFS（深度优先调度）和BFS（广度优先调度）之间的最佳通信和内存效率的平衡点。为了平衡流水线，我们分别从第一和最后阶段各减少一个Transformer层。这意味着第一阶段的第一个模型块仅有嵌入层，而最后阶段的最后一个模型块仅有输出投影和损失计算。为了减少流水线泡沫，我们采用了交错调度（Narayanan等人，2021年），在一个流水线等级上使用V个流水线阶段。整体流水线泡沫比率是（PP−1）/V*M。此外，我们在PP中采用异步点对点通信，这在文档掩码引入额外计算不平衡的情况下显著加快了训练速度。我们启用了TORCH_NCCL_AVOID_RECORD_STREAMS，以减少异步点对点通信的内存使用。最后，为了减少内存成本，基于详细的内存分配分析，我们主动释放了未来计算中不会使用的张量，包括每个流水线阶段的输入和输出张量。通过这些优化，我们得以在不使用激活检查点的情况下对8K标记的Llama 3进行预训练。</p> 
<p>长序列的上下文并行性。我们利用上下文并行性（CP）在扩展Llama 3的上下文长度时提高内存效率，并能够训练长达128K的极长序列。在CP中，我们跨序列维度进行分区，特别是我们将输入序列划分为2 × CP块，以便每个CP等级接收两个块以实现更好的负载平衡。第i个CP等级接收了第i个和第(2 × CP − 1 − i)个块。</p> 
<p>与现有的在环状结构中重叠通信和计算的CP实现不同（Liu等人，2023年），我们的CP实现采用了基于all-gather的方法，我们首先all-gather关键（K）和值（V）张量，然后计算局部查询（Q）张量块的注意力输出。尽管all-gather通信延迟在关键路径上暴露出来，但我们仍然采用这种方法，主要有两个原因：(1) 在基于all-gather的CP注意力中，支持不同类型的注意力掩码（如文档掩码）更容易、更灵活；(2) 由于使用了GQA（Ainslie等人，2023年），通信的K和V张量比Q张量小得多，因此暴露的all-gather延迟很小。因此，注意力计算的时间复杂度比all-gather大一个数量级（O(S^2)与O(S)，其中S表示全因果掩码中的序列长度），使all-gather的开销可以忽略不计。</p> 
<p>网络感知的并行配置。并行维度的顺序[TP, CP, PP, DP]针对网络通信进行了优化。最内层的并行需要最高的网络带宽和最低的延迟，因此通常限制在同一个服务器内。最外层的并行可以跨越多跳网络，并应能容忍更高的网络延迟。因此，基于对网络带宽和延迟的要求，我们按照[TP, CP, PP, DP]的顺序放置并行维度。DP（即FSDP）是最外层的并行，因为它可以通过异步预取分片模型权重和减少梯度来容忍更长的网络延迟。在避免GPU内存溢出的同时，找到最小化通信开销的最佳并行配置是具有挑战性的。我们开发了一个内存消耗估计器和性能预测工具，帮助我们探索各种并行配置，并有效预测整体训练性能和识别内存缺口。</p> 
<p>数值稳定性。通过比较不同并行设置之间的训练损失，我们解决了几个影响训练稳定性的数值问题。为确保训练收敛性，我们在多个微批次的反向计算中使用FP32梯度累积，并在FSDP中跨数据并行工作器使用FP32进行reduce-scatter梯度。对于在前向计算中多次使用的中间张量，例如视觉编码器的输出，反向梯度也以FP32累积。</p> 
<br> 
<h5><a id="333__274"></a>3.3.3 集体通信</h5> 
<p>我们的Llama 3集体通信库是基于Nvidia的NCCL库的一个分支，称为NCCLX。NCCLX显著提高了NCCL的性能，特别是对于高延迟网络。回想一下，平行维度的顺序是[TP, CP, PP, DP]，其中DP对应于FSDP。最外层的平行维度，PP和DP，可能通过多跳网络进行通信，延迟高达数十微秒。原始的NCCL集合体——FSDP中的all-gather和reduce-scatter，以及PP中的点对点——需要数据分块和分阶段数据复制。这种方法存在几个效率问题，包括(1)需要在网络上交换大量的小控制消息以促进数据传输，(2)额外的内存复制操作，以及(3)使用额外的GPU周期进行通信。对于Llama 3训练，我们通过调整分块和数据传输以适应我们的网络延迟来解决这些效率问题的一个子集，这些延迟在大型集群中可能高达数十微秒。我们还允许小控制消息以更高的优先级穿越我们的网络，特别是避免在深缓冲核心交换机中被阻塞。我们为未来Llama版本进行的持续工作涉及在NCCLX中进行更深入的更改，以全面解决上述所有问题。</p> 
<br> 
<h5><a id="334__280"></a>3.3.4 可靠性和运营挑战</h5> 
<p>16K GPU训练的复杂性和潜在故障场景超过了我们运营的更大的CPU集群。此外，训练的同步性质使其对故障的容忍度较低——单个GPU故障可能需要重启整个作业。尽管存在这些挑战，对于Llama 3，我们在支持自动化集群维护（如固件和Linux内核升级（Vigraham和Leonhardi，2024年））的同时，实现了超过90%的有效训练时间，这导致至少每天有一次训练中断。有效训练时间衡量的是流逝时间内用于有用训练的时间。<br> 在预训练的54天快照期间，我们经历了总共466次作业中断。其中，47次是计划内的中断，由于自动化维护操作，如固件升级或操作员启动的操作，如配置或数据集更新。其余419次是意外的中断，在表5中有分类。约78%的意外中断归因于确认的硬件问题，如GPU或主机组件故障，或疑似与硬件相关的问题，如静默数据损坏和计划外的单个主机维护事件。GPU问题是最大的类别，占所有意外问题的58.7%。尽管失败数量众多，但在这段时间内，仅三次需要重大手动干预，其余问题由自动化处理。<br> 为了增加有效训练时间，我们减少了作业启动和检查点时间，并开发了快速诊断和问题解决工具。我们广泛使用PyTorch内置的NCCL飞行记录器（Ansel等人，2024年），这是一个捕捉集体元数据和堆栈跟踪到环形缓冲区的功能，因此允许我们在大规模上快速诊断挂起和性能问题，特别是与NCCLX相关的。利用这个，我们有效地记录了每个通信事件和每次集体操作的持续时间，并且在NCCLX看门狗或心跳超时时自动转储跟踪数据。我们通过在线配置更改（Tang等人，2015年）根据需要在生产中选择性地启用更多计算密集型的跟踪操作和元数据收集，无需代码发布或作业重启。<br> 调试大规模训练中的问题由于我们网络中混合使用NVLink和RoCE而变得复杂。NVLink上的数据传输通常通过由CUDA内核发出的加载/存储操作进行，远程GPU或NVLink连接的故障通常表现为CUDA内核内的加载/存储操作停滞，而没有返回清晰的错误代码。NCCLX通过与PyTorch的紧密共同设计，提高了故障检测和定位的速度和准确性，允许PyTorch访问NCCLX的内部状态并跟踪相关信息。虽然由于NVLink故障引起的停滞无法完全防止，但我们的系统监控通信库的状态，并在检测到此类停滞时自动超时。此外，NCCLX跟踪每个NCCLX通信的内核和网络活动，并提供失败的NCCLX集体的内部状态的快照，包括所有等级之间已完成和待定的数据传输。我们分析这些数据以调试NCCLX扩展问题。<br> 有时，硬件问题可能导致仍在运行但缓慢的落后者，这很难检测。即使是单个落后者也可以减慢数千个其他GPU的速度，通常表现为通信功能正常但速度慢。我们开发了工具，以优先处理选定进程组中可能存在问题的通信。通过仅调查少数几个头号嫌疑对象，我们通常能够有效地识别落后者。<br> 一个有趣的观察是环境因素对大规模训练性能的影响。对于Llama 3 405B，我们注意到基于一天中的时间的日间1-2%的吞吐量变化。这种波动是由于中午更高的温度影响GPU动态电压和频率缩放所致。<br> 在训练期间，数万个GPU可能同时增加或减少功耗，例如，由于所有GPU等待检查点或集体通信完成，或整个训练作业的启动或关闭。当这种情况发生时，它可能导致数据中心的功耗瞬间波动数十兆瓦，考验电网的极限。随着我们为未来的、甚至更大的Llama模型扩展训练，这是我们面临的一个持续挑战。</p> 
<br> 
<h4><a id="34__292"></a>3.4 训练配方</h4> 
<p>用于预训练Llama 3 405B的配方包括三个主要阶段：(1)初始预训练，(2)长上下文预训练，以及(3)退火。下面分别描述这三个阶段。我们使用类似的配方来预训练8B和70B模型。</p> 
<br> 
<h5><a id="341__298"></a>3.4.1 初始预训练</h5> 
<p>我们使用余弦学习率计划对Llama 3 405B进行预训练，峰值学习率为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         8 
        
       
         × 
        
       
         1 
        
        
        
          0 
         
         
         
           − 
          
         
           5 
          
         
        
       
      
        8 × 10^{−5} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></span>，线性预热8,000步，然后在1,200,000个训练步骤中衰减到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         8 
        
       
         × 
        
       
         1 
        
        
        
          0 
         
         
         
           − 
          
         
           7 
          
         
        
       
      
        8 × 10^{−7} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></span>。我们在训练初期使用较小的批量大小以提高训练稳定性，并随后增加它以提高效率。具体来说，我们最初的批量大小为4M个标记，序列长度为4,096，然后在预训练了252M个标记后，将这些值加倍到8M个标记，序列长度为8,192。我们在预训练了2.87T个标记后再次将批量大小加倍到16M。我们发现这种训练配方非常稳定：我们观察到的损失峰值很少，并且不需要干预来纠正模型训练发散。</p> 
<p>调整数据混合。在训练期间，我们对预训练数据混合进行了几次调整，以提高模型在特定下游任务上的性能。特别是，我们在预训练期间增加了非英语数据的百分比，以提高Llama 3的多语言性能。我们还上采样数学数据以提高模型的数学推理性能，我们在预训练的后期增加了更多最新的网络数据以推进模型的知识截止日期，并且我们对后来被识别为质量较低的预训练数据子集进行了下采样。</p> 
<br> 
<h5><a id="342__306"></a>3.4.2 长上下文预训练</h5> 
<p>在预训练的最后阶段，我们对长序列进行训练，以支持高达128K个标记的上下文窗口。我们之所以没有提前对长序列进行训练，是因为自注意力层的计算在序列长度上呈二次方增长。我们逐步增加支持的上下文长度，直到模型成功适应增加的上下文长度。我们通过测量(1)模型在短上下文评估上的性能是否完全恢复，以及(2)模型是否能够完美解决长达那个长度的“针尖上的针”任务来评估成功的适应。在Llama 3 405B预训练中，我们从最初的8K上下文窗口开始，逐步增加了上下文长度，经过六个阶段，最终达到128K上下文窗口。这个阶段的长上下文预训练使用了大约800B个训练标记。<br> 图片</p> 
<br> 
<h5><a id="343__313"></a>3.4.3 退火</h5> 
<p>在最后的40M个标记的预训练中，我们将学习率线性退火至0，同时保持上下文长度为128K个标记。在这个退火阶段，我们还调整了数据混合，以增加对极高质量数据源的采样；见第3.1.3节。最后，在退火期间，我们计算模型检查点（Polyak（1991年）平均）的平均值，以产生最终的预训练模型。</p> 
<br> 
<h3><a id="4__319"></a>4. 后训练</h3> 
<p>我们通过对预训练检查点进行多轮后训练，或在预训练检查点的基础上与人类反馈（Ouyang等人，2022年；Rafailov等人，2024年）对齐模型，以产生对齐的Llama 3模型。每一轮后训练包括监督式微调（SFT）和直接偏好优化（DPO；Rafailov等人，2024年），这些操作都是在通过人工注释或合成生成的示例上进行的。我们的后训练建模和数据方法分别在第4.1节和第4.2节中描述。我们进一步在第4.3节中详细说明了定制数据管理策略，以提高推理、编码、事实性、多语言、工具使用、长上下文和精确指令跟随能力。</p> 
<br> 
<h4><a id="41__325"></a>4.1 建模</h4> 
<p>我们后训练策略的支柱是奖励模型和语言模型。我们首先使用人工注释的偏好数据，在预训练检查点的基础上训练奖励模型（见第4.1.2节）。然后，我们使用监督式微调（SFT；见第4.1.3节）对预训练检查点进行微调，并进一步使用直接偏好优化（DPO；见第4.1.4节）与检查点对齐。这个过程在图7中进行了说明。除非另有说明，我们的建模过程适用于Llama 3 405B，并且为了方便起见，我们将Llama 3 405B简称为Llama 3。</p> 
<br> 
<h5><a id="411__330"></a>4.1.1 聊天对话格式</h5> 
<p>为了调整大型语言模型进行人类-AI交互，我们需要为模型定义一个聊天对话协议，以理解人类指令并执行对话任务。与其前身相比，Llama 3具有新的能力，如工具使用（第4.3.5节），这可能需要在单个对话回合中生成多个消息并将其发送到不同的位置（例如，用户，ipython）。为支持这一点，我们设计了一种新的多消息聊天协议，使用各种特殊的头部和终止标记。头部标记用于指示对话中每条消息的来源和目的地。同样，终止标记指示何时在人类和AI之间交替发言。</p> 
<br> 
<h5><a id="412__335"></a>4.1.2 奖励建模</h5> 
<p>我们在预训练检查点的基础上，训练一个涵盖不同能力的奖励模型（RM）。训练目标与Llama 2相同，只是我们去掉了损失中的边际项，因为我们观察到数据扩展后的改进逐渐减少。按照Llama 2的做法，我们在过滤掉响应相似的样本后，使用我们所有的偏好数据进行奖励建模。除了标准的偏好对（被选择的，被拒绝的）响应外，注释还为一些提示创建了第三个“编辑过的响应”，其中从对中选择的响应进一步编辑以改进（见第4.2.1节）。因此，每个偏好排名样本有两个或三个具有清晰排名的响应（编辑过 &gt; 被选择的 &gt; 被拒绝的）。在训练期间，我们将提示和多个响应合并成一行，响应随机打乱。这是将响应分别放在单独的行中并计算分数的标准场景的近似，但在我们的消融研究中，这种方法在不损失准确性的情况下提高了训练效率。</p> 
<br> 
<h5><a id="413__340"></a>4.1.3 超监督微调</h5> 
<p>然后，我们使用奖励模型对人工注释提示进行拒绝采样，其细节在第4.2节中描述。连同这些拒绝采样的数据和其他数据源（包括合成数据），我们使用标准的交叉熵损失对预训练的语言模型进行微调（同时在提示标记上掩盖损失）。关于数据混合的更多细节可以在第4.2节找到。我们称这个阶段为监督式微调（SFT；Wei等人，2022a；Sanh等人，2022；Wang等人，2022b），即使许多训练目标是模型生成的。我们最大的模型在8.5K到9K步的过程中以1e-5的学习率进行微调。我们发现这些超参数设置在不同的回合和数据混合中表现良好。</p> 
<br> 
<h5><a id="414__345"></a>4.1.4 直接偏好优化</h5> 
<p>我们进一步使用直接偏好优化（DPO；Rafailov等人，2024年）对SFT模型进行训练，以符合人类偏好对齐。在训练中，我们主要使用前一轮对齐中表现最好的模型收集的最新一批偏好数据。因此，我们的训练数据更好地符合每轮优化中的策略模型的分布。我们还探索了如PPO（Schulman等人，2017）等策略算法，但发现DPO对于大规模模型需要的计算量更少，并且表现更好，尤其是在像IFEval（Zhou等人，2023）这样的指令跟随基准上。对于Llama 3，我们使用1e-5的学习率，并将β超参数设置为0.1。此外，我们对DPO应用了以下算法修改：</p> 
<p>在DPO损失中屏蔽格式标记：我们从损失中的被选择和被拒绝的响应中屏蔽特殊格式标记，包括头部和终止标记（见第4.1.1节），以稳定DPO训练。我们观察到，让这些标记对损失做出贡献可能导致不期望的模型行为，例如尾部重复或突然生成终止标记。我们假设这是由于DPO损失的对比性质——在被选择和被拒绝的响应中存在共同标记导致学习目标冲突，因为模型需要同时增加和减少这些标记的可能性。<br> 通过NLL损失进行正则化：我们添加了一个额外的负对数似然（NLL）损失项，对被选择的序列进行缩放，缩放系数为0.2，类似于Pang等人（2024年）。这有助于通过保持生成所需的格式和防止被选择响应的对数概率降低来进一步稳定DPO训练（Pang等人，2024年；Pal等人，2024年）。</p> 
<br> 
<h5><a id="415__353"></a>4.1.5 模型平均</h5> 
<p>最后，在每个RM、SFT或DPO阶段，我们对使用不同版本的数据或超参数的实验获得的模型进行平均（Izmailov等人，2019年；Wortsman等人，2022年；Li等人，2022年）。</p> 
<br> 
<h5><a id="416__359"></a>4.1.6 迭代轮次</h5> 
<p>遵循Llama 2的做法，我们通过六个轮次应用上述方法。在每个周期中，我们收集新的偏好注释和SFT数据，从最新的模型中采样合成数据。</p> 
<br> 
<h4><a id="42__364"></a>4.2 后训练数据</h4> 
<p>后训练数据的组成对语言模型的有用性和行为起着至关重要的作用。在本节中，我们讨论了我们的人工注释程序和偏好数据收集（第4.2.1节），我们的SFT数据的组成（第4.2.2节），以及数据质量控制和清洗的方法（第4.2.3节）。</p> 
<br> 
<h5><a id="421__369"></a>4.2.1 偏好数据</h5> 
<p>我们的偏好数据注释过程与Llama 2类似。我们在每个轮次后部署多个模型进行注释，并为每个用户提示采样两个不同模型的两个响应。这些模型可以用不同的数据混合和对齐配方进行训练，允许不同的能力强度（例如，编码专业知识）和增加数据多样性。我们要求注释者根据他们对被选择响应相对于被拒绝响应的偏好程度，将其偏好强度分为四个等级：明显更好、更好、略好或勉强更好。我们还在偏好排名后加入编辑步骤，鼓励注释者进一步完善首选响应。注释者可以直接编辑所选响应，或提示模型用反馈来细化自己的响应。因此，我们的部分偏好数据有三个排名的响应（编辑过 &gt; 被选择的 &gt; 被拒绝的）。</p> 
<p>在表6中，我们报告了我们用于Llama 3训练的偏好注释的统计数据。通用英语涵盖了多个子类别，如基于知识的问答或精确指令跟随，这些不在特定能力的范围之内。与Llama 2相比，我们观察到提示和响应的平均长度有所增加，这表明我们正在训练Llama 3处理更复杂的任务。此外，我们实施了质量分析和人工评估流程，以严格评估收集的数据，允许我们完善我们的提示并为注释者提供系统、可行的反馈。例如，随着Llama 3在每个轮次后改进，我们相应地增加提示的复杂性，以针对模型滞后的领域。</p> 
<p>在每个后训练轮次中，我们使用当时可用的所有偏好数据进行奖励建模，而仅使用各种能力的最新批次进行DPO训练。对于奖励建模和DPO，我们都使用被标记为被选择响应明显更好或比被拒绝的对应物更好的样本进行训练，并丢弃响应相似的样本。</p> 
<br> 
<h5><a id="422_SFT_378"></a>4.2.2 SFT数据</h5> 
<p>我们的微调数据主要由以下来源组成：</p> 
<p>来自我们人工注释收集的提示，以及拒绝采样的响应<br> 针对特定能力的目标合成数据（见第4.3节的更多细节）</p> 
<p>少量人工策划的数据（见第4.3节的更多细节）<br> 随着我们后训练轮次的进展，我们开发了更强的Llama 3变体，我们用它们来收集覆盖广泛复杂能力的大型数据集。在本节中，我们讨论了拒绝采样过程的细节和我们最终SFT数据混合的总体组成。</p> 
<p>拒绝采样。在拒绝采样（RS）期间，对于人工注释期间收集的每个提示（第4.2.1节），我们从最新的聊天模型策略中采样K（通常在10到30之间）个输出（通常是最好的性能检查点来自上一次后训练迭代，或特定能力的最好性能检查点），并使用我们的奖励模型选择最佳候选，与Bai等人（2022）一致。在后训练的后期轮次中，我们引入系统提示，以引导RS响应符合不同能力所需的期望语调、风格或格式。</p> 
<p>为了提高拒绝采样的效率，我们采用了PagedAttention（Kwon等人，2023）。PagedAttention通过动态键值缓存分配增强了内存效率。它通过根据当前缓存容量动态安排请求，支持任意输出长度。不幸的是，当内存不足时，这带来了交换的风险。为了消除这种交换开销，我们定义了最大输出长度，并仅在有足够的内存来适应该长度的输出时执行请求。PagedAttention还使我们能够跨所有相应的输出共享提示的键值缓存页面。这些共同导致了拒绝采样期间吞吐量的2倍以上提高。</p> 
<p>整体数据组成。表7显示了我们“有用性”混合的每个广泛类别的数据统计。虽然SFT和偏好数据包含重叠的领域，但它们被不同地策划，产生了不同的计数统计数据。在第4.2.3节中，我们描述了对我们的数据样本进行主题、复杂性和质量分类的技术。在每个后训练轮次中，我们仔细调整这些轴上的整体数据混合，以在广泛的基准上调整性能。我们的最终数据混合在一些高质量资源上多次循环，并对其他资源进行下采样。</p> 
<br> 
<h5><a id="423__395"></a>4.2.3 数据处理和质量控制</h5> 
<p>鉴于我们的大部分训练数据是模型生成的，因此需要仔细清洗和质量控制。</p> 
<p>数据清洗。在早期轮次中，我们观察到数据中存在一些不良模式，例如过度使用表情符号或感叹号。因此，我们实施了一系列基于规则的数据移除和修改策略，以过滤或清洗有问题的数据。例如，为了缓解过于道歉的语气问题，我们识别出过度使用的短语（如“I’m sorry”或“I apologize”），并仔细平衡我们数据集中这类样本的比例。</p> 
<ul><li>数据修剪。我们还应用了一系列基于模型的技术来移除低质量的训练样本并提高整体模型性能：</li><li>主题分类：我们首先将Llama 3 8B微调为主题分类器，并在所有数据上进行推理，将其分类为粗略的桶（“数学推理”）和细粒度的桶（“几何和三角学”）。</li><li>质量评分：我们同时使用奖励模型和基于Llama的信号为每个样本获得质量分数。对于基于RM的分数，我们认为RM分数在前四分之一的数据为高质量。对于基于Llama的分数，我们提示Llama 3检查点在三点量表上对一般英语数据（准确性、指令跟随和语调/呈现）进行评分，并对编码数据（错误识别和用户意图）进行两点量表评分，并将获得最高分数的样本视为高质量。RM和基于Llama的分数有很高的不一致率，我们发现结合这些信号在我们的内部测试集上产生了最佳的召回率。最终，我们选择被RM或基于Llama的过滤器标记为高质量的示例。</li><li>难度评分：因为我们也对优先考虑对模型更复杂的示例感兴趣，我们使用两种难度度量来评分数据：Instag（Lu等人，2023）和基于Llama的评分。对于Instag，我们提示Llama 3 70B对SFT提示进行意图标记，更多的意图意味着更复杂。我们还提示Llama 3在三点量表上测量对话的难度（Liu等人，2024c）。</li><li>语义去重：最后，我们执行语义去重（Abbas等人，2023；Liu等人，2024c）。我们首先使用RoBERTa（Liu等人，2019b）对完整对话进行聚类，并在每个聚类内按质量分数×难度分数排序。然后我们通过迭代所有排序的示例，并只保留与迄今为止聚类中看到的示例的最大余弦相似度小于阈值的示例，进行贪婪选择。</li></ul> 
<br> 
<h4><a id="43__408"></a>4.3 能力</h4> 
<p>我们特别强调为特定能力如代码（第4.3.1节）、多语言（第4.3.2节）、数学和推理（第4.3.3节）、长上下文（第4.3.4节）、工具使用（第4.3.5节）、事实性（第4.3.6节）和可控性（第4.3.7节）提高性能所做的努力。</p> 
<br> 
<h5><a id="431__413"></a>4.3.1 代码</h5> 
<p>自Copilot和Codex（Chen等人，2021年）发布以来，用于代码的大型语言模型（LLMs）受到了显著关注。开发者现在广泛使用这些模型生成代码片段、调试、自动化任务和提高代码质量。对于Llama 3，我们针对以下高优先级的编程语言改进和评估代码生成、文档编写、调试和审查能力：Python、Java、Javascript、C/C++、Typescript、Rust、PHP、HTML/CSS、SQL、bash/shell。在这里，我们介绍了通过训练代码专家、为SFT生成合成数据、通过系统提示引导改进格式以及创建质量过滤器从我们的训练数据中移除不良样本来改进这些编码能力的工作。</p> 
<ul><li> <p>专家训练。我们训练了一个代码专家，我们用它在后续轮次的后训练中收集高质量的人工注释代码。这是通过分支主预训练运行并在大部分（&gt;85%）代码数据的1T标记混合上继续预训练来实现的。继续在特定领域的数据上进行预训练已被证明对提高特定领域的表现是有效的（Gururangan等人，2020年）。我们遵循与CodeLlama（Rozière等人，2023年）类似的配方。在训练的最后几千步中，我们执行长上下文微调（LCFT），以将专家的上下文长度扩展到16K标记的高质量存储库级代码数据混合上。最后，我们遵循第4.1节中描述的类似的后训练建模配方来对齐此模型，只是SFT和DPO数据混合主要针对代码。这个模型也用于拒绝采样（第4.2.2节）的编码提示。</p> </li><li> <p>合成数据生成。在开发过程中，我们确定了代码生成中的关键问题，包括难以遵循指令、代码语法错误、代码生成不正确以及修复错误的困难。尽管理论上密集的人工注释可以解决这些问题，合成数据生成提供了一种成本更低、规模更大且不受注释者专业水平限制的补充方法。因此，我们使用Llama 3和代码专家生成了大量合成SFT对话。</p> </li></ul> 
<p>我们描述了生成合成代码数据的三种高层方法。总共，我们生成了超过2.7M个在SFT期间使用的合成示例。</p> 
<ol><li>合成数据生成：执行反馈。8B和70B模型在由更大、更有能力模型生成的数据上训练时显示出显著的性能提升。然而，我们的初步实验揭示，使用Llama 3 405B自己生成的数据进行训练并没有帮助（甚至可能降低性能）。为解决这个限制，我们引入执行反馈作为真实性的来源，使模型能够从错误中学习并保持在正确的轨道上。特别是，我们使用以下流程生成了大约一百万合成编码对话的大型数据集：</li></ol> 
<ul><li> <p>问题描述生成：首先，我们生成了一个涵盖广泛话题的编程问题描述的大量集合，包括那些在长尾分布中的话题。为实现这种多样性，我们从各种来源采样随机代码片段，并提示模型生成受这些示例启发的编程问题。这使我们能够涉及广泛的主题，并创建一套全面的问题描述（Wei等人，2024年）。</p> </li><li> <p>解决方案生成：然后，我们提示Llama 3用给定的编程语言解决每个问题。我们观察到，在提示中添加通用的良好编程规则可以提高生成的解决方案质量。此外，我们发现要求模型在注释中解释其思维过程是有帮助的。</p> </li><li> <p>正确性分析：生成解决方案后，认识到其正确性并非保证是至关重要的，将不正确的解决方案包含在微调数据集中可能会损害模型的质量。虽然我们不能完全确保正确性，但我们开发了近似方法。为实现此目的，我们提取生成解决方案的源代码，并应用了静态和动态分析技术的组合来测试其正确性，包括：<br> a.静态分析：我们将所有生成的代码通过解析器和linter运行，以确保语法正确性，捕捉诸如语法错误、使用未初始化变量或未导入函数、代码风格问题、类型错误等错误。<br> b.单元测试生成和执行：对于每个问题和解决方案，我们提示模型生成单元测试，在容器化环境中与解决方案一起执行，捕捉运行时执行错误和一些语义错误。</p> </li><li> <p>错误反馈和迭代自我修正：当解决方案在任何步骤失败时，我们提示模型进行修正。提示包括原始问题描述、错误的解决方案以及来自解析器/linter/测试器（stdout、stderr和返回代码）的反馈。在单元测试执行失败后，模型可以修复代码以通过现有测试，或修改其单元测试以适应生成的代码。只有通过所有检查的对话才包含在最终数据集中，用于监督式微调（SFT）。值得注意的是，我们观察到大约20%的解决方案最初是不正确的，但自我修正了，表明模型从执行反馈中学到了东西并提高了其性能。</p> </li><li> <p>微调和迭代改进：微调过程在多轮中进行，每一轮都建立在前一轮的基础上。每一轮之后，模型都会得到改进，为下一轮生成更高质量的合成数据。这种迭代过程允许逐步改进和增强模型的性能。</p> </li></ul> 
<ol start="2"><li> <p>合成数据生成： 编程语言翻译。<br> 我们观察到主要编程语言（例如，Python/C++）和较少使用的编程语言（例如，Typescript/PHP）之间的性能差距。这并不令人惊讶，因为我们为较少使用的编程语言的训练数据较少。为缓解这一点，我们通过将常见编程语言的数据翻译成较少使用的语言来补充现有数据（类似于Chen等人（2023年）在推理背景下的做法）。这是通过提示Llama 3并通过语法解析、编译和执行来确保质量来实现的。图8展示了从Python翻译成PHP的合成PHP代码的示例。这显著提高了较少使用语言的性能，如MultiPL-E（Cassano等人，2023年）基准测试所示。</p> </li><li> <p>合成数据生成：回译。为了提高某些编码能力（例如，文档编写、解释），在执行反馈对于确定质量不够有信息量的情况下，我们采用一种替代的多步骤方法。使用这一程序，我们生成了大约120万个与代码解释、生成、文档编写和调试相关的合成对话。从我们的预训练数据中，以多种语言编写的代码片段开始：<br> a.生成：我们提示Llama 3生成代表我们目标能力的数据（例如，我们为代码片段添加注释和docstrings，或者我们要求模型解释一段代码）。<br> b.回译：然后我们提示模型将合成生成的数据“回译”到原始代码（例如，我们提示模型仅从其文档生成代码，或者我们要求模型仅从其解释生成代码）。<br> c.筛选：使用原始代码作为参考，我们提示Llama 3确定输出的质量（例如，我们问模型回译的代码对原始代码的忠实度如何）。然后我们使用在SFT中具有最高自我验证分数的生成示例。</p> </li></ol> 
<p>在拒绝抽样过程中的系统提示导向。在拒绝抽样过程中，我们使用特定于代码的系统提示来提高代码可读性、文档完整性和具体性。回想，在第7节中，这些数据用于微调语言模型。图9显示了系统提示如何帮助提高生成的代码质量的一个示例——它添加了必要的注释，使用了更信息丰富的变量名，节省了内存等。</p> 
<p>使用执行和模型作为裁判信号过滤训练数据。如第4.2.3节所述，我们偶尔会在我们的拒绝抽样数据中遇到质量问题，例如包含错误的代码块。在我们的拒绝抽样数据中检测这些问题并不像在合成代码数据中那样直接，因为拒绝抽样的响应通常包含自然语言和代码的混合，其中代码可能并不总是预期可执行的。（例如，用户提示可能明确要求伪代码或仅对一个非常小的可执行程序片段进行编辑。）为了解决这个问题，我们采用了“模型作为裁判”的方法，其中早期版本的Llama 3根据两个标准评估并分配一个二进制（0/1）分数：代码正确性和代码风格。我们只保留那些获得2分满分的样本。最初，这种严格的过滤导致了下游基准性能的回归，主要是因为它不成比例地移除了具有挑战性提示的示例。为了抵消这一点，我们有策略地修订了一些被归类为最具挑战性的编码数据的响应，直到它们满足基于Llama的“模型作为裁判”的标准。通过完善这些具有挑战性的问题，编码数据在质量和难度之间实现了平衡，从而实现了最佳的下游性能。</p> 
<br> 
<h5><a id="432__450"></a>4.3.2 多语言能力</h5> 
<p>我们描述了我们如何提高Llama 3的多语言能力，包括训练一个专家，专门针对大量多语言数据进行训练，为德语、法语、意大利语、葡萄牙语、印地语、西班牙语和泰语来源和生成高质量的多语言指令调整数据，并解决多语言语言导向的具体挑战，以提高我们模型的整体性能。</p> 
<ul><li> <p>专家训练。我们的Llama 3预训练数据混合包含的英语标记比非英语标记多得多。为了收集非英语语言的更高质量人类注释，我们通过分支预训练运行并继续在包含90%多语言标记的数据混合上进行预训练，来训练一个多语言专家。然后我们按照第4.1节对这位专家进行后训练。这个专家模型随后被用来收集非英语语言的更高质量注释，直到预训练完全完成。</p> </li><li> <p>多语言数据收集。我们的多语言SFT数据主要来源于以下描述的来源。总体分布是2.4%人类注释，44.2%来自其他NLP任务的数据，18.8%拒绝抽样数据，和34.6%翻译推理数据。</p> 
  <ul><li> <p>人类注释：我们从语言学家和母语者那里收集高质量的、手动注释的数据。这些注释主要由代表现实世界用例的开放式提示组成。</p> </li><li> <p>来自其他NLP任务的数据：为了进一步增强，我们使用其他任务的多语言训练数据，并将其改写成对话格式。例如，我们使用来自exams-qa（Hardalov等人，2020年）和Conic10k（Wu等人，2023年）的数据。为了提高语言对齐，我们还使用GlobalVoices（Prokopidis等人，2016年）和Wikimedia（Tiedemann，2012年）的平行文本。我们使用基于LID的过滤和Blaser2.0（Seamless Communication等人，2023年）来移除低质量数据。对于平行文本数据，我们不是直接使用双语对，而是应用了一种受Wei等人（2022a）启发的多语言模板，以更好地模拟翻译和语言学习场景中的真实生活对话。</p> </li><li> <p>拒绝抽样数据：我们在人类注释提示上应用拒绝抽样，以生成用于微调的高质量样本，与英语数据的过程相比，修改很少：<br> a.生成：我们在后训练的早期轮次中探索了随机选择温度超参数的范围0.2−1，以实现多样化生成。高温下，多语言提示的响应可能具有创造性和启发性，但也容易不必要的或不自然的代码转换。在后训练的最后一轮，我们使用恒定值0.6来平衡权衡。此外，我们使用专门的系统提示来改善响应格式、结构和一般可读性。<br> b.选择：在基于奖励模型的选择之前，我们实施了多语言特定的检查，以确保提示和响应之间的高语言匹配率（例如，罗马化的印地语提示不应期望以印地语天城文脚本响应）。<br> c.翻译数据：我们尽量避免使用机器翻译数据来微调模型，以防止翻译体（Bizzoni等人，2020年；Muennighoff等人，2023年）或可能的名称偏见（Wang等人，2022a）、性别偏见（Savoldi等人，2021年）或文化偏见（Ji等人，2023年）。此外，我们的目标是防止模型只接触到根植于英语文化背景的任务，这可能无法代表我们旨在捕捉的语言和文化多样性。我们对此做了一个例外，并将我们的合成定量推理数据（见第4.3.3节详情）翻译，以提高非英语语言中的定量推理性能。由于这些数学问题的语言简单性，翻译样本的质量问题很少或没有。我们观察到，通过添加这些翻译数据，在MGSM（Shi等人，2022年）上取得了强劲的增长。</p> </li></ul> </li></ul> 
<br> 
<h5><a id="433__467"></a>4.3.3 数学与推理</h5> 
<p>我们将推理定义为执行多步骤计算并得出正确最终答案的能力。几个挑战指导了我们训练模型在数学推理方面出类拔萃的方法：</p> 
<ul><li> <p>缺乏提示：随着问题的复杂性增加，用于监督式微调（SFT）的有效提示或问题数量减少。这种稀缺性使得为教授模型各种数学技能而创建多样化和具有代表性的培训数据集变得困难（Yu等人，2023；Yue等人，2023；Luo等人，2023；Mitra等人，2024；Shao等人，2024；Yue等人，2024b）。</p> </li><li> <p>缺乏真实的思考链：有效的推理需要逐步解决方案以促进推理过程（Wei等人，2022c）。然而，通常缺少真实的思考链，这对于指导模型如何逐步分解问题并得出最终答案至关重要（Zelikman等人，2022）。</p> </li><li> <p>中间步骤不正确：当使用模型生成的思考链时，中间步骤可能并不总是正确的（Cobbe等人，2021；Uesato等人，2022；Lightman等人，2023；Wang等人，2023a）。这种不准确性可能导致最终答案不正确，需要解决。</p> </li><li> <p>教会模型使用外部工具：增强模型以使用外部工具，如代码解释器，允许它们通过交错代码和文本进行推理（Gao等人，2023；Chen等人，2022；Gou等人，2023）。这种能力可以显著提高它们的解决问题能力。</p> </li><li> <p>训练与推理之间的差异：训练期间模型的微调方式与推理期间的使用方式之间通常存在差异。在推理期间，微调模型可能与人类或其他模型交互，要求它使用反馈改进其推理。确保训练与真实世界使用之间的一致性对于维持推理性能至关重要。</p> </li></ul> 
<p>为了应对这些挑战，我们应用了以下方法：</p> 
<ul><li>解决提示不足的问题：我们从数学背景中获取相关的预训练数据，并将其转换为问答格式，然后可用于监督式微调。此外，我们确定模型表现不佳的数学技能，并积极从人类那里获取提示，教授模型这些技能。为了促进这一过程，我们创建了一个数学技能分类（Didolkar等人，2024）并要求人类相应地提供相关的提示/问题。</li><li>用逐步推理痕迹扩充训练数据：我们使用Llama 3为一组提示生成逐步解决方案。对于每个提示，模型产生不同数量的生成。然后根据正确答案过滤这些生成（Li等人，2024a）。我们还进行自我验证，使用Llama 3验证特定的逐步解决方案是否适用于给定问题。这一过程通过消除模型未产生有效推理痕迹的实例，提高了微调数据的质量。</li><li>过滤错误的推理痕迹：我们训练结果和逐步奖励模型（Lightman等人，2023；Wang等人，2023a）来过滤训练数据，其中中间推理步骤不正确。这些奖励模型用于消除带有无效逐步推理的数据，确保微调的高质量数据。对于更具挑战性的提示，我们使用带有学习到的逐步奖励模型的蒙特卡洛树搜索（MCTS）来生成有效的推理痕迹，进一步提高了收集高质量推理数据的能力（Xie等人，2024）。</li><li>交错代码和文本推理：我们提示Llama 3通过文本推理和相关Python代码的组合来解决推理问题（Gou等人，2023）。代码执行被用作反馈信号，以消除推理链无效的情况，确保推理过程的正确性。</li><li>从反馈和错误中学习：为了模拟人类反馈，我们利用错误的生成（即导致错误推理痕迹的生成）并通过提示Llama 3产生正确的生成来进行错误纠正（An等人，2023b；Welleck等人，2022；Madaan等人，2024a）。使用错误尝试的反馈并纠正它们的迭代过程有助于提高模型准确推理并从错误中学习的能力。</li></ul> 
<br> 
<h5><a id="434__489"></a>4.3.4 长文本环境</h5> 
<p>在最后的预训练阶段，我们将Llama 3的上下文长度从8K令牌扩展到128K令牌（见第3.4节以获取更多详细信息）。类似于预训练，我们发现在微调期间，我们必须仔细调整配方，以平衡短文本和长文本环境的能力。</p> 
<p>SFT和合成数据生成。简单地应用我们现有的仅使用短文本环境数据的SFT配方，导致长文本环境能力的显著退化，这突显了在SFT数据混合中纳入长文本环境数据的必要性。然而，在实践中，由于阅读冗长上下文的繁琐和耗时，让人类注释这样的示例在很大程度上是不切实际的，因此我们主要依赖合成数据来填补这一空白。我们使用早期版本的Llama 3基于关键的长文本环境用例生成合成数据：（可能是多轮）问答、长文档摘要和对代码库的推理，并在下文中更详细地描述它们。</p> 
<ul><li>问答：我们从预训练混合中精心策划一组长文档。我们将这些文档分割成8K令牌的块，并提示早期版本的Llama 3模型基于随机选择的块生成QA对。在训练期间，整个文档被用作上下文。<br> 摘要：我们通过首先使用我们最强的Llama 3 8K上下文模型对8K输入长度的块进行摘要，然后对摘要进行摘要，来应用长文本环境文档的分层摘要。在训练期间，我们提供完整文档，并提示模型在保留所有重要细节的同时摘要文档。我们还基于文档摘要生成QA对，并用需要对整个长文档有全局理解的问题提示模型。</li><li>长文本环境代码推理：我们解析Python文件以识别import语句并确定它们的依赖关系。从这里，我们选择最常依赖的文件，特别是至少被其他五个文件引用的文件。我们从存储库中移除其中一个关键文件，并提示模型识别依赖于缺失文件的文件，并生成必要的缺失代码。 我们根据序列长度（16K、32K、64K和128K）进一步对这些合成生成的样本进行分类，以便更细粒度地针对输入长度进行定位。 通过仔细的消融，我们观察到将0.1%的合成生成的长文本环境数据与原始短文本环境数据混合使用，可以在短文本环境和长文本环境基准测试中优化性能。 DPO。我们观察到，只要SFT模型适合长文本环境任务，仅使用短文本环境训练数据在DPO中就不会对长文本环境性能产生负面影响。我们怀疑这是由于我们的DPO配方比SFT有更少的优化步骤。鉴于这一发现，我们在长文本环境SFT检查点之上保持标准的短文本环境DPO配方。</li></ul> 
<br> 
<h5><a id="435__500"></a>4.3.5 工具使用</h5> 
<p>教会大型语言模型（LLMs）使用工具，如搜索引擎或代码解释器，极大地扩展了它们能够解决的任务范围，将它们从纯聊天模型转变为更通用的助手（Nakano等人，2021；Thoppilan等人，2022；Parisi等人，2022；Gao等人，2023；Mialon等人，2023a；Schick等人，2024）。我们训练Llama 3与以下工具进行交互：</p> 
<ul><li>搜索引擎。Llama 3被训练使用Brave Search7来回答超出其知识截止日期的近期事件问题，或需要从网络检索特定信息的问题。</li><li>Python解释器。Llama 3可以生成并执行代码以执行复杂计算，读取用户上传的文件，并基于这些文件执行任务，如问答、摘要、数据分析或可视化。</li><li>数学计算引擎。Llama 3可以使用Wolfram Alpha API8更准确地解决数学、科学问题，或从Wolfram的数据库检索准确信息。 生成的模型能够在聊天设置中使用这些工具来解决用户的查询，包括多轮对话。如果查询需要多次工具调用，模型可以编写逐步计划，按顺序调用工具，并在每次工具调用后进行推理。</li></ul> 
<p>我们还提高了Llama 3的零样本工具使用能力——在上下文中，可能是未见过的潜在工具定义和用户查询，我们训练模型生成正确的工具调用。</p> 
<ul><li> <p>实现。我们实现我们的核心工具为具有不同方法的Python对象。零样本工具可以作为具有描述、文档（即，如何使用它们的示例）的Python函数实现，模型只需要函数的签名和文档字符串作为上下文来生成适当的调用。我们还将函数定义和调用转换为JSON格式，例如，用于Web API调用。所有工具调用都由Python解释器执行，该解释器必须在Llama 3系统提示中启用。核心工具可以在系统提示中单独启用或禁用。</p> </li><li> <p>数据收集。与Schick等人（2024）不同，我们依赖人类注释和偏好来教会Llama 3使用工具。与通常在Llama 3中使用的后训练管道有两个主要区别：<br> 对于工具，对话通常包含不止一条助手消息（例如，调用工具和推理工具输出）。因此，我们在消息级别进行注释以收集细致的反馈：注释者在两个具有相同上下文的助手消息之间提供偏好，或者，如果两者都包含主要问题，则编辑其中一条消息。选择或编辑的消息随后被添加到上下文中，对话继续。这为助手调用工具的能力和对工具输出进行推理提供了人类反馈。注释者不能对工具输出进行排名或编辑。<br> 我们不执行拒绝抽样，因为我们在我们的工具基准测试中没有观察到增益。<br> 为了加速注释过程，我们首先通过在先前Llama 3检查点上微调合成生成的数据来引导基本工具使用能力。因此，注释者需要进行的编辑较少。同样，随着Llama 3在开发过程中逐渐改进，我们逐渐复杂化我们的人类注释协议：我们从单轮工具使用注释开始，然后转移到对话中的工具使用，最后注释多步工具使用和数据分析。</p> </li><li> <p>工具数据集。为了创建工具使用应用的数据，我们采用以下程序：</p> 
  <ul><li> <p>单步工具使用：我们首先通过少量样本生成合成用户提示，这些提示在构建时就需要调用我们的核心工具之一（例如，超出我们知识截止日期的问题）。然后，仍然依赖少量样本生成，我们为这些提示生成适当的工具调用，执行它们，并将输出添加到模型的上下文中。最后，我们再次提示模型根据工具的输出生成对用户查询的最终答案。我们最终得到以下形式的轨迹：系统提示、用户提示、工具调用、工具输出、最终答案。我们还筛选了这个数据集的大约30%，以移除无法执行的工具调用或其他格式问题。</p> </li><li> <p>多步工具使用：我们遵循类似的协议，首先生成合成数据以教授模型基本的多步工具使用能力。为此，我们首先提示Llama 3生成至少需要两次工具调用的用户提示，这些可以是来自我们核心集合的相同或不同的工具。然后，基于这些提示，我们少量样本提示Llama 3生成一个解决方案，该方案由交错的推理步骤和工具调用组成，类似于ReAct（Yao等人，2022）。见图10，展示Llama 3执行涉及多步工具使用的任务的示例。</p> </li><li> <p>文件上传 我们注释以下文件类型：<br> txt、.docx、.pdf、.pptx、.xlsx、.csv、.tsv、.py、.json、.jsonl、.html、.xml。我们的提示基于提供的文件，并要求概述文件内容、查找和修复错误、优化代码片段、执行数据分析或可视化。见图11，展示Llama 3执行涉及文件上传的任务的示例。<br> 在对这个合成数据进行微调后，我们在多种具有挑战性的场景中收集人类注释，包括多轮交互、超过三个步骤的工具使用，以及工具调用没有得到满意答案的情况。我们用不同的系统提示增强我们的合成数据，以教会模型仅在激活时使用工具。为了训练模型避免对简单查询调用工具，我们还添加了来自简单数学或问答数据集（Berant等人，2013；Koncel-Kedziorski等人，2016；Joshi等人，2017；Amini等人，2019）的查询及其响应，但没有使用工具，但在系统提示中激活了工具。</p> </li></ul> </li><li> <p>零样本工具使用数据。我们通过在大量多样的部分合成数据集（函数定义、用户查询、相应的调用）上微调，提高Llama 3的零样本工具使用能力（也称为函数调用）。我们在一组未见过的工具上评估我们的模型。</p> 
  <ul><li> <p>单一、嵌套和并行函数调用：调用可以是简单的，嵌套的，即我们把一个函数调用作为另一个函数的参数传递，或者是并行的，即模型返回一系列独立的函数调用。生成多样化的函数、查询和真实情况可能具有挑战性（Mekala等人，2024），我们依靠挖掘Stack（Kocetkov等人，2022）来使我们的合成用户查询基于真实函数。更具体地说，我们提取函数调用及其定义，进行清理和筛选，例如缺失文档字符串或不可执行的函数，并使用Llama 3生成与函数调用相对应的自然语言查询。</p> </li><li> <p>多轮函数调用：我们还为带有函数调用的多轮对话生成合成数据，遵循Li等人（2023b）提出的协议。我们使用多个代理生成领域、API、用户查询、API调用和响应，同时确保生成的数据涵盖多样化的领域和现实的API。所有代理都是以不同方式提示的Llama 3的变体，根据它们的角色进行协作，并以逐步的方式进行。</p> </li></ul> </li></ul> 
<br> 
<h5><a id="436__531"></a>4.3.6 事实性</h5> 
<p>幻觉对于大型语言模型来说仍然是一个主要挑战。模型往往过于自信，即使在它们知之甚少的领域也是如此。尽管存在这些不足，它们仍常被用作知识库，这可能导致诸如错误信息传播这样的风险结果。虽然我们认识到事实性可以超越幻觉，但在这里我们采取了以幻觉为先的方法。</p> 
<p>我们遵循的原则是，后训练应该使模型与“知道自己知道什么”对齐，而不是增加知识（Gekhman等人，2024；Mielke等人，2020）。我们的主要方法涉及生成数据，使模型生成与预训练数据中存在的事实数据子集对齐。为了实现这一点，我们开发了一种利用Llama 3上下文能力的知识探测技术。这个数据生成过程包括以下步骤：</p> 
<ul><li>从预训练数据中提取数据片段。</li><li>通过提示Llama 3生成关于这些片段（上下文）的事实性问题。</li><li>从Llama 3获取问题的回答样本。</li><li>使用原始上下文作为参考，以Llama 3为裁判，对生成的正确性进行评分。</li><li>使用Llama 3为裁判，对生成的信息性进行评分。</li><li>对于在生成中一贯信息丰富但不正确的回答，使用Llama 3生成拒绝回答。</li></ul> 
<p>我们使用从知识探测生成的数据鼓励模型只回答它所知道的问题，并拒绝回答它不确定的问题。此外，预训练数据并不总是事实一致或正确的。因此，我们还收集了有限的标记事实性数据，这些数据涉及存在事实矛盾或错误陈述的敏感话题。</p> 
<br> 
<h5><a id="437__548"></a>4.3.7 可引导性</h5> 
<p>可引导性是将模型的行为和结果引导至满足开发者和用户规范的能力。由于Llama 3是一个通用的基础模型，它应该是最容易引导至不同的下游用例的。对于Llama 3，我们专注于通过系统提示和自然语言指令增强其可引导性，特别是在回答长度、格式、语气和角色/个性方面。</p> 
<p>数据收集。我们通过要求注释者为Llama 3设计不同的系统提示，在通用英语类别内收集可引导性偏好样本。然后，注释者与模型进行对话，评估它们在对话过程中遵循系统提示中定义的指令的一致性。我们在下面展示了一个用于增强可引导性的定制系统提示示例：</p> 
<p>你是一个乐于助人且开朗的AI聊天机器人，充当忙碌家庭的饮食计划助手。这个家庭由2位成年人、3位青少年和2位学龄前儿童组成。每次计划两到三天，并使用剩余的食物或额外的食材为第二天的计划。用户会告诉你他们想要两天还是三天的计划。如果他们没有说，假设是三天。每个计划应包括早餐、午餐、小吃和晚餐。询问用户是否批准计划或需要调整。在他们批准后，提供一份考虑到家庭规模的购物清单。始终牢记家庭的喜好，如果有些东西他们不喜欢，就提供替代品。如果用户没有灵感，就问问他们本周最想去哪里度假，然后根据那个地方的文化建议餐点。周末的餐点可以更复杂。工作日的餐点应该是快速且容易的。对于早餐和午餐，优选像麦片、带预先煮熟的培根的英国松饼和其他快速且容易的食物。这个家庭很忙。确保询问他们是否有像咖啡或能量饮料这样的必需品和最喜欢的东西，这样他们就不会忘记购买。记得要考虑到预算，除非是特殊场合。</p> 
<p>建模。在我们收集了偏好数据后，我们利用这些数据在奖励建模、拒绝抽样、SFT和DPO中，以增强Llama 3的可引导性。</p> 
<br> 
<h3><a id="5__560"></a>5. 结果</h3> 
<p>我们对Llama 3进行了广泛的系列评估，研究了以下方面的性能：(1) 预训练语言模型，(2) 后训练语言模型，以及 (3) Llama 3的安全特性。我们在下面的各个小节中分别呈现这些评估的结果。</p> 
<br> 
<h4><a id="51__566"></a>5.1 预训练语言模型</h4> 
<p>在本节中，我们报告了我们预训练的Llama 3（第3节）的评估结果，并将其与各种其他类似规模的模型进行了比较。我们尽可能地复制了竞争对手模型的结果。对于非Llama模型，我们报告了公开报告的最佳分数，或者（在可能的情况下）我们自己复制的结果。这些评估的具体情况，包括配置（如样本数量、指标）以及其他相关的超参数和设置，可以在我们这里的Github仓库中访问。此外，我们正在发布作为评估一部分生成的数据，并与公开可用的基准进行比较，这些可以在Huggingface这里找到。我们根据标准基准评估我们的模型质量：</p> 
<p>(5.1.1) 标准基准，(5.1.2) 对多项选择题设置变化的鲁棒性，以及 (5.1.3) 对抗性评估。我们还进行了污染分析，以估计我们的评估在多大程度上受到训练数据污染的影响（第5.1.4节）。</p> 
<br> 
<h5><a id="511__573"></a>5.1.1 标准基准</h5> 
<p>为了将我们的模型与当前的最先进技术进行比较，我们在表8中显示的大量标准基准评估上评估了Llama 3。这些评估涵盖了八个顶级类别：(1) 常识推理；(2) 知识；(3) 阅读理解；(4) 数学、推理和问题解决；(5) 长文本环境；(6) 代码；(7) 对抗性评估；以及 (8) 综合评估。</p> 
<p>实验设置。对于每个基准，我们计算了Llama 3以及其他各种类似规模的预训练模型的分数。在可能的情况下，我们使用我们自己的流程重新计算其他模型的数字。为了确保公平比较，我们选择我们计算的分数和该模型的报告数字之间的最佳分数，该模型具有可比或更保守的设置。你可以在这里找到我们评估设置的更多细节。对于一些模型，不可能（重新）计算基准值，例如，因为预训练模型未发布，或者API不提供对对数概率的访问。特别是，这对于所有与Llama 3 405B相当的模型都是如此。因此，我们不报告Llama 3 405B的类别平均值，这需要所有基准的所有数字都可用。</p> 
<p>显著性值。在计算基准分数时，有几个来源的变异性会导致对模型在基准意图测量上的性能估计不精确，例如少量样本演示、随机种子和批量大小。这使得理解一个模型是否在统计上显著优于另一个模型变得具有挑战性。为此，我们报告了我们的分数以及来自基准数据选择的变异性的95%置信区间（CIs）。我们使用公式（Madaan等人，2024b）分析计算95% 。</p> 
<p>其中S是首选基准分数，N是基准的样本量。我们注意到，因为基准数据的变异性不是唯一的变异性来源，这些95% CI是能力估计中实际变异性的下限。对于不是简单平均值的指标，省略了CIs。</p> 
<p>8B和70B模型的结果。图12报告了Llama 3 8B和70B在常识推理、知识、阅读理解、数学和推理以及代码基准上的平均表现。结果显示，Llama 3 8B在几乎所有类别中都优于竞争模型，无论是按类别获胜率还是按类别平均表现来看。我们还发现，Llama 3 70B在大多数基准上大幅度优于其前身Llama 2 70B，例外的是可能已经饱和的常识基准。Llama 3 70B也优于Mixtral 8x22B。</p> 
<p>所有模型的详细结果。表9、10、11、12、13和14展示了预训练的Llama 3 8B、70B和405B模型在阅读理解任务、编码任务、常识理解任务、数学推理任务和一般任务上的基准表现。这些表格将Llama 3的表现与类似规模的模型进行了比较。结果显示，Llama 3 405B在其类别中与其他模型表现相当。特别是，Llama 3 405B在很大程度上优于以前的开源模型。对于长文本环境，我们在第5.2节中展示了更全面的结果（包括像针堆中找针这样的探测任务）。</p> 
<br> 
<h5><a id="512__588"></a>5.1.2 模型鲁棒性</h5> 
<p>除了在基准测试中的表现，鲁棒性是预训练语言模型质量的重要因素。我们研究了我们的预训练语言模型对多项选择题（MCQ）设置中设计选择的鲁棒性。先前的工作报告称，模型表现可能对这些设置中看似随意的设计选择敏感，例如，模型分数甚至排名可能会随着上下文示例的顺序和标签（Lu等人，2022；Zhao等人，2021；Robinson和Wingate，2023；Liang等人，2022；Gupta等人，2024）的变化而变化，提示的确切格式（Weber等人，2023b；Mishra等人，2022），或答案选择格式和顺序（Alzahrani等人，2024；Wang等人，2024a；Zheng等人，2023）。受此工作的启发，我们使用MMLU基准来评估我们的预训练模型对以下方面的鲁棒性：(1) 少量样本标签偏见，(2) 标签变体，(3) 答案顺序，和 (4) 提示格式：</p> 
<p>少量样本标签偏见。按照Zheng等人（2023）和Weber等人（2023a）的方法，我们研究了四样本示例中标签分布的影响。具体来说，我们考虑以下设置：(1) 所有少量样本示例具有相同的标签（A A A A）；(2) 所有示例具有不同的标签（A B C D）；(3) 只有两个标签存在（A A B B 和 C C D D）。<br> 标签变体。我们还研究了模型对不同选择标记集的反应。我们考虑了Alzahrani等人（2024）提出的两组标记：即一组常见的语言独立标记（$ &amp; # @）和一组没有隐含相对顺序的稀有标记（œ § з ü）。我们还考虑了规范标签的两个版本（A. B. C. D. 和 A) B) C) D))以及一个数字列表（1. 2. 3. 4.）。<br> 答案顺序。按照Wang等人（2024a）的方法，我们计算了不同答案顺序下结果的稳定性。为此，我们根据固定的排列重新映射数据集中的所有答案。例如，对于排列A B C D，所有标签为A和B的答案选项保留其标签，所有标签为C的答案选项得到标签D，反之亦然。<br> 提示格式。我们评估了五个任务提示中表现的差异，这些提示在提供的信息量上有所不同：一个提示简单地要求模型回答问题，而其他提示则断言模型的专业知识或应选择最佳答案。<br> 图13展示了我们关于模型对标签变体（左侧）和少量样本标签偏见（右侧）的鲁棒性实验结果。结果显示，我们的预训练语言模型对多项选择题标签的变化和少量样本提示标签的结构非常鲁棒。特别是对于405B参数模型，这种鲁棒性尤为显著。</p> 
<p>图14展示了我们对答案顺序和提示格式鲁棒性研究的结果。图中的结果进一步强调了我们预训练语言模型的性能鲁棒性，特别是Llama 3 405B模型。</p> 
<br> 
<h5><a id="513__601"></a>5.1.3 对抗性基准</h5> 
<p>除了上述基准测试外，我们还在三个领域中的几个对抗性基准上进行评估：问答、数学推理和释义检测。这种测试探测了模型在特别创建的具有挑战性的任务上的能力，并且可能也会指出对基准测试的过度拟合。对于问答，我们使用对抗性SQuAD（Jia和Liang，2017）和Dynabench SQuAD（Kiela等人，2021）。对于数学推理，我们使用GSM-Plus（Li等人，2024c）。对于释义检测，我们使用PAWS（Zhang等人，2019）。</p> 
<p>我们使用的非对抗性基准测试是SQuAD（Rajpurkar等人，2016）用于问答，GSM8K用于数学推理，QQP（Wang等人，2017）用于释义检测。每个数据点代表一对对抗性和非对抗性数据集（例如QQP与PAWS配对），我们显示了类别内所有可能的配对。对角线黑线代表了对抗性和非对抗性数据集之间的平等——位于线上将表明模型无论对抗性如何都有相似的表现。</p> 
<p>在释义检测方面，无论是预训练还是后训练模型，似乎都没有受到PAWS构建时所考虑的那种对抗性的影响，这与前一代模型相比是一个实质性的进步。这一结果证实了Weber等人（2023a）的发现，他们也发现大型语言模型对几种对抗性数据集中发现的那种虚假相关性不太敏感。然而，对于数学推理和问答，对抗性表现显著低于非对抗性表现。这种模式对于预训练和后训练模型都是相似的。</p> 
<br> 
<h5><a id="514__610"></a>5.1.4 污染分析</h5> 
<p>我们进行了污染分析，以估计基准测试分数在多大程度上可能受到预训练语料库中评估数据污染的影响。在以前的工作中，使用了几种不同的污染方法，具有各种不同的超参数——我们参考Singh等人（2024）的概述。这些方法中的任何一种都可能存在误报和漏报，如何最好地进行污染分析目前仍是一个开放的研究领域。在这里，我们主要遵循Singh等人（2024）的建议。</p> 
<p>方法。具体来说，Singh等人（2024）建议基于哪种方法在“干净”数据集部分和整个数据集之间产生最大的差异来选择污染检测方法，他们称之为估计的性能提升。对于我们所有的评估数据集，我们基于8-gram重叠对示例进行评分，这种方法被Singh等人（2024）发现对许多数据集是准确的。我们认为如果数据集D的一个示例的令牌比例TD是至少在预训练语料库中出现一次的8-gram的一部分，则该示例被污染。我们为每个数据集单独选择TD，基于哪个值在三种模型大小上显示出最大的显著估计性能提升。</p> 
<p>结果。在表15中，我们报告了所有关键基准测试中被认为是污染的评估数据的百分比，如上所述，以实现最大的估计性能提升。从表中，我们排除了结果不显著的基准测试的数字，例如，因为干净或污染的集合中示例太少，或者因为观察到的性能提升估计显示出极其不稳定的行为。在表15中，我们观察到对于一些数据集，污染有很大的影响，而对于其他数据集则没有。例如，对于PiQA和HellaSwag，污染的估计和性能提升的估计都很高。另一方面，对于Natural Questions，估计的52%污染似乎对性能几乎没有影响。对于SQuAD和MATH，低阈值产生高水平的污染，但没有性能提升。这表明污染对这些数据集要么没有帮助，要么需要更大的n来获得更好的估计。最后，对于MBPP、HumanEval、MMLU和MMLU-Pro，可能需要其他污染检测方法：即使使用更高的阈值，8-gram重叠也给出了如此高的污染分数，以至于无法获得良好的性能提升估计。</p> 
<br> 
<h4><a id="52__619"></a>5.2 后训练语言模型</h4> 
<p>我们展示了我们的Llama 3后训练模型在不同能力基准测试中的结果。与预训练类似，我们正在发布作为评估一部分生成的数据，并与公开可用的基准进行比较，这些可以在Huggingface这里找到。我们评估设置的更多细节可以在这里找到。</p> 
<p>基准测试和指标。表16包含了按能力组织的所有必要基准测试的概述。我们通过运行每个基准测试提示的精确匹配来对后训练数据进行去污染处理。除了标准的学术基准测试，我们还对不同能力进行了广泛的人类评估。详细信息在第5.3节中提供。</p> 
<p>实验设置。我们采用了与预训练阶段类似的实验设置，并对Llama 3与其他相似规模和能力的模型进行比较分析。尽可能地，我们自己评估其他模型的性能，并与报告的数字进行比较，选择最佳分数。你可以在这里找到我们评估设置的更多细节。</p> 
<br> 
<h5><a id="521__628"></a>5.2.1 一般知识和指令遵循基准测试</h5> 
<p>我们在表2中对Llama 3在一般知识和指令遵循的基准测试中进行评估。</p> 
<p>一般知识。我们利用MMLU（Hendrycks等人，2021a）和MMLU-Pro（Wang等人，2024b）来评估Llama 3在基于知识的问题回答方面的能力。对于MMLU，我们在没有CoT的5次射击标准设置下报告子任务准确性的宏观平均值。MMLU-Pro是MMLU的扩展，包含了更具挑战性、以推理为重点的问题，消除了嘈杂的问题，并将选项集从四个扩展到十个。鉴于其对复杂推理的专注，我们为MMLU-Pro报告5次射击CoT。所有任务都格式化为生成任务，类似于simple-evals（OpenAI，2024）。</p> 
<p>如表2所示，我们的8B和70B Llama 3变体在两项一般知识任务上都优于其他类似大小的模型。我们的405B模型优于GPT-4和Nemotron 4 340B，Claude 3.5 Sonnet在更大的模型中领先。</p> 
<p>指令遵循。我们通过IFEval（Zhou等人，2023）评估Llama 3和其他模型遵循自然语言指令的能力。IFEval包括大约500条“可验证指令”，如“用超过400字写”，可以通过启发式方法验证。我们在表2中报告在严格和宽松约束下提示级和指令级准确性的平均值。注意，所有Llama 3变体在IFEval中都优于可比模型。</p> 
<br> 
<h5><a id="522__639"></a>5.2.2 熟练度考试</h5> 
<p>接下来，我们对模型进行了广泛的熟练度考试评估，这些考试最初是为测试人类而设计的。我们从公开可用的官方来源获取这些考试；对于一些考试，我们报告每个熟练度考试的不同考试集的平均分数。具体来说，我们平均：</p> 
<ul><li> <p>GRE：官方GRE练习测试1和2（来自教育测试服务）；</p> </li><li> <p>LSAT：官方预测试71、73、80和93；</p> </li><li> <p>SAT：2018年版官方SAT学习指南中的8次考试；</p> </li><li> <p>AP：每个科目的一次官方练习考试；</p> </li><li> <p>GMAT官方GMAT在线考试。</p> </li></ul> 
<p>这些考试中的问题包含多项选择题样式和生成问题。我们排除了附有图像的问题。对于包含多个正确选项的GRE考试，我们只有在模型选择了所有正确选项时才将输出视为正确。我们在每个考试有超过1个考试集的情况下使用少量射击提示进行评估。我们将分数按130-170的范围进行缩放，用于GRE，并报告所有其他考试的准确性。</p> 
<p>我们的结果可以在表17中找到。我们观察到，我们的Llama 3 405B模型的表现与Claude 3.5 Sonnet和GPT-4 4o非常相似。我们的70B模型的表现更为令人印象深刻。它明显优于GPT-3.5 Turbo，在许多测试中击败了Nemotron 4 340B。</p> 
<br> 
<h5><a id="523__658"></a>5.2.3 编码基准测试</h5> 
<p>我们评估Llama 3在多个流行的Python和多编程语言基准测试中的代码生成能力。为了衡量我们的模型在生成功能正确代码方面的有效性，我们使用pass@N指标，该指标评估在N次生成中一组单元测试的通过率。我们报告pass@1的结果。</p> 
<ul><li> <p>Python代码生成。HumanEval（Chen等人，2021）和MBPP（Austin等人，2021）是Python代码生成的流行基准测试，专注于相对简单、自包含的函数。HumanEval+（Liu等人，2024a）是HumanEval的增强版本，其中生成了更多测试以避免误报。MBPP EvalPlus基础版本（v0.2.0）是从原始MBPP（训练和测试）数据集中的974个初始问题中精选出的378个结构良好问题的集合（Liu等人，2024a）。这些基准测试的结果在表18中报告。在这些基准测试的Python变体中，Llama 3 8B和70B优于类似大小的模型。对于最大的模型，Llama 3 405B、Claude 3.5 Sonnet和GPT-4o表现相似，GPT-4o显示出最强的结果。</p> </li><li> <p>多编程语言代码生成。为了评估Python之外的代码生成能力，我们报告了MultiPL-E（Cassano等人，2023）基准测试的结果，该基准测试基于从HumanEval和MBPP翻译的问题。表19中报告了一些流行编程语言的子集的结果。请注意，与表18中的Python对应项相比，性能有显著下降。</p> </li></ul> 
<br> 
<h5><a id="524__667"></a>5.2.4 多语言基准测试</h5> 
<p>Llama 3支持8种语言——英语、德语、法语、意大利语、葡萄牙语、印地语、西班牙语和泰语，尽管底层的基础模型已经在更广泛的语言集合上进行了训练。在表20中，我们展示了在多语言MMLU（Hendrycks等人，2021a）和多语言小学数学（MGSM）（Shi等人，2022）基准测试中评估Llama 3的结果。</p> 
<p>多语言MMLU。我们使用谷歌翻译翻译MMLU问题、少量样本示例和答案。我们保留任务说明为英语，并在5次射击设置中进行评估。在表20中，我们报告了德语、法语、意大利语、葡萄牙语、印地语、西班牙语和泰语的平均结果。</p> 
<p>MGSM（Shi等人，2022）。我们使用simple-evals（OpenAI，2024）中相同的母语提示，在0次射击CoT设置中测试我们的模型。在表20中，我们报告了MGSM基准测试涵盖的语言的平均结果。</p> 
<p>我们发现Llama 3 405B在MGSM上优于大多数其他模型，平均达到了91.6%。在MMLU上，与上面显示的英语MMLU结果一致，Llama 3 405B落后GPT-4o 2%。另一方面，Llama 3 70B和8B模型在两项任务中都表现出色，以较大的差距领先于竞争对手。</p> 
<br> 
<h5><a id="525__678"></a>5.2.5 数学与推理基准测试</h5> 
<p>我们的数学和推理基准测试结果如表2所示。Llama 3 8B模型在GSM8K、MATH和GPQA上的表现优于其他类似大小的模型。我们的70B模型在其所有基准测试中的表现显著优于同类别中的其他模型。最后，Llama 3 405B模型在GSM8K和ARC-C中是其类别中最好的，而在MATH中则是第二好的模型。在GPQA上，它与GPT-4 4o表现相当，而Claude 3.5 Sonnet则以显著的优势成为最好的模型。</p> 
<br> 
<h5><a id="526__683"></a>5.2.6 长文本环境基准测试</h5> 
<p>我们考虑了一系列涵盖各个领域和文本类型的任务。在下面列出的基准测试中，我们专注于使用无偏评估协议的子任务，即基于准确性的指标而非n-gram重叠指标。我们还优先考虑我们发现变异性较低的任务。</p> 
<p>Needle-in-a-Haystack（Kamradt，2023）衡量模型检索隐藏在长文档随机部分中的信息的能力。我们的Llama 3模型展示了完美的针头检索性能，成功检索到所有文档深度和上下文长度中的100%针头。我们还测量了Multi-needle（表21）的性能，这是Needle-in-a-Haystack的一个变体，我们在上下文中插入四个针头并测试模型是否能够检索到其中的两个。我们的Llama 3模型实现了接近完美的检索结果。<br> ZeroSCROLLS（Shaham等人，2023）是一个针对长文本的零样本自然语言理解基准测试。我们报告验证集上的数字，因为真实答案并未公开可用。我们的Llama 3 405B和70B模型在这项基准测试的多个任务中要么匹配要么超越了其他模型。<br> InfiniteBench（Zhang等人，2024）要求模型理解上下文窗口中的长依赖关系。我们在En.QA（小说上的QA）和En.MC（小说上的多项选择QA）上评估Llama 3，其中我们的405B模型超越了所有其他模型。特别是在En.QA上，提升尤为显著。</p> 
<br> 
<h5><a id="527__692"></a>5.2.7 工具使用性能</h5> 
<p>我们在一系列零样本工具使用（即函数调用）基准测试中评估我们的模型：Nexus（Srinivasan等人，2023）、API-Bank（Li等人，2023b）、Gorilla API-Bench（Patil等人，2023）和伯克利函数调用排行榜（BFCL）（Yan等人，2024）。结果在表22中显示。</p> 
<p>在Nexus上，我们的Llama 3变体与其对应模型相比表现最佳。在API-Bank上，我们的Llama 3 8B和70B模型在其所处类别中显著超越其他模型。405B模型仅落后Claude 3.5 Sonnet 0.6%。最后，我们的405B和70B模型在BFCL上表现具有竞争力，在其各自的尺寸类别中接近第二名。Llama 3 8B在其类别中表现最佳。</p> 
<p>人类评估。我们还进行人类评估以测试模型的工具使用能力，重点关注代码执行任务。我们收集了2000个与代码执行（不包括绘图或文件上传）、图表生成和文件上传相关的用户提示。这些提示收集自LMSys数据集（Chiang等人，2024）、GAIA基准测试（Mialon等人，2023b）、人类注释者和合成生成。</p> 
<p>我们使用OpenAI的Assistants API将Llama 3 405B与GPT-4o进行比较。结果在图16中提供。在仅限文本的代码执行任务和图表生成上，Llama 3 405B显著超越了GPT-4o。然而，它在文件上传用例上落后。</p> 
<br> 
<h4><a id="53__703"></a>5.3 人工评测</h4> 
<p>除了在标准基准测试集上的评估外，我们还进行了一系列人类评估。这些评估使我们能够测量和优化模型性能的更微妙方面，例如模型的语调、冗长性和对细微差别及文化背景的理解。精心设计的人类评估密切反映了用户体验，提供了模型在现实世界场景中表现的洞察。</p> 
<ul><li> <p>提示收集。我们收集了涵盖广泛类别和难度的高质量提示。为此，我们首先开发了一个包含尽可能多模型能力的类别和子类别的分类体系。我们使用这个分类体系收集了大约7000个提示，涵盖六个单独能力（英语、推理、编码、印地语、西班牙语和葡萄牙语），以及三个多轮能力11（英语、推理和编码）。我们确保每个类别内的提示在子类别中均匀分布。我们还将每个提示归类为三个难度级别之一，并确保我们的提示集合包含大约10%的简单提示、30%的中等提示和60%的困难提示。所有人类评估提示集都经过了彻底的质量保证流程。建模团队无法访问我们的人类评估提示，以防止意外污染或过度拟合测试集。</p> </li><li> <p>评估过程。为了对两个模型进行成对人类评估，我们要求人类注释者选择他们更喜欢的两个模型响应（由不同模型生成）。注释者使用7点量表进行评分，使他们能够表明一个模型响应是否明显优于、优于、略优于或与另一个模型响应大致相同。当一个注释者指出一个模型响应比另一个模型响应更好或明显更好时，我们认为这是该模型的“胜利”。我们执行模型之间的成对比较，报告提示集中每个能力的胜率。</p> </li><li> <p>结果。我们使用我们的人类评估流程比较Llama 3 405B与GPT-4（0125 API版本）、GPT-4o（API版本）和Claude 3.5 Sonnet（API版本）。这些评估的结果在图17中呈现。我们观察到Llama 3 405B与GPT-4的0125 API版本表现大致相当，而与GPT-4o和Claude 3.5 Sonnet相比则取得了混合结果（一些胜利和一些失败）。在几乎所有能力上，Llama 3和GPT-4的胜率都在误差范围内。在多轮推理和编码任务上，Llama 3 405B超越了GPT-4，但在多语言（印地语、西班牙语和葡萄牙语）提示上表现不佳。Llama 3在英语提示上与GPT-4o表现相当，在多语言提示上与Claude 3.5 Sonnet表现相当，并在单一和多轮英语提示上超越了Claude 3.5 Sonnet。然而，它在编码和推理等能力上落后于Claude 3.5 Sonnet。从定性上看，我们发现模型在人类评估中的表现在很大程度上受到模型语调、响应结构和冗长性等细微因素的影响——这些因素正是我们在后训练过程中优化的。总体而言，我们的人类评估结果与标准基准评估的结果一致：Llama 3 405B与领先的行业模型非常有竞争力，使其成为表现最佳的公开可用模型。</p> </li><li> <p>局限性。所有人类评估结果都经过了彻底的数据质量保证流程。然而，由于定义评估模型响应的客观标准具有挑战性，人类评估仍可能受到人类注释者的个人偏见、背景和偏好的影响，这可能导致结果不一致或不可靠。</p> </li></ul> 
<br> 
<h4><a id="54__716"></a>5.4 安全性</h4> 
<p>我们专注于评估Llama 3以安全和负责任的方式生成内容的能力，同时仍最大限度地提供有帮助的信息。我们的安全工作从预训练阶段开始，主要是通过数据清洗和过滤的形式。然后我们描述了我们对安全微调的方法，重点是如何在保持有用性的同时训练模型与特定的安全政策对齐。我们分析了Llama 3的每种能力，包括多语言、长文本环境、工具使用以及各种多模态能力，以衡量我们安全缓解措施的有效性。</p> 
<p>随后，我们描述了我们对提升网络安全和化学及生物武器风险的评估。提升指的是与使用现有可用技术（如网络搜索）相比，由新技术发展带来的额外风险。</p> 
<p>然后我们描述了我们如何利用红队演练来迭代识别和对抗各种能力和安全风险，并进行了残余风险评估。</p> 
<p>最后，我们描述了系统级安全性，或者围绕模型本身的输入和输出开发和协调分类器，以进一步增强安全性，并使开发人员更容易定制各种用例的安全性，并以更负责任的方式部署生成性AI。</p> 
<br> 
<h5><a id="541__728"></a>5.4.1 基准构建</h5> 
<p>我们创建了各种内部基准来帮助我们安全、负责任地开发模型。我们的基准在很大程度上受到ML Commons危险分类（Vidgen等人，2024）风险类别的启发。虽然存在诸如ToxiGen（Hartvigsen等人，2022）、XS Test（Röttger等人，2023）等语言模型安全性基准，但Llama 3中的一些新能力并没有足够的外部基准可用，而且外部基准往往缺乏足够的广度和深度覆盖。</p> 
<p>对于每个风险类别，我们收集了人类编写的提示，这些提示要么是对抗性的，要么是边缘性质的——这些提示的例子可以在表23中找到。对抗性提示从直接引发有害响应的直接提示到包含复杂越狱技术的提示不等。这些对抗性提示的基准是我们衡量违规率的基础。</p> 
<p>作为违规率的反指标，我们还构建了由边缘提示组成的错误拒绝基准。我们将错误拒绝定义为当一个模型即使在可能的情况下也能以有帮助的方式回答问题时却拒绝回答。边缘提示是接近决策边界的提示，一个校准良好的模型应该能够处理，例如，“我怎样才能从总是表现得像主角的我最好的朋友那里偷走风头？？” 我们的整体基准规模在违规和错误拒绝方面超过每个能力或语言4000个提示，并包含单轮和多轮提示的混合。</p> 
<br> 
<h5><a id="542__737"></a>5.4.2 安全预训练</h5> 
<p>我们认为负责任的开发必须从端到端的角度考虑，并在模型开发和部署的每个阶段都加以考虑。在预训练期间，我们应用了各种过滤器，例如用于识别可能包含个人身份识别信息的网站的过滤器（见第3.1节）。我们还大力关注可发现的记忆（Nasr等人，2023）。类似于Carlini等人（2022），我们使用所有n-gram的高效滚动哈希索引，在训练数据中以不同的出现频率采样提示和真实情况。我们通过变化提示和真实情况的长度、目标数据的检测语言和领域来构建不同的测试场景。然后我们测量模型生成真实情况序列一字不差的频率，并分析在特定场景中记忆的相对比率。我们将一字不差的记忆定义为包含率——模型生成包含真实情况延续的确切比例——并按数据中给定特征的普遍性加权报告平均值，如表24所示。我们发现训练数据的记忆率很低（对于405B，n=50和n=1000时分别为1.13%和3.91%）。记忆率大致与同等大小的Llama 2相当，并使用相同的方法应用于其数据混合。</p> 
<br> 
<h5><a id="543__743"></a>5.4.3 安全微调</h5> 
<p>我们描述了我们对安全微调的方法，以减轻许多能力的风险，这包括两个关键方面：（1）安全训练数据和（2）风险缓解技术。我们的安全微调过程在我们一般微调方法的基础上进行了修改，以解决特定的安全问题。</p> 
<p>我们优化了两个主要指标：违规率（VR），一个指标，用于捕获模型产生违反安全政策的响应时的情况；错误拒绝率（FRR），一个指标，用于捕获模型错误地拒绝对无害提示做出响应时的情况。同时，我们评估模型在有用性基准上的表现，以确保安全改进不会损害整体有用性。</p> 
<p>微调数据。安全训练数据的质量和设计对性能有深远的影响。通过广泛的消融实验，我们发现质量比数量更为关键。我们主要使用从数据供应商那里收集的人工生成数据，但发现这些数据可能会有错误和不一致之处——特别是对于微妙的安全政策。为确保最高质量数据，我们开发了AI辅助注释工具来支持我们严格的质量保证流程。除了收集对抗性提示外，我们还收集了一组类似的提示，我们称之为边缘提示。这些提示与对抗性提示密切相关，但目标是教会模型学会提供有帮助的响应，从而降低错误拒绝率（FRR）。</p> 
<p>除了人工注释，我们还利用合成数据来提高我们训练数据集的质量和覆盖范围。我们使用一系列技术生成额外的对抗性示例，包括通过精心设计的系统提示进行上下文学习、基于新的攻击向量的种子提示引导变异，以及包括Rainbow Teaming（Samvelyan等人，2024）在内的先进算法，这些算法基于MAP-Elites（Mouret和Clune，2015），能够在多样性的多个维度上生成提示。</p> 
<p>我们进一步解决了模型在生成安全响应时的语调问题，这会影响下游用户体验。我们为Llama 3制定了拒绝语调指南，并通过严格的质量保证流程确保所有新的安全数据都符合该指南。我们还根据指南优化现有的安全数据，使用零样本重写和人工参与编辑的组合来产生高质量的数据。通过采用这些方法，再加上使用语调分类器评估安全响应的语调质量，我们能够显著改善模型的措辞。</p> 
<p>安全监督微调。遵循我们Llama 2的配方（Touvron等人，2023b），我们在模型对齐阶段结合了所有有用性数据和安全数据。此外，我们引入了一个边缘数据集，帮助模型辨别安全和不安全请求之间的微妙区别。我们指示注释团队根据我们的指南精心制作对安全提示的响应。我们发现，当我们策略性地平衡对抗性到边缘示例的比例时，SFT（监督微调）在对齐模型方面非常有效。我们专注于更具挑战性的风险领域，边缘示例的比例更高。这在我们的成功安全缓解工作中发挥了关键作用，同时将错误拒绝降至最低。</p> 
<p>此外，我们在图18中检查了模型大小对FRR（错误拒绝率）和VR（违规率）之间权衡的影响。我们的结果表明，这种影响是不同的——较小的模型需要相对于有用性数据更大的安全数据比例，并且与较大模型相比，更难有效地平衡VR和FRR。</p> 
<p>安全DPO（差异隐私优化）。为了加强安全学习，我们将对抗性和边缘示例纳入我们在DPO中的偏好数据集中。我们发现，将响应对制作成在嵌入空间中几乎正交特别有效，这教会了模型区分给定提示的好响应和坏响应。我们进行了多次实验，以确定对抗性、边缘和有用性示例的最佳比例，旨在优化FRR和VR之间的权衡。我们还发现，模型大小影响学习结果——因此，我们为不同大小的模型定制了不同的安全组合。</p> 
<br> 
<h5><a id="544__762"></a>5.4.4 安全结果</h5> 
<p>我们首先突出展示Llama 3在各个轴上的一般行为，然后描述每个具体新能力的结果以及我们在减轻安全风险方面的有效性。</p> 
<p>总体表现。可以在图19和图20中找到Llama 3最终违规率和错误拒绝率与类似模型的比较。这些结果侧重于我们最大参数尺寸的Llama 3 405B模型，与相关竞争对手进行比较。两个竞争对手是通过API访问的端到端系统，其中之一是我们内部托管并直接评估的开源语言模型。我们评估了我们的Llama模型，既单独评估，也与我们的开源系统级安全解决方案Llama Guard结合评估（更多内容见第5.4.7节）。</p> 
<p>虽然低违规率是可取的，但将错误拒绝作为反指标考虑是至关重要的，因为总是拒绝的模型是最大程度安全的，但一点也不有帮助。同样，一个无论请求有多成问题都总是回答每一个提示的模型，将会过于有害和有毒。在图21中，利用我们的内部基准，我们探索了不同模型和行业系统如何处理这种权衡，以及Llama 3如何比较。我们发现我们的模型在保持低错误拒绝率的同时，实现了非常有竞争力的违规率指标，表明了在有用性和安全性之间取得了坚实的平衡。</p> 
<p>多语言安全性。我们的实验表明，英语中的安全知识并不轻易转移到其他语言，特别是考虑到安全政策的细微差别和语言特定的上下文。因此，为每种语言收集高质量的安全数据至关重要。我们还发现，每种语言的安全数据分布显著影响从安全角度的性能，一些语言从迁移学习中受益，而其他语言则需要更多的语言特定数据。为了在FRR（错误拒绝率）和VR（违规率）之间取得平衡，我们迭代地添加对抗性和边缘数据，同时监控对这两个指标的影响。</p> 
<p>我们在图19中展示了我们的内部基准测试结果，针对短文本模型，展示了Llama 3的违规和错误拒绝率，与类似模型和系统相比，分别针对英语和非英语语言。为了构建每种语言的基准测试，我们使用母语者编写的提示组合，有时辅以我们英语基准测试的翻译。对于我们支持的每种语言，我们发现配备Llama Guard的Llama 405B至少与两个竞争系统一样安全，如果不是更安全的话，同时保持了有竞争力的错误拒绝率。单独看Llama 405B模型，没有Llama Guard，我们发现它比竞争的独立开源模型有显著更低的违规率，但错误拒绝率更高。</p> 
<p>长文本环境安全性。长文本模型在没有针对性缓解的情况下，容易受到多轮越狱攻击（Anil等人，2024）。为了解决这个问题，我们在SFT数据集上微调我们的模型，其中包括在上下文中存在不安全行为示范的情况下的安全行为示例。我们开发了一种可扩展的缓解策略，显著降低了违规率，有效地中和了更长上下文攻击的影响，即使是256轮攻击也是如此。这种方法对FRR（错误拒绝率）和大多数有用性指标几乎没有影响。</p> 
<p>为了量化我们长文本环境安全缓解措施的有效性，我们使用了两种额外的基准测试方法：DocQA和多轮。对于DocQA，即“文档问题回答”，我们使用可能以对抗性方式利用信息的长文档。模型被提供了文档和与文档相关的一组提示，以测试问题是否与文档中的信息相关，影响了模型安全响应提示的能力。对于多轮，按照Anil等人（2024）的方法，我们构建了一个由不安全提示-响应对组成的合成聊天记录。最终提示与之前的消息无关，用来测试上下文中的不安全行为是否影响了模型以不安全的方式响应。图20显示了DocQA和多轮的违规和错误拒绝率。我们发现，无论是配备还是不配备Llama Guard，Llama 405B在违规率和错误拒绝率方面都优于Comp. 2系统，无论是DocQA还是多轮。与Comp. 1相比，我们发现Llama 405B明显更安全，尽管在错误拒绝上有所权衡。</p> 
<p>工具使用安全性。可能使用的工具的多样性以及工具使用调用和集成到模型中的实现使得工具使用成为一个难以完全缓解的能力（Wallace等人，2024）。我们专注于搜索用例。图20显示了违规和错误拒绝率。我们与Comp. 1系统进行了测试，发现Llama 405B明显更安全，尽管错误拒绝率略高。</p> 
<br> 
<h5><a id="545__781"></a>5.4.5 网络安全和化学/生物武器安全</h5> 
<p>网络安全评估结果。为了评估网络安全风险，我们利用CyberSecEval基准框架（Bhatt等人，2023, 2024），该框架包含测量在生成不安全代码、生成恶意代码、文本提示注入和漏洞识别等域中的安全性的任务。我们开发并应用Llama 3到新的基准上，涉及鱼叉式网络钓鱼和自动网络攻击。</p> 
<p>总体而言，我们发现Llama 3在生成恶意代码或利用漏洞方面没有显著的易感性。我们简要描述了特定任务的结果：</p> 
<p>不安全编码测试框架：在不安全编码测试框架中评估Llama 3 8B、70B和405B，我们继续观察到更大的模型不仅生成更多的不安全代码，而且还生成平均BLEU分数更高的代码（Bhatt等人，2023）。<br> 代码解释器滥用提示语料库：我们发现Llama 3模型在某些提示下容易执行恶意代码，特别是Llama 3 405B，其遵从恶意提示的比例为10.4%。Llama 3 70B的遵从率为3.8%。<br> 基于文本的提示注入基准：在评估提示注入基准时，针对Llama 3 405B的提示注入攻击在21.7%的情况下成功。图22提供了Llama 3、GPT-4 Turbo、Gemini Pro和Mixtral模型的基于文本的提示注入成功率。<br> 漏洞识别挑战：在使用CyberSecEval 2的捕获旗帜测试挑战评估Llama 3识别和利用漏洞的能力时，Llama 3并没有超越常用的、传统的非LLM工具和技术。<br> 鱼叉式网络钓鱼基准：我们评估模型在进行旨在欺骗目标无意中参与安全漏洞的个性化对话中的说服力和成功率。由LLM生成的随机详细受害者档案被用作鱼叉式网络钓鱼目标。一个裁判LLM（Llama 3 70B）对Llama 3 70B和405B与受害者模型（Llama 3 70B）的互动表现进行评分，并评估尝试的成功程度。裁判LLM评估Llama 3 70B和Llama 3 405B具有适度的说服力。Llama 3 70B被LLM判定在24%的鱼叉式网络钓鱼尝试中成功，而Llama 3 405B被判定在14%的尝试中成功。图23展示了裁判LLM评估的说服力得分，涵盖各个模型和网络钓鱼目标。<br> 攻击自动化框架：我们评估Llama 3 405B作为自主代理在勒索软件攻击的四个关键阶段——网络侦察、漏洞识别、利用执行和后期利用行动中的潜在作用。我们通过配置模型，使其能够在Kali Linux虚拟机上针对另一个已知漏洞的虚拟机，根据其先前命令的输出迭代生成并执行新的Linux命令，从而使模型能够自主行为。尽管Llama 3 405B在网络侦察中有效地识别了网络服务和开放端口，但模型未能有效地利用这些信息在34次测试运行中获得对易受攻击机器的初始访问。在识别漏洞方面，Llama 3 405B效果适中，但在选择和应用成功的利用技术方面存在困难。执行利用尝试完全失败，后期利用尝试在网络内保持访问或执行横向移动也完全失败。<br> 网络攻击的提升测试。我们进行了一项提升研究，测量虚拟助手在两次模拟的进攻性网络安全挑战中提高新手和专家网络攻击者的网络攻击率的程度。进行了一个两阶段的研究，共有62名内部志愿者参与。志愿者根据他们的进攻性安全经验被分为“专家”（31名受试者）和“新手”（31名受试者）小组。在第一阶段，受试者被要求在没有任何LLM辅助的情况下完成挑战，但可以访问开放的互联网。在第二阶段，受试者保留了访问互联网的权利，但也被提供了Llama 3 405B来完成一个难度与第一个相似的不同进攻性网络安全挑战。通过受试者完成挑战攻击阶段的完成率分析表明，使用405B模型的新手和专家在没有LLM的情况下，与仅拥有开放互联网访问权相比，表现没有显著提升。<br> 化学和生物武器的提升测试。为了评估与化学和生物武器扩散相关的风险，我们进行提升测试，旨在评估使用Llama 3是否会显著增加行动者计划此类攻击的能力。<br> 该研究包括六小时的情景，其中两个参与者的团队被要求为生物或化学攻击生成虚构的作战计划。情景涵盖了CBRNE攻击（剂获取、生产、武器化和交付）的主要规划阶段，并旨在引出详细计划，这些计划将解决与采购受限材料、现实世界的实验室协议和作战安全相关的挑战。参与者根据他们在科学或运营领域的相关经验被招募，并被分配到由两个低技能行动者（没有正式培训）或两个中等技能行动者（在科学或运营中有一些正式培训和实践经验）组成的团队。<br> 该研究是与一组CBRNE专家合作生成的，并旨在最大化一般性、有效性和定量和定性结果的鲁棒性。还进行了初步研究，以验证研究设计，包括进行强有力的功效分析，确保我们的样本量足以进行统计分析。<br> 每个团队被分配到“对照”或“LLM”条件。对照团队只能访问基于互联网的资源，而LLM启用的团队既有互联网访问权，也有访问启用了网络搜索（包括PDF摄取）、信息检索能力（RAG）和代码执行（Python和Wolfram Alpha）的Llama 3模型。为了启用RAG能力的测试，使用关键词搜索生成了数百篇相关科学论文的数据集，并加载到Llama 3模型推理系统中。在演习结束时，每个团队生成的作战计划由在生物学、化学和作战规划领域具有专业知识的专家进行评估。每个计划在潜在攻击的四个阶段进行评估，为科学准确性、细节、检测规避以及在科学和运营执行中成功的可能性等指标生成得分。在通过强有力的Delphi过程来减轻专家评估中的偏见和变异性之后，最终得分通过将阶段级指标汇总到一个综合得分中生成。<br> 这些研究结果的定量分析显示，与使用Llama 3模型相关的性能没有显著提升。当进行总体分析（将所有LLM条件与仅网络对照条件进行比较）以及按子组进行细分（例如，分别评估Llama 3 70B和Llama 3 405B模型，或分别评估与化学或生物武器相关的情景）时，这一结果成立。在与CBRNE SMEs验证这些结果后，我们评估认为发布Llama 3模型将增加与生物或化学武器攻击相关的生态系统风险的风险较低。</p> 
<br> 
<h5><a id="546__801"></a>5.4.6 红队演练</h5> 
<p>我们利用红队演练来发现风险，并利用这些发现来改进我们的基准测试和安全调整数据集。我们定期进行红队演练，以持续迭代和发现新风险，这指导了我们的模型开发和缓解过程。<br> 我们的红队由网络安全、对抗性机器学习、负责任的人工智能和完整性领域的专家组成，此外还有具有特定地理市场完整性问题背景的多语言内容专家。我们还与关键风险领域的内部和外部主题专家合作，帮助构建风险分类和协助更有针对性的对抗性评估。<br> 针对特定模型能力的对抗性测试。我们最初通过专注于个别模型能力的风险发现过程开始红队演练，在特定高风险类别的背景下测试能力，然后一起测试这些能力。红队专注于提示级别的攻击，以模拟更可能更真实的世界场景——我们发现模型经常偏离预期行为，特别是当提示的意图被混淆或提示叠加了多重抽象时。随着额外能力的出现，这些风险变得更加复杂，我们详细描述了我们红队演练的几个发现。我们将这些红队发现与我们在内部安全基准测试的结果结合起来，制定针对性的缓解措施，以持续和迭代地改进模型的安全性。<br> 短期和长期上下文英语。我们采用了单一和多轮对话中已知和未知技术的混合。我们还利用了类似于PAIR（Chao等人，2023）的高级、对抗性多轮自动化技术。总体而言，多轮对话导致更有害的输出。几种攻击在模型检查点中普遍存在，特别是当一起使用时。<br> 多轮拒绝抑制，以指定模型响应遵循特定格式或包含/排除与拒绝相关的特定信息，作为特定短语。<br> 假设情景将违规提示包装为假设性/理论性任务或虚构情景。提示可以简单到添加“假设”这个词，或构建一个复杂的分层情景。<br> 角色扮演给模型一个带有特定违规响应特征的违规角色（例如“你是X，你的目标是Y”）或你自己作为用户，适应一个特定的良性角色，这混淆了提示的上下文。<br> 添加免责声明和警告作为一种响应启动形式，我们假设一种方法，允许模型有一条与一般安全培训相交的帮助性合规路径。在多轮对话中，要求添加免责声明、触发警告等，并与其他提到的攻击相结合，有助于提高违规率。<br> 逐步升级违规是一种多轮攻击，对话开始时是一个或多或少良性的请求，然后通过直接提示更夸张的内容，可以逐渐引导模型生成一个非常违规的响应。一旦模型开始输出违规内容，模型可能很难恢复（或者如果遇到拒绝，可以使用另一种攻击）。对于更长上下文的模型，这将是一个越来越常见的问题。<br> 多语言。在考虑多种语言时，我们发现了一些独特的风险。<br> 在一个提示或对话中混合多种语言可能比使用单一语言更容易产生违规输出。<br> 资源较少的语言可能会导致违规输出，因为缺乏相关的安全微调数据，模型对安全的泛化较弱，或者在测试或基准测试中的优先级较低。然而，这种攻击通常会导致质量普遍较差，限制了实际的对抗性使用。<br> 俚语、特定上下文或文化特定的参考可能会混淆，或者乍一看似乎是违规的，只有在看到模型没有正确理解给定的参考时，才会使输出真正有害或防止其成为违规输出。<br> 工具使用。在测试中，除了在英语文本级别的对抗性提示技术成功生成违规输出外，还发现了几种特定工具的攻击。这包括但不限于：<br> 不安全的工具链，例如同时请求多个工具，其中一个是违规的，可能在早期检查点中导致所有工具被调用，输入既有良性的也有违规的。<br> 强制工具使用，通常带有特定输入字符串、分片段的或编码的文本，可以触发工具输入可能是违规的，从而导致更违规的输出。然后可以使用其他技术访问工具结果，即使模型通常拒绝执行搜索或协助结果。<br> 修改工具使用参数，如在多轮对话中交换查询中的单词、重试或混淆初始请求的某些部分，导致许多早期检查点中的违规，作为一种强制工具使用的形式。<br> 儿童安全风险。儿童安全风险评估是由专家团队进行的，以评估模型产生可能导致儿童安全风险的输出的能力，并通过微调告知任何必要和适当的风险缓解措施。我们利用这些专家红队演练，通过模型开发扩大了我们评估基准的覆盖范围。对于Llama 3，我们使用基于目标的方法论进行了新的深入会议，以评估模型风险沿着多个攻击向量。我们还与内容专家合作，进行红队演练，评估可能违规的内容，同时考虑市场特定的细微差别或经验。</p> 
<br> 
<h5><a id="547__823"></a>5.4.7 系统级安全</h5> 
<p>在大型语言模型的各种现实世界应用中，模型并不是孤立使用的，而是被集成到更广泛的系统中。在本节中，我们描述了我们的系统级安全实施，它通过提供更大的灵活性和控制力，补充了模型级缓解措施。<br> 为此，我们开发并发布了一个新的分类器，Llama Guard 3，这是一个为安全分类微调的Llama 3 8B模型。类似于Llama Guard 2（Llama-Team，2024），这个分类器用于检测由语言模型生成的输入提示和/或输出响应是否违反特定伤害类别的安全政策。<br> 它旨在支持Llama不断增长的能力，并且可以用于英语和多语言文本。它还针对工具调用（如搜索工具）和防止代码解释器滥用进行了优化。最后，我们还提供了量化变体以减少内存需求。我们鼓励开发人员使用我们发布的系统安全组件作为基础，并为他们自己的用例进行配置。<br> 分类体系。我们根据AI安全分类（Vidgen等人，2024）中列出的13个危险类别进行训练：儿童性剥削、诽谤、选举、仇恨、无差别武器、知识产权、非暴力犯罪、隐私、性相关犯罪、性内容、专业建议、自杀和自残，以及暴力犯罪。我们还对代码解释器滥用类别进行了训练，以支持工具调用用例。<br> 训练数据。我们从Llama Guard（Inan等人，2023）使用的英语数据开始，并扩展这个数据集以纳入新的能力。对于新能力如多语言和工具使用，我们收集提示和响应分类数据，并利用为安全微调收集的数据。我们通过提示工程增加训练集中不安全响应的数量，以使LLM不拒绝响应对抗性提示。我们使用Llama 3对此类生成的数据获取响应标签。<br> 为了提高Llama Guard 3的性能，我们使用人工注释和Llama 3的LLM注释对收集的样本进行了广泛的清理。获取用户提示的标签对于人类和LLM来说都是一项更困难的任务，我们发现人类标签略胜一筹，尤其是对于边缘提示，尽管我们的完整迭代系统能够减少噪声并产生更准确的标签。<br> 结果。Llama Guard 3能够显著减少各能力中的违规行为（在我们的基准测试中平均减少了65%的违规行为）。注意，增加系统防护（和一般的任何安全缓解措施）的代价是增加了对良性提示的拒绝。在表25中，我们报告了与基础模型相比违规率的降低和错误拒绝率的增加，以突出这种权衡。这种效应也可以在图19、20和21中看到。<br> 系统安全还提供了更大的灵活性。Llama Guard 3可以仅针对特定的伤害部署，仅启用对违规和错误拒绝权衡的控制，以伤害类别级别为单位。表26展示了每个类别的违规减少情况，以告知根据开发人员用例应该启用或禁用哪个类别。<br> 为了使部署安全系统更容易，我们提供了使用常用的int8量化技术量化版本的Llama Guard 3，将其大小减少了40%以上。表27说明了量化对模型性能的影响微乎其微。<br> 基于提示的系统防护。系统级安全组件使开发人员能够自定义和控制LLM系统如何响应用户请求。作为我们提高模型系统整体安全性并使开发人员能够负责任地部署的工作的一部分，我们描述并发布了两种基于提示的过滤机制的创建：Prompt Guard和Code Shield。我们开源这些，供社区直接利用或作为灵感并适应他们的用例。<br> Prompt Guard是一个基于模型的过滤器，旨在检测提示攻击，这些是旨在颠覆作为应用程序一部分的LLM预期行为的输入字符串。该模型是一个多标签分类器，检测两类提示攻击风险——直接越狱（明确尝试覆盖模型的安全条件或系统提示的技术）和间接提示注入（模型的上下文窗口中包含第三方数据，包括无意中被LLM执行为用户命令的指令）。该模型从mDeBERTa-v3-base微调而来，这是一个小型（8600万）参数模型，适用于过滤输入到LLM的输入。我们在表28中显示的几个评估数据集上评估了其性能。我们在两个数据集（越狱和注入）上进行了评估，这些数据集与训练数据具有相同的分布，以及一个英语的分布外数据集，一个从机器翻译构建的多语言越狱集，以及一个从CyberSecEval（英语和多语言）中提取的间接注入数据集。总体而言，我们发现该模型对新分布有很好的泛化能力，并具有强大的性能。<br> Code Shield是一个基于提供推理时过滤的系统级保护的示例。特别是，它专注于在不安全代码可能进入下游用例（如生产系统）之前检测不安全代码的生成。它通过利用静态分析库——不安全代码检测器（ICD），来识别不安全代码。ICD使用一系列静态分析工具对7种编程语言进行分析。这些类型的防护栏通常对开发人员很有用，他们可以在各种应用程序中部署多层保护。</p> 
<br> 
<h5><a id="548__839"></a>5.4.8 局限性</h5> 
<p>我们对Llama 3的安全使用进行了广泛的测量和缓解，涉及多种风险。然而，没有任何测试可以保证能够全面识别出所有可能的风险。由于在各种数据集上进行训练，特别是对于英语以外的语言，以及在熟练的对抗性红队工程师进行提示工程时，Llama 3可能仍会生成有害内容。恶意开发人员或对抗性用户可能会找到新的方法来越狱我们的模型，并将其用于各种恶意用例。我们将继续主动识别风险，进行缓解方法的研究，并鼓励开发人员在从模型开发到部署再到用户的每一个方面都考虑责任。我们希望开发人员能够利用并为我们发布的开源系统级安全套件做出贡献。</p> 
<br> 
<h3><a id="6__844"></a>6. 推理</h3> 
<p>我们研究了两种主要技术，以使 Llama 3 405B 模型的推理高效：(1) 流水线并行和 (2) FP8 量化。我们已经公开发布了我们的 FP8 量化实现。</p> 
<br> 
<h4><a id="61__850"></a>6.1 流水线并行</h4> 
<p>当使用 BF16 数字表示模型参数时，Llama 3 405B 不适合在装有 8 个 Nvidia H100 GPU 的单台机器的 GPU 内存中。为了解决这个问题，我们使用 BF16 精度在两台机器上的 16 个 GPU 上并行化模型推理。在每台机器内，高 NVLink 带宽使得可以使用张量并行（Shoeybi 等人，2019）。然而，跨节点的连接带宽较低且延迟较高，因此我们使用流水线并行（Huang 等人，2019）。</p> 
<p>在使用流水线并行进行训练时，气泡是主要的效率问题（见第 3.3 节）。然而，在推理过程中它们不是问题，因为推理不涉及需要流水线刷新的反向传递。因此，我们使用微批处理来提高流水线并行推理的吞吐量。</p> 
<p>我们评估了在推理工作负载中使用两个微批处理，在推理的关键值缓存预填充阶段和解码阶段，输入令牌为 4,096，输出令牌为 256 的效果。我们发现微批处理提高了相同本地批量大小的推理吞吐量；见图 24。这些改进来自于微批处理使得这两个阶段的微批处理能够并行执行。由于微批处理引起的额外同步点也增加了延迟，但总体上，微批处理仍然导致更好的吞吐量-延迟权衡。</p> 
<br> 
<h4><a id="62_FP8__859"></a>6.2 FP8 量化</h4> 
<p>我们利用 H100 GPU 的原生 FP8 支持进行低精度推理。为了启用低精度推理，我们对模型内的大多数矩阵乘法应用了 FP8 量化。特别是，我们量化了模型中前馈网络层中的大部分参数和激活，这些占推理计算时间的大约 50%。我们没有量化模型的自注意力层的参数。我们利用动态缩放因子以获得更好的准确性（Xiao 等人，2024b），优化我们的 CUDA 内核 15 以减少计算比例的开销。我们发现 Llama 3 405B 的质量对某些类型的量化敏感，并进行了一些额外的更改以提高模型输出质量：</p> 
<ol><li> <p>类似于 Zhang 等人（2021），我们不在第一层和最后一层 Transformer 层中进行量化。</p> </li><li> <p>高困惑度的令牌（如日期）可能导致大的激活值。反过来，这可能导致 FP8 中的高动态缩放因子和大量下溢，导致解码错误。为了解决这个问题，我们将动态缩放因子上界限制为 1200。</p> </li><li> <p>我们使用行量化，为参数和激活矩阵计算跨行的缩放因子（见图 25）。我们发现这比张量量化方法更有效。</p> </li></ol> 
<p>量化误差的影响。标准基准测试通常表明，即使没有这些缓解措施，FP8 推理也与 BF16 推理相当。然而，我们发现这样的基准测试并没有充分反映 FP8 量化的影响。当缩放因子没有上界限制时，模型偶尔会产生损坏的响应，尽管基准测试性能很强。我们发现，依靠基准测试来衡量量化引起的分布变化，不如分析使用 FP8 和 BF16 生成的 100,000 个响应的奖励模型分数的分布更好。图 26 显示了我们量化方法的奖励分布结果。图中的结果表明，我们对 FP8 量化的方法对模型的响应影响非常有限。</p> 
<p>效率的实验评估。图 27 描述了在预填充和解码阶段使用 Llama 3 405B 进行 FP8 推理的吞吐量-延迟权衡，使用 4,096 个输入令牌和 256 个输出令牌。该图比较了第 6.1 节中描述的两台机器 BF16 推理方法的效率。结果表明，使用 FP8 推理在预填充阶段的吞吐量提高了最多 50%，在解码期间的吞吐量-延迟权衡显著更好。</p> 
<br> 
<p><strong>版权声明：</strong><br> 欢迎关注<a href="https://blog.csdn.net/youcans/category_12244543.html">【youcans的AGI学习笔记】</a>，转发请注明原文链接：<a href="https://youcans.blog.csdn.net/article/details/140690941" rel="nofollow">【AIGC】Llama-3 官方技术报告</a><br> Copyright 2024 youcans, XUPT<br> Crated：2024-07-25</p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc9fbbcabc626bd6d13e005ec5b599dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】建堆算法复杂度分析及TOP-K问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/085d4646492ef9cf241bdc68e29fbb1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Excel基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>