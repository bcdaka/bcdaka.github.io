<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android13 设置固定热点ip地址192.168.43.1 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/576c2d6fdcbbd007bb7e07b1ea3679c0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android13 设置固定热点ip地址192.168.43.1">
  <meta property="og:description" content="Android13 设置固定热点ip地址192.168.43.1 文章目录 Android13 设置固定热点ip地址192.168.43.1一、前言二、设置固定ip地址实现1、Android13 代码中的实现：添加属性写法： 2、Android11 或者更旧的代码中的实现： 三、其他1、Android 代码获连接的wifi 的 ip地址：2、获取热点的ip地址（1）adb 获取ip地址（2）Android 代码获取所有网络的ip地址和MAC地址：（3）Android 代码获取热点的 ip地址：（4）动态设置热点ip的代码？（5）热点开启流程 一、前言 Android 热点ip一般的系统都是随机生成的，地址一般是：192.168.XX.XX
如果要设置成一个固定的ip地址，就需要适配系统代码。
相关的适配代码主要都在 IpServer.java 里面。
为啥要设置固定热点ip？
一般是投屏软件需求，或者其他一些开机或者打开热点后被自动连接场景的需求。
二、设置固定ip地址实现 1、Android13 代码中的实现： release\packages\modules\Connectivity\Tethering\src\android\net\ip\IpServer.java
private boolean configureIPv4(boolean enabled) { if (VDBG) Log.d(TAG, &#34;configureIPv4(&#34; &#43; enabled &#43; &#34;)&#34;); if (enabled) { //以前的随机的ip地址 //mIpv4Address = requestIpv4Address(true /* useLastAddress */); //换成自定义的ip地址 mIpv4Address = new LinkAddress(&#34;192.168.43.1/24&#34;); } 。。。。 } 就是这么简单，设置一下开启热点前请求到的ipv4地址就可以了。
从代码大致可以看到，如果未做修改的情况这里热点的默认ip是从上一次存在的热点ip，当然第一次还是随机生成的。
添加属性写法： 如果要添加属性判断设置，后期可以动态修改，那么可以设置一下prop属性。具体修改如下：
import android.os.SystemProperties; private boolean configureIPv4(boolean enabled) { if (VDBG) Log.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-26T09:05:46+08:00">
    <meta property="article:modified_time" content="2024-02-26T09:05:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android13 设置固定热点ip地址192.168.43.1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Android13_ip192168431_0"></a>Android13 设置固定热点ip地址192.168.43.1</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Android13_ip192168431_0" rel="nofollow">Android13 设置固定热点ip地址192.168.43.1</a></li><li><ul><li><a href="#_3" rel="nofollow">一、前言</a></li><li><a href="#ip_15" rel="nofollow">二、设置固定ip地址实现</a></li><li><ul><li><a href="#1Android13__17" rel="nofollow">1、Android13 代码中的实现：</a></li><li><ul><li><ul><li><a href="#_42" rel="nofollow">添加属性写法：</a></li></ul> 
    </li></ul> 
    </li><li><a href="#2Android11__69" rel="nofollow">2、Android11 或者更旧的代码中的实现：</a></li></ul> 
   </li><li><a href="#_162" rel="nofollow">三、其他</a></li><li><ul><li><a href="#1Android_wifi__ip_164" rel="nofollow">1、Android 代码获连接的wifi 的 ip地址：</a></li><li><a href="#2ip_197" rel="nofollow">2、获取热点的ip地址</a></li><li><ul><li><a href="#1adb_ip_199" rel="nofollow">（1）adb 获取ip地址</a></li><li><a href="#2Android_ipMAC_230" rel="nofollow">（2）Android 代码获取所有网络的ip地址和MAC地址：</a></li><li><a href="#3Android__ip_294" rel="nofollow">（3）Android 代码获取热点的 ip地址：</a></li><li><a href="#4ip_333" rel="nofollow">（4）动态设置热点ip的代码？</a></li><li><a href="#5_362" rel="nofollow">（5）热点开启流程</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_3"></a>一、前言</h3> 
<p>Android 热点ip一般的系统都是随机生成的，地址一般是：192.168.XX.XX</p> 
<p>如果要设置成一个固定的ip地址，就需要适配系统代码。</p> 
<p>相关的适配代码主要都在 IpServer.java 里面。</p> 
<p>为啥要设置固定热点ip？<br> 一般是投屏软件需求，或者其他一些开机或者打开热点后被自动连接场景的需求。</p> 
<h3><a id="ip_15"></a>二、设置固定ip地址实现</h3> 
<h4><a id="1Android13__17"></a>1、Android13 代码中的实现：</h4> 
<p>release\packages\modules\Connectivity\Tethering\src\android\net\ip\IpServer.java</p> 
<pre><code>private boolean configureIPv4(boolean enabled) {
    if (VDBG) Log.d(TAG, "configureIPv4(" + enabled + ")");

    if (enabled) {
    	//以前的随机的ip地址
        //mIpv4Address = requestIpv4Address(true /* useLastAddress */);
        //换成自定义的ip地址
        mIpv4Address = new LinkAddress("192.168.43.1/24");

    }
    。。。。
}
</code></pre> 
<p>就是这么简单，设置一下开启热点前请求到的ipv4地址就可以了。</p> 
<p>从代码大致可以看到，如果未做修改的情况这里热点的默认ip是从上一次存在的热点ip，当然第一次还是随机生成的。</p> 
<h6><a id="_42"></a>添加属性写法：</h6> 
<p>如果要添加属性判断设置，后期可以动态修改，那么可以设置一下prop属性。具体修改如下：</p> 
<pre><code>import android.os.SystemProperties;

private boolean configureIPv4(boolean enabled) {
    if (VDBG) Log.d(TAG, "configureIPv4(" + enabled + ")");

    if (enabled) {
        //set hotspot addr of this constant by  liwenzhi
        boolean isRandomIp = SystemProperties.getBoolean("persist.sys.dubug.random_hostip", false);
        if (isRandomIp) {
            mIpv4Address = requestIpv4Address(true /* useLastAddress */);
        } else { //默认是固定ip
            mIpv4Address = new LinkAddress("192.168.43.1/24");
        }
    }
    。。。。
}
</code></pre> 
<h4><a id="2Android11__69"></a>2、Android11 或者更旧的代码中的实现：</h4> 
<p>release\frameworks\base\packages\Tethering\src\android\net\ip\IpServer.java</p> 
<pre><code>    private boolean configureIPv4(boolean enabled) {
        if (VDBG) Log.d(TAG, "configureIPv4(" + enabled + ")");

        if (enabled) {
        	//以前的随机的ip地址
        	//mIpv4Address = requestIpv4Address();
        	//换成自定义的ip地址
			mIpv4Address = new LinkAddress("192.168.43.1/24");
        }
    }
</code></pre> 
<p>不同版本上，代码的修改都是差不多的，只是 IpServer.java 这个类的位置有改变。</p> 
<p>3、Android13 获取热点ip的过程</p> 
<p>release\packages\modules\Connectivity\Tethering\src\android\net\ip\IpServer.java</p> 
<pre><code>private boolean configureIPv4(boolean enabled) {
    if (VDBG) Log.d(TAG, "configureIPv4(" + enabled + ")");

    if (enabled) {
        mIpv4Address = requestIpv4Address(true /* useLastAddress */);
    }
    。。。。
}

private final PrivateAddressCoordinator mPrivateAddressCoordinator;

private LinkAddress requestIpv4Address(final boolean useLastAddress) {
	if (mStaticIpv4ServerAddr != null) return mStaticIpv4ServerAddr;

	if (shouldNotConfigureBluetoothInterface()) return new LinkAddress(BLUETOOTH_IFACE_ADDR);
	//在其他对象中获取
	return mPrivateAddressCoordinator.requestDownstreamAddress(this, useLastAddress);
}
</code></pre> 
<p>所以具体实现是在 PrivateAddressCoordinator 对象的 requestDownstreamAddress 方法中。</p> 
<p>release\packages\modules\Connectivity\Tethering\src\com\android\networkstack\tethering\PrivateAddressCoordinator.java</p> 
<pre><code>    /**
     * Pick a random available address and mark its prefix as in use for the provided IpServer,
     * returns null if there is no available address.
     */
    @Nullable
    public LinkAddress requestDownstreamAddress(final IpServer ipServer, boolean useLastAddress) {
        if (mConfig.shouldEnableWifiP2pDedicatedIp()
                &amp;&amp; ipServer.interfaceType() == TETHERING_WIFI_P2P) {
            return new LinkAddress(LEGACY_WIFI_P2P_IFACE_ADDRESS);
        }

        final LinkAddress cachedAddress = mCachedAddresses.get(ipServer.interfaceType());
        if (useLastAddress &amp;&amp; cachedAddress != null
                &amp;&amp; !isConflictWithUpstream(asIpPrefix(cachedAddress))) {
            mDownstreams.add(ipServer);
            return cachedAddress;
        }

        for (IpPrefix prefixRange : mTetheringPrefixes) {
            final LinkAddress newAddress = chooseDownstreamAddress(prefixRange);
            if (newAddress != null) {
                mDownstreams.add(ipServer);
                mCachedAddresses.put(ipServer.interfaceType(), newAddress);
                return newAddress;
            }
        }

        // No available address.
        return null;
    }
</code></pre> 
<p>有兴趣的可以自己在源码中查看，Android11 和Android13 的具体获取过程有很大的差异。</p> 
<p>上面就是本文的主要内容，下面是其他相关内容，有兴趣可以继续看看。</p> 
<h3><a id="_162"></a>三、其他</h3> 
<h4><a id="1Android_wifi__ip_164"></a>1、Android 代码获连接的wifi 的 ip地址：</h4> 
<pre><code>public static String getWifiIpAddress(Context context) {
        WifiManager wifiManager = (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        
        if (!wifiManager.isWifiEnabled()) {
            // Wi-Fi is not enabled, return null or handle the case accordingly
            return null;
        }
        
        int ipAddress = wifiManager.getConnectionInfo().getIpAddress();
        byte[] bytes = new byte[4];
        for (int i = 0; i &lt; 4; ++i) {
            bytes[i] = (byte)(ipAddress &gt;&gt; ((3 - i) * 8));
        }
        
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append((b &amp; 0xFF)).append(".");
        }
        sb.deleteCharAt(sb.length() - 1);
        
        return sb.toString();
    }
</code></pre> 
<p>要调用这段代码并获得热点的 IP 地址，只需传入一个有效的 <code>Context</code> 对象作为参数，然后调用 <code>getWifiIpAddress()</code> 方法即可。</p> 
<h4><a id="2ip_197"></a>2、获取热点的ip地址</h4> 
<h5><a id="1adb_ip_199"></a>（1）adb 获取ip地址</h5> 
<p>adb shell ifconfig</p> 
<pre><code>console:/ # ifconfig                                                           

wlan0     Link encap:Ethernet  HWaddr 38:64:07:88:6a:f6  Driver usb
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0 
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 
          collisions:0 txqueuelen:3000 
          RX bytes:0 TX bytes:0 
。。。

ap0       Link encap:Ethernet  HWaddr 3e:ea:29:0a:07:d9
          inet addr:192.168.43.1  Bcast:192.168.43.255  Mask:255.255.255.0 
          inet6 addr: fe80::3cea:29ff:fe0a:7d9/64 Scope: Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0 
          TX packets:9 errors:0 dropped:0 overruns:0 carrier:0 
          collisions:0 txqueuelen:1000 
          RX bytes:0 TX bytes:1450 
</code></pre> 
<p>一般情况热点的节点名称都是ap0，可以看到ip地址和相关信息。上面的wifi未连接所以才没有ip地址。</p> 
<h5><a id="2Android_ipMAC_230"></a>（2）Android 代码获取所有网络的ip地址和MAC地址：</h5> 
<p>Android 热点ip地址 IpServer 和相关的类都是隐藏的所以无法上Wifi那样通过api获取到ip地址，</p> 
<p>但是可以通过遍历节点的数据，获取到ip地址，</p> 
<p>wifi、有线网、热点的ip地址和节点相关的信息都可以这样获取到：</p> 
<pre><code>    /**
     * 获取ip地址,key为网络端口名称，比如wlan0、eth0、ap0等，value为ip地址,以及节点相关的MAC地址
     *
     * @return 键值对
     */
    private HashMap&lt;String, String&gt; getNetIPs() {
        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();
        try {
            for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) {
                NetworkInterface intf = en.nextElement(); //打印的信息和 ifconfig 的大致对应
                Log.i(TAG, "----》getEtherNetIP inf = " + intf); //eth0、wifi...
                for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) {
                    InetAddress inetAddress = enumIpAddr.nextElement();
                    if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) {
                        Log.i(TAG, "----》getEtherNetIP intf.getName() = " + intf.getName());
                        Log.i(TAG, "----》getEtherNetIP inetAddress = " + inetAddress);
                        Log.i(TAG, "----》getEtherNetIP inetAddress  getHostAddress = " + inetAddress.getHostAddress());
                        byte[] hardwareAddress = intf.getHardwareAddress();
                                               
                        //节点对应的ip地址
                        hashMap.put(intf.getName(), "" + inetAddress.getHostAddress());
                        //节点对应的MAC地址，mac地址是byte数值数据，要转换成字符串
                        String mac = bytesToString(hardwareAddress);
                        hashMap.put(intf.getName() + "-MAC", "" + mac);
                    }
                }
            }
        } catch (SocketException ex) {
            Log.e(TAG, "getEtherNetIP = " + ex.toString());
        }
        return hashMap;
    }
    
    //字节数据转换成字符串
    public static String bytesToString(byte[] bytes) {
        if (bytes == null || bytes.length == 0) {
            return null;
        }
        StringBuilder buf = new StringBuilder();
        for (byte b : bytes) {
            buf.append(String.format("%02X:", b));
        }
        if (buf.length() &gt; 0) {
            buf.deleteCharAt(buf.length() - 1);
        }
        return buf.toString();
    }
</code></pre> 
<p>上面是获取了ifconfig信息 节点上 Inet4Address 类型的所有信息，如果只要获取热点的ip地址，可以这样写：</p> 
<h5><a id="3Android__ip_294"></a>（3）Android 代码获取热点的 ip地址：</h5> 
<p>主要代码：</p> 
<pre><code>    /**
     * 获取热点ip地址字符串
     */
    private String getHotspottIPs() {
        try {
            for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) {
                NetworkInterface intf = en.nextElement(); //打印的信息和 ifconfig 的大致对应
                Log.i(TAG, "----》getEtherNetIP inf = " + intf); //eth0、wifi...
                for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) {
                    InetAddress inetAddress = enumIpAddr.nextElement();
                    if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address &amp;&amp; "ap0".equals(intf.getName())) { //判断热点的节点名称ap0，如果不是ap0，就自己修改
                         return "" + inetAddress.getHostAddress();
                    }
                }
            }
        } catch (SocketException ex) {
            Log.e(TAG, "getEtherNetIP = " + ex.toString());
        }
        return "";
    }
    

</code></pre> 
<p>上面的获取热点ip的方法，是不用Context对象，不用权限，普通应用就能调用和获取到信息，验证过是ok的。</p> 
<p>所以WiFi、有线网这些网络的ip地址也可以参考这样获取。</p> 
<p>网上搜到的通过 ConnectivityManager 获取WifiManager 相关接口获取的代码，都是获取不到热点ip地址的。</p> 
<p>即使通过反射也是无法获取到热点相关信息的，因为不仅相关方法是隐藏的，相关类也是被隐藏的，</p> 
<p>所以一般的反射手段是无法获取到热点ip的。</p> 
<h5><a id="4ip_333"></a>（4）动态设置热点ip的代码？</h5> 
<p>从网上其他文章上看到这样一段设置热点ip的代码：</p> 
<pre><code>  InterfaceConfiguration ifcg = mNwService.getInterfaceConfig(intf);                               
  if (ifcg != null) {                                                       
  /* IP/netmask: 192.168.43.1/255.255.255.0 */                          
  	ifcg.setLinkAddress(new LinkAddress(                                  
  	NetworkUtils.numericToInetAddress("192.168.43.1"), 24));      
  	ifcg.setInterfaceUp();                                                
	mNwService.setInterfaceConfig(intfaceName, ifcg); //intfaceName 是节点名称，比如"ap0"                       
}                                                       
</code></pre> 
<p>在普通应用试了下是没有 InterfaceConfiguration这个类的，需要那些导入了framework的系统才可以找到这些类和调用这些api。</p> 
<p>这个段代码并没有进行尝试，怀疑是不一定能设置到固定的ip的；</p> 
<p>因为开启热点不是这种代码，还需要配置相关信息的；</p> 
<p>并且尝试ifconfig ap0 down再，ifconfig ap0 up，默认是没有热点ip的，</p> 
<p>所以不经过某些系统流程是无获取到ip地址的。</p> 
<p>有兴趣的可以自己尝试研究看看。</p> 
<h5><a id="5_362"></a>（5）热点开启流程</h5> 
<p>系统源码追踪：</p> 
<pre><code>1、ConnectivityManager.startTethering
2、TetheringManager.startTethering
3、TetheringService.TetheringConnector.startTethering
4、Tethering.startTethering(request, listener);
5、WifiManager.startTetheredHotspot(null /* use existing softap config */)
6、WifiServiceImpl.startTetheredHotspot(@Nullable SoftApConfiguration softApConfig)
7、ActiveModeWarden.startSoftAp(apModeConfig);
8、ActiveModeManager.start();
10、WifiNative.startSoftAp
11、HostapdHal.addAccessPoint
</code></pre> 
<p>热点开启流程原文链接：</p> 
<p><a href="https://blog.csdn.net/wenzhi20102321/article/details/128473734">https://blog.csdn.net/wenzhi20102321/article/details/128473734</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf42d027a7f7f5001e9ee78459f19e6f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jmeter 测试数据库的详细方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4dcb1cc277d6641d40fb9ce900182b9f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode&#43;qt&#43;qmake开发环境搭建，史上最全最详细！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>