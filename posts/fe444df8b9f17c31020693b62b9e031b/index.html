<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——栈和队列（C语言实现） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fe444df8b9f17c31020693b62b9e031b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——栈和队列（C语言实现）">
  <meta property="og:description" content="写在前面：
栈和队列是两种重要的线性结构。其也属于线性表，只是操作受限，本节主要讨论的是栈和队列的定义、表示方法以及C语言实现。
一、栈和队列的定义与特点 栈：是限定仅在表尾进行插入和删除的线性表。对栈来说，表尾有着特殊的含义，称为栈顶，表头称为栈底，不含元素的空表称为空栈；
栈的特点就是：按后进先出的原则进行的，栈又称为后进先出的线性表；
与栈相反的是队列，队列是一种先进先出的特点。它只允许在标的一段进行插入，在另一端进行删除。允许插入的一段称为队尾，允许删除的一段称为队头。
二、栈 2.1顺序栈 顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放在自栈底到栈顶的数据元素。
设指针top指向栈顶元素在顺序表中的位置，base指针指向栈底元素在顺序栈中的位置。
2.1.1初始化 typedef struct Node { int *base; int *top; int stacksize; }Node; //初始化栈 void InitStack(Node *S) { S-&gt;base = (int *)malloc(sizeof(int)*MAXSIZE); S-&gt;top = S-&gt;base ; } 初始化，创建一个结构体类型，其中变量为栈顶指针、栈底指针，以及栈的最大空间；
使栈顶和栈底都指向空间的基地址；
2.1.2入栈 int PushStack(Node* S,int data) { if (S-&gt;top - S-&gt;base == MAXSIZE) { return -1; }	else { *(S-&gt;top) = data; (S-&gt;top)&#43;&#43;; } } 判断栈是否满，不满将新元素压入栈顶，栈顶指针&#43;1； 2.1.3出栈 int PopStack(Node * S) { if (S-&gt;top == S-&gt;base) return -1; else { (S-&gt;top)--; int i = *(S-&gt;top); return i; } } 判断栈顶是否为空，若不为空，栈顶指针减1，栈顶元素出栈； 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T21:23:14+08:00">
    <meta property="article:modified_time" content="2024-07-17T21:23:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——栈和队列（C语言实现）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>写在前面：</strong></p> 
 <p>        栈和队列是两种重要的线性结构。其也属于线性表，只是操作受限，本节主要讨论的是栈和队列的定义、表示方法以及C语言实现。</p> 
</blockquote> 
<h2 style="background-color:transparent;">一、栈和队列的定义与特点</h2> 
<blockquote> 
 <p>栈：是限定仅在表尾进行插入和删除的线性表。对栈来说，表尾有着特殊的含义，称为栈顶，表头称为栈底，不含元素的空表称为空栈；</p> 
 <p>栈的特点就是：按后进先出的原则进行的，栈又称为后进先出的线性表；</p> 
</blockquote> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/f3/7d/2O44DKF7_o.png" width="750"></p> 
<blockquote> 
 <p>      与栈相反的是队列，队列是一种先进先出的特点。它只允许在标的一段进行插入，在另一端进行删除。允许插入的一段称为队尾，允许删除的一段称为队头。</p> 
</blockquote> 
<h2>二、栈</h2> 
<h3 style="background-color:transparent;">2.1顺序栈</h3> 
<blockquote> 
 <p>        顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放在自栈底到栈顶的数据元素。</p> 
 <p>        设指针top指向栈顶元素在顺序表中的位置，base指针指向栈底元素在顺序栈中的位置。</p> 
</blockquote> 
<h4>2.1.1初始化</h4> 
<pre><code class="language-cpp">typedef struct Node
{
	int *base;
	int *top;
	int stacksize;
}Node;
//初始化栈
void  InitStack(Node *S)
{
	S-&gt;base = (int *)malloc(sizeof(int)*MAXSIZE);
	S-&gt;top = S-&gt;base ;
}</code></pre> 
<blockquote> 
 <p>初始化，创建一个结构体类型，其中变量为栈顶指针、栈底指针，以及栈的最大空间；</p> 
 <p>使栈顶和栈底都指向空间的基地址；</p> 
</blockquote> 
<h4>2.1.2入栈</h4> 
<pre><code class="language-cpp">int PushStack(Node* S,int data)
{
	if (S-&gt;top - S-&gt;base == MAXSIZE)
	{
		return -1;
	}	
	else
	{
		*(S-&gt;top) = data;
		(S-&gt;top)++;
	}
}</code></pre> 
<blockquote> 
 <p>判断栈是否满，不满将新元素压入栈顶，栈顶指针+1； </p> 
</blockquote> 
<h4>2.1.3出栈</h4> 
<pre><code class="language-cpp">int PopStack(Node * S)
{
	if (S-&gt;top == S-&gt;base)
		return -1;
	else
	{
		(S-&gt;top)--;
		int i = *(S-&gt;top);
		return i;
	}
}</code></pre> 
<blockquote> 
 <p>判断栈顶是否为空，若不为空，栈顶指针减1，栈顶元素出栈； </p> 
</blockquote> 
<h4>2.1.4 打印</h4> 
<pre><code class="language-cpp">void PrintStack(Node S)
{
	int len = (S.top-S.base);
	for (int i = 0; i &lt; len; i++)
	{
		(S.top)--;
		printf("%d-&gt;", *(S.top));
			}
	printf("NULL\n");
}
</code></pre> 
<blockquote> 
 <p>先计算栈的空间长度，再依次从栈顶打印除栈的元素； </p> 
</blockquote> 
<h4>2.1.5案例 </h4> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define MAXSIZE  5

typedef struct Node
{
	int *base;
	int *top;
	int stacksize;
}Node;
//初始化栈
void  InitStack(Node *S)
{
	S-&gt;base = (int *)malloc(sizeof(int)*MAXSIZE);
	S-&gt;top = S-&gt;base ;
}
//入栈
	//判断栈是否满了
int PushStack(Node* S,int data)
{
	if (S-&gt;top - S-&gt;base == MAXSIZE)
	{
		return -1;
	}
	
	else
	{
		*(S-&gt;top) = data;
		(S-&gt;top)++;
	}
}
//出栈
	//判断栈是否为空
int PopStack(Node * S)
{
	if (S-&gt;top == S-&gt;base)
		return -1;
	else
	{
		(S-&gt;top)--;
		int i = *(S-&gt;top);
		return i;
	}
}
//打印
void PrintStack(Node S)
{
	int len = (S.top-S.base);
	for (int i = 0; i &lt; len; i++)
	{
		(S.top)--;
		printf("%d-&gt;", *(S.top));
		
	}
	printf("NULL\n");
}

int  main()
{
	Node S;
	InitStack(&amp;S);
	PushStack(&amp;S, 1);
	PrintStack(S);
	PushStack(&amp;S, 2);
	PrintStack(S);
	PushStack(&amp;S, 3);
	PrintStack(S);
	PushStack(&amp;S, 4);
	PrintStack(S);
	PushStack(&amp;S, 5);
	PrintStack(S);
	int i = PopStack(&amp;S);
	printf("delete:%d\n",i);
	i = PopStack(&amp;S);
	printf("delete:%d\n", i);
	PrintStack(S);
	return 0;
}</code></pre> 
<p><strong>运行结果： </strong></p> 
<p class="img-center"><img alt="" height="235" src="https://images2.imgbox.com/7f/c6/N3TWjNhJ_o.png" width="616"></p> 
<h3>2.2链栈 </h3> 
<blockquote> 
 <p>链栈是指采用链式存储结构实现的栈，通常采用单链表实现；</p> 
 <p class="img-center"><img alt="" height="195" src="https://images2.imgbox.com/e7/fb/dVOSWyV3_o.png" width="300"></p> 
</blockquote> 
<h4>2.2.1初始化 </h4> 
<pre><code class="language-cpp">//新建结点
typedef struct Node
{
	int data;
	struct Node* next;
}Node;
//初始化
Node * StackIint()
{
	Node * head = (Node *)malloc(sizeof(Node));
	head-&gt;data=0;
	head-&gt;next = NULL;
	return head;
}</code></pre> 
<blockquote> 
 <p> 初始化，首先创建一个结构体代表一个节点，然后创建一个空栈，即只有头结点的链表。</p> 
</blockquote> 
<h4> 2.2.2入栈</h4> 
<pre><code class="language-cpp">void push(Node * node,int data)
{
	Node * S = (Node *)malloc(sizeof(Node));
	S-&gt;data = data;
	S-&gt;next = node-&gt;next;
	node-&gt;next = S;
	node-&gt;data++;	
}</code></pre> 
<blockquote> 
 <p>和链表的头插法一样，为入栈元素动态分配一个结点空间； </p> 
</blockquote> 
<h4 style="background-color:transparent;">2.2.3出栈</h4> 
<pre><code class="language-cpp">//判断是否为栈空
int isEmpty(Node * node)
{
	if (node-&gt;data == 0 || node-&gt;next == NULL)
		return 1;
	else
		return 0;
}
//出栈
int pop(Node * node)
{
	if (isEmpty(node))
		return -1;
	else
	{
		Node *S = node-&gt;next;
		int i = S-&gt;data;
		node-&gt;next = S-&gt;next;
		free(S);
		node-&gt;data--;
		return i;
	}
}</code></pre> 
<blockquote> 
 <p>        出栈，出栈前需要判断其栈是否为空，如果为空就无法进行出栈。出栈时需要把栈顶元素进行输出，并且释放栈顶空间。</p> 
</blockquote> 
<h4 style="background-color:transparent;">2.2.4取栈顶元素</h4> 
<pre><code class="language-cpp">//判断是否为栈空
int isEmpty(Node * node)
{
	if (node-&gt;data == 0 || node-&gt;next == NULL)
		return 1;
	else
		return 0;
}
//获取栈元素
int getvalue(Node * node)
{
	if (isEmpty(node))
	{
		return -1;
	}
	else
	{
		return(node-&gt;next-&gt;data);
	}
}</code></pre> 
<blockquote> 
 <p>与出栈一样，需要判断栈是否为空，如果不为空，则输出栈顶元素；</p> 
</blockquote> 
<h4 style="background-color:transparent;">2.2.5案例</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node
{
	int data;
	struct Node* next;
}Node;

//初始化
Node * StackIint()
{
	Node * head = (Node *)malloc(sizeof(Node));
	head-&gt;data=0;
	head-&gt;next = NULL;
	return head;
}

//判断是否为栈空
int isEmpty(Node * node)
{
	if (node-&gt;data == 0 || node-&gt;next == NULL)
		return 1;
	else
		return 0;
}
//获取栈元素

int getvalue(Node * node)
{
	if (isEmpty(node))
	{
		return -1;
	}
	else
	{
		return(node-&gt;next-&gt;data);
	}
}

//出栈
int pop(Node * node)
{
	if (isEmpty(node))
		return -1;
	else
	{
		Node *S = node-&gt;next;
		int i = S-&gt;data;
		node-&gt;next = S-&gt;next;
		free(S);
		node-&gt;data--;
		return i;
	}
}


//入栈
void push(Node * node,int data)
{
	Node * S = (Node *)malloc(sizeof(Node));
	S-&gt;data = data;
	S-&gt;next = node-&gt;next;
	node-&gt;next = S;
	node-&gt;data++;	
}
void printStack(Node * node)
{
	Node * S = node-&gt;next;
	while (S)
	{
		printf("%d-&gt;", S-&gt;data);
		S = S-&gt;next;
	}
	printf("NULL\n");
}
int main()
{
	Node * S = StackIint();
	push(S, 1);
	push(S, 2);
	push(S, 3);
	push(S, 4);
	printStack(S);
	int i=pop(S);
	printf(" top data:%d\n", i);
	printStack(S);
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p class="img-center"><img alt="" height="113" src="https://images2.imgbox.com/66/08/b0tHtwAh_o.png" width="350"></p> 
<h2 style="background-color:transparent;">三、队列</h2> 
<p style="background-color:transparent;">        有与栈结构相同，队列也有两种存储表示，顺序表示与链式表示；</p> 
<h3 style="background-color:transparent;">3.1顺序队列（循环队列）</h3> 
<blockquote> 
 <p>        在顺序队列中。除了设置一组地址连续的存储空间依次存放元素外，另外需要两个正向变量，分别指示队列头元素和队列尾元素的位置。</p> 
 <p class="img-center"><img alt="" height="345" src="https://images2.imgbox.com/21/af/4TDfoERT_o.png" width="800"></p> 
 <p>        在初始化空队列时，令front=rear=0;每当插入新的队列尾元素时，尾指针rear增1；每当删除队列头元素时，头指针front增1；在非空队列中，头指针始终指向队列头元素，而尾指针始终指向尾元素的下一个位置。但是这种操作会使得队列的指针最终越界处理，围殴了限制这种越界处理，我们提出循环队列的形式；</p> 
 <p class="img-center"><img alt="" height="221" src="https://images2.imgbox.com/fc/70/2kNjrVsl_o.png" width="300"></p> 
 <p>        循环队列的头尾以及队列元素之间的关系不变，只是在循环队列中，头指针、尾指针，依次环状增1的操作可以取模进行运算。通过取模运算，头指针和尾指针可以在顺序变种以头尾衔接的方式“循环”移动；</p> 
 <p>        对于循环队列 种，不能以头指针、尾指针的值是否相等来判断，队列的空间是“满”还是“空”，采取的方式是：</p> 
 <p>      <strong>  少用一个元素空间，即队列空间为m时，有m-1个元素就认为时队满，这样设置的意义在于：当头尾指针相等时，队列为空，当尾指针加1等于头指针时，则认为队列满；</strong></p> 
 <p><strong>队空条件：front==rear;</strong></p> 
 <p><strong>队满条件：（rear+1）%MAXQSIZE==front;</strong></p> 
</blockquote> 
<h4 style="background-color:transparent;">3.1.1初始化</h4> 
<pre><code class="language-cpp">//新建一个结构体
typedef struct Queue
{
	int front;
	int rear;
	int data[MAXSIZE];
}Queue;
//1、初始化队列
Queue * initQueue()
{
	Queue * Q = (Queue *)malloc(sizeof(Queue));
	Q-&gt;front = Q-&gt;rear = 0;
	return Q;
}</code></pre> 
<blockquote> 
 <p>创建一个结构体类型，结构体类型中有三个元素：数据数组、头指针地址、尾指针地址。然后初始化创建一个空队列；</p> 
</blockquote> 
<h4>3.1.2入队</h4> 
<pre><code class="language-cpp">//判断是否队满
int isFULL(Queue * Q)
{
	if ((Q-&gt;rear +1) % MAXSIZE == Q-&gt;front)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

//入队
int  enQueue(Queue * Q, int data)
{
	if (isFULL(Q))
	{
		return -1;
	}
	else
	{
		Q-&gt;data[Q-&gt;rear] = data;
		Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;
		return 1;
	}
}</code></pre> 
<blockquote> 
 <p>首先判断队列是否满，如果没满进行入队，并且操作的都是尾指针； </p> 
</blockquote> 
<h4>3.1.3出队</h4> 
<pre><code class="language-cpp">int isNULL(Queue * Q)
{
	if (Q-&gt;rear == Q-&gt;front)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int deQueue(Queue * Q)
{
	if (isNULL(Q))
	{
		return -1;
	}
	else
	{
		int e = Q-&gt;data[Q-&gt;front];
		Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;
		return e;
	}
}</code></pre> 
<blockquote> 
 <p>首先判断是否队列为空，如果没有为空，就从队头出队，操作的都是队头指针；</p> 
</blockquote> 
<h4>3.1.4打印队列</h4> 
<pre><code class="language-cpp">void printfQueue(Queue * Q)
{
	//要知道队列当前有多少个元素
	int len = (MAXSIZE + Q-&gt;rear - Q-&gt;front) % MAXSIZE;
	int index = Q-&gt;front;
	for (int i =0; i &lt;len; i++)
	{
		printf("%d-&gt;", Q-&gt;data[index]);
		index = (index + 1) % MAXSIZE;
	}
	printf("NULL\n");
}
</code></pre> 
<blockquote> 
 <p>进行队列元素的遍历，然后依次进行打印； </p> 
</blockquote> 
<h4>3.1.5案例 </h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 6
//新建一个结构体
typedef struct Queue
{
	int front;
	int rear;
	int data[MAXSIZE];
}Queue;
//1、初始化队列
Queue * initQueue()
{
	Queue * Q = (Queue *)malloc(sizeof(Queue));
	Q-&gt;front = Q-&gt;rear = 0;
	return Q;
}

int isFULL(Queue * Q)
{
	if ((Q-&gt;rear +1) % MAXSIZE == Q-&gt;front)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
//2、入队
int  enQueue(Queue * Q, int data)
{
	if (isFULL(Q))
	{
		return -1;
	}
	else
	{
		Q-&gt;data[Q-&gt;rear] = data;
		Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;
		return 1;
	}
}
//3、出队
int isNULL(Queue * Q)
{
	if (Q-&gt;rear == Q-&gt;front)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int deQueue(Queue * Q)
{
	if (isNULL(Q))
	{
		return -1;
	}
	else
	{
		int e = Q-&gt;data[Q-&gt;front];
		Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;
		return e;
	}
}
//4、打印队列
void printfQueue(Queue * Q)
{
	//要知道队列当前有多少个元素
	int len = (MAXSIZE + Q-&gt;rear - Q-&gt;front) % MAXSIZE;
	int index = Q-&gt;front;
	for (int i =0; i &lt;len; i++)
	{
		printf("%d-&gt;", Q-&gt;data[index]);
		index = (index + 1) % MAXSIZE;
	}
	printf("NULL\n");
}
int main()
{
	Queue * Q = initQueue();
	enQueue(Q, 1);
	printfQueue(Q);
	enQueue(Q, 2);
	printfQueue(Q);
	enQueue(Q, 3);
	printfQueue(Q);
	enQueue(Q, 4);
	printfQueue(Q);
	int i = deQueue(Q);
	printf(" delete	Queue:%d\n",i);
	printfQueue(Q);
	i = deQueue(Q);
	printf(" delete	Queue:%d\n",i);
	printfQueue(Q);
	return 0;
}</code></pre> 
<p><strong> 运行结果：</strong></p> 
<p class="img-center"><img alt="" height="167" src="https://images2.imgbox.com/52/10/z7eBAhhX_o.png" width="400"></p> 
<h3 style="background-color:transparent;">3.2链队</h3> 
<h4>3.2.1初始化</h4> 
<pre><code class="language-cpp">//定义结构体类型
typedef struct Node
{
	int data;
	struct Node* next;
}Node;
//初始化
Node * QueueInit()
{
	Node * head = (Node *)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}</code></pre> 
<blockquote> 
 <p>与栈操作相同，先创建一个结构类型，再创建一个空的队列，只含有一个头结点的队列。 </p> 
</blockquote> 
<h4>3.2.2入队</h4> 
<pre><code class="language-cpp">//入队
void Queueen(Node *Q,int data)
{
	Node * node = (Node *)malloc(sizeof(Node));
	node-&gt;data = data;
	Node * q = Q;
	while (q-&gt;next != NULL)
	{
		q = q-&gt;next;
	}
	node-&gt;next = q-&gt;next;
	q-&gt;next = node;
	Q-&gt;data++;
}</code></pre> 
<blockquote> 
 <p>入队操作和链表的尾插法是一样的，需要再队尾进行插入； </p> 
</blockquote> 
<h4>3.2.3出队</h4> 
<pre><code class="language-cpp">//判断
int isEmpty(Node * Q)
{
	if (Q-&gt;data)
		return 1;
	else
		return 0;
}
//出队
int dequeue(Node * Q)
{
	if (isEmpty(Q))
	{
		Node * node = Q-&gt;next;
		int i = node-&gt;data;
		Q-&gt;next = node-&gt;next;
		free(node);
		Q-&gt;data--;
		return i;
	}
	else
	{
		return -1;
	}
}</code></pre> 
<blockquote> 
 <p>        出队，首先要判断队列是否为空，而且还有遵循先进先出的原则。 </p> 
</blockquote> 
<h4 style="background-color:transparent;">3.2.4打印队列</h4> 
<pre><code class="language-cpp">//打印队列
void printQueue(Node * node)
{
	Node* p = node-&gt;next;
	while (p)
	{
		printf("%d-&gt;", p-&gt;data);
		p = p-&gt;next;
	}
	printf("NULL\n");
}
</code></pre> 
<blockquote> 
 <p>遍历队列，然后打印，同链表操作基本一致； </p> 
</blockquote> 
<h4 style="background-color:transparent;">3.2.5案例</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//定义结构体类型
typedef struct Node
{
	int data;
	struct Node* next;
}Node;
//初始化
Node * QueueInit()
{
	Node * head = (Node *)malloc(sizeof(Node));
	head-&gt;data = 0;
	head-&gt;next = NULL;
	return head;
}
//入队
void Queueen(Node *Q,int data)
{
	Node * node = (Node *)malloc(sizeof(Node));
	node-&gt;data = data;
	Node * q = Q;
	while (q-&gt;next != NULL)
	{
		q = q-&gt;next;
	}
	node-&gt;next = q-&gt;next;
	q-&gt;next = node;
	Q-&gt;data++;
}
//判断
int isEmpty(Node * Q)
{
	if (Q-&gt;data)
		return 1;
	else
		return 0;
}
//出队
int dequeue(Node * Q)
{
	if (isEmpty(Q))
	{
		Node * node = Q-&gt;next;
		int i = node-&gt;data;
		Q-&gt;next = node-&gt;next;
		free(node);
		Q-&gt;data--;
		return i;
	}
	else
	{
		return -1;
	}
}

//打印队列
void printQueue(Node * node)
{
	Node* p = node-&gt;next;
	while (p)
	{
		printf("%d-&gt;", p-&gt;data);
		p = p-&gt;next;
	}
	printf("NULL\n");
}

int main()
{
	Node * Q = QueueInit();
	Queueen(Q, 1);
	printQueue(Q);
	Queueen(Q, 2);
	printQueue(Q);
	Queueen(Q, 3);
	printQueue(Q);
	Queueen(Q, 4);
	printQueue(Q);
	Queueen(Q, 5);
	printQueue(Q);
	int i = dequeue(Q);
	printf("delete queue:%d\n", i);
	printQueue(Q);
	return 0;
}</code></pre> 
<p><strong>运行结果： </strong></p> 
<p class="img-center"><img alt="" height="181" src="https://images2.imgbox.com/fa/ea/pDwSDPlU_o.png" width="350"></p> 
<h2 style="background-color:transparent;">四、总结</h2> 
<p>        本次主要介绍了两个特殊的线性表：栈和队列；</p> 
<p>1、栈是限定仅在表尾进行插入或者删除的线性表，又称为后进先出的线性表。栈有两种存储结构表示方式，顺序表示（顺序栈）和链式表示（链栈）；栈的主要操作是入栈和出栈，注意入栈和出栈时需要分别判断栈满和栈空；</p> 
<p>2、队列是一种先入先出的线性表，它只允许在表的一端进行插入，在另一端删除元素。队列也有两种存储表示，顺序表示（循环队列）和链式表示（链队）。队列主要的操作是进队和出队，对于顺序的循环队列的进队和出队需要注意判断队满或队空。凡是涉及到队头和队尾指针的都要对其进行求模；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/09dc8dccee03aa2d01af23c9c433693c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C#】已知有三个坐标点：P0、P1、P2，当满足P3和P4连成的一条直线 与 P0和P1连成一条直线平行且长度一致，该如何计算P3、P4？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b57fb3319be8b6605fd48b05ff157c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">物联网与通信技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>