<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode的基础入门（非常详细）零基础入门到精通，收藏这一篇就够了 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4d591b83ac083dca521612376c644b7d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="LeetCode的基础入门（非常详细）零基础入门到精通，收藏这一篇就够了">
  <meta property="og:description" content="关于LeetCode都需要了解哪些？一文带你详细了解，欢迎收藏！
Python语法
reduce(function, iterable[, initializer]) reduce(lambda x,y:x * y,ns) # 数组之乘积 (ns[0] * ns[1]) * ns[2] reduce(lambda x,y:x &#43; y,ns) # 数组之和# 记忆化搜索@functools.lru_cache(None)res = helper(0,N,0)helper.cache_clear()tuple(ns) 可以hash做参数# 大根堆q = list(map(lambda x:-x,ns))heapq.heapify(q)key = -heapq.heappop(q)# 过滤函数filter(function, iterable)` `filter(lambda x: 2 &lt; x &lt; 10 and x % 2 == 0, range(18))` `filter(dfs, range(len(graph)))# 除数div, mod = divmod(sum(ns), 4)random.randint(i,len(self.ns)-1)#第一个降序，第二个升序sorted(pss,key = lambda x:[x[0],-x[1]]) # 不可变str 常见函数split(sep=None, maxsplit=-1) # 以sep来分割字符串strip([chars]) # 去除首末两端的字符, 默认是 \r,\n,&#34; &#34;join(iterable) # 将iterable内的元素拼接成字符串,如&#39;,&#39;.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-25T09:07:23+08:00">
    <meta property="article:modified_time" content="2024-04-25T09:07:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode的基础入门（非常详细）零基础入门到精通，收藏这一篇就够了</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>关于LeetCode都需要了解哪些？一文带你详细了解，欢迎收藏！</p> 
<p><img src="https://images2.imgbox.com/0d/71/KsAEksrl_o.png" alt=""></p> 
<p>Python语法</p> 
<pre><code>

</code></pre> 
<p>reduce(function, iterable[, initializer])<code> </code>reduce(lambda x,y:x * y,ns) # 数组之乘积 (ns[0] * ns[1]) * ns[2]<code> </code>reduce(lambda x,y:x + y,ns) # 数组之和<code># 记忆化搜索</code>@functools.lru_cache(None)<code>res = helper(0,N,0)</code>helper.cache_clear()<code>tuple(ns) 可以hash做参数</code># 大根堆<code>q = list(map(lambda x:-x,ns))</code>heapq.heapify(q)<code>key = -heapq.heappop(q)</code># 过滤函数<code>filter(function, iterable)` `filter(lambda x: 2 &lt; x &lt; 10 and x % 2 == 0, range(18))` `filter(dfs, range(len(graph)))</code># 除数<code>div, mod = divmod(sum(ns), 4)</code>random.randint(i,len(self.ns)-1)<code>#第一个降序，第二个升序</code>sorted(pss,key = lambda x:[x[0],-x[1]])<code> </code># 不可变str 常见函数<code>split(sep=None, maxsplit=-1) # 以sep来分割字符串</code>strip([chars]) # 去除首末两端的字符, 默认是 \r,\n," "<code>join(iterable) # 将iterable内的元素拼接成字符串,如','.join(['leet', 'code'])="leet,code"</code>replace(old, new[, count]) # 字符串替换, old to new<code>count(sub[, start[, end]]) # 统计子字符串sub的个数</code>startswith(prefix[, start[, end]]) # 以prefix开始的字符串<code>endswith(suffix[, start[, end]]) # 以suffix结束的字符串</code>cs in chrs: # chrs 中包含 cs<code> </code> <code># deque 常见函数</code>queue = deque([iterable[, maxlen]])<code>queue.append(val) # 往右边添加一个元素</code>queue.appendleft(val) # 往左边添加一个元素<code>queue.clear() # 清空队列</code>queue.count(val) # 返回指定元素的出现次数<code>queue.insert(val[, start[, stop]]) # 在指定位置插入元素</code>queue.pop() # 获取最右边一个元素，并在队列中删除<code>queue.popleft() # 获取最左边一个元素，并在队列中删除</code>queue.reverse() # 队列反转<code>queue.remove(val) # 删除指定元素</code>queue.rotate(n=1) # 把右边元素放到左边<code> </code># list 常见函数<code>lst.sort(*, key=None, reverse=False)</code>lst.append(val) # 也可以 lst = lst + [val]<code>lst.clear() # 清空列表</code>lst.count(val) # val个数<code>lst.pop(val=lst[-1]) # (默认)从末端移除一个值</code>lst.remove(val) # 移除 val<code>lst.reverse() # 反转</code>lst.insert(i, val) # 在 i 处插入 val<code> </code># 字典dict 常见函数<code>d = defaultdict(lambda : value) # 取到不存在的值时不会报错，用{}时、需要设置get的default值</code>pop(key[, default]) # 通过键去删除键值对(若没有该键则返回default(没有设置default则报错))<code>setdefault(key[, default]) # 设置默认值</code>update([other]) # 批量添加<code>get(key[, default]) # 通过键获取值(若没有该键可设置默认值, 预防报错)</code>clear() # 清空字典<code>keys() # 将字典的键组成新的可迭代对象</code>values() # 将字典中的值组成新的可迭代对象<code>items() # 将字典的键值对凑成一个个元组, 组成新的可迭代对象</code>dict1 = dict2 #两个字典完全相等，滑窗时可用<code> </code># 集合set 常见函数<code>s = set(lambda : value)</code>add(elem) # 向集合中添加数据<code>update(*others) # 迭代着增加</code>clear() # 清空集合<code>discard(elem) # 删除集合中指定的值(不存在则不删除)</code> <code># 堆heapq 常见函数</code>heap = [] # 建堆<code>heapq.heappush(heap,item) # 往堆中插入新值</code>heapq.heappop(heap) # 弹出最小的值<code>heap[0] # 查看堆中最小的值, 不弹出</code>heapq.heapify(x) # 以线性时间将一个列表转为堆<code>heapq.heappoppush(heap, item) # 弹出最小的值.并且将新的值插入其中.</code>heapq.merge(<em>iterables, key=None, reverse=False) # 将多个堆进行合并<code>heapq.nlargest(n, iterable, key=None) # 从堆中找出最大的 n 个数，key的作用和sorted( )方法里面的key类似, 用列表元素的某个属性和函数作为关键字</code>heapq.nsmallest(n, iterable, key=None) # 从堆中找出最小的 n 个数, 与 nlargest 相反<code> </code> <code># 二分查找函数</code>bisect.bisect_left(ps, T, L=0, R=len(ns)) #二分左边界<code>bisect.bisect_right(ps, T, L=0, R=len(ns)) #二分右边界` `bisect.insort_left(a, x, lo=0, hi=len(a)) # 二分插入到左侧</code>bisect.insort_right(a, x, lo=0, hi=len(a)) # 二分插入到右侧<code> </code># bit操作<code>&amp; 符号，x &amp; y ，会将两个十进制数在二进制下进行与运算</code>| 符号，x | y ，会将两个十进制数在二进制下进行或运算<code>^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算</code>&lt;&lt; 符号，x &lt;&lt; y 左移操作，最右边用 0 填充<code>&gt;&gt; 符号，x &gt;&gt; y 右移操作，最左边用 0 填充</code>~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反<code> </code># 整数集合set位运算<code># 整数集合做标志时，可以做参数加速运算</code>vstd 访问 i ：vstd | (1 &lt;&lt; i)<code>vstd 离开 i ：vstd &amp; ~(1 &lt;&lt; i)</code>vstd 不包含 i : not vstd &amp; (1 &lt;&lt; i)<code> </code>并集 ：A | B<code>交集 ：A &amp; B</code>全集 ：(1 &lt;&lt; n) - 1<code>补集 ：((1 &lt;&lt; n) - 1) ^ A</code>子集 ：(A &amp; B) == B<code>判断是否是 2 的幂 ：A &amp; (A - 1) == 0</code>最低位的 1 变为 0 ：n &amp;= (n - 1)<code> </code>while n:<code> </code>n &amp;= n - 1<code> </code>ret += 1<code>最低位的 1：A &amp; (-A)，最低位的 1 一般记为 lowbit(A)</code> <code># ^ ：匹配字符串开头</code># [±]：代表一个+字符或-字符<code># ? ：前面一个字符可有可无</code># \d ：一个数字<code># + ：前面一个字符的一个或多个</code># \D ：一个非数字字符<code># * ：前面一个字符的0个或多个</code>matches = re.match('[ ]</em>([±]?\d+)', s)</p> 
<pre><code>
  

![](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8X1wEorjS3bDLnHiar4vtV5s4iaFibfqswhDiaUmcuk0ibG6v33ybaPY8N6ZVvedwxAbibQ1ib6BIlnJtRw/640?wx_fmt=other&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;tp=webp)

背包模板


</code></pre> 
<p>**「力扣」**上的 0-1 背包问题：</p> 
<ul><li>组合问题模板</li></ul> 
<pre><code>#0-1背包，不可重复``for n in ns: ``    for i in range(T, n-1, -1):`        `dp[i]` `= max(dp[i], dp[i - n] + ws[i])``#完全背包，可重复，无序，算重量``for n in ns: ``    for i in range(n, T+1):`        `dp[i]` `= max(dp[i], dp[i - n] + ws[i])` `#完全背包，可重复，有序，算次数`     `for i in range(1, T+1):`    `for n in ns:`        `dp[i] +``= dp[i-n]
</code></pre> 
<ul><li> <p>377 组合总和 Ⅳ</p> </li><li> <p>494 目标和</p> </li><li> <p>518 零钱兑换 II</p> </li><li> <p>True、False问题</p> </li></ul> 
<pre><code>dp[i] |= dp[i-num]
</code></pre> 
<ul><li> <p>139 单词拆分</p> </li><li> <p>416 分割等和子集</p> </li></ul> 
<pre><code>#特殊的可以使用bit数组
</code></pre> 
<ul><li>最大最小问题：</li></ul> 
<pre><code>dp[i] = min(dp[i], dp[i-num]+1)dp[i] = max(dp[i], dp[i-num]+1)
</code></pre> 
<ul><li> <p>474 一和零</p> </li><li> <p>322 零钱兑换</p> </li></ul> 
<p>**「力扣」**第 879 题：盈利计划（困难）；<br> **「力扣」**第 1449 题：数位成本和为目标值的最大数字（困难）。</p> 
<p><img src="https://images2.imgbox.com/3a/d0/YG0ibe3o_o.png" alt=""></p> 
<p>回溯模板</p> 
<pre><code>

</code></pre> 
<h2><a id="2nNlrufunctoolslru_cacheNonedef_backtrack_____if_________append________return____for__in________________if_vsti______________continue________________backtrack_________97"></a>回溯算法，复杂度较高2^n或者N！，因为回溯算法就是暴力穷举，可用lru剪枝<code>@functools.lru_cache(None)</code>def backtrack(路径, 选择列表):<code> </code>if 满足结束条件:<code> </code>结果.append(路径)<code> </code>return<code> </code>for 选择 in 选择列表: # 核心代码段<code> </code>if vst[i]: # 辅助数组，减枝<code> </code>continue<code> </code>做出选择<code> </code>递归执行backtrack<code> </code>撤销选择</h2> 
<pre><code>
  



</code></pre> 
<p>**「剪枝」**第 46 题 全排列 第 47 题 全排列②</p> 
<pre><code># 剪枝``def backtrack(temp_list, length):`    `if length == n:`      `res.append(temp_list)`    `for i in range(n):`      `if not visited[i]:`          `visited[i] = 1`          `backtrack(temp_list + [nums[i]], length + 1)`          `visited[i] = 0
</code></pre> 
<p>**「索引遍历」**第 78 题 子集 | 第 47 题 子集② | 第 131 题 分割字符串</p> 
<pre><code>

  `第 **39 **题 组合 | 第 **40** 题 组合②  | 第 **216** 题 组合③`


</code></pre> 
<pre><code># 索引遍历``def helper1(idx, n, temp_list):`  `if temp_list not in res:`    `res.append(temp_list)`  `for i in range(idx, n):`    `helper1(i + 1, n, temp_list + [nums[i]])
</code></pre> 
<p>**「 资源消耗」**第 22 题 夸号生成</p> 
<pre><code>

`# 资源消耗``def backtrack(S, L, R):`  `if not L and not R:`    `ans.append(''.join(S))`    `return`  `if L :     backtrack(S + ['('], L-1, R)`  `if R &gt; L : backtrack(S + [')'], L, R-1)`


</code></pre> 
<p>**「资源消耗」**第 93 题 复原IP</p> 
<pre><code>

`资源消耗``def backtrack(i, tmp, flag):`  `if i == n and flag == 0:`    `res.append(tmp[:-1])`  `elif i&lt;n and s[i] == '0':`    `backtrack(i + 1, tmp + s[i] + ".", flag - 1)`  `elif flag :`    `for j in range(i, min(n,i + 3)):`      `if 0 &lt; int(s[i:j + 1]) &lt;= 255:`        `backtrack(j + 1, tmp + s[i:j + 1] + ".", flag - 1)`


</code></pre> 
<p>**「资源消耗」**第 17 题 电话号码</p> 
<pre><code>

`# 资源消耗``def dfs(path, remains):`  `if not remains:`    `res.append(path[:])`    `return`  `for i in range(len(remains)):`    `dfs(path + [remains[i]], remains[:i] + remains[i+1:])``   ``# 套模板``def dfs(pth,idx):`    `if idx == len(ds):`        `res.append(pth)`        `return`    `for c in dic[ds[idx]]:`        `dfs(pth + c, idx + 1)`


</code></pre> 
<p>**「多重限制」**第 37 题 解数独 | 第 51 题 N皇后</p> 
<pre><code>

</code></pre> 
<h2><a id="def_backtrackpos__if_pos__n____return_True__i_j__emptypos__for_num_in_rowi__colj__blockbidxi_j____rowiremovenum____coljremovenum____blockbidxi_jremovenum____boardij__strnum____if_backtrackpos__1_return_True____rowiaddnum____coljaddnum____blockbidxi_jaddnum_172"></a>多重限制``def backtrack(pos):<code> </code>if pos == n:<code> </code>return True<code> </code>i, j = empty[pos]<code> </code>for num in row[i] &amp; col[j] &amp; block[bidx(i, j)]:<code> </code>row[i].remove(num)<code> </code>col[j].remove(num)<code> </code>block[bidx(i, j)].remove(num)<code> </code>board[i][j] = str(num)<code> </code>if backtrack(pos + 1): return True<code> </code>row[i].add(num)<code> </code>col[j].add(num)<code> </code>block[bidx(i, j)].add(num)</h2> 
<pre><code>
  



</code></pre> 
<p>**「递归」**第 10 题 正则匹配</p> 
<pre><code># 递归``def isMatch(self, s: str, p: str) -&gt; bool:`  `if not p:``    return not s`  `f = bool(s and p[0] in {s[0],'.'})`  `if len(p) &gt;= 2 and p[1] == "*":`    `return self.isMatch(s, p[2:]) or f and self.isMatch(s[1:], p)`  `else:`    `return f and self.isMatch(s[1:], p[1:])
</code></pre> 
<p><img src="https://images2.imgbox.com/db/ca/8XwuXAjV_o.png" alt=""></p> 
<p>并查集模板</p> 
<pre><code>

</code></pre> 
<p>#虚拟节点用以连接某一特征的全部节点，类似于链表的preHead<code>dummy` `parent = {}</code>size = collections.defaultdict(lambda:1)<code>cnt = 0</code>def find(x):<code> </code>parent.setdefault(x,x)<code> </code>while x != parent[x]:<code> </code>x = parent[x]<code> </code>#路径压缩 parent[x] = parent[parent[x]];<code> </code>return x<code>def union(x,y):` `nonlocal cnt` `if connected(x,y): return` `# 小的树挂到大的树上， 使树尽量平衡` `xP = find(x)` `yP = find(y)` `if size[hP] &lt; size[yP]:` `parent[xP] = yP` `else:` `parent[yP] = xP` `size[xP] += size[yP]` `# 优化结束` `parent[find(x)] = find(y)` `# 不优化` `cnt -= 1` `return size[xP]</code>def connected(x, y):<code> </code>return find(x) == find(y)<code>def add(self,x):` `if x not in parent:` `parent[x] = None` `cnt += 1</code># 检查是否有环<code>for a, b in edges:` `if connected(a, b):</code> return True<code> </code>union(a, b)<code># 将每个集合组成以头为key的字典</code>res = collections.defaultdict(list)``for e in e2n:<code> </code>res[uf.find(e)].append(e)</p> 
<pre><code>
  



</code></pre> 
<p><img src="https://images2.imgbox.com/f7/3e/8aCrWtL5_o.png" alt=""></p> 
<p>拓扑排序模板</p> 
<pre><code>

</code></pre> 
<h2><a id="ins__0__nous__collectionsdefaultdictlistfor_cur_pre_in_ps____inscur__1__________________ouspreappendcur____res__listfilterlambda_xinsx0_rangenq__collectionsdequereswhile_q____pre__qpopleft____for_cur_in_ouspre___________inscur__1________if_not_inscur____________qappendcur__0____________resappendcur_218"></a>【拓扑排序模板】<code>ins = [0] * n</code>ous = collections.defaultdict(list)<code>for cur, pre in ps:` `ins[cur] += 1 #入度` `ous[pre].append(cur) #出度</code>res = list(filter(lambda x:ins[x]==0, range(n)))<code>q = collections.deque(res)</code>while q:<code> </code>pre = q.popleft()<code> </code>for cur in ous[pre]: #释放出度队列<code> </code>ins[cur] -= 1<code> </code>if not ins[cur]:`` q.append(cur) #入度为0解锁<code> </code>res.append(cur)</h2> 
<pre><code>
  

![](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8X1wEorjS3bDLnHiar4vtV5CzczGLPQOcdou3FWaqibqVYrYC7MMVyloDaAnM7sQXicrTKANsWYXwog/640?wx_fmt=other&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;tp=webp)

单调栈模板


</code></pre> 
<pre><code>

</code></pre> 
<h2><a id="sfor_i_in_rangelenns____while_stack_and_nsstack1__nsi__________stackpop_________stackappendi_236"></a>s中一般存索引``for i in range(len(ns):<code> </code>while stack and ns[stack[-1]] &lt;= ns[i]: # 单调递减栈<code> </code>stack.pop()<code> </code># 业务逻辑<code> </code>stack.append(i)</h2> 
<pre><code>
  



</code></pre> 
<p>**「单调递增」**第 84 题 求最大矩形</p> 
<pre><code>

</code></pre> 
<h2><a id="_84__for_i_in_rangelenhs____while_s_and_hsi__hss1________base__spop________if_s____________H__hsbase____________W__i__s1__1______________res__maxres_H__W____sappendi_251"></a>第 <strong>84</strong> 题 求最大矩形``for i in range(len(hs)):<code> </code>while s and hs[i] &lt; hs[s[-1]]:<code> </code>base = s.pop()<code> </code>if s:<code> </code>H = hs[base]<code> </code>W = i - s[-1] - 1 # 当前弹出的做高，当前与次小做宽<code> </code>res = max(res, H * W)<code> </code>s.append(i)</h2> 
<pre><code>
  



</code></pre> 
<p>**「单调递增,考虑剩余」**第 316 题 去除重复字符</p> 
<pre><code>

</code></pre> 
<h2><a id="_316__for_ic_in_enumeratess____if_c_not_in_s________while_s_and_c__s1_and_s1_in_ssi____________spop________sappendc_266"></a>第 <strong>316</strong> 题 去除重复字符``for i,c in enumerate(ss):<code> </code>if c not in s:<code> </code>while s and c &lt; s[-1] and s[-1] in ss[i:]:<code> </code>s.pop()<code> </code>s.append©</h2> 
<pre><code>
  



</code></pre> 
<p>**「单调递减」**第 42 题 接雨水</p> 
<pre><code>

</code></pre> 
<h2><a id="_42__for_i_in_rangelenhgt____while_stack_and_hgti__hgtstack1_________base__stackpop________if_stack____________LH__hgtstack1____________W__i__stack1__1____________H__minLHhgti__hgtbase____________res__W__H____stackappendi_281"></a>第 <strong>42</strong> 题 接雨水<code>for i in range(len(hgt)):` `while stack and hgt[i] &gt; hgt[stack[-1]]: #递减栈` `base = stack.pop()` `if stack:` `LH = hgt[stack[-1]]` `W = i - stack[-1] - 1` `H = min(LH,hgt[i]) - hgt[base]` `res += W * H</code> stack.append(i)</h2> 
<pre><code>
  



</code></pre> 
<p>**「单调递减」**第 739 题 每日温度</p> 
<pre><code>

</code></pre> 
<h2><a id="_739__for_i_in_rangelenT111____while_s_and_Ts1__Ti____________spop____resi__s1__i_if_s_else_0____sappendi_296"></a>第 <strong>739</strong> 题 每日温度``for i in range(len(T)-1,-1,-1):<code> </code>while s and T[s[-1]] &lt;= T[i] : #递减栈<code> </code>s.pop()<code> </code>res[i] = s[-1] - i if s else 0<code> </code>s.append(i)</h2> 
<pre><code>
  

![](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8X1wEorjS3bDLnHiar4vtV5ibBdQV0nVXicyxBznmwreAKcTzDlbYsiaB2vC1ygO11TMiaYgGbicqjOUDg/640?wx_fmt=other&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;tp=webp)

二分模板

  



</code></pre> 
<pre><code># 1355579 T=5 =&gt; 13(5)55579 返回2``# ps[i-1] &lt; ps[i] &lt;= ps[i+1]``bisect.bisect_left(ps, T, L=0, R=len(ns))`  `# 1355579 T=5 =&gt; 13555(5)79 返回5``# ps[i-1] &lt;= ps[i] &lt; ps[i+1]``bisect.bisect_right(ps, T, L=0, R=len(ns))`  `bisect.bisect(ps, T, L=0, R=len(ns))
</code></pre> 
<p>**「中位返回」**第 33 题 搜索旋转排序数组 | 第374题 猜数字大小 | 第69题 x平方根</p> 
<pre><code># 中位返回``while L &lt;= R:`    `M = (L + R) // 2`    `if nums[M] == T:`        `return M`    `elif nums[M] &lt; T:`        `L = M + 1`    `else:`        `R = M - 1
</code></pre> 
<p>**「区域压缩」**第278题 第一个错误版本| 第162题 寻找峰值 | 第153题 寻找数组最小值</p> 
<pre><code># 区域压缩``while L &lt; R:`    `M = (L + R) // 2`    `if need in s[L:M]:`        `R = M`    `else:`        `L = M + 1
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/22/t6JHFyQp_o.png" alt=""></p> 
<p>动态规划模板</p> 
<h5><a id="___339"></a><strong>▐</strong> <strong>单串问题</strong></h5> 
<ul><li> <p>70 爬楼梯问题</p> </li><li> <p>801 使序列递增的最小交换次数</p> </li><li> <p>746 使用最小花费爬楼梯</p> </li><li> <p>300 最长上升子序列</p> </li></ul> 
<pre><code>

`# 依赖前单个元素``dp[i] = dp[i-1] + ns[i]``# 依赖前部区域元素``for i in range(n)`    `for j in range(i)`        `dp[i] = min(dp[i], f(dp[j])`


</code></pre> 
<h5><a id="___362"></a><strong>▐</strong> <strong>单串加状态问题</strong></h5> 
<ul><li>887 鸡蛋掉落</li></ul> 
<pre><code># 鸡蛋掉落``while cur[K] &lt; N:             # 还剩 j 个蛋 测 ans 次 覆盖多少层`    `for j in range(1, K + 1): # 覆盖总层数 碎了 -1 次层数 + 1 + 没碎 -1 次层数`        `cur[j] = prev[j - 1] + 1 + prev[j]`    `ans += 1`    `prev = copy.deepcopy(cur)
</code></pre> 
<ul><li>813 最大平均值分组</li></ul> 
<pre><code>

`# 813 最大平均值分组``for k in range(K-1):            #循环k次`    `for i in range(N):          #每次均依赖上次的结果`        `for j in range(i+1, N):`            `dp[i] = max(dp[i], avrg(i, j) + dp[j])`


</code></pre> 
<ul><li>410 分割数组最大值</li></ul> 
<pre><code>

`# 410 分割数组最大值``for k in range(1,K):`    `for i in range(N):``        for j in range(i):`            `# 0~i中分 k 段最大 即为`            `# 0~j中分k-1段最大 和 j到i的前缀和的最大`            `dp[i][k] = min(dp[i][k], max(dp[j][k-1], ps[i+1] - ps[`


</code></pre> 
<p><strong>▐</strong> <strong>经典双串LCS问题</strong></p> 
<pre><code>

`# 经典双串LCS问题``dp = [[0] * (M+1) for _ in range(N+1)]``for i in range(N):`    `for j in range(M):`        `if t1[i] == t2[j] : dp[i+1][j+1] = dp[i][j] + 1``        else : dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j])`


</code></pre> 
<p><strong><strong>▐</strong></strong> <strong><strong>区间动态规划</strong></strong></p> 
<ul><li> <p>5 最长回文子串</p> </li><li> <p>647 最多回文子串</p> </li><li> <p>516 最长回文子序列</p> </li><li> <p>1312 最长回文插入次数</p> </li></ul> 
<pre><code># dp[i][j] 代表从 i 到 j 的最长子串满足条件的数量``# i-- &lt; j++  ==&gt; i 在 0~j 范围内 --``dp = [[0] * (N) for _ in range(N)]``for j in range(N):`    `dp[j][j] = 1`    `for i in range(j-1,-1,-1):`        `if ss[i] == ss[j]:`            `dp[i][j] = dp[i+1][j-1] +2`        `else :`            `dp[i][j] = max(dp[i+1][j],dp[i][j-1])
</code></pre> 
<h5><a id="___436"></a><strong>▐</strong> <strong>区间分治动态规划</strong></h5> 
<h5><a id="_438"></a></h5> 
<h5><a id="486_httpsleetcodecncomproblemspredictthewinnerspmata217360100049ae7ec0sfNWbz_440"></a>486 预测赢家：https://leetcode-cn.com/problems/predict-the-winner/?spm=ata.21736010.0.0.49ae7ec0sfNWbz</h5> 
<h5><a id="312_httpsataatatechorgarticleshttpsleetcodecncomproblemsburstballoonsspmata217360100049ae7ec0sfNWbz_442"></a>312 戳气球：https://ata.atatech.org/articles/***https://leetcode-cn.com/problems/burst-balloons/***?spm=ata.21736010.0.0.49ae7ec0sfNWbz</h5> 
<h5><a id="664_httpsataatatechorgarticleshttpsleetcodecncomproblemsstrangeprinterspmata217360100049ae7ec0sfNWbz_444"></a>664 奇怪的打印机：https://ata.atatech.org/articles/***https://leetcode-cn.com/problems/strange-printer/***?spm=ata.21736010.0.0.49ae7ec0sfNWbz</h5> 
<h5><a id="546_httpsataatatechorgarticleshttpsleetcodecncomproblemsremoveboxesspmata217360100049ae7ec0sfNWbz_446"></a>546 移除盒子：https://ata.atatech.org/articles/***https://leetcode-cn.com/problems/remove-boxes/***?spm=ata.21736010.0.0.49ae7ec0sfNWbz</h5> 
<pre><code>

</code></pre> 
<p><code># 区间分治动态规划</code></p> 
<p><code>def helper(self, ns: List[int]) :</code> <code>N = len(ns)</code> <code>dp = [[0] * N for _ in range(N+1)]</code> <code>for l in range(N): # 长度从小到大</code> <code>for i in range(N-l): # 以 i 为 开头</code> <code>j = i + l # 以 j 为 终点</code> <code>for k in range(i,j): # 以 k 为分割点，进行分治``// Todo 业务逻辑</code></p> 
<pre><code>
  



</code></pre> 
<p><strong>「卡特兰数」</strong></p> 
<pre><code># 卡特兰数``g(n) = g(0)*g(n-1) + g(1)*g(n-2) ...g(n-1)*g(0)``dp=[1] + [0] * n``for i in range(1,n+1):`    `for j in range(1,i+1):`        `dp[i] += dp[j-1] * dp[i-j]
</code></pre> 
<p><img src="https://images2.imgbox.com/df/66/qumTMtnd_o.png" alt=""></p> 
<p>滑动窗口</p> 
<pre><code>

</code></pre> 
<p><code>"""给定待查串s和目标串t"""``nd, wd = {}, {}``nd = collections.Counter(s1)``L, R = 0, 0``cnt = 0 # 满足条件个数``while R &lt; len(s): # 窗口右边界不断扩大，本质是搜索问题的可能解</code> <code>c = s[R] # 即将加入到窗口中的字符</code> <code>R += 1</code> <code>更新窗口中的数据</code> <code>while 满足窗口收缩条件：# 窗口的左边界收缩，本质是优化可行解</code> <code>记录或返回结果</code> <code>d = s[L] # 即将从窗口中删除的字符</code> <code>L += 1</code> <code>更新窗口中的数据``return 结果`` ``# 固定窗口 ,比滑动窗口更快一些``i = j = cnt = 0</code> <code>for j in range(len(A)):</code> <code>if A[j] == 0:`` cnt += 1</code> <code>if cnt &gt; K: #不满足时 平移</code> <code>if A[i] == 0:</code> <code>cnt -= 1</code> <code>i += 1``return j - i + 1</code> <code> ``for j in range(len(A)):</code> <code>if A[j] == 0:</code> <code>cnt += 1</code> <code>while cnt &gt; K:</code> <code>if A[i] == 0:</code> <code>cnt -= 1</code> <code>i += 1</code> <code>res = max(res, j - i + 1)``return res</code></p> 
<pre><code>
  

![](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnjuibb0x6cgXJvhur1ibsksniaysN9gt5lzDAtnaqOWEJNdFNQJOlkylJK27HmhJnLDPfEsu2ibzcajh0sQ/640?wx_fmt=png)

前缀和

  



</code></pre> 
<p><strong>「累加和存位置」</strong></p> 
<p>1371 最长偶数元音子数组</p> 
<p>525 最长相等01子数组</p> 
<p>325 最长和为k 子数组</p> 
<pre><code># 前缀和初始化``psd = {0: -1}`  `for i in range(len(s)):`    `t ^= cd.get(s[i], 0) # 业务逻辑`    `if t not in psd:`        `psd[t] = i       # 第一次存入数组`    `else:`        `ans = max(ans, i - psd[t]) #已存入则开始计算
</code></pre> 
<p><strong>「累加和存数量」</strong></p> 
<ul><li> <p>560 和为K的子数组数量</p> </li><li> <p>统计优美子数组</p> </li></ul> 
<pre><code># 累加和存数量``psd = {0:1}``for i in range(len(ns)):`    `s += ns[i]`    `if s - T in psd:`        `ans += psd[s - T] # 存数量`    `psd[s] = psd.get(s,0) + 1
</code></pre> 
<p><strong>「模K状态前缀和」</strong></p> 
<ul><li> <p>523 连续和为 k 倍 的子数组（存索引）</p> </li><li> <p>974 和被k 整除 子数组数量（存数量）</p> </li></ul> 
<pre><code># 模K状态前缀和``psd = {0:-1}``ans = s = 0``for i in range(len(ns)):`    `s += ns[i]                # 业务逻辑`    `if T != 0: s %= abs(T)    # 模k状态做key，索引做值`    `if s not in psd:`        `psd[s] = i`    `elif i - psd[s] &gt; 1:`        `return True
</code></pre> 
<p><strong>「矩阵前缀和」</strong></p> 
<ul><li> <p>363 不超过K的最大数值和</p> </li><li> <p>1074 和为目标值的子矩阵数量</p> </li></ul> 
<pre><code># 矩阵前缀和``for i in range(m):        #固定左边界`    `ps = [0] * n`    `for j in range(i, m): #固定右边界`        `psS = 0``        dct = {0:1}       #初始只有一种可能`        `for k in range(n): # 以高做前缀和`            `ps[k] += mtx[j][k]          # 每行前缀和`            `psS += ps[k]                # n行前缀和`            `cnt += dct.get(psS - T, 0)  # 满足条件cnt`            `dct[psS] = dct.get(psS,0) + 1 # 保存当前状态``return cnt
</code></pre> 
<p><img src="https://images2.imgbox.com/c6/e9/GbB6bfUE_o.png" alt=""></p> 
<p>双指针</p> 
<pre><code># 双指针``def removeElement(self, ns: List[int], val: int) -&gt; int:`    `slow = 0`    `n = len(ns)`    `for fast in range(n):`        `if ns[fast] != val:`            `ns[slow] = ns[fast]`            `slow += 1`    `return slow
</code></pre> 
<p><img src="https://images2.imgbox.com/09/8e/uOL28qcG_o.png" alt=""></p> 
<p>深度优先</p> 
<p><strong>「二叉树遍历模板」</strong></p> 
<pre><code># 递归``# 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。``# 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)``   ``# 递归1：二叉树遍历最易理解和实现版本``class Solution:`    `def preOrd(self, root: TreeNode) -&gt; List[int]:`        `if not root:`            `return []`        `# 前序递归`        `return [root.val] + self.preOrd(root.left) + self.preOrd(root.right)`        `# # 中序递归``        # return self.inOrd(root.left) + [root.val] + self.inOrd(root.right)`        `# # 后序递归`        `# return self.postOrd(root.left) + self.postOrd(root.right) + [root.val]``   ``# 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值``class Solution:`    `def preOrd(self, root: TreeNode) -&gt; List[int]:`        `def dfs(cur):`            `if not cur:`                `return``            # 前序递归`            `res.append(cur.val)`            `dfs(cur.left)`            `dfs(cur.right)``            # # 中序递归`            `# dfs(cur.left)`            `# res.append(cur.val)`            `# dfs(cur.right)`            `# # 后序递归`            `# dfs(cur.left)`            `# dfs(cur.right)`            `# res.append(cur.val)``        res = []`        `dfs(root)`        `return res``   ``   ``# 迭代``# 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。``# 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)``# 迭代1：前序遍历最常用模板（后序同样可以用）``class Solution:`    `def preOrd(self, root: TreeNode) -&gt; List[int]:`        `if not root:`            `return []``        res = []`        `stack = [root]`        `# # 前序迭代模板：最常用的二叉树DFS迭代遍历模板`        `while stack:`            `cur = stack.pop()`            `res.append(cur.val)`            `if cur.right:`                `stack.append(cur.right)`            `if cur.left:`                `stack.append(cur.left)`        `return res``   `        `# # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转`        `# while stack:`        `#     cur = stack.pop()`        `#     if cur.left:`        `#         stack.append(cur.left)`        `#     if cur.right:`        `#         stack.append(cur.right)`        `#     res.append(cur.val)`        `# return res[::-1]``   ``# 迭代1：层序遍历最常用模板``class Solution:`    `def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:`        `if not root:`            `return []`        `q = deque([root])`        `res = []`        `while q :`            `l = []`            `for i in range(len(q)) :`                `t = q.popleft()`                `l.append(t.val)`                `if t.left : q.append(t.left)`                `if t.right : q.append(t.right)`            `res.append(l)`        `return res``   ``   ``# 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）``class Solution:`    `def inOrd(self, root: TreeNode) -&gt; List[int]:``        res = []`        `stack = []`        `cur = root`        `# 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作`        `while stack or cur:`            `while cur:`                `stack.append(cur)`                `cur = cur.left`            `cur = stack.pop()`            `res.append(cur.val)`            `cur = cur.right`        `return res``   `        `# # 前序，相同模板`        `# while stack or cur:`        `#     while cur:`        `#         res.append(cur.val)`        `#         stack.append(cur)`        `#         cur = cur.left`        `#     cur = stack.pop()`        `#     cur = cur.right`        `# return res``   `        `# # 后序，相同模板`        `# while stack or cur:`        `#     while cur:`        `#         res.append(cur.val)`        `#         stack.append(cur)`        `#         cur = cur.right`        `#     cur = stack.pop()`        `#     cur = cur.left`        `# return res[::-1]``   ``   ``# 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：``# 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，``# 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。``class Solution:`    `def preOrd(self, root: TreeNode) -&gt; List[int]:`        `res = []`        `stack = [(0, root)]`        `while stack:`            `flag, cur = stack.pop()`            `if not cur: continue`            `if flag == 0:`                `# 前序，标记法`                `stack.append((0, cur.right))`                `stack.append((0, cur.left))`                `stack.append((1, cur))``   `                `# # 后序，标记法`                `# stack.append((1, cur))`                `# stack.append((0, cur.right))`                `# stack.append((0, cur.left))``   `                `# # 中序，标记法`                `# stack.append((0, cur.right))`                `# stack.append((1, cur))`                `# stack.append((0, cur.left))``            else:`                `res.append(cur.val)``        return res``   `        `# # 层序，标记法`        `# res = []`        `# queue = [(0, root)]`        `# while queue:`        `#     flag, cur = queue.pop(0)  # 注意是队列，先进先出`        `#     if not cur: continue`        `#     if flag == 0:`                  `# 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素`        `#         queue.append((1, cur))`        `#         queue.append((0, cur.left))`        `#         queue.append((0, cur.right))`        `#     else:`        `#         res.append(cur.val)`        `# return res``   ``   ``   ``# 莫里斯遍历``# 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)``# 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。``# 如果将结果储存最后输出，则空间复杂度还是O(n)。``   ``# PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，``# 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点``   ``# 此处只给出中序遍历，前序遍历只需修改输出顺序即可``# 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出``# 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，``# 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。``   ``# 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）``class Solution:`    `def inOrd(self, root: TreeNode) -&gt; List[int]:`        `res = []`        `# cur = pre = TreeNode(None)`        `cur = root``   `        `while cur:`            `if not cur.left:`                `res.append(cur.val)`                `# print(cur.val)`                `cur = cur.right`            `else:`                `pre = cur.left`                `while pre.right and pre.right != cur:`                    `pre = pre.right`                `if not pre.right:`                    `# print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别`                    `pre.right = cur`                    `cur = cur.left`                `else:`                    `pre.right = None`                    `res.append(cur.val)`                    `# print(cur.val)`                    `cur = cur.right`        `return res``   ``   ``# N叉树遍历``# 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。``# 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。``# 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。``   ``   ``# N叉树简洁递归``class Solution:`    `def preorder(self, root: 'Node') -&gt; List[int]:`        `if not root: return []`        `res = [root.val]`        `for node in root.children:`            `res.extend(self.preorder(node))`        `return res``   ``# N叉树通用递归模板``class Solution:`    `def preorder(self, root: 'Node') -&gt; List[int]:`        `res = []`        `def helper(root):`            `if not root:`                `return`            `res.append(root.val)`            `for child in root.children:`                `helper(child)`        `helper(root)`        `return res``   ``# N叉树迭代方法``class Solution:`    `def preorder(self, root: 'Node') -&gt; List[int]:`        `if not root:`            `return []`        `s = [root]`        `# s.append(root)`        `res = []`        `while s:`            `node = s.pop()`            `res.append(node.val)`            `# for child in node.children[::-1]:`            `#     s.append(child)`            `s.extend(node.children[::-1])`        `return res
</code></pre> 
<pre><code>

  

![](https://mmbiz.qpic.cn/mmbiz_png/33P2FdAnju8ibibjtBVabQNgGGzUMQ2HdNueaUgpu2E8dkXQbial78FKOfQt1tX77fic97CBsdskSuCicd0ZibKmvlzA/640?wx_fmt=png&amp;from=appmsg)

广度优先

  

</code></pre> 
<p><code># 「**无向图的遍历**」``q = collections.deque([i])``while q:</code> <code>cur = q.popleft()``for nxt in dt[cur]:``if not vst[nxt]:</code> <code>vstd[nxt] = True</code> <code>q.append(nxt)</code></p> 
<pre><code>
  



</code></pre> 
<pre><code># 「**二叉树层序遍历**」``q = deque([root])``res = []``while q :`    `l = []`    `for i in range(len(q)) :`        `t = q.popleft()`        `l.append(t.val)`        `if t.left : q.append(t.left)`        `if t.right : q.append(t.right)`    `res.append(l)``return res
</code></pre> 
<p><img src="https://images2.imgbox.com/39/ce/nD8YHutL_o.png" alt=""></p> 
<pre><code>

图论


</code></pre> 
<pre><code>

</code></pre> 
<p>#「Dijkstra最短路径」<code>dic = collections.defaultdict(list)</code>for u, v, w in edges:<code> </code>dic[u].append([v, w])<code> </code>dic[v].append([u, w])<code>q = [(0, n)]</code>dist = [-1] * (n + 1)``while q:<code> </code>dis, cur = heapq.heappop(q)<code> </code>if dist[cur] &lt; 0:<code> </code>dist[cur] = dis<code> </code>for nxt, wi in dic[cur]:<code> </code>heapq.heappush(q, [dis + wi, nxt])</p> 
<pre><code>
  



</code></pre> 
<p><strong>「Floyd 求图中路径」</strong></p> 
<pre><code># Floyd算法 求图中任意2点距离``ds = defaultdict(int)``st = set()``for i, (x, y) in enumerate(ess):`    `ds[(x, y)] = vs[i]`    `ds[(y, x)] = 1 / vs[i]`    `st.update({x,y})``arr = list(st)``for k in arr:`    `for i in arr:`        `for j in arr:`            `if ds[(i, k)] and ds[(k, j)]:`                `ds[(i, j)] = ds[(i, k)] * ds[(k, j)]
</code></pre> 
<p>​ <strong>为了帮助大家更好的学习黑客网络安全，我给大家准备了一份黑客网络安全入门/进阶学习资料，里面的内容都是适合零基础小白的笔记和资料，不懂编程也能听懂、看懂这些资料！</strong></p> 
<p>因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取</p> 
<p><a href="https://mp.weixin.qq.com/s/3IwEOvO3tD2m3WalhQFdXQ" rel="nofollow">[2024最新CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享]</a></p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTM0MTYwNw==&amp;mid=2247485343&amp;idx=1&amp;sn=1abafab670cea0773c36c46d394f5538&amp;chksm=ce9fc757f9e84e41c2e86c956b4e93aaf4472b27ff3e94fe89e78f014db6f1b0261b15fa794f&amp;token=1512649782&amp;lang=zh_CN&amp;scene=21#wechat_redirect" rel="nofollow" title="CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享"></a><br> <img src="https://images2.imgbox.com/a4/d4/DAlG6BIV_o.png" alt="在这里插入图片描述"></p> 
<p>因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取</p> 
<p><a href="https://mp.weixin.qq.com/s/3IwEOvO3tD2m3WalhQFdXQ" rel="nofollow">[2024最新CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享]</a><br> <img src="https://images2.imgbox.com/47/2a/aC5FEuWU_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/14/93/37D2issy_o.png" alt="在这里插入图片描述"></p> 
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTM0MTYwNw==&amp;mid=2247485343&amp;idx=1&amp;sn=1abafab670cea0773c36c46d394f5538&amp;chksm=ce9fc757f9e84e41c2e86c956b4e93aaf4472b27ff3e94fe89e78f014db6f1b0261b15fa794f&amp;token=1512649782&amp;lang=zh_CN&amp;scene=21#wechat_redirect" rel="nofollow" title="CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享"></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65a59ef530cd061bd4e87efad6f3d7e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Flutter】webview_flutter使用详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed26d39b417c21976d0b089e717a9513/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信小程序webview和小程序通讯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>