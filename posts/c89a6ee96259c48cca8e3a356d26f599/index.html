<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>重生之“我打数据结构，真的假的？”--2.单链表（完结） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c89a6ee96259c48cca8e3a356d26f599/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="重生之“我打数据结构，真的假的？”--2.单链表（完结）">
  <meta property="og:description" content="1.链表的深拷贝 . - 力扣（LeetCode）
思路：
1.遍历原链表根据结点保存的数据，申请并复制到新的结点，并且插入到该节点后。
2.新结点的随机指向结点 = 原链表结点的随机指向结点的下一个结点！！
3.所有malloc的新节点全部连接起来
struct Node* copyRandomList(struct Node* head) { struct Node* phead = NULL; struct Node* flag = head; struct Node* q = NULL; struct Node* p = NULL; if(head==NULL) return q; while (flag) { q = NULL; q = (struct Node*)malloc(sizeof(struct Node)); q-&gt;next = flag-&gt;next; flag-&gt;next = q; q-&gt;val = flag-&gt;val; flag = q-&gt;next; } flag = head; p = flag-&gt;next; phead = p; while (p-&gt;next) { if (flag-&gt;random == NULL) p-&gt;random = NULL; else { p-&gt;random = flag-&gt;random-&gt;next; } flag = p-&gt;next; p = flag-&gt;next; } if (flag-&gt;random == NULL) p-&gt;random = NULL; else { p-&gt;random = flag-&gt;random-&gt;next; } p=head-&gt;next; while (p-&gt;next) { p-&gt;next=p-&gt;next-&gt;next; p=p-&gt;next; } return phead; } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-19T15:51:17+08:00">
    <meta property="article:modified_time" content="2024-07-19T15:51:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">重生之“我打数据结构，真的假的？”--2.单链表（完结）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.链表的深拷贝</h2> 
<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b8/27/p025VmqI_o.png"></p> 
<p style="text-align:center;"></p> 
<blockquote> 
 <p>思路：</p> 
 <p>1.遍历原链表根据结点保存的数据，申请并复制到新的结点，并且插入到该节点后。</p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/25/91/07w8nVJh_o.jpg"></p> 
 <p> 2.新结点的随机指向结点 = 原链表结点的随机指向结点的下一个结点！！</p> 
 <p>3.所有malloc的新节点全部连接起来</p> 
</blockquote> 
<pre><code class="hljs">struct Node* copyRandomList(struct Node* head) {
    struct Node* phead = NULL;
    struct Node* flag = head;
    struct Node* q = NULL;
    struct Node* p = NULL;
    if(head==NULL)
    return q;
    while (flag) {
        q = NULL;
        q = (struct Node*)malloc(sizeof(struct Node));
        q-&gt;next = flag-&gt;next;
        flag-&gt;next = q;
        q-&gt;val = flag-&gt;val;
        flag = q-&gt;next;
    }
    flag = head;
    p = flag-&gt;next;
    phead = p;
    while (p-&gt;next) {
        if (flag-&gt;random == NULL)
            p-&gt;random = NULL;
        else {
            p-&gt;random = flag-&gt;random-&gt;next;
        }
        flag = p-&gt;next;
        p = flag-&gt;next;
    }
     if (flag-&gt;random == NULL)
            p-&gt;random = NULL;
        else {
            p-&gt;random = flag-&gt;random-&gt;next;
        }
    p=head-&gt;next;
     while (p-&gt;next)
     {
        p-&gt;next=p-&gt;next-&gt;next;
        p=p-&gt;next;
     }
    return phead;
}</code></pre> 
<p style="text-align:center;"></p> 
<h2>2.环形链表|| </h2> 
<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e8/9b/hCspP5Ah_o.png"></p> 
<p></p> 
<blockquote> 
 <p>思路</p> 
 <p>1.先判断是否有环</p> 
 <p>设快指针（一次走两步），慢指针（一次走一步）</p> 
 <p>若二者相遇则有环，若快指针走到NULL；则无环</p> 
 <p>2.标记快慢指针相遇处，为p</p> 
 <p><strong>设q为头；！！！！！！！</strong></p> 
 <p>在p与q相遇前 p=p-&gt;next;q=q-&gt;next;</p> 
 <p>3. p，q相遇时p为入口处；</p> 
 <pre><code class="hljs">struct ListNode *detectCycle(struct ListNode *head) {
    struct ListNode * p=head;
    struct ListNode * q=head;
    if(p==NULL||p-&gt;next==NULL) //判断是否有环
    return NULL;
    do
    {
    p=p-&gt;next;
    q=q-&gt;next-&gt;next;
    if(q==NULL||q-&gt;next==NULL)
    return NULL;
    }while(p!=q);//判断是否有环
    p=head;
    while(p!=q)
    {
        p=p-&gt;next;
        q=q-&gt;next;
    }
    return p;
    
}</code></pre> 
 <p></p> 
</blockquote> 
<h2>3.错题反思</h2> 
<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/34/HVdznbqU_o.png"></p> 
<blockquote> 
 <p>原思路：</p> 
 <p>1.实在想不到什么好办法；如果从a链表首节点开始，每次遍历一遍b表找第一个相同节点太耗费时间，意义不大。</p> 
 <p>2.也想过建立两个栈，让a，b各节点进栈，根据栈的<strong>后进先出</strong>从尾出栈开始比。</p> 
</blockquote> 
<blockquote> 
 <p>答案思路（nb！！！）</p> 
 <p>1. 如果两链表有共同节点</p> 
 <p>设a表头到共同节点的距离为x；</p> 
 <p>b表头到共同节点的距离为y；</p> 
 <p>共同节点到NULL的距离为n；</p> 
 <p>2.while（a！=b）</p> 
 <p>遍历a，b链表；</p> 
 <p>当a为NULL,a=headb;</p> 
 <p>当b为NULL,b=heada;</p> 
 <p>3.a与b必然在共同节点处相遇</p> 
 <p>因为a走的距离为：x+n+y；</p> 
 <p>b走的距离为：y+n+x；</p> 
 <p>4.</p> 
 <p>以a为例：</p> 
 <p>a走完x+n步后，变为headb，再走y步正好为共同节点处</p> 
 <p></p> 
</blockquote> 
<p></p> 
<pre><code class="hljs">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode *A = headA;
    struct ListNode *B = headB;
    while (A != B) {
        A = A ? A-&gt;next : headB;
        B = B ? B-&gt;next : headA;
    }
    return A;
}</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95cf1dbcdd5242796ac4451f65da88cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器人开源调度系统OpenTcs6-架构运行分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45e5c337a49f50a69cb1c7f5de420af4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">单链表＜数据结构 C版＞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>