<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】图论中求最短路径——迪杰斯特拉算法（Dijkstra）、弗洛伊德算法（Floyd） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/da481d2261b45aaac96acc84f61c6a26/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】图论中求最短路径——迪杰斯特拉算法（Dijkstra）、弗洛伊德算法（Floyd）">
  <meta property="og:description" content="目录 最短路径 (*)迪杰斯特拉算法（Dijkstra）迪杰斯特拉算法（Dijkstra）的算法原理： 弗洛伊德算法（Floyd）弗洛伊德算法（Floyd）的算法原理：弗洛伊德算法的（c语言）完整实例： 最短路径 (*) 生活中最短路径问题例如：
交通网络：给定了该网内的n个城市以及这些市之间的相通公路的距离，能否找到城市A城市B之间一条最近的通路呢？
从A地到B地换车次数最少的路径从A地到B地最短的路径（距离最短，行驶时间最短，费用最低） 迪杰斯特拉(Dijkstra)算法–从一个源点到其它各点的最短路径弗洛伊德(Floyd)算法–每一对顶点之间的最短路径Bellman-Ford算法 迪杰斯特拉算法（Dijkstra） 该算法只适用于静态网络网络上边的权值不能为负数
基本思想：设集合S中存放已找到最短路径的顶点，集合 T ＝ V − S T ＝V-S T＝V−S存放当前还未找到最短路径的顶点。
1.初态: S中 只包含源点 v0，v0到其余 各点的弧 为各点当前各点的“最短”路径。
2.从T中选取当前各点的“最短”路径长度中最短的顶点u加入到S中。
3.S加入新的顶点u后，考察顶点 v 0 v_0 v0​到T中剩余顶点的最短路径长度是否可以优化更新：T中各顶点新的最短路径长度值为原来的最短路径长度值、顶点u的最短路径长度值加上u到该顶点的路径长度值中的较小值。
4.重复2，3，直到T的顶点全部加入到S中、或源点到剩余顶点的路径都是∞为止。
一、图的存储：邻接矩阵和邻接表都可以
#define max 100 typedef struct { int arcs[max][max]; int vexnum,arcnum; }AGraphs; Agraphs G；//定义图存储结构 邻接矩阵的存储形式 二、区分已经求出最短路径的点
方法一:设一个一维数组int final[max];
final[i]=1表示从源点到顶点i的最短路径已经求出，i在S中
final[i]=0表示从源点到顶点i的最短路径尚未求出，i在V-S中
方法二：利用邻接矩阵主对角线的位置G.arcs[i][i]表示i是否在S中
G.arcs[i][i]=1表示从源点到顶点i的最短路径已经求出，i在S中
G.arcs[i][i]=0表示从源点到顶点i的最短路径尚未求出，i在V-S中
三、表示源点到顶点i的最短路径
一维数组int D[max]表示最短路径的长度
D[i] ：从源点到点 v i v_i vi​的最短路径的长度
初态为：若从源点 到 v i v_i vi​有弧，则D[i]为弧上的权值；否则置 D[i]为∞ ，即：D[i]=G.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-05T01:07:51+08:00">
    <meta property="article:modified_time" content="2024-06-05T01:07:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】图论中求最短路径——迪杰斯特拉算法（Dijkstra）、弗洛伊德算法（Floyd）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#__1" rel="nofollow">最短路径 (*)</a></li><li><ul><li><a href="#Dijkstra_12" rel="nofollow">迪杰斯特拉算法（Dijkstra）</a></li><li><ul><li><a href="#Dijkstra_64" rel="nofollow">迪杰斯特拉算法（Dijkstra）的算法原理：</a></li></ul> 
   </li><li><a href="#Floyd_116" rel="nofollow">弗洛伊德算法（Floyd）</a></li><li><ul><li><a href="#Floyd_132" rel="nofollow">弗洛伊德算法（Floyd）的算法原理：</a></li><li><a href="#c_160" rel="nofollow">弗洛伊德算法的（c语言）完整实例：</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__1"></a>最短路径 (*)</h2> 
<p>生活中最短路径问题例如：<br> <strong>交通</strong>网络：给定了该网内的n个城市以及这些市之间的相通公路的距离，能否找到城市A城市B之间一条最近的通路呢？</p> 
<ol><li>从A地到B地换车次数最少的路径</li><li>从A地到B地最短的路径（距离最短，行驶时间最短，费用最低）</li></ol> 
<blockquote> 
 <ol><li>迪杰斯特拉(Dijkstra)算法–从一个源点到其它各点的最短路径</li><li>弗洛伊德(Floyd)算法–每一对顶点之间的最短路径</li><li>Bellman-Ford算法</li></ol> 
</blockquote> 
<h3><a id="Dijkstra_12"></a>迪杰斯特拉算法（Dijkstra）</h3> 
<p>该算法只适用于<strong>静态网络网络</strong>上边的权值不能为负数</p> 
<p>基本思想：设集合<code>S</code>中存放<strong>已找到</strong>最短路径的顶点，集合<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         T 
        
       
         ＝ 
        
       
         V 
        
       
         − 
        
       
         S 
        
       
      
        T ＝V-S 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">T</span><span class="mord cjk_fallback">＝</span><span class="mord mathnormal" style="margin-right: 0.2222em;">V</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span></span></span></span></span>存放当前<strong>还未找到</strong>最短路径的顶点。<br> 1.初态: S中 <strong>只包含源点</strong> <code>v0</code>，<code>v0</code>到其余 <strong>各点的弧</strong> 为各点<code>当前各点</code>的“最短”路径。<br> 2.从<code>T</code>中选取当前各点的“最短”路径长度中最短的顶点<code>u</code>加入到<code>S</code>中。<br> 3.<code>S</code>加入新的顶点<code>u</code>后，考察顶点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          0 
         
        
       
      
        v_0 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>到<code>T</code>中剩余顶点的最短路径长度是否可以优化更新：T中各顶点新的最短路径长度值为原来的最短路径长度值、顶点<code>u</code>的最短路径长度值加上<code>u</code>到该顶点的路径长度值中的较小值。<br> 4.重复2，3，直到<code>T</code>的顶点全部加入到<code>S</code>中、或源点到剩余顶点的路径都是<code>∞</code>为止。</p> 
<p><img src="https://images2.imgbox.com/c3/c7/hQbYOS0a_o.png" alt="在这里插入图片描述"></p> 
<p>一、<strong>图的存储</strong>：邻接矩阵和邻接表都可以</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">max</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> arcs<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>AGraphs<span class="token punctuation">;</span>
Agraphs G；<span class="token comment">//定义图存储结构  邻接矩阵的存储形式</span>
</code></pre> 
<p>二、区分<strong>已经求出最短路径</strong>的点</p> 
<p><strong>方法一</strong>:设一个一维数组<code>int final[max];</code><br> <code>final[i]=1</code>表示从源点到顶点<code>i</code>的最短路径已经求出，<code>i</code>在<code>S</code>中<br> <code>final[i]=0</code>表示从源点到顶点<code>i</code>的最短路径尚未求出，<code>i</code>在<code>V-S</code>中</p> 
<p><strong>方法二</strong>：利用<code>邻接矩阵主对角线</code>的位置<code>G.arcs[i][i]</code>表示<code>i</code>是否在<code>S</code>中<br> <code>G.arcs[i][i]=1</code>表示从源点到顶点<code>i</code>的最短路径<code>已经求出</code>，<code>i</code>在<code>S</code>中<br> <code>G.arcs[i][i]=0</code>表示从源点到顶点<code>i</code>的最短路径<code>尚未求出</code>，<code>i</code>在<code>V-S</code>中</p> 
<p>三、表示<strong>源点到顶点i</strong>的<strong>最短路径</strong></p> 
<p>一维数组<code>int D[max]</code>表示<code>最短路径的长度</code><br> <code>D[i] </code>：从源点到点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          i 
         
        
       
      
        v_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的最短路径的长度<br> 初态为：若从源点 到<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          i 
         
        
       
      
        v_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>有弧，则<code>D[i]</code>为弧上的权值；否则置 <code>D[i]</code>为<code>∞</code> ，即：<code>D[i]=G.arcs[k][i]</code>; //说明：k为源点</p> 
<p>二维数组<code>int P[max][max]</code>表示<code>最短路径包含的顶点</code></p> 
<p><code>P[i][ ]</code> ：从源点到点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          i 
         
        
       
      
        v_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的最短路径</p> 
<p><code>P[i][j]=0</code> ： <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          j 
         
        
       
      
        v_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>不在从源点 到点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          i 
         
        
       
      
        v_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的最短路径上</p> 
<p><code>P[i][j]=1</code> ： <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          j 
         
        
       
      
        v_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7167em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>位于从源点 到点<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          v 
         
        
          i 
         
        
       
      
        v_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的最短路径上。</p> 
<h4><a id="Dijkstra_64"></a>迪杰斯特拉算法（Dijkstra）的算法原理：</h4> 
<pre><code class="prism language-cpp">
<span class="token keyword">void</span> <span class="token function">ShortestPath</span><span class="token punctuation">(</span>AGraphs G<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> P<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> D<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">int</span> i<span class="token punctuation">,</span>w<span class="token punctuation">,</span> j<span class="token punctuation">,</span>min<span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
	
		<span class="token keyword">final</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>
		
		D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//最短路径长度</span>
		
		<span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> w <span class="token operator">++</span><span class="token punctuation">)</span> 
			P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化</span>
			
		<span class="token keyword">if</span> <span class="token punctuation">(</span>D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>INFINITY<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//短路径包含的顶点</span>
			P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> 
			P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span>
			
	<span class="token punctuation">}</span>
	
	D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始点</span>
	
	<span class="token keyword">final</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
	
		min<span class="token operator">=</span>INFINITY<span class="token punctuation">;</span><span class="token comment">//初始化为 无穷大</span>
		
		<span class="token keyword">for</span> <span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> w <span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">final</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//</span>
				j<span class="token operator">=</span>w<span class="token punctuation">;</span> 
				min<span class="token operator">=</span>D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> 
			
		<span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">==</span> INFINITY<span class="token punctuation">)</span> <span class="token comment">//</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
			
		<span class="token keyword">final</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//标记为选入</span>
		
		<span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> w <span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">final</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>min<span class="token operator">+</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&lt;</span>D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
				D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token operator">+</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>
				P<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>P<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//？？</span>
				P<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  
			<span class="token punctuation">}</span>
			
	<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="Floyd_116"></a>弗洛伊德算法（Floyd）</h3> 
<p><img src="https://images2.imgbox.com/c8/8d/sCFlQBZg_o.png" alt="在这里插入图片描述"></p> 
<p><strong>图的存储</strong>：邻接矩阵和邻接表都可以</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">max</span> <span class="token expression"><span class="token number">100</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> arcs<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>AGraphs<span class="token punctuation">;</span>
Agraphs G；<span class="token comment">//定义图存储结构  邻接矩阵的存储形式</span>
</code></pre> 
<h4><a id="Floyd_132"></a>弗洛伊德算法（Floyd）的算法原理：</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">s1</span><span class="token punctuation">(</span><span class="token keyword">int</span> D<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Agraphs G<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   

	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>
	
	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span> vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> 
		<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span> vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
			D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> 
				p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>
				<span class="token keyword">if</span><span class="token punctuation">(</span>D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>INFINITY<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
					p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>
					p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//初始化</span>
				<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
	<span class="token keyword">for</span> <span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>G<span class="token punctuation">.</span> vexnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> 
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span> vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> 
				<span class="token keyword">if</span><span class="token punctuation">(</span>D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//是否K 加入能够减小路径长度</span>
					D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//如果可以 就加入</span>
					<span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">&lt;</span>G<span class="token punctuation">.</span> vexnum<span class="token punctuation">;</span>w<span class="token operator">++</span><span class="token punctuation">)</span> 
						p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">||</span>p<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//然后确定路径上的元素</span>
				<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="c_160"></a>弗洛伊德算法的（c语言）完整实例：</h4> 
<pre><code class="prism language-cpp"><span class="token comment">//算法6.11　弗洛伊德算法</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span>  <span class="token keyword">namespace</span>  std<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">MaxInt</span>  <span class="token expression"><span class="token number">32767</span>       </span><span class="token comment">//表示极大值，即∞</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">MVNum</span>  <span class="token expression"><span class="token number">100</span>           </span><span class="token comment">//最大顶点数</span></span>

<span class="token keyword">typedef</span>  <span class="token keyword">char</span>  VerTexType<span class="token punctuation">;</span>  <span class="token comment">//假设顶点的数据类型为字符型  </span>
<span class="token keyword">typedef</span>  <span class="token keyword">int</span>  ArcType<span class="token punctuation">;</span>   <span class="token comment">//假设边的权值类型为整型  </span>

<span class="token keyword">int</span>  Path<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span>                                                <span class="token comment">//最短路径上顶点vj的前一顶点的序号</span>
<span class="token keyword">int</span>  D<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span>                                                <span class="token comment">//记录顶点vi和vj之间的最短路径长度</span>

<span class="token comment">//------------图的邻接矩阵---------------</span>
<span class="token keyword">typedef</span>  <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>  
        VerTexType  vexs<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//顶点表  ？</span>
        ArcType  arcs<span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">[</span>MVNum<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//邻接矩阵  </span>
        <span class="token keyword">int</span>  vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span>         <span class="token comment">//图的当前点数和边数  </span>
<span class="token punctuation">}</span>AMGraph<span class="token punctuation">;</span>



<span class="token keyword">int</span>  <span class="token function">LocateVex</span><span class="token punctuation">(</span>AMGraph  G  <span class="token punctuation">,</span>  VerTexType  v<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//确定点v在G中的位置</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span>  i  <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>  i  <span class="token operator">&lt;</span>  G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>  <span class="token operator">++</span>i<span class="token punctuation">)</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token operator">==</span>  v<span class="token punctuation">)</span>
                        <span class="token keyword">return</span>  i<span class="token punctuation">;</span>
                <span class="token keyword">return</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//LocateVex</span>

<span class="token keyword">void</span>  <span class="token function">CreateUDN</span><span class="token punctuation">(</span>AMGraph  <span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token comment">//采用邻接矩阵表示法，创建有向网G  </span>
        <span class="token keyword">int</span>  i <span class="token punctuation">,</span> j  <span class="token punctuation">,</span> k<span class="token punctuation">;</span>
        <span class="token comment">//cout  &lt;&lt;"请输入总顶点数，总边数，以空格隔开:";</span>
        cin  <span class="token operator">&gt;&gt;</span>  G<span class="token punctuation">.</span>vexnum  <span class="token operator">&gt;&gt;</span>  G<span class="token punctuation">.</span>arcnum<span class="token punctuation">;</span>                                                        <span class="token comment">//输入总顶点数，总边数</span>

        <span class="token comment">//cout  &lt;&lt;  "输入点的名称，如a"  &lt;&lt;  endl;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span>i  <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>  i  <span class="token operator">&lt;</span>  G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>  <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>      
                <span class="token comment">//cout  &lt;&lt;  "请输入第"  &lt;&lt;  (i+1)  &lt;&lt;  "个点的名称:";</span>
                cin  <span class="token operator">&gt;&gt;</span>  G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                                                                        <span class="token comment">//依次输入点的信息  </span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i  <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>  i  <span class="token operator">&lt;</span>  G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>  <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                                        <span class="token comment">//初始化邻接矩阵，边的权值均置为极大值MaxInt  </span>
                <span class="token keyword">for</span><span class="token punctuation">(</span>j  <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>  j  <span class="token operator">&lt;</span>  G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>  <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>    
                        <span class="token keyword">if</span><span class="token punctuation">(</span>j  <span class="token operator">!=</span>  i<span class="token punctuation">)</span>
                            G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token operator">=</span>  MaxInt<span class="token punctuation">;</span>    
                        <span class="token keyword">else</span>
                            G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token comment">//for</span>
        <span class="token punctuation">}</span><span class="token comment">//for  //初始化</span>

        <span class="token comment">//cout  &lt;&lt;  "输入边依附的顶点及权值，如a  b  3"  &lt;&lt;  end；</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span>k  <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>  k  <span class="token operator">&lt;</span>  G<span class="token punctuation">.</span>arcnum<span class="token punctuation">;</span><span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>                                                <span class="token comment">//构造邻接矩阵  </span>
            VerTexType  v1  <span class="token punctuation">,</span>  v2<span class="token punctuation">;</span>
            ArcType  w<span class="token punctuation">;</span>

        <span class="token comment">//cout  &lt;&lt;  "请输入第"  &lt;&lt;  (k  +  1)  &lt;&lt;  "条边依附的顶点及权值:";</span>
            cin  <span class="token operator">&gt;&gt;</span>  v1  <span class="token operator">&gt;&gt;</span>  v2  <span class="token operator">&gt;&gt;</span>  w<span class="token punctuation">;</span>                                                      <span class="token comment">//输入一条边依附的顶点及权值</span>
            i  <span class="token operator">=</span>  <span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>  v1<span class="token punctuation">)</span><span class="token punctuation">;</span>    j  <span class="token operator">=</span>  <span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>  v2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//确定v1和v2在G中的位置，即顶点数组的下标  </span>
            G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token operator">=</span>  w<span class="token punctuation">;</span>                                                                <span class="token comment">//边&lt;v1,  v2&gt;的权值置为w  </span>
        <span class="token punctuation">}</span><span class="token comment">//for</span>
<span class="token punctuation">}</span><span class="token comment">//CreateUDN  </span>

<span class="token comment">/*
【样例输入】

4 5

A B C D 

A B 2 

A C 4

B C 3

B D 5

C D 1

A D

【样例输出】

5

*/</span>

<span class="token keyword">void</span>  <span class="token function">ShortestPath_Floyed</span><span class="token punctuation">(</span>AMGraph  G<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>   

<span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>

	<span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span> <span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 距离矩阵初始化</span>
			
                        Path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>		<span class="token comment">// 路径矩阵初始化</span>
                        
                        <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span>MaxInt<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                Path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">for</span><span class="token punctuation">(</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>k<span class="token operator">++</span> <span class="token punctuation">)</span>     
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">for</span><span class="token punctuation">(</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span> <span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span><span class="token punctuation">(</span> D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> D<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 动态更新距离矩阵</span>
					Path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Path<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 动态更新路径矩阵</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

        <span class="token comment">//test   看每个矩阵的结果</span>

        <span class="token comment">// 	printf("\nG.arc矩阵的结果如下：\n");</span>
	<span class="token comment">// for( i=0;i&lt;G.vexnum;i++ )     // 输出</span>
	<span class="token comment">// {<!-- --></span>
	<span class="token comment">// 	for( j=0;j&lt;G.vexnum;j++ )</span>
	<span class="token comment">// 	{<!-- --></span>
	<span class="token comment">// 		printf("%d  ",G.arcs[i][j]);</span>
	<span class="token comment">// 	}</span>
	<span class="token comment">// 	printf("\n");</span>
	<span class="token comment">// }</span>

        <span class="token comment">// 	printf("\n距离矩阵的结果如下：\n");</span>
	<span class="token comment">// for( i=0;i&lt;G.vexnum;i++ )     // 输出</span>
	<span class="token comment">// {<!-- --></span>
	<span class="token comment">// 	for( j=0;j&lt;G.vexnum;j++ )</span>
	<span class="token comment">// 	{<!-- --></span>
	<span class="token comment">// 		printf("%d  ",D[i][j]);</span>
	<span class="token comment">// 	}</span>
	<span class="token comment">// 	printf("\n");</span>
	<span class="token comment">// }</span>

	<span class="token comment">// printf("\n路径矩阵的结果如下：\n");</span>
	<span class="token comment">// for( i=0;i&lt;G.vexnum;i++ )     // 输出</span>
	<span class="token comment">// {<!-- --></span>
	<span class="token comment">// 	for( j=0;j&lt;G.vexnum;j++ )</span>
	<span class="token comment">// 	{<!-- --></span>
	<span class="token comment">// 		printf("%d  ",Path[i][j]);</span>
	<span class="token comment">// 	}</span>
	<span class="token comment">// 	printf("\n");</span>
	<span class="token comment">// }</span>

<span class="token punctuation">}</span>


<span class="token keyword">void</span>  <span class="token function">DisplayPath</span><span class="token punctuation">(</span>AMGraph  G  <span class="token punctuation">,</span>  <span class="token keyword">int</span>  begin  <span class="token punctuation">,</span><span class="token keyword">int</span>  temp  <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//显示最短路径</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Path<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">[</span>temp<span class="token punctuation">]</span>  <span class="token operator">!=</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token function">DisplayPath</span><span class="token punctuation">(</span>G  <span class="token punctuation">,</span>  begin  <span class="token punctuation">,</span>Path<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                cout  <span class="token operator">&lt;&lt;</span>  G<span class="token punctuation">.</span>vexs<span class="token punctuation">[</span>Path<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token operator">&lt;&lt;</span>  <span class="token string">"--&gt;"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment">//DisplayPath</span>

<span class="token keyword">int</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//cout  &lt;&lt;  "************算法6.11　弗洛伊德算法**************"  &lt;&lt;  endl  &lt;&lt;  endl;</span>
        AMGraph  G<span class="token punctuation">;</span>
        <span class="token keyword">char</span>  start  <span class="token punctuation">,</span>  destination<span class="token punctuation">;</span>
        <span class="token keyword">int</span>  num_start  <span class="token punctuation">,</span>  num_destination<span class="token punctuation">;</span>

        <span class="token function">CreateUDN</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//test</span>
        <span class="token comment">//cout  &lt;&lt;  "有向网G创建完成！"  &lt;&lt;  endl;</span>
        <span class="token comment">//test</span>

        <span class="token comment">//需要完成的函数</span>
        <span class="token function">ShortestPath_Floyed</span><span class="token punctuation">(</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//需要完成的函数</span>

        <span class="token comment">//test</span>
        <span class="token comment">//cout  &lt;&lt;  "请依次输入路径的起点与终点的名称：";</span>
        <span class="token comment">//test</span>

        cin  <span class="token operator">&gt;&gt;</span>  start  <span class="token operator">&gt;&gt;</span>  destination<span class="token punctuation">;</span>
        num_start  <span class="token operator">=</span>  <span class="token function">LocateVex</span><span class="token punctuation">(</span>G  <span class="token punctuation">,</span>  start<span class="token punctuation">)</span><span class="token punctuation">;</span>
        num_destination  <span class="token operator">=</span>  <span class="token function">LocateVex</span><span class="token punctuation">(</span>G  <span class="token punctuation">,</span>  destination<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//DisplayPath(G  ,  num_start  ,  num_destination);</span>
        <span class="token comment">//cout  &lt;&lt;  G.vexs[num_destination]  &lt;&lt;  endl;</span>

        cout  <span class="token operator">&lt;&lt;</span>  D<span class="token punctuation">[</span>num_start<span class="token punctuation">]</span><span class="token punctuation">[</span>num_destination<span class="token punctuation">]</span>  <span class="token operator">&lt;&lt;</span>  endl<span class="token punctuation">;</span>

        <span class="token keyword">return</span>  <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//main </span>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/27d8e68ca1e98f5191d973664b49e7ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构与算法 经典例题】反转链表(图文详解)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/955218105844c0913138978322ee6088/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python 绿色版制作总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>