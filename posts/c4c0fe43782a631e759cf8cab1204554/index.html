<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】单链表：数据结构中的舞者，穿梭于理论与实践的舞池 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c4c0fe43782a631e759cf8cab1204554/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】单链表：数据结构中的舞者，穿梭于理论与实践的舞池">
  <meta property="og:description" content="欢迎来到白刘的领域 Miracle_86.-CSDN博客 系列专栏 数据结构与算法 先赞后看，已成习惯 创作不易，多多支持！ 一、链表的概念和结构 1.1 链表的概念 在上一篇文章中，我们了解了线性表(linear list)，并且学习了其中一种线性表——顺序表(Sequence List)。链表也是线性表的一种，那么它是一种什么样的结构呢？
链表，顾名思义，带着链子的表。日常生活中，我们知道链子是用来链接两个东西的，那么我们可以很容易理解，顺序表是基于数组实现的，是一个元素一个元素挨着的，那链表我们就可以理解为每个元素用链子连接起来，这样就形成了链表(Linked List)。
1.2 链表的结构 那么我们得到了两个链表的组成的关键元素，一个是每个元素，我们管它叫节点(或结点)，另一个就是那个链子。而在C语言中，我们用结构体来实现节点，用指针来充当链，连接两个节点。
在生活中链表类似于我们的火车的结构，在物理上它是一种存储结构非顺序非连续的结构。
节点的组成主要由两个部分组成：一个是数值域，用来保存当前节点的数据，一个是指针域，用来保存下一个节点的地址(指针变量)。
如图所示，指针变量plist保存的是第一个节点的地址，如果我们想让plist指向第二个节点，我们只需要将plist保存的内容修改为0x0012FFD0。
为什么我们需要指针变量来保存下一个节点的位置？
因为之前我们说了，链表不同于顺序表，它在内存中的地址不一定是连续的，它是独立申请的(对其插入数据时才申请一个节点)。我们需要通过指针才能从当前节点找到下一个节点。
所以我们可以通过一个结构体来实现一个节点，它要有一个节点的数据以及一个指针变量来保存下一个节点的地址，代码如下：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 当然我们也可以用typedef来进行修改，方便我们后续操作。
typedef int SLTDataType; typedef struct SListNode { SLTDataType data; //节点数据 struct SListNode* next; //指针保存下⼀个节点的地址 }SLTNode; 我们如何将链表进行打印呢？
首先我们将节点传到打印函数，然后我们创建了一个指向头结点的结构体指针，利用循环从头遍历到尾，每次打印完成令pcur指向pcur的next节点。这里注意的就是结构体成员的访问的问题，我们用到了-&gt;操作符，在前面的博客我们都介绍过。
武器大师——操作符详解（下）-CSDN博客
代码如下：
void SLTPrint(SLTNode* phead){ SLTNode *cur = phead; while(cur){ printf(&#34;%d &#34;,cur-&gt;data); cur = cur-&gt;next; } printf(&#34;\n&#34;); } 二、单链表的实现 上面我们知道了什么是链表，那单链表又是什么呢？单链表(Singly Linked List)，一般所指的是“不带头单向不循环链表”。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T16:12:05+08:00">
    <meta property="article:modified_time" content="2024-07-08T16:12:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】单链表：数据结构中的舞者，穿梭于理论与实践的舞池</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="text-align:center;"><strong> <span style="color:#38d8f0;">欢迎来到白刘的领域</span>   </strong><a href="https://blog.csdn.net/Miracle_86?type=blog" title="Miracle_86.-CSDN博客">Miracle_86.-CSDN博客</a></h4> 
<h4 style="text-align:center;"><strong>         <span style="color:#ff9900;">系列专栏</span>   </strong><a href="https://blog.csdn.net/miracle_86/category_12649583.html?spm=1001.2014.3001.5482" title="数据结构与算法">数据结构与算法</a></h4> 
<h4 style="text-align:center;"><span style="color:#a2e043;"><strong>先赞后看，已成习惯</strong></span></h4> 
<h4 style="text-align:center;"><span style="color:#956fe7;">   创作不易，多多支持！</span></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/12/c5/18FrK6Ow_o.gif"></p> 
<h3 style="background-color:transparent;">一、链表的概念和结构</h3> 
<h4>1.1 链表的概念</h4> 
<p>在上一篇文章中，我们了解了线性表(linear list)，并且学习了其中一种线性表——顺序表(Sequence List)<strong>。</strong>链表也是线性表的一种，那么它是一种什么样的结构呢？</p> 
<p>链表，顾名思义，带着链子的表。日常生活中，我们知道链子是用来链接两个东西的，那么我们可以很容易理解，顺序表是基于数组实现的，是一个元素一个元素挨着的，那链表我们就可以理解为每个元素用链子连接起来，这样就形成了链表(Linked List)。</p> 
<h4>1.2 链表的结构</h4> 
<p>那么我们得到了两个链表的组成的关键元素，一个是每个元素，我们管它叫节点(或结点)，另一个就是那个链子。而在C语言中，我们用结构体来实现节点，用指针来充当链，连接两个节点。</p> 
<p>在生活中链表类似于我们的火车的结构，在物理上它是一种存储结构非顺序非连续的结构。</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/7b/5f/CCS1Jbav_o.png" width="696"></p> 
<p>节点的组成主要由两个部分组成：一个是数值域，用来保存当前节点的数据，一个是指针域，用来保存下一个节点的地址(指针变量)。</p> 
<p><img alt="" height="165" src="https://images2.imgbox.com/d1/55/bk3376P7_o.png" width="940"></p> 
<p>如图所示，指针变量plist保存的是第一个节点的地址，如果我们想让plist指向第二个节点，我们只需要将plist保存的内容修改为0x0012FFD0。</p> 
<p>为什么我们需要指针变量来保存下一个节点的位置？</p> 
<p>因为之前我们说了，链表不同于顺序表，它在内存中的地址不一定是连续的，它是独立申请的(对其插入数据时才申请一个节点)。我们需要通过指针才能从当前节点找到下一个节点。</p> 
<p>所以我们可以通过一个结构体来实现一个节点，它要有一个节点的数据以及一个指针变量来保存下一个节点的地址，代码如下：</p> 
<pre><code class="language-cpp">struct SListNode
{
	int data; //节点数据
	struct SListNode* next; //指针变量⽤保存下⼀个节点的地址
};</code></pre> 
<p>当然我们也可以用typedef来进行修改，方便我们后续操作。</p> 
<pre><code class="language-cpp">typedef int SLTDataType;

typedef struct SListNode
{
	SLTDataType data; //节点数据
	struct SListNode* next; //指针保存下⼀个节点的地址
}SLTNode;</code></pre> 
<p>我们如何将链表进行打印呢？</p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/9f/5f/chyyTY2V_o.png" width="685"></p> 
<p>首先我们将节点传到打印函数，然后我们创建了一个指向头结点的结构体指针，利用循环从头遍历到尾，每次打印完成令pcur指向pcur的next节点。这里注意的就是结构体成员的访问的问题，我们用到了-&gt;操作符，在前面的博客我们都介绍过。</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/Miracle_86/article/details/136435836?spm=1001.2014.3001.5502" title="武器大师——操作符详解（下）-CSDN博客">武器大师——操作符详解（下）-CSDN博客</a></p> 
</blockquote> 
<p>代码如下：</p> 
<pre><code class="language-cpp">void SLTPrint(SLTNode* phead){
    SLTNode *cur = phead;
    while(cur){
        printf("%d ",cur-&gt;data);
        cur = cur-&gt;next;
    }
    printf("\n");
}</code></pre> 
<h3> 二、单链表的实现</h3> 
<p>上面我们知道了什么是链表，那单链表又是什么呢？单链表(Singly Linked List)，一般所指的是“<strong>不带头单向不循环链表</strong>”。</p> 
<p>我们实现的功能无非就四个“增、删、查、改”。</p> 
<h4>2.1 增</h4> 
<h5>2.1.1 尾插</h5> 
<p>尾插，顾名思义，在尾部插入，<s>俗称后入</s>(bushi)。</p> 
<p>首先我们要申请新的节点，我们可以写一个申请节点的函数。</p> 
<pre><code class="language-cpp">SLTNode* BuyNode(SLTDataType x) {
    SLTNode* node = (SLTNode*)malloc(sizeof(SLTNode));
    if (node == NULL) {
        perror("malloc fail!\n");
        exit(1);
    }
    node-&gt;data = x;
    node-&gt;next = NULL;
    return node;
}</code></pre> 
<p>首先我们用malloc函数动态申请一块内存，然后将节点的数据赋进去。</p> 
<pre><code class="language-cpp">void SLTPushBack(SLTNode** pphead, SLTDataType x) {
    assert(pphead);
    SLTNode* node = BuyNode(x);
    if (*pphead == NULL) {
        *pphead = node;
        return;
    }
    //找尾
    SLTNode* cur = *pphead;
    while (cur-&gt;next) {
        cur = cur-&gt;next;
    }
    cur-&gt;next = node;
}</code></pre> 
<p>接下来的代码逻辑特别简单，首先我们通过buynode函数创建了一个节点，然后我们判空，如果这个链表是空的，我们直接将指针变量pphead赋为node。如果不是空的，那我们就需要找到链表的尾部，我们可以通过循环来找到尾部，首先为了防止原来数据被破坏，我们创建一个指向第一个节点的指针变量cur，而不是直接遍历pphead。</p> 
<p>注意我们如何找尾，通过判断该节点的下一个位置是否为空。</p> 
<p>这里还有一个细节就是，我们传入的是<strong>二级指针</strong>，因为我们要修改一个数据的话，需要传地址，而那个数据如果是指针的话，我们就需要传指针的地址，也就是二级指针。</p> 
<h5>2.1.2 头插</h5> 
<pre><code class="language-cpp">void SLTPushFront(SLTNode** pphead, SLTDataType x) {
    assert(pphead);
    SLTNode* node = BuyNode(x);
    node-&gt;next = *pphead;
    *pphead = node;
}</code></pre> 
<p>这个代码逻辑也很简单，首先我们assert断言防止访问空指针，之后buynode函数申请节点，然后将结点接到头部，也就是*pphead，之后别忘了将*pphead再指向node，形成新的头。</p> 
<h4>2.2 删</h4> 
<h5>2.2.1 尾删</h5> 
<p>尾删也很简单，仔细思考，我们只需要两步就能完成，一个是找尾，一个是删除。</p> 
<p>首先我们来看找尾，我们可以用循环，再加上两个指针，</p> 
<pre><code class="language-cpp">   //找尾
//    SLTNode *cur = *pphead;
//    SLTNode *prev = NULL;
//    while(cur-&gt;next){
//        prev = cur;
//        cur = cur-&gt;next;
//    }
//    prev-&gt;next = NULL;
//    free(cur);
//    cur = NULL;</code></pre> 
<p>首先cur指向头，prev指向空，cur用来找尾，prev用来保存上一个节点的地址。当cur的下一个位置为NULL时循环结束，意味着找到最后一个节点了，<strong>我们将它所指的位置free掉(因为是动态开辟出来的)，然后指针置空即可完成删除</strong>。</p> 
<p>还有一种方法可以用一个指针就解决，</p> 
<pre><code class="language-cpp">  SLTNode* tail = *pphead;
    while (tail-&gt;next-&gt;next) 
    {
        tail = tail-&gt;next;
    }
    free(tail-&gt;next);
    tail-&gt;next = NULL;</code></pre> 
<p> 我们判断条件改成这样，实际上我们找的tail是倒数第二个节点，所以最后的删除需要改成tail的next为NULL。</p> 
<h5>2.2.2 头删</h5> 
<p>头删的逻辑就更加简单了，我们只需要创建一个变量来保存原来的头节点，方便我们后续删除，然后让原头节点移到下一个结点成为新的头结点，然后删掉原来的。如果我们不保存，我们没有办法找到原来的头结点。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">void SLTPopFront(SLTNode** pphead) {
    assert(pphead);
    assert(*pphead);
    SLTNode* first = *pphead;
    *pphead = (*pphead)-&gt;next;
    free(first);
    first = NULL;
}</code></pre> 
<h4>2.3 查</h4> 
<p>这个实现也很简单，就是遍历，然后匹配。由于是查找，而不是对数据进行修改，所以传一级指针即可。</p> 
<pre><code class="language-cpp">SLTNode* SLTFind(SLTNode* phead, SLTDataType x) {
    assert(phead);
    SLTNode* cur = phead;
    while (cur) {
        if (cur-&gt;data == x) {
            return cur;
        }
        cur = cur-&gt;next;
    }
    return NULL;
}</code></pre> 
<h4>2.4 改</h4> 
<h5>2.4.1 在pos前插入</h5> 
<p><img alt="" height="477" src="https://images2.imgbox.com/13/85/8FNHNg71_o.png" width="1047"></p> 
<p>将图画出来我们就清晰明了了。我们如果想把node插入到pos前，我们只需要将node的next指向pos，然后将prev的next指向node，这样就构成了插入操作。</p> 
<p><img alt="" height="558" src="https://images2.imgbox.com/34/38/Bvb9xjs1_o.png" width="1081"></p> 
<p>试想一下，1和2的操作可以调换顺序吗？答案是不可以，这是因为如果我们先做2，这个时候我们就找不到pos了，也就不能执行1操作了。有人会问，我创建两个变量来记录这两个点的位置不可以吗？可以，但是没必要。</p> 
<p>之后我们来看代码部分，首先我们要创建一个node节点，用buynode函数。正常情况，我们需要找pos的前一个节点prev，利用循环即可。如果只有一个节点怎么办呢？这个时候直接头插就可以了。</p> 
<pre><code class="language-cpp">void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x) {
    assert(pphead);
    assert(pos);
    SLTNode* node = BuyNode(x);
    if (*pphead == pos) {
        //        node-&gt;next = pos;
        //        *pphead = node;
        SLTPushFront(pphead, x);
        return;
    }
    //找pos的前一个节点
    SLTNode* prev = *pphead;
    while (prev-&gt;next) {
        if (prev-&gt;next == pos) {
            break;
        }
        prev = prev-&gt;next;
    }
    node-&gt;next = pos;
    prev-&gt;next = node;
}</code></pre> 
<h5>2.4.2 删除pos</h5> 
<p>其实逻辑也是很简单的，要删除pos的话，我们需要找到pos前面的节点保存，否则就找不到了。</p> 
<pre><code class="language-cpp">void SLTErase(SLTNode** pphead, SLTNode* pos) {
	assert(pphead);
	assert(pos);
	if (*pphead == pos) {
		//        SLTNode *del = *pphead;
		//        *pphead = (*pphead)-&gt;next;
		//        free(del);
		//        del = NULL;
		SLTPopFront(pphead);
		return;
	}
	//找pos的前一个节点
	SLTNode* prev = *pphead;
	while (prev-&gt;next) {
		if (prev-&gt;next == pos) {
			break;
		}
		prev = prev-&gt;next;
	}
	prev-&gt;next = pos-&gt;next;
	free(pos);
	//    pos = NULL;//没有存在的必要
}</code></pre> 
<p>并且要注意连接好pos后面的节点后再删除，不然也找不到。</p> 
<h5>2.4.3 在pos后插入</h5> 
<p>逻辑跟在pos前插入一样，也要注意顺序，只不过在pos之后插入不需要传链表第一个节点了，只需要传pos即可。</p> 
<pre><code class="language-cpp">void SLTInsertAfter(SLTNode* pos, SLTDataType x) {
	assert(pos);
	SLTNode* node = BuyNode(x);
	node-&gt;next = pos-&gt;next;
	pos-&gt;next = node;
}</code></pre> 
<h5>2.4.4 删除pos后的节点</h5> 
<pre><code class="language-cpp">void SLTEraseAfter(SLTNode* pos){
    assert(pos);
    assert(pos-&gt;next);
    SLTNode *del = pos-&gt;next;
    pos-&gt;next = del-&gt;next;
    free(del);
    del = NULL;
}</code></pre> 
<p>其实看到这你就发现，对链表的操作无非就是保存节点，然后连接，同时画图操作也可以对我们学习数据结构有所帮助。</p> 
<h4>2.5 链表的销毁</h4> 
<p>我们将链表每个节点通过循环遍历free掉即可，唯一比较吃操作的就是创建一个用于保存下一个节点的位置的指针。</p> 
<pre><code class="language-cpp">//销毁链表
void SListDesTroy(SLTNode** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	SLTNode* pcur = *pphead;
	while (pcur)
	{
		SLTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
	*pphead = NULL;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ba26338c9a42c565f9ad3aeb686dd00/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">3款自己电脑就可以运行AI LLM的项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03840aba1bf58818faf1a27dade2f34f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从Java开发者到.NET Core初级工程师学习路线：C#语言基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>