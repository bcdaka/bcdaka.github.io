<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL之查询性能优化(二) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d8116e07d094a98fbef1d6282176c1e3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MySQL之查询性能优化(二)">
  <meta property="og:description" content="查询性能优化 慢查询基础:优化数据访问 查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但这并不场景。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效:
1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列2.确认MySQL服务器是否在分析大量超过需要的数据行 是否向数据库请求了不需要的数据。 有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这回给MySQL服务器带来额外的负担，并增加网络开销(如果应用服务器和数据库不在同一台主机上，网络开销就显得很明显了。即使在同一台服务器上仍然会有数据传输的开销)。另外也会消耗应用服务器的CPU和内存资源。下面是一些典型案例:
1.查询不需要的记录:一个常见的错误是常常误以为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。我们经常会看到一些了解其他数据库系统的人会设计出这类应用程序。这些开发者习惯适用这样的使用，先使用SELECT语句查询大量的结果，然后获取前面的N行后关闭结果集(例如在新闻网站中取出100条记录，但是只是在页面上显示前面10条)。它们认为MySQL会执行查询，并只返回它们需要的10条数据，然后停止查询。实际情况是MySQL会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中大部分数据。最简单有效的解决方法就是在这样的查询后面加上LIMIT2.多表关联时返回全部列:如果你想查询所有在电影Academy Dinosaur中出现的演员，千万不要按下面的写法编写查询: mysql&gt; SELECT * FROM actor -&gt; INNER JOIN film_actor USING(actor_id) -&gt; INNER JOIN film USING(film_id) -&gt; WHERE film.title=&#39;Academy Dinosaur&#39;; 这将返回这三个表的全部数据列。正确的方式应该时像下面这样只取需要的列:
mysql&gt;SELECT actor.* FROM actor ..... 3.总是取出全部列:每次看到SELECT * 的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能不是必需的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的IO、内存和CPU的消耗。因此，一些DBA是严格禁止SELECT * 的写法的，这样做有时候还能避免某些列被修改带来的问题。当然，查询返回超过需要的数据也不总是坏事。在许多案例中，人们会说这种有点浪费数据库资源的方式可以简化开发，因为能提高相同代码片段的复用性，如果清除这样做的性能影响，那么这种做法也是值得考虑的。如果应用程序使用了某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其他好处，但不要忘记这样做的代价是什么。获取并缓存所有的列的查询相比多个独立的只获取部分列的查询可能就更有好处。4.重复查询相同的数据:如果你不太小心，很容易出现这样的错误——不断地重复执行相同的查询，然后每次都返回完全相同的数据。例如，在用户评论的地方需要查询用户头像的URL,那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。 MySQL是否扫描额外的记录 在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了许多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下:
1.响应时间
2.扫描的行数
3.返回的行数
没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法
响应时间 要记住， 响应时间只是一个表面的值。这样说可能看起来和前面关于响应时间的说法有矛盾？其实并不矛盾，响应时间仍然是最重要的指标，这有一点复杂，后面细细道来。响应时间是两个部分之和:服务时间和排队时间。服务时间是指数据处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等待IO操作完成，也可能是等待行锁，等等。遗憾的是，我们无法把响应时间细分到上面这些部分，除非有什么办法能够逐个测量上面这些消耗，不过很难做到，一般最常见和重要的等待是IO和锁等待，但实际情况更加复杂。所以在不同类型的应用压力下，响应时间并没有什么一致的规律或者共识。诸如存储引擎的锁(表锁、行锁)、高并发资源竞争、硬件响应等诸多因素都会影响到响应时间。所以，响应时间既可能是一个问题的结果也可能是一个问题的原因，不同案例情况不同，除非我们能深入测量出每个环节。
当你看到一个查询的响应时间的时候，首先需要问问自己，这个响应时间是否是一个合理的值。实际上可以使用&#34;快速上限估计&#34;法来估算查询的响应时间，这是由Lahdenmaki和Mike Leach编写的Relational Database Index Design and the Optimizers一书中提到的技术。概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以在具体硬件条件下一次IO的消耗。最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理得值
扫描的行数和返回的行数 分析查询时，查看该查询扫描的行数时非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。对于找出哪些&#34;糟糕&#34;的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行访问速度要快得多。理想情况下扫描得行数和返回的行数应该是相同的。但实际情况中这种&#34;美事&#34;并不多。例如在做一个管来奶查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常非常大
扫描的行数和访问类型 在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无须扫描就能返回结果。在EXPLAIN语句中的type列反应了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度时从慢到快，扫描的行数也是从多到少。你不需要记住这些访问类型，但需要明白扫描表、扫描索引、范围访问和单值访问的概念.如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。现在应该明白为什么索引对于查询优化如此重要了。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。例如，我们看看示例库Sakila中的一个查询案例:
mysql&gt; SELECT * FROM film_actor WHERE film_id =1; &#43;----------&#43;---------&#43;---------------------&#43; | actor_id | film_id | last_update | &#43;----------&#43;---------&#43;---------------------&#43; | 1 | 1 | 2006-02-15 05:05:03 | | 10 | 1 | 2006-02-15 05:05:03 | | 20 | 1 | 2006-02-15 05:05:03 | | 30 | 1 | 2006-02-15 05:05:03 | | 40 | 1 | 2006-02-15 05:05:03 | | 53 | 1 | 2006-02-15 05:05:03 | | 108 | 1 | 2006-02-15 05:05:03 | | 162 | 1 | 2006-02-15 05:05:03 | | 188 | 1 | 2006-02-15 05:05:03 | | 198 | 1 | 2006-02-15 05:05:03 | &#43;----------&#43;---------&#43;---------------------&#43; 这个查询将返回10行数据，从EXPLAIN的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-03T21:59:07+08:00">
    <meta property="article:modified_time" content="2024-06-03T21:59:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL之查询性能优化(二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>查询性能优化</h2> 
<h3><a id="_1"></a>慢查询基础:优化数据访问</h3> 
<p>查询性能低下最基本的原因是访问的数据太多。某些查询可能不可避免地需要筛选大量数据，但这并不场景。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效:</p> 
<ul><li>1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列</li><li>2.确认MySQL服务器是否在分析大量超过需要的数据行</li></ul> 
<h4><a id="_5"></a>是否向数据库请求了不需要的数据。</h4> 
<p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这回给MySQL服务器带来额外的负担，并增加网络开销(如果应用服务器和数据库不在同一台主机上，网络开销就显得很明显了。即使在同一台服务器上仍然会有数据传输的开销)。另外也会消耗应用服务器的CPU和内存资源。下面是一些典型案例:</p> 
<ul><li>1.查询不需要的记录:一个常见的错误是常常误以为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。我们经常会看到一些了解其他数据库系统的人会设计出这类应用程序。这些开发者习惯适用这样的使用，先使用SELECT语句查询大量的结果，然后获取前面的N行后关闭结果集(例如在新闻网站中取出100条记录，但是只是在页面上显示前面10条)。它们认为MySQL会执行查询，并只返回它们需要的10条数据，然后停止查询。实际情况是MySQL会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中大部分数据。最简单有效的解决方法就是在这样的查询后面加上LIMIT</li><li>2.多表关联时返回全部列:如果你想查询所有在电影Academy Dinosaur中出现的演员，千万不要按下面的写法编写查询:</li></ul> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> actor
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> film_actor <span class="token keyword">USING</span><span class="token punctuation">(</span>actor_id<span class="token punctuation">)</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> film <span class="token keyword">USING</span><span class="token punctuation">(</span>film_id<span class="token punctuation">)</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">WHERE</span> film<span class="token punctuation">.</span>title<span class="token operator">=</span><span class="token string">'Academy Dinosaur'</span><span class="token punctuation">;</span>
</code></pre> 
<p>这将返回这三个表的全部数据列。正确的方式应该时像下面这样只取需要的列:</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span><span class="token keyword">SELECT</span> actor<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> actor <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<ul><li>3.总是取出全部列:每次看到SELECT * 的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能不是必需的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的IO、内存和CPU的消耗。因此，一些DBA是严格禁止SELECT * 的写法的，这样做有时候还能避免某些列被修改带来的问题。当然，查询返回超过需要的数据也不总是坏事。在许多案例中，人们会说这种有点浪费数据库资源的方式可以简化开发，因为能提高相同代码片段的复用性，如果清除这样做的性能影响，那么这种做法也是值得考虑的。如果应用程序使用了某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其他好处，但不要忘记这样做的代价是什么。获取并缓存所有的列的查询相比多个独立的只获取部分列的查询可能就更有好处。</li><li>4.重复查询相同的数据:如果你不太小心，很容易出现这样的错误——不断地重复执行相同的查询，然后每次都返回完全相同的数据。例如，在用户评论的地方需要查询用户头像的URL,那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。</li></ul> 
<h4><a id="MySQL_21"></a>MySQL是否扫描额外的记录</h4> 
<p>在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了许多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下:<br> 1.响应时间<br> 2.扫描的行数<br> 3.返回的行数<br> 没有哪个指标能够完美地衡量查询的开销，但它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法</p> 
<h5><a id="_27"></a>响应时间</h5> 
<p>要记住， 响应时间只是一个表面的值。这样说可能看起来和前面关于响应时间的说法有矛盾？其实并不矛盾，响应时间仍然是最重要的指标，这有一点复杂，后面细细道来。响应时间是两个部分之和:服务时间和排队时间。服务时间是指数据处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等待IO操作完成，也可能是等待行锁，等等。遗憾的是，我们无法把响应时间细分到上面这些部分，除非有什么办法能够逐个测量上面这些消耗，不过很难做到，一般最常见和重要的等待是IO和锁等待，但实际情况更加复杂。所以在不同类型的应用压力下，响应时间并没有什么一致的规律或者共识。诸如存储引擎的锁(表锁、行锁)、高并发资源竞争、硬件响应等诸多因素都会影响到响应时间。所以，响应时间既可能是一个问题的结果也可能是一个问题的原因，不同案例情况不同，除非我们能深入测量出每个环节。<br> 当你看到一个查询的响应时间的时候，首先需要问问自己，这个响应时间是否是一个合理的值。实际上可以使用"快速上限估计"法来估算查询的响应时间，这是由Lahdenmaki和Mike Leach编写的Relational Database Index Design and the Optimizers一书中提到的技术。概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机IO，再用其乘以在具体硬件条件下一次IO的消耗。最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理得值</p> 
<h5><a id="_30"></a>扫描的行数和返回的行数</h5> 
<p>分析查询时，查看该查询扫描的行数时非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。对于找出哪些"糟糕"的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行访问速度要快得多。理想情况下扫描得行数和返回的行数应该是相同的。但实际情况中这种"美事"并不多。例如在做一个管来奶查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常非常大</p> 
<h5><a id="_32"></a>扫描的行数和访问类型</h5> 
<p>在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无须扫描就能返回结果。在EXPLAIN语句中的type列反应了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度时从慢到快，扫描的行数也是从多到少。你不需要记住这些访问类型，但需要明白扫描表、扫描索引、范围访问和单值访问的概念.如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。现在应该明白为什么索引对于查询优化如此重要了。索引让MySQL以最高效、扫描行数最少的方式找到需要的记录。例如，我们看看示例库Sakila中的一个查询案例:</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> film_actor <span class="token keyword">WHERE</span> film_id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----------+---------+---------------------+</span>
<span class="token operator">|</span> actor_id <span class="token operator">|</span> film_id <span class="token operator">|</span> last_update         <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------+---------+---------------------+</span>
<span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>       <span class="token number">10</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>       <span class="token number">20</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>       <span class="token number">30</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>       <span class="token number">40</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>       <span class="token number">53</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>      <span class="token number">108</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>      <span class="token number">162</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>      <span class="token number">188</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">|</span>      <span class="token number">198</span> <span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2006</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">15</span> <span class="token number">05</span>:<span class="token number">05</span>:<span class="token number">03</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------+---------+---------------------+</span>
</code></pre> 
<p>这个查询将返回10行数据，从EXPLAIN的结果可以看到，MySQL在索引idx_fk_film_id上使用了ref访问类型来执行查询:</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> film_actor <span class="token keyword">WHERE</span> film_id<span class="token operator">=</span><span class="token number">1</span>\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: film_actor
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: ref
possible_keys: idx_fk_film_id
          <span class="token keyword">key</span>: idx_fk_film_id
      key_len: <span class="token number">2</span>
          ref: const
         <span class="token keyword">rows</span>: <span class="token number">10</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token boolean">NULL</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre> 
<p>EXPLAIN的结果也显示MySQL预估需要访问10行数据。换句话说，查询优化器认为这种访问类型可以高效地完成查询。如果没有合适地索引会怎样呢？MySQL就不得不使用一种更糟糕地访问类型，下面我们来看看如果我们删除对应的索引再来运行这个查询:</p> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> film_actor <span class="token keyword">DROP</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> fk_film_actor_film<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">18.97</span> sec<span class="token punctuation">)</span>
Records: <span class="token number">0</span>  Duplicates: <span class="token number">0</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> film_actor <span class="token keyword">DROP</span> <span class="token keyword">KEY</span> idx_fk_film_id<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span>
Records: <span class="token number">0</span>  Duplicates: <span class="token number">0</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> film_actor <span class="token keyword">WHERE</span> film_id<span class="token operator">=</span><span class="token number">1</span>\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: film_actor
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">ALL</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: <span class="token boolean">NULL</span>
      key_len: <span class="token boolean">NULL</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">5462</span>
     filtered: <span class="token number">10.00</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">where</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre> 
<p>正如我们预测的，访问类型变成了一个全表扫描(ALL)，现在MySQL预估需要扫描5462条记录来完成这个查询。这里的"Using Where"表示MySQL将通过WHERE条件来筛选存储引擎返回的记录。一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为:</p> 
<ul><li>1.在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的</li><li>2.使用索引覆盖扫描(在Extra列出现了Using index)来返回记录，直接从素银中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录</li><li>3.从数据表中返回数据，然后过滤不满足条件的记录(在Extra列中出现Using WHere)。这在MySQL服务器层完成，MySQL需要从数据表独处记录后过滤。<br> 上面这个例子说明了好的索引多么重要。好的索引可以让查询使用合适的访问了悉尼港，尽可能地只扫描需要的数据行。但也不是说增加索引就能让扫描的行数等于返回的行数。例如下面使用聚合函数COUNT()的查询:</li></ul> 
<pre><code class="prism language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> film_actor <span class="token keyword">WHERE</span> film_id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个查询需要读取几千行数据，但是仅返回200行结果。没有什么索引能够让这样的查询减少需要扫描的行数。不幸的是，MySQL不会告诉我们生成结果实际上需要扫描多少行数据(例如关联查询结果返回的一条记录通常是由多条记录组成的)而只会告诉我们生成结果时一共扫描了多少行数据。扫描的行数中的大部分都很可能是被WHERE条件过滤掉的，对最终结果集并没有贡献。在上面的例子中，删除索引后，看到MySQL需要扫描所有记录然后根据WHERE条件过滤，最终只返回10行结果。理解一个查询需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。</p> 
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它:</p> 
<ul><li>1.使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果；额</li><li>2.改变库表结构。例如使用单独的汇总表</li><li>3.重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/115add88cf496d35bf6d2e3b6363478c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】详解堆的基本结构及其实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15def1ef90faeca2a6ab4df2106d38f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Go语言精进之路】构建高效Go程序：零值可用、使用复合字面值作为初值构造器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>