<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端fetch 实现流式接口 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c1b17ff6fc83431035bd382172820527/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端fetch 实现流式接口">
  <meta property="og:description" content="遇到这样一个需求,通过ai动态生成大纲文本，前端在接收到后端的文本内容时，接收的文本是“动态”的，视角表现层面上逐字生成渲染的，效果如下，那么如何实现这种效果？这里就要用到流式接口，也就是流式传输。
什么是流式传输 先说说传统传输吧，我们日常接触的大多数是传统传输方式，就也是整段传输，前后端将数据一次性传送给对方；相比于传统传输方式，流式传输则采用分段的方式将要传输的数据分层n段，后端一次性传一段给前端，直到传输完成为止，当然在传输的过程中，前端也可以提前中断传输，后端收到中断传输的消息后，也不再继续往前端传输剩下没传完的数据段。 当然，前端流式传输需要在后端支持分块传输的情况下才能实现。
前端实现流式传输的几种主流方式 查阅了资料，目前前端实现流式传输主要有以下几种方式：fetch、SSE、websocket，详情移步另一位博主，没错我查阅的资料就是他的文章，链接chatGPT流式输出前端实现fetch、SSE、websocket_fetch sse-CSDN博客
我用的是fetch，fetch 本身不直接支持流式输出，但你可以使用fetch ai 中的 ReadableStream实现流式数据处理。
什么是fetch? 简单来说fetch 是一种 HTTP 数据请求的方式， XMLHttpRequest（以下简称 XHR）的一种替代方案。与基于回调的API的XMLHttpRequest不同，fetch是基于Promise的，可以链式分块化地处理数据，更重要的是Fetch API能够处理流式响应。
更多关于fetch 的文档可以参考以下文档，我们重点讲fetch 处理流式响应
fetch 官方文档： 官方文档 js ES6 fetch 方法_js fetch-CSDN博客
fetch实现流式输出的实现原理_fetch nodejs 客户端 流式输出-CSDN博客
fetch处理流式响应 要实现 fetch 的流式输出，关键在于如何正确地处理返回的 ReadableStream 对象。ReadableStream 是 HTML 标准的一部分，它代表了一个可以从内部读取数据的源头。在 Fetch API 中，Response 对象的 body 属性就是一个 ReadableStream 实例。
return fetch(input, { ...init, headers }) .then((res) =&gt; { console.log(&#39;res.body&#39;, res.body); if (res.ok) return Promise.resolve(res); }) 实现步骤： 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T14:43:08+08:00">
    <meta property="article:modified_time" content="2024-05-27T14:43:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端fetch 实现流式接口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>遇到这样一个需求,通过ai动态生成大纲文本，前端在接收到后端的文本内容时，接收的文本是“动态”的，视角表现层面上逐字生成渲染的，效果如下，那么如何实现这种效果？这里就要用到流式接口，也就是流式传输。</p> 
</blockquote> 
<div></div> 
<p></p> 
<h3>什么是流式传输</h3> 
<p>  先说说传统传输吧，我们日常接触的大多数是传统传输方式，就也是整段传输，前后端将数据一次性传送给对方；相比于传统传输方式，流式传输则采用分段的方式将要传输的数据分层n段，后端一次性传一段给前端，直到传输完成为止，当然在传输的过程中，前端也可以提前中断传输，后端收到中断传输的消息后，也不再继续往前端传输剩下没传完的数据段。 当然，前端流式传输需要在后端支持分块传输的情况下才能实现。</p> 
<p></p> 
<h3>前端实现流式传输的几种主流方式</h3> 
<p>查阅了资料，目前前端实现流式传输主要有以下几种方式：fetch、SSE、websocket，详情移步另一位博主，没错我查阅的资料就是他的文章，链接<a href="https://blog.csdn.net/qq_48434912/article/details/133910402?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%89%8D%E7%AB%AF%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-133910402.142%5Ev100%5Econtrol&amp;spm=1018.2226.3001.4187" title="chatGPT流式输出前端实现fetch、SSE、websocket_fetch sse-CSDN博客">chatGPT流式输出前端实现fetch、SSE、websocket_fetch sse-CSDN博客</a></p> 
<p>我用的是fetch，fetch 本身不直接支持流式输出，但你可以使用fetch ai 中的 ReadableStream实现流式数据处理。</p> 
<p></p> 
<h3>什么是fetch?</h3> 
<p>简单来说fetch 是一种 HTTP 数据请求的方式， XMLHttpRequest（以下简称 XHR）的一种替代方案。与基于回调的API的<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="nofollow" title="XMLHttpRequest">XMLHttpRequest</a>不同，fetch是基于Promise的，可以链式分块化地处理数据，更重要的是Fetch API能够处理流式响应。</p> 
<p></p> 
<p>更多关于fetch 的文档可以参考以下文档，我们重点讲fetch 处理流式响应</p> 
<blockquote> 
 <p>fetch 官方文档： <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="nofollow" title="官方文档">官方文档</a> </p> 
 <p> <a href="https://blog.csdn.net/mChales_Liu/article/details/107442783?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=fetch&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-107442783.142%5Ev100%5Econtrol&amp;spm=1018.2226.3001.4187" title="js ES6 fetch 方法_js fetch-CSDN博客">js ES6 fetch 方法_js fetch-CSDN博客</a></p> 
 <p><a href="https://blog.csdn.net/jyl4855/article/details/136484042?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171643548016800215015315%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=171643548016800215015315&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-136484042-null-null.142%5Ev100%5Econtrol&amp;utm_term=fetch%20%E5%AE%9E%E7%8E%B0%E6%B5%81%E5%BC%8F&amp;spm=1018.2226.3001.4187" title="fetch实现流式输出的实现原理_fetch nodejs 客户端 流式输出-CSDN博客">fetch实现流式输出的实现原理_fetch nodejs 客户端 流式输出-CSDN博客</a></p> 
</blockquote> 
<p></p> 
<h2 id="articleContentId">fetch处理流式响应</h2> 
<p>要实现 fetch 的流式输出，关键在于如何正确地处理返回的 ReadableStream 对象。ReadableStream 是 HTML 标准的一部分，它代表了一个可以从内部读取数据的源头。在 Fetch API 中，Response 对象的 body 属性就是一个 ReadableStream 实例。</p> 
<pre><code class="language-TypeScript">  return fetch(input, { ...init, headers })
    .then((res) =&gt; {
      console.log('res.body', res.body);
      if (res.ok) return Promise.resolve(res);
    })</code></pre> 
<p><img alt="" height="96" src="https://images2.imgbox.com/63/5e/RKeWkP3q_o.png" width="521"></p> 
<div></div> 
<h3></h3> 
<h3>实现步骤：</h3> 
<p>  1.创建一个阅读器并将流锁定到它。</p> 
<pre><code class="language-TypeScript"> //创建一个阅读器并将流锁定到它。当流被锁定时，在这个阅读器发布之前，无法获得其他阅读器
      const reader = res_.body.getReader();
      return reader.read().then(({ value, done }) =&gt; {
        console.log('value', value);
      });</code></pre> 
<h3>   <img alt="" height="99" src="https://images2.imgbox.com/ec/98/Dr1h3qAv_o.png" width="1062">       </h3> 
<p> 可以看到阅读器一次只接收一次响应数据，且接收到的数据为utf-8编码数据，这时我们需要让阅读器重复获取数据（发布这个阅读器），直到数据获取完或者手动中止为止，并且还要对 utf-8编码数据进行转码</p> 
<p>2. 发布阅读器我们 可以使用递归函数去重复发布阅读器</p> 
<pre><code class="language-TypeScript"> const reader = res_.body.getReader();
      return reader.read().then(function push({ value, done }) {
        console.log('done, value', done, value);
        return reader.read().then(push);
      });</code></pre> 
<p> 3. 转码的话我们需要使用 文本解码器（TextDecoder）进行转码 ，详情可以看我另一篇文章<a href="https://blog.csdn.net/weixin_44405693/article/details/139125477" title="浅识TextDecoder-CSDN博客">浅识TextDecoder-CSDN博客</a></p> 
<p></p> 
<pre><code class="language-TypeScript"> const reader = res_.body.getReader();
      const utf8Decoder = new TextDecoder('utf-8');
      return reader.read().then(function push({ value, done }) {
        let _value = value ? utf8Decoder.decode(value, { stream: true }) : '';
        console.log('转码后的数据', _value);
        return reader.read().then(push);
      });</code></pre> 
<p><img alt="" height="404" src="https://images2.imgbox.com/12/45/1Ze00dko_o.png" width="1035"></p> 
<p></p> 
<p></p> 
<p>4.中止fetch<br>   要中止不完整的<code>fetch()</code>操作，请使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="nofollow" title="AbortController">AbortController</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal" rel="nofollow" title="AbortSignal">AbortSignal</a>接口。</p> 
<p>   定义</p> 
<pre><code class="language-TypeScript">  const controllerRef = useRef(null);
</code></pre> 
<pre><code class="language-TypeScript"> controllerRef.current = new AbortController();
      const signal = controllerRef.current.signal;
      fetch(input, { headers, signal })</code></pre> 
<p></p> 
<p>  使用</p> 
<pre><code class="language-TypeScript"> &lt;button onClick={() =&gt; controllerRef.current.abort()}&gt;停止生成 &lt;/button&gt;
</code></pre> 
<p></p> 
<p></p> 
<p>5.完整代码</p> 
<pre><code class="language-TypeScript">//存储中断器
  const controllerRef = useRef(null);

  const getStreamData = () =&gt; {
    const input = 'xxxxxx';
    //fetch 其它配置项
    const token = utils.getToken();
    const headers = {
      ...(token ? { Authorization: 'Bearer ' + token } : null),
    };

    controllerRef.current = new AbortController();
    const signal = controllerRef.current.signal;

    //存储拿到的数据
    let outline = '';

    fetch(input, { headers, signal })
      .then((res) =&gt; {
        //res.ok 表示成功状态
        if (res.ok) return Promise.resolve(res);
      })
      .then((res_) =&gt; {
        //创建一个阅读器并将流锁定到它。当流被锁定时，在这个阅读器发布之前，无法获得其他阅读器
        const reader = res_.body.getReader();
        const utf8Decoder = new TextDecoder('utf-8');
        //定义一个对象存储每次拿到的数据
        return reader.read().then(function push({ value, done }) {
          if (done) {
            //表示数据流结束
            return outline;
          } else {
            let _value = value ? utf8Decoder.decode(value, { stream: true }) : '';
            let _data = _value?.split('\n\n') || [];
            for (const it of _data) {
              let _it = it.replace(/^(data: \[DONE\])|^(data:)/, '');
              if (_it) {
                let res: { code; data; msg } = JSON.parse(_it);
                if (res?.code == 0) {
                  outline = outline + res?.data?.text;
                  console.log('接收到的数据为:', outline);
                } else {
                  return Promise.reject(res);
                }
              }
            }
          }
          return reader.read().then(push);
        });
      });
  };</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><code class="language-TypeScript">​​​​​​​</code></p> 
<p>​​​​​​​</p> 
<div></div> 
<p></p> 
<div></div> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<pre></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d427fb2e9fd5f64b9474c4009eff9c68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中Comparable接口和Comparator接口的区别（如果想知道Java中Comparable接口和Comparator接口的区别，那么只看这一篇就足够了！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25fc10357c28272a65c13010e597d8f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】二叉搜索树——高阶数据结构的敲门砖</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>