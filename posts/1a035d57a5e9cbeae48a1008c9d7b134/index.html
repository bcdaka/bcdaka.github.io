<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 类和对象 拷贝构造函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1a035d57a5e9cbeae48a1008c9d7b134/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; 类和对象 拷贝构造函数">
  <meta property="og:description" content="一 拷贝构造函数的概念： 拷贝构造函数是一种特殊的构造函数，用于创建一个对象是另一个对象的副本。当需要用一个已存在的对象来初始化一个新对象时，或者将对象传递给函数或从函数返回对象时，会调用拷贝构造函数。
二 拷贝构造函数的特点： 1：拷贝构造函数是构造函数的一个重载形式。
2：拷贝构造函数的参数只有一个且必须是类类型对象的引用，使用传值方式编译器直接报错， 因为会引发无穷递归调用。
3：若未显式定义，编译器会生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按 字节序完成拷贝，这种拷贝叫做浅拷贝，或者值拷贝。
注意：在编译器生成的默认拷贝构造函数中，内置类型是按照字节方式直接拷贝的，而自定 义类型是调用其拷贝构造函数完成拷贝的。
4：编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，还需要自己显式实现吗？ 当然像日期类这样的类是没必要的。
2.1 代码示例： class Time { public: // 普通构造函数 Time(int hour = 0, int minute = 0, int second = 0) { _hour = hour; _minute = minute; _second = second; } // 拷贝构造函数，使用引用传递 Time(const Time&amp; other) { _hour = other._hour; _minute = other._minute; _second = other._second; } void Print() const { std::cout &lt;&lt; _hour &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-10T23:59:12+08:00">
    <meta property="article:modified_time" content="2024-07-10T23:59:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 类和对象 拷贝构造函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 拷贝构造函数的概念：</h2> 
<p>拷贝构造函数是一种特殊的构造函数，用于创建一个对象是另一个对象的副本。当需要用一个已存在的对象来初始化一个新对象时，或者将对象传递给函数或从函数返回对象时，会调用拷贝构造函数。</p> 
<h2>二 拷贝构造函数的特点：</h2> 
<p>1：拷贝构造函数是构造函数的一个重载形式。</p> 
<p>2：拷贝构造函数的参数只有一个且必须是类类型对象的引用，使用传值方式编译器直接报错， 因为会引发无穷递归调用。</p> 
<p>3：若未显式定义，编译器会生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按 字节序完成拷贝，这种拷贝叫做浅拷贝，或者值拷贝。</p> 
<p>注意：在编译器生成的默认拷贝构造函数中，内置类型是按照字节方式直接拷贝的，而自定 义类型是调用其拷贝构造函数完成拷贝的。</p> 
<p>4：编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，还需要自己显式实现吗？ 当然像日期类这样的类是没必要的。</p> 
<h4>2.1 代码示例：</h4> 
<pre><code>class Time 
{
public:
    // 普通构造函数
    Time(int hour = 0, int minute = 0, int second = 0) 
    {
        _hour = hour;
        _minute = minute;
        _second = second;
    }

    // 拷贝构造函数，使用引用传递
    Time(const Time&amp; other) 
    {
        _hour = other._hour;
        _minute = other._minute;
        _second = other._second;
    }

    void Print() const 
    {
        std::cout &lt;&lt; _hour &lt;&lt; ":" &lt;&lt; _minute &lt;&lt; ":" &lt;&lt; _second &lt;&lt; std::endl;
    }

private:
    int _hour;
    int _minute;
    int _second;
};

int main()
{
    Time t1(10, 20, 30);   // 使用普通构造函数

    //构造函数的重载
    Time t2 = t1;          // 使用拷贝构造函数
   
    //Time t2(t1);        // 拷贝构造的另一种写法

    t1.Print();
    t2.Print();
    return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/8d/a5/dfWXWYto_o.png" width="864"></p> 
<h4>2.2 为什么要使用引用呢？</h4> 
<p>我们在 increment 函数中改变x的值并没有间接性改变a，这是因为传过去的只是编译器创建实参的一个副本，而修改副本怎么可能可以改变a呢？</p> 
<pre><code>#include &lt;iostream&gt;

void increment(int x) 
{
    x = x + 1;  // 修改的是副本，不影响实参
}

int main() 
{
    int a = 5;
    increment(a);  // 传递a的副本
    std::cout &lt;&lt; a &lt;&lt; std::endl;  // 输出5，原始值a未被修改
    return 0;
}
</code></pre> 
<p>知道传值传参的本质之后，再来想一想为什么要用引用？咱们先来说说如果没用用引用的后果会是怎么样，当把自定义类型传出去后且不用引用或者指针来接收，它会</p> 
<p>调用 <code>Time(const Time other)</code>，其中 <code>other</code> 是 <code>t1</code> 的按值传递副本。</p> 
<p>为了按值传递，编译器需要创建 <code>other</code> 的副本。</p> 
<p>创建 <code>other</code> 的副本时，再次调用 <code>Time(const Time other)</code>。</p> 
<p>这个新调用的 <code>Time(const Time other)</code> 又需要创建自己的 <code>other</code> 副本，再次调用 <code>Time(const Time other)</code>。</p> 
<p>如此反复，导致无限递归调用，最终导致栈溢出。</p> 
<p>图：</p> 
<p><img alt="" height="635" src="https://images2.imgbox.com/49/b8/CoDhbpAO_o.png" width="1139"></p> 
<blockquote> 
 <p style="text-align:center;"><span style="color:#fe2c24;">C++规定，自定义类型的拷贝，都会调用拷贝构造</span></p> 
</blockquote> 
<p>那为什么要引用呢？</p> 
<p>首先我们来回顾一下引用 ：</p> 
<p>1<strong>：引用</strong>是现有变量的另一个名字。</p> 
<p>2：它们不创建新对象，只是指向已有对象。</p> 
<p>3：引用只是指向现有对象，<span style="color:#fe2c24;">不创建新副本</span></p> 
<p>因为引用就是它本身，所以何来创建新副本这一说法，创建新副本是怕改变副本从而导致改变实参值</p> 
<h4>2.3 总结：</h4> 
<p><strong>1：按值传递会递归</strong>：每次传递对象会复制对象，导致无限递归。</p> 
<p><strong>2：引用传递避免递归</strong>：引用只是指向对象本身，不会复制对象</p> 
<h2>三 默认拷贝构造：</h2> 
<p>当你没有显式定义拷贝构造函数时，编译器会为你自动生成一个默认的拷贝构造函数。这个默认拷贝构造函数会逐个拷贝对象的所有成员变量。</p> 
<h4>3.1 内置类型与自定义类型的拷贝：</h4> 
<p><strong>内置类型</strong>：如 <code>int</code>, <code>char</code>, <code>float</code> 等，拷贝时直接按照字节方式进行复制，也就是直接复制其值。</p> 
<p><strong>自定义类型</strong>：如类和结构体，拷贝时会调用该类型的拷贝构造函数。</p> 
<h4>3.2 代码示例：</h4> 
<p><strong>内置类型：</strong></p> 
<pre><code>#include &lt;iostream&gt;

class MyClass 
{
public:
    int x;  // 内置类型成员
};

int main() 
{
    MyClass obj1;
    obj1.x = 10;

    MyClass obj2 = obj1;  // 使用编译器生成的默认拷贝构造函数

    std::cout &lt;&lt; "obj1.x: " &lt;&lt; obj1.x &lt;&lt; std::endl; 
    std::cout &lt;&lt; "obj2.x: " &lt;&lt; obj2.x &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/fb/00/vlO4FnLy_o.png" width="864"></p> 
<p>对于一个类里面只有内置类型成员那编译器生成的默认拷贝构造会自动复制其值。</p> 
<p><strong>自定义类型：</strong></p> 
<pre><code>#include &lt;iostream&gt;

class Time 
{
public:
    // 默认构造函数
    Time() 
    {  
        _hour = 0;
        _minute = 0;
        _second = 0;
    }

    // 拷贝构造函数
    Time(const Time&amp; other) 
    {
        _hour = other._hour;
        _minute = other._minute;
        _second = other._second;
        std::cout &lt;&lt; "Time::Time(const Time&amp; other)" &lt;&lt; std::endl;
    }

private:
    int _hour;
    int _minute;
    int _second;
};

class MyClass 
{
public:
    int x;  // 内置类型成员
    Time t; // 自定义类型成员
};

int main() 
{
    MyClass obj1;
    obj1.x = 10;

    MyClass obj2 = obj1;  // 使用编译器生成的默认拷贝构造函数

    std::cout &lt;&lt; "obj1.x: " &lt;&lt; obj1.x &lt;&lt; std::endl;
    std::cout &lt;&lt; "obj2.x: " &lt;&lt; obj2.x &lt;&lt; std::endl; 

    return 0;
}</code></pre> 
<p>当执行MyClass obj2 = obj1; 因obj1类里面有自定义类型 t 所以编译器生成的默认拷贝构造会自动调用Time(const Time&amp; other) 来完成</p> 
<h4>3.3 总结：</h4> 
<p>内置类型：编译器默认拷贝构造函数会直接复制其值。</p> 
<p>自定义类型：编译器默认拷贝构造函数会调用该类型的拷贝构造函数来复制其内容。</p> 
<h2>四 内存分区：</h2> 
<p>要理解好深拷贝与浅拷贝那就得先了解内存是怎么样分区的。</p> 
<p class="img-center"><img alt="" height="402" src="https://images2.imgbox.com/97/31/kUp9YAMg_o.png" width="418"></p> 
<h2></h2> 
<p>计算机程序运行时，内存通常被分为四个主要区域：栈区、堆区、全局静态区和只读区（常量区和代码区）。</p> 
<h4><strong>4.1 栈区：</strong></h4> 
<p>局部变量：函数内部定义的变量。</p> 
<p>形参（函数参数）：函数定义时的参数。</p> 
<p>返回地址：函数调用后的返回地址。</p> 
<p><span style="color:#a2e043;">特点：</span></p> 
<p>栈区中<span style="color:#fe2c24;">访问速度快</span>且栈的<span style="color:#fe2c24;">内存连续分配</span>。</p> 
<p>因存储的都是 局部/形参/返回地址 所以<span style="color:#fe2c24;">栈区空间小</span>，存储的<span style="color:#fe2c24;">生命周期短</span>。</p> 
<p>在我们局部变量所在的函数执行完成时，它会<span style="color:#fe2c24;">自动释放内存</span>。</p> 
<h4><strong>4.2 堆区：</strong></h4> 
<p>动态分配的数据：通过 <code>new</code> 或 <code>malloc</code> 等动态分配函数分配的内存。</p> 
<p><span style="color:#a2e043;">特点：</span></p> 
<p>因存储的都是new 或者malloc开辟的空间所以<span style="color:#fe2c24;">堆区空间大</span><span style="color:#0d0016;">，所以</span><span style="color:#fe2c24;">访问速度慢</span><span style="color:#0d0016;">。</span></p> 
<p>堆中的内存分配和释放是通过指针进行的，可能<span style="color:#fe2c24;">不是连续</span>的。</p> 
<p>堆区的内存需要程序员手动管理，必须<span style="color:#fe2c24;">手动释放动态分配的内存</span>，否则会导致内存泄漏。</p> 
<h4><strong>4.3 全区/静态区：</strong></h4> 
<p>全局变量：在所有函数外部定义的变量。</p> 
<p>静态变量：使用 <code>static</code> 关键字定义的变量。</p> 
<p><span style="color:#a2e043;">特点：</span></p> 
<p>全局变量和静态变量在程序的<span style="color:#fe2c24;">整个运行期间一直存在</span>，直到程序结束。</p> 
<p>全局变量可以在程序的<span style="color:#fe2c24;">所有函数中访问</span>，静态变量在<span style="color:#fe2c24;">声明的作用域内共享</span>。</p> 
<h4><strong>4.4 只读常量区：</strong></h4> 
<p>常量：程序中定义的常量。</p> 
<p>代码：程序的指令代码。</p> 
<p><span style="color:#a2e043;">特点：</span></p> 
<p>常量区的数据在<span style="color:#fe2c24;">程序运行期间不能被修改</span>，保证了数据的安全性和稳定性。</p> 
<p>代码区存储程序的指令代码，在程序运行时被载入内存以执行。</p> 
<h2>五 浅拷贝：</h2> 
<p>首先我们来回顾C语言里面的<span style="color:#fe2c24;">基本类型</span>和<span style="color:#fe2c24;">指针类型</span><span style="color:#0d0016;">。</span></p> 
<h4><span style="color:#0d0016;">5.1 基本类型：</span></h4> 
<p>基本类型是C语言内置的数据类型，它们用于存储最基本的数值数据。常见的基本类型包括：int float char……</p> 
<h4><span style="color:#0d0016;">5.2 指针类型：</span></h4> 
<p>指针类型是存储内存地址的数据类型。指针用于指向其他变量或对象在内存中的位置。</p> 
<h4>5.3 基本类型代码示例：</h4> 
<pre><code>#include &lt;iostream&gt;

class BasicType 
{
public:
    int value;

    // 构造函数
    BasicType(int v) 
    {
        value = v;
    }

    // 拷贝构造函数
    BasicType(const BasicType&amp; other) 
    {
        value = other.value;
    }
};

int main() 
{
    BasicType obj1(10);
    BasicType obj2 = obj1;  // 浅拷贝，复制基本类型的值

    std::cout &lt;&lt; "改变前: " &lt;&lt; std::endl;
    std::cout &lt;&lt; "obj1.value: " &lt;&lt; obj1.value &lt;&lt; std::endl;
    std::cout &lt;&lt; "obj2.value: " &lt;&lt; obj2.value &lt;&lt; std::endl;

    obj2.value = 20;  // 修改obj2的值

    std::cout &lt;&lt; "改变后: " &lt;&lt; std::endl;
    std::cout &lt;&lt; "obj1.value: " &lt;&lt; obj1.value &lt;&lt; std::endl;
    std::cout &lt;&lt; "obj2.value: " &lt;&lt; obj2.value &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<p>输出：</p> 
<p><img alt="" height="237" src="https://images2.imgbox.com/cc/20/S1AbuEnn_o.png" width="876"></p> 
<blockquote> 
 <p>值会被复制但修改新对象的值不会影响原对象。</p> 
</blockquote> 
<h4>5.3 指针类型代码示例：</h4> 
<pre><code>#include &lt;iostream&gt;

class SimplePointer 
{
public:
    int* ptr;  // 成员变量 ptr

    // 构造函数
   SimplePointer(int value)
{
    ptr = (int*)malloc(sizeof(int));  // 动态分配内存并初始化
    if (ptr != nullptr) 
    {
        *ptr = value;
    }
}
    SimplePointer(const SimplePointer&amp; other) 
    {
       this-&gt;ptr = other.ptr;  // 浅拷贝，复制内存地址
    }

    void print() const 
    {
        std::cout &lt;&lt; "Value: " &lt;&lt; *ptr &lt;&lt; std::endl;
    }
};

int main() 
{
    SimplePointer obj1(10);  // 创建第一个对象，并将值初始化为10
    SimplePointer obj2(obj1);  // 使用拷贝构造函数（浅拷贝）

    // 打印初始值
    std::cout &lt;&lt; "Initial values:" &lt;&lt; std::endl;
    obj1.print();
    obj2.print();

    // 修改obj2的值
    *obj2.ptr = 20;

    // 打印修改后的值
    std::cout &lt;&lt; "After change:" &lt;&lt; std::endl;
    obj1.print();
    obj2.print(); 

    return 0;
}</code></pre> 
<p>输出：</p> 
<p><img alt="" height="219" src="https://images2.imgbox.com/f6/af/X8gp6C4w_o.png" width="851"></p> 
<blockquote> 
 <p>复制内存地址，共享同一块内存，修改会互相影响</p> 
</blockquote> 
<h2 style="background-color:transparent;">六 深拷贝：</h2> 
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;

class SimpleClass 
{
public:
    int* ptr;

    // 默认构造函数
    SimpleClass(int value) 
    {
        ptr = (int*)malloc(sizeof(int));  // 动态分配内存并初始化
        if (ptr != nullptr) 
        {
            *ptr = value;
        }
    }

    // 深拷贝构造函数
    SimpleClass(const SimpleClass&amp; other) 
    {
        ptr = (int*)malloc(sizeof(int));  // 分配新内存
        if (ptr != nullptr) 
        {
            *ptr = *(other.ptr);  // 复制内容
        }
    }

    // 析构函数
    ~SimpleClass() 
    {
        if (ptr != nullptr) 
        {
            free(ptr);  // 释放内存
        }
    }

    void Print() const 
    {
        if (ptr != nullptr) 
        {
            std::cout &lt;&lt; "Value: " &lt;&lt; *ptr &lt;&lt; std::endl;
        }
    }
};

int main() 
{
    SimpleClass obj1(10);  // 创建对象，ptr 指向的值为 10
    SimpleClass obj2 = obj1;  // 使用深拷贝构造函数

    obj1.Print();
    obj2.Print();

    // 修改 obj2 的值
    if (obj2.ptr != nullptr) 
    {
        *(obj2.ptr) = 20;
    }

    obj1.Print();
    obj2.Print();

    return 0;
}
</code></pre> 
<p>输出：<img alt="" height="181" src="https://images2.imgbox.com/b9/97/FDjNXCf6_o.png" width="875"></p> 
<blockquote> 
 <p>深拷贝不仅复制对象的指针成员，还为指针指向的内容分配新的内存，并复制原对象的数据。这样，两个对象拥有独立的内存，修改一个不会影响另一个。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa7edda545ff1aa38626774f5b3222c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">链表 OJ（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c18d1eaf87d0258d0b54874c6960a84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用【Python】【线性规划】优化工厂生产：实现智能资源配置与利润最大化的现代解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>