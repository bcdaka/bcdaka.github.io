<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Qt的学习日常]--常用控件1 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/94130ab3110d5926b01140e0e288e20a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[Qt的学习日常]--常用控件1">
  <meta property="og:description" content="前言
作者：小蜗牛向前冲
名言：我可以接受失败，但我不能接受放弃
如果觉的博主的文章还不错的话，还请点赞，收藏，关注👀支持博主。如果发现有问题的地方欢迎❀大家在评论区指正
目录
一、什么是控件
二、QWidget属性
1、什么是QWidget
2、Qwidget核心属性 2.1、enabled
2.2、geometry
2.3、windowTitle
2.4、windIcon 2.5、windowOpacity
本期学习：学习控件的基础常识，对部分Qwidget的核心部分进行学习enable,geometry,window-Tilte,windowIcom，windowOpacity。
一、什么是控件 Widget是Qt中的核⼼概念.英⽂原义是&#34;⼩部件&#34;,我们此处也把它翻译为&#34;控件&#34;控件是构成⼀个图形化界⾯的基本要素
上面图中的标识，我们都可以称为控件，在QT中控件的学习是非常重要的，所以我们要学习和掌握它。
在下面我们会学习到上图的一些控件，大家可以结合上图，对应去理解，当我第一次看前面这张图的时候不大脑还是懵逼的，学完之后豁然开然。
当我们打开Qt Creator的时候会有一个Forms文件夹，里面会有我们的widget.ui文件存放我们的相关控件
理解控件可以从两个方面来考虑：
视觉方面：控件是用户界面上可见的元素，它们有各种不同的外观和样式，用于呈现信息、接收输入或执行操作。例如，按钮控件用于触发操作，文本框控件用于接收用户输入，标签控件用于显示文本等等。
功能方面：控件具有各种功能，例如响应用户输入、发出信号、执行操作等。通过连接控件的信号（例如点击按钮时发出的信号）和槽（用于处理信号的函数），可以实现控件之间的交互和应用程序逻辑。
二、QWidget属性 1、什么是QWidget 在Qt中，QWidget（窗口部件）是所有可视化控件的基类，它提供了基本的用户界面功能。QWidget本身可以作为一个容器，用于包含其他控件，也可以作为一个可视化控件直接显示在用户界面上。
因此，QWidget可以被看作是控件的基础，它提供了控件所需的基本功能，如绘制、事件处理、布局管理等。其他更具体的控件，如按钮、文本框、标签等，通常都是从QWidget派生出来的特定类。
因此，可以说QWidget是控件的基类，而其他各种控件则是从QWidget派生出来的具体实现。
2、Qwidget核心属性 2.1、enabled 从字面意思理解，有激活的意思，主要控制控件是否可以被使用。
相关API
API说明isEabled获取到控件的可⽤状态setEabled设置控件是否可使⽤ true 表⽰可⽤,false 表⽰禁⽤ 对于禁用其实非常好理解，就是该控件不在接收任何用户的输入，外观是灰色的，鼠标点击是没有任何反应的(如果点击控件本身可以触发信息的话)。 代码示例: 通过按钮2切换按钮1的禁⽤状态
核心代码：
Widget.cpp
void Widget::on_pushButton_clicked() { qDebug() &lt;&lt; &#34;按下按钮&#34;; } void Widget::on_pushButton_2_clicked() { bool flag = this-&gt;ui-&gt;pushButton-&gt;isEnabled(); this-&gt;ui-&gt;pushButton-&gt;setEnabled(!flag); } 其中 2.2、geometry 对于geometry控件，我们要理解其核心属性:
x：横做标
y：纵坐标
width：宽度
height：高度
这里我们要注意的是 对于Qt的坐标系,是&#34;左⼿坐标系&#34;.其中坐标系的原点是当前元素的⽗元素的左上⻆。
在图形用户界面编程中，窗口通常作为父元素，而窗口中的控件（如按钮、文本框、标签等）作为子元素。父元素（窗口）负责管理和布局这些子元素
但是实际开发中,我们并不会直接使⽤这⼏个属性,⽽是通过⼀系列封装的⽅法来获取/修改.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-16T12:25:24+08:00">
    <meta property="article:modified_time" content="2024-06-16T12:25:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Qt的学习日常]--常用控件1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>前言</strong></p> 
 <p><img alt="" height="28" src="https://images2.imgbox.com/47/2b/8scvWjUn_o.png" width="28"><strong><span style="color:#956fe7;">作者</span>：小蜗牛向前冲</strong></p> 
 <p><img alt="" height="28" src="https://images2.imgbox.com/c5/95/npfYnxFN_o.png" width="28"><strong><span style="color:#956fe7;">名言</span>：我可以接受失败，但我不能接受放弃</strong></p> 
 <p><span style="color:#fe2c24;"><strong>  如果觉的博主的文章还不错的话，还请<img alt="" height="28" src="https://images2.imgbox.com/9a/56/N5zPwQj4_o.png" width="28">点赞，收藏，关注👀支持博主。如果发现有问题的地方欢迎❀大家在评论区指正</strong></span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E4%BB%B6" rel="nofollow">一、什么是控件</a></p> 
<p id="%E4%BA%8C%E3%80%81QWidget%E5%B1%9E%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81QWidget%E5%B1%9E%E6%80%A7" rel="nofollow">二、QWidget属性</a></p> 
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFQWidget-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFQWidget" rel="nofollow">1、什么是QWidget</a></p> 
<p id="2%E3%80%81Qwidget%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7%C2%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81Qwidget%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7%C2%A0" rel="nofollow">2、Qwidget核心属性 </a></p> 
<p id="2.1%E3%80%81enabled-toc" style="margin-left:80px;"><a href="#2.1%E3%80%81enabled" rel="nofollow">2.1、enabled</a></p> 
<p id="2.2%E3%80%81geometry-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81geometry" rel="nofollow">2.2、geometry</a></p> 
<p id="2.3%E3%80%81windowTitle-toc" style="margin-left:80px;"><a href="#2.3%E3%80%81windowTitle" rel="nofollow">2.3、windowTitle</a></p> 
<p id="2.4%E3%80%81windIcon%C2%A0-toc" style="margin-left:80px;"><a href="#2.4%E3%80%81windIcon%C2%A0" rel="nofollow">2.4、windIcon </a></p> 
<p id="2.5%E3%80%81windowOpacity-toc" style="margin-left:80px;"><a href="#2.5%E3%80%81windowOpacity" rel="nofollow">2.5、windowOpacity</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> 本期学习：学习控件的基础常识，对部分Qwidget的核心部分进行学习enable,geometry,window-Tilte,windowIcom，windowOpacity。</p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E4%BB%B6" style="background-color:transparent;">一、什么是控件</h2> 
<p>Widget是Qt中的核⼼概念.英⽂原义是"⼩部件",我们此处也把它翻译为"控件"控件是构成⼀个图形化界⾯的基本要素</p> 
<p><img alt="" height="1007" src="https://images2.imgbox.com/3a/e9/ZGQmymwC_o.png" width="1200"></p> 
<p>上面图中的标识，我们都可以称为控件，在QT中控件的学习是非常重要的，所以我们要学习和掌握它。</p> 
<p>在下面我们会学习到上图的一些控件，大家可以结合上图，对应去理解，当我第一次看前面这张图的时候不大脑还是懵逼的，学完之后豁然开然。</p> 
<p><img alt="" height="978" src="https://images2.imgbox.com/de/8b/9iOZ2beC_o.png" width="882"></p> 
<p>当我们打开Qt Creator的时候会有一个Forms文件夹，里面会有我们的widget.ui文件存放我们的相关控件</p> 
<p><img alt="" height="586" src="https://images2.imgbox.com/63/51/foGrikO3_o.png" width="515"></p> 
<p></p> 
<p>理解控件可以从两个方面来考虑：</p> 
<blockquote> 
 <ol><li> <p><strong>视觉方面</strong>：控件是用户界面上可见的元素，它们有各种不同的外观和样式，用于呈现信息、接收输入或执行操作。例如，<strong>按钮控件用于触发操作</strong>，<strong>文本框控件用于接收用户输入，标签控件用于显示文本</strong>等等。</p> </li><li> <p><strong>功能方面</strong>：控件具有各种功能，例如响应用户输入、发出信号、执行操作等。通过连接控件的信号（例如点击按钮时发出的信号）和槽（用于处理信号的函数），可以实现控件之间的交互和应用程序逻辑。</p> </li></ol> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81QWidget%E5%B1%9E%E6%80%A7">二、QWidget属性</h2> 
<h3 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFQWidget" style="background-color:transparent;">1、什么是QWidget</h3> 
<p>在Qt中，<strong>QWidget（窗口部件）</strong>是所有可视化控件的基类，它提供了基本的用户界面功能。QWidget本身可以作为一个容器，用于包含其他控件，也可以作为一个可视化控件直接显示在用户界面上。</p> 
<p>因此，QWidget可以被看作是控件的基础，<strong>它提供了控件所需的基本功能，如绘制、事件处理、布局管理</strong>等。其他更具体的控件，如按钮、文本框、标签等，通常都是从QWidget派生出来的特定类。</p> 
<p>因此，可以说QWidget是控件的基类，而其他各种控件则是从QWidget派生出来的具体实现。</p> 
<p><img alt="" height="667" src="https://images2.imgbox.com/df/42/HoyEwHdx_o.png" width="1200"></p> 
<h3 id="2%E3%80%81Qwidget%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7%C2%A0" style="background-color:transparent;">2、Qwidget核心属性 </h3> 
<h4 id="2.1%E3%80%81enabled" style="background-color:transparent;">2.1、enabled</h4> 
<p>从字面意思理解，有激活的意思，主要控制控件是否可以被使用。</p> 
<p><strong>相关API</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>API</td><td>说明</td></tr><tr><td>isEabled</td><td>获取到控件的可⽤状态</td></tr><tr><td>setEabled</td><td>设置控件是否可使⽤ true 表⽰可⽤,false 表⽰禁⽤</td></tr></tbody></table> 
<p>对于禁用其实非常好理解，就是该控件不在接收任何用户的输入，外观是灰色的，鼠标点击是没有任何反应的(如果点击控件本身可以触发信息的话)。  </p> 
<p><strong>代码示例: 通过按钮2切换按钮1的禁⽤状态</strong></p> 
<p>核心代码：</p> 
<p>Widget.cpp</p> 
<pre><code class="language-cpp">void Widget::on_pushButton_clicked()
{
qDebug() &lt;&lt; "按下按钮";
}
void Widget::on_pushButton_2_clicked()
{
bool flag = this-&gt;ui-&gt;pushButton-&gt;isEnabled();
this-&gt;ui-&gt;pushButton-&gt;setEnabled(!flag);
}</code></pre> 
<p>其中 </p> 
<p><img alt="" height="620" src="https://images2.imgbox.com/ac/b6/W5nHOubM_o.png" width="818"></p> 
<h4 id="2.2%E3%80%81geometry" style="background-color:transparent;">2.2、geometry</h4> 
<p>对于geometry控件，我们要理解其核心属性:</p> 
<p><img alt="" height="623" src="https://images2.imgbox.com/03/5d/wGyzcxYZ_o.png" width="1192"></p> 
<blockquote> 
 <p>x：横做标</p> 
 <p>y：纵坐标</p> 
 <p>width：宽度</p> 
 <p>height：高度</p> 
</blockquote> 
<p>这里我们要注意的是 对于Qt的坐标系,是"左⼿坐标系".其中<strong>坐标系的原点是当前元素的⽗元素的左上⻆。</strong></p> 
<p>在图形用户界面编程中，窗口通常作为父元素，而窗口中的控件（如按钮、文本框、标签等）作为子元素。父元素（窗口）负责管理和布局这些子元素</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/bc/3a/xZh0kxM0_o.png" width="1200"></p> 
<p>但是实际开发中,我们并不会直接使⽤这⼏个属性,⽽是通过⼀系列封装的⽅法来获取/修改.</p> 
<p><strong>常用API</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>API</td><td>说明</td></tr><tr><td>geometry()</td><td>获取控制的位置(x,y)和尺寸(width,hight),返回类型是QRect，包含了x,y,width，height的属性</td></tr><tr><td> <p>setGeometry(QRect)</p> <p>setGeometry(int x,int y, int wideh,int hight)</p> </td><td>设置控件的位置和尺寸，可以直接设置⼀个QRect,也可以分四个属性单独设置</td></tr></tbody></table> 
<p><strong>例子演示：⼀个表⽩程序</strong></p> 
<p>在widget,cpp中，添加slot(槽函数)</p> 
<pre><code class="language-cpp">void Widget::on_pushButton_clicked()
{
    ui-&gt;label-&gt;setText("太好了，一起去玩吧！！！");
}

void Widget::on_pushButton_2_clicked()
{
    //获取窗口的高度和宽度
    int width = this-&gt;geometry().width();
    int height = this-&gt;geometry().height();

    //重新生成按键的位置
    int x = rand()%width;
    int y = rand()%height;

    //重新设置位置
    ui-&gt;pushButton_2-&gt;move(x,y);
}
</code></pre> 
<p> <img alt="" height="705" src="https://images2.imgbox.com/34/14/F8mJS1EW_o.png" width="1200"></p> 
<p>这里只有点接受，就会打印出一下一句话，拒绝的话，按键就会随机移动造成点不到的现象。</p> 
<p>对于窗口信息来说果widget作为⼀个窗⼝(带有标题栏,最⼩化,,最⼤化,关闭按钮),那么在计算尺⼨和坐标的时候就有两种算法.包含w<strong>indow frame和不包含window frame</strong></p> 
<p>其中frameGeometry是<strong>带window frame</strong>（窗口包含标题栏，最小化，最大化等)，</p> 
<p>geometry是不带<strong>window frame（也就是不包含</strong>标题栏，最小化，最大化等<strong>）</strong></p> 
<p>简单来说，<code>frameGeometry</code> 是窗口在屏幕上的总体占位，而 <code>geometry</code> （是在客户端）是窗口内部。</p> 
<p>为了更好的理解geometry和frameGeometry的区别</p> 
<p><strong>在界⾯上放置⼀个按钮</strong></p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/4d/de/kK5GmwTz_o.png" width="1150"></p> 
<p><strong>在按钮的slot函数中,编写代码</strong><br>  </p> 
<pre><code class="language-cpp">void Widget::on_pushButton_clicked()
{
    QRect rect1 = this-&gt;geometry();
    QRect rect2 = this-&gt;frameGeometry();
    qDebug() &lt;&lt; rect1;
    qDebug() &lt;&lt; rect2;
}</code></pre> 
<p><strong>在构造函数中,也添加同样的代码</strong></p> 
<pre><code class="language-cpp">Widget::Widget(QWidget *parent)
: QWidget(parent)
, ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);
    QRect rect1 = this-&gt;geometry();
    QRect rect2 = this-&gt;frameGeometry();
    qDebug() &lt;&lt; rect1;
    qDebug() &lt;&lt; rect2;
}
</code></pre> 
<p>执⾏程序,可以看到,构造函数中,打印出的geometry和frameGeometry是相同的.<br> 但是在点击按钮时,打印的geometry和frameGeometry则存在差异.</p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/7b/d5/Z4xsvcWx_o.png" width="1200"></p> 
<blockquote> 
 <p>在构造函数中</p> 
 <ul><li><strong>构造函数执行时</strong>：此时窗口尚未显示，它的位置和尺寸可能还没有被窗口管理器完全处理。因此，<code>geometry()</code> 和 <code>frameGeometry()</code> 返回相同的值，通常是因为窗口还没有被分配一个框架（标题栏和边框）。在这个阶段，窗口的位置和大小仅仅是你在代码中设置的，或者是由 Qt 的默认布局决定的（如果没有明确设置）。</li></ul> 
 <p>在按钮点击事件中</p> 
 <ul><li><strong>点击按钮执行时</strong>：此时窗口已经被完全创建并显示出来，窗口管理器已经应用了框架，这包括标题栏和边框等。这时，<code>geometry()</code> 返回的是窗口内容区域的大小和位置，而 <code>frameGeometry()</code> 返回的是包括窗口框架的整体大小和位置。因此，两者出现差异是因为窗口框架被包括在内。</li></ul> 
 <p>如何理解这些差异？</p> 
 <ol><li> <p><strong>geometry()</strong>：<span style="color:#fe2c24;"><strong>返回窗口的客户区（内容显示区）的几何信息，不包括窗口的边框和标题栏。</strong></span></p> </li><li> <p><strong>frameGeometry()</strong>：<span style="color:#fe2c24;"><strong>返回包括窗口边框和标题栏在内的整个窗口的几何信息。</strong></span></p> </li></ol> 
 <p>这种设计允许开发者能够精确控制窗口内容的布局，同时也能够处理涉及整个窗口尺寸和位置的操作，如窗口的拖动和调整大小。</p> 
 <p>最佳实践</p> 
 <ul><li> <p><strong>初始化和布局</strong>：通常，最好在窗口显示后（例如在 <code>show()</code> 或 <code>showMaximized()</code> 调用之后）查询和操作窗口的几何属性，这样可以确保窗口管理器已经应用了所有的框架和布局设置。</p> </li><li><strong>事件处理</strong>：在处理如点击等事件时，根据需要查询 <code>geometry()</code> 或 <code>frameGeometry()</code>，以获取最准确的窗口状态信息。</li></ul> 
</blockquote> 
<h4 id="2.3%E3%80%81windowTitle" style="background-color:transparent;">2.3、windowTitle</h4> 
<p>这个控件非常简单，就是获取控件的窗口标题</p> 
<table><tbody><tr><td>API</td><td>说明</td></tr><tr><td>windowTitle()</td><td>获取到控件的窗⼝标题.</td></tr><tr><td>setWindowTitle(const<br> QString&amp;title)</td><td>设置控件的窗⼝标题.</td></tr></tbody></table> 
<p><strong> 代码⽰例:设置窗⼝标题</strong></p> 
<p>修改widget.cpp</p> 
<pre><code class="language-cpp">Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);
    // 设置窗⼝标题
    this-&gt;setWindowTitle("这是标题");
}</code></pre> 
<p>执⾏效果</p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/fc/26/bS4UMTQ7_o.png" width="1200"></p> 
<h4 id="2.4%E3%80%81windIcon%C2%A0" style="background-color:transparent;">2.4、windIcon </h4> 
<p>这个控件是获取控件的图标</p> 
<table><tbody><tr><td>API</td><td>说明</td></tr><tr><td>windowIcon()</td><td>获取到控件的窗⼝图标.返回QIcon对象.</td></tr><tr><td>setWindowIcon(const<br> QIcon&amp;icon)</td><td>设置控件的窗⼝图标.</td></tr></tbody></table> 
<p> 那这个有什么用呢，其实上面说的和我将在下面为大家分享的控件无非<strong>是为了让用户界面变的更好看</strong>。比如这里我们可以通过这个windowIconAPI将窗口界面改的更加好看，比如下面我们通过调用将控件的图标变成了一朵花。</p> 
<p><img alt="" height="719" src="https://images2.imgbox.com/94/22/15W8FcnW_o.png" width="1200"></p> 
<p>这朵花，其实是一个资源，他要被系统调用 ，肯定要知道他的路径在那里。</p> 
<p>对于路径可以分为<strong>相对路径</strong>和<strong>绝对路径。</strong></p> 
<blockquote> 
 <p><strong>绝对路径: </strong>以盘符(windows)或者以 <strong>/  </strong>(Linux)开头的路径.<br><strong>相对路径</strong>: 以<strong> .</strong> (表⽰当前路径)或者以<strong> .. </strong>(表⽰当前路径上级路径)开头的路径.其中<strong> . </strong>经常也<br> 会省略.相对路径的前提是需要明确"当前⼯作⽬录".</p> 
</blockquote> 
<p>实际开发中,我们⼀般不会在代码中通过绝对路径引⼊图⽚.因为我们⽆法保证程序发布后,⽤<br> 户的电脑上也有同样的路径。</p> 
<p>所以我们在开发的过程中，往往会引入相对路径。则需要确保代码中的相对路径写法和图⽚实际所在的路径匹配(⽐如代码中写作"./image/rose.jpg",就需要在当前⼯作⽬录中创建image⽬录,并把rose.jpg放进去).</p> 
<p>在qt中为了保证：</p> 
<blockquote> 
 <ul><li>你要使用的图片的路径是在目标用户机器上存在的</li><li>保证改不图不会被用户随意删除</li></ul> 
</blockquote> 
<p>引入了一个qrc机制。 </p> 
<p>qrc⽂件<strong>是⼀种XML格式的资源配置⽂件</strong>,它⽤XML记录硬盘上的⽂件和对应的随意指定的资<br> 源名称.应⽤程序通过资源名称来访问这些资源.<br> 在Qt开发中,可以通过<strong>将资源⽂件添加到项⽬中</strong>来⽅便地访问和管理这些资源.这些资源⽂件<br> 可以<strong>位于qrc⽂件所在⽬录的同级或其⼦⽬录下</strong><br><span style="color:#fe2c24;"><strong>在构建程序的过程中,Qt会把资源⽂件的⼆进制数据转成cpp代码,编译到exe中.从⽽使依赖的资源变得"路径⽆关".</strong></span><br><strong>代码⽰例:通过qrc管理图⽚作为图标</strong></p> 
<p><strong> </strong>右键项⽬,创建⼀个QtResourceFile(qrc⽂件),⽂件名随意起(不要带中⽂),此处叫做resource.qrc</p> 
<p><img alt="" height="802" src="https://images2.imgbox.com/d6/66/iCI13d6z_o.png" width="1200"></p> 
<p>在qrc编辑器中,添加前缀.</p> 
<p><img alt="" height="460" src="https://images2.imgbox.com/b6/95/L1S3FT9x_o.png" width="1200"></p> 
<p> 所谓的前缀,可以理解成"⽬录".这个前缀决定了后续我们如何在代码中访问资源</p> 
<p>在资源编辑器中,点击 add Files 添加资源⽂件.此处我们需要添加的是device.jpg</p> 
<p><img alt="" height="782" src="https://images2.imgbox.com/58/3c/xYO6jYvR_o.png" width="1200"></p> 
<p>注意:添加的⽂件必须是在qrc⽂件的同级⽬录,或者同级⽬录的⼦⽬录中.因此我们需要把之前D盘中的device.jpg复制到上述⽬录中<br> 添加完毕后,可以在资源编辑器中看到添加好的⽂件</p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/38/7c/MxHMlwLr_o.png" width="711"></p> 
<p>编辑widget.cpp<br>  </p> 
<pre><code class="language-cpp">Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui-&gt;setupUi(this);
    this-&gt;setWindowTitle("标题");

    //创建图标对象
    QIcon icon(":device.jpg");
    //设置图标
    this-&gt;setWindowIcon(icon);

    //获取当前路径
    QString currentDir = QDir::currentPath();
    //设置工作目录到lable中
   ui-&gt;label-&gt;setText(currentDir);
}</code></pre> 
<p> <img alt="" height="557" src="https://images2.imgbox.com/cc/b9/RDvZodID_o.png" width="1200"></p> 
<p> 接下来,我们可以进⼊到项⽬的构建⽬录,可以看到,⽬录中多了⼀个 qrc_resource.cpp ⽂件.直接打开这个⽂件,可以看到类似如下代码:<br><img alt="" height="611" src="https://images2.imgbox.com/31/d7/EI1gAYBh_o.png" width="1200"></p> 
<p>上述代码其实就是通过unsigned char 数组,把device.jpg每个字节都记录下来.这些代码会被编译到exe中.后续⽆论exe被复制到哪个⽬录下,都确保能够访问到该图⽚资源.</p> 
<p><strong>对qrc机制总结</strong></p> 
<blockquote> 
 <p><strong>优点：</strong>确保了图⽚,字体,声⾳等资源能够真正做到"⽬录⽆关",⽆论如何都不会出现资源丢失的情况。</p> 
 <p><strong>缺点</strong>：<span style="color:#fe2c24;"><strong>不适合管理体积⼤的资源.</strong></span>如果资源⽐较⼤(⽐如是⼏个MB的⽂件),或者资源特别多,⽣成的最终的<strong>exe体积就会⽐较⼤,</strong>程序运⾏<strong>消耗的内存也会增⼤</strong>,<strong>程序编译的时间也会显著增加.</strong></p> 
</blockquote> 
<h4 id="2.5%E3%80%81windowOpacity" style="background-color:transparent;">2.5、windowOpacity</h4> 
<p>Opacity的英文：</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/37/ca/mqxdyLig_o.png" width="922"></p> 
<p>所以这个控件是用来调节控件透明度的。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>API<br>  </td><td>说明</td></tr><tr><td>windowOpacity()</td><td> <p style="margin-left:0;text-align:justify;">获取到控件的不透明数值.返回float,取值为0.0-&gt;1.0其中0.0表⽰全透明,1.0表⽰完全不透明.</p> </td></tr><tr><td> <p style="margin-left:0;text-align:justify;">setWindowOpacity(flo</p> <p style="margin-left:0;text-align:justify;">atn)</p> </td><td>设置控件的不透明数值.</td></tr></tbody></table> 
<p><strong>代码⽰例:调整窗⼝透明度</strong></p> 
<p>1)在界⾯上拖放两个按钮,分别⽤来增加不透明度和减少不透明度.<br> objectName分别为pushButton_add 和 pushButton_sub</p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/0c/ea/ExEKHw52_o.png" width="802"></p> 
<p> 2)编写wdiget.cpp,编写两个按钮的slot函数<br> • 点击pushButton_sub 会减少不透明度,也就是窗⼝越来越透明.<br> • 点击pushButton_add 会增加不透明度,窗⼝会逐渐恢复.</p> 
<pre><code class="language-cpp">void Widget::on_pushButton_add_clicked()
{
    float opacity = this-&gt;windowOpacity();
    if (opacity &gt;= 1.0) {
       return;
    }
    qDebug() &lt;&lt; opacity;
    opacity += 0.1;
    this-&gt;setWindowOpacity(opacity);
}
void Widget::on_pushButton_sub_clicked()
{
    float opacity = this-&gt;windowOpacity();
    if (opacity &lt;= 0.0) {
       return;
    }
    qDebug() &lt;&lt; opacity;
    opacity -= 0.1;
    this-&gt;setWindowOpacity(opacity);
}
</code></pre> 
<p>执⾏程序,可以看到,点击了⼏下-之后,就可以透过窗⼝看到后⾯的猫猫头了.点击+⼜会逐渐恢复</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/aa/8f/dfE2Zmp9_o.png" width="806"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca9f12291003cd6a03d0bdc2b3fb1719/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">鸿蒙解决JSON字段名和对象属性名之间的对应关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b5c9aed9fe7a2f698d271e0c48f70ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一些个人电脑用的小工具软件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>