<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之ArrayList与顺序表（下） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/813f247e5cfa8a773a33fc234dce4891/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之ArrayList与顺序表（下）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
ArrayList的具体使用 118. 杨辉三角
扑克洗牌算法 接上篇：数据结构之ArrayList与顺序表（上）-CSDN博客
ArrayList的具体使用 118. 杨辉三角 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1:
输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2:
输入: numRows = 1 输出: [[1]] 1 &lt;= numRows &lt;= 30 分析：首先是一个杨辉三角的问题，杨辉三角其实就是一个只有一半的二维数组。 public class Test { public static void main(String[] args) { // 打印杨辉三角 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int count = 0; // 创建一个n行n列的二维数组 int[][] array = new int[n][n]; for (int i = 0; i &lt; n; i&#43;&#43;) { for (int j = 0; j &lt; n; j&#43;&#43;) { if (i == j) { array[i][j] = 1; }else if (j == 0) { array[i][j] = 1; }else { // 只有从第二行开始才会有下面的规律 if (i &gt;= 2) { array[i][j] = array[i-1][j] &#43; array[i-1][j-1]; } } } } for (int[] x:array) { for (int y:x) { if (y !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-08T20:05:47+08:00">
    <meta property="article:modified_time" content="2024-06-08T20:05:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之ArrayList与顺序表（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="ArrayList%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:0px;"><a href="#ArrayList%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">ArrayList的具体使用 </a></p> 
<p id="118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-toc" style="margin-left:40px;"><a href="#118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92" rel="nofollow">118. 杨辉三角</a></p> 
<p id="%E6%89%91%E5%85%8B%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%89%91%E5%85%8B%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%C2%A0" rel="nofollow">扑克洗牌算法 </a></p> 
<hr id="hr-toc"> 
<p>接上篇：<a href="https://blog.csdn.net/2301_80854132/article/details/139523921?spm=1001.2014.3001.5501" title="数据结构之ArrayList与顺序表（上）-CSDN博客">数据结构之ArrayList与顺序表（上）-CSDN博客</a></p> 
<h2 id="ArrayList%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%C2%A0"><span style="color:#fe2c24;">ArrayList的具体使用 </span></h2> 
<h3 id="118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><a href="https://leetcode.cn/problems/pascals-triangle/description/" rel="nofollow" title="118. 杨辉三角">118. 杨辉三角</a></h3> 
<blockquote> 
 <p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code> </em>行。</p> 
 <p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="240" src="https://images2.imgbox.com/6b/a0/S7dYLCUm_o.gif" width="260"></p> 
 <p><strong>示例 1:</strong></p> 
 <pre><strong>输入:</strong> numRows = 5
<strong>输出:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
</pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><strong>输入:</strong> numRows = 1
<strong>输出:</strong> [[1]]</pre> 
 <ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul> 
</blockquote> 
<p><span style="color:#ff9900;">分析：</span>首先是一个杨辉三角的问题，杨辉三角其实就是一个只有一半的二维数组。 </p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/48/52/pUw9ByBj_o.png" width="1200"></p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 打印杨辉三角
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int count = 0;
        // 创建一个n行n列的二维数组
        int[][] array = new int[n][n];
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i == j) {
                    array[i][j] = 1;
                }else if (j == 0) {
                    array[i][j] = 1;
                }else {
                    // 只有从第二行开始才会有下面的规律
                    if (i &gt;= 2) {
                        array[i][j] = array[i-1][j] + array[i-1][j-1];
                    }
                }
            }
        }
        for (int[] x:array) {
            for (int y:x) {
                if (y != 0) {
                    System.out.print(y+" ");
                }
            }
            System.out.println();
        }
    }
}</code></pre> 
<p><span style="color:#a2e043;">打印结果：</span></p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/63/05/TENiiw34_o.png" width="960"></p> 
<p>注意：杨辉三角还有一个规律就是第 i-1 行有 i 个元素。 </p> 
<p>这里主要的难点是：List&lt;List&lt;Integer&gt;&gt;   这个代码的意思是什么？分开看，List&lt;Integer&gt; 这个代码的意思是有一个线性表，这个线性表中存放的是 Integer 类型。List&lt;List&lt;Integer&gt;&gt; 难道这个代码的意思是有一个线性表，这个线性表里面存放的是一个线性表？没错！不过这个不叫线性表了。如果我们把这个List看成一个数组，那就是一个数组里面存放的是一个一个的数组元素，然后这些数组元素里面的元素是一个一个的整形包装类。这就是二维数组嘛！二维数组里面是一个一个的一维数组，而一维数组里面是一个一个的整型元素。</p> 
<p>例如：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 二维数组
        // 根据顺序表的特点这个二维数组为0行0列
        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); 
        //二维数组的初始化
        list.add(new ArrayList&lt;&gt;()); // 二维数组的元素是一维数组
        list.add(new ArrayList&lt;&gt;()); // 二维数组的元素是一维数组
        list.add(new ArrayList&lt;&gt;()); // 二维数组的元素是一维数组
        // 一维数组的初始化
        list.get(0).add(10); // list.get(0)得到的是下标为0的一维数组，接着尾插10
        list.get(1).add(20); // list.get(1)得到的是下标为1的一维数组，接着尾插20
        list.get(2).add(30); // list.get(2)得到的是下标为2的一维数组，接着尾插30
    }
}</code></pre> 
<p>画图理解：</p> 
<p><img alt="" height="1112" src="https://images2.imgbox.com/da/cb/GjbcKR0o_o.png" width="1200"></p> 
<p> 上面搞懂了，就可以开始做题了。这个题目的意思就是让我们把存放杨辉三角二维数组改成一个ArrayList。</p> 
<p>根据我们用二维数组做题时的代码改编一下就可以了。</p> 
<p><span style="color:#ff9900;">下面是改编的代码：</span></p> 
<p><span style="color:#ff9900;">方法一：</span></p> 
<pre><code class="language-java">public class Test {
    public static List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
        // 创建一个二维数组
        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        for (int i = 0; i &lt; numRows; i++) {
            // 不用下标直接尾插也是可以的
            list.add(i, new ArrayList&lt;&gt;());
        }
        // 开始为二维数组存放元素
        for (int i = 0; i &lt; numRows; i++) {
            List&lt;Integer&gt; list1 = list.get(i);
            //        注意这里j的条件
            for (int j = 0; j &lt;= i; j++) {
                if (i == j) {
                    list1.add(1);
                }else if (j == 0) {
                    list1.add(1);
                }else if (i &gt;= 2) {
                    // 实现这个代码：a[i][j] = a[i-1][j]+a[i-1][j-1];
                    // 得到i-1下标数组的j位置的值  得到i-1下标数组的j-1位置的值

                    // 这个写法有问题。就像：3 = 5
                    // list.get(i).get(j) = list.get(i-1).get(j)  + list.get(i-1).get(j-1);
                    // 这个就是对上面的代码进行翻译一下
                    int t  = list.get(i - 1).get(j) + list.get(i - 1).get(j - 1);
                    list1.add(j , t);
                }
            }
        }
        return list;
    }
    public static void main(String[] args) {
        List&lt;List&lt;Integer&gt;&gt; listList = generate(5);
        for (List&lt;Integer&gt; list : listList) {
            for (Integer x : list) {
                System.out.print(x+" ");
            }
            System.out.println();
        }
    }
}</code></pre> 
<p><span style="color:#a2e043;">方法二： </span></p> 
<pre><code class="language-java">public class TestDrive {
    public static List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
        // 创建一个二维数组
        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        for (int i = 0; i &lt; numRows; i++) {
            // 不用下标直接尾插也是可以的
            list.add(i, new ArrayList&lt;&gt;());
            // 为二维数组的每一位元素的初始化为0
            for (int j = 0; j &lt; numRows; j++) {
                list.get(i).add(j,0);
            }
        }
        // 开始为二维数组存放元素
        for (int i = 0; i &lt; numRows; i++) {
            List&lt;Integer&gt; list1 = list.get(i);
            //      注意这里的j和方法进行区别
            for (int j = 0; j &lt; numRows; j++) {
                if (i == j) {
                    // 因为所有元素都有初始值了，所以这里就都是set而不是add
                    list1.set(j,1);
                }else if (j == 0) {
                    list1.set(j,1);
                }else if (i &gt;= 2) {
                    int t  = list.get(i - 1).get(j) + list.get(i - 1).get(j - 1);
                    list1.set(j , t);
                }
            }
        }
        return list;
    }
    public static void main(String[] args) {
        List&lt;List&lt;Integer&gt;&gt; listList = generate(5);
        for (List&lt;Integer&gt; list : listList) {
            for (Integer x : list) {
                if (x != 0) {
                    System.out.print(x+" ");
                }
            }
            System.out.println();
        }
    }
}
</code></pre> 
<p><span style="color:#ed7976;">方法一与方法二的区别：</span></p> 
<p>方法二就是完全对前面代码的改编。因为前面我们在创建一个二维数组的同时是进行了初始化的，所以这里的所有元素都是有初始值的。但我们用顺序表来创建二维数组的时候，如果没有初始化，那么其值就是null，这个是不能参与运算的。因此，我们要手动的置为0，这样就可以参与运算了，否则就会发生异常。</p> 
<p>方法一就是改进了方法二的不足之处。既然你不初始化，在运算时，会发生异常，那么我就把你的范围卡在只参与运算的部分。也就是 j &lt;= i 。我们仔细观察会发现杨辉三角是一个等腰直角三角形。如下图：</p> 
<p><img alt="" height="1027" src="https://images2.imgbox.com/55/09/EeGDEewb_o.png" width="1200"></p> 
<p>杨辉三角练习完了，接下来，就要进入重磅戏了：扑克洗牌算法。 </p> 
<h3 id="%E6%89%91%E5%85%8B%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%C2%A0"><span style="color:#38d8f0;"><strong>扑克洗牌算法 </strong></span></h3> 
<p>要求：</p> 
<p>1. 生成一副扑克牌。</p> 
<p>2. 并且把这副扑克牌打乱。</p> 
<p>3. 发给3个人，每人每轮发一张，总共发5轮。 </p> 
<p><span style="color:#494949;">一张一张的牌，一张牌包括牌面值和花色 </span></p> 
<pre><code class="language-java">// 一张牌
public class Card {
    public int rank; // 牌面值
    public String suit; // 对应的花色

    public Card(int rank, String suit) {
        this.rank = rank;
        this.suit = suit;
    }

    @Override
    public String toString() {
        return ""+suit+rank+" ";
    }
}
</code></pre> 
<p>有了一张一张的牌，就可以生成一副牌和存放牌的容器，也就是顺序表</p> 
<pre><code class="language-java">public class Cards {
    // 生成牌的四色
    public static final String suit[] = {"♠","♣","♥","♦"};
    public List&lt;Card&gt; cardList;

    // 在new一个对象的时候，就会生成存储一副牌的数组
    public Cards() {
        this.cardList = new ArrayList&lt;&gt;();
    }

    // 生成一副牌
    // 为了方便，这里的牌面值都用数字表示
    public List&lt;Card&gt; generateCards() {
        for (int i = 1; i &lt;= 14; i++) {
            int count = 0;
            for (int j = 0; j &lt; suit.length; j++) {
                // 生成一张牌
                Card card = new Card(i, suit[j]);
                // 把牌存放到数组中
                cardList.add(card);
                if (i &gt; 13 &amp;&amp; count &lt; 2) {
                    count++;
                }
                if (count == 2) {
                    break;
                }
            }
        }
        return cardList;
    }
}</code></pre> 
<p>接下来就是要开始洗牌了。</p> 
<pre><code class="language-java">    // 洗牌
    public void shuffle() {
        // 通过随机下标进行交换
        Random random = new Random();
        // i=0就是自己和自己交换了
        for (int i = cardList.size()-1; i &gt; 0; i--) {
            // 生成[0,i)之间的值，也就是[0,i-1]
            int index = random.nextInt(i);
            swap(cardList, index, i);
        }
    }

    private void swap(List&lt;Card&gt; cardList, int index, int i) {
        // 交换index和i下标对应的数组元素
        // int tmp = a; a = b; b = tmp;
        Card tmp = cardList.get(i);
        // 把i下标的值，改为index下标对应的值
        cardList.set(i, cardList.get(index));
        cardList.set(index, tmp);
    }</code></pre> 
<p> 发牌</p> 
<pre><code class="language-java">    // 发牌
    // 给3人发5轮牌，每人每轮发一张
    public List&lt;List&lt;Card&gt;&gt; dealCards() {
        // 创建一个二维数组
        List&lt;List&lt;Card&gt;&gt; listList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 3; i++) {
            listList.add(new ArrayList&lt;&gt;());
        }
        for (int i = 0; i &lt; 5; i++) {
            for (int j = 0; j &lt; 3; j++) {
                // 第j个人拿到第0下标的牌
                listList.get(j).add(cardList.get(0)); // 假设从最上面开始拿
                // 每拿一张就少一张
                cardList.remove(0);
            }
        }
        return listList;
    }</code></pre> 
<p>测试：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        // 生成一副牌
        Cards cards = new Cards();
        List&lt;Card&gt; cardList = cards.generateCards();
        System.out.println(cardList);

        // 开始洗牌——将牌的顺序打乱
        cards.shuffle();
        System.out.println(cardList);

        // 开始发牌
        List&lt;List&lt;Card&gt;&gt; listList = cards.dealCards();


        // 查看结果
        int i = 1;
        for (List&lt;Card&gt; list: listList) {
            System.out.print("第"+i+"个人拿到的牌：");
            for (Card x : list) {
                System.out.print(x+" ");
            }
            i++;
            System.out.println();
        }
    }
}</code></pre> 
<p> 好啦！本期 数据结构之ArrayList与顺序表（下）的学习就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e5b201309532ae87983693d31f48fc7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三端植物大战僵尸杂交版来了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/129851e9eb896eb5b3b23ef0c5c62203/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入解析Kafka消息丢失的原因与解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>