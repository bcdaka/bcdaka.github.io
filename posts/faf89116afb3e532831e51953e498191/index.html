<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】聊聊数据库是如何保证数据不丢的 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/faf89116afb3e532831e51953e498191/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL】聊聊数据库是如何保证数据不丢的">
  <meta property="og:description" content="对于一个存储系统来说，其中比较关键的核心组件包含，网络、存储模型、持久化、数据结构等。而数据如何保证不丢失，对于不同的存储系统来说，比如Redis采用AOF和RDB的方式进行混合使用，而MySQL采用日志进行保证。也就是redo\undo\bin log。本篇就聊聊数据库是如何进行不丢失的。
总体流程 对于数据不丢失，其实就是针对更新语句（update\delete\insert）的操作流程，其中主要靠redo log保证恢复事务，undo log 回滚事务。
bin log的写入机制 binlog在事务执行过程中，把日志写到binlog cache中，等事务提交的时候，再把binlog cache写到binlog中。而操作的维度就是一个事务。
系统给binlog cache分配了一片内存，每个线程一个。binlog_cache_size 控制单个线程内binlog cache所占内存的大小，超过之后，就暂存到磁盘中。
事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中。并清空binlog cache
每个线程都有自己的binlog cache，但是对于bin log来说共用的。
write：把日志文件binlog cache写入到binlog files中，也就是paeg cache中，因为是内存操作，所以速度比较快。fsync: 将数据从page cache写入到本次磁盘中，这个比较费时，所以可能是影响IOPS的一个因素。 决定执行write和fsync由sync_binlog参数决定。
sync_binlog=0 每次提交事务只write，不fsyncsync_binlog=1 提交事务的时候都fsyncsync_binlog&gt;1 提交事务的只write ,但是积累到N个事务才fsync。其实就是批处理。 其实就是在性能和可用性之间进行权衡，在时机中，一般都是设置成100-1000中的某个值。但是当系统发生宕机的时候，可能丢失N个事务的binlog 日志。
redo log的写入机制 redo log是先写入redo log buffer-&gt; page cache -&gt; 磁盘
从而就对应三种写入状态
写入时机 存储在redo log buffer中，其实就是MySQL进程内存中。红色部分写到磁盘write，但是没有持久化(fsync) 文件系统的page cache里面，黄色部分持久化到磁盘里，就是hard disk，绿色部分。 InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，控制写入策略。
0 ： 事务提交时，只把redo log留在redo log buffer中。1 ： 事务提交时，redo log 持久化到磁盘2 ： 事务提交时，redo log 写到page cache中。 如图5就是将定时将脏页进行刷新操作。而对于bin log来说，是依靠每次事务提交的时候进行刷盘。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-15T22:08:59+08:00">
    <meta property="article:modified_time" content="2024-06-15T22:08:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】聊聊数据库是如何保证数据不丢的</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>对于一个存储系统来说，其中比较关键的核心组件包含，网络、存储模型、持久化、数据结构等。而数据如何保证不丢失，对于不同的存储系统来说，比如Redis采用AOF和RDB的方式进行混合使用，而MySQL采用日志进行保证。也就是redo\undo\bin log。本篇就聊聊数据库是如何进行不丢失的。</p> 
<h3><a id="_1"></a>总体流程</h3> 
<p>对于数据不丢失，其实就是针对更新语句（update\delete\insert）的操作流程，其中主要靠redo log保证恢复事务，undo log 回滚事务。<br> <img src="https://images2.imgbox.com/96/80/6TGLcLmp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="bin_log_4"></a>bin log的写入机制</h3> 
<p>binlog在事务执行过程中，把日志写到binlog cache中，等事务提交的时候，再把binlog cache写到binlog中。而操作的维度就是一个事务。<br> 系统给binlog cache分配了一片内存，每个线程一个。<code>binlog_cache_size</code> 控制单个线程内binlog cache所占内存的大小，超过之后，就暂存到磁盘中。<br> 事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中。并清空binlog cache<br> <img src="https://images2.imgbox.com/d6/7d/ZHzYz3l6_o.png" alt="在这里插入图片描述"><br> 每个线程都有自己的binlog cache，但是对于bin log来说共用的。</p> 
<ul><li>write：把日志文件binlog cache写入到binlog files中，也就是paeg cache中，因为是内存操作，所以速度比较快。</li><li>fsync: 将数据从page cache写入到本次磁盘中，这个比较费时，所以可能是影响IOPS的一个因素。</li></ul> 
<p>决定执行write和fsync由sync_binlog参数决定。</p> 
<ul><li>sync_binlog=0 每次提交事务只write，不fsync</li><li>sync_binlog=1 提交事务的时候都fsync</li><li>sync_binlog&gt;1 提交事务的只write ,但是积累到N个事务才fsync。其实就是批处理。</li></ul> 
<p>其实就是在性能和可用性之间进行权衡，在时机中，一般都是设置成100-1000中的某个值。但是当系统发生宕机的时候，可能丢失N个事务的binlog 日志。</p> 
<h3><a id="redo_log_21"></a>redo log的写入机制</h3> 
<p>redo log是先写入redo log buffer-&gt; page cache -&gt; 磁盘<br> <img src="https://images2.imgbox.com/bf/1d/kNpZddUv_o.png" alt="在这里插入图片描述"><br> 从而就对应三种写入状态</p> 
<h3><a id="_26"></a>写入时机</h3> 
<ul><li>存储在redo log buffer中，其实就是MySQL进程内存中。红色部分</li><li>写到磁盘write，但是没有持久化(fsync) 文件系统的page cache里面，黄色部分</li><li>持久化到磁盘里，就是hard disk，绿色部分。</li></ul> 
<p>InnoDB 提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，控制写入策略。</p> 
<ul><li>0 ： 事务提交时，只把redo log留在redo log buffer中。</li><li>1 ： 事务提交时，redo log 持久化到磁盘</li><li>2 ： 事务提交时，redo log 写到page cache中。</li></ul> 
<p><img src="https://images2.imgbox.com/05/a1/6BQpsQ1j_o.png" alt="InnoDB"><br> 如图5就是将定时将脏页进行刷新操作。而对于bin log来说，是依靠每次事务提交的时候进行刷盘。<br> InnoDB由一个后台线程，间隔1S把redo log buffer中的日志，调用write写到文件系统的page cache，调用fscyn持久化到磁盘中。</p> 
<p>所以这里可能存在一种情况，可能一个事务执行过程中，也可能被定时后台线程持久化到磁盘中。</p> 
<h4><a id="_42"></a>刷盘时机</h4> 
<ul><li>定时1S刷盘操作</li><li>redo log buffer达到 <code>innodb_log_buffer_size</code> 一半的空间。只写write</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li><li>mysql正常关闭的时候。</li></ul> 
<h3><a id="group_commit_48"></a>组提交机制(group commit)</h3> 
<p><strong>日志逻辑序列号 log sequence number LSN</strong> 对应redo log的一个个写入点，每次写入长度为length的redo log LSN的值就会加上length。<br> <img src="https://images2.imgbox.com/11/38/cu1EBAyP_o.png" alt="在这里插入图片描述"><br> 图中有三个事务trx1、trx2、trx3 分别是50、120、160。</p> 
<p>当trx1 第一个到达，提交的时候就会把2 3也一起进行提交fsync。所以一组提交的事务越多IOPS的效果越好。其实就是批处理的概念，一次多处理，而不是分批处理。比如批量插入SQL等，Kafka的批处理消息等。</p> 
<p>WAL其实就只依赖于两个方面，redo log 和 bin log 都是顺序写，磁盘的顺序写比随机写快，另外一个是组提交，大幅度降低磁盘的IOPS消耗。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/064d6e746c06a11b6a93b7c1b2e4f8af/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle的这些BUG你要遇到,说明你是一个DBA老鸟...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66b5769d8b7403017a79a5e9b975c43f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Linux内核】伙伴系统算法和slab分配器（1）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>