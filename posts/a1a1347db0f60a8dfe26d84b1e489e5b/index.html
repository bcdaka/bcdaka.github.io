<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Umi Max 详解：打造高性能、可扩展的前端应用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a1a1347db0f60a8dfe26d84b1e489e5b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Umi Max 详解：打造高性能、可扩展的前端应用">
  <meta property="og:description" content="UMI是蚂蚁金服的底层前端框架，也是一个基于React的企业级前端应用框架，它提供了开箱即用的项目脚手架和插件化的配置，如路由构建、部署测试、文档工具、请求库等，帮助开发者快速搭建和管理复杂的前端项目，其设计目标是提高前端项目的开发效率和可维护性，尤其适用于大型复杂项目的开发与管理。
目录
初识Umi Max
Umi Max数据流
接口请求
初识Umi Max 了解框架：为了方便开发者更加方便的使用umi提供的插件，umi团队在这些插件开源的基础上，直接将其集成到一起，打造了@umijs/max，让开发者直接可以通过脚手架马上获得和蚂蚁集团开发umi应用一样的开发体检，只需要在使用create-umi选择Ant Design Pro模板，就能使用@umijs/max来创建项目了，可以参考官方文档：地址 ，详细了解umi max的相关开发：
因为umi max是使用Ant Design Pro模板进行开发的，所以我们也需要了解 Ant Design Pro 对应相关配置和API的使用，通过查阅官方文档进行详细了解：
当然我们在使用antd的时候，有一些组件的是十分细碎的，这里我们可以参考ProComponents ，其可以让让中后台开发更简单，如下所示：
像登录表单的内容，ProComponents组件库已经帮助我们封装好了，如下图所示：
安装项目：接下来我们开始安装umi max项目，安装的方式和umi项目命令一样，只需要在进行模板选择的时候，选择Ant Design Pro模板即可：
安装完之后直接拖到编辑器中执行 pnpm run dev 运行项目即可，最终呈现的效果如下所示：
当然在使用 Ant Design Pro 的时候，除了使用 umi 进行安装项目，我们也可以使用官方推荐给我们的pro-cli脚手架进行安装项目，如下图所示：
Umi Max数据流 官方文档给我们介绍到，umi max给我们内置了数据流管理插件，它是一种基于hooks范式的轻量级数据管理方案，可以在umi项目中管理全局的共享数据，从官方文档可以看到umi max规定的数据流和相关命名规范方面的内容，如下所示：
这里我们在src下的models目录下新建一个ts文件，用于全局状态管理的设置，这里我们可以使用react提供的相关API函数进行书写，书写的方式有点类似pinia状态管理的写法，条理十分清晰：
import { useState, useCallback,useEffect } from &#34;react&#34;; export default function countModel() { const [count, setCount] = useState(0); // setCount修改状态是异步的，所以需要使用useCallback包裹一下 const add = useCallback(() =&gt; setCount(count &#43; 1) , [count]); const minus = useCallback(() =&gt; setCount(count - 1), [count]); // 设置两秒之后修改count的值 useEffect(() =&gt; { setTimeout(() =&gt; { setCount(100); }, 2000) }, []); // 返回count和两个方法 return { count, add, minus } } 定义好仓库之后，接下来我们就需要使用仓库中的数据了，使用方式也是非常简单，直接借助umi框架提供的api函数useModel即可，具体代码如下所示：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-19T14:51:14+08:00">
    <meta property="article:modified_time" content="2024-07-19T14:51:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Umi Max 详解：打造高性能、可扩展的前端应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>UMI是蚂蚁金服的底层前端框架，也是一个基于React的企业级前端应用框架，它提供了开箱即用的项目脚手架和插件化的配置，如路由构建、部署测试、文档工具、请求库等，帮助开发者快速搭建和管理复杂的前端项目，其设计目标是提高前端项目的开发效率和可维护性，尤其适用于大型复杂项目的开发与管理。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%88%9D%E8%AF%86Umi%20Max-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E8%AF%86Umi%20Max" rel="nofollow">初识Umi Max</a></p> 
<p id="Umi%C2%A0Max%E6%95%B0%E6%8D%AE%E6%B5%81-toc" style="margin-left:80px;"><a href="#Umi%C2%A0Max%E6%95%B0%E6%8D%AE%E6%B5%81" rel="nofollow">Umi Max数据流</a></p> 
<p id="%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82" rel="nofollow">接口请求</a></p> 
<h4 id="%E5%88%9D%E8%AF%86Umi%20Max">初识Umi Max</h4> 
<p><span style="color:#be191c;"><strong>了解框架</strong></span>：为了方便开发者更加方便的使用umi提供的插件，umi团队在这些插件开源的基础上，直接将其集成到一起，打造了@umijs/max，让开发者直接可以通过脚手架马上获得和蚂蚁集团开发umi应用一样的开发体检，只需要在使用create-umi选择Ant Design Pro模板，就能使用@umijs/max来创建项目了，可以参考官方文档：<a class="link-info" href="https://umijs.org/docs/max/introduce" rel="nofollow" title="地址">地址</a> ，详细了解umi max的相关开发：</p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/ca/16/64WiLNeF_o.png" width="1200"></p> 
<p>因为umi max是使用Ant Design Pro模板进行开发的，所以我们也需要了解 <a class="link-info" href="https://pro.ant.design/zh-CN" rel="nofollow" title="Ant Design Pro">Ant Design Pro</a> 对应相关配置和API的使用，通过查阅官方文档进行详细了解：</p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/fb/82/g2XVvhlG_o.png" width="1200"></p> 
<p>当然我们在使用antd的时候，有一些组件的是十分细碎的，这里我们可以参考<a class="link-info" href="https://procomponents.ant.design/" rel="nofollow" title="ProComponents">ProComponents</a> ，其可以让让中后台开发更简单，如下所示：</p> 
<p><img alt="" height="785" src="https://images2.imgbox.com/4a/4d/rpqnvUc3_o.png" width="1200"></p> 
<p>像登录表单的内容，ProComponents组件库已经帮助我们封装好了，如下图所示：</p> 
<p class="img-center"><img alt="" height="618" src="https://images2.imgbox.com/60/d3/GunjLESk_o.png" width="1200"></p> 
<p><span style="color:#be191c;"><strong>安装项目</strong></span>：接下来我们开始安装umi max项目，安装的方式和umi项目命令一样，只需要在进行模板选择的时候，选择Ant Design Pro模板即可：</p> 
<p><img alt="" height="242" src="https://images2.imgbox.com/e6/64/3pP96aLL_o.png" width="786"></p> 
<p>安装完之后直接拖到编辑器中执行 pnpm run dev 运行项目即可，最终呈现的效果如下所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/07/55/KRz12JYe_o.gif"></p> 
<p>当然在使用 Ant Design Pro 的时候，除了使用 umi 进行安装项目，我们也可以使用官方推荐给我们的pro-cli脚手架进行安装项目，如下图所示：</p> 
<p><img alt="" height="577" src="https://images2.imgbox.com/2d/4e/RDNlVMY1_o.png" width="1173"></p> 
<h4 id="Umi%C2%A0Max%E6%95%B0%E6%8D%AE%E6%B5%81">Umi Max数据流</h4> 
<p>官方文档给我们介绍到，umi max给我们内置了数据流管理插件，它是一种基于hooks范式的轻量级数据管理方案，可以在umi项目中管理全局的共享数据，从官方文档可以看到umi max规定的数据流和相关命名规范方面的内容，如下所示：</p> 
<p class="img-center"><img alt="" height="477" src="https://images2.imgbox.com/ed/d2/zqU4PUVC_o.png" width="887"></p> 
<p>这里我们在src下的models目录下新建一个ts文件，用于全局状态管理的设置，这里我们可以使用react提供的相关API函数进行书写，书写的方式有点类似pinia状态管理的写法，条理十分清晰：</p> 
<pre><code class="language-javascript">import { useState, useCallback,useEffect } from "react";

export default function countModel() {
    const [count, setCount] = useState(0);
    // setCount修改状态是异步的，所以需要使用useCallback包裹一下
    const add = useCallback(() =&gt; setCount(count + 1) , [count]);
    const minus = useCallback(() =&gt; setCount(count - 1), [count]);

    // 设置两秒之后修改count的值
    useEffect(() =&gt; {
        setTimeout(() =&gt; {
            setCount(100);
        }, 2000)
    }, []);

    // 返回count和两个方法
    return {
        count,
        add,
        minus
    }
}</code></pre> 
<p>定义好仓库之后，接下来我们就需要使用仓库中的数据了，使用方式也是非常简单，直接借助umi框架提供的api函数useModel即可，具体代码如下所示：</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/98/42/aLI1ukxu_o.png" width="790"></p> 
<p>最终呈现的效果如下所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/08/26/yE3SAoRc_o.gif"></p> 
<p><span style="color:#be191c;"><strong>性能优化</strong></span>：官方文档提供了一个性能优化的方案，useModel() 方法可以接受可选的第二个参数，当组件只需要使用Model中的部分参数，而对其它参数的变化不感兴趣时，可以传入一个函数进行过滤。</p> 
<p>        组件并不关心计数器Model中的counter值，只需要使用Model提供的increment()和decrement()方法，于是传入了一个函数作为useModel() 方法的第二个参数，该函数的返回值将作为useModel()方法的返回值，这样过滤掉了counter这一频繁变化的值，避免了组件重复渲染带来的性能损失，以实现计数器的操作按钮为例：</p> 
<pre><code class="language-javascript">// src/components/CounterActions/index.tsx
import { useModel } from 'umi';

export default function Page() {
  const { add, minus } = useModel('counterModel', (model) =&gt; ({
    add: model.increment,
    minus: model.decrement,
  }));

  return (
    &lt;div&gt;
      &lt;button onClick={add}&gt;add by 1&lt;/button&gt;
      &lt;button onClick={minus}&gt;minus by 1&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre> 
<p><span style="color:#be191c;"><strong>全局初始状态</strong></span>：@umi/max内置了全局初始状态管理插件，可以快速构建并在组件内获取umi项目全局的初始状态，全局初始状态在整个umi项目的最开始创建，编写src/app.ts的导出方法getInitialState()，其返回值将成为全局初始状态。例如：</p> 
<pre><code class="language-javascript">// src/app.ts
import { fetchInitialData } from '@/services/initial';

export async function getInitialState() {
  const initialData = await fetchInitialData();
  return initialData;
}</code></pre> 
<p>现在，各种插件和定义的组件都可以通过useModel('@@initialState')直接获取到这份全局的初始状态，如下所示：</p> 
<pre><code class="language-javascript">import { useModel } from 'umi';

export default function Page() {
  const { initialState, loading, error, refresh, setInitialState } =
    useModel('@@initialState');
  return &lt;&gt;{initialState}&lt;/&gt;;
};</code></pre> 
<h4 id="%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82">接口请求</h4> 
<p><span style="color:#be191c;"><strong>request</strong></span>：umi提供了内置的请求接口的API函数，它基于axios和ahooks的useRequest提供了一套统一的网络请求和错误处理方案，如下：</p> 
<pre><code class="language-javascript">import { request } from '@umijs/max';</code></pre> 
<p>然后我们在接口文件里面直接使用类似axios的写法即可，接口引入接口函数调用，示例如下：</p> 
<pre><code class="language-javascript">export async function testApi() {
  return request("https://api.uomg.com/api/rand.qinghua")
}</code></pre> 
<p><img alt="" height="397" src="https://images2.imgbox.com/6e/1a/OajCTlsQ_o.png" width="821"></p> 
<p>最终呈现的效果如下所示：</p> 
<p><img alt="" src="https://images2.imgbox.com/b4/ee/wnkEdlQP_o.gif"></p> 
<p><span style="color:#be191c;"><strong>useRequest</strong></span>：官方文档也是给我们提供了useRequest这个API，帮我我们更好的去消费数据：</p> 
<pre><code class="language-javascript">import { useRequest } from 'umi';

export default function Page() {
  const { data, error, loading } = useRequest(() =&gt; {
    return services.getUserList('/api/test');
  });
  if (loading) {
    return &lt;div&gt;loading...&lt;/div&gt;;
  }
  if (error) {
    return &lt;div&gt;{error.message}&lt;/div&gt;;
  }
  return &lt;div&gt;{data.name}&lt;/div&gt;;
};</code></pre> 
<p>上面的是什么意思呢？就是说当我们创建好接口函数之后，想要调用接口就可以使用useRequest对数据进行相应的处理，这里给出基础案例：</p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/04/b2/1Xd5Tsuj_o.png" width="795"></p> 
<p>上面代码中可以看到我们是直接使用了data属性就能获取对应的数据，而不需要再通过链式操作一层一层的去寻找我们的数据，这是为啥呢？原来umi已经帮我们封装好了配置项：</p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/6c/c9/CQDxCbM8_o.png" width="881"></p> 
<p>我们在构建时的配置项中已经配置好了相应的属性下的值，从而不需要再data.content去拿数据：</p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/1c/39/t2jyuPaA_o.png" width="1200"></p> 
<p><span style="color:#be191c;"><strong>请求响应报错拦截</strong></span>：在 src/app.ts 中你可以通过配置 request 项，来为你的项目进行统一的个性化的请求设定。</p> 
<pre><code class="language-javascript">import type { RequestConfig } from '@umijs/max';

export const request: RequestConfig = {
  timeout: 1000,
  errorConfig: {
    errorHandler(){
    },
    errorThrower(){
    }
  },
  requestInterceptors: [],
  responseInterceptors: []
};</code></pre> 
<p>这里官方给出一个完整的运行时配置示例，以帮助能够更好的去为自己的项目设定个性化的请求方案：</p> 
<pre><code class="language-javascript">import { RequestConfig } from './request';

// 错误处理方案： 错误类型
enum ErrorShowType {
  SILENT = 0,
  WARN_MESSAGE = 1,
  ERROR_MESSAGE = 2,
  NOTIFICATION = 3,
  REDIRECT = 9,
}
// 与后端约定的响应数据格式
interface ResponseStructure {
  success: boolean;
  data: any;
  errorCode?: number;
  errorMessage?: string;
  showType?: ErrorShowType;
}

// 运行时配置
export const request: RequestConfig = {
  // 统一的请求设定
  timeout: 1000,
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // 错误处理： umi@3 的错误处理方案。
  errorConfig: {
    // 错误抛出
    errorThrower: (res: ResponseStructure) =&gt; {
      const { success, data, errorCode, errorMessage, showType } = res;
      if (!success) {
        const error: any = new Error(errorMessage);
        error.name = 'BizError';
        error.info = { errorCode, errorMessage, showType, data };
        throw error; // 抛出自制的错误
      }
    },
    // 错误接收及处理
    errorHandler: (error: any, opts: any) =&gt; {
      if (opts?.skipErrorHandler) throw error;
      // 我们的 errorThrower 抛出的错误。
      if (error.name === 'BizError') {
        const errorInfo: ResponseStructure | undefined = error.info;
        if (errorInfo) {
          const { errorMessage, errorCode } = errorInfo;
          switch (errorInfo.showType) {
            case ErrorShowType.SILENT:
              // do nothing
              break;
            case ErrorShowType.WARN_MESSAGE:
              message.warn(errorMessage);
              break;
            case ErrorShowType.ERROR_MESSAGE:
              message.error(errorMessage);
              break;
            case ErrorShowType.NOTIFICATION:
              notification.open({
                description: errorMessage,
                message: errorCode,
              });
              break;
            case ErrorShowType.REDIRECT:
              // TODO: redirect
              break;
            default:
              message.error(errorMessage);
          }
        }
      } else if (error.response) {
        // Axios 的错误
        // 请求成功发出且服务器也响应了状态码，但状态代码超出了 2xx 的范围
        message.error(`Response status:${error.response.status}`);
      } else if (error.request) {
        // 请求已经成功发起，但没有收到响应
        // \`error.request\` 在浏览器中是 XMLHttpRequest 的实例，
        // 而在node.js中是 http.ClientRequest 的实例
        message.error('None response! Please retry.');
      } else {
        // 发送请求时出了点问题
        message.error('Request error, please retry.');
      }
    },

  },

  // 请求拦截器
  requestInterceptors: [
    (config) =&gt; {
    // 拦截请求配置，进行个性化处理。
      const url = config.url.concat('?token = 123');
      return { ...config, url};
    }
  ],

  // 响应拦截器
  responseInterceptors: [
    (response) =&gt; {
       // 拦截响应数据，进行个性化处理
       const { data } = response;
       if(!data.success){
         message.error('请求失败！');
       }
       return response;
    }
  ]
};</code></pre> 
<p>当然unimax还有一些其他有趣的功能，这里就不再一一赘述了，感兴趣的朋友可自行查阅文档，后面项目中遇到的话，博主在进行讲解。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40becb2734e01910a8fa5593f4463753/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kafka 实现延迟队列的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7dfa8dcb117b6de0e6c286ddf1241c50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL 8.0安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>