<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【QT】Qt 网络 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b436c7f76e9f1f0527ef8d7ec614723a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【QT】Qt 网络">
  <meta property="og:description" content="Qt 网络 Qt 网络1. UDP Socket（1）核心 API 概览（2）回显服务器（3）回显客户端 2. TCP Socket（1）核心 API 概览（2）回显服务器（3）回显客户端 Qt 网络 和多线程类似，Qt 为了⽀持跨平台，对网络编程的 API 也进行了重新封装。
在进行网络编程之前，需要在项目中的 .pro 文件中添加 network 模块。添加之后要手动编译⼀下项目，使 Qt Creator 能够加载对应模块的头文件。
1. UDP Socket （1）核心 API 概览 主要的类有两个：QUdpSocket 和 QNetworkDatagram
QUdpSocket 表示⼀个 UDP 的 socket 文件。
QNetworkDatagram 表示⼀个 UDP 数据报
（2）回显服务器 1、创建界面，包含⼀个 QListWidget 用来显示信息
2、 创建 QUdpSocket 成员，修改 widget.h：
class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); private: Ui::Widget *ui; QUdpSocket *socket; }; 修改 widget.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-05T09:47:38+08:00">
    <meta property="article:modified_time" content="2024-08-05T09:47:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【QT】Qt 网络</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Qt 网络</h4> 
 <ul><li><a href="#Qt__2" rel="nofollow">Qt 网络</a></li><li><ul><li><a href="#1_UDP_Socket_11" rel="nofollow">1. UDP Socket</a></li><li><ul><li><a href="#1_API__14" rel="nofollow">（1）核心 API 概览</a></li><li><a href="#2_32" rel="nofollow">（2）回显服务器</a></li><li><a href="#3_112" rel="nofollow">（3）回显客户端</a></li></ul> 
   </li><li><a href="#2_TCP_Socket_199" rel="nofollow">2. TCP Socket</a></li><li><ul><li><a href="#1_API__202" rel="nofollow">（1）核心 API 概览</a></li><li><a href="#2_229" rel="nofollow">（2）回显服务器</a></li><li><a href="#3_343" rel="nofollow">（3）回显客户端</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Qt__2"></a>Qt 网络</h2> 
<p>和多线程类似，<strong>Qt</strong> 为了⽀持跨平台，对网络编程的 API 也进行了重新封装。</p> 
<p>在进行网络编程之前，需要在项目中的 .pro 文件中添加 network 模块。添加之后要手动编译⼀下项目，使 <strong>Qt Creator</strong> 能够加载对应模块的头文件。</p> 
<h3><a id="1_UDP_Socket_11"></a>1. UDP Socket</h3> 
<h4><a id="1_API__14"></a>（1）核心 API 概览</h4> 
<p>主要的类有两个：<strong>QUdpSocket</strong> 和 <strong>QNetworkDatagram</strong></p> 
<p><strong>QUdpSocket</strong> 表示⼀个 <strong>UDP</strong> 的 <strong>socket</strong> 文件。</p> 
<p><img src="https://images2.imgbox.com/d5/33/LhnY1TSr_o.png" alt="在这里插入图片描述"></p> 
<p><strong>QNetworkDatagram</strong> 表示⼀个 UDP 数据报</p> 
<p><img src="https://images2.imgbox.com/5b/91/Z5u7yhvn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_32"></a>（2）回显服务器</h4> 
<p>1、创建界面，包含⼀个 <strong>QListWidget</strong> 用来显示信息<br> 2、 创建 <strong>QUdpSocket</strong> 成员，修改 widget.h：</p> 
<pre><code>			class Widget : public QWidget
			{
			    Q_OBJECT
			public:
			    Widget(QWidget *parent = nullptr);
			    ~Widget();
			
			private:
			    Ui::Widget *ui;
			    QUdpSocket *socket;
			};
</code></pre> 
<p>修改 widget.cpp，完成 socket 后续的初始化。⼀般来说, 要先连接信号槽, 再绑定端⼝。如果顺序反过来, 可能会出现端⼝绑定好了之后, 请求就过来了. 此时还没来得及连接信号槽. 那么这个请求就有可能错过了.</p> 
<pre><code>			Widget::Widget(QWidget *parent)
			    : QWidget(parent), ui(new Ui::Widget)
			{
			    ui-&gt;setupUi(this);
			    // 1. 设置窗⼝标题
			    this-&gt;setWindowTitle("服务器");
			    // 2. 实例化 socket
			    socket = new QUdpSocket(this);
			    // 3. 连接信号槽, 处理收到的请求
			    connect(socket, &amp;QUdpSocket::readyRead, this, &amp;Widget::processRequest);
			    // 4. 绑定端⼝
			    bool ret = socket-&gt;bind(QHostAddress::Any, 9090);
			    if (!ret)
			    {
			        QMessageBox::critical(nullptr, "服务器启动出错", socket-&gt;errorString());
			        return;
			    }
			}
</code></pre> 
<p>3、实现 <strong>processRequest</strong> , 完成处理请求的过程</p> 
<ul><li> <p>读取请求并解析</p> </li><li> <p>根据请求计算响应</p> </li><li> <p>把响应写回到客户端</p> <pre><code>  		void Widget::processRequest()
  		{
  		    // 1. 读取请求
  		    const QNetworkDatagram &amp;requestDatagram = socket-&gt;receiveDatagram();
  		    QString request = requestDatagram.data();
  		    // 2. 根据请求计算响应
  		    const QString &amp;response = process(request);
  		    // 3. 把响应写回到客⼾端
  		    QNetworkDatagram responseDatagram(response.toUtf8(),
  		                                      requestDatagram.senderAddress(), requestDatagram.senderPort());
  		    socket-&gt;writeDatagram(responseDatagram);
  		    // 显⽰打印⽇志
  		    QString log = "[" + requestDatagram.senderAddress().toString() + ":" +
  		                  QString::number(requestDatagram.senderPort()) + "] req: " + request + ", resp: " + response;
  		    ui-&gt;listWidget-&gt;addItem(log);
  		}
</code></pre> </li></ul> 
<p>4、实现 process 函数</p> 
<p>由于我们此处是实现回显服务器. 所以 process ⽅法中并没有包含实质性的内容.</p> 
<pre><code>			QString Widget::process(const QString&amp; request)
			{
			 return request;
			}
</code></pre> 
<h4><a id="3_112"></a>（3）回显客户端</h4> 
<p>1、创建界面，包含⼀个 QLineEdit , QPushButton , QListWidget；</p> 
<ul><li>先使用⽔平布局把 <strong>QLineEdit</strong> 和 <strong>QPushButton</strong> 放好, 并设置这两个控件的垂直方向的 sizePolicy 为 Expanding<br> • 再使用垂直布局把 QListWidget 和上面的水平布局放好.<br> • 设置垂直布局的 layoutStretch 为 5, 1 (当然这个尺寸比例根据个人喜好微调).</li></ul> 
<p><img src="https://images2.imgbox.com/ee/5a/9Rw0pIVo_o.png" alt="在这里插入图片描述"></p> 
<p>2、在 widget.cpp 中, 先创建两个全局常量, 表⽰服务器的 IP 和 端⼝</p> 
<pre><code>			// 提前定义好服务器的 IP 和 端⼝
			const QString&amp; SERVER_IP = "127.0.0.1";
			const quint16 SERVER_PORT = 9090;
</code></pre> 
<p>3、创建 <strong>QUdpSocket</strong> 成员</p> 
<p>修改 widget.h, 定义成员</p> 
<pre><code>			class Widget : public QWidget
			{
			    Q_OBJECT
			public:
			    Widget(QWidget *parent = nullptr);
			    ~Widget();
			
			private:
			    Ui::Widget *ui;
			    // 创建 socket 成员
			    QUdpSocket *socket;
			};
</code></pre> 
<p>修改 widget.cpp, 初始化 socket</p> 
<pre><code>			Widget::Widget(QWidget *parent)
			    : QWidget(parent), ui(new Ui::Widget)
			{
			    ui-&gt;setupUi(this);
			    // 1. 设置窗⼝名字
			    this-&gt;setWindowTitle("客⼾端");
			    // 2. 实例化 socket
			    socket = new QUdpSocket(this);
			}
</code></pre> 
<p>4、给发送按钮 slot 函数, 实现发送请求</p> 
<pre><code>			void Widget::on_pushButton_clicked()
			{
			    // 1. 获取到输⼊框的内容
			    const QString &amp;text = ui-&gt;lineEdit-&gt;text();
			    // 2. 构造请求数据
			    QNetworkDatagram requestDatagram(text.toUtf8(), QHostAddress(SERVER_IP),
			                                     SERVER_PORT);
			    // 3. 发送请求
			    socket-&gt;writeDatagram(requestDatagram);
			    // 4. 消息添加到列表框中
			    ui-&gt;listWidget-&gt;addItem("客户端说: " + text);
			    // 5. 清空输⼊框
			    ui-&gt;lineEdit-&gt;setText("");
			}
</code></pre> 
<p>5、再次修改 Widget 的构造函数, 通过信号槽, 来处理服务器的响应.</p> 
<pre><code>			connect(socket, &amp;QUdpSocket::readyRead, this, [=]()
			{
			    const QNetworkDatagram responseDatagram = socket-&gt;receiveDatagram();
			    QString response = responseDatagram.data();
			    ui-&gt;listWidget-&gt;addItem(QString("服务器说: ") + response); 
			});
</code></pre> 
<h3><a id="2_TCP_Socket_199"></a>2. TCP Socket</h3> 
<h4><a id="1_API__202"></a>（1）核心 API 概览</h4> 
<p>核⼼类是两个: <strong>QTcpServer</strong> 和 <strong>QTcpSocket</strong></p> 
<p>QTcpServer 用于监听端口, 和获取客户端连接。</p> 
<p><img src="https://images2.imgbox.com/a3/54/FGYQFTkL_o.png" alt="在这里插入图片描述"></p> 
<p><strong>QTcpSocket</strong> 用户客户端和服务器之间的数据交互。</p> 
<p><img src="https://images2.imgbox.com/ce/00/3jYotJfO_o.png" alt="在这里插入图片描述"></p> 
<p>QByteArray 用于表示⼀个字节数组. 可以很⽅便的和 QString 进行相互转换.</p> 
<p>例如：</p> 
<ul><li>使用 <strong>QString</strong> 的构造函数即可把 QByteArray 转成 QString.</li><li>使用 <strong>QString</strong> 的 toUtf8 函数即可把 QString 转成 QByteArray.</li></ul> 
<h4><a id="2_229"></a>（2）回显服务器</h4> 
<p>1、创建界⾯. 包含⼀个 QListWidget , ⽤于显⽰收到的数据.</p> 
<p><img src="https://images2.imgbox.com/b5/11/Zu9mCTDV_o.png" alt="在这里插入图片描述"></p> 
<p>2、创建 <strong>QTcpServer</strong> 并初始化</p> 
<p>修改 widget.h, 添加 QTcpServer 指针成员</p> 
<pre><code>			class Widget : public QWidget
			{
			    Q_OBJECT
			public:
			    Widget(QWidget *parent = nullptr);
			    ~Widget();
			
			private:
			    Ui::Widget *ui;
			
			    // 创建 QTcpServer
			    QTcpServer *tcpServer;
			};
</code></pre> 
<p>修改 widget.cpp, 实例化 QTcpServer 并进⾏后续初始化操作.</p> 
<ul><li> <p>设置窗⼝标题</p> </li><li> <p>实例化 TCP server. (⽗元素设为当前控件, 会在⽗元素销毁时被⼀起销毁).</p> </li><li> <p>通过信号槽, 处理客⼾端建⽴的新连接.</p> </li><li> <p>监听端口</p> <pre><code>  		Widget::Widget(QWidget *parent)
  		    : QWidget(parent), ui(new Ui::Widget)
  		{
  		    ui-&gt;setupUi(this);
  		    // 1. 设置窗⼝标题
  		    this-&gt;setWindowTitle("服务器");
  		    // 2. 实例化 TCP server
  		    tcpServer = new QTcpServer(this);
  		
  		    // 3. 通过信号槽, 处理客⼾端建⽴的新连接.
  		    connect(tcpServer, &amp;QTcpServer::newConnection, this,
  		            &amp;Widget::processConnection);
  		
  		    // 4. 监听端⼝
  		    bool ret = tcpServer-&gt;listen(QHostAddress::Any, 9090);
  		    if (!ret)
  		    {
  		        QMessageBox::critical(nullptr, "服务器启动失败!", tcpServer - &gt; errorString());
  		        exit(1);
  		    }
  		}
</code></pre> </li></ul> 
<p>3、继续修改 widget.cpp, 实现处理连接的具体⽅法 processConnection</p> 
<ul><li> <p>获取到新的连接对应的 socket.</p> </li><li> <p>通过信号槽, 处理收到请求的情况</p> </li><li> <p>通过信号槽, 处理断开连接的情况</p> <pre><code>  		void Widget::processConnection()
  		{
  		    // 1. 获取到新的连接对应的 socket.
  		    QTcpSocket *clientSocket = tcpServer-&gt;nextPendingConnection();
  		    QString log = QString("[") + clientSocket-&gt;peerAddress().toString() + ":" + QString::number(clientSocket-&gt;peerPort()) + "] 客⼾端上线!";
  		    ui-&gt;listWidget-&gt;addItem(log);
  		    // 2. 通过信号槽, 处理收到请求的情况
  		    connect(clientSocket, &amp;QTcpSocket::readyRead, this, [=]()
  		    {
  		        // a) 读取请求
  		        QString request = clientSocket-&gt;readAll();
  		        // b) 根据请求处理响应
  		        const QString&amp; response = process(request);
  		        // c) 把响应写回客⼾端
  		        clientSocket-&gt;write(response.toUtf8());
  		        QString log = QString("[") + clientSocket-&gt;peerAddress().toString()
  		        + ":" + QString::number(clientSocket-&gt;peerPort()) + "] req: " + 
  		        request + ", resp: " + response;
  		        ui-&gt;listWidget-&gt;addItem(log); 
  		    });
  		    // 3. 通过信号槽, 处理断开连接的情况
  		    connect(clientSocket, &amp;QTcpSocket::disconnected, this, [=]()
  		    {
  		        QString log = QString("[") + clientSocket-&gt;peerAddress().toString()
  		        + ":" + QString::number(clientSocket-&gt;peerPort()) + "] 客户端下线!";
  		        ui-&gt;listWidget-&gt;addItem(log);
  		        // 删除 clientSocket
  		        clientSocket-&gt;deleteLater(); 
  		    });
  		}
</code></pre> </li></ul> 
<p>4、实现 process 方法, 实现根据请求处理响应</p> 
<p>由于我们此处是实现回显服务器. 所以 process ⽅法中并没有包含实质性的内容</p> 
<pre><code>			QString Widget::process(const QString &amp;request)
			{
				return request;
			}
</code></pre> 
<h4><a id="3_343"></a>（3）回显客户端</h4> 
<p>1、创建界⾯；包含⼀个 QLineEdit , QPushButton , QListWidget</p> 
<ul><li>先使用⽔平布局把 <strong>QLineEdit</strong> 和 <strong>QPushButton</strong> 放好, 并设置这两个控件的垂直方向的 <strong>sizePolicy</strong> 为 <strong>Expanding</strong></li><li>再使用垂直布局把 <strong>QListWidget</strong> 和上面的水平布局放好.</li><li>设置垂直布局的 <strong>layoutStretch</strong> 为 5, 1 (当然这个尺寸比例根据个⼈喜好微调).</li></ul> 
<p><img src="https://images2.imgbox.com/34/99/uwso3CRy_o.png" alt="在这里插入图片描述"></p> 
<p>2、创建 <strong>QTcpSocket</strong> 并实例化</p> 
<p>修改 widget.h, 创建成员.</p> 
<pre><code>			class Widget : public QWidget
			{
			    Q_OBJECT
			public:
			    Widget(QWidget *parent = nullptr);
			    ~Widget();
			
			private:
			    Ui::Widget *ui;
			    // 新增 QTcpSocket
			    QTcpSocket *socket;
			};
</code></pre> 
<p>修改 widget.cpp, 对 QTcpSocket 进行实例化</p> 
<ul><li> <p>设置窗⼝标题</p> </li><li> <p>实例化 socket 对象 (⽗元素设为当前控件, 会在⽗元素销毁时被⼀起销毁).</p> </li><li> <p>和服务器建⽴连接.</p> </li><li> <p>等待并确认连接是否出错.</p> <pre><code>  		Widget::Widget(QWidget *parent)
  		    : QWidget(parent), ui(new Ui::Widget)
  		{
  		    ui-&gt;setupUi(this);
  		    // 1. 设置窗⼝标题.
  		    this-&gt;setWindowTitle("客⼾端");
  		    // 2. 实例化 socket 对象.
  		    socket = new QTcpSocket(this);
  		    // 3. 和服务器建⽴连接.
  		    socket-&gt;connectToHost("127.0.0.1", 9090);
  		    // 4. 等待并确认连接是否出错.
  		    if (!socket-&gt;waitForConnected())
  		    {
  		        QMessageBox::critical(nullptr, "连接服务器出错!", socket-&gt;errorString());
  		        exit(1);
  		    }
  		}
</code></pre> </li></ul> 
<p>3、修改 widget.cpp, 给按钮增加点击的 slot 函数, 实现发送请求给服务器.</p> 
<pre><code>			void Widget::on_pushButton_clicked()
			{
			    // 获取输⼊框的内容
			    const QString &amp;text = ui-&gt;lineEdit-&gt;text();
			    // 清空输⼊框内容
			    ui-&gt;lineEdit-&gt;setText("");
			    // 把消息显⽰到界⾯上
			    ui-&gt;listWidget-&gt;addItem(QString("客⼾端说: ") + text);
			    // 发送消息给服务器
			    socket-&gt;write(text.toUtf8());
			}
</code></pre> 
<p>4、修改 widget.cpp 中的 Widget 构造函数, 通过信号槽, 处理收到的服务器的响应.</p> 
<pre><code>			// 处理服务器返回的响应.
			connect(socket, &amp;QTcpSocket::readyRead, this, [=]()
			{
			    QString response = socket-&gt;readAll();
			    qDebug() &lt;&lt; response;
			    ui-&gt;listWidget-&gt;addItem(QString("服务器说: ") + response); 
			});
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47e1e0b0d380105cad2643a2ee5607be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据-65 Kafka 高级特性 分区 Broker自动再平衡 ISR 副本 宕机恢复再重平衡 实测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/baa1b77a1b34c02ba95cf7d366459dfd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL进阶】MySQL主从复制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>