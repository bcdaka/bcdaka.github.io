<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>{Spring Boot 原理篇} Spring Boot自动装配原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/10209430ad6e105d50b5a6587519425a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="{Spring Boot 原理篇} Spring Boot自动装配原理">
  <meta property="og:description" content="@SpringBootApplication 1，Spring Boot 应用启动，@SpringBootApplication标注的类就是启动类，它去实现配置类中的Bean的自动装配
@SpringBootApplication public class SpringbootRedis01Application { public static void main(String[] args) { SpringApplication.run(SpringbootRedis01Application.class, args); } } 2，而@SpringBootApplicatiozn注解中包含了三个注解：
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //以上四个都为元注解,以下三个才是去实现自动装配的注解 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) @SpringBootConfiguration 这个注解包含了@Configuration，@Configuration里面又包含了一个@Component注解，也就是
说，这个注解标注在哪个类上，就表示当前这个类是一个配置类，而配置类也是spring容器中的组
件，
@SpringBootConfiguration：对@Configuration 注解的封装，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中。
@EnableAutoConfiguration 这个注解是开启自动配置的功能核心注解，里面包含了两个注解
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
@AutoConfigurationPackage： 将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器，这也就是为什么我们在利用springboot进行开发的时候，无论是Controller还是Service的路径都是与主配置类同级或者次级的原因。
@Import(AutoConfigurationImportSelector.class) 上一个注解我们把所有组件都加载到了容器里面，这个注解就是将需要自动装配的类以全类名的方
式返回
1、AutoConfigurationImportSelector这个类里面有一个方法selectImports()，如下
2、在selectImport()方法里调用了一个getAutoConfigurationEntry()方法，这个方法里面又调用
了一个getCandidateConfigurations()方法
3、在getCandidateConfigurations()方法里面调用了loadFactoryNames()方法、">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T21:06:09+08:00">
    <meta property="article:modified_time" content="2024-07-24T21:06:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">{Spring Boot 原理篇} Spring Boot自动装配原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>@SpringBootApplication</h2> 
<p>1，Spring Boot 应用启动，@SpringBootApplication标注的类就是启动类，它去实现配置类中的Bean的自动装配</p> 
<pre><code class="language-java">@SpringBootApplication
public class SpringbootRedis01Application {

	public static void main(String[] args) {
		SpringApplication.run(SpringbootRedis01Application.class, args);
	}

}</code></pre> 
<p>2，而@SpringBootApplicatiozn注解中包含了三个注解：</p> 
<p>@SpringBootConfiguration<br> @EnableAutoConfiguration<br> @ComponentScan</p> 
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
//以上四个都为元注解,以下三个才是去实现自动装配的注解
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)</code></pre> 
<h2>@SpringBootConfiguration</h2> 
<p>这个注解包含了@Configuration，@Configuration里面又包含了一个@Component注解，也就是</p> 
<p>说，<strong>这个注解标注在哪个类上，就表示当前这个类是一个配置类，而配置类也是spring容器中的组</strong></p> 
<p><strong>件，</strong></p> 
<p><img alt="" height="207" src="https://images2.imgbox.com/2e/3e/aaF9spAi_o.png" width="538"></p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/69/79/ZpYkg9BR_o.png" width="431"></p> 
<p>@SpringBootConfiguration：对@Configuration 注解的封装，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中。</p> 
<h2>@EnableAutoConfiguration</h2> 
<p>这个注解是开启自动配置的功能核心注解，里面包含了两个注解</p> 
<p>@AutoConfigurationPackage</p> 
<p>@Import({AutoConfigurationImportSelector.class})</p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/70/93/DYddIxGq_o.png" width="852"></p> 
<h3>@AutoConfigurationPackage：</h3> 
<p>将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器，这也就是为什么我们在利用springboot进行开发的时候，无论是Controller还是Service的路径都是与主配置类同级或者次级的原因。</p> 
<h3>@Import(AutoConfigurationImportSelector.class)</h3> 
<p>上一个注解我们把所有组件都加载到了容器里面，这个注解就是将需要自动装配的类以全类名的方</p> 
<p>式返回</p> 
<p>1、AutoConfigurationImportSelector这个类里面有一个方法selectImports()，如下</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/0d/d6/JqiR5tDW_o.png" width="1200"></p> 
<p>2、在<strong>selectImport</strong>()方法里调用了一个<strong>getAutoConfigurationEntry</strong>()方法，这个方法里面又调用</p> 
<p>了一个<strong>getCandidateConfigurations</strong>()方法</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/3b/af/a8VZ1vQx_o.png" width="1200"></p> 
<p>3、在<strong>getCandidateConfigurations</strong>()方法里面调用了<strong>loadFactoryNames</strong>()方法、</p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/20/a4/QRwSiSbj_o.png" width="1200"></p> 
<p> 4、<strong>loadFactoryNames</strong>()方法里面又调用了一个<strong>loadSpringFactories</strong>()方法</p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/de/48/1bGmoJBD_o.png" width="1120"></p> 
<p>5、关键就在这个<strong>loadSpringFactories</strong>()方法里面，在这个方法里，它会查找所有在<strong>META-INF</strong>路</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/43/29/fyCET9zh_o.png" width="1197"></p> 
<p>6、在<strong>META-INF/spring.factories</strong>这个文件里面的数据是以<strong>键=值</strong>的方式存储，然后解析这些文</p> 
<p>件，找出以<strong>EnableAutoConfiguration</strong>为键的所有值，以列表的方式返回</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/55/a1/QUIab2QS_o.png" width="993"></p> 
<h2>@ComponentScan</h2> 
<p>这个注解的作用就是扫描当前包及子包的注解</p> 
<p></p> 
<p>@Condition注解就是在自动装配的时候如果这个类中有此注解而且满足其定义的逻辑，是否要注入容器。</p> 
<p>定义自己的条件类，实现Condition口重写match方法</p> 
<pre><code class="language-java">public class ClassCondition implements Condition {
//条件为是否导入相应坐标而且是单个条件
//    @Override
//    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
//        boolean flag=true;
//        try {
//            Class&lt;?&gt; clas= Class.forName("redis.clients.jedis.Jedis");
//        } catch (ClassNotFoundException e) {
//
//           flag=false;
//        }
//
//        return flag;
//    }
//条件为是否导入相应坐标而且是多个条件
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        boolean flag=true;
       Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClasss.class.getName());
        String[] value = (String[]) map.get("value");
        try {
            for(String className :value) {
                Class&lt;?&gt; clas = Class.forName(className);
            }
        } catch (ClassNotFoundException e) {

            flag=false;
        }

        return flag;
    }
}</code></pre> 
<p>定义配置类：@Condition（value属性指的就是条件类）</p> 
<pre><code class="language-java">@Configuration
public class UserConfig {

    @Bean
//    @Conditional(value = ClassCondition.class)
    @ConditionOnClasss(value={"com.alibaba.fastjson.JSON","redis.clients.jedis.Jedis"})
    public Hotel hotel(){
        return new Hotel();
    }


    @Bean
//    @Conditional(value = ClassCondition.class)
//    @ConditionOnClasss(value={"com.alibaba.fastjson.JSON","redis.clients.jedis.Jedis"})
    @ConditionalOnProperty(value = "k1",havingValue = "k2")
    public Hotel hotel2(){
        return new Hotel();
    }


}</code></pre> 
<p>Condition – 小结</p> 
<p>自定义条件：</p> 
<p>① 定义条件类：自定义类实现Condition接口，重写 matches 方法，在 matches 方法中进行逻辑判 断，返回 boolean值 。</p> 
<p>        matches 方法两个参数：</p> 
<p>                • context：上下文对象，可以获取属性值，获取类加载器，获取BeanFactory等。</p> 
<p>                • metadata：元数据对象，用于获取注解属性。</p> 
<p>② 判断条件： 在初始化Bean时，使用 @Conditional(条件类.class)注解</p> 
<p>SpringBoot 提供的常用条件注解： </p> 
<p>          以下注解在springBoot-autoconfigure的condition包下 ：</p> 
<p>ConditionalOnProperty：判断配置文件中是否有对应属性和值才初始化</p> 
<p>Bean ConditionalOnClass：判断环境中是否有对应字节码文件才初始化Bean ConditionalOnMissingBean：判断环境中没有对应Bean才初始化Bean</p> 
<p>ConditionalOnBean：判断环境中有对应Bean才初始化Bean 可以查看RedisAutoConfiguration类说明以上注解使用 距离演示ConditionalOnProperty</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/084cae817d6a2a156b602fb4ad79f455/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">扫雷-C语言</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f2621c5918494902900ea7797103dd0c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">奇怪的Excel单元格字体颜色格式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>