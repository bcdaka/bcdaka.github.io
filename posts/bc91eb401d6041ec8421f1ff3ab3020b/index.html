<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java I/O (Input/Output)——文件字节流 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bc91eb401d6041ec8421f1ff3ab3020b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java I/O (Input/Output)——文件字节流">
  <meta property="og:description" content="博客主页：誓则盟约系列专栏：Java SE 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ Java I/O 简介 Java I/O（输入/输出）是 Java 程序中用于处理数据输入和输出的重要部分。
输入流（Input Streams）：用于从数据源读取数据。常见的输入流包括FileInputStream（从文件读取）、BufferedInputStream（提高读取效率）等。
输出流（Output Streams）：用于将数据写入到目的地。例如FileOutputStream（向文件写入）、BufferedOutputStream（提高写入效率）。
字符流（Reader 和 Writer）：处理字符数据，更适合处理文本。如FileReader和FileWriter。
缓冲流（Buffered Streams）：通过缓冲区来减少实际的 I/O 操作次数，提高性能。
对象流（Object Streams）：用于实现对象的序列化和反序列化，如ObjectInputStream和ObjectOutputStream。
在实际编程中，根据具体的需求选择合适的 I/O 流可以提高程序的效率和可读性。
计算机总线结构： 那么为什么会有I/O呢？其实I/O无时无刻不在我们身边，比如读取硬盘上的文件，网络文件的传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。
我们可以大致看一下整个计算机的总线结构：
最核心的是CPU，CPU像计算机的大脑一样，是计算机的核心部件，几乎所有的计算都是靠这个CPU来进行的，CPU懂的比较多，它可以对各种类型进行计算，但是随着时代的发展对图形的要求越来越高，CPU就略显乏力；于是就出现了GPU(显卡)，显卡就是专门对于图形进行计算。
通过北桥芯片连接到内存，这样CPU就可以对内存进行操作；南桥芯片是用于读取U盘或者硬盘内的数据 。
常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。
而我们在程序中，想要读取这些外部连接的!O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统(如:Windows/inux/MacOS)就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。
JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO。
文件字节流： 字节流一次读取一个字节，也就是一个 byte 的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个 char 的大小(在读取纯文本文件的时候更加适合)。
文件输入流： 在 Java 中，文件输入流（FileInputStream）用于从文件中读取数据。FileInputStream 允许程序以字节为单位读取文件的内容。
创建方式：
通常通过指定要读取的文件路径来创建文件输入流对象。例如：
try { FileInputStream fis = new FileInputStream(&#34;your_file_path&#34;); // 后续的读取操作 } catch (FileNotFoundException e) { e.printStackTrace(); } 但是这种方式需要处理各种可能的异常，比如 FileNotFoundException 异常和 IOException 异常，并且需要手动关闭文件，完整代码如下：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T13:03:27+08:00">
    <meta property="article:modified_time" content="2024-08-08T13:03:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java I/O (Input/Output)——文件字节流</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li><strong>博客主页：<a href="https://blog.csdn.net/Xxy_1008?type=blog" title="誓则盟约">誓则盟约</a></strong></li><li><strong>系列专栏：<a href="https://blog.csdn.net/xxy_1008/category_12731002.html?spm=1001.2014.3001.5482" title="Java SE 专栏">Java SE 专栏</a></strong></li><li><strong>关注博主，后期持续更新系列文章</strong></li><li><strong>如果有错误感谢请大家批评指出，及时修改</strong></li><li><strong>感谢大家点赞👍收藏⭐评论✍</strong> </li></ul> 
<hr> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7e/ab/5WHw9zee_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d2/25/Ih7nDYsV_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/89/72/ncO7aeMa_o.gif"></p> 
<h2>Java I/O 简介</h2> 
<p>        Java I/O（输入/输出）是 Java 程序中用于<strong>处理数据输入和输出</strong>的重要部分。</p> 
<p><strong>输入流（Input Streams）</strong>：用于从数据源读取数据。常见的输入流包括<code>FileInputStream</code>（从文件读取）、<code>BufferedInputStream</code>（提高读取效率）等。</p> 
<p><strong>输出流（Output Streams）</strong>：用于将数据写入到目的地。例如<code>FileOutputStream</code>（向文件写入）、<code>BufferedOutputStream</code>（提高写入效率）。</p> 
<p><strong>字符流（Reader 和 Writer）</strong>：处理字符数据，更适合处理文本。如<code>FileReader</code>和<code>FileWriter</code>。</p> 
<p><strong>缓冲流（Buffered Streams）</strong>：通过缓冲区来减少实际的 I/O 操作次数，提高性能。</p> 
<p><strong>对象流（Object Streams）</strong>：用于实现对象的序列化和反序列化，如<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>。</p> 
<p>        在实际编程中，根据具体的需求选择合适的 I/O 流可以提高程序的效率和可读性。</p> 
<hr> 
<h3 style="text-align:justify;">计算机总线结构：   </h3> 
<p style="text-align:justify;">        那么为什么会有I/O呢？其实I/O无时无刻不在我们身边，比如读取硬盘上的文件，网络文件的传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。</p> 
<p>我们可以大致看一下<strong>整个计算机的总线结构</strong>：</p> 
<p><img alt="" height="757" src="https://images2.imgbox.com/d2/30/lcquV79T_o.png" width="1200"></p> 
<p style="text-align:justify;">        <strong>最核心的是CPU</strong>，CPU像计算机的大脑一样，是计算机的核心部件，几乎所有的计算都是靠这个CPU来进行的，CPU懂的比较多，它可以对各种类型进行计算，但是随着时代的发展对图形的要求越来越高，CPU就略显乏力；于是就出现了GPU(显卡)，显卡就是专门对于图形进行计算。</p> 
<p style="text-align:justify;">        通过<strong>北桥芯片</strong>连接到内存，这样CPU就可以对内存进行操作；南桥芯片是用于读取U盘或者硬盘内的数据 。</p> 
<p style="text-align:justify;">        常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，<strong>这些设备是由CPU发出指令通过南桥芯片间接进行控制</strong>，而不是由CPU直接操作。</p> 
<p style="text-align:justify;">        而我们在程序中，想要读取这些外部连接的!O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统(如:Windows/inux/MacOS)就是专门<strong>用于控制和管理计算机硬件和软件资源</strong>的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。</p> 
<p style="text-align:justify;">        JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO。</p> 
<hr> 
<h4>文件字节流：</h4> 
<p>        字节流一次读取一个字节，也就是一个 byte 的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个 char 的大小(在读取纯文本文件的时候更加适合)。</p> 
<h3>文件输入流：</h3> 
<p>在 Java 中，文件输入流<strong>（<code>FileInputStream</code>）</strong>用于从文件中读取数据。<strong><code>FileInputStream</code> </strong>允许程序以字节为单位读取文件的内容。</p> 
<p><strong>创建方式</strong>：<br> 通常通过指定要读取的文件路径来创建文件输入流对象。例如：</p> 
<pre><code class="language-java">try {
    FileInputStream fis = new FileInputStream("your_file_path");
    // 后续的读取操作
} catch (FileNotFoundException e) {
    e.printStackTrace();
}</code></pre> 
<p>        但是这种方式需要处理各种可能的异常，比如 FileNotFoundException 异常和 IOException 异常，并且需要手动关闭文件，完整代码如下：</p> 
<pre><code class="language-java">public class Hello_World {
    public static void main(String[] args) { // 想读取一个文件  创建一个文件输入流   使用完把流关闭掉 释放掉 close
        FileInputStream stream = null;
        try {
            stream = new FileInputStream("绝对路径/相对路径");
//            stream.close();
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}</code></pre> 
<p style="text-align:justify;">        仅仅是取得文件就如此费劲，不合乎常理。所以有了<strong><code>try-with-resources</code></strong> 语句这种简便方式，<strong><code>try-with-resources</code> </strong>语句是一种用于更方便、更安全地管理资源（如输入流、输出流、数据库连接等）的机制。</p> 
<p><strong>优点</strong>：</p> 
<ol><li>自动资源管理：无需显式地调用 <code>close</code> 方法来关闭资源，避免了因忘记关闭资源而导致的资源泄漏问题。</li><li>简洁的代码：减少了样板代码，使代码更简洁、更易读。</li></ol> 
<p><strong>语法格式</strong>：</p> 
<pre><code class="language-java">try (Resource res = new Resource()) {
    // 使用资源的操作
} catch (Exception e) {
    // 异常处理
}</code></pre> 
<p>        对于以上示例的完整代码转成<strong><code>try-with-resources</code></strong> 语句如下：</p> 
<pre><code class="language-java">public class Hello_World {
    public static void main(String[] args) {
        try(FileInputStream inputStream = new FileInputStream("路径")){ // 直接在try()中定义要在完成之后释放的资源
        } catch (IOException e){ // 这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的
            e.printStackTrace();
        }// 无需再编写finally语句块，因为在最后自动帮我们调用了close()。
    }
}</code></pre> 
<p>        由此可见，<strong><code>try-with-resources</code> 语句极大地提高了资源管理的便利性和可靠性，使代码更加健壮和易于维护。</strong></p> 
<h4><strong>数据的传递：</strong></h4> 
<h4><img alt="" height="334" src="https://images2.imgbox.com/af/be/hs7XV3LM_o.png" width="1196"></h4> 
<p>        如图所示，在计算机数据由文件向内存进行传递的形式是以二进制01串进行的，一次一个字节，就像水流一样源源不断的传输，直至文件传输结束。</p> 
<p>        数据不断传输过来，那我们如何去读取数据呢？</p> 
<p>        调用read()方法是必要的，但是read()方法的调用方式也有很多种，这里主要列出来常见的三种。</p> 
<h4>1.直接读取</h4> 
<pre><code class="language-java">       try(FileInputStream inputStream = new FileInputStream("C:\\Users\\Xxy63\\Desktop\\无限弹窗代码.txt")){ // 直接在try()中定义要在完成之后释放的资源
            int i = inputStream.read();
            System.out.println((char)i);
            int x = inputStream.read();  // 当没有内容后，会返回-1
            System.out.println((char)x);
      } catch (IOException e){ // 这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的
            e.printStackTrace();
        }// 无需再编写finally语句块，因为在最后自动帮我们调用了close()。
    </code></pre> 
<p>        由于读取数据返回的是int类型的一个数据，所以我们用int i 去接收它，然后利用强制类型转换把i 转为char类型进行输出。调用一次读取一个字符，当读取完之后会返回-1.这样效率较为低下，所以有下面第二种读取方法。</p> 
<h4>2.循环读取</h4> 
<p>         由于读取完之后会返回数字-1，所以可以利用这一性质进行while循环进行读取，直到返回-1时结束循环，代码如下：</p> 
<pre><code class="language-java">try(FileInputStream inputStream = new FileInputStream("C:\\Users\\Xxy63\\Desktop\\无限弹窗代码.txt")){ // 直接在try()中定义要在完成之后释放的资源
            int i;
            while ((i = inputStream.read()) != -1) {
                System.out.print((char)i);
            }
        } catch (IOException e){ // 这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的
            e.printStackTrace();
}// 无需再编写finally语句块，因为在最后自动帮我们调用了close()。
    
</code></pre> 
<p>        通过这种方式就可以一次性对文件内的内容全部读取。但是由于不够灵活，可变性较差，所以还可以用下面第三种方法进行读取。</p> 
<h4>3.区间读取</h4> 
<p>        区间读取，顾名思义就是定义一个固定长度的区间，将文件内的内容按照这个区间大小进行读取，当文件未读内容小于区间长度时会以小于区间长度的形式进行最后一次读取，若没有元素可读取时，一样会返回-1。具体代码如下：</p> 
<pre><code class="language-java">        try(FileInputStream inputStream = new FileInputStream("C:\\Users\\Xxy63\\Desktop\\无限弹窗代码.txt")){ // 直接在try()中定义要在完成之后释放的资源

            System.out.println(inputStream.available()); // 获取有多少个数据可读
            byte [] bytes = new byte[inputStream.available()]; // 一次读x个数据
            while (inputStream.read(bytes) != -1)   // 当最后不足x个或者已经没有时，会返回少于x个的数据或者-1
                System.out.println(new String(bytes));

        } catch (IOException e){ // 这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的
            e.printStackTrace();
        }// 无需再编写finally语句块，因为在最后自动帮我们调用了close()。</code></pre> 
<p>        读取过程中可使用<strong>available()</strong>方法查询可读数量，在上面的案例中，我将区间长度x设置为了可读长度，这样也可以一次性读取完文件内数据。也可以设置其他int类型的x作为长度参数。</p> 
<p style="text-align:justify;">        这种方法在<strong>文件输出流</strong>常用，一个字节一个字节的读取出来并一个字节一个字节的写入另一个文件，相当于文件的拷贝操作。</p> 
<p style="text-align:justify;">       <strong>跳过操作</strong>：skip()方法。给skip(x)传人参数x，可以设置跳过前几个字节进行读取其下一个字节。</p> 
<hr> 
<h3>文件输出流：</h3> 
<p>        文件输出流（<strong><code>FileOutputStream</code></strong>）用于将数据写入到文件中。文件输出流允许您以字节为单位向文件写入数据。</p> 
<p>        在写入之前您需要提供要写入的文件的路径和名称。如果文件不存在，它将被创建；如果文件已存在，默认情况下，新写入的数据会覆盖原有的内容。</p> 
<pre><code class="language-java">   try {
       FileOutputStream fos = new FileOutputStream("your_file.txt");
   } catch (IOException e) {
       e.printStackTrace();
   }</code></pre> 
<p><strong><code>  stream.flush()</code></strong>方法的主要作用是将输出流缓冲区中的数据强制刷新并输出。通常，当我们使用输出流（如 <code>FileOutputStream</code> 、<code>BufferedOutputStream</code> 等）写入数据时，数据并不是立即被发送到目的地（如文件），而是先被存储在缓冲区中。缓冲区的目的是减少实际的 I/O 操作次数，从而提高性能。</p> 
<p>        然而，在某些情况下，我们希望确保数据能够立即被发送出去，而不是等到缓冲区填满或者输出流被关闭。这时就可以使用 <code>flush</code> 方法。  </p> 
<p>        默认情况下(append的参数默认是false)，写入的内容会直接取代原文件内的内容，即覆盖掉。代码如下：</p> 
<pre><code class="language-java">public class Hello_World {
    public static void main(String[] args) {
        try(FileOutputStream stream = new FileOutputStream("C:\\Users\\Xxy63\\Desktop\\无限弹窗代码.txt")){
            stream.write("Hello World".getBytes());  // 直接取代原内容
            stream.flush();
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}</code></pre> 
<p>        如果想接着文件的内容往后继续写(<strong>追加模式</strong>)，那么只需要把append的参数改为true即可，代码如下：</p> 
<pre><code class="language-java">public class Hello_World {
    public static void main(String[] args) {
        try(FileOutputStream stream = new FileOutputStream("C:\\Users\\Xxy63\\Desktop\\无限弹窗代码.txt",true)){ // 加上true 变成追加模式
            stream.write("Hello World".getBytes());  // 直接取代原内容
            stream.flush();
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p>        至此，我们就完成了输出流操作，那么，就可以结合输入流和输出流进行拷贝操作了。</p> 
<h3>文件的拷贝：</h3> 
<p>        文件拷贝是将一个文件的内容完整地复制到另一个文件的操作。相关的类有：</p> 
<pre><code class="language-java">   import java.io.FileInputStream;
   import java.io.FileOutputStream;
   import java.io.IOException;</code></pre> 
<p>        文件的拷贝操作一般使用读取数据的第三种方法，区间读取。因为这种方法可以设置足够大的区间，读取速度较快，不需要一个字节一个字节的去读取。下面是两个拷贝的示例代码：</p> 
<pre><code class="language-java">// 文件拷贝+进度条
public class Hello_World {
    public static void main(String[] args) {
        File file = new File("C:\\Users\\Xxy63\\Desktop\\文章.md");
        try(FileInputStream in = new FileInputStream(file);
        FileOutputStream out = new FileOutputStream("XXX.txt")){
            byte [] bytes = new byte[400];
            int len;
            long total = file.length() , sum = 0;
            while ((len = in.read(bytes))!=-1){
                out.write(bytes, 0, len);
                sum += len;
                System.out.println("文件已拷贝" + (sum*100/total) + '%');
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}</code></pre> 
<pre><code class="language-java">public class Hello_World {
    public static void main(String[] args) {
        try(FileInputStream in = new FileInputStream("C:\\Users\\Xxy63\\Desktop\\无限弹窗代码.txt");
            FileOutputStream out = new FileOutputStream("C:\\Users\\Xxy63\\Desktop\\copy.txt")){
            byte[] bytes = new byte[1024];
            int len;
            while ((len = in.read(bytes)) != -1) {
                out.write(bytes, 0, len);
            } // 拷贝速度大大提升
        }catch (IOException  e){
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p style="text-align:justify;">        在上述代码中，通过创建输入流 <code>FileInputStream</code> 从源文件读取数据，创建输出流 <code>FileOutputStream</code> 向目标文件写入数据。使用一个缓冲区来提高拷贝效率，每次读取一定数量的字节到缓冲区，然后将缓冲区中的数据写入目标文件，直到读取完源文件的所有内容。</p> 
<p>文件拷贝在很多场景中都很有用，比如：</p> 
<ul><li>数据备份：将重要文件复制一份以防止数据丢失。</li><li>共享文件：将文件拷贝到多个位置以便不同的程序或用户使用。</li></ul> 
<p>        例如，如果您有一个包含重要配置信息的文件，为了安全起见，可以定期进行备份拷贝。又或者在一个文件处理系统中，需要将原始文件拷贝到多个不同的目录下以供不同的模块处理。</p> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/4c/MfoU8tCx_o.jpg"></p> 
<h2 style="text-align:center;"><span style="color:#f3f3f4;"><span style="background-color:#0d0016;"> “且将新火试新茶，诗酒趁年华。”——《望江南·超然台作》</span></span></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bcc9fdcae7d97ee68ca17f51492339f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python &#43; Playwright（1）：Page 页面操作[详细介绍]</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ea3ae57f624a23dafd359c5576e6198/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ansible自动化运维中剧本角色(roles)来完成apache服务操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>