<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从零手写实现 nginx-04-基于 netty http 出入参优化处理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/50269b9571b3c2e308e6453a23d82332/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="从零手写实现 nginx-04-基于 netty http 出入参优化处理">
  <meta property="og:description" content="前言 大家好，我是老马。很高兴遇到你。
我们希望实现最简单的 http 服务信息，可以处理静态文件。
如果你想知道 servlet 如何处理的，可以参考我的另一个项目：
手写从零实现简易版 tomcat minicat netty 相关 如果你对 netty 不是很熟悉，可以读一下
Netty 权威指南-01-BIO 案例
Netty 权威指南-02-NIO 案例
Netty 权威指南-03-AIO 案例
Netty 权威指南-04-为什么选择 Netty？Netty 入门教程
手写 nginx 系列 如果你对 nginx 原理感兴趣，可以阅读：
从零手写实现 nginx-01-为什么不能有 java 版本的 nginx?
从零手写实现 nginx-02-nginx 的核心能力
从零手写实现 nginx-03-nginx 基于 Netty 实现
从零手写实现 nginx-04-基于 netty http 出入参优化处理
从零手写实现 nginx-05-MIME类型（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）
从零手写实现 nginx-06-文件夹自动索引
从零手写实现 nginx-07-大文件下载
从零手写实现 nginx-08-范围查询
从零手写实现 nginx-09-文件压缩
从零手写实现 nginx-10-sendfile 零拷贝">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T09:02:23+08:00">
    <meta property="article:modified_time" content="2024-06-04T09:02:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从零手写实现 nginx-04-基于 netty http 出入参优化处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="前言">前言</h2> 
<p>大家好，我是老马。很高兴遇到你。</p> 
<p>我们希望实现最简单的 http 服务信息，可以处理静态文件。</p> 
<p>如果你想知道 servlet 如何处理的，可以参考我的另一个项目：</p> 
<blockquote> 
 <p>手写从零实现简易版 tomcat <a href="https://github.com/houbb/minicat">minicat</a> </p> 
</blockquote> 
<h3 id="netty-相关">netty 相关</h3> 
<p>如果你对 netty 不是很熟悉，可以读一下</p> 
<p><a href="https://houbb.github.io/2019/05/10/netty-definitive-gudie-01-bio" rel="nofollow">Netty 权威指南-01-BIO 案例</a></p> 
<p><a href="https://houbb.github.io/2019/05/10/netty-definitive-gudie-02-nio" rel="nofollow">Netty 权威指南-02-NIO 案例</a></p> 
<p><a href="https://houbb.github.io/2019/05/10/netty-definitive-gudie-03-aio" rel="nofollow">Netty 权威指南-03-AIO 案例</a></p> 
<p><a href="https://houbb.github.io/2019/05/10/netty-definitive-gudie-04-why-netty" rel="nofollow">Netty 权威指南-04-为什么选择 Netty？Netty 入门教程</a></p> 
<h3 id="手写-nginx-系列">手写 nginx 系列</h3> 
<p>如果你对 nginx 原理感兴趣，可以阅读：</p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-01-how-to" rel="nofollow">从零手写实现 nginx-01-为什么不能有 java 版本的 nginx?</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-02-basic-http" rel="nofollow">从零手写实现 nginx-02-nginx 的核心能力</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-03-basic-http-netty" rel="nofollow">从零手写实现 nginx-03-nginx 基于 Netty 实现</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-04-netty-http-optimize" rel="nofollow">从零手写实现 nginx-04-基于 netty http 出入参优化处理</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-05-mime-type" rel="nofollow">从零手写实现 nginx-05-MIME类型（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-06-dir-list" rel="nofollow">从零手写实现 nginx-06-文件夹自动索引</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-07-big-file" rel="nofollow">从零手写实现 nginx-07-大文件下载</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-08-range" rel="nofollow">从零手写实现 nginx-08-范围查询</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-09-comparess" rel="nofollow">从零手写实现 nginx-09-文件压缩</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-10-sendfile" rel="nofollow">从零手写实现 nginx-10-sendfile 零拷贝</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-11-file-and-range-merge" rel="nofollow">从零手写实现 nginx-11-file+range 合并</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-12-keepalive" rel="nofollow">从零手写实现 nginx-12-keep-alive 连接复用</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-13-nginx-conf-intro" rel="nofollow">从零手写实现 nginx-13-nginx.conf 配置文件介绍</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-14-nginx-conf-hocon" rel="nofollow">从零手写实现 nginx-14-nginx.conf 和 hocon 格式有关系吗？</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-15-nginx-conf-parser" rel="nofollow">从零手写实现 nginx-15-nginx.conf 如何通过 java 解析处理？</a></p> 
<p><a href="https://houbb.github.io/2018/11/22/nginx-write-16-nginx-conf-multi-server" rel="nofollow">从零手写实现 nginx-16-nginx 支持配置多个 server</a></p> 
<h2 id="前言-1">前言</h2> 
<p>我们上一篇文章中，使用 netty 优化我们的 io 模型。</p> 
<p>对于请求和响应是基于自己的代码封装实现的。</p> 
<p>但是 http 协议本身比较复杂，自己实现起来要耗费大量的时间。</p> 
<p>那么，有没有现成的实现呢？</p> 
<p>答案是 netty 已经帮我们封装好了。</p> 
<h2 id="核心代码">核心代码</h2> 
<h3 id="启动类">启动类</h3> 
<p>我们对启动类调整如下：</p> 
<pre><code class="language-java">/**
 * netty 实现
 *
 * @author 老马啸西风
 * @since 0.2.0
 */
public class NginxServerNetty implements INginxServer {

    //basic ...

    @Override
    public void start() {
        // 服务器监听的端口号
        String host = InnerNetUtil.getHost();
        int port = nginxConfig.getHttpServerListen();

        EventLoopGroup bossGroup = new NioEventLoopGroup();
        //worker 线程池的数量默认为 CPU 核心数的两倍
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ChannelPipeline p = ch.pipeline();

                            p.addLast(new HttpRequestDecoder()); // 请求消息解码器
                            p.addLast(new HttpObjectAggregator(65536)); // 目的是将多个消息转换为单一的request或者response对象
                            p.addLast(new HttpResponseEncoder()); // 响应解码器
                            p.addLast(new ChunkedWriteHandler()); // 目的是支持异步大文件传输
                            // 业务逻辑
                            p.addLast(new NginxNettyServerHandler(nginxConfig));
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);

            // Bind and start to accept incoming connections.
            ChannelFuture future = serverBootstrap.bind(port).sync();

            log.info("[Nginx4j] listen on http://{}:{}", host, port);

            // Wait until the server socket is closed.
            future.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            // 省略...
        }
    }

}</code></pre> 
<h3 id="nginxnettyserverhandler-业务逻辑">NginxNettyServerHandler 业务逻辑</h3> 
<p>这个类可以变得非常简单</p> 
<pre><code class="language-java">/**
 * netty 处理类
 * @author 老马啸西风
 * @since 0.2.0
 */
public class NginxNettyServerHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; {

    //...

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
        logger.info("[Nginx] channelRead writeAndFlush start request={}", request);

        // 分发
        final NginxRequestDispatch requestDispatch = nginxConfig.getNginxRequestDispatch();
        FullHttpResponse response = requestDispatch.dispatch(request, nginxConfig);

        // 结果响应
        ChannelFuture lastContentFuture = ctx.writeAndFlush(response);
        //如果不支持keep-Alive，服务器端主动关闭请求
        if (!HttpUtil.isKeepAlive(request)) {
            lastContentFuture.addListener(ChannelFutureListener.CLOSE);
        }
        logger.info("[Nginx] channelRead writeAndFlush DONE response={}", response);
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        logger.error("[Nginx] exceptionCaught", cause);
        ctx.close();
    }

}</code></pre> 
<h3 id="分发处理">分发处理</h3> 
<p>分发处理的逻辑，主要是构建响应内容。</p> 
<p>我们先实现最基本的能力：</p> 
<pre><code class="language-java">    /**
     * 内容的分发处理
     *
     * @param requestInfoBo 请求
     * @param nginxConfig   配置
     * @return 结果
     * @author 老马啸西风
     */
    public FullHttpResponse dispatch(final FullHttpRequest requestInfoBo, final NginxConfig nginxConfig) {
        // 消息解析不正确
        /*如果无法解码400*/
        if (!requestInfoBo.decoderResult().isSuccess()) {
            log.warn("[Nginx] base request for http={}", requestInfoBo);
            return buildCommentResp(null, HttpResponseStatus.BAD_REQUEST, requestInfoBo, nginxConfig);
        }

        final String basicPath = nginxConfig.getHttpServerRoot();
        final String path = requestInfoBo.uri();

        boolean isRootPath = isRootPath(requestInfoBo, nginxConfig);
        // 根路径
        if(isRootPath) {
            log.info("[Nginx] current req meet root path");
            String indexContent = nginxConfig.getNginxIndexContent().getContent(nginxConfig);
            return buildCommentResp(indexContent, HttpResponseStatus.OK, requestInfoBo, nginxConfig);
        }

        // other
        String fullPath = FileUtil.buildFullPath(basicPath, path);
        if(FileUtil.exists(fullPath)) {
            String fileContent = FileUtil.getFileContent(fullPath);
            return buildCommentResp(fileContent, HttpResponseStatus.OK, requestInfoBo, nginxConfig);
        }  else {
            return buildCommentResp(null, HttpResponseStatus.NOT_FOUND, requestInfoBo, nginxConfig);
        }
    }</code></pre> 
<p>核心逻辑：</p> 
<p>1）如果请求体解析失败，直接返回。</p> 
<p>2）根路径，则返回 index 内容</p> 
<p>3）否则解析处理文件内容，不存在则返回 404</p> 
<p>resp 构建的方法暂时简单实现如下，后续我们会持续改进</p> 
<pre><code class="language-java">    /**
     * String format = "HTTP/1.1 200 OK\r\n" +
     *                 "Content-Type: text/plain\r\n" +
     *                 "\r\n" +
     *                 "%s";
     *
     * @param rawText 原始内容
     * @param status 结果枚举
     * @param request 请求内容
     * @param nginxConfig 配置
     * @return 结果
     * @author 老马啸西风
     */
    protected FullHttpResponse buildCommentResp(String rawText,
                                            final HttpResponseStatus status,
                                            final FullHttpRequest request,
                                            final NginxConfig nginxConfig) {
        String defaultContent = status.toString();
        if(StringUtil.isNotEmpty(rawText)) {
            defaultContent = rawText;
        }

        // 构造响应
        FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,
                status, Unpooled.copiedBuffer(defaultContent, CharsetUtil.UTF_8));
        // 头信息
        // TODO: 根据文件变化
        response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain; charset=UTF-8");
        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
        //如果request中有KEEP ALIVE信息
        if (HttpUtil.isKeepAlive(request)) {
            response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);
        }

        return response;
    }</code></pre> 
<h2 id="小结">小结</h2> 
<p>本节我们使用 netty 简化出入参的处理。</p> 
<p>但是响应的构建还不够完善，我们下一节来一起优化一下响应的处理。</p> 
<p>我是老马，期待与你的下次重逢。</p> 
<h2 id="开源地址">开源地址</h2> 
<p>为了便于大家学习，已经将 nginx 开源</p> 
<blockquote> 
 <p><a href="https://github.com/houbb/nginx4j">https://github.com/houbb/nginx4j</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d342a5e302f0546322d542b8b10f23f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AIGC 011-SAM第一个图像分割大模型-分割一切！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d950f3b1c7b5cc16be9b4f75bdab324c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习（中）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>