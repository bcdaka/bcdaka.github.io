<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring】Spring的循环依赖以及解决方案 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0da3a7b55e8a7e3822bee0a89550c16f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Spring】Spring的循环依赖以及解决方案">
  <meta property="og:description" content="1. 什么是Spring循环依赖？ ​ Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。通俗的说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。
​ Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。
2. 常见形成原因 1. 构造函数循环依赖 ​ 在使用构造函数注入Bean时，如果两个Bean之间相互依赖，就可能会形成构造函数循环依赖，例如：
@Component public class A { private B b; public A(B b) { this.b = b; }} ============== @Component public class B { private A a; public B(A a) { this.a = a; }} 上述代码，A、B的构造函数分别需要创建对方，A依赖B，B依赖A，它们之间形成了一个循环依赖。
当Spring容器启动时，它会尝试先实例化A，但是在实例化A的时候需要先实例化B，而实例化B的时候需要先实例化A，这样就形成了一个循环依赖的死循环，从而导致应用程序无法正常启动。
2. 属性循环依赖 ​ 在使用属性注入Bean时，如果两个Bean之间相互依赖，就可能会形成属性循环依赖。例如：
@Component public class A { @Autowired private B b; } ============= @Component public class B { @Autowired private A a; } 类似的，同样Spring在实例化A时会注入B，而注入B时又需要注入A，形成循环依赖">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-04T17:12:37+08:00">
    <meta property="article:modified_time" content="2024-02-04T17:12:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring】Spring的循环依赖以及解决方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_Spring_0"></a>1. 什么是Spring循环依赖？</h2> 
<p>​ Spring循环依赖指的是两个或多个Bean之间相互依赖，形成一个环状依赖的情况。通俗的说，就是A依赖B，B依赖C，C依赖A，这样就形成了一个循环依赖的环。</p> 
<p>​ Spring循环依赖通常会导致Bean无法正确地被实例化，从而导致应用程序无法正常启动或者出现异常。因此，Spring循环依赖是一种需要尽量避免的情况。</p> 
<h2><a id="2__6"></a>2. 常见形成原因</h2> 
<h3><a id="1__8"></a>1. 构造函数循环依赖</h3> 
<p>​ 在使用构造函数注入Bean时，如果两个Bean之间相互依赖，就可能会形成构造函数循环依赖，例如：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>    
    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>    
	<span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>     
        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>   
    <span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>   
    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>   
    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>     
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> 
<p>上述代码，A、B的构造函数分别需要创建对方，A依赖B，B依赖A，它们之间形成了一个循环依赖。<br> 当Spring容器启动时，它会尝试先实例化A，但是在实例化A的时候需要先实例化B，而实例化B的时候需要先实例化A，这样就形成了一个循环依赖的死循环，从而导致应用程序无法正常启动。</p> 
<h3><a id="2___31"></a>2. 属性循环依赖</h3> 
<p>​ 在使用属性注入Bean时，如果两个Bean之间相互依赖，就可能会形成属性循环依赖。例如：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>   
    <span class="token annotation punctuation">@Autowired</span>    
    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>    
    <span class="token annotation punctuation">@Autowired</span>    
    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>类似的，同样Spring在实例化A时会注入B，而注入B时又需要注入A，形成循环依赖</p> 
<h2><a id="3_Spring_51"></a>3. Spring如何解决循环依赖</h2> 
<p>要了解如何解决Spring的循环依赖，就必须要从Spring对Bean的创建过程入手，从原理上去理解，而不是单纯记忆</p> 
<h3><a id="31_Spring_Bean_55"></a>3.1 Spring 是如何创建Bean的？</h3> 
<p><img src="https://images2.imgbox.com/4c/f9/oVUp2FCV_o.png" alt="image-20231127202430747"></p> 
<p>​ (1) 首先Spring容器启动之后，会根据使用不同类型的Application Context，通过不同的方式去加载Bean配置，如xml方式、注解方式，将这些Bean配置加载到容器中，作为Bean定义包装成BeanDefinition对象保存起来，为下一步创建Bean做准备。</p> 
<p>​ (2) 根据加载的Bean定义信息，通过反射来创建Bean实例，如果是普通Bean，则直接创建Bean，如果是FactoryBean，说明真正要创建的对象为getObject()的返回值，调用getObject()将返回值作为Bean。</p> 
<p>​ (3) 目前已经完成了Bean实例的创建，还需要对依赖的属性进行装配，例如，平时开发中Controller中，往往需要将Service Bean注入进来，循环依赖也是在这一步解决的，后面会详细说明，如果通过@Autowired注解注入的成员变量，则会通过AutowiredAnnotationBeanPostProcessor后置处理器进行注入，如果xml自动注入，则会根据按名字自动装配和按类型自动装配分别进行处理。</p> 
<p>​ (4) 自动装配完成后，将完整的Bean对象保存到Spring 缓存中，接下来进入Bean的初始化流程，执行Bean的后置处理器的前置处理方法，如果Bean本身实现了InitializingBean接口，就去执行对应的afterPropertiesSet()方法，最后再执行Bean的后置处理器的后置处理方法。</p> 
<h3><a id="32_Spring_67"></a>3.2 Spring三级缓冲机制</h3> 
<h4><a id="1_Spring_69"></a>1. Spring可以解决的依赖循环</h4> 
<p>回到上述的依赖循环案例，A、B相互依赖时，产生的循环依赖现象还需进一步细分：</p> 
<p><img src="https://images2.imgbox.com/0e/3b/Ik2JMUcW_o.png" alt="image-20231127205639553"></p> 
<blockquote> 
 <p>注意：只有单例的 Bean 存在循环依赖的情况，Spring才可以解决，<strong>原型</strong>(Prototype)情况下，Spring 会直接抛出异常。</p> 
</blockquote> 
<p>​ Spring 不支持基于构造器注入的循环依赖。 但是假如 AB 循环依赖，如果一个是构造器注入，一个是 setter 注入呢？</p> 
<p>看看几种情形：</p> 
<p><img src="https://images2.imgbox.com/2a/d2/MTe1XOA2_o.png" alt="循环依赖的几种情形"><br> <strong>第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</strong></p> 
<p>简单总结，当循环依赖的实例都采用 setter 方法注入的时候，Spring 可以支持，都采用构造器注入的时候，不支持，构造器注入和 setter 注入同时存在的时候，看天。</p> 
<h4><a id="2__86"></a>2. 三层缓存机制</h4> 
<p>bean的创建流程：</p> 
<p><img src="https://images2.imgbox.com/4d/18/BKkO9b2O_o.png" alt="image-20231127210241590"></p> 
<p>​ 依赖注入就发生在第二步，<strong>属性赋值</strong>，结合这个过程，Spring 通过<strong>三级缓存</strong>解决了循环依赖：</p> 
<ol><li>一级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>singletonObjects</strong>，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例</li><li>二级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>earlySingletonObjects</strong>，早期曝光对象，用于保存实例化完成的 bean 实例</li><li>三级缓存 : <code>Map&lt;String,ObjectFactory&lt;?&gt;&gt;</code> <strong>singletonFactories</strong>，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。</li></ol> 
<p><img src="https://images2.imgbox.com/70/e8/Jf2fpGpU_o.png" alt="三级缓存"></p> 
<p>我们来看一下三级缓存解决循环依赖的过程：</p> 
<p>当 A、B 两个类发生循环依赖时：<br> <img src="https://images2.imgbox.com/ea/14/Ef92qhvG_o.png" alt="循环依赖"></p> 
<p>A 实例的初始化过程：</p> 
<ol><li>创建 A 实例，实例化的时候把 A 对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道</li></ol> 
<p><img src="https://images2.imgbox.com/37/cb/0bJkLOOh_o.png" alt="1">1</p> 
<ol><li>A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B</li><li>同样，B 注⼊属性时发现依赖 A，它就会从缓存里找 A 对象。依次从⼀级到三级缓存查询 A，从三级缓存通过对象⼯⼚拿到 A，发现 A 虽然不太完善，但是存在，把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入⼀级缓存。</li></ol> 
<p><img src="https://images2.imgbox.com/93/14/ggCwvENl_o.png" alt="2">2</p> 
<ol><li>接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存</li><li>最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象</li></ol> 
<p><img src="https://images2.imgbox.com/07/d0/fWXxr8vx_o.png" alt="5">5</p> 
<p>所以，我们就知道为什么 Spring 能解决 setter 注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p> 
<p>所以，我们就知道为什么 Spring 能解决 setter 注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c9887d116c6aeb797779d52a56b3e748/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot集成Flowable工作流</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0412d21cf98a73f4d8b624cd58a28cdc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI时代架构设计新模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>