<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java - JDK17语法新增特性（如果想知道Java - JDK17语法新增常见的特性的知识点，那么只看这一篇就足够了！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/04c1f2eff839c3331d378058090f0bc6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java - JDK17语法新增特性（如果想知道Java - JDK17语法新增常见的特性的知识点，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：Java在2021年发布了最新的长期支持版本：JDK 17。这个版本引入了许多新的语法特性，提升了开发效率和代码可读性。本文将简要介绍一些常见的新特性，帮助开发者快速掌握并应用于实际开发中。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
1.yield关键词 ——先让我们来了解一下yield关键词的作用：
yield关键字，用于增强switch表达式，使其能够返回值。yield允许switch表达式在不同的分支中返回特定的值，并将其赋给变量。
先让我们来看一个正常的switch的例子：
public class Test { public static void main(String[] args) { String data = &#34;one&#34;; int result = 0; // 接收数据的返回值 switch (data) { case &#34;one&#34;: result = 1; // 为result重新赋值 break; case &#34;two&#34;: result = 2; // 为result重新赋值 break; default: result = -1; // 为result重新赋值 break; } System.out.println(result); } } 代码分析：
定义类和主方法：代码定义了一个名为Test的类，并包含一个main方法，这是程序的入口点。
初始化变量：声明并初始化了两个变量，data和result。data被赋值为字符串&#34;one&#34;，result被初始化为0。
switch语句：
根据data的值进行判断。
如果data的值是&#34;one&#34;，则执行result = 1;，并通过break跳出switch语句。
如果data的值是&#34;two&#34;，则执行result = 2;，并通过break跳出switch语句。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-06T15:01:25+08:00">
    <meta property="article:modified_time" content="2024-07-06T15:01:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java - JDK17语法新增特性（如果想知道Java - JDK17语法新增常见的特性的知识点，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>       前言：Java在2021年发布了最新的长期支持版本：JDK 17。这个版本引入了许多新的语法特性，提升了开发效率和代码可读性。本文将简要介绍一些常见的新特性，帮助开发者快速掌握并应用于实际开发中。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d2/71/8lTeBoPk_o.jpg"></p> 
 <p><strong>✨✨<span style="color:#ff9900;">✨这里是秋刀鱼不做梦的BLOG</span></strong></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文大致的讲解内容：</strong></span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9f/39/XOfajOMB_o.png"></p> 
<p></p> 
<h2><span style="color:#956fe7;"><strong>1.yield关键词</strong></span></h2> 
<p><span style="color:#956fe7;"><strong>       </strong></span><strong> ——先让我们来了解一下yield关键词的作用：</strong></p> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong><code>yield</code>关键字，用于增强<code>switch</code>表达式，使其能够返回值。<code>yield</code>允许<code>switch</code>表达式在不同的分支中返回特定的值，并将其赋给变量。</strong></span></p> 
</blockquote> 
<p><strong>先让我们来看一个正常的switch的例子：</strong></p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        String data = "one";
        int result = 0; // 接收数据的返回值
        switch (data) {
            case "one":
                result = 1; // 为result重新赋值
                break;
            case "two":
                result = 2; // 为result重新赋值
                break;
            default:
                result = -1; // 为result重新赋值
                break;
        }
        System.out.println(result);
    }
}</code></pre> 
<p><span style="color:#38d8f0;"><strong>代码分析：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong>定义类和主方法：代码定义了一个名为<code>Test</code>的类，并包含一个<code>main</code>方法，这是程序的入口点。</strong></p> </li><li> <p><strong>初始化变量：声明并初始化了两个变量，<code>data</code>和<code>result</code>。<code>data</code>被赋值为字符串"one"，<code>result</code>被初始化为0。</strong></p> </li><li> <p><strong>switch语句：</strong></p> 
   <ul><li> <p><strong>根据<code>data</code>的值进行判断。</strong></p> </li><li> <p><strong>如果<code>data</code>的值是"one"，则执行<code>result = 1;</code>，并通过<code>break</code>跳出<code>switch</code>语句。</strong></p> </li><li> <p><strong>如果<code>data</code>的值是"two"，则执行<code>result = 2;</code>，并通过<code>break</code>跳出<code>switch</code>语句。</strong></p> </li><li> <p><strong>如果<code>data</code>的值不是"one"或"two"，则执行<code>default</code>块，将<code>result</code>赋值为-1，并通过<code>break</code>跳出<code>switch</code>语句。</strong></p> </li></ul></li><li> <p><strong>输出结果：通过<code>System.out.println(result);</code>将<code>result</code>的值输出到控制台。</strong></p> </li></ol> 
</blockquote> 
<p><span style="color:#38d8f0;"><strong>现在让我们将上述的代码进行简化，简化后的switch：</strong></span></p> 
<pre><code class="language-java">public static void main(String[] args) {
    String data = "one";
    int result = switch (data) {
        case "one" -&gt; 1;
        case "two" -&gt; 2;
        default -&gt; -1;
    };
    System.out.println(result);
}</code></pre> 
<p><span style="color:#38d8f0;"><strong>我们发现我们可以使用-&gt;来返回switch语句的值，当然有读者会问了，这和我们讲解的yield有什么关系呢？，接下来让我们将上述代码转换为yield的形式：</strong></span></p> 
<pre><code class="language-java">public static void main(String[] args) {
    String data = "one" ;
    int result = switch (data) {
        case "one" : yield 1;
        case "two": yield 2;
        default : yield -1;
    };
    System.out.println(result) ;
}</code></pre> 
<p>我们可以发现我们也可以使用yield来返回switch的值，这就是yield语句。</p> 
<p></p> 
<h2><span style="color:#956fe7;">2.var关键词</span></h2> 
<p><span style="color:#956fe7;">        </span><span style="color:#ff9900;"><strong><code>var</code>是Java 10中引入的一个新特性，用于局部变量类型推断。它允许编译器在编译时自动推断变量的类型，从而简化代码书写和增强代码可读性。 </strong></span></p> 
<p><span style="color:#ff9900;"><strong>        </strong></span>接下来我们直接使用实例来进行讲解：</p> 
<p>以下是一个使用<code>var</code>的示例：</p> 
<pre><code class="language-java">import java.util.ArrayList;

public class VarExample {
    public static void main(String[] args) {
        // 使用var声明整型变量
        var number = 10;
        System.out.println("Number: " + number);

        // 使用var声明字符串变量
        var text = "Hello, Java 10!";
        System.out.println("Text: " + text);

        // 使用var声明集合
        var list = new ArrayList&lt;String&gt;();
        list.add("Apple");
        list.add("Banana");
        System.out.println("List: " + list);

        // 使用var声明迭代器
        for (var item : list) {
            System.out.println("Item: " + item);
        }
    }
}
</code></pre> 
<p><span style="color:#4da8ee;"><strong>        </strong></span><span style="color:#4da8ee;"><strong>从上述的代码我们可以看到，我们使用var关键词来声明变量，其会自动的推断类型。这大大的方便了我们声明变量。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>        虽然var关键词可以推断出变量的类型，但是不要什么时候都使用var关键词来声明变量，一般在类型名称非常长的时候，例如泛型，我们会使用var来简化代码。</strong></span></p> 
</blockquote> 
<p><span style="color:#ffd900;"><strong>例如：</strong></span></p> 
<pre><code class="language-java">public static void main(String[] args) {
    Map&lt;String, List&lt;Map&lt;Integer, String&gt;&gt;&gt; complexMap = new HashMap&lt;String,
                List&lt;Map&lt;Integer, String&gt;&gt;&gt;();

    //使用var关键词进行简化 
    var complexMap2 = new HashMap&lt;String, List&lt;Map&lt;Integer, String&gt;&gt;&gt;();
}</code></pre> 
<p><span style="color:#38d8f0;"><strong>我们可以发现这样我们的代码繁琐度大大的简化了。</strong></span></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>注意事项：</strong></span></p> 
<ul><li> <p><span style="color:#fe2c24;"><strong><code>var</code>只能用于局部变量声明，不能用于成员变量、方法参数或返回类型。</strong></span></p> </li><li> <p><span style="color:#fe2c24;"><strong>变量必须在声明时初始化，因为编译器需要根据初始化值来推断变量类型。</strong></span></p> </li><li> <p><span style="color:#fe2c24;"><strong><code>var</code>不能用于没有初始化值的变量声明。</strong></span></p> </li><li> <p><span style="color:#fe2c24;"><strong><code>var</code>不能用于<code>null</code>初始化，因为无法推断类型。</strong></span></p> </li></ul> 
<p><strong>以上就是Java中的var关键词的使用了。</strong></p> 
<p></p> 
<h2><span style="color:#956fe7;"><strong>3.</strong>密封类 - sealed</span></h2> 
<p><span style="color:#956fe7;">     </span><span style="color:#ff9900;"><strong>   </strong></span><strong>在讲解sealed关键词之前，先让我们讲解一下什么是密封类：</strong></p> 
<blockquote> 
 <p><strong>        <span style="color:#ff9900;">密封类（Sealed Classes）是一项语言特性，旨在更好地控制类层次结构中的继承关系。通过使用密封类，开发者可以明确指定哪些类可以继承某个类，从而增强类型安全性和代码可维护性。</span></strong></p> 
</blockquote> 
<p>我们知道，在Java中使用final修饰的类为密封类，其作用就是不能被其他类所继承，如果被继承就会报错，例如：</p> 
<pre><code class="language-java">// 定义一个final类
public final class FinalClass {
    private String message;

    public FinalClass(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}

// 尝试继承final类
public class SubClass extends FinalClass {  // 这行会导致编译错误
    public SubClass(String message) {
        super(message);
    }
}
</code></pre> 
<p><span style="color:#38d8f0;"><strong>        当然，在JDK17中提供了一个新的关键字： sealed 。它允许你显式地列出可以扩展某个类或实现某个接口的类，从而增强了类型安全性和可维护性。</strong></span></p> 
<p><strong>      </strong></p> 
<p><strong>         —— 那么怎么使用sealed关键词呢？</strong></p> 
<p>     </p> 
<p><span style="color:#a2e043;"><strong>使用<code>sealed</code>关键字的步骤如下：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong>（1）声明一个<code>sealed</code>类或接口。</strong></p> </li><li> <p><strong>（2）使用<code>permits</code>关键字明确允许哪些类可以继承该<code>sealed</code>类或接口。</strong></p> </li><li> <p><strong>（3）被允许的子类必须是<code>final</code>，<code>sealed</code>，或<code>non-sealed</code>的。</strong></p> </li></ol> 
</blockquote> 
<p><strong>让我们直接使用案例来帮助你进行理解：（代码如下）</strong></p> 
<pre><code class="language-java">// 定义一个sealed类
public sealed class Shape permits Circle, Rectangle, Square {
    // 声明一个抽象方法area，要求任何继承Shape的子类必须实现这个方法
    public abstract double area();
}

// 定义一个final子类
public final class Circle extends Shape {
    // 声明一个私有的最终变量radius，用于存储圆的半径
    private final double radius;

    // Circle类的构造方法，接收一个半径参数并初始化radius
    public Circle(double radius) {
        this.radius = radius;
    }

    // 实现Shape类中声明的抽象方法area，计算并返回圆的面积
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}

// 定义一个sealed子类
public sealed class Rectangle extends Shape permits FilledRectangle {
    // 声明两个私有的最终变量width和height，用于存储矩形的宽和高
    private final double width;
    private final double height;

    // Rectangle类的构造方法，接收矩形的宽和高参数并初始化width和height
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    // 实现Shape类中声明的抽象方法area，计算并返回矩形的面积
    @Override
    public double area() {
        return width * height;
    }
}

// 定义一个non-sealed子类
public non-sealed class Square extends Shape {
    // 声明一个私有的最终变量side，用于存储正方形的边长
    private final double side;

    // Square类的构造方法，接收一个边长参数并初始化side
    public Square(double side) {
        this.side = side;
    }

    // 实现Shape类中声明的抽象方法area，计算并返回正方形的面积
    @Override
    public double area() {
        return side * side;
    }
}

// 进一步定义一个final子类
public final class FilledRectangle extends Rectangle {
    // 声明一个私有的最终变量color，用于存储填充矩形的颜色
    private final String color;

    // FilledRectangle类的构造方法，接收矩形的宽、高和颜色参数，并调用父类Rectangle的构造方法进行初始化
    public FilledRectangle(double width, double height, String color) {
        super(width, height);
        this.color = color;
    }

    // 添加一个额外的方法getColor，用于获取填充矩形的颜色
    public String getColor() {
        return color;
    }
}
</code></pre> 
<p><span style="color:#ffd900;"><strong>在这个例子中：</strong></span></p> 
<blockquote> 
 <p><strong><code>1. Shape</code>是一个<code>sealed</code>类，只有<code>Circle</code>，<code>Rectangle</code>和<code>Square</code>可以继承它。</strong></p> 
 <p><strong><code>2. Circle</code>是一个<code>final</code>类，不能被进一步继承。</strong></p> 
 <p><strong><code>3. Rectangle</code>是一个<code>sealed</code>类，只有<code>FilledRectangle</code>可以继承它。</strong></p> 
 <p><strong><code>4. Square</code>是一个<code>non-sealed</code>类，可以被进一步继承</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>并且我们要注意：</strong></span></p> 
<blockquote> 
 <p><strong>        1. sealed修饰的类必须要有子类；</strong></p> 
 <p><strong>        2. 未被permits 允许的类型，则没办法继承；</strong></p> 
 <p><strong>        3. 子类使用final修饰则不可以继承发生继承；</strong></p> 
 <p><strong>        4. 子类使用 non-sealed 关键字修饰。表示不限制，任何类都可以继承；</strong></p> 
 <p><strong>        5. 子类使用sealed关键词的可以继承发生继承；</strong></p> 
</blockquote> 
<p>这样我们就大致的了解了sealed关键词了。</p> 
<p></p> 
<h2><span style="color:#956fe7;">4.接口中的私有方法</span></h2> 
<p><span style="color:#ff9900;"><strong>        在接口中的私有方法常常用于对接口中的default修饰的方法和静态方法进行辅助，将其内部的代码进行封装简化。</strong></span></p> 
<p><span style="color:#ffd900;"><strong>例如：</strong></span></p> 
<pre><code class="language-java">interface HelloService {
    public void sayHello();
    // 默认方法
    default void saySomething(){
        syaEngHello();
        sayHello();
    };
    // 私有方法
    private void syaEngHello(){
        System.out.println("Hello!");
    }</code></pre> 
<p><span style="color:#38d8f0;"><strong>        接口的私有方法为Java语言引入了更多的灵活性和功能性，可以帮助编写更干净、更模块化的代码，提升了接口的设计和实现的效率和质量。</strong></span></p> 
<p><strong>        这就是Java中接口中的私有方法的使用。</strong></p> 
<p></p> 
<h2><span style="color:#956fe7;"><strong>5.</strong>instanceof关键词</span></h2> 
<p><span style="color:#956fe7;">        </span><span style="color:#ff9900;"><strong>在Java中，<code>instanceof</code>是一个关键字，用于测试一个对象是否是一个类的实例或者是其子类的实例。它的语法形式如下：</strong></span></p> 
<pre><code class="language-java">object instanceof type
</code></pre> 
<p><strong>        其中，<code>object</code>是要检查的对象，<code>type</code>是一个类名或接口名。<code>instanceof</code>操作符的作用是检查<code>object</code>是否是<code>type</code>类型的实例，或者是<code>type</code>类型的子类的实例。它返回一个布尔值，如果<code>object</code>是<code>type</code>类型或其子类的实例，则返回<code>true</code>；否则返回<code>false</code>。</strong></p> 
<p></p> 
<p><span style="color:#ffd900;"><strong>        ——接下来让我们使用一个实例来进行对其进一步理解：</strong></span></p> 
<pre><code class="language-java">class Animal {
    // Animal 类的成员和方法
}

class Dog extends Animal {
    // Dog 类的成员和方法
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // 创建一个 Dog 对象并赋值给 Animal 类型的变量

        // 使用 instanceof 来检查对象的类型
        if (animal instanceof Dog) {
            System.out.println("animal 是 Dog 类的实例");
        }
        
        if (animal instanceof Animal) {
            System.out.println("animal 是 Animal 类的实例");
        }
        
        if (animal instanceof Object) {
            System.out.println("animal 是 Object 类的实例");
        }
    }
}
</code></pre> 
<p><span style="color:#ff9900;"><strong>解释：</strong></span></p> 
<ol><li> <p><strong><code>Animal</code>是一个类，<code>Dog</code>是<code>Animal</code>的子类。</strong></p> </li><li> <p><strong>在<code>main</code>方法中，创建了一个<code>Dog</code>对象，并将其赋值给一个<code>Animal</code>类型的变量<code>animal</code>。</strong></p> </li><li> <p><strong>使用<code>instanceof</code>关键字，首先检查<code>animal</code>是否是<code>Dog</code>类的实例，结果为<code>true</code>，因为<code>animal</code>确实是<code>Dog</code>类的实例。</strong></p> </li><li> <p><strong>接着检查<code>animal</code>是否是<code>Animal</code>类的实例，同样为<code>true</code>，因为<code>Dog</code>类是<code>Animal</code>类的子类。</strong></p> </li><li> <p><strong>最后检查<code>animal</code>是否是<code>Object</code>类的实例，结果同样为<code>true</code>，因为所有类在Java中最终都是继承自<code>Object</code>类的。</strong></p> </li></ol> 
<p><strong><span style="color:#38d8f0;">        通过上面的讲解，我相信你已经对Java中instanceof关键词有了一定的理解，那么instanceof关键词有什么用处呢？</span></strong></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>instanceof的用途：</strong></span></p> 
<ul><li> <p><strong>类型检查和转换</strong>：<code>instanceof</code>通常用于在运行时检查对象的类型，以便进行类型转换或根据对象的实际类型执行特定的操作。</p> </li><li> <p><strong>条件控制</strong>：可以根据对象的类型来决定执行不同的代码路径，以实现多态性和灵活的程序逻辑。</p> </li><li> <p><strong>安全性检查</strong>：在某些情况下，使用<code>instanceof</code>可以帮助避免类型转换异常（<code>ClassCastException</code>），在进行类型转换之前先检查对象的类型是否符合预期。</p> </li></ul> 
<p></p> 
<p><strong>这样我们就大致的了解了Java中的instanceof关键词了。</strong></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的全部内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb58269c4b52c447eb7976f117811971/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">超级好用的java http请求工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9ea7114d918713bcbca8f62ce6f90d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【学习笔记】程序设计竞赛</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>