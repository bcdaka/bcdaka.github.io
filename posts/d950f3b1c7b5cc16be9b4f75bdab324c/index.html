<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度学习（中） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d950f3b1c7b5cc16be9b4f75bdab324c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深度学习（中）">
  <meta property="og:description" content="1.前馈全连接神经网络对鸢尾花数据集进行分类 1.1导入鸢尾花数据集 iris =load_iris() 1.2划分训练集测试集 x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target,test_size=0.2,random_state=23) 参数1：数据集数据
参数2：数据集标签
参数3：测试集大小
参数4：随机种子
1.3划分验证集 x_train,X_valid,y_train,y_valid = train_test_split(x_train,y_train,test_size=0.2,random_state=12) 1.4输出验证集训练集的形状 print(X_valid.shape) print(X_train.shape) 运行结果： 1.5 训练模型（和上篇文章有些方法是一样的） keras.layers.Dropout(rate=0.2) Dropout是一种正则化方法，用于防止过拟合；rate=0.2表示在训练时，该层会随机地将20%的输入单元置0
8.6使用fit训练模型，将训练过程转为二维数组 h = model.fit(x_train,y_train,batch_size=10,epochs=20,validation_data=(X_valid,y_valid)) pd.DataFrame(h.history) 运行结果： 1.7 画图 运行结果： 1.8评估模型:使用函数evaluate model.evaluate(x_test,y_test,batch_size=1) 运行结果： 2.卷积神经网络 2.1加载显示图像 2.1.1导入加载内置图像的库 from sklearn.datasets import load_sample_image 2.1.2将图像进行归一化 china = load_sample_image(&#39;china.jpg&#39;)/255 flower = load_sample_image(&#39;flower.jpg&#39;)/255 2.1.3绘制图像 plt.subplot(1,2,1) plt.imshow(china) plt.subplot(1,2,2) plt.imshow(flower) 2.1.4输出维度 print(&#39;china.jpg的维度：&#39;,china.shape) print(&#39;flower.jpg的维度：&#39;,flower.shape) 2.1.5将两张图像组成一个数组 imgs = np.array([china,flower]) img_shape = imgs.shape print(&#39;数据集的维度：&#39;,img_shape) 运行结果： 2.2确定卷积层大小，滑动步长 输出特征图数目 u = 7 #卷积层大小 s = 1 #滑动步长 p = 5 #输出特征图数目 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T09:04:02+08:00">
    <meta property="article:modified_time" content="2024-06-04T09:04:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度学习（中）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:justify;"><strong>1.前馈全连接神经网络对鸢尾花数据集进行分类</strong></h2> 
<h3 style="text-align:justify;"><strong>1.1导入鸢尾花数据集</strong></h3> 
<pre><code>iris =load_iris()</code></pre> 
<h3 style="text-align:justify;"><strong>1.2划分训练集测试集</strong></h3> 
<pre><code>x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target,test_size=0.2,random_state=23)</code></pre> 
<p style="margin-left:.0001pt;text-align:left;">参数1：数据集数据</p> 
<p style="margin-left:.0001pt;text-align:left;">参数2：数据集标签</p> 
<p style="margin-left:.0001pt;text-align:left;">参数3：测试集大小</p> 
<p style="margin-left:.0001pt;text-align:left;">参数4：随机种子</p> 
<h3 style="text-align:justify;"><strong>1.3划分验证集</strong></h3> 
<pre><code>x_train,X_valid,y_train,y_valid = train_test_split(x_train,y_train,test_size=0.2,random_state=12)</code></pre> 
<h3 style="text-align:justify;"><strong>1.4输出验证集训练集的形状</strong></h3> 
<pre><code>print(X_valid.shape)

print(X_train.shape)</code></pre> 
<h5 style="text-align:justify;"><strong>运行结果：</strong></h5> 
<p style="margin-left:.0001pt;text-align:left;">          <img alt="" height="74" src="https://images2.imgbox.com/63/10/d80ONRcF_o.png" width="449"></p> 
<h3 style="text-align:justify;"><strong>1.5 训练模型（和上篇文章有些方法是一样的）</strong></h3> 
<pre><code>keras.layers.Dropout(rate=0.2)</code></pre> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#1f2328;">Dropout是</span></span><span style="background-color:#ffffff;"><span style="color:#1f2328;">一种正则化方法，用于防止过拟合</span></span><span style="background-color:#ffffff;"><span style="color:#1f2328;">；rate=0.2</span></span><span style="background-color:#ffffff;"><span style="color:#1f2328;">表示</span></span><span style="background-color:#ffffff;"><span style="color:#1f2328;">在训练时，该层会随机地将20%的输入单元置</span></span><span style="background-color:#ffffff;"><span style="color:#1f2328;">0</span></span></p> 
<h4 style="text-align:justify;"><strong>8.6使用fit训练模型，将训练过程转为二维数组</strong></h4> 
<pre><code>h = model.fit(x_train,y_train,batch_size=10,epochs=20,validation_data=(X_valid,y_valid))

pd.DataFrame(h.history)</code></pre> 
<h5 style="text-align:justify;"><strong>运行结果：</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;">            <img alt="" height="326" src="https://images2.imgbox.com/9f/fe/wTnKyasq_o.png" width="252">   </p> 
<h3 style="text-align:justify;">1.7 画图</h3> 
<h5 style="text-align:justify;"><strong>运行结果：</strong></h5> 
<p style="margin-left:.0001pt;text-align:justify;">      <img alt="" height="319" src="https://images2.imgbox.com/cf/cb/754m9eLV_o.png" width="535"></p> 
<h4 style="text-align:justify;"><strong>1.8评估模型:使用函数evaluate</strong></h4> 
<pre><code>model.evaluate(x_test,y_test,batch_size=1)</code></pre> 
<h5 style="text-align:justify;"><strong>运行结果：</strong></h5> 
<p><img alt="" height="59" src="https://images2.imgbox.com/43/a3/LbCflBi7_o.png" width="692"></p> 
<h2>2.卷积神经网络</h2> 
<h3>2.1<strong>加载显示图像</strong></h3> 
<h4><strong>2.1.1导入加载内置图像的库</strong></h4> 
<pre><code>from sklearn.datasets import load_sample_image</code></pre> 
<h4>2.1.2<strong>将图像进行归一化</strong></h4> 
<pre><code>china = load_sample_image('china.jpg')/255

flower = load_sample_image('flower.jpg')/255</code></pre> 
<h4>2.1.3<strong>绘制图像</strong></h4> 
<pre><code>plt.subplot(1,2,1)
plt.imshow(china)
plt.subplot(1,2,2)
plt.imshow(flower)</code></pre> 
<h4>2.1.4<strong>输出维度</strong></h4> 
<pre><code>print('china.jpg的维度：',china.shape)
print('flower.jpg的维度：',flower.shape)</code></pre> 
<h4>2.1.5<strong>将两张图像组成一个数组</strong></h4> 
<pre><code>imgs = np.array([china,flower])
img_shape = imgs.shape

print('数据集的维度：',img_shape)</code></pre> 
<h5>运行结果：</h5> 
<p><img alt="" height="291" src="https://images2.imgbox.com/bc/47/sTWdguUS_o.png" width="692"></p> 
<h3>2.2<strong>确定卷积层大小，滑动步长   输出特征图数目</strong></h3> 
<pre><code>u = 7            #卷积层大小
s = 1            #滑动步长
p = 5            #输出特征图数目</code></pre> 
<h3>2.3定义二维卷积层</h3> 
<pre><code class="language-python">conv = keras.layers.Conv2D(filters = p,kernel_size = u,strides = s,padding = 'SAME',activation = 'relu',input_shape = img_shape)</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">参数1：卷积核数量</p> 
<p style="margin-left:.0001pt;text-align:justify;">参数2：卷积核的大小</p> 
<p style="margin-left:.0001pt;text-align:justify;">参数3：卷积的步长</p> 
<p style="margin-left:.0001pt;text-align:justify;">参数4：卷积操作时使用的填充方式， 'SAME' 表示使用边界像素填充，保持卷积后输出的空间维度与输入相同，'VALID'不使用填充，可能会导致输出的空间维度小于输入</p> 
<p style="margin-left:.0001pt;text-align:justify;">参数5：激活函数</p> 
<p style="margin-left:.0001pt;text-align:justify;">参数6：输出数据的形状</p> 
<h3 style="margin-left:.0001pt;text-align:justify;">2.4<strong>将二维卷积层应用于图像数组，打印卷积后的张量大小</strong></h3> 
<pre><code class="language-python">img_after_conv = conv(imgs)
print('卷积后的张量大小：',img_after_conv.shape)

</code></pre> 
<h5>运行结果：</h5> 
<p><img alt="" height="39" src="https://images2.imgbox.com/7b/25/IOjOOinL_o.png" width="692"></p> 
<h3 style="text-align:justify;"><strong>2.5 汇聚层</strong></h3> 
<h4 style="text-align:justify;"><strong>2.5.1应用最大池化层到卷积后的图像数据，减少数据维度，打印处理后的图像数据的形状</strong></h4> 
<h5 style="text-align:justify;"><strong>定义了一个最大池化层</strong><strong>，参数为：指定了池化窗口的大小</strong></h5> 
<pre><code class="language-python">pool_max = keras.layers.MaxPool2D(pool_size = 2)</code></pre> 
<h5 style="text-align:justify;"><strong>将最大池化层应用到卷积后的图像数据</strong></h5> 
<pre><code class="language-python">img_after_pool_max = pool_max(img_after_conv)

print('最大汇聚后的张量大小：',img_after_pool_max.shape)</code></pre> 
<h5 style="text-align:justify;"><strong>运行结果：</strong></h5> 
<p><img alt="" height="45" src="https://images2.imgbox.com/00/9b/Y8cu7MGH_o.png" width="643"></p> 
<h3 style="text-align:justify;"><strong>2.6 </strong><strong>平均汇聚</strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">和汇聚层操作过程一样，使用的方法不一样</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">keras.layers.AvgPool2D</span></p> 
<h5 style="text-align:justify;"><strong>运行结果：</strong></h5> 
<p><img alt="" height="49" src="https://images2.imgbox.com/d4/48/C7JLu09i_o.png" width="577"></p> 
<h3 style="text-align:justify;"><strong>2.7 全局平均汇聚</strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">和汇聚层操作过程一样，使用的方法不一样</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"> keras.layers.GlobalAvgPool2D</span></p> 
<h5 style="text-align:justify;"><strong>运行结果：</strong></h5> 
<p><img alt="" height="49" src="https://images2.imgbox.com/8d/48/DE1jakVv_o.png" width="513"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50269b9571b3c2e308e6453a23d82332/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从零手写实现 nginx-04-基于 netty http 出入参优化处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5672792b2872a7275d9510f59a69c786/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ消息的发布确认机制详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>