<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构与算法】堆排序算法原理与实现：基于堆实现的高效排序算法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5efb6cef4068c25ed5ca5658b6b7b776/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构与算法】堆排序算法原理与实现：基于堆实现的高效排序算法">
  <meta property="og:description" content="💓 博客主页：倔强的石头的CSDN主页 📝Gitee主页：倔强的石头的gitee主页
⏩ 文章专栏：《数据结构与算法》
期待您的关注
​
目录
一、引言
堆排序的简介
堆排序的特点
二、堆的概念
三、堆排序算法的原理
四、堆排序的步骤
🍃构建堆 🍃交换与调整
🍃重复过程
五、堆排序的性能分析
🍃时间复杂度：
🍃空间复杂度：
六、示例代码
七、总结
一、引言 堆排序的简介 堆排序（Heap Sort）是一种基于堆数据结构实现的排序算法。利用堆这种数据结构的高效性，通过构建和调整堆来实现排序，是一种性能优秀的排序算法。
堆排序的特点 时间复杂度：堆排序的最坏、最好、平均时间复杂度均为O(nlogn)，其中n是待排序元素的数量。稳定性：堆排序在排序过程中相等的元素不会交换位置，因此它是稳定的排序算法。选择排序：堆排序是一种选择排序，它总是选择当前未排序部分的最大（或最小）元素进行排序。 二、堆的概念 关于堆的详细介绍，参考前置文章
【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客
三、堆排序算法的原理 堆排序的基本思想是将待排序的序列构建成一个堆，然后依次将堆顶元素与堆尾元素交换，并将堆的大小减小1，再对剩余的堆进行调整，使其满足堆的性质。重复这个过程，直到堆的大小为1，此时排序完成。 四、堆排序的步骤 🍃构建堆 借助建堆算法，降序建小堆，升序建大堆，可以选择向上或者向下调整算法
向上调整建堆的原理：
模仿堆的插入操作来构建堆，从第一个子结点开始，将它看做是新插入的元素，向上调整至满足堆的性质，然后依次往后走，直到最后一个叶子节点完成上述调整
向下调整建堆的原理：
从最后一个父结点开始，先保证它和左右子树成为堆，然后依次往前走，保证每个父结点与左右子树成堆，直到最后根结点与左右子树成堆
关于建堆的向上调整算法和向下调整算法有时间复杂度推导
限于篇幅，这里就不展开推导了，直接给出结论
向下调整建堆的时间复杂度为O（N）向上调整算法的时间复杂度为O（n*logN） 向下调整算法优于向上调整，所以应该选择向下调整算法
这里分别给出向下调整建小堆和向下调整建大堆的算法
（如果关于向上调整算法和向下调整算法有疑惑，建议了解完堆的这篇文章之后再来看
【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客）
void Adjustdownsmall(DataType* a, int parent, int size)//向下调整建小堆算法 { int child = parent * 2 &#43; 1;//先假定左孩子小 while (child &lt; size)//循环条件是未调整至叶子节点 { if (child &#43; 1 &lt; size &amp;&amp; a[child &#43; 1] &lt; a[child])//如果右孩子存在且更小，改变为右孩子 child&#43;&#43;; if (a[child] &lt; a[parent])//如果子节点小于父节点，交换位置 { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 &#43; 1; } else break; } } void Adjustdownbig(DataType* a, int parent, int size)//向下调整建大堆算法 { int child = parent * 2 &#43; 1;//先假定左孩子大 while (child &lt; size)//循环条件是未调整至叶子节点 { if (child &#43; 1 &lt; size &amp;&amp; a[child &#43; 1] &gt; a[child])//如果右孩子存在且更大，改变为右孩子 child&#43;&#43;; if (a[child] &gt; a[parent])//如果子节点大于父节点，交换位置 { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 &#43; 1; } else break; } } 🍃交换与调整 建堆之后，就是排序">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-02T11:38:07+08:00">
    <meta property="article:modified_time" content="2024-07-02T11:38:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构与算法】堆排序算法原理与实现：基于堆实现的高效排序算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>   </p> 
 <p>        <strong>    💓 博客主页：<strong><strong><strong><a href="https://blog.csdn.net/2302_78391795?type=blog" title="倔强的石头的CSDN主页">倔强的石头的CSDN主页</a></strong></strong></strong> </strong></p> 
 <p><strong>           📝Gitee主页：<strong><strong><strong><a href="https://gitee.com/xing-shichuang" rel="nofollow" title="倔强的石头的gitee主页">倔强的石头的gitee主页</a></strong></strong></strong></strong></p> 
 <p><strong>            ⏩ 文章专栏：<strong><strong><strong><a href="https://blog.csdn.net/2302_78391795/category_12527598.html?spm=1001.2014.3001.5482" title="《数据结构与算法》">《数据结构与算法》</a></strong></strong></strong></strong></p> 
 <p><strong>                                  期待您的关注</strong></p> 
 <p> </p> 
 <p><img src="https://images2.imgbox.com/b1/e0/3f2Vs4x7_o.gif" alt="1b7335aca73b41609b7f05d1d366f476.gif">​</p> 
 <p> </p> 
</blockquote> 
<p><strong>目录</strong></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80" rel="nofollow">一、引言</a></p> 
<p style="margin-left:80px;"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%80%E4%BB%8B" rel="nofollow">堆排序的简介</a></p> 
<p style="margin-left:80px;"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">堆排序的特点</a></p> 
<p style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">二、堆的概念</a></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">三、堆排序算法的原理</a></p> 
<p style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4" rel="nofollow">四、堆排序的步骤</a></p> 
<p style="margin-left:80px;"><a href="#%F0%9F%8D%83%E5%85%A5%E6%A0%88" rel="nofollow">🍃构建堆 </a></p> 
<p style="margin-left:80px;"><a href="#%F0%9F%8D%83%E5%85%A5%E6%A0%88" rel="nofollow">🍃交换与调整</a></p> 
<p style="margin-left:80px;"><a href="#%F0%9F%8D%83%E5%85%A5%E6%A0%88" rel="nofollow">🍃重复过程</a></p> 
<p style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" rel="nofollow">五、堆排序的性能分析</a></p> 
<p style="margin-left:80px;"><a href="#%F0%9F%8D%83%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A" rel="nofollow">🍃时间复杂度：</a></p> 
<p style="margin-left:80px;"><a href="#%F0%9F%8D%83%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A" rel="nofollow">🍃空间复杂度：</a></p> 
<p style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" rel="nofollow">六、示例代码</a></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">七、总结</a></p> 
<hr> 
<p> </p> 
<h3><strong>一、引言</strong></h3> 
<h4><strong>堆排序的简介</strong></h4> 
<blockquote> 
 <p>堆排序（Heap Sort）是一种基于堆数据结构实现的排序算法。利用堆这种数据结构的高效性，通过构建和调整堆来实现排序，是一种性能优秀的排序算法。</p> 
</blockquote> 
<h4><strong>堆排序的特点</strong></h4> 
<blockquote> 
 <ol><li><strong>时间复杂度</strong>：堆排序的最坏、最好、平均时间复杂度均为O(nlogn)，其中n是待排序元素的数量。</li><li><strong>稳定性</strong>：堆排序在排序过程中相等的元素不会交换位置，因此它是稳定的排序算法。</li><li><strong>选择排序</strong>：堆排序是一种选择排序，它总是选择当前未排序部分的最大（或最小）元素进行排序。</li></ol> 
</blockquote> 
<p> </p> 
<h3><strong>二、堆的概念</strong></h3> 
<blockquote> 
 <p><strong>关于堆的详细介绍，参考前置文章</strong></p> 
 <p><strong><a href="https://blog.csdn.net/2302_78391795/article/details/139664921" title="【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客">【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客</a></strong></p> 
</blockquote> 
<p> </p> 
<h3><strong>三、堆排序算法的原理</strong></h3> 
<blockquote> 
 <ul><li><strong>堆排序的基本思想是将待排序的序列构建成一个堆，然后依次将堆顶元素与堆尾元素交换，并将堆的大小减小1，再对剩余的堆进行调整，使其满足堆的性质。</strong></li><li><strong>重复这个过程，直到堆的大小为1，此时排序完成。 </strong></li></ul> 
</blockquote> 
<h3>四、堆排序的步骤</h3> 
<h4>🍃构建堆 </h4> 
<blockquote> 
 <p><strong>借助建堆算法，降序建小堆，升序建大堆，可以选择向上或者向下调整算法</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>向上调整建堆的原理：</strong><br> 模仿堆的插入操作来构建堆，从第一个子结点开始，将它看做是新插入的元素，向上调整至满足堆的性质，然后依次往后走，直到最后一个叶子节点完成上述调整</p> 
 <p><strong>向下调整建堆的原理：</strong><br> 从最后一个父结点开始，先保证它和左右子树成为堆，然后依次往前走，保证每个父结点与左右子树成堆，直到最后根结点与左右子树成堆</p> 
 <p> </p> 
 <p>关于建堆的向上调整算法和向下调整算法有时间复杂度推导</p> 
 <p>限于篇幅，这里就不展开推导了，直接给出结论</p> 
 <ul><li>向下调整建堆的时间复杂度为O（N）</li><li>向上调整算法的时间复杂度为O（n*logN）</li></ul> 
 <p><strong>向下调整算法优于向上调整，所以应该选择向下调整算法</strong></p> 
</blockquote> 
<p><strong> 这里分别给出向下调整建小堆和向下调整建大堆的算法</strong></p> 
<p><strong>（如果关于向上调整算法和向下调整算法有疑惑，建议了解完堆的这篇文章之后再来看</strong></p> 
<p><strong><a href="https://blog.csdn.net/2302_78391795/article/details/139664921" title="【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客">【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客</a>）</strong></p> 
<pre><code class="language-cpp">void Adjustdownsmall(DataType* a, int parent, int size)//向下调整建小堆算法
{
	
	int child = parent * 2 + 1;//先假定左孩子小
	while (child &lt; size)//循环条件是未调整至叶子节点
	{
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])//如果右孩子存在且更小，改变为右孩子
			child++;
		if (a[child] &lt; a[parent])//如果子节点小于父节点，交换位置
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
			break;
	}
}
void Adjustdownbig(DataType* a, int parent, int size)//向下调整建大堆算法
{
	
	int child = parent * 2 + 1;//先假定左孩子大
	while (child &lt; size)//循环条件是未调整至叶子节点
	{
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])//如果右孩子存在且更大，改变为右孩子
			child++;
		if (a[child] &gt; a[parent])//如果子节点大于父节点，交换位置
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
			break;
	}
}</code></pre> 
<p><br>  </p> 
<h4>🍃交换与调整</h4> 
<blockquote> 
 <p>建堆之后，就是排序<br> 以降序为例，每次将堆顶与堆尾数据交换（相当于将当前的最小值挪到最后），然后堆尾数据伪删除（有效数据个数--，不是真删除）进行一轮向下调整，恢复堆的结构</p> 
 <p> </p> 
</blockquote> 
<pre><code class="language-cpp">Swap(&amp;a[0], &amp;a[end]);//交换堆顶和堆尾数据
end--;
Adjustdownsmall(a, 0, end);//向下调整恢复堆的结构</code></pre> 
<p> <img src="https://images2.imgbox.com/08/76/JHWXlgqP_o.png" alt="9b7e5cb844404312a312e019bae3b8bd.png"></p> 
<p> </p> 
<h4>🍃重复过程</h4> 
<blockquote> 
 <p> 重复上述交换与调整的过程，直到堆的大小为1，此时排序完成。</p> 
</blockquote> 
<p> </p> 
<h3><strong>五、堆排序的性能分析</strong></h3> 
<h4>🍃时间复杂度：</h4> 
<blockquote> 
 <ol><li><strong>建堆</strong>：对于长度为n的数组，建堆的时间复杂度为O(n)。这是因为建堆的过程中，元素需要逐个从数组尾部加入到堆中，并重新调整堆的结构以维持其性质。每个元素加入堆中最多会触发从该元素到根节点的路径上元素的重新调整，因此，平均而言，每个元素会触发O(log n)次调整。所以，建堆的总时间复杂度为O(n *log n)。但是，由于建堆的过程是线性的（从最后一个非叶子节点开始，逐个向上调整），所以实际的时间复杂度为O(n)。</li><li><strong>排序</strong>：在排序阶段，每次从堆顶取出最大（或最小）元素，并重新调整堆结构的时间复杂度为O(log n)。因为需要排序n个元素，所以排序阶段的时间复杂度为O(n *log n)。</li></ol> 
 <p>综上，<strong>堆排序的总时间复杂度为O(n) + O(n *log n) = O(n *log n)。</strong></p> 
</blockquote> 
<p> </p> 
<h4>🍃空间复杂度：</h4> 
<blockquote> 
 <p><strong>堆排序的空间复杂度为O(1)。</strong>这是因为堆排序是原地排序算法，它只需要常数个额外的空间来存储临时变量，而不需要额外的存储空间来存储待排序的数组。所有的操作都是直接在原数组上进行的。所以，堆排序的空间复杂度非常低。</p> 
</blockquote> 
<h3><strong>六、示例代码</strong></h3> 
<p><strong>（分别给出了完整的降序排序算法和升序排序算法）</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#if 1
//堆排序
typedef int DataType;
void Swap(DataType* a, DataType* b)
{
	DataType tmp = *a;
	*a = *b;
	*b = tmp;
}
void Adjustdownsmall(DataType* a, int parent, int size)//向下调整建小堆算法
{
	
	int child = parent * 2 + 1;//先假定左孩子小
	while (child &lt; size)//循环条件是未调整至叶子节点
	{
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])//如果右孩子存在且更小，改变为右孩子
			child++;
		if (a[child] &lt; a[parent])//如果子节点小于父节点，交换位置
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
			break;
	}
}
void Adjustdownbig(DataType* a, int parent, int size)//向下调整建大堆算法
{
	
	int child = parent * 2 + 1;//先假定左孩子大
	while (child &lt; size)//循环条件是未调整至叶子节点
	{
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])//如果右孩子存在且更大，改变为右孩子
			child++;
		if (a[child] &gt; a[parent])//如果子节点大于父节点，交换位置
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
			break;
	}
}

void HeapSortDOrder(DataType* a,int size)//降序排序
{
	
	//向下调整建小堆
	for (int i = (size - 2) / 2; i &gt;= 0; i--)//从最后一个父节点调整
	{
		Adjustdownsmall(a, i, size);
	}
	int end = size - 1;
	while (end&gt;0)
	{
		Swap(&amp;a[0], &amp;a[end]);//交换堆顶和堆尾数据
		end--;
		Adjustdownsmall(a, 0, end);//向下调整恢复堆的结构
	}
}
void HeapSortAOrder(DataType* a, int size)//升序排序
{

	//向下调整建大堆
	for (int i = (size - 2) / 2; i &gt;= 0; i--)//从最后一个父节点调整
	{
		Adjustdownbig(a, i, size);
	}
	int end = size - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);//交换堆顶和堆尾数据
		end--;
		Adjustdownbig(a, 0, end);//向下调整恢复堆的结构
	}
}
#endif

void print(DataType* a, int size)
{
	for (int i = 0; i &lt; size; i++)
	{
		printf("%d ", a[i]);
	}
	printf("\n");
}
int main()
{
	int arr[] = { 12,3,5,78,46,15,23,19,20,36,52 };
	int size = sizeof(arr) / sizeof(arr[0]);
	HeapSortDOrder(arr, size);//降序
	print(arr, size);
	HeapSortAOrder(arr, size);//升序
	print(arr, size);

}</code></pre> 
<p> <img src="https://images2.imgbox.com/78/08/IQhZdAzk_o.png" alt="27c88bb4be3d4b43beb24363a0fd02ae.png"></p> 
<h3><strong>七、总结</strong></h3> 
<blockquote> 
 <p>堆排序算法是一种高效且实用的排序算法，它通过利用堆数据结构的特点和性质，实现了对数据的高效排序。在实际应用中，我们可以根据问题的特点选择使用堆排序算法，以提高程序的性能和效率。</p> 
</blockquote> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/356c588977773abeb386d756e59cf297/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI 入门：Kimi 详细使用手册，Kimi 使用效率提升 60%（附 16 个高阶提示词）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d913649b2a2230b4100478ee5d948c44/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【TS】TypeScript 入门指南：强大的JavaScript超集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>