<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>​数据结构之初始二叉树（3） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4915465bba0322f0496683d610ca35d7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="​数据结构之初始二叉树（3）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
二叉树的基本操作
通过上篇文章的学习，我们简单的了解了二叉树的相关操作。接下来就是有关二叉树的经典题型练习。
递归相关的题目都有一个套路：例如：确定一个节点要做的事情，其余的套框架，递归就行了。下面我们就来细细品味。 目录
100. 相同的树
572. 另一棵树的子树
226. 翻转二叉树
101. 对称二叉树
110. 平衡二叉树
牛客网——JZ36 二叉搜索树与双向链表
牛客网——KY11 二叉树遍历
100. 相同的树 题目：
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
示例 1：
输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2：
输入：p = [1,2], q = [1,null,2] 输出：false 示例 3：
输入：p = [1,2,1], q = [1,1,2] 输出：false 提示：
两棵树上的节点数目都在范围 [0, 100] 内-104 &lt;= Node.val &lt;= 104 思路： 按照上面的套路，我们应该找到一个节点所做的事情，即判断这个节点是否相同。
if (p.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T08:34:25+08:00">
    <meta property="article:modified_time" content="2024-07-20T08:34:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">​数据结构之初始二叉树（3）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><strong><strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></strong></strong></p> 
</blockquote> 
<p><a href="https://blog.csdn.net/2301_80854132/article/details/140419482?spm=1001.2014.3001.5502" title="二叉树的基本操作">二叉树的基本操作</a></p> 
<p>通过上篇文章的学习，我们简单的了解了二叉树的相关操作。接下来就是有关二叉树的经典题型练习。</p> 
<p>递归相关的题目都有一个套路：例如：确定一个节点要做的事情，其余的套框架，递归就行了。下面我们就来细细品味。 </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91-toc" style="margin-left:0px;"><a href="#100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91" rel="nofollow">100. 相同的树</a></p> 
<p id="572.%20%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91-toc" style="margin-left:0px;"><a href="#572.%20%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91" rel="nofollow">572. 另一棵树的子树</a></p> 
<p id="226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">226. 翻转二叉树</a></p> 
<p id="101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">101. 对称二叉树</a></p> 
<p id="110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">110. 平衡二叉树</a></p> 
<p id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94JZ36%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94JZ36%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow">牛客网——JZ36 二叉搜索树与双向链表</a></p> 
<p id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94KY11%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94KY11%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86" rel="nofollow">牛客网——KY11 二叉树遍历</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><a class="link-info" href="https://leetcode.cn/problems/same-tree/description/" rel="nofollow" title="100. 相同的树">100. 相同的树</a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p> 
 <p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="182" src="https://images2.imgbox.com/f8/cd/rQxpDHIx_o.jpg" width="622"></p> 
 <pre><strong>输入：</strong>p = [1,2,3], q = [1,2,3]
<strong>输出：</strong>true
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="182" src="https://images2.imgbox.com/e9/9f/9GKqan6E_o.jpg" width="382"></p> 
 <pre><strong>输入：</strong>p = [1,2], q = [1,null,2]
<strong>输出：</strong>false
</pre> 
 <p><strong>示例 3：</strong></p> 
 <p class="img-center"><img alt="" height="182" src="https://images2.imgbox.com/6d/4f/3QEjaALW_o.jpg" width="622"></p> 
 <pre><strong>输入：</strong>p = [1,2,1], q = [1,1,2]
<strong>输出：</strong>false

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul> 
</blockquote> 
<p>思路： 按照上面的套路，我们应该找到一个节点所做的事情，即判断这个节点是否相同。</p> 
<pre><code class="language-java">if (p.val != q.val) {
    return false;
}</code></pre> 
<p>上面这个代码的确是我们判读判断的逻辑，但是还要注意 p 和 q 可能出现为 null 的情况。因此还要排除，并且当两者同时为 null 时，我们要返回 true。因为空树也是相同的树。</p> 
<pre><code class="language-java">// 一个是空树，一个不是，不符合
if (p == null &amp;&amp; q != null || p != null &amp;&amp; q == null) {
    return false;
}
// 两个都是空树，符合
if (p == null &amp;&amp; q == null) {
    return true;
}
</code></pre> 
<p>一个节点的事情处理完了，就该开始套框架，递归了。我们先不看框架，这个方法处理的是一个节点的（可以理解为根结点），接下来就要开始处理左子树和右子树。也就是递归处理。</p> 
<pre><code class="language-java">//             判断左子树                   判断右子树
return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</code></pre> 
<p>只有当左右子树和根都为true时，才能返回true。</p> 
<p>思路整理完成就可以实现全部的代码了。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // 根结点的判断
        if (p == null &amp;&amp; q != null || p != null &amp;&amp; q == null) {
            return false;
        }
        if (p == null &amp;&amp; q == null) {
            return true;
        }
        if (p.val != q.val) {
            return false;
        }
        // 左右子树的判断
        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
    }
}</code></pre> 
<p>注意：如果我们是在不放心这个方法，那么写完之后，就可以检查这个方法内容是否满足递归的两个条件：1、存在限制条件；2、每次递归之后都将进一步接近这个条件。</p> 
<p>限制条件：就是什么时候，这个递归将会停止。很明显，当遇到空树时，就可以停止了，因为空树没有左右子树了。我们上面的代码满足这个条件，遇到空树就会返回。</p> 
<p>随着递归的深入，我们会很明显的发现越来越接近限制条件。 </p> 
<p>怎么样？是不是觉得这个方法非常的好用？是不是觉得自己现在强的可怕？别担心，下面还有很多硬菜等着我们去品尝，慢慢来吧。</p> 
<h2 id="572.%20%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><a class="link-info" href="https://leetcode.cn/problems/subtree-of-another-tree/description/" rel="nofollow" title="572. 另一棵树的子树">572. 另一棵树的子树</a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p> 
 <p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/fd/bd/XU26Chmk_o.jpg" width="532"></p> 
 <pre><strong>输入：</strong>root = [3,4,5,1,2], subRoot = [4,1,2]
<strong>输出：</strong>true
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="458" src="https://images2.imgbox.com/63/2a/ELE5FR7M_o.jpg" width="502"></p> 
 <pre><strong>输入：</strong>root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
<strong>输出：</strong>false

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li><li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li><li><code>-104 &lt;= root.val &lt;= 104</code></li><li><code>-104 &lt;= subRoot.val &lt;= 104</code></li></ul> 
</blockquote> 
<p>思路：判断一棵树是否为另一棵树的子树，换句话说，就是看一棵树中是否有子树和另一棵树相同。可以理解为上一题的变形版。同样，先明确根结点要做的事情，判断根结点所在的树是否与另一颗相同，另外就是套框架，递归根结点的左子树、右子树，看是否与另一个子树相同</p> 
<p>根结点做的事情：</p> 
<pre><code class="language-java">// 根结点为空，直接不需要比较了，这个也是限制条件
if (root == null) {
    return false;
}
// 判断根结点所在的子树是否另一棵子树相同
if (isSameTree(root, subRoot)) {
    return true;
}</code></pre> 
<p>框架：</p> 
<pre><code class="language-java">// 左子树相同了，就不需要比较了
if (isSubtree(root.left, subRoot)) {
    return true;
}
// 不管右子树的比较结果如何，都可以直接返回了
return isSubtree(root.right, subRoot);</code></pre> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {    
        // 判断是否存在root的子树和subRoot是相同的树

        // 限制条件：什么时候可以停止递归了？root为null了，找不到了
        if (root == null) {
            return false;
        }
        // 先判断根结点
        if (isSameTree(root, subRoot)) {
            return true;
        }
        // 递归判断左子树
        if (isSubtree(root.left, subRoot)) {
            return true;
        }
        // 递归判断右子树
            return isSubtree(root.right, subRoot);
    }

    // 判断这两颗树是否相同
    private boolean isSameTree(TreeNode root, TreeNode subRoot) {
        // 根 左子树 右子树
        if (root == null &amp;&amp; subRoot != null || root != null &amp;&amp; subRoot == null) {
            return false;
        }
        if (root == null &amp;&amp; subRoot == null) {
            return true;
        }
        if (subRoot.val != root.val) {
            return false;
        }
        // 递归判断左子树 &amp;&amp; 递归判断右子树
        return isSameTree(root.left, subRoot.left) &amp;&amp; isSameTree(root.right, subRoot.right);
    }
}</code></pre> 
<h2 id="226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><a class="link-info" href="https://leetcode.cn/problems/invert-binary-tree/description/" rel="nofollow" title="226. 翻转二叉树">226. 翻转二叉树</a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/fc/86/K4cfTGSG_o.jpg" width="911"></p> 
 <pre><strong>输入：</strong>root = [4,2,7,1,3,6,9]
<strong>输出：</strong>[4,7,2,9,6,3,1]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="182" src="https://images2.imgbox.com/6f/f4/bzauqyUS_o.jpg" width="761"></p> 
 <pre><strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>[2,3,1]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul> 
</blockquote> 
<p>思路一：翻转二叉树就是将每个结点的左子树和右子树都进行交换。</p> 
<p>根结点做的事情：</p> 
<p>交换根的左子树和根的右子树。</p> 
<pre><code class="language-java">// 空节点不需要交换
if (root == null) {
    return root;
}
// 交换
TreeNode tmp = root.left;
root.left = root.right;
root.right = tmp;</code></pre> 
<p>框架：</p> 
<pre><code class="language-java">// 根的左子树 和 根的右子树
invertTree(root.left);
invertTree(root.right);</code></pre> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        // 先翻转根结点
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        // 翻转左子树
        invertTree(root.left);
        // 翻转右子树
        invertTree(root.right);
        return root;
    }
}</code></pre> 
<p>其实，如果我们仔细观察会发现，叶子结点是不需要交换的，因为叶子结点的左子树和右子树都是空，交换前后不变。</p> 
<pre><code class="language-java">if (root.left == null &amp;&amp; root.right == null) {
    return root;
}</code></pre> 
<p>注意：虽然我们的限制条件改成了叶子结点，但是root 判空的语句还是得有，因为测试用例的root可能为null。</p> 
<p>思路二：上面的思路是从根结点开始进行交换，但是进行左右子树交换时，并没有用到其返回值，因此，这个思路就是先从根的左子树和右子树开始交换，交换的结果储存起来，再去交换根的左右子树。</p> 
<p>根结点做的事情：</p> 
<pre><code class="language-java">if (root == null) {
    return root;
}
// 叶子结点直接返回即可
if (root.left == null &amp;&amp; root.right == null) {
    return root;
}
// 根的左子树和右子树进行了递归翻转
.......   
     
// 开始交换本级根的左子树和右子树
root.left = rightTree;
root.right = leftTree;</code></pre> 
<p> 框架：</p> 
<pre><code class="language-java">// 翻转左子树的结果
TreeNode leftTree = invertTree(root.left);
// 翻转右子树的结果
TreeNode rightTree = invertTree(root.right);</code></pre> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        // 叶子结点直接返回即可
        if (root.left == null &amp;&amp; root.right == null) {
            return root;
        }
        // 翻转左子树的结果
        TreeNode leftTree = invertTree(root.left);
        // 翻转右子树的结果
        TreeNode rightTree = invertTree(root.right);
        // 开始交换本级根的左子树和右子树
        root.left = rightTree;
        root.right = leftTree;
        return root;
    }
}</code></pre> 
<h2 id="101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><a class="link-info" href="https://leetcode.cn/problems/symmetric-tree/description/" rel="nofollow" title="101. 对称二叉树">101. 对称二叉树</a></h2> 
<p> 题目：</p> 
<blockquote> 
 <p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="291" src="https://images2.imgbox.com/88/aa/AsGn6Q36_o.png" width="354"></p> 
 <pre><strong>输入：</strong>root = [1,2,2,3,4,4,3]
<strong>输出：</strong>true
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="258" src="https://images2.imgbox.com/bf/cc/8nCzxI7s_o.png" width="308"></p> 
 <pre><strong>输入：</strong>root = [1,2,2,null,3,null,3]
<strong>输出：</strong>false

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul> 
</blockquote> 
<p>思路：判断是否为对称二叉树其实就是看这个根结点的左右子树是否可以翻转。那么这个题目就变成了判断根的左右子树是可以翻转</p> 
<pre><code class="language-java">public boolean isSymmetric(TreeNode root) {
    // 比较根结点的左子树和右子树
    return invertTree(root.left, root.right);
}</code></pre> 
<p>根结点做的事情：（节点是否相同）</p> 
<pre><code class="language-java">if (left == null &amp;&amp; right != null || left != null &amp;&amp; right == null) {
    return false;
}
if (left == null &amp;&amp; right == null) {
    return true;
}
if (left.val != right.val) {
    return false;
}</code></pre> 
<p>框架：</p> 
<pre><code class="language-java">//                 最外围是否可以翻转             、    内围是否可以翻转
return invertTree(left.left, right.right) &amp;&amp; invertTree(left.right, right.left);</code></pre> 
<p> 代码实现：</p> 
<pre><code class="language-java">class Solution {
    public boolean isSymmetric(TreeNode root) {
        // 比较根结点的左子树和右子树
        return invertTree(root.left, root.right);
    }

    // 就是比较对应结点的值是否一样
    public boolean invertTree(TreeNode left, TreeNode right) {
        if (left != null &amp;&amp; right == null || left == null &amp;&amp; right != null) {
            return false;
        }
        if (left == null &amp;&amp; right == null) {
            return true;
        }
        if (left.val != right.val) {
            return false;
        }
        return invertTree(left.left, right.right) &amp;&amp; invertTree(left.right, right.left); 
    }
}</code></pre> 
<h2 id="110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><a class="link-info" href="https://leetcode.cn/problems/balanced-binary-tree/submissions/547594771/" rel="nofollow" title="110. 平衡二叉树">110. 平衡二叉树</a></h2> 
<blockquote> 
 <p>给定一个二叉树，判断它是否是 平衡二叉树  </p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="221" src="https://images2.imgbox.com/e5/73/4SlyUTOM_o.jpg" width="342"></p> 
 <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>true
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/e2/0b/ZjG36fkp_o.jpg" width="452"></p> 
 <pre><strong>输入：</strong>root = [1,2,2,3,3,null,null,4,4]
<strong>输出：</strong>false
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>root = []
<strong>输出：</strong>true

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul> 
</blockquote> 
<p>首先得明确一个概念：什么是平衡二叉树。 </p> 
<p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的深度相差不超过 1。  </p> 
<p>注意：是所有结点的左右子树，而不是根结点的左右子树。</p> 
<p>思路：我们首先想到的就是求树的高度，然后相减判断差值是否大于1。</p> 
<p>根结点做的事情：先判断根结点是不是平衡二叉树</p> 
<pre><code class="language-java">    // 限制条件
    if (root == null) {
            return true;
        }
    // 这个判断的是根结点
    if (Math.abs(TreeNodeHigh(root.left) - TreeNodeHigh(root.right)) &gt; 1) {
        return false;
    }</code></pre> 
<p>框架：根结点判断完成再判断左右子树是否是平衡二叉树</p> 
<pre><code class="language-java">        // 递归判断左子树和右子树
        if (!isBalanced(root.left)) {
            return false;
        }
        return isBalanced(root.right);</code></pre> 
<p>计算树的高度：</p> 
<pre><code class="language-java">    // 计算二叉树的高度
    private int TreeNodeHigh(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 左子树的高度
        int leftHigh = TreeNodeHigh(root.left);
        // 右子树的高度
        int rightHigh = TreeNodeHigh(root.right);
        // 返回左子树和右子树的最大高度+根结点
        return Math.max(leftHigh, rightHigh)+1;
    }</code></pre> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    // 这个方法是用来判断一个二叉树是否为平衡二叉树的
    // 而我们想要的是一个方法来计算这个二叉树的根结点的左右子树高度
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 这个判断的是根结点
        if (Math.abs(TreeNodeHigh(root.left) - TreeNodeHigh(root.right)) &gt; 1) {
            return false;
        }
        // 递归判断左子树和右子树
        if (!isBalanced(root.left)) {
            return false;
        }
        return isBalanced(root.right);
    }
    // 计算二叉树的高度
    private int TreeNodeHigh(TreeNode root) {
        if (root == null) {
            return 0;
        }
        // 左子树的高度
        int leftHigh = TreeNodeHigh(root.left);
        // 右子树的高度
        int rightHigh = TreeNodeHigh(root.right);
        // 返回左子树和右子树的最大高度+根结点
        return Math.max(leftHigh, rightHigh)+1;
    }
}</code></pre> 
<p>上述代码有不足的地方：重复计算比较多。当根结点是平衡二叉树时，就需要计算根结点左子树的左右子树的高度，而这部分的高度是我们在第一次计算时，就已经计算过了。因此我们就可以保留上一次计算的值，也就是存起来或者说记录上次计算的值，看看满不满足我们的要求。如下所示：</p> 
<p><img alt="" height="795" src="https://images2.imgbox.com/f6/d8/AhHdNjAs_o.png" width="1200"></p> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 因为返回值就三种：&lt;0 ==0 &gt;0 最后就比较看是否符合情况
        return TreeNodeHigh(root) &gt;= 0;
    }

    private int TreeNodeHigh(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHigh = TreeNodeHigh(root.left);
        // 如果不符合要求了，就返回-1（标记）
        if (leftHigh &lt; 0) {
            return -1;
        }
        int rightHigh = TreeNodeHigh(root.right);
        // 符合要求(高度差符合平衡二叉树且右边的高度大于0)就返回高度
        if (rightHigh &gt;= 0 &amp;&amp; Math.abs(leftHigh - rightHigh) &lt;= 1) {
            return Math.max(leftHigh, rightHigh) + 1 ;
        } else {
            // 不符合（高度差大于1或者右边的高度也是负数）就返回-1
            return -1;
        }
    }
}</code></pre> 
<p>这种方法还是大佬才能想到的。我们一般把第一种的普通递归思路写出来就行。 </p> 
<h2 id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94JZ36%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><a class="link-info" href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;ru=/exam/oj" rel="nofollow" title="牛客网——JZ36 二叉搜索树与双向链表">牛客网——JZ36 二叉搜索树与双向链表</a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>描述</p> 
 <p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p> 
 <p></p> 
 <p class="img-center"><img alt="" height="572" src="https://images2.imgbox.com/03/5f/gS1TcKcT_o.png" width="1200"></p> 
 <p></p> 
 <p>数据范围：输入二叉树的节点数 0≤𝑛≤10000≤n≤1000，二叉树中每个节点的值 0≤𝑣𝑎𝑙≤10000≤val≤1000<br> 要求：空间复杂度𝑂(1)O(1)（即在原树上操作），时间复杂度 𝑂(𝑛)O(n)</p> 
 <p></p> 
 <p>注意:</p> 
 <p>1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继<br> 2.返回链表中的第一个节点的指针<br> 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构</p> 
 <p>4.你不用输出双向链表，程序会根据你的返回值自动打印输出</p> 
 <p>输入描述：</p> 
 <p>二叉树的根节点</p> 
 <p>返回值描述：</p> 
 <p>双向链表的其中一个头节点。</p> 
 <p>示例1</p> 
 <p>输入：</p> 
 <pre>{10,6,14,4,8,12,16}</pre> 
 <p>返回值：</p> 
 <pre>From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;</pre> 
 <p>说明：</p> 
 <pre>输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。     </pre> 
 <p>示例2</p> 
 <p>输入：</p> 
 <pre>{5,4,#,3,#,2,#,1}</pre> 
 <p>返回值：</p> 
 <pre>From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;</pre> 
 <p>说明：</p> 
 <pre>                    5
                  /
                4
              /
            3
          /
        2
      /
    1
树的形状如上图       
</pre> 
</blockquote> 
<p>二叉搜索树的概念：树上每个节点的左子树的根结点的值小于根结点的值小于右子树的根结点的值。因此，当我们去用中序遍历去遍历这棵树时，其输出的结果的就是一个有序的数据。</p> 
<p>思路：既然是要变成一个有序的双向链表，那么我们就可以从这里得出一些有用的信息。肯定是以中序遍历的方式去遍历这棵二叉树。修改的话，以 left 作为 prev 指针，以 right 作为 next 指针。那么我们就可以写一个二叉树中序遍历的方法出来，通过中序遍历来修改二叉树的指向。</p> 
<p>下面是递归的核心代码： </p> 
<pre><code class="language-java">    // 中序遍历修改二叉树的指向
    private void inOrder(TreeNode root) {
        // 左子树 根 右子树
        if (root == null) { // 限制条件
            return;
        }
        // 左子树
        inOrder(root.left);

        // 修改根结点的指向
        ......

        // 右子树
        inOrder(root.right);
    } </code></pre> 
<p>当 root 走到 4 这个节点时（上面描述的图），就可以修改其 left 与 right 的值，因为这里需要一个不断变化的值来指向 left 和 right 要修改的对象，因此就可以定义一个 prev 指针来指向要修改的前一个节点，那么就可以解决修改指针的问题。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">public class Solution {
    private TreeNode prev; // 默认是null
    public TreeNode Convert(TreeNode pRootOfTree) {
        if (pRootOfTree == null) {
            return null;
        }
        // 修改二叉树为有序的双向链表
        inOrder(pRootOfTree);
        // 找到头结点并返回
        TreeNode head = pRootOfTree;
        // 一直找到 head.left == null 即可（沿着10找到4）
        while (head.left != null) {
            head = head.left;
        }
        return head;
    }

    // 中序遍历修改二叉树的指向
    private void inOrder(TreeNode root) {
        // 左子树 根 右子树
        if (root == null) { // 限制条件
            return;
        }
        // 左子树
        inOrder(root.left);

        // 修改根结点的指向
        // 第一三行代码都执行时，是这样：4.left = prev  4.right = 6
        root.left = prev;
        if (prev != null) {
            prev.right = root;
        }
        // 更新prev的值（不断的指向root的前一个结点）
        prev = root; 

        // 右子树
        inOrder(root.right);
    } 
}</code></pre> 
<h2 id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94KY11%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86" style="background-color:transparent;"><a class="link-info" href="https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=60&amp;&amp;tqId=29483&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/tsing-kaoyan/question-ranking" rel="nofollow" title="牛客网——KY11 二叉树遍历">牛客网——KY11 二叉树遍历</a></h2> 
<blockquote> 
 <p>描述</p> 
 <p>编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p> 
 <p>输入描述：</p> 
 <p>输入包括1行字符串，长度不超过100。</p> 
 <p>输出描述：</p> 
 <p>可能有多组测试数据，对于每组数据， 输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。 每个输出结果占一行。</p> 
 <p>示例1</p> 
 <p>输入：</p> 
 <pre>abc##de#g##f###
</pre> 
 <p>输出：</p> 
 <pre>c b e g d f a </pre> 
</blockquote> 
<p>注意：这里给了我们前序遍历的结果，并且把空树的位置告诉我们了，因此这里可以只通过前序遍历来创建一棵唯一的二叉树。</p> 
<p>思路：既然给了我们前序遍历的结果，那么我们肯定是要通过前序遍历来创建二叉树。即先创建根结点，再创建左子树，再创建右子树。核心代码思路出来了，也就可以开始写了。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">import java.util.Scanner;

// 创建树的节点
class TreeNode {
    public char val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode(char val) {
        this.val = val;
    }
}

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextLine()) { // 注意 while 处理多个 case
            String str = in.nextLine();
            // 以前序遍历的方式来创建二叉树
            TreeNode root = createTree(str);
            // 中序遍历二叉树
            inOrder(root);
        }
    }

    // 递归创建二叉树
    public static int i; // 记录遍历的位置
    public static TreeNode createTree(String str) {
        // 根据前序遍历创建二叉树：根 左子树 右子树
        TreeNode root = null;
        char ch = str.charAt(i);
        if (ch != '#') {
            // 这里不是空树，创建树：根 左子树 右子树
            root = new TreeNode(ch);
            i++; // 创建完成，就要往后走
            // 左子树
            root.left = createTree(str);
            // 右子树
            root.right = createTree(str);
        } else {
            // 因为root已经初始化，这里只需要让i往后走即可
            i++;
        }
        return root;
    }

    public static void inOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        // 根 左子树 右子树
        inOrder(root.left);
        System.out.print(root.val+" ");
        inOrder(root.right);
    }

}</code></pre> 
<p>二叉树的创建中根结点做的事情： 就是创建根结点即可。其余的就是交给框架去递归创建左子树和右子树。</p> 
<p>注意：这里在创建二叉树时，i 由于是 static 修饰，只有一份。当我们再次去创建一棵二叉树时，这个 i 的值不会从 0 开始，因此我们的处理方法有两种：</p> 
<p>1、在每次创建完一棵二叉树之后，把 i 置为 0即可。</p> 
<p>2、尽量不要用 static 修饰的变量。但是这里受题目限制，只能用这个了，而且这里的测试用例很可能只有一个</p> 
<p>好啦！本期 ​数据结构之初始二叉树（3）的刷题篇（上）的学习之旅就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c06760384ac261b6214a05a08dd56bd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle数据库 v$archived_log</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f68aefa933ddaec909c1a7c77b6e5d0a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于微信小程序&#43;SpringBoot&#43;数据可视化的校园快餐配送小程序设计和实现(源码&#43;论文&#43;部署讲解等)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>