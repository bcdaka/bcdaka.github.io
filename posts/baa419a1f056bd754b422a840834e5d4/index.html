<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法设计与分析】期末复习 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/baa419a1f056bd754b422a840834e5d4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法设计与分析】期末复习">
  <meta property="og:description" content="文章目录 复习大纲第一章算法概述1.1算法与程序1.2 算法复杂性分析 第二章递归与分治策略分治法的基本思想递归与分治的关系：用分治法解决的问题的几个特征：例题： 第三章动态规划动态规划的基本思想：分治与动态规划算法的异同：理解动态规划算法的基本要素：动态规划算法求解问题的步骤：例题： 第四章贪心算法理解贪心算法的基本要素：贪心算法与动态规划算法的异同点：0-1背包问题能不能用贪心算法求解？为什么？例题： 第五章回溯法回溯法的基本思想：回溯法解题步骤用回溯法解题的特征：回溯法的算法框架：影响回溯法的效率因素：例题（看PPT）： 第六章分支限界法分支限界法的基本思想：分支限界法与回溯法的异同：分支限界法的实现方式：例题： 复习题库选择题填空题算法填空简答题1.分治法的基本思想：2.设计动态规划算法的主要步骤为：3. 分治法与动态规划法异同4. 分支限界法与回溯法异同5.贪心算法与动态规划算法的主要区别6. 分治法所能解决的问题一般具有的几个特征是：7. 用分支限界法设计算法的步骤是：8. 常见的两种分支限界法的算法框架9. 回溯法中常见的两类典型的解空间树：10. 分支限界法的搜索策略是：11、回溯法的基本思想 算法设计题 复习大纲 第一章算法概述 1.1算法与程序 算法：是解决问题的一种方法或一个过程，是由若干条指令组成的有穷序列。
算法性质：
1.输入：有零个或多个
2.输出：至少一个
3.确定性：组成算法的每条指令清晰无歧义
4.有限性：算法中每条指令的执行次数和执行时间是有限的
5.算法与程序的区别：程序是算法用某种程序设计语言的具体实现，可以不满足有限性。
1.2 算法复杂性分析 1.算法的复杂性分时间复杂性和空间复杂性。
2.三种情况下的时间复杂性，可操作性最好最有实际价值的是最坏情况下的时间复杂性。
3.算法复杂性的渐进分析：O，o，Ω，ω，Θ
第二章递归与分治策略 分治法的基本思想 将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归地解这些子问题，然后将各子问题的解合并得到原问题的解。
递归与分治的关系： 由分治法产生的子问题往往是原问题的较小模式，反复应用分治法，可以使子问题与原问题类型一致且规模不断缩小，最终使子问题缩小到很容易求解，因此用递归求解。
用分治法解决的问题的几个特征： •问题的规模缩小到一定的程度可以容易地解决；
•问题可以分解为若干个规模较小的相同问题；
•利用原问题分解出的子问题的解可以合并为原问题的解；
•问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。如果子问题不是相互独立的，可以用动态规划法。
例题： 深刻理解算法的设计并能够进行时间复杂度分析
排列问题（包括有重复元素的情况），二分搜索，大整数乘法和矩阵乘法的分治思想，合并排序，快速排序，棋盘覆盖的思想。
第三章动态规划 动态规划的基本思想： 将待求解问题分解成若干个子问题，如果各个子问题不是独立的，不同的子问题的个数只是多项式量级，为避免大量的重复计算，用一个表记录所有已解决的子问题的答案，而在需要的时候再找出已求得的答案。
分治与动态规划算法的异同： 分治法与动态规划法的相同点是:将待求解的问题分解成若干个子问题,先求解子问题,然后从这些子问题的解得到原问题的解。
两者的不同点是:适合于用动态规划法求解的问题,经分解得到的子问题往往不是互相独立的。而用分治法求解的问题,经分解得到的子问题往往是互相独立的。
理解动态规划算法的基本要素： 最优子结构性质：问题的最优解包含了其子问题的最优解。重叠子问题性质：有些子问题被反复计算多次。 动态规划算法求解问题的步骤： 找出最优解的性质，并刻画其结构特征递归地定义最优值以自底向上的方式计算出最优值构造最优解 例题： 深刻理解矩阵连乘问题、最长公共子序列问题、最大子段和问题和0-1背包问题的动态规划算法，并进行时间复杂度和空间复杂度分析。
第四章贪心算法 理解贪心算法的基本要素： 贪心选择性质：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。最优子结构性质。 贪心算法与动态规划算法的异同点： （1）共同点：都需要最优子结构性质，都用来求最优化问题。
（2）不同点：
动态规划：每一步作一个选择—依赖于子问题的解。
贪心方法：每一步作一个选择—不依赖于子问题的解。
动态规划方法的条件：子问题的重叠性质。
可用贪心方法的条件：最优子结构性质；贪心选择性质。
动态规划：自底向上或自顶向下（备忘录方法）求解；
贪心方法：自顶向下求解。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-21T18:15:22+08:00">
    <meta property="article:modified_time" content="2023-06-21T18:15:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法设计与分析】期末复习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">复习大纲</a></li><li><ul><li><a href="#_2" rel="nofollow">第一章算法概述</a></li><li><ul><li><a href="#11_4" rel="nofollow">1.1算法与程序</a></li><li><a href="#12__14" rel="nofollow">1.2 算法复杂性分析</a></li></ul> 
   </li><li><a href="#_20" rel="nofollow">第二章递归与分治策略</a></li><li><ul><li><a href="#_22" rel="nofollow">分治法的基本思想</a></li><li><a href="#_26" rel="nofollow">递归与分治的关系：</a></li><li><a href="#_30" rel="nofollow">用分治法解决的问题的几个特征：</a></li><li><a href="#_37" rel="nofollow">例题：</a></li></ul> 
   </li><li><a href="#_42" rel="nofollow">第三章动态规划</a></li><li><ul><li><a href="#_44" rel="nofollow">动态规划的基本思想：</a></li><li><a href="#_49" rel="nofollow">分治与动态规划算法的异同：</a></li><li><a href="#_53" rel="nofollow">理解动态规划算法的基本要素：</a></li><li><a href="#_58" rel="nofollow">动态规划算法求解问题的步骤：</a></li><li><a href="#_65" rel="nofollow">例题：</a></li></ul> 
   </li><li><a href="#_69" rel="nofollow">第四章贪心算法</a></li><li><ul><li><a href="#_71" rel="nofollow">理解贪心算法的基本要素：</a></li><li><a href="#_76" rel="nofollow">贪心算法与动态规划算法的异同点：</a></li><li><a href="#01_86" rel="nofollow">0-1背包问题能不能用贪心算法求解？为什么？</a></li><li><a href="#_88" rel="nofollow">例题：</a></li></ul> 
   </li><li><a href="#_92" rel="nofollow">第五章回溯法</a></li><li><ul><li><a href="#_94" rel="nofollow">回溯法的基本思想：</a></li><li><a href="#_98" rel="nofollow">回溯法解题步骤</a></li><li><a href="#_104" rel="nofollow">用回溯法解题的特征：</a></li><li><a href="#_108" rel="nofollow">回溯法的算法框架：</a></li><li><a href="#_112" rel="nofollow">影响回溯法的效率因素：</a></li><li><a href="#PPT_120" rel="nofollow">例题（看PPT）：</a></li></ul> 
   </li><li><a href="#_130" rel="nofollow">第六章分支限界法</a></li><li><ul><li><a href="#_132" rel="nofollow">分支限界法的基本思想：</a></li><li><a href="#_135" rel="nofollow">分支限界法与回溯法的异同：</a></li><li><a href="#_139" rel="nofollow">分支限界法的实现方式：</a></li><li><a href="#_143" rel="nofollow">例题：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_146" rel="nofollow">复习题库</a></li><li><ul><li><a href="#_148" rel="nofollow">选择题</a></li><li><a href="#_244" rel="nofollow">填空题</a></li><li><a href="#_273" rel="nofollow">算法填空</a></li><li><a href="#_407" rel="nofollow">简答题</a></li><li><ul><li><a href="#1_409" rel="nofollow">1.分治法的基本思想：</a></li><li><a href="#2_413" rel="nofollow">2.设计动态规划算法的主要步骤为：</a></li><li><a href="#3__418" rel="nofollow">3. 分治法与动态规划法异同</a></li><li><a href="#4__423" rel="nofollow">4. 分支限界法与回溯法异同</a></li><li><a href="#5_428" rel="nofollow">5.贪心算法与动态规划算法的主要区别</a></li><li><a href="#6__435" rel="nofollow">6. 分治法所能解决的问题一般具有的几个特征是：</a></li><li><a href="#7__442" rel="nofollow">7. 用分支限界法设计算法的步骤是：</a></li><li><a href="#8__446" rel="nofollow">8. 常见的两种分支限界法的算法框架</a></li><li><a href="#9__451" rel="nofollow">9. 回溯法中常见的两类典型的解空间树：</a></li><li><a href="#10__456" rel="nofollow">10. 分支限界法的搜索策略是：</a></li><li><a href="#11_459" rel="nofollow">11、回溯法的基本思想</a></li></ul> 
   </li><li><a href="#_463" rel="nofollow">算法设计题</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>复习大纲</h2> 
<h3><a id="_2"></a>第一章算法概述</h3> 
<h4><a id="11_4"></a>1.1算法与程序</h4> 
<p>算法：是解决问题的<mark>一种方法或一个过程</mark>，是由若干条<mark>指令</mark>组成的有穷序列。<br> <strong>算法性质</strong>：<br> 1.输入：有零个或多个<br> 2.输出：至少一个<br> 3.确定性：组成算法的每条指令清晰无歧义<br> 4.有限性：算法中每条指令的执行次数和执行时间是有限的<br> 5.算法与程序的区别：程序是算法用某种程序设计语言的具体实现，可以不满足有限性。</p> 
<h4><a id="12__14"></a>1.2 算法复杂性分析</h4> 
<p>1.算法的复杂性分<mark>时间复杂性</mark>和<mark>空间复杂性</mark>。<br> 2.三种情况下的时间复杂性，可操作性最好最有实际价值的是<mark>最坏情况下的时间复杂性</mark>。<br> 3.算法复杂性的渐进分析：O，o，Ω，ω，Θ</p> 
<h3><a id="_20"></a>第二章递归与分治策略</h3> 
<h4><a id="_22"></a>分治法的基本思想</h4> 
<p>将一个规模为n的问题分解为k个规模较小的子问题，这些子问题<mark>互相独立</mark>且与原问题相同。递归地解这些子问题，然后将各子问题的解<mark>合并</mark>得到原问题的解。</p> 
<h4><a id="_26"></a>递归与分治的关系：</h4> 
<p>由分治法产生的子问题往往是原问题的较小模式，反复应用分治法，可以使子问题与原问题类型一致且规模不断缩小，最终使子问题缩小到很容易求解，因此<mark>用递归求解</mark>。</p> 
<h4><a id="_30"></a>用分治法解决的问题的几个特征：</h4> 
<p>•问题的规模缩小到一定的程度<mark>可以容易地解决</mark>；<br> •问题可以<mark>分解为若干个规模较小的相同问题</mark>；<br> •利用原问题分解出的<mark>子问题的解可以合并为原问题的解</mark>；<br> •问题所分解出的各个子问题是<mark>相互独立的</mark>，即<mark>子问题之间不包含公共的子问题</mark>。如果子问题不是相互独立的，可以用<mark>动态规划法</mark>。</p> 
<h4><a id="_37"></a>例题：</h4> 
<p>深刻理解算法的设计并能够进行时间复杂度分析<br> 排列问题（包括有重复元素的情况），二分搜索，大整数乘法和矩阵乘法的分治思想，合并排序，快速排序，棋盘覆盖的思想。</p> 
<h3><a id="_42"></a>第三章动态规划</h3> 
<h4><a id="_44"></a>动态规划的基本思想：</h4> 
<p>将待求解问题分解成若干个子问题，如果各个子问题不是独立的，不同的子问题的个数只是多项式量级，为避免大量的重复计算，用一个表记录所有已解决的子问题的答案，而在需要的时候再找出已求得的答案。</p> 
<h4><a id="_49"></a>分治与动态规划算法的异同：</h4> 
<p>分治法与动态规划法的相同点是:将待求解的问题分解成若干个子问题,先求解子问题,然后从这些子问题的解得到原问题的解。<br> 两者的不同点是:适合于用动态规划法求解的问题,经分解得到的子问题往往不是互相独立的。而用分治法求解的问题,经分解得到的子问题往往是互相独立的。</p> 
<h4><a id="_53"></a>理解动态规划算法的基本要素：</h4> 
<ul><li><mark>最优子结构性质</mark>：问题的最优解包含了其子问题的最优解。</li><li><mark>重叠子问题性质</mark>：有些子问题被反复计算多次。</li></ul> 
<h4><a id="_58"></a>动态规划算法求解问题的步骤：</h4> 
<ul><li>找出最优解的性质，并刻画其结构特征</li><li>递归地定义最优值</li><li>以<mark>自底向上</mark>的方式计算出最优值</li><li>构造最优解</li></ul> 
<h4><a id="_65"></a>例题：</h4> 
<p>深刻理解矩阵连乘问题、<mark>最长公共子序列问题</mark>、<mark>最大子段和问题</mark>和<mark>0-1背包问题</mark>的动态规划算法，并进行时间复杂度和空间复杂度分析。</p> 
<h3><a id="_69"></a>第四章贪心算法</h3> 
<h4><a id="_71"></a>理解贪心算法的基本要素：</h4> 
<ul><li>贪心选择性质：所求问题的整体最优解可以通过一系列<mark>局部最优</mark>的选择，即贪心选择来达到。</li><li>最优子结构性质。</li></ul> 
<h4><a id="_76"></a>贪心算法与动态规划算法的异同点：</h4> 
<p>（1）共同点：都需要<mark>最优子结构性质</mark>，都用来求最优化问题。<br> （2）不同点：<br> 动态规划：每一步作一个选择—<mark>依赖于子问题的解</mark>。<br> 贪心方法：每一步作一个选择—<mark>不依赖于子问题的解</mark>。<br> 动态规划方法的条件：子问题的重叠性质。<br> 可用贪心方法的条件：最优子结构性质；贪心选择性质。<br> 动态规划：自底向上或自顶向下（备忘录方法）求解；<br> 贪心方法：自顶向下求解。</p> 
<h4><a id="01_86"></a>0-1背包问题能不能用贪心算法求解？为什么？</h4> 
<p>对于部分背包问题,依照贪心选择策略,可以得到最优解。而0-1背包问题,贪心选择之所以不能得到最优解,是因为在这种情况下,它<mark>无法保证最终能将背包装满</mark>,<mark>部分闲置的背包空间使每公斤背包空间的价值降低了</mark>。因而我们选择的判断标准出现了误差。</p> 
<h4><a id="_88"></a>例题：</h4> 
<p>重点：<mark>活动安排</mark>、背包问题、最优装载<br> 单源最短路径、哈弗曼编码、最小生成树问题，重点理解贪心策略</p> 
<h3><a id="_92"></a>第五章回溯法</h3> 
<h4><a id="_94"></a>回溯法的基本思想：</h4> 
<p>在问题的解空间树中，按<mark>深度优先</mark>策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，<mark>先判断该结点是否包含问题的解</mark>。如果肯定不包含，则跳过对该结点为根的子树的搜索，<mark>逐层向其祖先结点回溯</mark>；<mark>否则，进入该子树，继续按深度优先策略搜索</mark>。</p> 
<h4><a id="_98"></a>回溯法解题步骤</h4> 
<ol><li>针对所给问题，定义问题的解空间；</li><li>确定易于搜索的解空间结构；</li><li>以深度优先方式搜索解空间，并在搜索过程中用<mark>剪枝函数</mark>避免无效搜索。</li></ol> 
<h4><a id="_104"></a>用回溯法解题的特征：</h4> 
<p>在搜索过程中动态产生问题的解空间。问题的解空间树是虚拟的，并不需要在算法运行时构造一棵真正的树结构。在任何时刻，算法<mark>只保存从根结点到当前扩展结点的路径</mark>。</p> 
<h4><a id="_108"></a>回溯法的算法框架：</h4> 
<p>递归回溯、子集树与<mark>排列树</mark>算法框架</p> 
<h4><a id="_112"></a>影响回溯法的效率因素：</h4> 
<ol><li>产生x[k]的时间；</li><li>满足显约束的x[k]值的个数；</li><li>计算约束函数constraint的时间；</li><li>计算上界函数bound的时间；</li><li>满足约束函数和上界函数约束的所有x[k]的个数。</li></ol> 
<h4><a id="PPT_120"></a>例题（看PPT）：</h4> 
<p>装载问题、n后问题、0-1背包问题、最大团问题、图的m着色问题、旅行售货员问题。<br> 对每一个问题深刻理解以下几点：</p> 
<ol><li>解的表示形式</li><li>解空间表示成什么样的树型结构</li><li>约束条件是什么？</li><li>限界条件是什么（如果有的话）？</li><li>如何构造并输出解。</li></ol> 
<h3><a id="_130"></a>第六章分支限界法</h3> 
<h4><a id="_132"></a>分支限界法的基本思想：</h4> 
<p>分支限界法常以<mark>广度优先</mark>或以<mark>最小耗费</mark>(最大效益)优先的方式搜索问题的解空间树。</p> 
<h4><a id="_135"></a>分支限界法与回溯法的异同：</h4> 
<p>1)求解目旳:回溯法旳求解目旳是找出解空间树中满足约束条件旳<mark>所有解</mark>,而分支限界法旳求解目旳则是找出满足约束条件旳<mark>一种解</mark>,或是在满足约束条件旳解中找出<mark>在某种意义下旳最优解</mark>。<br> 2)搜索方式旳不同:回溯法以<mark>深度优先</mark>旳方式搜索解空间树,而分支限界法则以<mark>广度优先</mark>或以<mark>最小耗费优先</mark>旳方式搜索解空间树。</p> 
<h4><a id="_139"></a>分支限界法的实现方式：</h4> 
<p>队列式和优先队列式</p> 
<h4><a id="_143"></a>例题：</h4> 
<p>单源最短路径、装载问题（重点）、0-1背包问题、旅行售货员问题。对于优先队列式分支限界法，重点理解堆元素的优先级怎么定，结点的上界或下界如何确定。</p> 
<h2><a id="_146"></a>复习题库</h2> 
<h3><a id="_148"></a>选择题</h3> 
<p>1、二分搜索算法是利用（ A ）实现的算法。<br> <strong>A、分治策略</strong> B、动态规划法 C、贪心法 D、回溯法<br> 2、下列不是动态规划算法基本步骤的是（ A ）。<br> <strong>A、找出最优解的性质</strong> B、构造最优解 C、算出最优解 D、定义最优解<br> 3、最大效益优先是（ A ）的一搜索方式。<br> <strong>A、分支界限法</strong> B、动态规划法 C、贪心法 D、回溯法<br> 5. 回溯法解旅行售货员问题时的解空间树是（B ）。<br> A、子集树 <strong>B、排列树</strong> C、深度优先生成树 D、广度优先生成树<br> 6．下列算法中通常以自底向上的方式求解最优解的是（ B ）。<br> A、备忘录法 <strong>B、动态规划法</strong> C、贪心法 D、回溯法<br> 7、衡量一个算法好坏的标准是（C ）。<br> A 运行速度快 B 占用空间少 <strong>C 时间复杂度低</strong> D 代码短<br> 8、以下不可以使用分治法求解的是（D ）。<br> A 棋盘覆盖问题 B 选择问题 C 归并排序 <strong>D 0/1背包问题</strong><br> 9. 实现循环赛日程表利用的算法是（ A ）。<br> <strong>A、分治策略</strong> B、动态规划法 C、贪心法 D、回溯法<br> 11．下面不是分支界限法搜索方式的是（ D ）。<br> A、广度优先 B、最小耗费优先 C、最大效益优先 <strong>D、深度优先</strong><br> 12．下列算法中通常以深度优先方式系统搜索问题解的是（ D ）。<br> A、备忘录法 B、动态规划法 C、贪心法 <strong>D、回溯法</strong><br> 13.备忘录方法是那种算法的变形。（ B ）<br> A、分治法 <strong>B、动态规划法</strong> C、贪心法 D、回溯法<br> 14．<mark>哈弗曼编码的贪心算法</mark>所需的计算时间为（ B ）。<br> A、O（n2n） <strong>B、O（nlogn）</strong> C、O（2n） D、O（n）<br> 15．分支限界法解最大团问题时，活结点表的组织形式是（ B ）。<br> A、最小堆 <strong>B、最大堆</strong> C、栈 D、数组<br> 16．最长公共子序列算法利用的算法是（ B ）。<br> A、分支界限法 <strong>B、动态规划法</strong> C、贪心法 D、回溯法<br> 17．实现棋盘覆盖算法利用的算法是（ A ）。<br> <strong>A、分治法</strong> B、动态规划法 C、贪心法 D、回溯法<br> 18.下面是贪心算法的基本要素的是（ C ）。<br> A、重叠子问题 B、构造最优解 <strong>C、贪心选择性质</strong> D、定义最优解<br> 19.回溯法的效率不依赖于下列哪些因素（ D ）<br> A.满足显约束的值的个数 B. 计算约束函数的时间<br> C. 计算限界函数的时间 <strong>D. 确定解空间的时间</strong><br> 20.下面哪种函数是回溯法中为避免无效搜索采取的策略（ B ）<br> A．递归函数 <strong>B.剪枝函数</strong> C。随机数函数 D.搜索函数<br> 21、下面关于NP问题说法正确的是（B ）<br> A NP问题都是不可能解决的问题<br> <strong>B P类问题包含在NP类问题中</strong><br> C NP完全问题是P类问题的子集<br> D NP类问题包含在P类问题中<br> 24. （D ）是贪心算法与动态规划算法的共同点。<br> A、重叠子问题 B、构造最优解 C、贪心选择性质 <strong>D、最优子结构性质</strong><br> 25. 矩阵连乘问题的算法可由（ B）设计实现。<br> A、分支界限算法 <strong>B、动态规划算法</strong> C、贪心算法 D、回溯算法<br> 26. 分支限界法解旅行售货员问题时，活结点表的组织形式是（ A ）。<br> <strong>A、最小堆</strong> B、最大堆 C、栈 D、数组<br> 27、Strassen矩阵乘法是利用（ A ）实现的算法。<br> <strong>A、分治策略</strong> B、动态规划法 C、贪心法 D、回溯法<br> 29、使用分治法求解不需要满足的条件是（A ）。<br> <strong>A 子问题必须是一样的</strong><br> B 子问题不能够重复<br> C 子问题的解可以合并<br> D 原问题和子问题使用相同的方法解<br> 30、下面问题（B ）不能使用贪心法解决。<br> A 单源最短路径问题 <strong>B N皇后问题</strong><br> C 最小花费生成树问题 D 背包问题<br> 31、下列算法中不能解决0/1背包问题的是（A ）<br> <strong>A 贪心法</strong> B 动态规划 C 回溯法 D 分支限界法<br> 34．实现合并排序利用的算法是（ A ）。<br> <strong>A、分治策略</strong> B、动态规划法 C、贪心法 D、回溯法<br> 35．下列是动态规划算法基本要素的是（ D ）。<br> A、定义最优解 B、构造最优解 C、算出最优解 <strong>D、子问题重叠性质</strong><br> 37．采用广度优先策略搜索的算法是（ A ）。<br> <strong>A、分支界限法</strong> B、动态规划法 C、贪心法 D、回溯法<br> 38、合并排序算法是利用（ A ）实现的算法。<br> <strong>A、分治策略</strong> B、动态规划法 C、贪心法 D、回溯法<br> 40、背包问题的贪心算法所需的计算时间为（ B ）<br> A、O（n2n） <strong>B、O（nlogn）</strong> C、O（2n） D、O（n）<br> 41．实现大整数的乘法是利用的算法（ C ）。<br> A、贪心法 B、动态规划法 <strong>C、分治策略</strong> D、回溯法<br> 42．0-1背包问题的回溯算法所需的计算时间为（ A ）<br> <strong>A、O（n2n）</strong> B、O（nlogn） C、O（2n） D、O（n）<br> 43．采用最大效益优先搜索方式的算法是（ A ）。<br> <strong>A、分支界限法</strong> B、动态规划法 C、贪心法 D、回溯法<br> 44．贪心算法与动态规划算法的主要区别是（ B ）。<br> A、最优子结构 <strong>B、贪心选择性质</strong> C、构造最优解 D、定义最优解<br> 45. 实现最大子段和利用的算法是（ B ）。<br> A、分治策略 <strong>B、动态规划法</strong> C、贪心法 D、回溯法<br> 46.优先队列式分支限界法选取扩展结点的原则是（ C ）。<br> A、先进先出 B、后进先出 <strong>C、结点的优先级</strong> D、随机<br> 47.背包问题的贪心算法所需的计算时间为（ B ）。<br> A、O（n2n） <strong>B、O（nlogn）</strong> C、O（2n） D、O（n）<br> 48、广度优先是（ A ）的一搜索方式。<br> <strong>A、分支界限法</strong> B、动态规划法 C、贪心法 D、回溯法<br> 52. 一个问题可用动态规划算法或贪心算法求解的关键特征是问题的（ B ）。<br> A、重叠子问题 <strong>B、最优子结构性质</strong> C、贪心选择性质 D、定义最优解<br> 53．采用贪心算法的最优装载问题的主要计算量在于将集装箱依其重量从小到大排序，故算法的时间复杂度为 ( B ) 。<br> A、O（n2n） <strong>B、O（nlogn）</strong> C、O（2n） D、O（n）<br> 54. 以深度优先方式系统搜索问题解的算法称为 ( D ) 。<br> A、分支界限算法 B、概率算法 C、贪心算法 <strong>D、回溯算法</strong><br> 55. 实现最长公共子序列利用的算法是（ B ）。<br> A、分治策略 <strong>B、动态规划法</strong> C、贪心法 D、回溯法</p> 
<h3><a id="_244"></a>填空题</h3> 
<p>1.算法的复杂性有 <strong>时间</strong> 复杂性和 <strong>空间</strong> 复杂性之分。<br> 2、程序是 <strong>算法</strong> 用某种程序设计语言的具体实现。<br> 3、算法的“确定性”指的是组成算法的每条 <strong>指令</strong> 是清晰的，无歧义的。<br> 4.矩阵连乘问题的算法可由 <strong>动态规划</strong> 设计实现。<br> 6、算法是指解决问题的 <strong>一种方法</strong> 或 <strong>一个过程</strong> 。<br> 7、从分治法的一般设计模式可以看出，用它设计出的程序一般是 <strong>递归算法</strong> 。<br> 8、问题的 <strong>最优子结构性质</strong> 是该问题可用动态规划算法或贪心算法求解的关键特征。<br> 9、以深度优先方式系统搜索问题解的算法称为 <strong>回溯法</strong> 。<br> 11、计算一个算法时间复杂度通常可以计算 <strong>循环次数</strong> 、 <strong>基本操作的频率</strong> 或计算步。<br> 14、解决0/1背包问题可以使用动态规划、回溯法和分支限界法，其中不需要排序的是 <strong>动态规划</strong> ，需要排序的是 <strong>回溯法</strong> ，<strong>分支限界法</strong> 。<br> 15、使用回溯法进行状态空间树裁剪分支时一般有两个标准：约束条件和目标函数的界，N皇后问题和0/1背包问题正好是两种不同的类型，其中同时使用约束条件和目标函数的界进行裁剪的是 <strong>0/1背包问题</strong> ，只使用约束条件进行裁剪的是 <strong>N皇后问题</strong> 。<br> 16、 <strong>贪心选择性质</strong> 是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。<br> 17、矩阵连乘问题的算法可由 <strong>动态规划</strong> 设计实现。<br> 19.贪心算法的基本要素是 <strong>贪心选择</strong> 质和 <strong>最优子结构</strong> 性质 。<br> 21. 动态规划算法的基本思想是将待求解问题分解成若干 <strong>子问题</strong> ，先求解 <strong>子问题</strong> ，然后从这些 <strong>子问题</strong> 的解得到原问题的解。<br> 22.算法是由若干条指令组成的有穷序列，且要满足<strong>输入</strong>、 <strong>输出</strong> 、<strong>确定性</strong>和 <strong>有限性</strong> 四条性质。<br> 23、大整数乘积算法是用 <strong>分治法</strong> 来设计的。<br> 24、以广度优先或以最小耗费方式搜索问题解的算法称为 <strong>分支限界法</strong> 。<br> 26、 <strong>贪心选择性质</strong> 是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。<br> 27.快速排序算法是基于 <strong>分治策略</strong> 的一种排序算法。<br> 28.动态规划算法的两个基本要素是. <strong>最优子结构</strong> 性质和 <strong>重叠子问题</strong> 性质 。<br> 30.回溯法是一种既带有 <strong>系统性</strong> 又带有 <strong>跳跃性</strong> 的搜索算法。<br> 31.分支限界法主要有 <strong>队列式（FIFO）</strong> 分支限界法和 <strong>优先队列式</strong> 分支限界法。<br> 32．分支限界法是一种既带有 <strong>系统性</strong> 又带有 <strong>跳跃性</strong> 的搜索算法。<br> 33．回溯法搜索解空间树时，常用的两种剪枝函数为 <strong>约束函数</strong> 和 <strong>限界函数</strong> 。<br> 34.任何可用计算机求解的问题所需的时间都与其 <strong>规模</strong> 有关。<br> 35.快速排序算法的性能取决于 <strong>划分的对称性</strong> 。</p> 
<h3><a id="_273"></a>算法填空</h3> 
<p>1.背包问题的<mark>贪心算法</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">float</span> M<span class="token punctuation">,</span> <span class="token keyword">float</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">float</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
      <span class="token function">Sort</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排序</span>
      <span class="token keyword">int</span> i<span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//不选这个物品</span>
      Float c <span class="token operator">=</span> M<span class="token punctuation">;</span><span class="token comment">//设置背包剩余容量</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//开始遍历物品</span>
    	<span class="token punctuation">{<!-- --></span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//如果物品的重量大于剩余背包容量，跳出循环</span>
          x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//否则改变物品状态为1 表示已经选择</span>
          c <span class="token operator">-</span> <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//背包剩余容量改变 </span>
    	<span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c <span class="token operator">/</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//如果没有装完物品的话，能装多少装多少</span>
<span class="token punctuation">}</span>
 

</code></pre> 
<p>2.最大子段和 <mark>动态规划算法</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">MaxSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//sum用来表示最大值 b用来当做目前的子段和</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> b <span class="token operator">+=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//如果b大于0，那么就加上当前的 </span>
        <span class="token keyword">else</span> b <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//否则就等于当前的</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&gt;</span> sum<span class="token punctuation">)</span><span class="token comment">//如果b比sum大的话 那么sum就赋值为b</span>
            sum <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>   
</code></pre> 
<p>3.<mark>贪心算法</mark>求装载问题</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Type</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Loading</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Type w<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Type c<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">Sort</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> t<span class="token punctuation">,</span> n<span class="token punctuation">)</span> 
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> w<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        x<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        c <span class="token operator">-=</span> w<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>4.<mark>贪心算法</mark>求活动安排问题</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Type</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">GreedySelector</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> Type s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Type f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    A<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//如果开始时间大于上一个的结束时间</span>
        <span class="token punctuation">{<!-- --></span>
            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment">//选择这个活动</span>
            j <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//更新上一个活动的标记</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//不选这个活动</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>5.<mark>快速排序</mark></p> 
<p>核心思想是二分</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Type</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>Type a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        Int q <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对左半段排序</span>
        <span class="token function">QuickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对右半段排序</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>6.<mark>排列问题</mark></p> 
<pre><code class="prism language-cpp">Template<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Type</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">perm</span><span class="token punctuation">(</span>Type list<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> m<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span> <span class="token comment">// 只剩下一个元素 直接输出列表元素0~m</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            cout <span class="token operator">&lt;&lt;</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token comment">// 还有多个元素待排列，递归产生排列</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//从k到m</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换k i元素</span>
            <span class="token function">perm</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//排列 k+1~m</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>list<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//再换回来</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>7.用<mark>回溯法搜索子集树</mark>的算法为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&gt;</span> n<span class="token punctuation">)</span>
        <span class="token function">output</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//大于节点数了，直接输出x</span>
    <span class="token keyword">else</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            x<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">constraint</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">bound</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">backtrack</span><span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_407"></a>简答题</h3> 
<h4><a id="1_409"></a>1.分治法的基本思想：</h4> 
<p>将一个规模为n的问题分解为k个规模较小的子问题，这些子问题互相独立且与原问题相同。递归地解这些子问题，然后将各个子问题的解合并得到原问题的解。</p> 
<h4><a id="2_413"></a>2.设计动态规划算法的主要步骤为：</h4> 
<p>（1）找出最优解的性质，并刻画其结构特征。（2）递归地定义最优值。<br> （3）以自底向上的方式计算出最优值。（4）根据计算最优值时得到的信息，构造最优解。</p> 
<h4><a id="3__418"></a>3. 分治法与动态规划法异同</h4> 
<p>相同点是：将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。<br> 不同点是：适合于用动态规划法求解的问题，经分解得到的子问题往往不是互相独立的。而用分治法求解的问题，经分解得到的子问题往往是互相独立的。</p> 
<h4><a id="4__423"></a>4. 分支限界法与回溯法异同</h4> 
<p>相同点：都是一种在问题的解空间树T中搜索问题解的算法。<br> 不同点：（1）求解目标不同（2）搜索方式不同（3）对扩展结点的扩展方式不同（4）存储空间的要求不同。</p> 
<h4><a id="5_428"></a>5.贪心算法与动态规划算法的主要区别</h4> 
<p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是利用贪心算法求解最优解的第一个基本要素，也是贪心算法与动态规划算法的主要区别。<br> 共同点：<br> 求解的问题都具有最优子结构性质<br> 差异点：<br> 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每做一次贪心选择就将所求问题简化为规模更小的子问题。</p> 
<h4><a id="6__435"></a>6. 分治法所能解决的问题一般具有的几个特征是：</h4> 
<p>（1）该问题的规模缩小到一定的程度就可以容易地解决；<br> （2）该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质;<br> （3）利用该问题分解出的子问题的解可以合并为该问题的解；<br> （4）原问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p> 
<h4><a id="7__442"></a>7. 用分支限界法设计算法的步骤是：</h4> 
<p>(1)针对所给问题，定义问题的解空间（对解进行编码）(2)确定易于搜索的解空间结构（按树或图组织解）；(3)以广度优先或以最小耗费（最大收益）优先的方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p> 
<h4><a id="8__446"></a>8. 常见的两种分支限界法的算法框架</h4> 
<p>（1）队列式(FIFO)分支限界法：按照队列先进先出原则选取下一个节点为扩展节点。<br> （2）优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</p> 
<h4><a id="9__451"></a>9. 回溯法中常见的两类典型的解空间树：</h4> 
<p>子集树：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。这类子集树通常有2n个叶结点，遍历子集树需O(2n)计算时间 。<br> 排列树：当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。这类排列树通常有n!个叶结点。遍历排列树需要O(n!)计算时间。</p> 
<h4><a id="10__456"></a>10. 分支限界法的搜索策略是：</h4> 
<p>在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展结点。为了有效地选择下一扩展结点，加速搜索的进程，在每一个活结点处，计算一个函数值（限界），并根据函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。</p> 
<h4><a id="11_459"></a>11、回溯法的基本思想</h4> 
<p>是在一棵含有问题全部可能解的状态空间树上进行深度优先搜索，解为叶子结点。搜索过程中，每到达一个结点时，则判断该结点为根的子树是否含有问题的解，如果可以确定该子树中不含有问题的解，则放弃对该子树的搜索，退回到上层父结点，继续下一步深度优先搜索过程。在回溯法中，并不是先构造出整棵状态空间树，再进行搜索，而是在搜索过程，逐步构造出状态空间树，即边搜索，边构造。</p> 
<h3><a id="_463"></a>算法设计题</h3> 
<ol><li>给定已按升序排好序的n个元素a[0:n-1]，现要在这n个元素中找出一特定元素x，返回其在数组中的位置，如果未找到返回-1。<br> 写出<mark>二分搜索</mark>的算法，并分析其时间复杂度。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Type</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span>Type a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Type <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> <span class="token comment">// 在a[0:n]中搜索x，找到x时返回其在数组中的位置，否则返回-1</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//找到中点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//如果找到了 返回</span>
            <span class="token keyword">return</span> middle<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>middle<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//如果大于 那就在右边找</span>
            left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token comment">//如果小于 那就在左边找</span>
            right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Return <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//没找到 返回-1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>时间复杂性为O(logn)</p> 
<ol start="2"><li>利用分治算法写出合并排序的算法，并分析其时间复杂度</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>Type a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>                               <span class="token comment">// 至少有2个元素</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 取中点</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左侧合并排序</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右侧合并排序</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> left<span class="token punctuation">,</span> i<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合并到数组b</span>
        <span class="token function">copy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 复制回数组a</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>算法在最坏情况下的时间复杂度为O(nlogn)。</p> 
<p>3.<mark>N皇后回溯法</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token class-name">Queen</span><span class="token double-colon punctuation">::</span><span class="token function">Place</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> <span class="token comment">// 检查x[k]位置是否合法</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>k <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">abs</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">Queen</span><span class="token double-colon punctuation">::</span><span class="token function">Backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&gt;</span> n<span class="token punctuation">)</span>
        sum<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            x<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>约束函数<span class="token punctuation">)</span>
                <span class="token function">Backtrack</span><span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>4.最大团问题 <mark>回溯法</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token class-name">Clique</span><span class="token double-colon punctuation">::</span><span class="token function">Backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment">// 计算最大团</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span> <span class="token comment">// 到达叶结点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        	bestx<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        bestn <span class="token operator">=</span> cn<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 检查顶点 i 与当前团的连接</span>
    <span class="token keyword">int</span> OK <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span> <span class="token comment">// i与j不相连</span>
            OK <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>OK<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span> <span class="token comment">// 进入左子树</span>
        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        cn<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">Backtrack</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        cn<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cn <span class="token operator">+</span> n <span class="token operator">-</span> i <span class="token operator">&gt;</span> bestn<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span> <span class="token comment">// 进入右子树</span>
        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">Backtrack</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>5.最长公共子序列问题</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 参数:x字符串长度为m y字符串长度为n</span>
<span class="token keyword">void</span> <span class="token function">LCSLength</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> y<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/* 计算最长公共子序列的长度 */</span>
    <span class="token keyword">int</span> L<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> i，j<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> y<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> L<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>6.分别用贪心算法、动态规划法、回溯法设计0-1背包问题。要求：说明所使用的算法策略；写出算法实现的主要步骤；分析算法的时间。<br> （1）贪心算法 O（nlog（n））<br> 首先计算每种物品单位重量的价值Vi/Wi，然后，依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。若将这种物品全部装入背包后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能多地装入背包。依此策略一直地进行下去，直到背包装满为止。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Knapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">float</span> M<span class="token punctuation">,</span> <span class="token keyword">float</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">float</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">float</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">sort</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> c <span class="token operator">=</span> M<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        c <span class="token operator">-=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span>
        x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c <span class="token operator">/</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（2）动态规划法 O(nc)<br> m(i，j)是背包容量为j，可选择物品为i，i+1，…，n时0-1背包问题的最优值。由0-1背包问题的最优子结构性质，可以建立计算m(i，j)的递归式如下。</p> 
<p><img src="https://images2.imgbox.com/f0/bb/qvSsUDQA_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">KnapSack</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> jMax <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>w<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> jMax<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">/*m(n,j)=0   0=&lt;j&lt;w[n]*/</span>
        m<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> w<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">/*m(n,j)=v[n]   j&gt;=w[n]*/</span>
        m<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> jMax <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> jMax<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">/*m(i,j)=m(i+1,j)   0=&lt;j&lt;w[i]*/</span>
            m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">/*m(n,j)=v[n]   j&gt;=w[n]*/</span>
            m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> w<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> w<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（3）回溯法 O(2n)<br> cw:当前重量 cp:当前价值 bestp：当前最优值</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token comment">// 回溯法 i初值1</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> n<span class="token punctuation">)</span> <span class="token comment">// 到达叶结点</span>
    <span class="token punctuation">{<!-- --></span>
        bestp <span class="token operator">=</span> cp<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cw <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c<span class="token punctuation">)</span> <span class="token comment">// 搜索左子树</span>
    <span class="token punctuation">{<!-- --></span>
        cw <span class="token operator">+=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        Cp <span class="token operator">+=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cw <span class="token operator">-=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        cp <span class="token operator">-=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Bound</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> bestp<span class="token punctuation">)</span>
        <span class="token comment">// 搜索右子树</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
<span class="token punctuation">}</span>
</code></pre> 
<p>7.通过键盘输入一个高精度的正整数n(n的有效位数≤240)，去掉其中任意s个数字后，剩下的数字按原左右次序将组成一个新的正整数。编程对给定的n 和s，寻找一种方案，使得剩下的数字组成的新数最小。<br> 【样例输入】<br> 178543<br> S=4<br> 【样例输出】<br> 13<br> 为了尽可能地逼近目标，我们选取的贪心策略为：每一步总是选择一个使剩下的数最小的数字删去，即按高位到低位的顺序搜索，若各位数字递增，则删除最后一个数字，否则删除第一个递减区间的首字符。然后回到串首，按上述规则再删除下一个数字。重复以上过程s次，剩下的数字串便是问题的解了。<br> 具体算法如下：</p> 
<pre><code class="prism language-cpp">输入s<span class="token punctuation">,</span> n<span class="token punctuation">;</span>
<span class="token keyword">while</span>（ s <span class="token operator">&gt;</span> <span class="token number">0</span> ）
<span class="token punctuation">{<!-- --></span>
    i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 从串首开始找</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token function">length</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>n<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> n<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token keyword">delete</span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除字符串n的第i个字符</span>
    s<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">length</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>‘<span class="token number">0</span>’<span class="token punctuation">)</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删去串首可能产生的无用零</span>
输出n<span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/11fc0bb771ba19d37c92766aa9c2cfda/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端遇到302处理方式以及设置第三方Cookie研究</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ca134c7e9e599bf1c42abee40aa6a03/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算两幅图像的相似度（PSNR、SSIM、MSE、余弦相似度、MD5、直方图、互信息、Hash）&amp; 代码实现 与举例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>