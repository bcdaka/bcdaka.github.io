<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pytorch backbone - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6019b432cebd0bcf01dd4d0078792976/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="pytorch backbone">
  <meta property="og:description" content="1 简介 在PyTorch深度学习中，预训练backbone（骨干网络）是一个常见的做法，特别是在处理图像识别、目标检测、图像分割等任务时。预训练backbone通常是指在大型数据集（如ImageNet）上预先训练好的卷积神经网络（CNN）模型，这些模型能够提取图像中的通用特征，这些特征在多种任务中都是有用的。
1. 常见的预训练Backbone 以下是一些在PyTorch中常用的预训练backbone：
ResNet：由何恺明等人提出的深度残差网络，通过引入残差连接解决了深层网络训练中的梯度消失或梯度爆炸问题。ResNet系列包括ResNet-18、ResNet-34、ResNet-50、ResNet-101、ResNet-152等，数字表示网络的层数。VGG：由牛津大学的Visual Geometry Group提出，特点是使用了多个小卷积核（如3x3）的卷积层和池化层来构建深层网络。VGG系列包括VGG16、VGG19等。MobileNet：专为移动和嵌入式设备设计的轻量级网络，通过深度可分离卷积减少了计算量和模型大小。DenseNet：通过密集连接（dense connections）提高了信息流动和梯度传播效率，进一步增强了特征重用。EfficientNet：通过同时缩放网络的深度、宽度和分辨率来优化网络，实现了在保持模型效率的同时提高准确率。 2. 如何使用预训练Backbone 在PyTorch中，使用预训练backbone通常涉及以下几个步骤：
导入模型：使用PyTorch的torchvision.models模块导入所需的预训练模型。
import torchvision.models as models # 导入预训练的ResNet50模型 resnet50 = models.resnet50(pretrained=True) print(resnet50) 修改模型：根据需要修改模型的最后几层以适应特定的任务（如分类任务中的类别数）。
# 假设我们有一个100类的分类任务 num_ftrs = resnet50.fc.in_features resnet50.fc = torch.nn.Linear(num_ftrs, 100) 冻结backbone：在训练时，可以选择冻结backbone的参数，只训练新添加的层（如分类层），这有助于加快训练速度并防止过拟合。
for param in resnet50.parameters(): param.requires_grad = False # 只对新添加的层设置requires_grad=True resnet50.fc.parameters().requires_grad = True 训练模型：使用适当的数据集和训练策略来训练模型。
评估模型：在测试集上评估模型的性能。
3. 注意事项 使用预训练权重时，应确保输入图像的预处理（如大小调整、归一化等）与预训练时使用的预处理一致。冻结backbone时，应确保模型的其余部分（如新添加的层）有足够的容量来学习任务特定的特征。在某些情况下，解冻backbone的一部分或全部并在目标数据集上进行微调可能会获得更好的性能。 通过以上步骤，可以在PyTorch中有效地利用预训练backbone来解决各种计算机视觉任务。
2 查看模型源码 想查看models.resnet50的源码，可以点击查看pytorch中的官方注释，可以看到源码链接为
vision/torchvision/models/resnet.py at main · pytorch/vision · GitHub
这样就可以看到 class ResNet(nn.Module) 的定义
3 查看权重参数 在PyTorch中，查看深度学习预训练backbone的权重参数可以通过几种方法实现。以下是一些常用的步骤和方法：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T22:49:16+08:00">
    <meta property="article:modified_time" content="2024-07-23T22:49:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pytorch backbone</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1 简介</h3> 
<blockquote> 
 <p>在PyTorch深度学习中，预训练backbone（骨干网络）是一个常见的做法，特别是在处理图像识别、目标检测、图像分割等任务时。预训练backbone通常是指在大型数据集（如ImageNet）上预先训练好的卷积神经网络（CNN）模型，这些模型能够提取图像中的通用特征，这些特征在多种任务中都是有用的。</p> 
 <h4>1. 常见的预训练Backbone</h4> 
 <p>以下是一些在PyTorch中常用的预训练backbone：</p> 
 <ul><li><strong>ResNet</strong>：由何恺明等人提出的深度残差网络，通过引入残差连接解决了深层网络训练中的梯度消失或梯度爆炸问题。ResNet系列包括ResNet-18、ResNet-34、ResNet-50、ResNet-101、ResNet-152等，数字表示网络的层数。</li><li><strong>VGG</strong>：由牛津大学的Visual Geometry Group提出，特点是使用了多个小卷积核（如3x3）的卷积层和池化层来构建深层网络。VGG系列包括VGG16、VGG19等。</li><li><strong>MobileNet</strong>：专为移动和嵌入式设备设计的轻量级网络，通过深度可分离卷积减少了计算量和模型大小。</li><li><strong>DenseNet</strong>：通过密集连接（dense connections）提高了信息流动和梯度传播效率，进一步增强了特征重用。</li><li><strong>EfficientNet</strong>：通过同时缩放网络的深度、宽度和分辨率来优化网络，实现了在保持模型效率的同时提高准确率。</li></ul> 
 <h4>2. 如何使用预训练Backbone</h4> 
 <p>在PyTorch中，使用预训练backbone通常涉及以下几个步骤：</p> 
 <ol><li> <p><strong>导入模型</strong>：使用PyTorch的<code>torchvision.models</code>模块导入所需的预训练模型。</p> <pre><code class="language-python">import torchvision.models as models  

# 导入预训练的ResNet50模型  
resnet50 = models.resnet50(pretrained=True)
print(resnet50)</code></pre> </li><li> <p><strong>修改模型</strong>：根据需要修改模型的最后几层以适应特定的任务（如分类任务中的类别数）。</p> <pre><code class="language-python"># 假设我们有一个100类的分类任务  
num_ftrs = resnet50.fc.in_features  
resnet50.fc = torch.nn.Linear(num_ftrs, 100)</code></pre> </li><li> <p><strong>冻结backbone</strong>：在训练时，可以选择冻结backbone的参数，只训练新添加的层（如分类层），这有助于加快训练速度并防止过拟合。</p> <pre><code class="language-python">for param in resnet50.parameters():  
    param.requires_grad = False  

# 只对新添加的层设置requires_grad=True  
resnet50.fc.parameters().requires_grad = True</code></pre> </li><li> <p><strong>训练模型</strong>：使用适当的数据集和训练策略来训练模型。</p> </li><li> <p><strong>评估模型</strong>：在测试集上评估模型的性能。</p> </li></ol> 
 <h4>3. 注意事项</h4> 
 <ul><li>使用预训练权重时，应确保输入图像的预处理（如大小调整、归一化等）与预训练时使用的预处理一致。</li><li>冻结backbone时，应确保模型的其余部分（如新添加的层）有足够的容量来学习任务特定的特征。</li><li>在某些情况下，解冻backbone的一部分或全部并在目标数据集上进行微调可能会获得更好的性能。</li></ul> 
 <p>通过以上步骤，可以在PyTorch中有效地利用预训练backbone来解决各种计算机视觉任务。</p> 
</blockquote> 
<h3>2 查看模型源码</h3> 
<blockquote> 
 <p>想查看models.resnet50的源码，可以点击查看pytorch中的官方注释，可以看到源码链接为</p> 
 <p><a href="https://github.com/pytorch/vision/blob/main/torchvision/models/resnet.py" title="vision/torchvision/models/resnet.py at main · pytorch/vision · GitHub">vision/torchvision/models/resnet.py at main · pytorch/vision · GitHub</a></p> 
 <p>这样就可以看到 class ResNet(nn.Module) 的定义</p> 
</blockquote> 
<h3>3 查看权重参数</h3> 
<blockquote> 
 <p>在PyTorch中，查看深度学习预训练backbone的权重参数可以通过几种方法实现。以下是一些常用的步骤和方法：</p> 
 <h4>1. 加载预训练模型</h4> 
 <p>首先，你需要使用<code>torchvision.models</code>模块加载所需的预训练模型。例如，加载一个预训练的ResNet50模型：</p> 
 <pre><code class="language-python">import torchvision.models as models  
  
# 加载预训练的ResNet50模型  
resnet50 = models.resnet50(pretrained=True)</code></pre> 
 <h4>2. 查看模型参数</h4> 
 <h5>方法一：使用<code>model.parameters()</code></h5> 
 <p><code>model.parameters()</code>方法返回一个生成器，包含模型的所有参数（权重和偏置）。但是，这个方法不会直接显示参数的名称，只适合在训练循环中迭代参数。</p> 
 <h5>方法二：使用<code>model.named_parameters()</code></h5> 
 <p><code>model.named_parameters()</code>方法返回一个生成器，其中每个元素都是一个包含参数名称和参数本身的元组。这是查看模型每层权重参数及其名称的最直接方法。</p> 
 <pre><code class="language-python">for name, param in resnet50.named_parameters():  
    print(name, param.size())</code></pre> 
 <p>这段代码会遍历模型的所有参数，并打印出每个参数的名称和尺寸。</p> 
 <h4>3. 专注于特定层的参数</h4> 
 <p>如果你只对backbone中的特定层感兴趣，可以进一步筛选<code>named_parameters()</code>的输出。例如，如果你想看ResNet50中第一个卷积层的参数：</p> 
 <pre><code class="language-python">for name, param in resnet50.named_parameters():  
    if 'conv1' in name:  
        print(name, param.size())</code></pre> 
 <h4>4. 注意事项</h4> 
 <ul><li>当查看模型参数时，请确保你了解模型的架构，以便正确地解释参数的名称和尺寸。</li><li>预训练模型的权重是在特定数据集（如ImageNet）上训练的，因此这些权重可能对你的特定任务有所帮助，但也可能需要进一步的微调。</li><li>如果你的模型是基于预训练模型进行修改的（例如，更改了最后一层以匹配不同的类别数），请确保你理解这些修改如何影响模型的参数。</li></ul> 
 <h4>5. 示例输出</h4> 
 <p>运行上述代码（针对ResNet50的<code>named_parameters()</code>）将输出类似以下的信息（输出将非常长，这里只展示部分）：</p> 
 <pre><code class="language-python">conv1.weight torch.Size([64, 3, 7, 7])  
conv1.bias torch.Size([64])  
bn1.weight torch.Size([64])  
bn1.bias torch.Size([64])  
bn1.running_mean torch.Size([64])  
bn1.running_var torch.Size([64])  
...</code></pre> 
 <p>这表示<code>conv1</code>层有一个权重参数（大小为<code>[64, 3, 7, 7]</code>）和一个偏置参数（大小为<code>[64]</code>），以及对应的批量归一化层的权重、偏置、运行均值和运行方差等参数。</p> 
</blockquote> 
<h3 style="background-color:transparent;">4 常见bakcbone以及适用业务</h3> 
<blockquote> 
 <p>在PyTorch中，预训练的backbone模型是深度学习领域中的重要组成部分，它们为各种任务提供了强大的特征提取能力。然而，由于PyTorch本身是一个灵活的深度学习框架，它并不直接提供所有可能的预训练backbone模型，而是由社区和研究者基于PyTorch框架实现并分享。以下是一些常见的PyTorch预训练backbone模型，以及它们的优劣和适用场景：</p> 
 <h4>1. ResNet（残差网络）</h4> 
 <p><strong>优势</strong>：</p> 
 <ul><li>引入了残差连接，解决了深层网络训练中的梯度消失或梯度爆炸问题。</li><li>在多个计算机视觉任务中表现出色，如图像分类、目标检测等。</li></ul> 
 <p><strong>劣势</strong>：</p> 
 <ul><li>对于某些特定任务，可能不是最优选择，需要根据任务特点进行调整。</li></ul> 
 <p><strong>适用场景</strong>：</p> 
 <ul><li>图像分类、目标检测、语义分割等。</li></ul> 
 <h4>2. VGG</h4> 
 <p><strong>优势</strong>：</p> 
 <ul><li>结构简单明了，易于理解和实现。</li><li>在多个基准数据集上取得了良好的性能。</li></ul> 
 <p><strong>劣势</strong>：</p> 
 <ul><li>参数量较大，计算成本较高。</li></ul> 
 <p><strong>适用场景</strong>：</p> 
 <ul><li>早期深度学习研究和教学。</li></ul> 
 <h4>3. MobileNet</h4> 
 <p><strong>优势</strong>：</p> 
 <ul><li>专为移动和嵌入式设备设计，具有较小的模型大小和较快的推理速度。</li><li>采用了深度可分离卷积等技术，减少了计算量和参数量。</li></ul> 
 <p><strong>劣势</strong>：</p> 
 <ul><li>相比于其他大型模型，可能在某些复杂任务上的精度稍低。</li></ul> 
 <p><strong>适用场景</strong>：</p> 
 <ul><li>移动应用、嵌入式设备上的实时图像处理和分类。</li></ul> 
 <h4>4. DenseNet（密集连接网络）</h4> 
 <p><strong>优势</strong>：</p> 
 <ul><li>每一层都直接与后面的所有层相连，增强了特征传播和复用。</li><li>在多个数据集上取得了比ResNet更好的性能。</li></ul> 
 <p><strong>劣势</strong>：</p> 
 <ul><li>参数量和计算量相对较大。</li></ul> 
 <p><strong>适用场景</strong>：</p> 
 <ul><li>需要高精度和强特征表达能力的任务，如医学图像分析。</li></ul> 
 <h4>5. EfficientNet</h4> 
 <p><strong>优势</strong>：</p> 
 <ul><li>通过复合缩放方法（compound scaling）平衡了网络的深度、宽度和分辨率，实现了在有限资源下的最佳性能。</li><li>在多个计算机视觉任务中取得了SOTA（state-of-the-art）性能。</li></ul> 
 <p><strong>劣势</strong>：</p> 
 <ul><li>需要根据具体任务进行微调以获得最佳性能。</li></ul> 
 <p><strong>适用场景</strong>：</p> 
 <ul><li>追求极致性能的计算机视觉任务，如大规模图像分类和检测。</li></ul> 
 <h4>6. YOLOv5的Backbone（如CSPDarknet）</h4> 
 <p><strong>优势</strong>：</p> 
 <ul><li>专为目标检测任务设计，具有较快的推理速度和较高的检测精度。</li><li>采用了CSPNet等结构，进一步提升了网络性能。</li></ul> 
 <p><strong>劣势</strong>：</p> 
 <ul><li>相比于专门的分类网络，可能在分类任务上的性能稍逊。</li></ul> 
 <p><strong>适用场景</strong>：</p> 
 <ul><li>实时目标检测任务，如自动驾驶、视频监控等。</li></ul> 
 <p>请注意，以上列举的backbone模型并不全面，PyTorch社区和研究者们不断在推出新的模型和架构。此外，每种模型都有其特定的优势和劣势，以及适用的场景。在选择模型时，需要根据具体任务的需求、计算资源等因素进行综合考虑。</p> 
 <p>对于PyTorch中预训练backbone模型的获取，可以通过PyTorch的官方模型库（如<code>torchvision</code>）或第三方库（如<code>timm</code>、<code>pretrainedmodels</code>等）来获取。这些库提供了大量预训练的backbone模型，并支持多种加载和使用方式。</p> 
</blockquote> 
<h3>5 从backbone提取特征图(☆)</h3> 
<pre><code class="language-python">import torch
import torch.nn as nn
import torchvision.models as models
from collections import OrderedDict


class ResNet18(nn.Module):
    def __init__(self):
        super().__init__()
        self.resnet18 = models.resnet18(pretrained=True)

    def forward(self, x):
        features = OrderedDict()
        x = self.resnet18.conv1(x)
        x = self.resnet18.bn1(x)
        x = self.resnet18.relu(x)
        x = self.resnet18.maxpool(x)
        features['3'] = x
        x = self.resnet18.layer1(x)
        x = self.resnet18.layer2(x)
        features['2'] = x
        x = self.resnet18.layer3(x)
        features['1'] = x
        x = self.resnet18.layer4(x)
        features['0'] = x
        return features


model = ResNet18()
input = torch.ones(1, 3, 640, 640)  # NCHW
y = model(input)
for key, value in y.items():
    print(key, value.shape)
</code></pre> 
<blockquote> 
 <p>打印信息</p> 
 <p>3 torch.Size([1, 64, 160, 160])<br> 2 torch.Size([1, 128, 80, 80])<br> 1 torch.Size([1, 256, 40, 40])<br> 0 torch.Size([1, 512, 20, 20])</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3001a016e931fbe6f94e0b207fbd7820/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;五子棋（未做完，但能玩，而且还不错）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc45fdc25823ccc4aa2ff15f62bc0476/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】关联容器探秘：Map与Multimap详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>