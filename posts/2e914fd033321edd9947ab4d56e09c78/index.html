<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构的直接插入排序（C语言版） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2e914fd033321edd9947ab4d56e09c78/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构的直接插入排序（C语言版）">
  <meta property="og:description" content="一.直接插入排序的基本概念 1.直接插入排序的基本思想 将数组分为已排序和未排序两部分。
每次从未排序部分取出一个元素,将其插入到已排序部分的合适位置,使得已排序部分保持有序。
重复步骤2,直到整个数组有序。
2.排序的工作原理 假设前 i-1 个元素已经有序,现在要将第 i 个元素插入到前 i-1 个有序元素中,使得前 i 个元素也有序。
为了插入第 i 个元素,需要先找到它在前 i-1 个元素中的适当位置。可以从右到左依次与前面的元素比较,找到第一个小于第 i 个元素的位置。
找到合适的位置后,将第 i 个元素插入到该位置,同时需要将位置之后的元素都向后移动一位。
重复步骤 1-3, 直到整个数组有序。
3.排序的优点 实现简单,编码容易。
对于部分有序的数组,直接插入排序的效率很高。
是一种稳定的排序算法,即相等元素的相对位置不会改变。
在数组规模较小时,直接插入排序的性能优于其他更复杂的排序算法。
4.排序的缺点 时间复杂度为O(n^2),在数据量较大时效率较低。
需要在数组中进行大量的数据移动操作,效率较低。
不适合于元素数量较大的数组排序。如果待排序数组基本有序,直接插入排序的效率会很高,但如果数组越乱,排序效率就会越低。
无法利用cpu的缓存机制,对于大规模数据排序,其性能会明显低于其他排序算法。
5.直接插入排序的功能 将无序数组或部分有序数组排列成升序序列。
维护数组中元素的相对顺序,即相等元素的相对位置不会改变。这使得直接插入排序是一种稳定的排序算法。
适用于小规模数据的排序,当数组规模较小时它的性能比较优秀。
对于部分有序的数组,直接插入排序的效率会很高,因为需要移动的元素较少。
可以改写为降序排序,只需要在插入时改为从后向前比较并插入即可。
可以作为其他排序算法的基础,如希尔排序就是基于直接插入排序改进而来的。
二.直接插入排序的代码实现 void insertionSort(int arr[], int n) { int i, j, key; for (i = 1; i &lt; n; i&#43;&#43;) { key = arr[i]; j = i - 1; /* 将key插入到已排序的数组中 */ while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j &#43; 1] = arr[j]; j = j - 1; } arr[j &#43; 1] = key; } } 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T14:12:21+08:00">
    <meta property="article:modified_time" content="2024-05-27T14:12:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构的直接插入排序（C语言版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="838" src="https://images2.imgbox.com/f8/6a/AkTmjj9h_o.png" width="1000"></p> 
<h2>一.直接插入排序的基本概念</h2> 
<h3>1.直接插入排序的基本思想</h3> 
<ol><li> <p>将数组分为已排序和未排序两部分。</p> </li><li> <p>每次从未排序部分取出一个元素,将其插入到已排序部分的合适位置,使得已排序部分保持有序。</p> </li><li> <p>重复步骤2,直到整个数组有序。</p> </li></ol> 
<h3>2.排序的工作原理</h3> 
<ol><li> <p>假设前 i-1 个元素已经有序,现在要将第 i 个元素插入到前 i-1 个有序元素中,使得前 i 个元素也有序。</p> </li><li> <p>为了插入第 i 个元素,需要先找到它在前 i-1 个元素中的适当位置。可以从右到左依次与前面的元素比较,找到第一个小于第 i 个元素的位置。</p> </li><li> <p>找到合适的位置后,将第 i 个元素插入到该位置,同时需要将位置之后的元素都向后移动一位。</p> </li><li> <p>重复步骤 1-3, 直到整个数组有序。</p> </li></ol> 
<h3>3.排序的优点</h3> 
<ol><li> <p>实现简单,编码容易。</p> </li><li> <p>对于部分有序的数组,直接插入排序的效率很高。</p> </li><li> <p>是一种稳定的排序算法,即相等元素的相对位置不会改变。</p> </li><li> <p>在数组规模较小时,直接插入排序的性能优于其他更复杂的排序算法。</p> </li></ol> 
<h3>4.排序的缺点</h3> 
<ol><li> <p>时间复杂度为O(n^2),在数据量较大时效率较低。</p> </li><li> <p>需要在数组中进行大量的数据移动操作,效率较低。</p> </li><li> <p>不适合于元素数量较大的数组排序。如果待排序数组基本有序,直接插入排序的效率会很高,但如果数组越乱,排序效率就会越低。</p> </li><li> <p>无法利用cpu的缓存机制,对于大规模数据排序,其性能会明显低于其他排序算法。</p> </li></ol> 
<h3>5.直接插入排序的功能</h3> 
<ol><li> <p>将无序数组或部分有序数组排列成升序序列。</p> </li><li> <p>维护数组中元素的相对顺序,即相等元素的相对位置不会改变。这使得直接插入排序是一种稳定的排序算法。</p> </li><li> <p>适用于小规模数据的排序,当数组规模较小时它的性能比较优秀。</p> </li><li> <p>对于部分有序的数组,直接插入排序的效率会很高,因为需要移动的元素较少。</p> </li><li> <p>可以改写为降序排序,只需要在插入时改为从后向前比较并插入即可。</p> </li><li> <p>可以作为其他排序算法的基础,如希尔排序就是基于直接插入排序改进而来的。</p> </li></ol> 
<h2>二.直接插入排序的代码实现</h2> 
<p>                              <img alt="" height="247" src="https://images2.imgbox.com/1a/16/KlyOUYZR_o.png" width="389"></p> 
<pre><code class="language-cpp">void insertionSort(int arr[], int n) {
    int i, j, key;
    for (i = 1; i &lt; n; i++) {
        key = arr[i];
        j = i - 1;

        /* 将key插入到已排序的数组中 */
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}</code></pre> 
<h3>1.直接插入排序算法的工作原理</h3> 
<ol><li> <p><code>insertionSort(int arr[], int n)</code> 函数是直接插入排序的实现。它接受一个整型数组 <code>arr</code> 和数组长度 <code>n</code> 作为参数。</p> </li><li> <p>外层 <code>for</code> 循环从下标为 1 的元素开始遍历数组。这是因为下标为 0 的元素可以认为是一个已排序的子数组。</p> </li><li> <p>在每次外层循环迭代中:</p> 
  <ul><li>将当前元素 <code>arr[i]</code> 保存到变量 <code>key</code> 中。</li><li>将当前元素的前一个下标 <code>i-1</code> 赋给变量 <code>j</code>。这个变量用于在已排序的子数组中找到 <code>key</code> 的插入位置。</li></ul></li><li> <p>内层 <code>while</code> 循环用于在已排序的子数组中找到 <code>key</code> 的插入位置。循环条件是 <code>j &gt;= 0 &amp;&amp; arr[j] &gt; key</code>，即只要 <code>j</code> 不越界且 <code>arr[j]</code> 大于 <code>key</code>，就一直执行循环体。</p> </li><li> <p>在内层循环中:</p> 
  <ul><li>将 <code>arr[j]</code> 向后移动一位,赋值给 <code>arr[j+1]</code>。这相当于为 <code>key</code> 腾出一个位置。</li><li>将 <code>j</code> 减1,继续向前检查已排序的子数组。</li></ul></li><li> <p>当内层循环结束时,也就找到了 <code>key</code> 的合适插入位置 <code>j+1</code>。此时将 <code>key</code> 赋值给 <code>arr[j+1]</code>，完成了插入操作。</p> </li><li> <p><code>main()</code> 函数中创建了一个示例数组 <code>arr</code>，并调用 <code>insertionSort()</code> 函数对其进行排序。</p> </li><li> <p>最后,分别打印排序前后的数组。</p> </li></ol> 
<h3>2.算法的工作过程</h3> 
<ol><li>将数组分为已排序和未排序两部分。</li><li>每次从未排序部分取出一个元素 <code>key</code>。</li><li>在已排序部分中找到 <code>key</code> 的合适插入位置。</li><li>将 <code>key</code> 插入到找到的位置,完成一次插入排序。</li><li>重复步骤2-4,直到整个数组有序。</li></ol> 
<h2>三.直接插入排序的源代码</h2> 
<h3><code>1.insertionSort(int arr[], int n)</code> 函数</h3> 
<ul><li>接受一个整型数组 <code>arr</code> 和数组长度 <code>n</code> 作为输入参数。</li><li>实现直接插入排序算法,将数组 <code>arr</code> 按升序排列。</li></ul> 
<h3>2.算法步骤</h3> 
<ul><li>从数组的第二个元素开始遍历 (<code>i = 1</code>到<code>n-1</code>).</li><li>对于当前元素 <code>arr[i]</code>, 将其保存在变量 <code>key</code> 中.</li><li>设置一个指针 <code>j</code> 指向当前元素的前一个位置 (<code>j = i-1</code>).</li><li>从 <code>j</code> 开始向前遍历已排序子数组, 将大于 <code>key</code> 的元素都向后移动一位 (<code>while (j &gt;= 0 &amp;&amp; arr[j] &gt; key)</code>).</li><li>找到 <code>key</code> 的正确插入位置后, 将 <code>key</code> 插入到该位置 (<code>arr[j+1] = key</code>).</li></ul> 
<h3>3.<code>main()</code> 函数</h3> 
<ul><li>定义一个整型数组 <code>arr</code> 并计算其长度 <code>n</code>.</li><li>打印原始数组.</li><li>调用 <code>insertionSort()</code> 函数对数组进行排序.</li><li>打印排序后的数组.</li></ul> 
<p><strong><span style="color:#fe2c24;">通过这段代码,我们可以看到直接插入排序的具体实现过程。它将数组分为已排序和未排序两部分,并且每次从未排序部分取出一个元素,找到它在已排序部分的正确位置并插入。这种简单高效的排序方法在小规模数据和部分有序数组中表现出色。</span></strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

void insertionSort(int arr[], int n) {
    int i, j, key;
    for (i = 1; i &lt; n; i++) {
        key = arr[i];
        j = i - 1;

        /* 将key插入到已排序的数组中 */
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("原始数组: ");
    for (int i = 0; i &lt; n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    insertionSort(arr, n);

    printf("排序后的数组: ");
    for (int i = 0; i &lt; n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e97488eb5ddf3a9f6e327bd240bf3599/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【vscode 怎么实现ctrl&#43;鼠标左键点击模组，能够进入PYTHONPATH(第三方)的模组里面】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d16974cd64f2ffe6bb9c1efd015b4f6a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于小波熵阈值的心电信号R波检测算法（MATLAB）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>