<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【海贼王的数据航海】栈和队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0039b73fe2105cff9bbb4529d16654cc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【海贼王的数据航海】栈和队列">
  <meta property="og:description" content="目录
1 -&gt; 栈
1.1 -&gt; 栈的概念及结构
1.2 -&gt; 栈的实现
1.2.1 -&gt; Stack.h
1.2.2 -&gt; Stack.c
1.2.3 -&gt; Test.c
2 -&gt; 队列
2.1 -&gt; 队列的概念及结构
2.2 -&gt; 队列的实现
2.2.1 -&gt; Queue.h
2.2.2 -&gt; Queue.c
1 -&gt; 栈 1.1 -&gt; 栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO(Last In First Out)的原则。
压栈：栈的插入操作叫进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
1.2 -&gt; 栈的实现 栈的实现一般可以使用数组或链表实现，相对而言数组的结构实现更优。因为数组在尾上插入数据的代价比较小。
1.2.1 -&gt; Stack.h #pragma once #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;stdbool.h&gt; // 定长的静态栈的结构，实际中一般不实用 //typedef int STDataType; //#define N 10 //typedef struct Stack //{ //	STDataType a[N]; //	int top; //}ST; // 动态增长的栈 typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; // 栈的初始化 void STInit(ST* pst); // 栈的销毁 void STDestroy(ST* pst); // 入栈 void STPush(ST* pst, STDataType x); // 出栈 void STPop(ST* pst); // 获取栈顶元素 STDataType STTop(ST* pst); // 判空 bool STEmpty(ST* pst); // 栈的有效元素个数 int STSize(ST* pst); 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-13T19:42:58+08:00">
    <meta property="article:modified_time" content="2024-03-13T19:42:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【海贼王的数据航海】栈和队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%20-%3E%20%E6%A0%88-toc" style="margin-left:0px;"><strong><a href="#1%20-%3E%20%E6%A0%88" rel="nofollow"><span style="color:#be191c;">1 -&gt; 栈</span></a></strong></p> 
<p id="1.1%20-%3E%20%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><strong><a href="#1.1%20-%3E%20%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow"><span style="color:#be191c;">1.1 -&gt; 栈的概念及结构</span></a></strong></p> 
<p id="1.2%20-%3E%20%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#1.2%20-%3E%20%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow"><span style="color:#be191c;">1.2 -&gt; 栈的实现</span></a></strong></p> 
<p id="1.2.1%20-%3E%20Stack.h-toc" style="margin-left:80px;"><strong><a href="#1.2.1%20-%3E%20Stack.h" rel="nofollow"><span style="color:#be191c;">1.2.1 -&gt; Stack.h</span></a></strong></p> 
<p id="1.2.2%20-%3E%20Stack.c-toc" style="margin-left:80px;"><strong><a href="#1.2.2%20-%3E%20Stack.c" rel="nofollow"><span style="color:#be191c;">1.2.2 -&gt; Stack.c</span></a></strong></p> 
<p id="1.2.3%20-%3E%20Test.c-toc" style="margin-left:80px;"><strong><a href="#1.2.3%20-%3E%20Test.c" rel="nofollow"><span style="color:#be191c;">1.2.3 -&gt; Test.c</span></a></strong></p> 
<p id="2%20-%3E%20%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><strong><a href="#2%20-%3E%20%E9%98%9F%E5%88%97" rel="nofollow"><span style="color:#be191c;">2 -&gt; 队列</span></a></strong></p> 
<p id="2.1%20-%3E%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><strong><a href="#2.1%20-%3E%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow"><span style="color:#be191c;">2.1 -&gt; 队列的概念及结构</span></a></strong></p> 
<p id="2.2%20-%3E%20%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#2.2%20-%3E%20%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow"><span style="color:#be191c;">2.2 -&gt; 队列的实现</span></a></strong></p> 
<p id="2.2.1%20-%3E%20Queue.h-toc" style="margin-left:80px;"><strong><a href="#2.2.1%20-%3E%20Queue.h" rel="nofollow"><span style="color:#be191c;">2.2.1 -&gt; Queue.h</span></a></strong></p> 
<p id="2.2.2%20-%3E%20Queue.c-toc" style="margin-left:80px;"><strong><a href="#2.2.2%20-%3E%20Queue.c" rel="nofollow"><span style="color:#be191c;">2.2.2 -&gt; Queue.c</span></a></strong></p> 
<hr> 
<p><img alt="" height="803" src="https://images2.imgbox.com/25/a1/68skjBIX_o.png" width="1064"></p> 
<h2>1 -&gt; 栈</h2> 
<h3 id="1.1%20-%3E%20%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.1 -&gt; 栈的概念及结构</h3> 
<p><span style="color:#6eaad7;">栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。<strong>进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。</strong>栈中的数据元素遵守后进先出LIFO(Last In First Out)的原则。</span></p> 
<p><span style="color:#6eaad7;">压栈：栈的插入操作叫进栈/压栈/入栈，<strong>入数据在栈顶。</strong></span></p> 
<p><span style="color:#6eaad7;">出栈：栈的删除操作叫做出栈。<strong>出数据也在栈顶。</strong></span></p> 
<p class="img-center"><img alt="" height="383" src="https://images2.imgbox.com/27/ae/aNDfne1O_o.png" width="936"></p> 
<p class="img-center"><img alt="" height="524" src="https://images2.imgbox.com/30/49/oZlHwXVc_o.png" width="478"></p> 
<h3 id="1.2%20-%3E%20%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0">1.2 -&gt; 栈的实现</h3> 
<p><span style="color:#6eaad7;">栈的实现一般可以使用数组或链表实现，相对而言数组的结构实现更优。因为数组在尾上插入数据的代价比较小。</span></p> 
<p class="img-center"><img alt="" height="143" src="https://images2.imgbox.com/88/06/IeLrbETb_o.png" width="626"></p> 
<p class="img-center"><img alt="" height="351" src="https://images2.imgbox.com/4b/2e/PL1aHz76_o.png" width="501"></p> 
<h4 id="1.2.1%20-%3E%20Stack.h">1.2.1 -&gt; Stack.h</h4> 
<pre><code>#pragma once

#define  _CRT_SECURE_NO_WARNINGS 1

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdbool.h&gt;

// 定长的静态栈的结构，实际中一般不实用
//typedef int STDataType;
//#define N 10
//typedef struct Stack
//{
//	STDataType a[N];
//	int top;
//}ST;

// 动态增长的栈
typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;

// 栈的初始化
void STInit(ST* pst);

// 栈的销毁
void STDestroy(ST* pst);

// 入栈
void STPush(ST* pst, STDataType x);

// 出栈
void STPop(ST* pst);

// 获取栈顶元素
STDataType STTop(ST* pst);

// 判空
bool STEmpty(ST* pst);

// 栈的有效元素个数
int STSize(ST* pst);</code></pre> 
<h4 id="1.2.2%20-%3E%20Stack.c">1.2.2 -&gt; Stack.c</h4> 
<pre><code>#include "Stack.h"

// 栈的初始化
void STInit(ST* pst)
{
	assert(pst);

	pst-&gt;a = NULL;
	pst-&gt;top = 0;
	pst-&gt;capacity = 0;
}

// 栈的销毁
void STDestroy(ST* pst)
{
	assert(pst);

	free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;top = 0;
	pst-&gt;capacity = 0;
}

// 入栈
void STPush(ST* pst, STDataType x)
{
	if (pst-&gt;top == pst-&gt;capacity)
	{
		int newCapacity = pst-&gt;capacity == 0 ? 4 : pst-&gt;capacity * 2;
		STDataType* tmp = (STDataType*)realloc(pst-&gt;a, newCapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}

		pst-&gt;a = tmp;
		pst-&gt;capacity = newCapacity;
	}

	pst-&gt;a[pst-&gt;top] = x;
	pst-&gt;top++;
}

// 出栈
void STPop(ST* pst)
{
	assert(pst);
	assert(!STEmpty(pst));

	pst-&gt;top--;
}

// 获取栈顶元素
STDataType STTop(ST* pst)
{
	assert(pst);
	assert(!STEmpty(pst));

	return pst-&gt;a[pst-&gt;top - 1];
}

// 判空
bool STEmpty(ST* pst)
{
	assert(pst);

	return pst-&gt;top == 0;
}

// 栈的有效元素个数
int STSize(ST* pst)
{
	assert(pst);

	return pst-&gt;top;
}</code></pre> 
<h4 id="1.2.3%20-%3E%20Test.c">1.2.3 -&gt; Test.c</h4> 
<pre><code>#include "Stack.h"

void Test1()
{
	ST st;
	STInit(&amp;st);

	STPush(&amp;st, 1);
	STPush(&amp;st, 2);
	printf("%d\n", STTop(&amp;st));
	STTop(&amp;st);
	STPush(&amp;st, 3);
	STPush(&amp;st, 4);
	STPush(&amp;st, 5);

	while (!STEmpty(&amp;st))
	{
		printf("%d ", STTop(&amp;st));
		STPop(&amp;st);
	}

	STDestroy(&amp;st);
}

int main()
{

	Test1();

	return 0;
}</code></pre> 
<h2 id="2%20-%3E%20%E9%98%9F%E5%88%97">2 -&gt; 队列</h2> 
<h3 id="2.1%20-%3E%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">2.1 -&gt; 队列的概念及结构</h3> 
<p><span style="color:#6eaad7;">队列：只允许一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out)。</span></p> 
<p><span style="color:#6eaad7;">入队列：进行插入操作的一端称为<strong>队尾</strong>。</span></p> 
<p><span style="color:#6eaad7;">出队列：进行删除操作的一端称为<strong>队头</strong>。</span></p> 
<p class="img-center"><img alt="" height="298" src="https://images2.imgbox.com/ad/4e/HDPyLqW7_o.png" width="589"></p> 
<h3 id="2.2%20-%3E%20%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">2.2 -&gt; 队列的实现</h3> 
<p><span style="color:#6eaad7;">队列也可以用数组和链表的结构实现，使用链表的结构实现更优，因为如果使用数组的结构，出队列在数组头上出数据，效率较低。</span></p> 
<p class="img-center"><img alt="" height="390" src="https://images2.imgbox.com/c5/91/0OZxmt3n_o.png" width="606"></p> 
<h4 id="2.2.1%20-%3E%20Queue.h">2.2.1 -&gt; Queue.h</h4> 
<pre><code>#pragma once

#define  _CRT_SECURE_NO_WARNINGS 1

#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

// 链式结构: 表示队列
typedef int QDataType;

typedef struct QueueNode
{
	struct QueueNode* next;
	QDataType data;
}QNode;

typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;

// 队列的初始化
void QueueInit(Queue* pq);

// 队列的销毁
void QueueDestroy(Queue* pq);

// 队尾入队列
void QueuePush(Queue* pq, QDataType x);

// 队头出队列
void QueuePop(Queue* pq);

// 获取队头元素
QDataType QueueFront(Queue* pq);

// 获取队尾元素
QDataType QueueBack(Queue* pq);

// 获取队列中有效元素个数
int QueueSize(Queue* pq);

// 判空
bool QueueEmpty(Queue* pq);</code></pre> 
<h4 id="2.2.2%20-%3E%20Queue.c">2.2.2 -&gt; Queue.c</h4> 
<pre><code>#include "Queue.h"

// 队列的初始化
void QueueInit(Queue* pq)
{
	assert(pq);

	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}

// 队列的销毁
void QueueDestroy(Queue* pq)
{
	assert(pq);

	QNode* cur = pq-&gt;phead;
	while (cur)
	{
		QNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}

	pq-&gt;phead = NULL;
	pq-&gt;ptail = NULL;
	pq-&gt;size = 0;
}

// 队尾入队列
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);

	QNode* newnode = (QNode*)malloc(sizeof(QNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return;
	}

	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	if (pq-&gt;ptail == NULL)
	{
		assert(pq-&gt;phead == NULL);

		pq-&gt;phead = newnode;
		pq-&gt;ptail = newnode;
	}
	else
	{
		pq-&gt;ptail-&gt;next = newnode;
		pq-&gt;ptail = newnode;
	}

	pq-&gt;size++;
}

// 队头出队列
void QueuePop(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));

	if (pq-&gt;phead-&gt;next == NULL)
	{
		free(pq-&gt;phead);
		pq-&gt;phead = NULL;
		pq-&gt;ptail = NULL;
	}
	else
	{
		QNode* next = pq-&gt;phead-&gt;next;

		free(pq-&gt;phead);
	
		pq-&gt;phead = next;
	}

	pq-&gt;size--;
}

// 获取队头元素
QDataType QueueFront(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));

	return pq-&gt;phead-&gt;data;
}

// 获取队尾元素
QDataType QueueBack(Queue* pq)
{
	assert(pq);
	assert(!QueueEmpty(pq));

	return pq-&gt;ptail-&gt;data;
}

// 获取队列中有效元素个数
int QueueSize(Queue* pq)
{
	assert(pq);

	return pq-&gt;size;
}

// 判空
bool QueueEmpty(Queue* pq)
{
	assert(pq);

	return pq-&gt;size == 0;
}</code></pre> 
<hr> 
<p></p> 
<p></p> 
<p style="text-align:center;"><span style="color:#1c7331;"><strong>感谢各位大佬支持！！！</strong></span></p> 
<p style="text-align:center;"><span style="color:#1c7331;"><strong>互三啦！！！</strong></span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94da45907ff04835ebfb71d6cbf86e2d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python之格式化输出format()函数使用总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1cee8a023a591d207d32d16fb96bd2b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】string进一步介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>