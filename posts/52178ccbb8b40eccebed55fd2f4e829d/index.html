<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>操作系统课程设计——文件管理模拟 C&#43;&#43;版 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/52178ccbb8b40eccebed55fd2f4e829d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="操作系统课程设计——文件管理模拟 C&#43;&#43;版">
  <meta property="og:description" content="参考博客：【操作系统之模拟文件管理系统 - CSDN App】
并在此基础上进行了修改和完善部分代码
这是我的第一篇CSDN，内容有点长
实验内容 文件管理
一、目的
通过模拟磁盘，完成操作系统的文件管理功能，掌握包括目录结构的管理、外存空【操作系统之模拟文件管理系统 - CSDN App】间的分配与释放以及空闲空间管理三部分。为写入模拟磁盘的数据文件建立目录，目录可以是单级文件目录、双级文件目录、树形结构目录。在目录中选择某个文件可以将其数据读入模拟内存。
二、设计内容
通过初始化操作建立一个模拟磁盘，在模拟磁盘中保存目录和文件内容。创建该模拟磁盘时可创建初始的根目录内容、文件分配表。文件目录项（可以采用FCB格式）应包括文件名、类型（目录 or文件）、创建日期、大小、第一个磁盘块块号。目录管理需支持：
新建目录：在目录中新建空目录； 删除目录：删除空目录
为文件建立目录项：一个文件创建成功后，为该文件创建目录项，并将文件和相关信息写入目录；
删除文件：删除目录中某个文件，删除其在磁盘中的数据，并删除目录项。如果被删除文件已经读入内存应阻止删除，完成基本的文件保护。 三、 设计要求
不同的功能使用不同的函数实现（模块化），对每个函数的功能和调用接口要注释清楚。对程序其它部分也进行必要的注释。对系统进行功能模块分析、画出总流程图和各模块流程图。用户界面要求使用方便、简洁明了、美观大方、格式统一。所有功能可以反复使用，最好使用菜单。通过命令行相应选项能直接进入某个相应菜单选项的功能模块。所有程序需调试通过。 实验说明 本实验是参考了http://t.csdnimg.cn/B0Fqh
，并在此基础上进行了修改和完善部分代码。
本次实验为Linux系统设计了一个简单的二级文件系统，可以做到以下几点：
可用命令及说明 register 用户的注册login 用户的登入cd 切换目录mkdir 创建用户的子目录rmdir 删除用户的子目录dir 显示当前目录的子目录create 创建文件夹的文件del 删除文件夹的文件open 打开文件close 关闭文件read 读文件write 写文件set 设置文件的保护码exit 退出系统look 查看系统中的所有用户fatused 查看目前块的状态用户登入时会对用户名和密码进行匹配进入系统的第一步需要注册账号并登入（为测试方便，初始化了一个用户）在创建子目录时必须先登入不可在打开的状态下进行任何删除操作删除子目录或文件时释放其空间创建文件和打开文件时必须先进入文件夹文件被打开后可进行读写操作文件保护码为2可读可写，为0不可读，其他不可写 文件结构 这些图表是我的一点理解，可能存在偏差
用户文件结构
​
打开文件结构
​
创建文件流程图
​
删除文件流程图
​
代码说明 整体结构 #define BLOCK_SIZE 512 //每一个磁盘块的大小 #define BLOCK_NUM 64 //磁盘块数量 #define MAX_FILE_NUM	16 //每个文件夹的最大文件数 #define MAX_FOLDER_NUM 16	//每个用户可以拥有的最大文件夹数 #define MAX_OPEN_FILE_NUM 16	//最大同时打开文件数 #define MAX_USER_NUM	16 //最大用户数 主目录 存放用户数据结构 最大可存放16个用户用户名密码指向用户的指针 struct MFD//用户数据结构 { string username;//用户名 string password;//密码 struct USER_UFD *next;//指向用户文件的指针 }; 子目录（文件夹数据结构）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-05T21:28:02+08:00">
    <meta property="article:modified_time" content="2024-01-05T21:28:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">操作系统课程设计——文件管理模拟 C&#43;&#43;版</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考博客：<a class="link-info" href="http://t.csdnimg.cn/B0Fqh" rel="nofollow" title="【操作系统之模拟文件管理系统 - CSDN App】">【操作系统之模拟文件管理系统 - CSDN App】</a></p> 
<p>并在此基础上进行了修改和完善部分代码</p> 
<p>这是我的第一篇CSDN，内容有点长</p> 
<hr> 
<h3 id="%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9" style="background-color:transparent;">实验内容</h3> 
<p><strong>文件管理</strong></p> 
<p>一、目的</p> 
<p>通过模拟磁盘，完成操作系统的文件管理功能，掌握包括目录结构的管理、外存空<a class="link-info" href="http://t.csdnimg.cn/B0Fqh" rel="nofollow" title="【操作系统之模拟文件管理系统 - CSDN App】">【操作系统之模拟文件管理系统 - CSDN App】</a>间的分配与释放以及空闲空间管理三部分。为写入模拟磁盘的数据文件建立目录，目录可以是单级文件目录、双级文件目录、树形结构目录。在目录中选择某个文件可以将其数据读入模拟内存。</p> 
<p>二、设计内容</p> 
<ol><li>通过初始化操作建立一个模拟磁盘，在模拟磁盘中保存目录和文件内容。创建该模拟磁盘时可创建初始的根目录内容、文件分配表。</li><li>文件目录项（可以采用FCB格式）应包括文件名、类型（目录 or文件）、创建日期、大小、第一个磁盘块块号。</li><li>目录管理需支持：<br> 新建目录：在目录中新建空目录； 删除目录：删除空目录<br> 为文件建立目录项：一个文件创建成功后，为该文件创建目录项，并将文件和相关信息写入目录；<br> 删除文件：删除目录中某个文件，删除其在磁盘中的数据，并删除目录项。如果被删除文件已经读入内存应阻止删除，完成基本的文件保护。</li></ol> 
<p>三、 设计要求</p> 
<ol><li>不同的功能使用不同的函数实现（模块化），对每个函数的功能和调用接口要注释清楚。对程序其它部分也进行必要的注释。</li><li>对系统进行功能模块分析、画出总流程图和各模块流程图。</li><li>用户界面要求使用方便、简洁明了、美观大方、格式统一。所有功能可以反复使用，最好使用菜单。</li><li>通过命令行相应选项能直接进入某个相应菜单选项的功能模块。</li><li>所有程序需调试通过。</li></ol> 
<h3 id="%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E" style="background-color:transparent;">实验说明</h3> 
<p>本实验是参考了<a href="http://t.csdnimg.cn/B0Fqh" rel="nofollow" title="http://t.csdnimg.cn/B0Fqh">http://t.csdnimg.cn/B0Fqh</a><br>  ，并在此基础上进行了修改和完善部分代码。</p> 
<p>本次实验为Linux系统设计了一个简单的二级文件系统，可以做到以下几点：</p> 
<ol><li>可用命令及说明 
  <ul><li>register 用户的注册</li><li>login 用户的登入</li><li>cd 切换目录</li><li>mkdir 创建用户的子目录</li><li>rmdir 删除用户的子目录</li><li>dir 显示当前目录的子目录</li><li>create 创建文件夹的文件</li><li>del 删除文件夹的文件</li><li>open 打开文件</li><li>close 关闭文件</li><li>read 读文件</li><li>write 写文件</li><li>set 设置文件的保护码</li><li>exit 退出系统</li><li>look 查看系统中的所有用户</li><li>fatused 查看目前块的状态</li></ul></li><li>用户登入时会对用户名和密码进行匹配</li><li>进入系统的第一步需要注册账号并登入（为测试方便，初始化了一个用户）</li><li>在创建子目录时必须先登入</li><li>不可在打开的状态下进行任何删除操作</li><li>删除子目录或文件时释放其空间</li><li>创建文件和打开文件时必须先进入文件夹</li><li>文件被打开后可进行读写操作</li><li>文件保护码为2可读可写，为0不可读，其他不可写</li></ol> 
<h3 id="%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" style="background-color:transparent;">文件结构</h3> 
<p>这些图表是我的一点理解，可能存在偏差</p> 
<p>用户文件结构</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/40/e5/goA3D1pS_o.jpg"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p>打开文件结构</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ab/9a/PMBhfWEb_o.jpg"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p>创建文件流程图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e2/00/aXtN78qU_o.jpg"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p>删除文件流程图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a3/80/zXa0lanr_o.jpg"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p></p> 
<h3 id="%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E">代码说明</h3> 
<h4 id="%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84">整体结构</h4> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE     		512  <span class="hljs-comment">//每一个磁盘块的大小</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_NUM       	64   <span class="hljs-comment">//磁盘块数量</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FILE_NUM		16   <span class="hljs-comment">//每个文件夹的最大文件数</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FOLDER_NUM  	16	 <span class="hljs-comment">//每个用户可以拥有的最大文件夹数</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_OPEN_FILE_NUM   16	 <span class="hljs-comment">//最大同时打开文件数</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_USER_NUM		16   <span class="hljs-comment">//最大用户数</span></span></code></pre> 
</div> 
<p></p> 
<ul><li>主目录 
  <ul><li>存放用户数据结构 最大可存放16个用户</li><li>用户名</li><li>密码</li><li>指向用户的指针</li></ul></li></ul> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-keyword">struct</span> <span class="class_ hljs-title">MFD</span><span class="hljs-comment">//用户数据结构</span>
{
string username;<span class="hljs-comment">//用户名</span>
string password;<span class="hljs-comment">//密码</span>
<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">USER_UFD</span> *next;<span class="hljs-comment">//指向用户文件的指针</span>
};</code></pre> 
</div> 
<p></p> 
<ul><li> <p>子目录（文件夹数据结构）</p> 
  <ul><li>各个用户所拥有的目录</li><li>最大创建16个目录（及文件）</li><li>其中包含文件数据结构</li><li>文件夹名字</li><li>当前文件夹的文件数</li></ul></li><li> <p>文件数据结构</p> 
  <ul><li>文件名（同文件下不可重名）</li><li>文件保护码（默认为2 可读可写，为0 不可读）</li><li>文件长度（长度超过块的存储范围会找下一个块）</li><li>文件起始地址</li><li>文件创建日期</li><li>是否占用</li></ul></li></ul> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-keyword">struct</span> <span class="class_ hljs-title">UFD</span><span class="hljs-comment">//文件夹数据结构 </span>
{
	<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">file_message</span><span class="hljs-comment">//文件数据结构</span>
	{
		string filename;<span class="hljs-comment">//文件名</span>
		<span class="hljs-type">int</span> protect_code;<span class="hljs-comment">//文件保护码</span>
		<span class="hljs-type">int</span> length;<span class="hljs-comment">//文件长度</span>
		<span class="hljs-type">int</span> addr;<span class="hljs-comment">//文件起始地址</span>
		string time;	<span class="hljs-comment">//日期时间，格式为yyyymmdd hhmmss</span>
        <span class="hljs-type">int</span> used;<span class="hljs-comment">//是否被占用 0：空闲 1：占用</span>
	}ufd[MAX_FILE_NUM];<span class="hljs-comment">//一个文件夹最对可以有16个文件</span>
	string directname;<span class="hljs-comment">//文件夹名字</span>
	<span class="hljs-type">int</span> cur_file_size = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前该文件夹含有的文件数量</span>
};</code></pre> 
</div> 
<p></p> 
<ul><li>打开的文件数据结构 
  <ul><li>最多打开16个文件</li><li>文件名字</li><li>文件长度</li><li>文件保护码</li><li>文件起始地址</li><li>当前打开的文件数量</li></ul></li></ul> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-keyword">struct</span> <span class="class_ hljs-title">UOF</span><span class="hljs-comment">//打开文件数据结构</span>
{
	<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">uof</span>
	{
		string filename;<span class="hljs-comment">//文件名字</span>
		<span class="hljs-type">int</span> pointer;<span class="hljs-comment">//文件长度</span>
		<span class="hljs-type">int</span> protect_code;<span class="hljs-comment">//文件保护码  默认2  2为可读可写  0为不可读  其余数字不可写</span>
		<span class="hljs-type">int</span> addr;<span class="hljs-comment">//文件起始地址</span>
	}uof[MAX_OPEN_FILE_NUM];<span class="hljs-comment">//最多可以同时打开16个文</span>
	<span class="hljs-type">int</span> cur_openfilesize = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前打开的文件数量</span>
};</code></pre> 
</div> 
<p></p> 
<ul><li>块号数据结构 
  <ul><li>存放下一页的块号</li><li>块号的状态 （1 占用; 0 空闲）</li></ul></li></ul> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-keyword">struct</span> <span class="class_ hljs-title">fat</span><span class="hljs-comment">//块号</span>
{
	<span class="hljs-type">int</span> next = <span class="hljs-number">-1</span>;<span class="hljs-comment">//存放下一页的块号，无为-1</span>
	<span class="hljs-type">int</span> used = <span class="hljs-number">0</span>;  <span class="hljs-comment">//used存在三种状态，1：被占用 0：空闲</span>
}fat[BLOCK_NUM];<span class="hljs-comment">//最大为64</span></code></pre> 
</div> 
<p></p> 
<ul><li>用户文件数据结构 
  <ul><li>包含文件夹数据结构</li><li>当前拥有的文件夹数量</li></ul></li></ul> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-keyword">struct</span> <span class="class_ hljs-title">USER_UFD</span><span class="hljs-comment">//用户文件数据结构</span>
{
	<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">UFD</span> direct[MAX_FOLDER_NUM];<span class="hljs-comment">//一个用户最多可以有16个文件夹</span>
	<span class="hljs-type">int</span> cur_user_direct_size = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前拥有的文件夹数量</span>
};</code></pre> 
</div> 
<p></p> 
<h4 id="%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%8F%8A%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">定义属性及函数声明</h4> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-type">int</span> mark = <span class="hljs-number">1</span>;
<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">USER_UFD</span> cur_user_all_direct_array[MAX_USER_NUM];<span class="hljs-comment">//用户文件数组 16</span>
<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">MFD</span> cur_user;<span class="hljs-comment">//当前用户</span>
<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">UOF</span> * cur_opentable;<span class="hljs-comment">//指向打开文件数组的指针</span>
<span class="hljs-type">char</span> *fdisk;<span class="hljs-comment">//模拟磁盘指针</span>
<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">UOF</span> openfile[MAX_OPEN_FILE_NUM];<span class="hljs-comment">//每一个用户对应一个文件打开表对象，16</span>
<span class="hljs-keyword">struct</span> <span class="class_ hljs-title">MFD</span> mfd[MAX_USER_NUM]; <span class="hljs-comment">//16个用户</span>
<span class="hljs-type">int</span> cur_user_size = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录当前用户的人数</span>
string path;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">REGISTER</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//注册用户</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LOGIN</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//登录用户</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CREATE</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">//创建文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DELETE</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">//删除文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OPEN</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">//打开文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">WRITE</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">//写文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">READ</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">//读文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CLOSE</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">//关闭文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CD</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//更改当前目录</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MKDIR</span><span class="hljs-params">(string name)</span></span>;<span class="hljs-comment">//创建文件夹</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DIR</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//显示当前目录的子目录</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SET</span><span class="hljs-params">(string name, <span class="hljs-type">int</span> protectcode)</span></span>;<span class="hljs-comment">//设置保护码</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">INPUT_OPERATION</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//指令输入</span></code></pre> 
</div> 
<h4 id="main%E5%87%BD%E6%95%B0">main函数</h4> 
<p>初始化一个用户方便调试代码<br> 并输出命令格式说明</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	cur_user.username = <span class="hljs-string">""</span>;
	path = <span class="hljs-string">""</span>;
	fdisk = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//模拟硬盘指针</span>
	
	<span class="hljs-comment">//注册root用户并登录，方便调试代码</span>
	mfd[cur_user_size].username = <span class="hljs-string">"root"</span>;
	mfd[cur_user_size].password = <span class="hljs-string">"123456"</span>;
	cur_user_size++;
	mfd[<span class="hljs-number">0</span>].next = &amp;(cur_user_all_direct_array[<span class="hljs-number">0</span>]);	
	cur_user = mfd[<span class="hljs-number">0</span>];
	cur_user.next-&gt;cur_user_direct_size = mfd[<span class="hljs-number">0</span>].next-&gt;cur_user_direct_size;
	cur_user_size++;
	cur_opentable = &amp;openfile[cur_user_size]; <span class="hljs-comment">//指针指向文件打开表对象</span>
	cur_opentable-&gt;cur_openfilesize = <span class="hljs-number">0</span>;
	
	cout &lt;&lt; <span class="hljs-string">"*******************欢迎使用二级文件系统*******************"</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        命令格式                说明                      "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        register                注册用户                  "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        login                   登录                      "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        cd 目录名               更改当前目录              "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        mkdir 目录名            创建子目录                "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        rmdir 目录名            删除子目录                "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        dir                     显示当前目录的子目录      "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        create 文件名           创建文件                  "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        del 文件名              删除文件                  "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        open 文件名             打开文件                  "</span> &lt;&lt; endl;		
	cout &lt;&lt; <span class="hljs-string">"        close                   关闭文件                  "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        read 文件名               读文件                    "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        write 文件名              写文件                    "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        set 文件名 文件保护码   设置文件保护码            "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        exit                    退出系统                  "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        look                    查看用户                 "</span> &lt;&lt; endl;
	cout &lt;&lt; <span class="hljs-string">"        fatused                 查看块                 "</span> &lt;&lt; endl;
	<span class="hljs-keyword">while</span> (mark)
		<span class="hljs-built_in">INPUT_OPERATION</span>();
	<span class="hljs-built_in">free</span>(fdisk);
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<h4 id="input_operation%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4%E8%BE%93%E5%85%A5">INPUT_OPERATION函数（指令输入）</h4> 
<blockquote> 
 <p>开始运行文件管理系统时是未登入的状态（现在代码是默认初始化一个用户）<br> 未登录时显示<code>localhost :</code><br> 登入后显示<code>cur_user.username@localhost home/ path：</code>(用户名+@localhost home/： )刚登入时<code>path=""</code><br> 然后通过<code>cin &gt;&gt; operaton;</code>输入控制语句，进行匹配调用不同的函数</p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">INPUT_OPERATION</span><span class="hljs-params">()</span><span class="hljs-comment">//指令输入</span>
</span>{
	<span class="hljs-keyword">if</span> (cur_user.username == <span class="hljs-string">""</span>)
		cout &lt;&lt; <span class="hljs-string">"localhost :"</span>;
	<span class="hljs-keyword">else</span>
		cout &lt;&lt; cur_user.username &lt;&lt; <span class="hljs-string">"@localhost  home/"</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">":"</span>;
	string operaton;
	cin &gt;&gt; operaton;
	<span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"login"</span>)
	{
		<span class="hljs-built_in">LOGIN</span>();
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"create"</span>)
	{
		string filename;
		cin &gt;&gt; filename;
		<span class="hljs-built_in">CREATE</span>(filename);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"del"</span>)
	{
		string name;
		cin &gt;&gt; name;
		<span class="hljs-built_in">DELETE</span>(name, <span class="hljs-number">-1</span>);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"open"</span>)
	{
		string name;
		cin &gt;&gt; name;
		<span class="hljs-built_in">OPEN</span>(name);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"close"</span>)
	{
		string name;
		cin &gt;&gt; name;
		<span class="hljs-built_in">CLOSE</span>(name);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"write"</span>)
	{
		string content;
		string name;
		cin &gt;&gt; name;
		<span class="hljs-built_in">WRITE</span>(name);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"read"</span>)
	{
		string name;
		cin &gt;&gt; name;
		<span class="hljs-built_in">READ</span>(name);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"exit"</span>)
	{
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"cd"</span>)
	{
	<span class="hljs-built_in">CD</span>();
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"dir"</span>)
	{
		<span class="hljs-built_in">DIR</span>();
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"mkdir"</span>)
	{
		string name;
		cin &gt;&gt; name;
		<span class="hljs-built_in">MKDIR</span>(name);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"register"</span>)
	{
		<span class="hljs-built_in">REGISTER</span>();
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"exit"</span>)
	{
		mark = <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"set"</span>)
	{
		string name;
		<span class="hljs-type">int</span> protextcode;
		cin &gt;&gt; name;
		cin &gt;&gt; protextcode;
		<span class="hljs-built_in">SET</span>(name, protextcode);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"rmdir"</span>)
	{
		string name;
		cin &gt;&gt; name;
		<span class="hljs-built_in">RMDIR</span>(name);
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"look"</span>)
	{
		<span class="hljs-built_in">LOOK</span>();
	}
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operaton == <span class="hljs-string">"fatused"</span>)
	{
		<span class="hljs-built_in">fatused</span>();
	}
	<span class="hljs-keyword">else</span>
	{
		cout &lt;&lt; <span class="hljs-string">"命令错误，请重新输入"</span> &lt;&lt; endl;
	}
}</code></pre> 
</div> 
<p></p> 
<h4 id="register%E5%87%BD%E6%95%B0%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C">REGISTER函数（用户注册）</h4> 
<blockquote> 
 <p>输入用户名和密码<br> 先对比用户数据结构数组（<code>struct UOF openfile[MAX_OPEN_FILE_NUM]</code>）中的用户名，用户名重复则失败，否则成功，并将用户信息存入用户结构体中</p> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">REGISTER</span><span class="hljs-params">()</span><span class="hljs-comment">//注册用户</span>
</span>{
	cout &lt;&lt; <span class="hljs-string">"请输入用户名:"</span>;
	string username;
	cin &gt;&gt; username;
	cout &lt;&lt; <span class="hljs-string">"请输入密码:"</span>;
	string password;
	cin &gt;&gt; password;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_USER_NUM; i++)<span class="hljs-comment">//最大可有16个用户</span>
	{
		<span class="hljs-keyword">if</span> (mfd[i].username == username)
		{
			cout &lt;&lt; <span class="hljs-string">"注册失败，该用户名已存在"</span> &lt;&lt; endl;
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}
	}
	<span class="hljs-comment">//将用户信息存入用户结构体中</span>
	mfd[cur_user_size].username = username;
	mfd[cur_user_size].password = password;
	cur_user_size++;
	cout &lt;&lt; <span class="hljs-string">"注册成功"</span> &lt;&lt; endl;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="login%E5%87%BD%E6%95%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%85%A5">LOGIN函数（用户登入）</h4> 
<blockquote> 
 <p>把输入的用户名和密码与记录所有用户的结构体数组进行比对，<br> 比对成功后将此用户文件的指针加入到当前用户文件数组中，并设置此为当前目录（即当前用户下）<br> 并指向当前用户的文件打开表对象</p> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LOGIN</span><span class="hljs-params">()</span><span class="hljs-comment">//用户登入</span>
</span>{
	cout &lt;&lt; <span class="hljs-string">"请输入用户名："</span>;
	string username;
	cin &gt;&gt; username;
	cout &lt;&lt; <span class="hljs-string">"请输入密码："</span>;
	string password;
	cin &gt;&gt; password;
	<span class="hljs-type">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user_size; i++)
	{
		<span class="hljs-keyword">if</span> (mfd[i].username == username)
		{
			<span class="hljs-keyword">if</span> (mfd[i].password != password)
			{
				cout &lt;&lt; <span class="hljs-string">"密码错误"</span> &lt;&lt; endl;
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			}
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-keyword">break</span>;
			}
		}
	}
	<span class="hljs-keyword">if</span> (i == cur_user_size)
	{
		cout &lt;&lt; <span class="hljs-string">"没有此用户"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	mfd[i].next = &amp;(cur_user_all_direct_array[i]);<span class="hljs-comment">//用户文件指向第i个用户数组</span>
	cur_user = mfd[i];<span class="hljs-comment">//登入后此为当前目录</span>
	cur_user.next-&gt;cur_user_direct_size = mfd[i].next-&gt;cur_user_direct_size;<span class="hljs-comment">//让当前用户找到所登入的用户文件</span>
	cur_user_size++;<span class="hljs-comment">//用户人数+1</span>
	cur_opentable = &amp;openfile[cur_user_size]; <span class="hljs-comment">//指针指向文件打开表对象  每一个用户一个文件打开表对象，该表中最多存放16个文件夹</span>
	cur_opentable-&gt;cur_openfilesize = <span class="hljs-number">0</span>;<span class="hljs-comment">//设置当前打开的文件数为0</span>
	path = <span class="hljs-string">""</span>;<span class="hljs-comment">//设置path在刚登入时为空</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="look%E5%87%BD%E6%95%B0%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7">LOOK函数（查看所有用户）</h4> 
<blockquote> 
 <p>遍历用户名，方便观察调试</p> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-comment">//查看用户表</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LOOK</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-type">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user_size; i++)
	{
		cout &lt;&lt; mfd[i].username &lt;&lt; <span class="hljs-string">"  "</span>;<span class="hljs-comment">//遍历现有的用户数，方便观察</span>
	}
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>); 
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="getcurrenttimestr%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4">getCurrentTimeStr函数（获取当前时间）</h4> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function">string <span class="hljs-title">getCurrentTimeStr</span><span class="hljs-params">()</span><span class="hljs-comment">//得到时间</span>
</span>{
	<span class="hljs-type">time_t</span> t = <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>);
	<span class="hljs-type">char</span> ch[<span class="hljs-number">64</span>] = {<!-- --><span class="hljs-number">0</span>};
	<span class="hljs-built_in">strftime</span>(ch, <span class="hljs-built_in">sizeof</span>(ch) - <span class="hljs-number">1</span>, <span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>, <span class="hljs-built_in">localtime</span>(&amp;t));
	<span class="hljs-keyword">return</span> ch;
}</code></pre> 
</div> 
<p></p> 
<h4 id="create%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6">CREATE函数（创建文件）</h4> 
<blockquote> 
 <ol><li>必须先进入文件夹在创建文件</li><li>找到对应文件夹</li><li>判断文件是否重名</li><li>判断该文件夹中的文件是否满16个</li><li>判断是否有空闲块</li><li>条件满足创建，否则输出提示</li></ol> 
</blockquote> 
<p>更新文件数据，文件数量＋1，磁盘块占用</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-comment">//创建文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CREATE</span><span class="hljs-params">(string name)</span>
</span>{
	<span class="hljs-type">int</span> index;
	<span class="hljs-keyword">if</span> (path == <span class="hljs-string">""</span>)
	{
		cout &lt;&lt; <span class="hljs-string">"请先进入文件夹,再创建文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)
	{
		<span class="hljs-keyword">if</span> (path == cur_user.next-&gt;direct[index].directname)<span class="hljs-comment">//如果path等于文件夹名</span>
		{
			<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-type">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)<span class="hljs-comment">//循环当前文件夹的文件数</span>
	{
		<span class="hljs-keyword">if</span> (name == cur_user.next-&gt;direct[index].ufd[i].filename)
		{
		<span class="hljs-keyword">break</span>;<span class="hljs-comment">//文件名重复跳出循环</span>
		}
	}
	<span class="hljs-keyword">if</span> (i &lt; cur_user.next-&gt;direct[index].cur_file_size)<span class="hljs-comment">//重复 i会小于文件数，无重复 则等于</span>
	{
		cout &lt;&lt; <span class="hljs-string">"文件名重复"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">if</span> (cur_user.next-&gt;direct[index].cur_file_size == MAX_OPEN_FILE_NUM)
	{
		cout &lt;&lt; <span class="hljs-string">"该文件夹文件已达到"</span>&lt;&lt; MAX_OPEN_FILE_NUM &lt;&lt; <span class="hljs-string">"个"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-type">int</span> j;
	<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; BLOCK_NUM; j++)<span class="hljs-comment">//判断是否有空闲块 磁盘块数量64 每个块大小512</span>
	{
		<span class="hljs-keyword">if</span> (fat[j].used == <span class="hljs-number">0</span>)
		{
			<span class="hljs-keyword">break</span>;
		}
			
	}
	<span class="hljs-keyword">if</span> (j &gt;= BLOCK_NUM)
	{
		cout &lt;&lt; <span class="hljs-string">"磁盘没有空闲块了"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	string tim=<span class="hljs-built_in">getCurrentTimeStr</span>();
	cout &lt;&lt; tim &lt;&lt; endl;
	

	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].time = tim;<span class="hljs-comment">//创建时间</span>
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].filename = name;<span class="hljs-comment">//上面都通过了保存文件名</span>
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].addr = j; <span class="hljs-comment">//文件起始盘块号</span>
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].length = <span class="hljs-number">0</span>;<span class="hljs-comment">//未写入数据，长度为0</span>
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].protect_code = <span class="hljs-number">2</span>; <span class="hljs-comment">//表示可读可写</span>
	<span class="hljs-comment">//cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].time = tim;//创建时间</span>
	cur_user.next-&gt;direct[index].cur_file_size++;<span class="hljs-comment">//用户文件数量加1</span>
    fat[j].used = <span class="hljs-number">1</span>;<span class="hljs-comment">//此时已被占用</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="delete%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6">DELETE函数（删除文件）</h4> 
<blockquote> 
 <ol><li>判断是否在文件中</li><li>循环找到文件夹</li><li>循环找到文件</li><li>判断文件是否打开（打开时文件不可删除）</li><li>删除文件或输出提示</li></ol> 
</blockquote> 
<p>更新文件数组信息，将最后一个文件替换到删除的文件中<br> 如果已经是最后一个文件，则直接删除</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-comment">//删除文件</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DELETE</span><span class="hljs-params">(string name, <span class="hljs-type">int</span> mark)</span>
</span>{
	<span class="hljs-keyword">if</span> (path == <span class="hljs-string">""</span> &amp;&amp; mark == <span class="hljs-number">-1</span>)
	{
		cout &lt;&lt; <span class="hljs-string">"请在文件夹中删除文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-type">int</span> index;
	<span class="hljs-keyword">if</span>(mark != <span class="hljs-number">-1</span>) 	<span class="hljs-comment">//如果是被RMDIR函数调用，则当前path=""</span>
		index = mark;
	<span class="hljs-keyword">else</span>
		<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)<span class="hljs-comment">//循环用户拥有的文件夹</span>
		{
			<span class="hljs-keyword">if</span> (path == cur_user.next-&gt;direct[index].directname)<span class="hljs-comment">//找到文件夹后退出</span>
			{
				<span class="hljs-keyword">break</span>;
			}
		}

	<span class="hljs-type">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)<span class="hljs-comment">//循环该文件夹的文件</span>
	{
		<span class="hljs-keyword">if</span> (cur_user.next-&gt;direct[index].ufd[i].filename == name)<span class="hljs-comment">//找到文件后退出</span>
		{
			<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-keyword">if</span> (i &gt;= cur_user.next-&gt;direct[index].cur_file_size)
	{
		cout &lt;&lt; <span class="hljs-string">"没有该文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-type">int</span> j;
	<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; i &lt; cur_opentable-&gt;cur_openfilesize; j++)<span class="hljs-comment">//循环打开的文件，查看是否被打开</span>
	{
		<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[j].filename == name)
			<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (j &lt; cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; <span class="hljs-string">"该文件已被打开，无法删除"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}

	<span class="hljs-comment">//更新当前用户目录下文件数组信息,就是将最后一个文件的信息替换到要删除的文件的位置</span>

	<span class="hljs-comment">//如果本身是最后一个文件，那么不需要替换，直接删除</span>
	<span class="hljs-keyword">if</span>(i == cur_user.next-&gt;direct[index].cur_file_size <span class="hljs-number">-1</span>)
	{
		fat[cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - <span class="hljs-number">1</span>].addr].used = <span class="hljs-number">0</span>; 
		cur_user.next-&gt;direct[index].cur_file_size--;
		<span class="hljs-comment">//next为-1 说明没有下一页，此为最后一页</span>
		<span class="hljs-type">int</span> temp = fat[cur_user.next-&gt;direct[index].ufd[i].addr].next;
		<span class="hljs-keyword">while</span> (temp != <span class="hljs-number">-1</span>)<span class="hljs-comment">//删除该文件的内存空间</span>
		{
			fat[temp].used = <span class="hljs-number">0</span>;
			temp = fat[temp].next;
		}
		cout &lt;&lt; <span class="hljs-string">"删除文件"</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">"成功"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		cur_user.next-&gt;direct[index].ufd[i].filename = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - <span class="hljs-number">1</span>].filename;
		<span class="hljs-comment">//先将该块置0</span>
		fat[cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - <span class="hljs-number">1</span>].addr].used = <span class="hljs-number">0</span>; 
		cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - <span class="hljs-number">1</span>].addr = cur_user.next-&gt;direct[index].ufd[i].addr;
		cur_user.next-&gt;direct[index].ufd[i].length = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - <span class="hljs-number">1</span>].length;
		cur_user.next-&gt;direct[index].ufd[i].protect_code = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - <span class="hljs-number">1</span>].protect_code;
		cur_user.next-&gt;direct[index].cur_file_size--;

		<span class="hljs-comment">//将该文件设置为占用</span>
		fat[cur_user.next-&gt;direct[index].ufd[i].addr].used = <span class="hljs-number">1</span>;
		
		<span class="hljs-comment">//next为-1 说明没有下一页，此为最后一页</span>
		<span class="hljs-type">int</span> temp = fat[cur_user.next-&gt;direct[index].ufd[i].addr].next;
		<span class="hljs-keyword">while</span> (temp != <span class="hljs-number">-1</span>)<span class="hljs-comment">//删除该文件的内存空间</span>
		{
			fat[temp].used = <span class="hljs-number">0</span>;
			temp = fat[temp].next;
		}
		cout &lt;&lt; <span class="hljs-string">"删除文件"</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">"成功"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
}</code></pre> 
</div> 
<p></p> 
<h4 id="opem%E5%87%BD%E6%95%B0%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">OPEM函数（打开文件）</h4> 
<blockquote> 
 <ol><li>判断是否在文件夹中</li><li>循环文件夹数，找到要打开文件所在的文件夹</li><li>循环文件数，找到文件</li><li>判断打开的文件数是否满16</li><li>判断文件是否已经打开</li><li>将文件信息加入到已打开的文件数组中</li><li>打开文件</li></ol> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OPEN</span><span class="hljs-params">(string name)</span><span class="hljs-comment">//打开文件</span>
</span>{
    <span class="hljs-keyword">if</span> (path == <span class="hljs-string">""</span>)
	{
		cout &lt;&lt; <span class="hljs-string">"请在文件夹中打开文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	string AllName = path +<span class="hljs-string">'/'</span>+name;<span class="hljs-comment">//设置该变量的原因是防止出现打开文件数组中存在文件夹名不同而文件同名的情况</span>
	<span class="hljs-type">int</span> index;
	<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)<span class="hljs-comment">//循环当前用户的文件</span>
	{
		<span class="hljs-keyword">if</span> (path == cur_user.next-&gt;direct[index].directname)
		{
			 <span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)<span class="hljs-comment">//循环文件数</span>
	{
		<span class="hljs-keyword">if</span> (name == cur_user.next-&gt;direct[index].ufd[i].filename)<span class="hljs-comment">//找到同名文件</span>
			 <span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (i &gt;= cur_user.next-&gt;direct[index].cur_file_size)
	{
		cout &lt;&lt; <span class="hljs-string">"没有该文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">if</span> (cur_opentable-&gt;cur_openfilesize == MAX_OPEN_FILE_NUM)
	{
		cout &lt;&lt; <span class="hljs-string">"文件打开数量已经达到最大值"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; i &lt; cur_opentable-&gt;cur_openfilesize; j++)
	{
		<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[i].filename == AllName)<span class="hljs-comment">//在打开文件中找到相应文件夹中的文件</span>
		{
			 cout &lt;&lt; <span class="hljs-string">"该文件已经打开"</span> &lt;&lt; endl;
			 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}
	}
	<span class="hljs-type">int</span> k;
	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; cur_user.next-&gt;direct[index].cur_file_size; k++)
	{
		<span class="hljs-keyword">if</span> (cur_user.next-&gt;direct[index].ufd[k].filename == name)<span class="hljs-comment">//找到相应文件夹中的文件</span>
		 <span class="hljs-keyword">break</span>;
	} 
	<span class="hljs-comment">//将该文件的信息加入到已打开的文件数组中</span>
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].filename = AllName;<span class="hljs-comment">//在打开的文件数组中加入该文件</span>
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].protect_code = 	cur_user.next-&gt;direct[index].ufd[k].protect_code;<span class="hljs-comment">//保护码</span>
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].pointer = cur_user.next-&gt;direct[index].ufd[k].length;
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].addr = cur_user.next-&gt;direct[index].ufd[k].addr;<span class="hljs-comment">//起始地址</span>
	cur_opentable-&gt;cur_openfilesize++; <span class="hljs-comment">//文件打开数量加1</span>
	cout &lt;&lt; <span class="hljs-string">"文件打开成功"</span> &lt;&lt;endl;
	<span class="hljs-keyword">return</span> k; <span class="hljs-comment">//返回文件在文件打开表中的第几项</span>
}</code></pre> 
</div> 
<p></p> 
<h4 id="close%E5%87%BD%E6%95%B0%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6">CLOSE函数（关闭文件）</h4> 
<blockquote> 
 <ol><li>循环打开的文件数，找到文件</li><li>更新打开文件数组信息将最后一个打开文件的信息替换到要关闭的位置</li><li>关闭文件</li></ol> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CLOSE</span><span class="hljs-params">(string name)</span><span class="hljs-comment">//关闭文件</span>
</span>{	
	<span class="hljs-type">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_opentable-&gt;cur_openfilesize; i++)
	{
		<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[i].filename == path + <span class="hljs-string">'/'</span> + name)
		{
			<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-keyword">if</span> (i &gt;= cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; <span class="hljs-string">"该文将未打开"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-comment">//更新当前用户打开文件数组信息,就是将最后一个打开文件的信息替换到要关闭的打开文件的位置</span>
	cur_opentable-&gt;uof[i].filename = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - <span class="hljs-number">1</span>].filename;
	cur_opentable-&gt;uof[i].pointer = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - <span class="hljs-number">1</span>].pointer;
	cur_opentable-&gt;uof[i].protect_code = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - <span class="hljs-number">1</span>].protect_code;
	cur_opentable-&gt;uof[i].addr = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - <span class="hljs-number">1</span>].addr;
	cur_opentable-&gt;cur_openfilesize--;
	cout &lt;&lt; <span class="hljs-string">"文件关闭成功"</span> &lt;&lt; endl;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="write%E5%87%BD%E6%95%B0%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">WRITE函数（写入文件）</h4> 
<blockquote> 
 <ol><li>循环文件夹数，找到文件所在文件夹</li><li>循环打开文件，判断文件是否已打开</li><li>判断文件保护码是否可写</li><li>输入内容</li><li>更新磁盘空间大小</li><li>磁盘空间不够写，填满最后一个磁盘块后寻找下一个空闲块</li><li>写入</li></ol> 
</blockquote> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">WRITE</span><span class="hljs-params">(string name)</span><span class="hljs-comment">//写入文件</span>
</span>{
	<span class="hljs-type">int</span> index; <span class="hljs-comment">//标识当前目录在direct数组中第几个</span>
	<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)
	{
		<span class="hljs-keyword">if</span> (path == cur_user.next-&gt;direct[index].directname)<span class="hljs-comment">//在当前用户的文件夹中找到相应的文件</span>
		{
			<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-type">int</span> i;
	<span class="hljs-comment">//判读文件是否打开</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_opentable-&gt;cur_openfilesize; i++)
	{
		<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[i].filename == path + <span class="hljs-string">'/'</span> + name)<span class="hljs-comment">//循环打开的文件</span>
			<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (i &gt;= cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; <span class="hljs-string">"文件没有打开， 无法写入"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	}
	<span class="hljs-type">int</span> fd = i; <span class="hljs-comment">//获取文件描述字</span>
	<span class="hljs-comment">//判断读文件的合法性</span>
	<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[fd].protect_code != <span class="hljs-number">2</span>)
	{
		cout &lt;&lt; <span class="hljs-string">"文件不可写"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		string content;<span class="hljs-comment">//字符串  存储输入的一行内容</span>
		cin.<span class="hljs-built_in">ignore</span>();
		<span class="hljs-comment">//cin.ignore()函数是C++标准输入流（cin）中的一个方法。cin.ignore()函数中有两个参数，</span>
		<span class="hljs-comment">//分别为数值型的a 和 字符型的 ch ，即cin.ignore( a, ch )。它表示从输入流 cin 中提取</span>
		<span class="hljs-comment">//字符，提取的字符被忽略，不被使用。而每抛弃一个字符，它都要进行计数和比较字符：如果</span>
		<span class="hljs-comment">//计数值达到 a 或者被抛弃的字符是 ch ，则cin.ignore() 函数执行终止；否则，它继续等待。</span>
		<span class="hljs-comment">//如果默认不给参数的话，默认参数为cin.ignore(1, EOF)，即把EOF前的1个字符清掉,没有遇</span>
		<span class="hljs-comment">//到EOF就清掉一个字符然后结束。</span>
		cout &lt;&lt; <span class="hljs-string">"请输入文件要写入的内容: "</span> &lt;&lt; endl;;
		<span class="hljs-built_in">getline</span>(cin, content); <span class="hljs-comment">//读入一整行内容</span>
		<span class="hljs-type">int</span> cin_len = content.<span class="hljs-built_in">length</span>();<span class="hljs-comment">//输入一行的长度</span>
		<span class="hljs-type">int</span> cin_p=<span class="hljs-number">0</span>;<span class="hljs-comment">//初值为0</span>
		<span class="hljs-type">int</span> last_block_res;<span class="hljs-comment">//磁盘剩余空间的大小</span>

		<span class="hljs-comment">//追加写</span>
		<span class="hljs-comment">//找到该文件存放的最后一个磁盘块  </span>
		<span class="hljs-type">int</span> last_block = cur_opentable-&gt;uof[fd].addr;
		<span class="hljs-keyword">while</span> (fat[last_block].next != <span class="hljs-number">-1</span>)
		{
			last_block = fat[last_block].next;
		}

		<span class="hljs-type">int</span> temp;<span class="hljs-comment">//保存当前所写的文件在用户文件目录表的第几项，为了后面修改文件的大小</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; cur_user.next-&gt;direct[index].cur_file_size; k++)
		{
			<span class="hljs-keyword">if</span> (cur_user.next-&gt;direct[index].ufd[k].filename == name)<span class="hljs-comment">//找到该文件</span>
			{
				temp = k;
				<span class="hljs-keyword">break</span>;
			}
		}

		<span class="hljs-comment">//计算该文件存放的最后一个地址</span>
		<span class="hljs-type">char</span>  * first;
		first = fdisk + last_block * BLOCK_SIZE + cur_opentable-&gt;uof[fd].pointer % BLOCK_SIZE;

		<span class="hljs-comment">//计算最后一个磁盘块还有多少空间</span>
		<span class="hljs-keyword">if</span>(cur_opentable-&gt;uof[fd].pointer == <span class="hljs-number">0</span>)
			last_block_res = BLOCK_SIZE;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur_opentable-&gt;uof[fd].pointer % BLOCK_SIZE == <span class="hljs-number">0</span>)
			last_block_res = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">else</span>
			last_block_res = BLOCK_SIZE - (cur_opentable-&gt;uof[fd].pointer % BLOCK_SIZE);

		<span class="hljs-comment">//首先填满最后一个磁盘块</span>
		<span class="hljs-keyword">if</span>(last_block_res)
		{
			<span class="hljs-keyword">if</span>(last_block_res &lt;= cin_len)	<span class="hljs-comment">//当最后一个磁盘块的空间小于输入内容大小</span>
			{
				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;last_block_res;j++)
					first[j] = content[cin_p++];
				cin_len -= last_block_res;<span class="hljs-comment">//计算还有多少字符没存入</span>
			}
			<span class="hljs-keyword">else</span>	<span class="hljs-comment">//当最后一个磁盘块的空间大于输入内容大小</span>
			{
				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cin_len;j++)
					first[j] = content[cin_p++];
				cur_opentable-&gt;uof[fd].pointer = cur_opentable-&gt;uof[fd	].pointer + cin_len;  <span class="hljs-comment">//更新文件打开表</span>
				cur_user.next-&gt;direct[index].ufd[temp].length = cur_user.next-&gt;direct[index].ufd[temp].length + cin_len; <span class="hljs-comment">//更新用户目录文件表</span>
				cout &lt;&lt; <span class="hljs-string">"文件写入成功，共写入"</span> &lt;&lt; cin_len &lt;&lt; <span class="hljs-string">"字节"</span> &lt;&lt; endl;
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			}
		}

		<span class="hljs-comment">//计算还需要多少个磁盘块，判断空间是否足够</span>
		<span class="hljs-type">int</span> times = cin_len / BLOCK_SIZE;<span class="hljs-comment">//向上取整 求存满块数</span>
		<span class="hljs-type">int</span> offset = cin_len % BLOCK_SIZE;<span class="hljs-comment">//取余  未存满</span>
		<span class="hljs-keyword">if</span> (offset != <span class="hljs-number">0</span>)
			times++;<span class="hljs-comment">//块数＋1</span>

		<span class="hljs-type">int</span> unused_block_num = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录没有使用过的磁盘块的个数</span>
		<span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; BLOCK_NUM; j++)
		{
			<span class="hljs-keyword">if</span> (fat[j].used == <span class="hljs-number">0</span>)
			{
				unused_block_num++;
			}
		}

		<span class="hljs-keyword">if</span>(unused_block_num &lt; times)<span class="hljs-comment">//剩余的块不够写</span>
		{
			cout&lt;&lt;<span class="hljs-string">"空间不足，写入内容失败！\n"</span>;
			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
		}

		<span class="hljs-type">int</span> next_block = fat[cur_opentable-&gt;uof[fd].addr].next; <span class="hljs-comment">//记录块的起始地址的next</span>
		<span class="hljs-type">int</span> first_unused_block; <span class="hljs-comment">//记录第一个没有被使用过的磁盘</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;times;j++)
		{
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; BLOCK_NUM; k++)
			{
				<span class="hljs-keyword">if</span> (fat[k].used == <span class="hljs-number">0</span>)
				{
					first_unused_block = k;
					<span class="hljs-keyword">break</span>;
				}
			}
			fat[last_block].next = first_unused_block;
			last_block = first_unused_block;
			first = fdisk + last_block * BLOCK_SIZE;
			<span class="hljs-keyword">if</span>(j!=times<span class="hljs-number">-1</span>)
			{
				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;BLOCK_SIZE;k++)
					first[k] = content[cin_p++];
			}
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;offset;k++)
					first[k] = content[cin_p++];
			}

		}
		cur_opentable-&gt;uof[fd].pointer = cur_opentable-&gt;uof[fd].pointer + cin_p;  <span class="hljs-comment">//更新文件打开表</span>
		cur_user.next-&gt;direct[index].ufd[temp].length = cur_user.next-&gt;direct[index].ufd[temp].length + cin_p; <span class="hljs-comment">//更新用户目录文件表</span>
		cout &lt;&lt; <span class="hljs-string">"文件写入成功，共写入"</span> &lt;&lt; cin_p &lt;&lt; <span class="hljs-string">"字节"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
}</code></pre> 
</div> 
<p></p> 
<h4 id="read%E5%87%BD%E6%95%B0%E8%AF%BB%E6%96%87%E4%BB%B6">READ函数（读文件）</h4> 
<blockquote> 
 <ol><li>找到文件所在文件夹</li><li>循环文件数，找到文件</li><li>判断文件是否打开</li><li>判断文件是否可读</li><li>借助缓冲区输出文件内容</li><li>释放缓冲区</li></ol> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">READ</span><span class="hljs-params">(string name)</span><span class="hljs-comment">//读文件</span>
</span>{
	<span class="hljs-type">int</span> index1; <span class="hljs-comment">//标识当前目录在direct数组中第几个</span>
	<span class="hljs-keyword">for</span> (index1 = <span class="hljs-number">0</span>; index1 &lt; cur_user.next-&gt;cur_user_direct_size; index1++)
	{
		<span class="hljs-keyword">if</span> (path == cur_user.next-&gt;direct[index1].directname)<span class="hljs-comment">//找到文件夹</span>
		{
			<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-type">int</span> a;
	<span class="hljs-keyword">for</span> (a = <span class="hljs-number">0</span>; a &lt; cur_user.next-&gt;direct[index1].cur_file_size; a++)    <span class="hljs-comment">//判断文件是否存在</span>
	{
	<span class="hljs-keyword">if</span> (cur_user.next-&gt;direct[index1].ufd[a].filename == name)<span class="hljs-comment">//找文件</span>
		<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (a &gt;= cur_user.next-&gt;direct[index1].cur_file_size)
	{
		cout &lt;&lt; <span class="hljs-string">"没有这个文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-type">int</span> i;
	<span class="hljs-comment">//判读文件是否打开</span>
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_opentable-&gt;cur_openfilesize; i++)
	{
		<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[i].filename == path + <span class="hljs-string">'/'</span> + name)
			<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (i &gt;= cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; <span class="hljs-string">"文件没有打开， 无法读取"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
	}
	<span class="hljs-type">int</span> fd = i; <span class="hljs-comment">//获取文件描述字</span>
	<span class="hljs-comment">//判断读文件的合法性</span>
	<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[fd].protect_code == <span class="hljs-number">0</span>) <span class="hljs-comment">//我们创建的文件都是默认可读可写的</span>
	{
		cout &lt;&lt; <span class="hljs-string">"文件不可读"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-type">int</span> len = cur_opentable-&gt;uof[fd].pointer; <span class="hljs-comment">//文件的长度</span>
		<span class="hljs-type">int</span> block_num = len / BLOCK_SIZE; <span class="hljs-comment">//磁盘的个数</span>
		<span class="hljs-type">int</span> offset = len % BLOCK_SIZE; <span class="hljs-comment">//偏移量</span>
		<span class="hljs-keyword">if</span> (offset != <span class="hljs-number">0</span>)
			block_num++;
		
		<span class="hljs-comment">//如果我用一个文件表示磁盘的引导块，用另一个文件表示磁盘的	数据块，那么我们计算文件的起始位置就不用加上磁盘的引导块了吧</span>
		<span class="hljs-comment">//关于文件的存放文件，我们char *fdisk表示一整个磁盘，然后不		同文件的内容存放在这个指针所指向的不同字符段</span>
		<span class="hljs-type">char</span> * first = fdisk + cur_opentable-&gt;uof[fd].addr * BLOCK_SIZE; <span class="hljs-comment">//文件的起始地址 第0块起始地址为0 第1块起始地址为512</span>
		<span class="hljs-type">char</span> * buf = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">513</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>)); <span class="hljs-comment">//缓冲区  给指针申请513个char类型大小的空间  512个空间存放内容 第513个存\0</span>
		cout &lt;&lt; <span class="hljs-string">"文件的内容为 :"</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; block_num; k++)
		{
			<span class="hljs-keyword">if</span> (k == block_num - <span class="hljs-number">1</span>)  <span class="hljs-comment">//则是最后一个磁盘块</span>
			{
				<span class="hljs-type">int</span> j;
				<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - k * BLOCK_SIZE; j++)  <span class="hljs-comment">//赋值文件剩余的字符，其实就是偏移量</span>
				{
					buf[j] = first[j];
				}
				buf[j] = <span class="hljs-string">'\0'</span>;<span class="hljs-comment">//\0结束</span>
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, buf); <span class="hljs-comment">//输出文件的内容</span>
			}
			<span class="hljs-keyword">else</span> <span class="hljs-comment">//不在最后一个磁盘块，也就是在其他已经读满的磁盘块</span>
			{
				<span class="hljs-type">int</span> j;
				<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; BLOCK_SIZE; j++)
					buf[j] = first[j]; <span class="hljs-comment">//缓冲区读满就输出内容</span>
				buf[j] = <span class="hljs-string">'\0'</span>;
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, buf); <span class="hljs-comment">//输出文件的内容</span>
				<span class="hljs-type">int</span> next_block = fat[cur_opentable-&gt;uof[fd].addr].next; 				<span class="hljs-comment">//读完一个磁盘块后，在接着读下一个磁盘块</span>
				first = fdisk + next_block * BLOCK_SIZE;
			}
		}
		cout &lt;&lt; endl;
		<span class="hljs-built_in">free</span>(buf); <span class="hljs-comment">//释放缓冲区</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
}</code></pre> 
</div> 
<p></p> 
<h4 id="cd%E5%87%BD%E6%95%B0%E6%9B%B4%E6%94%B9%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95">CD函数（更改当前目录）</h4> 
<blockquote> 
 <ol><li>判断是否在根目录</li><li>循环寻找文件夹</li><li>找到则更改path值</li></ol> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CD</span><span class="hljs-params">()</span><span class="hljs-comment">//更改当前目录</span>
</span>{
	string temp_path;
	cin &gt;&gt; temp_path;
	<span class="hljs-keyword">if</span> (temp_path == <span class="hljs-string">".."</span>)
	{
		<span class="hljs-keyword">if</span>(path == <span class="hljs-string">""</span>)
		{
			cout &lt;&lt; <span class="hljs-string">"已在根目录"</span> &lt;&lt; endl;
		}
		<span class="hljs-keyword">else</span>
		{
			path = <span class="hljs-string">""</span>;
		  	
		}
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	}
	<span class="hljs-type">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;cur_user_direct_size; i++)
	{
		<span class="hljs-keyword">if</span> (temp_path == cur_user.next-&gt;direct[i].directname)
			<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (i &gt;= cur_user.next-&gt;cur_user_direct_size)
	{
		cout &lt;&lt; <span class="hljs-string">"没有此目录"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	path = temp_path;<span class="hljs-comment">//path为该路径</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="mkdir%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95">MKDIR函数（创建目录）</h4> 
<blockquote> 
 <ol><li>判断用户目录是否已达16</li><li>判断目录是否已存在（重名）</li><li>创建目录</li></ol> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MKDIR</span><span class="hljs-params">(string name)</span><span class="hljs-comment">//创建目录</span>
</span>{
	<span class="hljs-keyword">if</span> (cur_user.next-&gt;cur_user_direct_size == MAX_USER_NUM)
	{
		cout &lt;&lt; <span class="hljs-string">"用户目录数量已经达到最大值"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-type">int</span> i;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;cur_user_direct_size; i++)
	{
		<span class="hljs-keyword">if</span> (cur_user.next-&gt;direct[i].directname == name)
			<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (i &lt; cur_user.next-&gt;cur_user_direct_size)
	{
		cout &lt;&lt; <span class="hljs-string">"该目录名已存在"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size].directname = name;
	cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size].cur_file_size = <span class="hljs-number">0</span>; <span class="hljs-comment">//新创建的目录里面的文件个数为0</span>
	cur_user.next-&gt;cur_user_direct_size++;
	cout &lt;&lt; <span class="hljs-string">"创建目录成功"</span> &lt;&lt; endl;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="rmdir%E5%87%BD%E6%95%B0%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95">RMDIR函数（删除目录）</h4> 
<blockquote> 
 <ol><li>判断是否在根目录</li><li>找到文件夹位置</li><li>判断是否其中有文件打开</li><li>删除该文件夹的所有文件</li><li>将最后一个文件夹的位置替换为删除的文件夹的位置</li><li>目录-1</li><li>成功删除</li></ol> 
</blockquote> 
<p></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RMDIR</span><span class="hljs-params">(string name)</span><span class="hljs-comment">//删除目录</span>
</span>{
	<span class="hljs-keyword">if</span>(path != <span class="hljs-string">""</span>)
	{
		cout &lt;&lt; <span class="hljs-string">"请先退出文件夹"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-type">int</span> index;<span class="hljs-comment">//文件夹的位置</span>
	<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)<span class="hljs-comment">//先判断是否有该文件夹</span>
	{
		<span class="hljs-keyword">if</span> (name == cur_user.next-&gt;direct[index].directname)
			<span class="hljs-keyword">break</span>;
	}

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)
	{
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;i&lt;cur_opentable-&gt;cur_openfilesize;j++)
			<span class="hljs-keyword">if</span> (name + <span class="hljs-string">'/'</span> + cur_user.next-&gt;direct[index].ufd[i].filename 	== cur_opentable-&gt;uof[j].filename)
			{
				cout &lt;&lt; <span class="hljs-string">"请先关闭该文件夹的所有文件"</span> &lt;&lt; endl;
				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
			}
	}
	<span class="hljs-comment">//删除该文件夹的所有文件</span>

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)
	{
		<span class="hljs-built_in">DELETE</span>(cur_user.next-&gt;direct[index].ufd[i].filename, index);
	}
	<span class="hljs-comment">//把最后一个文件的位置放到删除的位置</span>
	cur_user.next-&gt;direct[index].cur_file_size = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - <span class="hljs-number">1</span>].cur_file_size;  <span class="hljs-comment">//注意这里	需要减一，由于本身结构的限制</span>
	cur_user.next-&gt;direct[index].directname = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - <span class="hljs-number">1</span>].directname;
	<span class="hljs-comment">//改变文件的位置</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - <span class="hljs-number">1</span>].cur_file_size; i++)  <span class="hljs-comment">//注意这里的减一</span>
	{
		cur_user.next-&gt;direct[index].ufd[i].addr = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - <span class="hljs-number">1</span>].ufd[i].addr;
		cur_user.next-&gt;direct[index].ufd[i].filename = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - <span class="hljs-number">1</span>].ufd[i].filename;
		cur_user.next-&gt;direct[index].ufd[i].length = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - <span class="hljs-number">1</span>].ufd[i].length;
		cur_user.next-&gt;direct[index].ufd[i].protect_code = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - <span class="hljs-number">1</span>].ufd[i].protect_code;
	}
	cur_user.next-&gt;cur_user_direct_size--; <span class="hljs-comment">//目录数量减1</span>
	cout &lt;&lt; <span class="hljs-string">"删除目录成功"</span> &lt;&lt; endl;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p></p> 
<h4 id="dir%E5%87%BD%E6%95%B0%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95">DIR函数（显示当前目录）</h4> 
<blockquote> 
 <ol><li>循环找到当前文件夹</li><li>判断是否在根目录</li><li>是则循环输出文件名，否则输出文件相关信息</li></ol> 
</blockquote> 
<p> </p> 
<div> 
 <pre><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DIR</span><span class="hljs-params">()</span><span class="hljs-comment">//显示当前地址下的内容</span>
</span>{
	<span class="hljs-type">int</span> index;
	<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)
	{
		<span class="hljs-keyword">if</span> (path == cur_user.next-&gt;direct[index].directname)
		{
			<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-keyword">if</span> (path == <span class="hljs-string">""</span>)
	{
		cout &lt;&lt; <span class="hljs-string">"  目录名"</span> &lt;&lt; endl;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;cur_user_direct_size; i++)
		{
			cout &lt;&lt; <span class="hljs-string">"  "</span> &lt;&lt; cur_user.next-&gt;direct[i].directname &lt;&lt; endl;
		}
	}
	<span class="hljs-keyword">else</span>
	{
		cout &lt;&lt; <span class="hljs-string">"\t文件名\t文件保护码\t文件长度\t文件起始盘块号\t\t创建日期"</span> &lt;&lt; endl;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)
		{
			cout &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt; cur_user.next-&gt;direct[index].ufd[i].filename &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt; cur_user.next-&gt;direct[index].ufd[i].protect_code &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt;cur_user.next-&gt;direct[index].ufd[i].length &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt; cur_user.next-&gt;direct[index].ufd[i].addr &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt; <span class="hljs-string">"\t"</span> &lt;&lt;  cur_user.next-&gt;direct[index].ufd[i].time &lt;&lt; endl;
		}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p> </p> 
<h4 id="set%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%A0%81">SET函数（设置文件保护码）</h4> 
<blockquote> 
 <ol><li>循环找到文件夹</li><li>循环找文件</li><li>判断文件是否已打开（打开不可设置保护码）</li><li>更改保护码</li></ol> 
</blockquote> 
<p> </p> 
<div> 
 <pre><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SET</span><span class="hljs-params">(string name,<span class="hljs-type">int</span> protectcode)</span><span class="hljs-comment">//设置文件保护码</span>
</span>{
	<span class="hljs-type">int</span> index;
	<span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)<span class="hljs-comment">//找到文件夹的位置</span>
	{
		<span class="hljs-keyword">if</span> (path == cur_user.next-&gt;direct[index].directname)
		{
			<span class="hljs-keyword">break</span>;
		}
	}
	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)<span class="hljs-comment">//找文件</span>
	{
		<span class="hljs-keyword">if</span> (name == cur_user.next-&gt;direct[index].ufd[i].filename)
			<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (i &gt;= cur_user.next-&gt;direct[index].cur_file_size)
	{
		cout &lt;&lt; <span class="hljs-string">"该用户没有这个文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	<span class="hljs-type">int</span> j;
	<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; i &lt; cur_opentable-&gt;cur_openfilesize; j++)
	{
		<span class="hljs-keyword">if</span> (cur_opentable-&gt;uof[j].filename == path + <span class="hljs-string">"/"</span> + name)
		<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">if</span> (j &lt; cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; <span class="hljs-string">"请先关闭该文件"</span> &lt;&lt; endl;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	cur_user.next-&gt;direct[index].ufd[i].protect_code = protectcode;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p> </p> 
<h4 id="fatused%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E5%9D%97%E7%9A%84%E7%8A%B6%E6%80%81">fatused函数（输出块的状态）</h4> 
<blockquote> 
 <p>类似位示图</p> 
</blockquote> 
<p> </p> 
<div> 
 <pre><code class="hljs language-cpp"><span class="hljs-comment">//输出块的状态</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fatused</span><span class="hljs-params">()</span>
</span>{

	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; BLOCK_NUM; i++)<span class="hljs-comment">//判断是否有空闲块 磁盘块数量64 每个块大小512</span>
		{
			<span class="hljs-comment">// cout &lt;&lt; fat[i].used &lt;&lt; " ";</span>
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d  "</span>,fat[i].used);
			<span class="hljs-keyword">if</span>(i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)
			{
				cout &lt;&lt; endl;
			}
		}
		cout &lt;&lt; endl;
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre> 
</div> 
<p> </p> 
<h3 id="%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%92%8C%E5%BF%83%E5%BE%97">问题总结和心得</h3> 
<ol><li> <p>熟练运用指针和结构体构建文件整体结构</p> </li><li> <p>块号位示图问题</p> 
  <ul><li>删除文件后，该文件的块号状态应置为空闲</li><li>将最后一块的块号状态置0</li><li>最后一个块号的内容替换到删除的位置</li><li>如果已经是最后一块，则直接删除并置为空闲</li></ul></li><li> <p>当前用户问题</p> 
  <ul><li>当登录后，此用户为当前用户</li><li>找到当前用户的文件数组</li></ul></li><li> <p>文件读写问题</p> 
  <ul><li>文件被打开时才可进行读写操作</li><li>通过文件保护码，判断文件是否可写可读（2：可读可写；0：不可读；其他：可读）</li></ul></li><li> <p>文件保护问题</p> 
  <ul><li>当文件被打开时不可删除</li><li>当文件被打开时不可修改文件保护码</li><li>可读可写保护</li><li>追加信息写入问题</li><li>每个用户只能访问自己的文件夹</li></ul></li><li> <p>删除文件问题</p> 
  <ul><li>先进入对应文件夹</li><li>找到要删除的文件</li><li>判断文件是否被打开</li><li>删除文件信息</li><li>清空文件所占用的空间</li></ul></li></ol> 
<h3 style="background-color:transparent;">代码整合</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;malloc.h&gt;
#include&lt;time.h&gt;
using namespace std;

#define BLOCK_SIZE     		512  //每一个磁盘块的大小
#define BLOCK_NUM       	64   //磁盘块数量
#define MAX_FILE_NUM		16   //每个文件夹的最大文件数
#define MAX_FOLDER_NUM  	16	 //每个用户可以拥有的最大文件夹数
#define MAX_OPEN_FILE_NUM   16	 //最大同时打开文件数
#define MAX_USER_NUM		16   //最大用户数

struct MFD//用户数据结构
{
	string username;//用户名
	string password;//密码
	struct USER_UFD *next;//指向用户文件的指针
};

struct UFD//文件夹数据结构 
{
	struct file_message//文件数据结构
	{
		string filename;//文件名
		int protect_code;//文件保护码
		int length;//文件长度
		int addr;//文件起始地址
		string time;	//日期时间，格式为yyyymmdd hhmmss
        int used;//是否被占用 0：空闲 1：占用
	}ufd[MAX_FILE_NUM];//一个文件夹最对可以有16个文件
	string directname;//文件夹名字
	int cur_file_size = 0;//当前该文件夹含有的文件数量
};

struct UOF//打开文件数据结构
{
	struct uof
	{
		string filename;//文件名字
		int pointer;//文件长度
		int protect_code;//文件保护码  默认2  2为可读可写  0为不可读  其余数字不可写
		int addr;//文件起始地址
	}uof[MAX_OPEN_FILE_NUM];//最多可以同时打开16个文
	int cur_openfilesize = 0;//当前打开的文件数量
};

struct fat//块号
{
	int next = -1;//存放下一页的块号，无为-1
	int used = 0;  //used存在三种状态，1：被占用 0：空闲
}fat[BLOCK_NUM];//最大为64

struct USER_UFD//用户文件数据结构
{
	struct UFD direct[MAX_FOLDER_NUM];//一个用户最多可以有16个文件夹
	int cur_user_direct_size = 0;//当前拥有的文件夹数量
};

int mark = 1;
struct USER_UFD cur_user_all_direct_array[MAX_USER_NUM];//用户文件数组 16
struct MFD cur_user;//当前用户
struct UOF * cur_opentable;//指向打开文件数组的指针
char *fdisk;//模拟磁盘指针
struct UOF openfile[MAX_OPEN_FILE_NUM];//每一个用户对应一个文件打开表对象，16
struct MFD mfd[MAX_USER_NUM]; //16个用户
int cur_user_size = 0;//记录当前用户的人数
string path;

int REGISTER();//注册用户
int LOGIN();//登录用户
int CREATE(string name);//创建文件
int DELETE(string name);//删除文件
int OPEN(string name);//打开文件
int WRITE(string name);//写文件
int READ(string name);//读文件
int CLOSE(string name);//关闭文件
int CD();//更改当前目录
int MKDIR(string name);//创建文件夹
int DIR();//显示当前目录的子目录
int SET(string name, int protectcode);//设置保护码
void INPUT_OPERATION();//指令输入

int REGISTER()//注册用户
{
	cout &lt;&lt; "请输入用户名:";
	string username;
	cin &gt;&gt; username;
	cout &lt;&lt; "请输入密码:";
	string password;
	cin &gt;&gt; password;
	for (int i = 0; i &lt; MAX_USER_NUM; i++)//最大可有16个用户
	{
		if (mfd[i].username == username)
		{
			cout &lt;&lt; "注册失败，该用户名已存在" &lt;&lt; endl;
			return 0;
		}
	}
	//将用户信息存入用户结构体中
	mfd[cur_user_size].username = username;
	mfd[cur_user_size].password = password;
	cur_user_size++;
	cout &lt;&lt; "注册成功" &lt;&lt; endl;
	return 1;
}

int LOGIN()//用户登入
{
	cout &lt;&lt; "请输入用户名：";
	string username;
	cin &gt;&gt; username;
	cout &lt;&lt; "请输入密码：";
	string password;
	cin &gt;&gt; password;
	int i;
	for (i = 0; i &lt; cur_user_size; i++)
	{
		if (mfd[i].username == username)
		{
			if (mfd[i].password != password)
			{
				cout &lt;&lt; "密码错误" &lt;&lt; endl;
				return 0;
			}
			else
			{
				break;
			}
		}
	}
	if (i == cur_user_size)
	{
		cout &lt;&lt; "没有此用户" &lt;&lt; endl;
		return 0;
	}
	mfd[i].next = &amp;(cur_user_all_direct_array[i]);//用户文件指向第i个用户数组
	cur_user = mfd[i];//登入后此为当前目录
	cur_user.next-&gt;cur_user_direct_size = mfd[i].next-&gt;cur_user_direct_size;//让当前用户找到所登入的用户文件
	cur_user_size++;//用户人数+1
	cur_opentable = &amp;openfile[cur_user_size]; //指针指向文件打开表对象  每一个用户一个文件打开表对象，该表中最多存放16个文件夹
	cur_opentable-&gt;cur_openfilesize = 0;//设置当前打开的文件数为0
	path = "";//设置path在刚登入时为空
	return 1;
}

//查看用户表
int LOOK()
{
	int i;
	for (i = 0; i &lt; cur_user_size; i++)
	{
		cout &lt;&lt; mfd[i].username &lt;&lt; "  ";//遍历现有的用户数，方便观察
	}
	printf("\n"); 
	return 1;
}

string getCurrentTimeStr()//得到时间
{
	time_t t = time(NULL);
	char ch[64] = {0};
	strftime(ch, sizeof(ch) - 1, "%Y-%m-%d %H:%M:%S", localtime(&amp;t));
	return ch;
}

//创建文件
int CREATE(string name)
{
	int index;
	if (path == "")
	{
		cout &lt;&lt; "请先进入文件夹,再创建文件" &lt;&lt; endl;
		return 0;
	}
	for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)
	{
		if (path == cur_user.next-&gt;direct[index].directname)//如果path等于文件夹名
		{
			break;
		}
	}
	int i;
	for (i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)//循环当前文件夹的文件数
	{
		if (name == cur_user.next-&gt;direct[index].ufd[i].filename)
		{
		break;//文件名重复跳出循环
		}
	}
	if (i &lt; cur_user.next-&gt;direct[index].cur_file_size)//重复 i会小于文件数，无重复 则等于
	{
		cout &lt;&lt; "文件名重复" &lt;&lt; endl;
		return 0;
	}
	if (cur_user.next-&gt;direct[index].cur_file_size == MAX_OPEN_FILE_NUM)
	{
		cout &lt;&lt; "该文件夹文件已达到"&lt;&lt; MAX_OPEN_FILE_NUM &lt;&lt; "个" &lt;&lt; endl;
		return 0;
	}
	int j;
	for (j = 0; j &lt; BLOCK_NUM; j++)//判断是否有空闲块 磁盘块数量64 每个块大小512
	{
		if (fat[j].used == 0)
		{
			break;
		}
			
	}
	if (j &gt;= BLOCK_NUM)
	{
		cout &lt;&lt; "磁盘没有空闲块了" &lt;&lt; endl;
		return 0;
	}

	string tim=getCurrentTimeStr();
	cout &lt;&lt; tim &lt;&lt; endl;
	

	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].time = tim;//创建时间
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].filename = name;//上面都通过了保存文件名
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].addr = j; //文件起始盘块号
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].length = 0;//未写入数据，长度为0
	cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].protect_code = 2; //表示可读可写
	//cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size].time = tim;//创建时间
	cur_user.next-&gt;direct[index].cur_file_size++;//用户文件数量加1
    fat[j].used = 1;//此时已被占用
	return 1;
}

//删除文件
int DELETE(string name, int mark)
{
	if (path == "" &amp;&amp; mark == -1)
	{
		cout &lt;&lt; "请在文件夹中删除文件" &lt;&lt; endl;
		return 0;
	}
	int index;
	if(mark != -1) 	//如果是被RMDIR函数调用，则当前path=""
		index = mark;
	else
		for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)//循环用户拥有的文件夹
		{
			if (path == cur_user.next-&gt;direct[index].directname)//找到文件夹后退出
			{
				break;
			}
		}

	int i;
	for (i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)//循环该文件夹的文件
	{
		if (cur_user.next-&gt;direct[index].ufd[i].filename == name)//找到文件后退出
		{
			break;
		}
	}
	if (i &gt;= cur_user.next-&gt;direct[index].cur_file_size)
	{
		cout &lt;&lt; "没有该文件" &lt;&lt; endl;
		return 0;
	}
	int j;
	for (j = 0; i &lt; cur_opentable-&gt;cur_openfilesize; j++)//循环打开的文件，查看是否被打开
	{
		if (cur_opentable-&gt;uof[j].filename == name)
			break;
	}
	if (j &lt; cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; "该文件已被打开，无法删除" &lt;&lt; endl;
		return 0;
	}

	//更新当前用户目录下文件数组信息,就是将最后一个文件的信息替换到要删除的文件的位置

	//如果本身是最后一个文件，那么不需要替换，直接删除
	if(i == cur_user.next-&gt;direct[index].cur_file_size -1)
	{
		fat[cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].addr].used = 0; 
		cur_user.next-&gt;direct[index].cur_file_size--;
		//next为-1 说明没有下一页，此为最后一页
		int temp = fat[cur_user.next-&gt;direct[index].ufd[i].addr].next;
		while (temp != -1)//删除该文件的内存空间
		{
			fat[temp].used = 0;
			temp = fat[temp].next;
		}
		cout &lt;&lt; "删除文件" &lt;&lt; name &lt;&lt; "成功" &lt;&lt; endl;
		return 1;
	}
	else
	{
		cur_user.next-&gt;direct[index].ufd[i].filename = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].filename;
		//先将该块置0
		fat[cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].addr].used = 0; 
		cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].addr = cur_user.next-&gt;direct[index].ufd[i].addr;
		cur_user.next-&gt;direct[index].ufd[i].length = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].length;
		cur_user.next-&gt;direct[index].ufd[i].protect_code = cur_user.next-&gt;direct[index].ufd[cur_user.next-&gt;direct[index].cur_file_size - 1].protect_code;
		cur_user.next-&gt;direct[index].cur_file_size--;

		//将该文件设置为占用
		fat[cur_user.next-&gt;direct[index].ufd[i].addr].used = 1;
		
		//next为-1 说明没有下一页，此为最后一页
		int temp = fat[cur_user.next-&gt;direct[index].ufd[i].addr].next;
		while (temp != -1)//删除该文件的内存空间
		{
			fat[temp].used = 0;
			temp = fat[temp].next;
		}
		cout &lt;&lt; "删除文件" &lt;&lt; name &lt;&lt; "成功" &lt;&lt; endl;
		return 1;
	}
}

int OPEN(string name)//打开文件
{
    if (path == "")
	{
		cout &lt;&lt; "请在文件夹中打开文件" &lt;&lt; endl;
		return 0;
	}
	string AllName = path +'/'+name;//设置该变量的原因是防止出现打开文件数组中存在文件夹名不同而文件同名的情况
	int index;
	for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)//循环当前用户的文件
	{
		if (path == cur_user.next-&gt;direct[index].directname)
		{
			 break;
		}
	}
	int i = 0;
	for (i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)//循环文件数
	{
		if (name == cur_user.next-&gt;direct[index].ufd[i].filename)//找到同名文件
			 break;
	}
	if (i &gt;= cur_user.next-&gt;direct[index].cur_file_size)
	{
		cout &lt;&lt; "没有该文件" &lt;&lt; endl;
		return 0;
	}
	if (cur_opentable-&gt;cur_openfilesize == MAX_OPEN_FILE_NUM)
	{
		cout &lt;&lt; "文件打开数量已经达到最大值" &lt;&lt; endl;
		return 0;
	}
	
	for (int j = 0; i &lt; cur_opentable-&gt;cur_openfilesize; j++)
	{
		if (cur_opentable-&gt;uof[i].filename == AllName)//在打开文件中找到相应文件夹中的文件
		{
			 cout &lt;&lt; "该文件已经打开" &lt;&lt; endl;
			 return 0;
		}
	}
	int k;
	for (k = 0; k &lt; cur_user.next-&gt;direct[index].cur_file_size; k++)
	{
		if (cur_user.next-&gt;direct[index].ufd[k].filename == name)//找到相应文件夹中的文件
		 break;
	} 
	//将该文件的信息加入到已打开的文件数组中
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].filename = AllName;//在打开的文件数组中加入该文件
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].protect_code = 	cur_user.next-&gt;direct[index].ufd[k].protect_code;//保护码
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].pointer = cur_user.next-&gt;direct[index].ufd[k].length;
	cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize].addr = cur_user.next-&gt;direct[index].ufd[k].addr;//起始地址
	cur_opentable-&gt;cur_openfilesize++; //文件打开数量加1
	cout &lt;&lt; "文件打开成功" &lt;&lt;endl;
	return k; //返回文件在文件打开表中的第几项
}

int CLOSE(string name)//关闭文件
{	
	int i;
	for (i = 0; i &lt; cur_opentable-&gt;cur_openfilesize; i++)
	{
		if (cur_opentable-&gt;uof[i].filename == path + '/' + name)
		{
			break;
		}
	}
	if (i &gt;= cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; "该文将未打开" &lt;&lt; endl;
		return 0;
	}
	//更新当前用户打开文件数组信息,就是将最后一个打开文件的信息替换到要关闭的打开文件的位置
	cur_opentable-&gt;uof[i].filename = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].filename;
	cur_opentable-&gt;uof[i].pointer = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].pointer;
	cur_opentable-&gt;uof[i].protect_code = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].protect_code;
	cur_opentable-&gt;uof[i].addr = cur_opentable-&gt;uof[cur_opentable-&gt;cur_openfilesize - 1].addr;
	cur_opentable-&gt;cur_openfilesize--;
	cout &lt;&lt; "文件关闭成功" &lt;&lt; endl;
	return 1;
}

int WRITE(string name)//写入文件
{
	int index; //标识当前目录在direct数组中第几个
	for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)
	{
		if (path == cur_user.next-&gt;direct[index].directname)//在当前用户的文件夹中找到相应的文件
		{
			break;
		}
	}
	int i;
	//判读文件是否打开
	for (i = 0; i &lt; cur_opentable-&gt;cur_openfilesize; i++)
	{
		if (cur_opentable-&gt;uof[i].filename == path + '/' + name)//循环打开的文件
			break;
	}
	if (i &gt;= cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; "文件没有打开， 无法写入" &lt;&lt; endl;
		return -1;
	}
	int fd = i; //获取文件描述字
	//判断读文件的合法性
	if (cur_opentable-&gt;uof[fd].protect_code != 2)
	{
		cout &lt;&lt; "文件不可写" &lt;&lt; endl;
		return -1;
	}
	else
	{
		string content;//字符串  存储输入的一行内容
		cin.ignore();
		//cin.ignore()函数是C++标准输入流（cin）中的一个方法。cin.ignore()函数中有两个参数，
		//分别为数值型的a 和 字符型的 ch ，即cin.ignore( a, ch )。它表示从输入流 cin 中提取
		//字符，提取的字符被忽略，不被使用。而每抛弃一个字符，它都要进行计数和比较字符：如果
		//计数值达到 a 或者被抛弃的字符是 ch ，则cin.ignore() 函数执行终止；否则，它继续等待。
		//如果默认不给参数的话，默认参数为cin.ignore(1, EOF)，即把EOF前的1个字符清掉,没有遇
		//到EOF就清掉一个字符然后结束。
		cout &lt;&lt; "请输入文件要写入的内容: " &lt;&lt; endl;;
		getline(cin, content); //读入一整行内容
		int cin_len = content.length();//输入一行的长度
		int cin_p=0;//初值为0
		int last_block_res;//磁盘剩余空间的大小

		//追加写
		//找到该文件存放的最后一个磁盘块  
		int last_block = cur_opentable-&gt;uof[fd].addr;
		while (fat[last_block].next != -1)
		{
			last_block = fat[last_block].next;
		}

		int temp;//保存当前所写的文件在用户文件目录表的第几项，为了后面修改文件的大小
		for (int k = 0; k &lt; cur_user.next-&gt;direct[index].cur_file_size; k++)
		{
			if (cur_user.next-&gt;direct[index].ufd[k].filename == name)//找到该文件
			{
				temp = k;
				break;
			}
		}

		//计算该文件存放的最后一个地址
		char  * first;
		first = fdisk + last_block * BLOCK_SIZE + cur_opentable-&gt;uof[fd].pointer % BLOCK_SIZE;

		//计算最后一个磁盘块还有多少空间
		if(cur_opentable-&gt;uof[fd].pointer == 0)
			last_block_res = BLOCK_SIZE;
		else if(cur_opentable-&gt;uof[fd].pointer % BLOCK_SIZE == 0)
			last_block_res = 0;
		else
			last_block_res = BLOCK_SIZE - (cur_opentable-&gt;uof[fd].pointer % BLOCK_SIZE);

		//首先填满最后一个磁盘块
		if(last_block_res)
		{
			if(last_block_res &lt;= cin_len)	//当最后一个磁盘块的空间小于输入内容大小
			{
				for(int j=0;j&lt;last_block_res;j++)
					first[j] = content[cin_p++];
				cin_len -= last_block_res;//计算还有多少字符没存入
			}
			else	//当最后一个磁盘块的空间大于输入内容大小
			{
				for(int j=0;j&lt;cin_len;j++)
					first[j] = content[cin_p++];
				cur_opentable-&gt;uof[fd].pointer = cur_opentable-&gt;uof[fd	].pointer + cin_len;  //更新文件打开表
				cur_user.next-&gt;direct[index].ufd[temp].length = cur_user.next-&gt;direct[index].ufd[temp].length + cin_len; //更新用户目录文件表
				cout &lt;&lt; "文件写入成功，共写入" &lt;&lt; cin_len &lt;&lt; "字节" &lt;&lt; endl;
				return 0;
			}
		}

		//计算还需要多少个磁盘块，判断空间是否足够
		int times = cin_len / BLOCK_SIZE;//向上取整 求存满块数
		int offset = cin_len % BLOCK_SIZE;//取余  未存满
		if (offset != 0)
			times++;//块数＋1

		int unused_block_num = 0; //记录没有使用过的磁盘块的个数
		int flag = 0;
		for (int j = 0; j &lt; BLOCK_NUM; j++)
		{
			if (fat[j].used == 0)
			{
				unused_block_num++;
			}
		}

		if(unused_block_num &lt; times)//剩余的块不够写
		{
			cout&lt;&lt;"空间不足，写入内容失败！\n";
			return -1;
		}

		int next_block = fat[cur_opentable-&gt;uof[fd].addr].next; //记录块的起始地址的next
		int first_unused_block; //记录第一个没有被使用过的磁盘
		for(int j=0;j&lt;times;j++)
		{
			for (int k = 0; k &lt; BLOCK_NUM; k++)
			{
				if (fat[k].used == 0)
				{
					first_unused_block = k;
					break;
				}
			}
			fat[last_block].next = first_unused_block;
			last_block = first_unused_block;
			first = fdisk + last_block * BLOCK_SIZE;
			if(j!=times-1)
			{
				for(int k = 0;k&lt;BLOCK_SIZE;k++)
					first[k] = content[cin_p++];
			}
			else
			{
				for(int k=0;k&lt;offset;k++)
					first[k] = content[cin_p++];
			}

		}
		cur_opentable-&gt;uof[fd].pointer = cur_opentable-&gt;uof[fd].pointer + cin_p;  //更新文件打开表
		cur_user.next-&gt;direct[index].ufd[temp].length = cur_user.next-&gt;direct[index].ufd[temp].length + cin_p; //更新用户目录文件表
		cout &lt;&lt; "文件写入成功，共写入" &lt;&lt; cin_p &lt;&lt; "字节" &lt;&lt; endl;
		return 0;
	}
}

int READ(string name)//读文件
{
	int index1; //标识当前目录在direct数组中第几个
	for (index1 = 0; index1 &lt; cur_user.next-&gt;cur_user_direct_size; index1++)
	{
		if (path == cur_user.next-&gt;direct[index1].directname)//找到文件夹
		{
			break;
		}
	}
	int a;
	for (a = 0; a &lt; cur_user.next-&gt;direct[index1].cur_file_size; a++)    //判断文件是否存在
	{
	if (cur_user.next-&gt;direct[index1].ufd[a].filename == name)//找文件
		break;
	}
	if (a &gt;= cur_user.next-&gt;direct[index1].cur_file_size)
	{
		cout &lt;&lt; "没有这个文件" &lt;&lt; endl;
		return 0;
	}
	int i;
	//判读文件是否打开
	for (i = 0; i &lt; cur_opentable-&gt;cur_openfilesize; i++)
	{
		if (cur_opentable-&gt;uof[i].filename == path + '/' + name)
			break;
	}
	if (i &gt;= cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; "文件没有打开， 无法读取" &lt;&lt; endl;
		return -1;
	}
	int fd = i; //获取文件描述字
	//判断读文件的合法性
	if (cur_opentable-&gt;uof[fd].protect_code == 0) //我们创建的文件都是默认可读可写的
	{
		cout &lt;&lt; "文件不可读" &lt;&lt; endl;
		return 0;
	}
	else
	{
		int len = cur_opentable-&gt;uof[fd].pointer; //文件的长度
		int block_num = len / BLOCK_SIZE; //磁盘的个数
		int offset = len % BLOCK_SIZE; //偏移量
		if (offset != 0)
			block_num++;
		
		//如果我用一个文件表示磁盘的引导块，用另一个文件表示磁盘的	数据块，那么我们计算文件的起始位置就不用加上磁盘的引导块了吧
		//关于文件的存放文件，我们char *fdisk表示一整个磁盘，然后不		同文件的内容存放在这个指针所指向的不同字符段
		char * first = fdisk + cur_opentable-&gt;uof[fd].addr * BLOCK_SIZE; //文件的起始地址 第0块起始地址为0 第1块起始地址为512
		char * buf = (char *)malloc(513 * sizeof(char)); //缓冲区  给指针申请513个char类型大小的空间  512个空间存放内容 第513个存\0
		cout &lt;&lt; "文件的内容为 :" &lt;&lt; endl;
		for (int k = 0; k &lt; block_num; k++)
		{
			if (k == block_num - 1)  //则是最后一个磁盘块
			{
				int j;
				for (j = 0; j &lt; len - k * BLOCK_SIZE; j++)  //赋值文件剩余的字符，其实就是偏移量
				{
					buf[j] = first[j];
				}
				buf[j] = '\0';//\0结束
				printf("%s\n", buf); //输出文件的内容
			}
			else //不在最后一个磁盘块，也就是在其他已经读满的磁盘块
			{
				int j;
				for (j = 0; j &lt; BLOCK_SIZE; j++)
					buf[j] = first[j]; //缓冲区读满就输出内容
				buf[j] = '\0';
				printf("%s", buf); //输出文件的内容
				int next_block = fat[cur_opentable-&gt;uof[fd].addr].next; 				//读完一个磁盘块后，在接着读下一个磁盘块
				first = fdisk + next_block * BLOCK_SIZE;
			}
		}
		cout &lt;&lt; endl;
		free(buf); //释放缓冲区
		return 0;
	}
}

int CD()//更改当前目录
{
	string temp_path;
	cin &gt;&gt; temp_path;
	if (temp_path == "..")
	{
		if(path == "")
		{
			cout &lt;&lt; "已在根目录" &lt;&lt; endl;
		}
		else
		{
			path = "";
		  	
		}
			return 1;
	}
	int i;
	for (i = 0; i &lt; cur_user.next-&gt;cur_user_direct_size; i++)
	{
		if (temp_path == cur_user.next-&gt;direct[i].directname)
			break;
	}
	if (i &gt;= cur_user.next-&gt;cur_user_direct_size)
	{
		cout &lt;&lt; "没有此目录" &lt;&lt; endl;
		return 0;
	}
	path = temp_path;//path为该路径
	return 1;
}

int MKDIR(string name)//创建目录
{
	if (cur_user.next-&gt;cur_user_direct_size == MAX_USER_NUM)
	{
		cout &lt;&lt; "用户目录数量已经达到最大值" &lt;&lt; endl;
		return 0;
	}
	int i;
	for (i = 0; i &lt; cur_user.next-&gt;cur_user_direct_size; i++)
	{
		if (cur_user.next-&gt;direct[i].directname == name)
			break;
	}
	if (i &lt; cur_user.next-&gt;cur_user_direct_size)
	{
		cout &lt;&lt; "该目录名已存在" &lt;&lt; endl;
		return 0;
	}
	cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size].directname = name;
	cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size].cur_file_size = 0; //新创建的目录里面的文件个数为0
	cur_user.next-&gt;cur_user_direct_size++;
	cout &lt;&lt; "创建目录成功" &lt;&lt; endl;
	return 1;
}

int RMDIR(string name)//删除目录
{
	if(path != "")
	{
		cout &lt;&lt; "请先退出文件夹" &lt;&lt; endl;
		return 0;
	}
	int index;//文件夹的位置
	for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)//先判断是否有该文件夹
	{
		if (name == cur_user.next-&gt;direct[index].directname)
			break;
	}

	for (int i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)
	{
		for(int j=0;i&lt;cur_opentable-&gt;cur_openfilesize;j++)
			if (name + '/' + cur_user.next-&gt;direct[index].ufd[i].filename 	== cur_opentable-&gt;uof[j].filename)
			{
				cout &lt;&lt; "请先关闭该文件夹的所有文件" &lt;&lt; endl;
				return 0;
			}
	}
	//删除该文件夹的所有文件

	for (int i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)
	{
		DELETE(cur_user.next-&gt;direct[index].ufd[i].filename, index);
	}
	//把最后一个文件的位置放到删除的位置
	cur_user.next-&gt;direct[index].cur_file_size = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - 1].cur_file_size;  //注意这里	需要减一，由于本身结构的限制
	cur_user.next-&gt;direct[index].directname = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - 1].directname;
	//改变文件的位置
	for (int i = 0; i &lt; cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - 1].cur_file_size; i++)  //注意这里的减一
	{
		cur_user.next-&gt;direct[index].ufd[i].addr = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - 1].ufd[i].addr;
		cur_user.next-&gt;direct[index].ufd[i].filename = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - 1].ufd[i].filename;
		cur_user.next-&gt;direct[index].ufd[i].length = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - 1].ufd[i].length;
		cur_user.next-&gt;direct[index].ufd[i].protect_code = cur_user.next-&gt;direct[cur_user.next-&gt;cur_user_direct_size - 1].ufd[i].protect_code;
	}
	cur_user.next-&gt;cur_user_direct_size--; //目录数量减1
	cout &lt;&lt; "删除目录成功" &lt;&lt; endl;
	return 1;
}

int DIR()//显示当前地址下的内容
{
	int index;
	for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)
	{
		if (path == cur_user.next-&gt;direct[index].directname)
		{
			break;
		}
	}
	if (path == "")
	{
		cout &lt;&lt; "  目录名" &lt;&lt; endl;
		for (int i = 0; i &lt; cur_user.next-&gt;cur_user_direct_size; i++)
		{
			cout &lt;&lt; "  " &lt;&lt; cur_user.next-&gt;direct[i].directname &lt;&lt; endl;
		}
	}
	else
	{
		cout &lt;&lt; "\t文件名\t文件保护码\t文件长度\t文件起始盘块号\t\t创建日期" &lt;&lt; endl;
		for (int i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)
		{
			cout &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[index].ufd[i].filename &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[index].ufd[i].protect_code &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt;cur_user.next-&gt;direct[index].ufd[i].length &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; cur_user.next-&gt;direct[index].ufd[i].addr &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt; "\t" &lt;&lt;  cur_user.next-&gt;direct[index].ufd[i].time &lt;&lt; endl;
		}
	}
	return 1;
}

int SET(string name,int protectcode)//设置文件保护码
{
	int index;
	for (index = 0; index &lt; cur_user.next-&gt;cur_user_direct_size; index++)//找到文件夹的位置
	{
		if (path == cur_user.next-&gt;direct[index].directname)
		{
			break;
		}
	}
	int i = 0;
	for (i = 0; i &lt; cur_user.next-&gt;direct[index].cur_file_size; i++)//找文件
	{
		if (name == cur_user.next-&gt;direct[index].ufd[i].filename)
			break;
	}
	if (i &gt;= cur_user.next-&gt;direct[index].cur_file_size)
	{
		cout &lt;&lt; "该用户没有这个文件" &lt;&lt; endl;
		return 0;
	}
	int j;
	for (j = 0; i &lt; cur_opentable-&gt;cur_openfilesize; j++)
	{
		if (cur_opentable-&gt;uof[j].filename == path + "/" + name)
		break;
	}
	if (j &lt; cur_opentable-&gt;cur_openfilesize)
	{
		cout &lt;&lt; "请先关闭该文件" &lt;&lt; endl;
		return 0;
	}
	cur_user.next-&gt;direct[index].ufd[i].protect_code = protectcode;
	return 1;
}

//输出块的状态
int fatused()
{

	for (int i = 0; i &lt; BLOCK_NUM; i++)//判断是否有空闲块 磁盘块数量64 每个块大小512
		{
			// cout &lt;&lt; fat[i].used &lt;&lt; " ";
			printf("%d  ",fat[i].used);
			if(i % 8 == 0)
			{
				cout &lt;&lt; endl;
			}
		}
		cout &lt;&lt; endl;
	return 1;
}


void INPUT_OPERATION()//指令输入
{
	if (cur_user.username == "")
		cout &lt;&lt; "localhost :";
	else
		cout &lt;&lt; cur_user.username &lt;&lt; "@localhost  home/" &lt;&lt; path &lt;&lt; ":";
	string operaton;
	cin &gt;&gt; operaton;
	if (operaton == "login")
	{
		LOGIN();
	}
	else if (operaton == "create")
	{
		string filename;
		cin &gt;&gt; filename;
		CREATE(filename);
	}
	else if (operaton == "del")
	{
		string name;
		cin &gt;&gt; name;
		DELETE(name, -1);
	}
	else if (operaton == "open")
	{
		string name;
		cin &gt;&gt; name;
		OPEN(name);
	}
	else if (operaton == "close")
	{
		string name;
		cin &gt;&gt; name;
		CLOSE(name);
	}
	else if (operaton == "write")
	{
		string content;
		string name;
		cin &gt;&gt; name;
		WRITE(name);
	}
	else if (operaton == "read")
	{
		string name;
		cin &gt;&gt; name;
		READ(name);
	}
	else if (operaton == "exit")
	{
		exit(0);
	}
	else if (operaton == "cd")
	{
	CD();
	}
	else if (operaton == "dir")
	{
		DIR();
	}
	else if (operaton == "mkdir")
	{
		string name;
		cin &gt;&gt; name;
		MKDIR(name);
	}
	else if (operaton == "register")
	{
		REGISTER();
	}
	else if (operaton == "exit")
	{
		mark = 0;
	}
	else if (operaton == "set")
	{
		string name;
		int protextcode;
		cin &gt;&gt; name;
		cin &gt;&gt; protextcode;
		SET(name, protextcode);
	}
	else if (operaton == "rmdir")
	{
		string name;
		cin &gt;&gt; name;
		RMDIR(name);
	}
	else if (operaton == "look")
	{
		LOOK();
	}
	else if (operaton == "fatused")
	{
		fatused();
	}
	else
	{
		cout &lt;&lt; "命令错误，请重新输入" &lt;&lt; endl;
	}
}

int main()
{
	cur_user.username = "";
	path = "";
	fdisk = (char *)malloc(1024 * 1024 * sizeof(int));//模拟硬盘指针
	
	//注册root用户并登录，方便调试代码
	mfd[cur_user_size].username = "root";
	mfd[cur_user_size].password = "123456";
	cur_user_size++;
	mfd[0].next = &amp;(cur_user_all_direct_array[0]);
	cur_user = mfd[0];
	cur_user.next-&gt;cur_user_direct_size = mfd[0].next-&gt;cur_user_direct_size;
	cur_user_size++;
	cur_opentable = &amp;openfile[cur_user_size]; //指针指向文件打开表对象
	cur_opentable-&gt;cur_openfilesize = 0;
	
	cout &lt;&lt; "*******************欢迎使用二级文件系统*******************" &lt;&lt; endl;
	cout &lt;&lt; "        命令格式                说明                      " &lt;&lt; endl;
	cout &lt;&lt; "        register                注册用户                  " &lt;&lt; endl;
	cout &lt;&lt; "        login                   登录                      " &lt;&lt; endl;
	cout &lt;&lt; "        cd 目录名               更改当前目录              " &lt;&lt; endl;
	cout &lt;&lt; "        mkdir 目录名            创建子目录                " &lt;&lt; endl;
	cout &lt;&lt; "        rmdir 目录名            删除子目录                " &lt;&lt; endl;
	cout &lt;&lt; "        dir                     显示当前目录的子目录      " &lt;&lt; endl;
	cout &lt;&lt; "        create 文件名           创建文件                  " &lt;&lt; endl;
	cout &lt;&lt; "        del 文件名              删除文件                  " &lt;&lt; endl;
	cout &lt;&lt; "        open 文件名             打开文件                  " &lt;&lt; endl;		
	cout &lt;&lt; "        close                   关闭文件                  " &lt;&lt; endl;
	cout &lt;&lt; "        read 文件名               读文件                    " &lt;&lt; endl;
	cout &lt;&lt; "        write 文件名              写文件                    " &lt;&lt; endl;
	cout &lt;&lt; "        set 文件名 文件保护码   设置文件保护码            " &lt;&lt; endl;
	cout &lt;&lt; "        exit                    退出系统                  " &lt;&lt; endl;
	cout &lt;&lt; "        look                    查看用户                 " &lt;&lt; endl;
	cout &lt;&lt; "        fatused                 查看块                 " &lt;&lt; endl;
	while (mark)
		INPUT_OPERATION();
	free(fdisk);
	return 1;
}</code></pre> 
<p>此文章为学习记录^_^ </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e8b0b987ce5e290c52ba140d479385e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Stable Diffusion 基本原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47c05addf4428ab00721413821eac0d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Fiddler入门：下载、安装、配置、抓包、customize rules</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>