<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[MySQL][深入理解隔离性][下][Read View]详细讲解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/579f072fb4a33c8592b1875db46f8487/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[MySQL][深入理解隔离性][下][Read View]详细讲解">
  <meta property="og:description" content="目录 1.Read View1.是什么？2.理解3.整体流程 2.RR与RC的本质区别1.当前读和快照读在RR级别下的区别2.RR与RC的本质区别 1.Read View 1.是什么？ Read View就是事务进行 快照读 操作的时候生产的 读视图(Read View)，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID，这个ID是递增的，所以最新的事务，ID值越大)Read View 在 MySQL 源码中，就是一个类，本质是用来进行可见性判断的 即：当某个事务执行快照读的时候，对该记录创建一个 Read View 读视图，把它比作条件，用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的 undo log 里面的某个版本的数据注意：Read View是事务可见性的一个类，不是事务创建出来的，就会有Read View，而是当这个事务(已经存在)，首次进行快照读的时候，MYSQL形成Read View 下面是 ReadView 结构，但为了减少同学们负担，我们简化一下class ReadView { // 省略... private: /** 高水位，大于等于这个ID的事务均不可见*/ trx_id_t m_low_limit_id /** 低水位：小于这个ID的事务均可见 */ trx_id_t m_up_limit_id; /** 创建该 Read View 的事务ID*/ trx_id_t m_creator_trx_id; /** 创建视图时的活跃事务id列表*/ ids_t m_ids; /** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG， * 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/ trx_id_t m_low_limit_no; /** 标记视图是否被关闭*/ bool m_closed; // 省略... }; m_ids; // 一张列表，用来维护Read View生成时刻，系统正活跃的事务ID up_limit_id; // 记录m_ids列表中事务ID最小的ID(没有写错) low_limit_id; // ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值&#43;1 creator_trx_id // 创建该ReadView的事务ID 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T00:02:55+08:00">
    <meta property="article:modified_time" content="2024-07-22T00:02:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[MySQL][深入理解隔离性][下][Read View]详细讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1Read_View_3" rel="nofollow">1.Read View</a></li><li><ul><li><a href="#1_5" rel="nofollow">1.是什么？</a></li><li><a href="#2_45" rel="nofollow">2.理解</a></li><li><a href="#3_61" rel="nofollow">3.整体流程</a></li></ul> 
  </li><li><a href="#2RRRC_108" rel="nofollow">2.RR与RC的本质区别</a></li><li><ul><li><a href="#1RR_110" rel="nofollow">1.当前读和快照读在RR级别下的区别</a></li><li><a href="#2RRRC_147" rel="nofollow">2.RR与RC的本质区别</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="1Read_View_3"></a>1.Read View</h2> 
<h3><a id="1_5"></a>1.是什么？</h3> 
<ul><li>Read View就是事务进行 <strong>快照读</strong> 操作的时候生产的 <strong><font color="red">读视图(Read View)</font></strong>，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID，这个ID是递增的，所以最新的事务，ID值越大)</li><li><strong>Read View</strong> 在 MySQL 源码中，<strong>就是一个类</strong>，<font color="red"><strong>本质是用来进行可见性判断的</strong></font> 
  <ul><li>即：<strong>当某个事务<font color="red">执行快照读的时候</font>，对该记录创建一个 Read View 读视图，把它比作条件，<font color="red">用来判断当前事务能够看到哪个版本的数据</font></strong>，既可能是当前最新的数据，也有可能是该行记录的 undo log 里面的某个版本的数据</li><li><font color="red"><strong>注意：</strong></font>Read View是事务可见性的一个类，不是事务创建出来的，就会有Read View，而是当这个事务(已经存在)，首次进行快照读的时候，MYSQL形成Read View</li></ul> </li><li>下面是 ReadView 结构，但为了减少同学们负担，我们简化一下<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">ReadView</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 省略...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">/** 高水位，大于等于这个ID的事务均不可见*/</span>
    trx_id_t m_low_limit_id

    <span class="token comment">/** 低水位：小于这个ID的事务均可见 */</span>
    trx_id_t m_up_limit_id<span class="token punctuation">;</span>

    <span class="token comment">/** 创建该 Read View 的事务ID*/</span>
    trx_id_t m_creator_trx_id<span class="token punctuation">;</span>

    <span class="token comment">/** 创建视图时的活跃事务id列表*/</span>
    ids_t m_ids<span class="token punctuation">;</span>

    <span class="token comment">/** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，
     * 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/</span>
    trx_id_t m_low_limit_no<span class="token punctuation">;</span>

    <span class="token comment">/** 标记视图是否被关闭*/</span>
    <span class="token keyword">bool</span> m_closed<span class="token punctuation">;</span>

    <span class="token comment">// 省略...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

m_ids<span class="token punctuation">;</span> <span class="token comment">// 一张列表，用来维护Read View生成时刻，系统正活跃的事务ID</span>
up_limit_id<span class="token punctuation">;</span> <span class="token comment">// 记录m_ids列表中事务ID最小的ID(没有写错)</span>
low_limit_id<span class="token punctuation">;</span> <span class="token comment">// ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</span>
creator_trx_id <span class="token comment">// 创建该ReadView的事务ID</span>
</code></pre> </li></ul> 
<h3><a id="2_45"></a>2.理解</h3> 
<ul><li> <p>在实际读取数据版本链的时候，是能读取到每一个版本对应的事务ID的，即：当前记录的DB_TRX_ID</p> </li><li> <p>那么，现在手里面有的东西就有，<strong>当前快照读的 ReadView</strong> 和 <strong>版本链中的某一个记录的DB_TRX_ID</strong></p> </li><li> <p><font color="blue"><strong>所以现在的问题就是，当前快照读，应不应该读到当前版本记录？</strong></font></p> <p><img src="https://images2.imgbox.com/5a/55/s3j8JqJl_o.png" alt="请添加图片描述"></p> </li><li> <p><strong>对应源码策略</strong></p> 
  <ul><li> <p>如果查到不应该看到当前版本，接下来就是遍历下一个版本，直到符合条件，才可以看到</p> </li><li> <p>下面的 readview 是当你进行select的时候，会自动形成</p> <p><img src="https://images2.imgbox.com/56/40/fgPvOUUP_o.png" alt="请添加图片描述"></p> </li></ul> </li></ul> 
<h3><a id="3_61"></a>3.整体流程</h3> 
<ul><li> <p>假设当前有条记录：</p> 
  <table><thead><tr><th><strong>name</strong></th><th><strong>age</strong></th><th>**DB_TRX_ID(**<strong>创建该记录的事务ID)</strong></th><th>**DB_ROW_ID(**<strong>隐式主键)</strong></th><th>**DB_ROLL_PTR(**<strong>回滚指针)</strong></th></tr></thead><tbody><tr><td><strong>张三</strong></td><td><strong>28</strong></td><td><strong>null</strong></td><td><strong>1</strong></td><td><strong>null</strong></td></tr></tbody></table></li><li> <p>事务操作：<br> <img src="https://images2.imgbox.com/98/b3/AyKp8woN_o.png" alt="请添加图片描述"></p> </li><li> <p>事务4：修改name(张三)变成name(李四)</p> 
  <ul><li>当 事务2 对某行数据执行了快照读 ，数据库为该行数据生成一个 Read View 读视图</li></ul> <pre><code class="prism language-cpp"><span class="token comment">// 事务2的 Read View</span>
m_ids<span class="token punctuation">;</span> <span class="token comment">// 1,3</span>
up_limit_id<span class="token punctuation">;</span> <span class="token comment">// 1</span>
low_limit_id<span class="token punctuation">;</span> <span class="token comment">// 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID</span>
creator_trx_id <span class="token comment">// 2</span>
</code></pre> </li><li> <p>此时版本链是：<br> <img src="https://images2.imgbox.com/81/62/8jPDfbqE_o.png" alt="请添加图片描述"></p> </li><li> <p>只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务<br> <img src="https://images2.imgbox.com/f9/45/wNqdZxXR_o.png" alt="请添加图片描述"></p> </li><li> <p><strong>事务2在快照读该行记录的时候，就会拿该行记录的 <font color="red">DB_TRX_ID 去跟 up_limit_id，low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本</font></strong></p> <pre><code class="prism language-mysql">// 事务2的 Read View
m_ids;          // 1,3
up_limit_id;    // 1
low_limit_id;   // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
creator_trx_id  // 2

// 事务4提交的记录对应的事务ID
DB_TRX_ID=4

// 比较步骤
DB_TRX_ID（4）&lt; up_limit_id（1） ? 不小于，下一步
DB_TRX_ID（4）&gt;= low_limit_id(5) ? 不大于，下一步
m_ids.contains(DB_TRX_ID) ? 不包含，说明，事务4不在当前的活跃事务中

// 结论
故，事务4的更改，应该看到
所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本
</code></pre> </li></ul> 
<hr> 
<h2><a id="2RRRC_108"></a>2.RR与RC的本质区别</h2> 
<h3><a id="1RR_110"></a>1.当前读和快照读在RR级别下的区别</h3> 
<ul><li> <p><code>select * from user lock in share mode;</code>以加共享锁方式进行读取，对应的就是当前读</p> </li><li> <p>测试表</p> <pre><code class="prism language-mysql">--设置RR模式下测试
mysql&gt; set global transaction isolation level REPEATABLE READ;

--重启终端
mysql&gt; select @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+

--依旧用之前的表
create table if not exists account(
    id int primary key,
    name varchar(50) not null default '',
    blance decimal(10,2) not null default 0.0
)ENGINE=InnoDB DEFAULT CHARSET=UTF8;

--插入一条记录，用来测试
mysql&gt; insert into user (id, age, name) values (1, 15,'黄蓉');
</code></pre> </li><li> <p>测试用例1-表1：<br> <img src="https://images2.imgbox.com/93/7e/ZMbOeAXV_o.png" alt="请添加图片描述"></p> </li><li> <p>测试用例2-表2：<br> <img src="https://images2.imgbox.com/be/06/8yrbbQy1_o.png" alt="请添加图片描述"></p> </li><li> <p>用例1与用例2：<strong><font color="purple">唯一区别仅仅是 表1 的事务B在事务A修改age前快照读过一次age数据，而 表2 的事务B在事务A修改age前没有进行过快照读</font></strong></p> </li><li> <p><font color="red"><strong>结论：</strong></font></p> 
  <ul><li><font color="red"><strong>事务中快照读的结果是非常依赖该事务首次出现快照读的地方</strong></font> 
    <ul><li>即某个事务中首次出现快照读，决定该事务后续快照读结果的能力</li></ul> </li><li>delete同样如此</li></ul> </li></ul> 
<h3><a id="2RRRC_147"></a>2.RR与RC的本质区别</h3> 
<ul><li><font color="red"><strong>正是Read View生成时机的不同，从而造成RC，RR级别下快照读的结果的不同</strong></font></li><li><font color="red"><strong>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View</strong></font>，将当前系统活跃的其他事务记录起来 
  <ul><li>此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见</li><li><strong>即：RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</strong></li></ul> </li><li><font color="red"><strong>在RC级别下的事务中，每次快照读都会新生成一个快照和Read View</strong></font>，这就是在RC级别下的事务中可以看到别的事务提交的更新的原因 
  <ul><li>正是RC每次快照读，都会形成Read View，所以，RC才会有不可重复读问题</li></ul> </li><li><strong>总结：</strong> 
  <ul><li>在RC隔离级别下，是每个快照读都会生成并获取最新的Read View</li><li>而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View</li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb55c8587f460d8effbec16118144140/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ACM_前缀和算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fb1f369d5141007dfbcf98f2b24ff33f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】string类（上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>