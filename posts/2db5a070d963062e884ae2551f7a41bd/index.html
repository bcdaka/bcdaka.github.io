<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43;基础知识 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2db5a070d963062e884ae2551f7a41bd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C/C&#43;&#43;基础知识">
  <meta property="og:description" content="数据类型 目录
数据类型
基本数据类型
变量所占大小
char
构造类型
数组
1.一维数组
2.二维数组
结构体
联合体
指针 内存的申请与释放
C&#43;&#43;中的new
malloc
malloc与new的异同
C&#43;&#43;中的delete
free
new和delete是如何实现的
malloc和free的实现
被free回收的内存是立即还给操作系统了吗
calloc与realloc
指针类型
数组指针与指针数组
二级指针
函数指针
指针大小
*的三种作用
C&#43;&#43;引用变量
声明
常量引用
指针的引用
引用与函数
引用与指针的区别
修饰符
static的用法和作用
静态变量什么时候初始化
指针与const的用法
基本数据类型 变量所占大小 X64X86char1字节1字节short2字节2字节int4字节4字节long8字节4字节long long8字节8字节float4字节4字节double8字节8字节long double 通常16字节通常8字节 char 分为三类型：
1.char：标准类型
2.unsigned char：无符号char（0~255）
3.signed char：有符号char（-128~127）
构造类型 数组 1.一维数组 字符串/字符数组
char arr1[] = &#34;hello&#34;; 字符串:结尾有&#39;\0&#39;终止符,arr1占6字节 char arr2[] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;}; 字符数组：结尾无&#39;\0&#39;，arr2占5字节 &#39;\0&#39;影响printf等输出，输出结果为&#39;\0&#39;之前 字符串的申明方式">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-27T21:34:42+08:00">
    <meta property="article:modified_time" content="2024-07-27T21:34:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43;基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</h2> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">数据类型</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">基本数据类型</a></p> 
<p id="%E5%8F%98%E9%87%8F%E6%89%80%E5%8D%A0%E5%A4%A7%E5%B0%8F-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E9%87%8F%E6%89%80%E5%8D%A0%E5%A4%A7%E5%B0%8F" rel="nofollow">变量所占大小</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20char-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20char" rel="nofollow">        char</a></p> 
<p id="%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B" rel="nofollow">构造类型</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%95%B0%E7%BB%84" rel="nofollow">        数组</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:120px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">        1.一维数组</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-toc" style="margin-left:120px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" rel="nofollow">        2.二维数组</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">        结构体</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E8%81%94%E5%90%88%E4%BD%93-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E8%81%94%E5%90%88%E4%BD%93" rel="nofollow">        联合体</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%C2%A0" rel="nofollow">        指针 </a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE-toc" style="margin-left:120px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE" rel="nofollow">         内存的申请与释放</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E4%B8%AD%E7%9A%84new-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E4%B8%AD%E7%9A%84new" rel="nofollow">                C++中的new</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc" rel="nofollow">                malloc</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc%E4%B8%8Enew%E7%9A%84%E5%BC%82%E5%90%8C-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc%E4%B8%8Enew%E7%9A%84%E5%BC%82%E5%90%8C" rel="nofollow">                malloc与new的异同</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E4%B8%AD%E7%9A%84delete-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E4%B8%AD%E7%9A%84delete" rel="nofollow">                C++中的delete</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20free-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20free" rel="nofollow">                free</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84" rel="nofollow">               new和delete是如何实现的</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc%E5%92%8Cfree%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc%E5%92%8Cfree%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">                malloc和free的实现</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%86%E5%90%97-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%86%E5%90%97" rel="nofollow">               被free回收的内存是立即还给操作系统了吗</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20calloc%E4%B8%8Erealloc-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20calloc%E4%B8%8Erealloc" rel="nofollow">                calloc与realloc</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:120px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B" rel="nofollow">         指针类型</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow">                数组指针与指针数组</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88" rel="nofollow">                二级指针</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88" rel="nofollow">                函数指针</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%E5%A4%A7%E5%B0%8F-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%E5%A4%A7%E5%B0%8F" rel="nofollow">                指针大小</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20*%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%9C%E7%94%A8-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20*%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%9C%E7%94%A8" rel="nofollow">                *的三种作用</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F-toc" style="margin-left:120px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F" rel="nofollow">        C++引用变量</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%A3%B0%E6%98%8E-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%A3%B0%E6%98%8E" rel="nofollow">                声明</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8" rel="nofollow">                常量引用</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8" rel="nofollow">                指针的引用</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0" rel="nofollow">                引用与函数</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:160px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">                引用与指针的区别</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BF%AE%E9%A5%B0%E7%AC%A6" rel="nofollow">        修饰符</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20static%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20static%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8" rel="nofollow">                static的用法和作用</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">                静态变量什么时候初始化</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%8C%87%E9%92%88%E4%B8%8Econst%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%8C%87%E9%92%88%E4%B8%8Econst%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">                指针与const的用法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</h3> 
<h4 id="%E5%8F%98%E9%87%8F%E6%89%80%E5%8D%A0%E5%A4%A7%E5%B0%8F">变量所占大小</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th style="width:120px;"></th><th style="width:165px;">X64</th><th style="width:214px;">X86</th></tr></thead><tbody><tr><th style="width:120px;">char</th><td style="width:165px;">1字节</td><td style="width:214px;">1字节</td></tr><tr><th style="width:120px;">short</th><td style="width:165px;">2字节</td><td style="width:214px;">2字节</td></tr><tr><th style="width:120px;">int</th><td style="width:165px;">4字节</td><td style="width:214px;">4字节</td></tr><tr><th style="width:120px;">long</th><td style="width:165px;">8字节</td><td style="width:214px;">4字节</td></tr><tr><th style="width:120px;">long long</th><td style="width:165px;">8字节</td><td style="width:214px;">8字节</td></tr><tr><th style="width:120px;">float</th><td style="width:165px;">4字节</td><td style="width:214px;">4字节</td></tr><tr><th style="width:120px;">double</th><td style="width:165px;">8字节</td><td style="width:214px;">8字节</td></tr><tr><th style="width:120px;">long double </th><td style="width:165px;">通常16字节</td><td style="width:214px;">通常8字节</td></tr></tbody></table> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20char">        char</h4> 
<p>        分为三类型：</p> 
<p>        1.char：标准类型</p> 
<p>        2.unsigned char：无符号char（0~255）</p> 
<p>        3.signed char：有符号char（-128~127）</p> 
<h3 id="%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B">构造类型</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%95%B0%E7%BB%84">        数组</h4> 
<h5 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">        1.一维数组</h5> 
<p>                <strong>字符串/字符数组</strong></p> 
<pre><code class="language-cpp">char arr1[] = "hello"; 字符串:结尾有'\0'终止符,arr1占6字节
char arr2[] = {'H', 'e', 'l', 'l', 'o'}; 字符数组：结尾无'\0'，arr2占5字节
'\0'影响printf等输出，输出结果为'\0'之前</code></pre> 
<p>                <strong>字符串的申明方式</strong></p> 
<p>                1.静态分配，编译时在栈上分配好内存</p> 
<p>                2.字符串常量</p> 
<p>                3.动态分配内存(malloc和new)</p> 
<p>                4.自动分配，在局部函数中</p> 
<p>                <strong>操作函数</strong></p> 
<pre><code class="language-cpp">size_t strlen(const char *str) 返回字符串长度，不包含'\0'
char *strcpy(char *dest, char *src) 把src复制给dest
char *strncpy(char *dest, const char *src, size_t n) 把src复制给dest前n个字符
char *strcat(char *dest, const char *src) 把src添加到dest的结尾
char *strncat(char *dest, const char *src, size_t n) 把src前n个字符添加到dest结尾
int strcmp(const char *str1, const char *str2) 比较字符串是否相同，成功返回0，失败返回不同个数
int strncmp(const char *str1, const char *str2, size_t n) 比较前n个字符串，返回与strcmp相同
char *strchr(const char *str, int c) 返回c第一次在str出现的地址
char *strrchr(const char *str, int c) 返回c最后一次在str出现的地址
char *strstr(const char *haystack, const char *needle) 返回needle在haystack第一次出现的地址
</code></pre> 
<p>                <strong>地址</strong></p> 
<pre><code class="language-cpp">char arr[10] = "Hello";
arr与&amp;arr[0]所表示是一样的
&amp;arr是整个数组的地址，类型是char (*)[10]，表示10个指向char元素的指针</code></pre> 
<p>                <strong>指针数组与数组指针</strong></p> 
<pre><code class="language-cpp">指针数组，包含3个char的指针
char *ptr_arry[3]
数组指针，指向一个包含3个char的数组
char (*arry_ptr)[3]</code></pre> 
<h5 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">        2.二维数组</h5> 
<p>                <strong>初始化</strong></p> 
<pre><code class="language-cpp">1.没什么好说的
int array[3][4];
2.编译器自动分配
int array[][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
3.分配动态内存
int rows = 3;
int cols = 4;
int **array = (int **)malloc(rows * sizeof(int *));
for (int i = 0; i &lt; rows; i++) {
    array[i] = (int *)malloc(cols * sizeof(int));
}
4.使用stl容器
int rows = 3;
int cols = 4;
std::vector&lt;std::vector&lt;int&gt;&gt; array(rows, std::vector&lt;int&gt;(cols));</code></pre> 
<p>                <strong>地址 </strong></p> 
<p><strong>                </strong>&amp;a[1]，&amp;a[0]==a；一维数组地址</p> 
<p>                &amp;a[0][1]，&amp;a[0][0] == a[0]；元素地址</p> 
<p>                &amp;a；二维数组地址</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E7%BB%93%E6%9E%84%E4%BD%93">        结构体</h4> 
<p>                <strong>声明</strong></p> 
<pre><code class="language-cpp">1.默认声明
struct Point {
    int x;
    int y;
};
C++的结构体class，为兼容c，保留了struct
2.定义并声明实例
struct Point {
    int x;
    int y;
} p1, p2;
3.结构体别名
typedef struct {
    int x;
    int y;
} Point;
Point p1; 
C++默认声明，创建实例时不需要声明结构体struct或class

</code></pre> 
<p>                <strong>结构体大小</strong></p> 
<pre><code class="language-cpp">struct Example {
    char a;    // 1 byte
    int b;     // 4 bytes
    char c;    // 1 byte
};</code></pre> 
<p>                以上面为例，变量存储地址为自身所占字节大小的倍数，设从0x00开始，char占1个字节，地址在0x00，b占4字节，因为地址要是自身字节大小的整数倍，所以地址在0x04；c占1个字节，地址在0x08，所以Example结构体的大小为9字节。</p> 
<p>                其中，c特有的位域，变量+：+位数，用于修改变量大小，节省内存空间。计算方式为同类型变量合并，不足该变量字节大小的部分自动填充，不同类型的变量按结构体的计算方式存入地址。</p> 
<p>                <strong>链表</strong></p> 
<p>                <strong>单链表</strong>：简单，节点只包含指向下一个节点的指针。</p> 
<p><strong>                双向链表</strong>：支持双向遍历，节点包含指向前一个和下一个节点的指针。</p> 
<p><strong>                循环链表</strong>：尾节点指向头节点，形成一个环，适合需要循环访问的情况。</p> 
<p>                <strong>C++中class与struct区别</strong></p> 
<p>                (1)相同点</p> 
<p>                都能拥有成员函数，公有和私有部分；class可以实现的struct也可以实现。</p> 
<p>                (2)不同点</p> 
<p>                struct默认公有，class默认私有；struct默认公有继承，class默认私有继承。 </p> 
<p>                (3)C++的struct与C的区别</p> 
<p>                C语言中struct是自定义数据类型；C++中是抽象数据类型，支持成员函数的定义(C++中可以继承和实现多态)</p> 
<p>                C语言中struct没有访问权限设置，成员只能是变量，但可以存入函数地址，数据不能被隐藏。</p> 
<p>                C++设置了访问权限，功能与class一样，默认是public访问。</p> 
<p>                C语言声明实例时必须在前面加struct，除非定义结构体时使用typedef。C++不需要，结构体struct在C++中被当作特例。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E8%81%94%E5%90%88%E4%BD%93">        联合体</h4> 
<p>                <strong>联合体声明</strong>     </p> 
<pre><code class="language-cpp">union Data {
    int i;
    float f;
    char str[20];
};</code></pre> 
<p>                <strong>联合体大小计算</strong></p> 
<p>                联合体的大小是其最大的数据成员大小的整数倍再满足编译器的内存对齐要求的最小倍数。以上面为例，联合体最大成员时char str[20]，则联合体大小为20字节，若内存对齐要求为4字节，则不变；若为8字节，则填充4字节为24字节。</p> 
<p><strong>                判断大小端</strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
union data{
    int a;
    char b;
}

void main()
{
    data udata;
    udata.a = 0x12345678;
    if(udata.b == 0x78)
        printf("Little-Endian\n");
    else if(udata.b == 0x12)
        printf("Big-Endian\n");
    else
        printf("Unkonwn Endian\n");
}</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%C2%A0">        指针 </h4> 
<h5 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE">         内存的申请与释放</h5> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E4%B8%AD%E7%9A%84new">                C++中的new</h6> 
<pre><code class="language-cpp">分配内存，构造一个整数
int* ptr = new int;
分配内存，构造函数参数进行构造
MyClass* ptr = new MyClass(arg1, arg2);
分配数组内存
MyClass* array = new MyClass[5];
或者memset设置内存初始值
使用std::nothrow，new失败时返回null</code></pre> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc">                malloc</h6> 
<pre><code class="language-cpp">type p = (type)malloc(分配大小)
分配失败时返回null</code></pre> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc%E4%B8%8Enew%E7%9A%84%E5%BC%82%E5%90%8C">                <strong>malloc与new的异同</strong></h6> 
<p><strong>                相同点</strong></p> 
<p>                都可以动态申请内存</p> 
<p>                <strong>不同点</strong></p> 
<p>                new是C++操作符，支持重载，还会调用构造函数；malloc是C/C++的标准函数。</p> 
<p>                new是类型安全的，malloc不安全。</p> 
<p>                new返回具体指针，malloc返回void型指针，需要类型转换。</p> 
<p>                new自动计算分配内存大小，malloc需要手动计算。</p> 
<p>                new是封装了malloc。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E4%B8%AD%E7%9A%84delete">                C++中的delete</h6> 
<p>                <strong>释放内存 </strong></p> 
<pre><code class="language-cpp">释放单个对象的内存
MyClass* obj = new MyClass(); // 用 new 分配对象
delete obj; // 释放分配的对象内存
释放数组的内存
MyClass* array = new MyClass[10]; // 用 new[] 分配对象数组
delete[] array; // 释放分配的数组内存
一个new对应一个delete
释放内存后需要将指针指向空
delete null是安全的</code></pre> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20free">                free</h6> 
<p>                <strong>释放内存</strong></p> 
<pre><code class="language-cpp">int *array = (int *)malloc(10 * sizeof(int));
free(array);
一个malloc对应一个free
内存释放后将指针指向null，避免产生野指针
free(NULL)会崩溃</code></pre> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">               new和delete是如何实现的</h6> 
<p>                <strong>new的实现过程</strong>：对简单的函数直接使用operator new函数；对复杂的数据结构调用operator new函数，分配足够大的原始为类型化的内存，运行该类型的构造函数并传入初始值，最后返回该对象的指针。</p> 
<p>                <strong>delete的实现过程</strong>：简单数据类型直接调用free；对复杂的数据结构对指针指向的对象运行析构函数，再用operator delete函数释放对象所使用内存。</p> 
<p>                new[]一个数组对象，需要知道数组的长度，会多分配4个字节，实际的数组所占内存为p-4；delete[]操作会取出这个数，知道要调用多少次析构函数。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20malloc%E5%92%8Cfree%E7%9A%84%E5%AE%9E%E7%8E%B0">                malloc和free的实现</h6> 
<p>                这两个函数是由brk、mmp和munmap这些系统调用实现的。</p> 
<p>                <strong>brk</strong>是将堆顶的指针向高位移动，获得新的内存空间。<strong>mmap</strong>是在进程的<strong>虚拟地址空间(堆和栈中间，称为文件映射区)</strong>中找到一块空闲的内存块。这两种都是分配虚拟内存，没有分配实际的物理内存。在第一次访问已分配的虚拟地址空间，发生<strong>缺页中断(当程序访问的虚拟内存页面不存在物理内存时，会触发缺页中断)</strong>，操作系统分配物理内存，建立虚拟内存与物理内存的映射关系。</p> 
<p>                malloc分配内存时，当分配内存小于128k，则使用brk在堆顶向高地址移动指针；当分配的内存大于128k时，使用mmap在虚拟地址空间寻找一块空闲内存。brk分配内存需要等高地址的内存释放后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K，则会执行内存紧缩。    </p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%86%E5%90%97">               被free回收的内存是立即还给操作系统了吗</h6> 
<p>                不是的，被free回收的内存会用双链表ptmalloc保存，当下次申请内存的时候就尝试再内存中寻找合适的返回，避免反复的系统调用，同时tpmalloc也会尝试合并小块内存，防止产生过多内存碎片。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20calloc%E4%B8%8Erealloc" style="background-color:transparent;">                calloc与realloc</h6> 
<p>                calloc省去了人为空间计算，calloc申请的空间的初始值是0；realloc给动态分配的空间分配额外的空间。</p> 
<p><strong>                深拷贝和浅拷贝</strong></p> 
<p><strong>                浅拷贝</strong></p> 
<pre><code class="language-cpp">class a{
    public:
        char *data;
        a(const char* str){
            data = new char[strlen(str)+1];
            strcpy(data, str);
        }
        a(const a &amp;other) : data(other.data) {} //浅拷贝构造函数
        a();
        ~a();
}

int main()
{
    a a1("hello world!");
    a a2 = a1;
    return 0;
}</code></pre> 
<p><strong>               </strong>a1直接赋值给a2，实际a2使用的内存与a1使用的是同一块，a1内存被回收后，a2会访问无效内存，发生未定义行为。</p> 
<p><strong>                深拷贝</strong></p> 
<pre><code class="language-cpp">class a{
    public:
        char *data;
        a(const char* str){
            data = new char[strlen(str)+1];
            strcpy(data, str);
        }
        a(const a &amp;other){
            data = new char[strlen(other.data)+1];
            strcpy(data, other.data);
        }//深拷贝构造函数
        a();
        ~a();
}

int main()
{
    a a1("hello world!");
    a a2 = a1;
    return 0;
}</code></pre> 
<p>                a2不仅复制了a1的值，还分配了独立内存 。</p> 
<h5 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">         指针类型</h5> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">                数组指针与指针数组</h6> 
<p>                数组指针：数组是指针；指针数组：成员是指针。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88">                二级指针</h6> 
<p>                一级指针指向某数据类型的内存地址，二级指针指向一级指针的内存地址。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">                函数指针</h6> 
<pre><code class="language-cpp">int (*funcPtr)(int, int);</code></pre> 
<p>                它用于指向函数的内存地址。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%E5%A4%A7%E5%B0%8F">                指针大小</h6> 
<p>                32位一般是4字节，64位一般是8字节。地址+1是加了一个类型的大小。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20*%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BD%9C%E7%94%A8">                *的三种作用</h6> 
<p>                <strong>(1)解引用运算符：</strong>*指针变量，表示地址操作符，取内容</p> 
<p>                <strong>(2)指针申明：</strong>表示指针变量</p> 
<p>               <strong> (3)运算：</strong>表示乘</p> 
<h5 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20C%2B%2B%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F">        C++引用变量</h5> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%A3%B0%E6%98%8E">                <strong>声明</strong></h6> 
<pre><code class="language-cpp">int b = 4;
int &amp;a = b;</code></pre> 
<p>                是对已存在变量的别名。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8">                常量引用</h6> 
<pre><code class="language-cpp">const int &amp;value
</code></pre> 
<p>                值不允许修改。</p> 
<p>                数组引用与指针一样。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8">                指针的引用</h6> 
<pre><code class="language-cpp">int *a = new int;
int *(&amp;b) = a;</code></pre> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0">                引用与函数</h6> 
<p>                不要引用局部变量。</p> 
<h6 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB" style="background-color:transparent;">                引用与指针的区别</h6> 
<p>                (1)引用声明的初始化，指针不用马上初始化</p> 
<p>                (2)引用不能指向空，指针可以</p> 
<p>                (3)引用初始化后不能指向其他变量，指针可以</p> 
<p>                (4)引用效率高</p> 
<p>                (5)引用更安全，指针可以偏移</p> 
<p>                (6)指针更灵活，直接操作地址；指针更通用，C/C++都可以。</p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E4%BF%AE%E9%A5%B0%E7%AC%A6">        修饰符</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20static%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8">                static的用法和作用</h4> 
<p>                1.隐藏</p> 
<p>                2.保持变量内容的持久，即改变变量的生命周期。将static修饰的变量存入静态数据区(全局区)。</p> 
<p>                3.默认初始化为0。</p> 
<p>               4.在C++中类成员声明static：</p> 
<p>                (1)函数体内static变量的作用范围为该函数体，内存只分配一次。</p> 
<p>                (2)在模块内的static全局变量只能被该模块的函数访问。</p> 
<p>                (3)模块内的static函数只能被该模块的函数调用。</p> 
<p>                (4)类中的static成员变量属于类所有，对类的所有对象只有一份拷贝，该变量的初始化要在类外。</p> 
<p>                (5)类中的static成员函数属于类所有，这个函数没有this指针，只能访问类中的静态成员变量。</p> 
<p>                类内：               </p> 
<p>                (6)static类对象要在类外初始化，因为static修饰的变量先类存在。</p> 
<p>                (7)static修饰的类成员属于类不属于对象，所以没有this指针，this指针是指向本成员的指针，所以无法访问非static的类成员。</p> 
<p>                (8)static成员函数不能被virtual修饰，static成员不属于任何对象和实例，virtual加上没有任何意义；静态成员没有this指针，虚函数的实现是对每个对象分配vptr指针，而vptr指针由this指针调用，所以不能为virtual。虚函数的调用关系：this-&gt;vptr-&gt;ctable-&gt;virtual function。</p> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96">                静态变量什么时候初始化</h4> 
<p>                1.初始化只有一次，在主程序前编译器已经分配好内存。</p> 
<p>                2.静态局部变量与全局变量一样存在全局区。在C中，初始化发生在执行代码前，编译阶段分配内存后，就会初始化，所以C语言中无法用变量初始化静态局部变量；程序结束，变量所处的全局内存会被回收。</p> 
<p>                3.在C++中，初始化在执行相关代码时，主要时C++引入对象后，要进行初始化必须要用构造函数或析构函数，构造和析构函数一般需要执行相关的程序，而非简单分配内存。所以C++规定在首次使用到全局或静态变量时进行构造，并通过atexit()管理。在程序结束时，根据构造的顺序反方向析构，所以C++中的静态局部变量可以用变量初始化。</p> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E6%8C%87%E9%92%88%E4%B8%8Econst%E7%9A%84%E7%94%A8%E6%B3%95" style="background-color:transparent;">                指针与const的用法</h4> 
<pre><code class="hljs">int val = 10;
指针常量
int* const a = &amp;val;
常量指针
const int *b = &amp;val;</code></pre> 
<p>                指针常量是指指针是常量，即指针指向的地址不可变，但指向地址的内容可变。</p> 
<p>                常量指针是指指针指向的内容不可变，地址可变。</p> 
<p><strong>剩下的明天写。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c4da87c662f7e3c1088bde1b6b24f1f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深入理解SpringCloud微服务】深入理解Ribbon原理并手写一个微服务负载均衡器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d46f3754059014b5e2d00dc80d4e2410/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows下Java环境配置教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>