<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶】C&#43;&#43;继承学习手册：全面解析继承的各个方面 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/03235c3038fe565bb74947e7e7fcf097/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;高阶】C&#43;&#43;继承学习手册：全面解析继承的各个方面">
  <meta property="og:description" content="📝个人主页🌹：Eternity._
⏩收录专栏⏪：C&#43;&#43; “ 登神长阶 ”
🤡往期回顾🤡：模板进阶
🌹🌹期待您的关注 🌹🌹
继承 📖1. 继承的概念及定义⛰️继承的概念🌄继承定义 📙2. 基类和派生类对象赋值转换📕3. 继承中的作用域🎩成员变量隐藏🎈成员函数隐藏 📚4. 派生类的默认成员函数🧩默认成员函数🧩派生类默认函数特征 📒5. 友元与静态成员变量🍂友元🍁静态成员 📜6. 多继承🌞菱形继承🌙虚拟继承⭐虚拟继承解决数据冗余和二义性的原理 🔥7. 总结 前言： 当我们踏上C&#43;&#43;编程的旅程时，继承无疑是一个无法回避且至关重要的概念。作为面向对象编程的三大特性之一，继承不仅让我们能够创建出层次清晰、结构合理的代码，还极大地提高了代码的可重用性和可维护性。在本文中，我们将一起深入探讨C&#43;&#43;继承的奥秘，从基础概念到高级应用，逐步揭开它的神秘面纱
C&#43;&#43;继承允许我们定义一个基类（或称为父类），并从这个基类中派生出新的类（称为派生类、子类）。派生类会继承基类的成员和成员函数，同时还可以添加自己的成员和成员函数。这种能力使得我们能够构建出复杂的类层次结构，实现代码的模块化和复用
在本文的学习中我们不仅仅要了解继承的基本概念。在实际编程中，我们还需要掌握如何正确使用继承、如何避免常见的继承陷阱、以及如何利用继承来优化我们的代码结构。因此，本文将带领大家从多个角度全面学习C&#43;&#43;继承，包括继承的语法规则、访问控制、构造函数与析构函数的调用、多重继承与菱形继承等问题
让我们一起踏上学习C&#43;&#43;继承的旅程吧！
📖1. 继承的概念及定义 ⛰️继承的概念 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用
继承代码示例
class A { public: void func() { cout &lt;&lt; &#34;A::func()&#34; &lt;&lt; endl; } protected: int _a = 10; }; // 继承后父类A的成员_a（成员函数&#43;成员变量）都会变成子类的一部分 class B : public A { public: // ...... protected: int _b = 100; }; int main() { A a ; B b; a.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T17:46:44+08:00">
    <meta property="article:modified_time" content="2024-06-13T17:46:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶】C&#43;&#43;继承学习手册：全面解析继承的各个方面</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>📝个人主页🌹：<a href="https://blog.csdn.net/EterNity_TiMe_?type=blog">Eternity._</a><br> ⏩收录专栏⏪：<a href="http://t.csdnimg.cn/rM7cw" rel="nofollow">C++ “ 登神长阶 ”</a><br> 🤡往期回顾🤡：<a href="http://t.csdnimg.cn/ZP4yd" rel="nofollow">模板进阶</a><br> 🌹🌹期待您的关注 🌹🌹</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/1b/f9/rE4K2lcN_o.gif" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ba/66/GkxuKPaH_o.gif" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a8/91/LAQHJXJy_o.gif" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>继承</h4> 
 <ul><li><a href="#1__22" rel="nofollow">📖1. 继承的概念及定义</a></li><li><ul><li><a href="#_23" rel="nofollow">⛰️继承的概念</a></li><li><a href="#_59" rel="nofollow">🌄继承定义</a></li></ul> 
  </li><li><a href="#2__86" rel="nofollow">📙2. 基类和派生类对象赋值转换</a></li><li><a href="#3___114" rel="nofollow">📕3. 继承中的作用域</a></li><li><ul><li><a href="#_121" rel="nofollow">🎩成员变量隐藏</a></li><li><a href="#_156" rel="nofollow">🎈成员函数隐藏</a></li></ul> 
  </li><li><a href="#4__194" rel="nofollow">📚4. 派生类的默认成员函数</a></li><li><ul><li><a href="#_195" rel="nofollow">🧩默认成员函数</a></li><li><a href="#_202" rel="nofollow">🧩派生类默认函数特征</a></li></ul> 
  </li><li><a href="#5__306" rel="nofollow">📒5. 友元与静态成员变量</a></li><li><ul><li><a href="#_307" rel="nofollow">🍂友元</a></li><li><a href="#_342" rel="nofollow">🍁静态成员</a></li></ul> 
  </li><li><a href="#6__376" rel="nofollow">📜6. 多继承</a></li><li><ul><li><a href="#_399" rel="nofollow">🌞菱形继承</a></li><li><a href="#_429" rel="nofollow">🌙虚拟继承</a></li><li><a href="#_456" rel="nofollow">⭐虚拟继承解决数据冗余和二义性的原理</a></li></ul> 
  </li><li><a href="#7__467" rel="nofollow">🔥7. 总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<p><strong>前言：</strong> 当我们踏上C++编程的旅程时，继承无疑是一个无法回避且至关重要的概念。作为面向对象编程的三大特性之一，<strong>继承不仅让我们能够创建出层次清晰、结构合理的代码，还极大地提高了代码的可重用性和可维护性</strong>。在本文中，我们将一起深入探讨C++继承的奥秘，从基础概念到高级应用，逐步揭开它的神秘面纱</p> 
<blockquote> 
 <p><strong>C++继承允许我们定义一个基类（或称为父类），并从这个基类中派生出新的类（称为派生类、子类）</strong>。派生类会继承基类的成员和成员函数，同时还可以添加自己的成员和成员函数。<strong>这种能力使得我们能够构建出复杂的类层次结构，实现代码的模块化和复用</strong></p> 
</blockquote> 
<p>在本文的学习中我们不仅仅要了解继承的基本概念。在实际编程中，我们还需要掌握如何正确使用继承、如何避免常见的继承陷阱、以及如何利用继承来优化我们的代码结构。因此，<strong>本文将带领大家从多个角度全面学习C++继承，包括继承的语法规则、访问控制、构造函数与析构函数的调用、多重继承与菱形继承等问题</strong></p> 
<p><strong>让我们一起踏上学习C++继承的旅程吧！</strong></p> 
<hr> 
<h2><a id="1__22"></a>📖1. 继承的概念及定义</h2> 
<h3><a id="_23"></a>⛰️继承的概念</h3> 
<p><strong>继承</strong>(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在<strong>保持原有类特性的基础上进行扩展，增加功能</strong>，这样产生新的类，称派生类。继承<strong>呈现了面向对象程序设计的层次结构</strong>，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，<strong>继承是类设计层次的复用</strong></p> 
<p><strong>继承代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 继承后父类A的成员_a（成员函数+成员变量）都会变成子类的一部分</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// ......</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A a <span class="token punctuation">;</span>
	B b<span class="token punctuation">;</span>
	a<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	b<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b可以调用A中的成员函数</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_59"></a>🌄继承定义</h3> 
<p><strong>我们从刚刚的代码示例可以看到A是基类(父类)，B是派生类(子类)</strong></p> 
<p><strong>定义格式</strong><br> <img src="https://images2.imgbox.com/1b/9d/kaa2vY7Z_o.png" alt="在这里插入图片描述"><br> <strong>注意：在定义继承的时候继承方式可以省略不写，如果不写则是根据基类的定义来决定默认继承方式，但是建议定义时带上继承方式</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span>定义的类默认<span class="token keyword">private</span>继承，<span class="token keyword">struct</span>定义的类默认<span class="token keyword">public</span>继承
</code></pre> 
<hr> 
<p><strong>继承关系和访问限定符</strong><br> <img src="https://images2.imgbox.com/70/7b/BVWFeIyS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c8/b0/a9NW4Kzw_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>继承基类成员访问方式的变化</strong><br> <strong>继承方式和访问限定符都有三种，虽然它们组合一共有9中能使用的方法，但是我们最常用的只有红色框里面的两种用法</strong><br> <img src="https://images2.imgbox.com/45/77/31o8mS2Q_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>这里我们有以下几点需要注意：</strong></p> 
 <ul><li>基类private成员在派生类中无论以什么方式继承都是不可见的。<strong>这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它</strong></li><li>基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。<strong>可以看出保护成员限定符是因继承才出现的</strong></li><li><strong>实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected&gt; private</strong></li><li>使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，<strong>不过最好显示的写出继承方式</strong></li><li><strong>在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承</strong>，也不提倡使protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强</li></ul> 
</blockquote> 
<hr> 
<h2><a id="2__86"></a>📙2. 基类和派生类对象赋值转换</h2> 
<p><strong>关于赋值规则这里我们先提两点：</strong></p> 
<blockquote> 
 <ul><li><strong>派生类对象</strong> 可以赋值给 <strong>基类的对象 / 基类的指针 / 基类的引用</strong>。这里有个形象的说法叫切片或者切割。寓意把派生类中父类那部分切来赋值过去</li><li><strong>基类对象不能赋值给派生类对象</strong></li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d0/d6/zJP81puX_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>我们在讲C++入门知识的时候讲过，引用类型不同的变量时，会产生一个临时变量，临时变量具有常性，需要const修饰，但是在继承中就不需要const修饰</strong></p> 
<p><strong>代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> r <span class="token operator">=</span> d<span class="token punctuation">;</span> <span class="token comment">// 中间产生了一个临时变量，临时变量具有常性，需要const修饰</span>
	
	B b<span class="token punctuation">;</span>
	A a <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 子类可以赋值给基类</span>
	<span class="token comment">// b = a; // false, 基类不可以赋值给子类</span>
	
	A<span class="token operator">&amp;</span> ra <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// is-a 的关系中间不会产生临时对象，父子类的赋值兼容规则（切割/切片）</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>继承中的对象是<code>is-a</code> 的关系，它们中间并不会产生临时对象，这就是父子类的赋值兼容规则（切割/切片）</strong></p> 
<hr> 
<h2><a id="3___114"></a>📕3. 继承中的作用域</h2> 
<p><strong>关于作用域的注意事项：</strong></p> 
<blockquote> 
 <ul><li>在继承体系中基类和派生类都有独立的作用域。</li><li>子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。<strong>（在子类成员函数中，可以使用 基类::基类成员 显示访问）</strong></li><li>需要注意的是如果是成员函数的隐藏，<strong>只需要函数名相同就构成隐藏</strong></li><li>注意在实际中在继承体系里面最好<strong>不要定义同名的成员</strong></li></ul> 
</blockquote> 
<hr> 
<h3><a id="_121"></a>🎩成员变量隐藏</h3> 
<blockquote> 
 <p><strong>当继承的基类与子类有同名的成员变量时，不指定的话，会调用子类的成员变量</strong></p> 
</blockquote> 
<p><strong>代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"_a："</span> <span class="token operator">&lt;&lt;</span> _a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token comment">// cout &lt;&lt; "A: _a：" &lt;&lt; A::_a &lt;&lt; endl; // 要想成功打印A类的元素必须要指定</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"_b："</span> <span class="token operator">&lt;&lt;</span> _b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B b<span class="token punctuation">;</span>
	<span class="token comment">// 成员变量同名</span>
	<span class="token comment">// A 和 B中的 _a 构成隐藏</span>
	b<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// // _a = 99 , _b = 100; 就近原则</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="_156"></a>🎈成员函数隐藏</h3> 
<blockquote> 
 <p><strong>在继承中，同名函数并不会构成函数重载，因为他们在不同的作用域，每个类都是独立的，成员函数满足函数名相同就构成隐藏</strong></p> 
</blockquote> 
<p><strong>代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// </span>
	<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B b<span class="token punctuation">;</span>
	<span class="token comment">// 成员函数同名</span>
	<span class="token comment">// A 和 B中的 func() 构成隐藏</span>
	b<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印“func(int b)”</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="4__194"></a>📚4. 派生类的默认成员函数</h2> 
<h3><a id="_195"></a>🧩默认成员函数</h3> 
<p><strong>默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个</strong><br> <img src="https://images2.imgbox.com/ab/b4/i7NhUxky_o.png" alt="在这里插入图片描述"></p> 
<p><strong>相关文章：</strong><a href="http://t.csdnimg.cn/sxfYU" rel="nofollow">默认成员函数</a></p> 
<hr> 
<h3><a id="_202"></a>🧩派生类默认函数特征</h3> 
<blockquote> 
 <ul><li>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用</li><li>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化</li><li>派生类的operator=必须要调用基类的operator=完成基类的复制</li><li>派生类的析构函数会在被调用完成后<strong>自动调用基类的析构函数清理基类成员</strong>。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序</li><li>派生类对象初始化先调用基类构造再调派生类构造</li><li><strong>派生类对象析构清理先调用派生类析构再调基类的析构</strong></li><li>因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同(这个我们后面会讲解)。那么编译器会对析构函数名进行特殊处理，处理成destrutor()，所以父类析构函数不加virtual的情况下，<strong>子类析构函数和父类析构函数构成隐藏关系</strong></li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/06/e4/KPQgfAO1_o.png" alt="在这里插入图片描述"><br> <strong>综上所述：关于基类和子类的调用顺序，一般情况都是先父后子，但是析构必须先子后父，来避免析构完父类之后，子类出错</strong></p> 
<p><strong>继承默认函数的实现代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>_a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(const A&amp; a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A&amp; operator=(const A&amp; a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>a <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_a <span class="token operator">=</span> a<span class="token punctuation">.</span>_a<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
		<span class="token comment">// :_a(a) // _a不是基类成员不能这样初始化</span>
		<span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
		<span class="token comment">// :_a(a) // _a不是基类成员不能这样初始化</span>
		<span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_b</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>_b<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B(const A&amp; a, const B&amp; b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B&amp; operator=(const B&amp; b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>b <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 需要调用A类的 operator=</span>
			A<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
			_b <span class="token operator">=</span> b<span class="token punctuation">.</span>_b<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 析构函数会先析构父类，而有时候先析构父类，子类会出事</span>
	<span class="token comment">// 不需要显式调用父类析构</span>
	<span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~B()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B <span class="token function">b1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	B <span class="token function">b2</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>

	B <span class="token function">b3</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	b1 <span class="token operator">=</span> b3<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="5__306"></a>📒5. 友元与静态成员变量</h2> 
<h3><a id="_307"></a>🍂友元</h3> 
<blockquote> 
 <p><strong>友元关系不能继承，也就是说基类友元不能访问子类私有和保护成员，因为朋友的朋友不一定也是自己的朋友，如果基类，子类都想使用必须都在各自的域里面声明</strong></p> 
</blockquote> 
<p><strong>代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// </span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> B<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span>_b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A a<span class="token punctuation">;</span>
	B b<span class="token punctuation">;</span>
	<span class="token function">Print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_342"></a>🍁静态成员</h3> 
<blockquote> 
 <p><strong>基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。无论派生出多少个子类，都只有一个static成员实例</strong></p> 
</blockquote> 
<p><strong>代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>_count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> _count<span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span>_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// </span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A a<span class="token punctuation">;</span>
	B b<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> A<span class="token double-colon punctuation">::</span>_count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="6__376"></a>📜6. 多继承</h2> 
<p>单继承：一个子类只有一个直接父类时称这个继承关系为单继承</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">public</span> A
</code></pre> 
<p>多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B <span class="token punctuation">,</span> <span class="token keyword">public</span> C
</code></pre> 
<p>菱形继承：菱形继承是多继承的一种特殊情况。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B <span class="token punctuation">,</span> <span class="token keyword">public</span> C
</code></pre> 
<hr> 
<h3><a id="_399"></a>🌞菱形继承</h3> 
<p><img src="https://images2.imgbox.com/3a/28/WRyQrDOA_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。在D的对象中_a成员会有两份，我们在访问的时候无法明确知道访问的是哪一个，必须要显示指定访问哪个父类的成员，但是数据冗余任然无法解决！</strong><br> <img src="https://images2.imgbox.com/fe/60/J7XeqQDG_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_429"></a>🌙虚拟继承</h3> 
<p>虚拟继承可以解决菱形继承的二义性和数据冗余的问题。如上面的继承关系，在A和B的继承A时使用虚拟继承，即可解决问题。<strong>需要注意的是，虚拟继承不要在其他地方去使用</strong></p> 
<p><strong>代码示例</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_456"></a>⭐虚拟继承解决数据冗余和二义性的原理</h3> 
<blockquote> 
 <ul><li>虚拟继承通过将共同的祖先类（即虚基类）的拷贝在派生类对象中只保留一份，来解决这个问题。具体来说，虚拟继承会在内存中创建一个虚基表，并在派生类对象中存储一个指向这个虚基表的指针（即虚基表指针）。<strong>虚基表中存的偏移量。通过偏移量可以找到下面的A</strong>，而无需在派生类对象中多次存储这些数据成员。因此，虚拟继承通过减少重复存储的数据成员来消除数据冗余</li></ul> 
</blockquote> 
<blockquote> 
 <ul><li>虚拟继承通过改变派生类访问虚基类成员的方式来解决这个问题。在虚拟继承中，派生类对象通过虚基表指针来访问虚基类（即共同祖先类）的成员。由于虚基表中存储了虚基类成员的地址，因此派生类对象可以明确地知道应该访问哪个虚基类成员，从而消除了二义性。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d4/f2/oAvYgfnB_o.png" alt="在这里插入图片描述"></p> 
<p><strong>加上表中偏移量可以找到最底下的A</strong></p> 
<hr> 
<h2><a id="7__467"></a>🔥7. 总结</h2> 
<p><strong>回顾学习过程，我们学会了如何定义基类与派生类，掌握了访问控制规则，理解了构造函数与析构函数在继承中的作用，还探讨了多重继承及其带来的挑战。这些知识不仅丰富了我们的编程技能，更为我们解决实际问题提供了有力的工具</strong></p> 
<blockquote> 
 <p>在结束对C++继承的学习之旅后，我们不禁感叹其强大的功能和灵活性。通过深入探究继承的基本概念、语法规则以及高级应用，我们逐渐揭开了其背后的奥秘，并体验到了它在面向对象编程中的独特价值</p> 
</blockquote> 
<p>学习C++继承并非一蹴而就的过程。它需要我们不断地实践、思考、总结和创新。在未来的编程之路上，我们将继续深化对继承的理解，探索其更多的应用场景和高级特性，如虚继承、接口继承等，我们也要认识到继承并非万能的。在使用继承时，我们需要权衡其带来的好处和潜在的风险，避免过度使用导致代码结构复杂、难以维护。我们应该根据具体的需求和场景，选择最合适的编程范式和工具！！！<br> <img src="https://images2.imgbox.com/0c/f9/QPdw261H_o.gif" alt="在这里插入图片描述"></p> 
<p><strong>希望本文能够为你提供有益的参考和启示，让我们一起在编程的道路上不断前行！<br> 谢谢大家支持本篇到这里就结束了，祝大家天天开心！</strong><br> <img src="https://images2.imgbox.com/35/ec/tI1i5voE_o.gif" alt="在这里插入图片描述"><br> 我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=1m2qp8pe3h4nz</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1f5448e7f7c570b688a46559ece091ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">夏季河湖防溺水新举措：青犀AI视频智能监控系统保障水域安全</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4f592d6744ff02d51879b184986109d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">力扣每日一题 6/13 反悔贪心算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>