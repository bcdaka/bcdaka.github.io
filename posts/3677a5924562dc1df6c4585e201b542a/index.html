<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之探索“队列”的奥秘 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3677a5924562dc1df6c4585e201b542a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之探索“队列”的奥秘">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
队列有关概念
队列的使用 队列模拟实现 循环队列的模拟实现
622. 设计循环队列 双端队列
栈与队列相互转换
232. 用栈实现队列
225. 用队列实现栈 队列有关概念 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 的特点。
入队列：进行插入操作的一端称为队尾（Tail/Rear） ；
出队列：进行删除操作的一端称为队头 （Head/Front）。
队列和我们在日常生活中买东西排队或者在食堂打饭的场景是一样的。如下图：
队列的使用 上面这张图中，Queue 便是队列，可以看到其底层是 LinkedList ，也就是双向链表实现的。
队列的常用方法 方法功能boolean offer(E e)往队尾添加元素E poll()获取并删除队头元素peek()获取队头元素int size()获取队列中有效元素个数boolean isEmpty()检测队列是否为空 public class Test { public static void main(String[] args) { Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 判断队列是否为空 System.out.println(queue.isEmpty()); // 往队尾插入元素 queue.offer(1); queue.offer(2); queue.offer(3); queue.offer(4); queue.offer(5); // 获得并删除对头元素 System.out.println(queue.poll()); // 获取对头元素 System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-19T20:00:00+08:00">
    <meta property="article:modified_time" content="2024-06-19T20:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之探索“队列”的奥秘</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%98%9F%E5%88%97%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E9%98%9F%E5%88%97%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">队列有关概念</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">队列的使用 </a></p> 
<p id="%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0%C2%A0" rel="nofollow">队列模拟实现  </a></p> 
<p id="%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">循环队列的模拟实现</a></p> 
<p id="%C2%A0%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0" rel="nofollow"> 622. 设计循环队列 </a></p> 
<p id="%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97" rel="nofollow">双端队列</a></p> 
<p id="%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2" rel="nofollow">栈与队列相互转换</a></p> 
<p id="232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97" rel="nofollow">232. 用栈实现队列</a></p> 
<p id="225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%C2%A0-toc" style="margin-left:40px;"><a href="#225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%C2%A0" rel="nofollow">225. 用队列实现栈 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E9%98%9F%E5%88%97%E6%9C%89%E5%85%B3%E6%A6%82%E5%BF%B5" style="background-color:transparent;"><span style="color:#fe2c24;">队列有关概念</span></h2> 
<p>队列：只允许<strong>在一端</strong>进行<strong>插入数据</strong>操作，在<strong>另一端</strong>进行<strong>删除数据</strong>操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 的特点。</p> 
<p>入队列：进行插入操作的一端称为队尾（Tail/Rear） ；</p> 
<p>出队列：进行删除操作的一端称为队头 （Head/Front）。</p> 
<p>队列和我们在日常生活中买东西排队或者在食堂打饭的场景是一样的。如下图：</p> 
<p><img alt="" height="803" src="https://images2.imgbox.com/11/c8/2tNADSXg_o.png" width="1200"></p> 
<h2 id="%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" style="background-color:transparent;"><span style="color:#fe2c24;">队列的使用 </span></h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ba/09/d5Dls2DV_o.jpg"></p> 
<p>上面这张图中，Queue 便是队列，可以看到其底层是 LinkedList ，也就是双向链表实现的。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   队列的常用方法 
 </caption><tbody><tr><td>方法</td><td>功能</td></tr><tr><td>boolean offer(E e)</td><td>往队尾添加元素</td></tr><tr><td>E poll()</td><td>获取并删除队头元素</td></tr><tr><td>peek()</td><td>获取队头元素</td></tr><tr><td>int size()</td><td>获取队列中有效元素个数</td></tr><tr><td>boolean isEmpty()</td><td>检测队列是否为空</td></tr></tbody></table> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        // 判断队列是否为空
        System.out.println(queue.isEmpty());
        // 往队尾插入元素
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);
        queue.offer(4);
        queue.offer(5);
        // 获得并删除对头元素
        System.out.println(queue.poll());
        // 获取对头元素
        System.out.println(queue.peek());
        // 判断队列是否为空
        System.out.println(queue.isEmpty());
        int x = queue.size();
        System.out.println(x);
        // 循环遍历队列中的元素并删除
        for (int i = 0; i &lt; x; i++) {
            System.out.print(queue.poll()+" ");
        }
        System.out.println();
        // 注意这个poll()方法并不会因为队列为空而抛出空指针异常
        System.out.println(queue.poll());
    }
}
</code></pre> 
<p>因为上面代码中队列是用 LinkedList 实现的，那么我们就应该去其源码下，查看 poll() 方法</p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/3d/da/1yRVjW9t_o.png" width="1200"></p> 
<h2 id="%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0%C2%A0" style="background-color:transparent;"><span style="color:#fe2c24;">队列模拟实现</span>  </h2> 
<pre><code class="language-java">// 用链表模拟实现队列
public class MyQueue {
    static class ListNode {
        int val;
        ListNode prev;
        ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }

    public ListNode head;
    public ListNode last;
    public int size; // 减少时间复杂度去遍历链表

    // 往队尾添加元素
    public boolean offer(int val) {
        // 创建一个新的节点
        ListNode newNode = new ListNode(val);
        // 队列为空
        if (head == null) {
            head = newNode;
            last = newNode;
        } else {
            // 就是在链表中尾插元素
            last.next = newNode;
            newNode.prev = last;
            last = last.next;
        }
        size++;
        return true;
    }

    // 删除并获取对头元素
    public Integer poll() {
        // 链表为空就返回null
        if (head == null) {
            return null;
        } else {
            int x = head.val;
            size--;
            // 链表中只有一个元素就直接删除
            if (head.next == null) {
                head = null;
                last = null;
                return x;
            } else {
                // 链表中有多个节点
                head = head.next;
                return x;
            }
        }
    }

    // 获取对头元素
    public Integer peek() {
        // 模范源码的写法
        return head == null ? null : head.val;
    }

    // 获取节点个数
    public int size() {
        return size;
    }

    // 检测链表是否为空
    public boolean isEmpty() {
        return head == null;
    }
}
</code></pre> 
<p>上面是用链表模拟实现，队列用链表实现时，就可以把队列看成是一个链表，我们就可以用实现链表的方式来实现队列。又因为链表是用节点组成，因此，我们就要创建节点，来操作链表。</p> 
<p>接下来，我们就可以尝试用数组来实现队列。</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/ab/34/1WWbUlfC_o.png" width="1200"></p> 
<p>上面这个数组看起来虽然可以实现队列，但是我们如果去写队列的方法时，根本无法实现。因为删除对头元素时，last到底要不要 -1 呢？如果 -1，那么last 就会指向5位置的下标，不符合要求；如果不 -1，那么对头元素该怎么办呢？有小伙伴可能会说，直接把元素从后往前覆盖，然后再把 last -1，不就完事了吗？ 但又有一个问题：移动数组元素所付出的时间是非常大的，因为队列中出队的元素永远是数组的首元素，在移动数组时，全部的元素都得移动，这就会浪费很多的时间。因此上面这种方法是不可行的，就得用一种全新的数组来解决：循环数组。用循环数组实现的队列也叫作循环队列。</p> 
<h2 id="%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#fe2c24;">循环队列的模拟实现</span></h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/24/b6/GxlOpGYv_o.png" width="1200"></p> 
<p>循环队列有几个要解决的难题：</p> 
<p>1、怎么判断这个队列是空还是有元素？</p> 
<p>可能有小伙伴会说：看head 与 last 两者的下标是否相等，如果相等，就说明队列为空；如果不相等就说明队列不为空。但是很巧不巧：当队列满了的时候，这个head 与 last 指向的位置还是一样的啊。有三种解决方案：1、使用usedSize 来记录元素的个数。当head 与 last 相遇时，看看usedSize 是否为0，不为0，就说明的确是满了；否则，就没满。2、浪费一个空间来阻止其相遇。既然当两者相遇时，不知道到底是空还是满，那我们就阻止其相遇即可，当last 的下一个位置是head时，就说明队列已经满了，则不往这个位置存放元素。3、使用标记的方式。就是通过维护一个额外的变量，来判断这个队列是否满了。例如：定义一个isEmpty的变量，初始化为true，只要执行了入队操作，就把其变为false，如果在之后的入队操作中，遇到head == last ，并且isEmpty 为false，那么就说明满了。其实这个就是排除了刚开始 head == last的情况。</p> 
<p>2、当这个last 或者是 head 为7 时，怎么把其变为 0呢？也就是说怎么把这个下标给正常化？</p> 
<p>大佬们给出的方法是 last = (last+1) % Queue.size();   </p> 
<p>极端情况：0 = (7+1) % 8           正常情况：1 = (0+1) % 8 、  6 = (5+1) % 8</p> 
<p>两种难题都已经解决了，就可以开始着手写循环队列了。</p> 
<h3 id="%C2%A0%C2%A0" style="background-color:transparent;"> <a class="link-info" href="https://leetcode.cn/problems/design-circular-queue/description/" rel="nofollow" title="622. 设计循环队列">622. 设计循环队列</a> </h3> 
<blockquote> 
 <p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p> 
 <p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p> 
 <p>你的实现应该支持如下操作：</p> 
 <ul><li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code>isEmpty()</code>: 检查循环队列是否为空。</li><li><code>isFull()</code>: 检查循环队列是否已满。</li></ul> 
 <p><strong>示例：</strong></p> 
 <pre>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>所有的值都在 0 至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul> 
</blockquote> 
<p>思路：其实把上面的难题解决之后，循环队列也就容易实现了。</p> 
<pre><code class="language-java">class MyCircularQueue {
    // 用数组来实现循环队列
    public int[] elem; // 循环数组
    public int usedSize; // 记录数组的有效元素的个数
    public int head; // 记录对头的位置
    public int last; // 记录队尾的位置
    public int lastValue; // 获取队尾的值

    public MyCircularQueue(int k) {
        this.elem = new int[k];
    }
    
    public boolean enQueue(int value) {
        // 如果满了，就插入失败
        if (isFull()) {
            return false;
        }
        // 往数组中插入元素
        elem[last] = value;
        lastValue  = elem[last];
        last = (last+1) % elem.length;
        // 注意：不能简单的++了
        usedSize++;
        return true;
    }
    
    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        // 删除对头元素
        // head 往后走就行，其余不用管
        head = (head+1) % elem.length;
        usedSize--;
        return true;
    }
    
    public int Front() {
        if (isEmpty()) {
            return -1;
        } else {
            return elem[head];
        }
    }
    
    public int Rear() {
        if (isEmpty()) {
            return -1;
        } else {
            return lastValue;
        }
    }
    
    public boolean isEmpty() {
        return usedSize == 0;
    }
    
    public boolean isFull() {
        return usedSize == elem.length;
    }
}</code></pre> 
<p>注意：因为这里 last 的位置会在插入元素之后发生改变， 因此，我们得把改变前的位置存起来或者把改变前的队尾值存起来，以便后面的 Rear() 方法。</p> 
<p>这里我用的是usedSize 记录位置看是否满，也可以用其他的方法。下面是用浪费一个空间的方法：（为了更好的观察，就只给出了改动代码）</p> 
<pre><code class="language-java">class MyCircularQueue {

    public MyCircularQueue(int k) {
        // 既然浪费了一个空间，那么我们就偷偷地多申请一个空间
        this.elem = new int[k+1];
    }
    
    
    public boolean isEmpty() {
        // 两者只有在队列为空时，才能相遇
        return head == last;
    }
    
    public boolean isFull() {
        // 如果 last+1 == head，说明此时队列已经满了
        return (last+1) % elem.length == head;
    }
}</code></pre> 
<h2 id="%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97" style="background-color:transparent;"><span style="color:#fe2c24;">双端队列</span></h2> 
<p>前面我们学习的队列都是队尾进，对头出。现在我们来学习一种全新的队列：双端队列。</p> 
<p>双端队列（deque）是指允许两端都可以进行入队和出队操作的队列，deque 是 “double ended queue” 的简称。 那就说明元素可以从队头出队和入队，也可以从队尾出队和入队。 </p> 
<p><img alt="" src="https://images2.imgbox.com/7e/e4/CnS91BKI_o.jpg"></p> 
<p>从上图也可以看出Deque 拓展了 Queue 的功能，并且 ArrayList 与 LinkedList 都是实现了该接口的，也就说明既有 线性的双端队列，也有链式的双端队列。</p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/71/40/46fYQCeh_o.png" width="1200"></p> 
<p>其他的方法与我们在上面的方法差不多，都是这样的，这里就不过多的赘述了。</p> 
<p><img alt="" height="727" src="https://images2.imgbox.com/cf/7f/MtqpODNK_o.png" width="1200"></p> 
<p>上面是ArrayDeque 的offer() 方法。</p> 
<p>注意：Java 8 和 Java 17 在针对ArrayDeque的无参构造方法上设计的有些不一样。</p> 
<p><img alt="" height="918" src="https://images2.imgbox.com/d5/fc/LsGGXZI3_o.png" width="1200"></p> 
<p>上面这个就是在浪费一个空间作为判断循环队列是否已满的情况。和我们前面的处理是一样。 </p> 
<p>由于双端队列可以在一端进，一端出，这也就表明其可以作为栈来使用了。</p> 
<h2 id="%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2" style="background-color:transparent;"><span style="color:#fe2c24;">栈与队列相互转换</span></h2> 
<h3 id="232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97" style="background-color:transparent;"><a class="link-info" href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" rel="nofollow" title="232. 用栈实现队列">232. 用栈实现队列</a></h3> 
<blockquote> 
 <p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p> 
 <p>实现 <code>MyQueue</code> 类：</p> 
 <ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul> 
 <p><strong>说明：</strong></p> 
 <ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
<strong>输出：</strong>
[null, null, null, 1, 1, false]

<strong>解释：</strong>
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul> 
</blockquote> 
<p><img alt="" height="884" src="https://images2.imgbox.com/c5/ea/FYKAB5kV_o.png" width="1200"></p> 
<p>思路：先取一个栈让其作为第一次存放元素的栈， 如果进行peek 或者 pop 操作，就把有元素的栈中所有元素出栈到另一个空栈中即可，empty 就是看两个栈是否都为空。</p> 
<pre><code class="language-java">class MyQueue {
    public Stack&lt;Integer&gt; stack1;
    public Stack&lt;Integer&gt; stack2;

    public MyQueue() {
        stack1 = new Stack&lt;&gt;();
        stack2 = new Stack&lt;&gt;();
    }
    
    public void push(int x) {
        // 如果两个栈都为空，随便选取一个作为存放元素的栈
        if (empty()) {
            stack1.push(x);
        } else if (!stack1.empty()) {
            // 如果栈1不为空，存放到栈1中，反之则存放到栈2中
            stack1.push(x);
        } else {
            stack2.push(x);
        }
    }
    
    public int pop() {
        // 把有元素的栈中所有元素存放到另一个栈中
        if (!stack1.empty()) {
            int size = stack1.size();
            for (int i = 0; i &lt; size; i++) {
                stack2.push(stack1.pop());
            }
            // 再颠倒过来
            int x = stack2.pop();
            size = stack2.size();
            for (int i = 0; i &lt; size; i++) {
                stack1.push(stack2.pop());
            }
            return x;
        } else {
            int size = stack2.size();
            for (int i = 0; i &lt; size; i++) {
                stack1.push(stack2.pop());
            }
            // 再颠倒过来
            int x = stack2.pop();
            size = stack2.size();
            for (int i = 0; i &lt; size; i++) {
                stack1.push(stack2.pop());
            }
            return x;
        }
    }
    
    public int peek() {
        // 把有元素的栈中所有元素存放到另一个栈中
        if (!stack1.empty()) {
            int size = stack1.size();
            for (int i = 0; i &lt; size; i++) {
                stack2.push(stack1.pop());
            }
            // 再颠倒过来
            // 这个peek()方法的顺序没有关系
            int x = stack2.peek();
            size = stack2.size();
            for (int i = 0; i &lt; size; i++) {
                stack1.push(stack2.pop());
            }
            return x;
        } else {
            int size = stack2.size();
            for (int i = 0; i &lt; size; i++) {
                stack1.push(stack2.pop());
            }
            // 再颠倒过来
            int x = stack2.peek();
            size = stack2.size();
            for (int i = 0; i &lt; size; i++) {
                stack1.push(stack2.pop());
            }
            return x;
        }
    }
    
    public boolean empty() {
        // 当两个栈同时为空时，才为空
        return stack1.empty() &amp;&amp; stack2.empty();
    }
}</code></pre> 
<p> 上面这个代码有些过于繁琐了，可以简化为下面这样：</p> 
<pre><code class="language-java">class MyQueue {
    public Stack&lt;Integer&gt; stack1;
    public Stack&lt;Integer&gt; stack2;

    public MyQueue() {
        stack1 = new Stack&lt;&gt;();
        stack2 = new Stack&lt;&gt;();
    }
    
    public void push(int x) {
        // 指定在一个中存放
        stack1.push(x);
    }
    
    public int pop() {
        while (stack2.empty()) {
            while (!stack1.empty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
    
    public int peek() {
        while (stack2.empty()) {
            while (!stack1.empty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }
    
    public boolean empty() {
        // 当两个栈同时为空时，才为空
        return stack1.empty() &amp;&amp; stack2.empty();
    }
}
</code></pre> 
<p>这个代码就是把一个栈专门用来存放元素，另一个栈专门用来出元素。</p> 
<p><img alt="" height="1073" src="https://images2.imgbox.com/08/5c/7LLSkWqM_o.png" width="1200"></p> 
<h3 id="225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%C2%A0" style="background-color:transparent;"><a class="link-info" href="https://leetcode.cn/problems/implement-stack-using-queues/description/" rel="nofollow" title="225. 用队列实现栈">225. 用队列实现栈</a> </h3> 
<blockquote> 
 <p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p> 
 <p>实现 <code>MyStack</code> 类：</p> 
 <ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul> 
 <p></p> 
 <p><strong>注意：</strong></p> 
 <ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul> 
 <p><strong>示例：</strong></p> 
 <pre><strong>输入：</strong>
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
<strong>输出：</strong>
[null, null, null, 2, 2, false]

<strong>解释：</strong>
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul> 
</blockquote> 
<p><img alt="" height="869" src="https://images2.imgbox.com/71/52/DufClKPl_o.png" width="1200"></p> 
<p>思路：一个队列存放元素，在pop时，把有元素的队列的前n-1个元素给到新队列，再根据需要处理最后一个元素即可。 </p> 
<pre><code class="language-java">class MyStack {
    public Queue&lt;Integer&gt; queue1;
    public Queue&lt;Integer&gt; queue2;

    public MyStack() {
        queue1 = new LinkedList&lt;&gt;();
        queue2 = new LinkedList&lt;&gt;();
    }
    
    public void push(int x) {
        // 如果两个都为空，则任选一个
        if (!empty()) {
            queue1.offer(x);
        } else if (!queue1.isEmpty()) {
            queue1.offer(x);
        } else {
            queue2.offer(x);
        }
    }
    
    public int pop() {
        // 把不为空的队列的前n-1个元素出队
        if (!queue1.isEmpty()) {
            int size = queue1.size();
            for (int i = 0; i &lt; size-1; i++) {
                queue2.offer(queue1.poll());
            }
            // 将原队列的队尾元素出队
            return queue1.poll();
        } else {
            int size = queue2.size();
            for (int i = 0; i &lt; size-1; i++) {
                queue1.offer(queue2.poll());
            }
            return queue2.poll();
        }
    }
    
    public int top() {
        // 把不为空的队列的前n-1个元素出队
        if (!queue1.isEmpty()) {
            int size = queue1.size();
            for (int i = 0; i &lt; size-1; i++) {
                queue2.offer(queue1.poll());
            }
            // 得到原队列的队尾元素，并插入新队列
            int x = queue1.peek();
            queue2.offer(queue1.poll());
            return x;
        } else {
            int size = queue2.size();
            for (int i = 0; i &lt; size-1; i++) {
                queue1.offer(queue2.poll());
            }
            int x = queue2.peek();
            queue1.offer(queue2.poll());
            return x;
        }
    }
    
    public boolean empty() {
        // 两个都为空，则返回空
        return queue1.isEmpty() &amp;&amp; queue2.isEmpty();
    }
}</code></pre> 
<p>当然本题可以使用双端队列，只不过题目要求要用两个队列，而且双端队列来实现栈比用两个队列更为简单，因为只需要维护一个队列即可。 </p> 
<p>双端队列 思路：创建一个双端队列，正常入队元素，但出队是从队尾出。</p> 
<p>综上：栈与队列之间的相互转换还是不难的，只要掌握了栈与队列的特点，再根据各自的特点去实现即可。 </p> 
<p>好啦！本期 数据结构之探索“队列”的奥秘 的学习之旅就到此结束了，我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/954c14c4cb0e3f33754029d12d256134/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【golang学习之旅】使用VScode安装配置Go开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0285fdb9539de6ed8f1079e08ade44a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">力扣每日一题 6/19 排序&#43;动态规划</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>