<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux详解】进程等待 | 非阻塞轮询 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5d0cc1830dbc6ba5774fd030c4db1368/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Linux详解】进程等待 | 非阻塞轮询">
  <meta property="og:description" content="引入：
为什么？是什么？怎么办
是什么？ 进程等待是指父进程暂停自己的执行，直到某个特定的子进程结束或发生某些特定的事件。
为什么？ 僵尸进程刀枪不入，不可被杀死，存在内存泄露获取进程的执行情况，知道我布置给子进程的任务，它完成的怎么样了–可选 怎么办 wait 函数
#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; pid_t wait(int* status); 测试：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; int main ( void ) { pid_t id = fork(); if (id == 0) { // child while (1) { printf(&#34;我是子进程，我正在运行... Pid: %d\n&#34;, getpid()); sleep(1); } } else { printf(&#34;我是父进程: pid: %d，我将耐心地等待子进程！\n&#34;, getpid()); sleep(20); // 为了便于观察，我们让父进程休眠20s // 苏醒后，父进程执行 wait，耐心地等待子进程 pid_t ret = wait(NULL); // 暂且将status参数设置为NULL if (ret &lt; 0) { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-07T16:57:44+08:00">
    <meta property="article:modified_time" content="2024-07-07T16:57:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux详解】进程等待 | 非阻塞轮询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>引入</strong>：</p> 
<p>为什么？是什么？怎么办</p> 
<h3><a id="_6"></a>是什么？</h3> 
<p>进程等待是指父进程暂停自己的执行，直到某个特定的子进程结束或发生某些特定的事件。</p> 
<h3><a id="_10"></a>为什么？</h3> 
<ul><li>僵尸进程刀枪不入，不可被杀死，存在内存泄露</li><li>获取进程的执行情况，知道我布置给子进程的任务，它完成的怎么样了–可选</li></ul> 
<h3><a id="_15"></a>怎么办</h3> 
<p>wait 函数</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>

pid_t <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>测试：</p> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
 
int main (
    void
    ) 
{
    pid_t id = fork();
    if (id == 0) {
        // child
        while (1) {
            printf("我是子进程，我正在运行... Pid: %d\n", getpid());
            sleep(1);
        }
    }
    else {
        printf("我是父进程: pid: %d，我将耐心地等待子进程！\n", getpid());
        sleep(20);   // 为了便于观察，我们让父进程休眠20s
 
        // 苏醒后，父进程执行 wait，耐心地等待子进程
        pid_t ret = wait(NULL);  // 暂且将status参数设置为NULL
        if (ret &lt; 0) {
            printf("等待失败！\n");
        }
        else {
            printf("等待成功！\n");   // 此时 Z → X
        }
 
        sleep(20);  // 子进程退出后，再让父进程存在一段时间
    }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/29/46/OluVAQx8_o.png" alt="在这里插入图片描述"></p> 
<p>为什么是交替型，不是一个执行完？//了解循环的细节</p> 
<p>在 <code>fork</code> 创建子进程后，<mark>父进程会首先执行</mark>并打印这条信息，其中 <code>&lt;父进程的pid&gt;</code> 是父进程的进程ID。截不下就没截了</p> 
<ul><li><strong>父进程打印一次消息后休眠20秒</strong>: 
  <ul><li>父进程仅在创建子进程后打印一次消息，然后<mark>休眠20秒等待观察子进程的活动</mark>，不再进行其他操作。</li></ul> </li></ul> 
<p>通过这种方式，父进程和子进程能够并发地执行各自的任务，并且我们通过延迟父进程的退出能观察到子进程的连续活动。</p> 
<h5><a id="_78"></a>整个程序执行流程如下：</h5> 
<ol><li> <p>父进程打印：</p> <pre><code>yamlCopy code
我是父进程: pid: 1234，我将耐心地等待子进程！
</code></pre> </li><li> <p>子进程每秒打印一次：</p> <pre><code class="prism language-c++">yamlCopy code
我是子进程，我正在运行... Pid: 5678
</code></pre> <p>（此循环持续到子进程被终止）</p> </li><li> <p>通过终端输入 <code>kill 5678</code> 终止子进程。</p> </li><li> <p>父进程20秒后苏醒并等待子进程结束后，打印：</p> <pre><code>textCopy code
等待成功！
</code></pre> </li></ol> 
<p>之后，父进程再休眠20秒并继续存在一段时间后退出</p> 
<hr> 
<h3><a id="waitpid_109"></a>waitpid</h3> 
<p>刚才讲的 wait 并不是主角，因为其功能比较简单，在进程等待时用的更多的是 <mark>waitpid</mark></p> 
<p>waitpid 可以把 wait 完全包含，wait 是 waitpid 的一个子功能。</p> 
<p><img src="https://images2.imgbox.com/a4/6d/gLSWdDwX_o.png" alt=""></p> 
<p><strong>参数</strong>：</p> 
<ul><li> <pre><code>pid
</code></pre> <p>：要<mark>等待的子进程的进程ID</mark>。根据传入的值可以指定等待任何子进程、特定进程ID的子进程、任何同一进程组的子进程或者任何同一会话的子进程。</p> 
  <ul><li>如果 <code>pid</code> 大于零，<code>waitpid</code> 将等待指定进程ID的子进程结束。</li><li>如果 <code>pid</code> 等于 -1，<code>waitpid</code> 将等待<mark>任意子进程结束</mark>，等同于 <code>wait</code> 函数。</li></ul> </li><li> <p><code>status</code>：一个指向整型的指针，是一个输出型参数，它将用于存储<mark>子进程的终止状态</mark>。</p> </li><li> <pre><code>options
</code></pre> <p>：用于指定等待行为的附加选项。</p> 
  <ul><li>传入0表示以默认行为等待子进程。（阻塞等待中再讲）</li></ul> </li></ul> 
<p><strong>返回值</strong>：</p> 
<ul><li>如果 <code>waitpid</code> 成功，返回值是<mark>已终止子进程的进程ID</mark>。</li><li>如果出现错误，返回-1，并且会设置 <code>errno</code> 变量来指示具体错误原因。</li></ul> 
<blockquote> 
 <p>Z状态，其本质上就是将自己的 task_struct 维护起来（代码可以释放，但是 task_struct 必须维护）。所谓的 wait/waitpid 的退出信息，实际上就是从子进程的 task_struct 中拿出来的，即 <strong>从子进程的 task_struct 中拿出子进程退出的退出码，拷贝到父进程中</strong></p> 
 <p><img src="https://images2.imgbox.com/87/21/d5Cs0hBJ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h6><a id="status_149"></a>status</h6> 
<p>该参数是一个 <strong>输出型参数</strong> （即通过调用该函数，从函数内部拿出来特定的数据）。整数的低 16 位，其中又可以分为 <strong>最低八位</strong> 和 <strong>次低八位</strong>（具体细节看图）：</p> 
<p><img src="https://images2.imgbox.com/c5/7d/Aec3Q0OO_o.png" alt="img"></p> 
<h5><a id="1_155"></a>1.<mark>次低八位：拿子进程退出码</mark></h5> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
 
int main (
    void
    ) 
{
    pid_t id = fork();
    if (id == 0) {
        int cnt = 5;   // 循环5次
        // child
        while (1) {
            // 五秒之内运行状态
            printf("我是子进程，我正在运行... Pid: %d\n", getpid());
            sleep(1);
 
            // 五秒之后子进程终止
            cnt--;
            if (cnt == 0) {
                break; 
            }
        }
 
        exit(233);   // 方便辨识，退出码我们设置为233，这是我们的预期结果
    }
    else {
        printf("我是父进程: pid: %d，我将耐心地等待子进程！\n", getpid());
        
        // ***** 使用waitpid进行进程等待
        int status = 0;  // 接收 waitpid 的 status 参数
 
        pid_t ret = waitpid(id, &amp;status, 0);
        if (ret &gt; 0) {   // 等待成功
            printf (
                "等待成功，ret: %d, 我所等待的子进程退出码: %d\n", 
                ret,
                (status&gt;&gt;8)&amp;0xFF
            );
        }
 
    }
}
</code></pre> 
<p><em>status</em> 并不是整体使用的，而是区域性使用的，我们要取其次低八位。我们可以用 <strong>位操作</strong> 来完成，将 <em>status</em><mark>右移八位再按位与上 0XFF</mark>，即 (<em>status</em>&gt;&gt;8)&amp;0xFF ，就可以提取到 <em>status</em> 的次低八位了。</p> 
<p><img src="https://images2.imgbox.com/7a/3b/cxAOfl07_o.png" alt="在这里插入图片描述"></p> 
<p>waitpid 经过系统调用，来读取子进程的pcb（eg. task_st…)，这是为什么呢</p> 
<blockquote> 
 <p><mark>操作系统不相信任何人</mark>，父进程用户无法直接读取子进程的 pcb ，要通过系统调用的接口</p> 
 <p><img src="https://images2.imgbox.com/db/d8/YjjCqJpm_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h5><a id="2_core_dump_217"></a>2.初识 core dump（核心转储）</h5> 
<p><img src="https://images2.imgbox.com/3e/2a/QMycTPJz_o.png" alt="在这里插入图片描述"></p> 
<p>它是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件。目前只需要知道，该信息是用于<mark>调试</mark>的。</p> 
<h5><a id="3_224"></a>3.最低七位：提取子进程的退出信号</h5> 
<p>刚才我们讲的 wait/waitpid 和次低八位的时侯，都是关于进程(exit) 的 <strong>正常退出。</strong></p> 
<p>如果进程 <strong>异常退出</strong> 呢？我们来模拟一下进程的异常退出。</p> 
<p>💬 模拟异常退出的情况，让子进程一直跑，父进程一直等。</p> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
 
int main (
    void
    ) 
{
    pid_t id = fork();
    if (id == 0) {
        // 子进程一直不退出，父进程会一直等待。
        // child
        while (1) {
            printf("我是子进程，我正在运行... Pid: %d\n", getpid());
            sleep(1);
        }
 
        exit(13);
    }
    else {
        printf("我是父进程: pid: %d，我将耐心地等待子进程！\n", getpid());
        
        int status = 0;
        pid_t ret = waitpid(id, &amp;status, 0);
        if (ret &gt; 0) {   // 等待成功
            printf(
                "等待成功，ret: %d, 我所等待的子进程退出码: %d\n, 退出信号是: %d", 
                ret, (status&gt;&gt;8)&amp;0xFF, 
                status&amp;0x7F
            );
        }
 
    }
}
</code></pre> 
<p>现在我们直接 <mark>while(1)</mark> 死循环让子进程往死里跑，此时父进程由于调用了 waitpid，就会一直等待子进程，<strong>父进程就会持续阻塞</strong>。</p> 
<p>父进程看到子进程<mark>kill</mark>了，终于可以不用等了，可以给子进程收尸了</p> 
<p><img src="https://images2.imgbox.com/1f/40/luj1QNBi_o.png" alt="在这里插入图片描述"></p> 
<p>可以发现，使用-9号信号kill掉进程时,进程的退出信号就是9，然而当进程由于信号异常终止时,此时进程退出码是无意义的！</p> 
<p><strong>所以<mark>进程的等待</mark>可以理解为是 父进程在等给子进程退出记录</strong></p> 
<hr> 
<p><strong>非阻塞轮询</strong></p> 
<p>options -&gt;阻塞方式</p> 
<blockquote> 
 <p>waitpid(pid,&amp;status,WNOHANG);</p> 
</blockquote> 
<p><code>WNOHANG</code>就是wait no hang，hang也就是悬挂,也就是非阻塞，等待子进程死亡,若父进程执行到<code>waitpid</code>时,子进程还没退出,则函数返回0后接着运行下面的代码,若执行到<code>waitpid</code>后子进程已经退出则返回退出子进程的<code>pid</code></p> 
<p>假如要期末考试了，我想找小张去自习室帮我复习，小张自己也在复习，我打电话问他什么时候复习完了，可以出门，情况解释如下</p> 
<p><code>WNOHANG</code> 夯住，非阻塞+循环</p> 
<blockquote> 
 <p>我给小张间隔打电话寻求帮忙，自己干等在楼下</p> 
</blockquote> 
<p>阻塞式调用</p> 
<blockquote> 
 <p>打电话一直不挂</p> 
</blockquote> 
<p><mark>非阻塞轮询+自己的事情</mark>（最高效）</p> 
<blockquote> 
 <p>间隔打电话，<mark>自己也在复习</mark></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/20/1f/4PxTV6gG_o.png" alt="在这里插入图片描述"></p> 
<p><strong>返回值</strong></p> 
<p>pid_t</p> 
<p>ret_pid=0–所等待的条件还没有就绪，&gt;0成功返回退出码，&lt;0失败</p> 
<p><strong>代码验证</strong></p> 
<pre><code class="prism language-c++">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
int main()
{
    pid_t id = fork();
    if(id&lt;0)
    {
        perror("fork");
        exit(1);
    }

    if(id==0)//子进程代码
    {
        int count = 5;
        while(count)
        {
            printf("[%d]我是子进程,我的pid是: %d\n",count,getpid());
            sleep(1);
            count--;
        }
        exit(55);//子进程执行完代码后退出
    }
    //父进程代码
    while(1)//循环访问子进程退出情况
    {
        int wait = waitpid(id,NULL,WNOHANG);
        if(wait&gt;0)//子进程退出成功
        {
            printf("子进程退出成功,子进程pid: %d\n",wait);
            break;
        }
        else if(wait==0)//子进程还没退出,父进程干自己的事情
        {
            //此处简单模拟父进程干的事情
            printf("我是父进程,我现在要干一些别的事情\n");
        }
        else //等待子进程退出失败
        {
            perror("waitpid");
            exit(1);
        }
        sleep(1);
    }
    return 0;
}

</code></pre> 
<p><img src="https://images2.imgbox.com/89/f5/TgWvpbPQ_o.png" alt="在这里插入图片描述"></p> 
<p>⚠️注:这里父进程可以执行任一任务,我使用printf打印,只是为了明显的看到父进程是没有阻塞等待的!</p> 
<hr> 
<h5><a id="_378"></a>进程退出的宏</h5> 
<p>为了增加可读性，定义了接口宏，来查找退出码</p> 
<p><code>WEXITSTATUS </code>和<code>WIFEXITED</code>，在这之前，我们再思考一个问题：</p> 
<p>❓ **思考：**一个进程退出时，可以拿到退出码和推出信号，我们先看谁？</p> 
<p>一旦程序发现异常，我们只关心退出信号，退出码没有任何意义。</p> 
<blockquote> 
 <p>所以，我们先关注退出信号，如果有异常了我们再去关注退出码。</p> 
</blockquote> 
<p>WEXITSTATUS 宏用于查看进程的退出码，若非 0，提取子进程退出码。</p> 
<pre><code class="prism language-scss">WEXITSTATUS(status)
</code></pre> 
<p>WIFEXITED 宏用于查看进程是否正常退出，如果是正常终止的子进程返回状态，则为真。</p> 
<pre><code class="prism language-scss">WIFEXITED(status)
</code></pre> 
<p><code>waitpid</code>意义：</p> 
<ol><li> <p>返回记录子进程内核的数据结构</p> </li><li> <p>Z-&gt;X</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2831b694fc3e4d0cc534875719f209fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot的无缝衔接：深入解析与实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/450d55c3aadd0ee11214c0c8b4bc6039/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于AOP的数据字典实现：实现前端下拉框的可配置更新</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>