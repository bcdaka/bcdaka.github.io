<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java之集合类详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/57a1fe3f4a0b70f2d5dd4c135f74a9db/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java之集合类详解">
  <meta property="og:description" content="·5：集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率
二、Java集合主要由两个接口派生：Collection和Map，是集合框架的根接口。
1. collection的子接口：Set:接口 —实现类： HashSet、LinkedHashSet
set的子接口SortedSet接口—实现类：TreeSet 3. List:接口—实现类： LinkedList,Vector,ArrayList
4. List:有序列表，允许存放重复的元素；
实现类：
ArrayList：数组实现，查询快，增删慢，轻量级；(线程不安全)
LinkedList：双向链表实现，增删快，查询慢 (线程不安全)
Vector：数组实现，重量级 (线程安全、使用少)
5. Set:无序集合，不允许存放重复的元素；允许使用null元素
HashSet 的后台有一个HashMap;初始化后台容量；只不过生成一个HashSet的话，系统只提供key的访问； 如果有两个Key重 复，那么会覆盖之前的；
实现类
HashSet：equals返回true，hashCode返回相同的整数；哈希表；存储的数据是无序的。
LinkedHashSet：此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。
哈希表详解：
http://www.bianceng.cn/Programming/sjjg/200705/1126.htm
http://blog.csdn.net/feixiaoxing/article/details/6885657
http://blog.csdn.net/jdh99/article/details/8490704
6. 子接口SortedSet,对Set排序实现类 :TreeSet：使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序；二叉树实现的；
二叉树详解：
http://blog.csdn.net/luckyxiaoqiang/article/details/7518888/
http://blog.csdn.net/pony_maggie/article/details/38390513
7. Map的实现类：HashMap、TreeMap、LinkedHashMap、Hashtable等
HashMap：键值对，key不能重复，但是value可以重复；key的实现就是HashSet；value对应着放；允许null的键或值；
Hashtable：线程安全的，不允许null的键或值；
Properties:：key和value都是String类型，用来读配置文件；
TreeMap：对key排好序的Map; key 就是TreeSet, value对应每个key; key要实现Comparable接口或TreeMap有自己的构造器；
LinkedHashMap： 此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。存储的数
据是有序的。
接口
简述
实现
操作特性
成员要求
Set
成员不能重复
HashSet
外部无序地遍历成员
成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法。
TreeSet">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-15T05:10:32+08:00">
    <meta property="article:modified_time" content="2024-04-15T05:10:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java之集合类详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>·5：集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率</p> 
<p><strong>二、Java集合主要由两个接口派生：Collection和Map，是集合框架的根接口。</strong></p> 
<p>1. collection的子接口：Set:接口 —实现类： HashSet、LinkedHashSet</p> 
<ol start="2"><li>set的子接口SortedSet接口—实现类：TreeSet</li></ol> 
<p>3. List:接口—实现类： LinkedList,Vector,ArrayList</p> 
<p>4. List:有序列表，允许存放重复的元素；</p> 
<p>实现类：</p> 
<p>ArrayList：数组实现，查询快，增删慢，轻量级；(线程不安全)</p> 
<p>LinkedList：双向链表实现，增删快，查询慢 (线程不安全)</p> 
<p>Vector：数组实现，重量级  (线程安全、使用少)</p> 
<p>5. Set:无序集合，不允许存放重复的元素；允许使用null元素</p> 
<p>HashSet 的后台有一个HashMap;初始化后台容量；只不过生成一个HashSet的话，系统只提供key的访问； 如果有两个Key重   复，那么会覆盖之前的；</p> 
<p>实现类</p> 
<p>HashSet：equals返回true，hashCode返回相同的整数；哈希表；存储的数据是无序的。</p> 
<p>LinkedHashSet：此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。</p> 
<p>哈希表详解：</p> 
<p><a href="" rel="nofollow">http://www.bianceng.cn/Programming/sjjg/200705/1126.htm</a></p> 
<p><a href="" rel="nofollow">http://blog.csdn.net/feixiaoxing/article/details/6885657</a></p> 
<p><a href="" rel="nofollow">http://blog.csdn.net/jdh99/article/details/8490704</a></p> 
<p>6. 子接口SortedSet,对Set排序实现类 :TreeSet：使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序；二叉树实现的；</p> 
<p>二叉树详解：</p> 
<p><a href="" rel="nofollow">http://blog.csdn.net/luckyxiaoqiang/article/details/7518888/</a></p> 
<p><a href="" rel="nofollow">http://blog.csdn.net/pony_maggie/article/details/38390513</a></p> 
<p>7. Map的实现类：HashMap、TreeMap、LinkedHashMap、Hashtable等</p> 
<p>HashMap：键值对，key不能重复，但是value可以重复；key的实现就是HashSet；value对应着放；允许null的键或值；</p> 
<p>Hashtable：线程安全的，不允许null的键或值；</p> 
<p>Properties:：key和value都是String类型，用来读配置文件；</p> 
<p>TreeMap：对key排好序的Map; key 就是TreeSet, value对应每个key; key要实现Comparable接口或TreeMap有自己的构造器；</p> 
<p>LinkedHashMap： 此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。存储的数</p> 
<p>据是有序的。</p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td><p>接口</p></td><td><p>简述</p></td><td><p>实现</p></td><td><p>操作特性</p></td><td><p>成员要求</p></td></tr><tr><td rowspan="3"><p>Set</p></td><td rowspan="3"><p>成员不能重复</p></td><td><p>HashSet</p></td><td><p>外部无序地遍历成员</p></td><td><p>成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法。</p></td></tr><tr><td><p>TreeSet</p></td><td><p>外部有序地遍历成员；附加实现了SortedSet, 支持子集等要求顺序的操作</p></td><td><p>成员要求实现caparable接口，或者使用 <strong>Comparator构造</strong>TreeSet。成员一般为同一类型。</p></td></tr><tr><td><p>LinkedHashSet</p></td><td><p>外部按成员的插入顺序遍历成员</p></td><td><p>成员与HashSet成员类似</p></td></tr><tr><td rowspan="2"><p>List</p></td><td rowspan="2"><p>提供基于索引的对成员的随机访问</p></td><td><p>ArrayList</p></td><td><p>提供快速的基于索引的成员访问，对尾部成员的增加和删除支持较好</p></td><td><p>成员可为任意Object子类的对象</p></td></tr><tr><td><p>LinkedList</p></td><td><p>对列表中任何位置的成员的增加和删除支持较好，但对基于索引的成员访问支持性能较差</p></td><td><p>成员可为任意Object子类的对象</p></td></tr><tr><td rowspan="5"><p>Map</p></td><td rowspan="5"><p>保存键值对成员，基于键找值操作，compareTo或compare方法对键排序</p></td><td><p>HashMap</p></td><td><p>能满足用户对Map的通用需求</p></td><td><p>键成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法。</p></td></tr><tr><td><p>TreeMap</p></td><td><p>支持对键有序地遍历，使用时建议先用HashMap增加和删除成员，最后从HashMap生成TreeMap；附加实现了SortedMap接口，支持子Map等要求顺序的操作</p></td><td><p>键成员要求实现caparable接口，或者使用Comparator构造TreeMap。键成员一般为同一类型。</p></td></tr><tr><td><p>LinkedHashMap</p></td><td><p>保留键的插入顺序，用equals 方法检查键和值的相等性</p></td><td><p>成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法。</p></td></tr><tr><td><p>IdentityHashMap</p></td><td><p>使用== 来检查键和值的相等性。</p></td><td><p>成员使用的是严格相等</p></td></tr><tr><td><p>WeakHashMap</p></td><td><p>其行为依赖于垃圾回收线程，没有绝对理由则少用</p></td><td><p></p></td></tr></tbody></table> 
<p><strong>三、Collection常见方法</strong></p> 
<p>add(E e); addAll(Collection c);clear();contains(Obj o);返回是否包含指定的元素(true false)</p> 
<p>containsAll(Collection c)是否包含c中所有元素 isEmpty(); iterator();remove();size();toArray();返回collection中所有元素的数组</p> 
<p><strong>四、集合的遍历</strong></p> 
<p>1、增强for循环 for(Obj o:c){syso(o)}</p> 
<p>2、使用iterator ， Iterator it=c.iterator;</p> 
<p>while(it.hasNext()){Object o = it.next()}</p> 
<p>3、普通循环：for(Iterator it=c.iterator();it.hasNext()😉{it.next() }</p> 
<p><strong>五、代码实例</strong></p> 
<p>1、 ArrayList</p> 
<p>import java.util.ArrayList;</p> 
<p>/**</p> 
<ul><li><li> <p>关于ArrayList的基本操作</p> </li><li> <p>其它操作感兴趣的读者可以自己结合源码实现一下</p> </li><li> 
  <ul><li>@author erqing</li></ul> </li><li></ul> 
<p>*/</p> 
<p>public class ListTest {<!-- --></p> 
<p>public static void main(String[] args) {<!-- --></p> 
<p>/* 新建一个ArrayList */</p> 
<p>ArrayList list = new ArrayList();</p> 
<p>System.out.println(“初始化大小:” + list.size());</p> 
<p>/* 添加元素 */</p> 
<p>list.add(“zzz”);</p> 
<p>list.add(“egg”);</p> 
<p>list.add(“hell”);</p> 
<p>list.add(“child”);</p> 
<p>System.out.println(“当前容量:” + list.size());</p> 
<p>/* 将ArrayList的大小和实际所含元素的大小设置一致 */</p> 
<p>list.trimToSize();</p> 
<p>/* 遍历 */</p> 
<p>for (String string : list) {<!-- --></p> 
<p>System.out.println(string);</p> 
<p>}</p> 
<p>/* 在指定位置插入元素 */</p> 
<p>list.add(2, “zhu”);</p> 
<p>for (String string : list) {<!-- --></p> 
<p>System.out.println(string);</p> 
<p>}</p> 
<p>System.out.println(“--------------”);</p> 
<p>/* 清空list */</p> 
<p>list.clear();</p> 
<p>/* 遍历 */</p> 
<p>for (String string : list) {<!-- --></p> 
<p>System.out.println(string);</p> 
<p>}</p> 
<p>System.out.println(“--------------”);</p> 
<p>}</p> 
<p>}</p> 
<p>2、LinkedList</p> 
<p>import java.util.LinkedList;</p> 
<p>public class LinkedListTest {<!-- --></p> 
<p>public static void main(String[] args) {<!-- --></p> 
<p>/* 新建一个list */</p> 
<p>LinkedList list = new LinkedList();</p> 
<p>System.out.println(list.size());</p> 
<p>/* 向list中添加元素 */</p> 
<p>list.add(222);</p> 
<p>list.add(111);</p> 
<p>list.add(0);</p> 
<p>list.add(3333);</p> 
<p>list.add(8888);</p> 
<p>System.out.println(list.size());</p> 
<p>/* 遍历list */</p> 
<p>for (Integer integer : list) {<!-- --></p> 
<p>System.out.println(integer);</p> 
<p>}</p> 
<p>/* 获取第一个元素 ,即header的next域*/</p> 
<p>System.out.println(“第一个元素是:” + list.getFirst());</p> 
<p>/<em>获取最后一个元素,即header的previous域</em>/</p> 
<p>System.out.println(“最后一个元素是:”+list.getLast());</p> 
<p>}</p> 
<p>}</p> 
<p>3、hashset</p> 
<p>public static void main(String[] args) {<!-- --></p> 
<p>Set set = new HashSet();</p> 
<p>set.add(“a”);</p> 
<p>set.add(“b”);</p> 
<p>System.out.println(set);</p> 
<p>Student stu= new Student(18, “小名”, 60);</p> 
<p>set.add(stu);//调用第一个对象的hashcode方法 调 equals</p> 
<p>set.add(new Student(19, “小明”, 60));</p> 
<p>set.add(new Student(19, “小明”, 60));</p> 
<p>set.add(new Student(20, “小明”, 61));</p> 
<p>System.out.println(set);</p> 
<p>}</p> 
<p>4、treeset</p> 
<p>import java.util.ArrayList;</p> 
<p>import java.util.HashSet;</p> 
<p>import java.util.TreeSet;</p> 
<p>/**</p> 
<ul><li> <p>使用treeset存放一组学生成绩</p> </li><li> <p>1、可以自动排序(系统类 自然排序)</p> </li><li> <p>2、不可重复(去重)</p> </li><li> <p>3、只能存放一种数据类型</p> </li><li> <p>—存放到 treeset中的元素必须要具有比较能力</p> </li><li> <p>调用compareTo() 如果得到的结果为0 ， 两个元素相等</p> </li><li> <pre><code> 1 ---》排到后面
</code></pre> </li><li> <pre><code> -1 ---&gt;排到前面
</code></pre> </li><li><li> <p>hashset:–&gt;hashtable(哈希表)</p> </li><li> <p>treeset:–&gt;二叉树，红黑树算法</p> </li><li> <p>每存入一个元素就会调用一次compareTo方法</p> </li><li> <p>@author Administrator</p> </li><li></ul> 
<p>*/</p> 
<p>import java.util.Comparator;</p> 
<p>/**</p> 
<ul><li> <p>外部比较器，当系统类提供的比较规则满足不了需求时使用</p> </li><li> <p>1、自己创建一个比较器 实现 Comprator接口 ，添加一个泛型（需要比较的数据类型）</p> </li><li> <p>2、重写comprae方法,用来比较，参数是两个需要比较的对象</p> </li><li> <p>@author Administrator</p> </li><li></ul> 
<p>*/</p> 
<p>public class MyStrCompartor implements Comparator{<!-- --></p> 
<p>@Override</p> 
<p>public int compare(String o1, String o2) {<!-- --></p> 
<p>//按照字符串长度排序</p> 
<p>return o1.length() - o2.length();</p> 
<p>}</p> 
<p>}</p> 
<p>public class TestTreeSet02 {<!-- --></p> 
<p>public static void main(String[] args) {<!-- --></p> 
<p>//使用外部比较器，</p> 
<p>//1 拿到比较器的对象</p> 
<p>MyStrCompartor mcom = new MyStrCompartor();</p> 
<p>//2在创建集合时，调用有参的构造方法，把比较器传进去</p> 
<p>//3、在treeset中添加元素时，会优先调用自定义比较器的方法</p> 
<p>//treeset专用</p> 
<p>TreeSet ts = new TreeSet(mcom);</p> 
<p>// ts.add(20);//自动装箱</p> 
<p>// ts.add(1);</p> 
<p>// ts.add(100);</p> 
<p>// ts.add(7);</p> 
<p>// ts.add(8);</p> 
<p>// ts.add(100);</p> 
<p>System.out.println(ts);</p> 
<p>//需求：不希望按照系统的排序来排列</p> 
<p>//自己创建一个比较规则</p> 
<p>ts.add(“xiaomi32313”);</p> 
<p>ts.add(“zhangliguo5”);</p> 
<p>ts.add(“asima1”);</p> 
<p>ts.add(“baibaibai4”);</p> 
<p>ts.add(“sansan2”);</p> 
<p>// ts.add(new Student(“yushen”, 19, 19));</p> 
<p>// ts.add(new Student(“xiaoming”, 19, 19));</p> 
<p>// ts.add(new Student(“axiaoming1”, 19, 18));</p> 
<p>System.out.println(ts);</p> 
<p>}</p> 
<p>}</p> 
<p>5、hashmap</p> 
<p>import java.util.HashMap;</p> 
<p>import java.util.Map;</p> 
<p>import java.util.Set;<br> <strong>自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。</strong></p> 
<p><strong>深知大多数Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！</strong></p> 
<p><strong>因此收集整理了一份《2024年Java开发全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。</strong><img src="https://images2.imgbox.com/9d/d0/So6aRrzn_o.jpg" alt="img"></p> 
<p><img src="https://images2.imgbox.com/01/46/jpNZ8bNM_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/c6/ca/2J8yr3RE_o.png" alt=""></p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Java开发知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且会持续更新！</strong></p> 
<p><strong>如果你觉得这些内容对你有帮助，可以扫码获取！！（备注Java获取）</strong></p> 
<img src="https://images2.imgbox.com/7c/0b/dLSoNgiw_o.jpg" alt="img"> 
<h2><a id="_449"></a>最后</h2> 
<p>面试是跳槽涨薪最直接有效的方式，马上金九银十来了，各位做好面试造飞机，工作拧螺丝的准备了吗？</p> 
<p>掌握了这些知识点，面试时在候选人中又可以夺目不少，暴击9999点。机会都是留给有准备的人，只有充足的准备，才可能让自己可以在候选人中脱颖而出。</p> 
<p><img src="https://images2.imgbox.com/63/18/EPMYBPZB_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/18/67/sbODWvz9_o.png" alt=""></p> 
<p><strong>《互联网大厂面试真题解析、进阶开发核心学习笔记、全套讲解视频、实战项目源码讲义》<a href="https://bbs.csdn.net/forums/f76c2498e3b04ae99081eaf6e6cf692c">点击传送门即可获取！</a></strong><br> g src=“https://img-blog.csdnimg.cn/img_convert/c0701122e0c60050a061f2f550c2710f.jpeg” alt=“img” style=“zoom: 33%;” /&gt;</p> 
<h2><a id="_462"></a>最后</h2> 
<p>面试是跳槽涨薪最直接有效的方式，马上金九银十来了，各位做好面试造飞机，工作拧螺丝的准备了吗？</p> 
<p>掌握了这些知识点，面试时在候选人中又可以夺目不少，暴击9999点。机会都是留给有准备的人，只有充足的准备，才可能让自己可以在候选人中脱颖而出。</p> 
<p>[外链图片转存中…(img-kZm1kjFZ-1713129018517)]</p> 
<p>[外链图片转存中…(img-HjLlwTW1-1713129018517)]</p> 
<p><strong>《互联网大厂面试真题解析、进阶开发核心学习笔记、全套讲解视频、实战项目源码讲义》<a href="https://bbs.csdn.net/forums/f76c2498e3b04ae99081eaf6e6cf692c">点击传送门即可获取！</a></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9dd02c8f07f0c289578b24de22f581e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git在macOS环境下的安装与配置（小白版）_apple git 设置(1)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8778d47364cc6be2683ac07daf6e43f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[python]gurobi安装和配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>