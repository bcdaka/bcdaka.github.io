<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】AVL树（旋转、平衡因子） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d5cfd7b1b75ed5700a8a6edfbd5fff09/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】AVL树（旋转、平衡因子）">
  <meta property="og:description" content="🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
前言
AVL树的概念
节点
插入
AVL树的旋转 新节点插入较高左子树的左侧---左左：右单旋 新节点插入较高右子树的右侧---右右：左单旋
新节点插入较高左子树的右侧---左右：先左单旋再右单旋
新节点插入较高右子树的左侧---右左：先右单旋再左单旋
AVL树的验证 AVL树的性能
完整代码
前言 💬 hello! 各位铁子们大家好哇。
今日更新了AVL树的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
AVL树的概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查 找元素相当于在顺序表中搜索元素，效率低下。
解决方案：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。
它的左右子树都是AVL树左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1) 如果一棵二叉搜索树是高度平衡的，它就是AVL树。
插入的总体原则：
按照搜索树规则插入更新插入节点的祖先节点的平衡因子。 如果插入在父亲左边，父亲的平衡因子--。如果插入在父亲右边，父亲的平衡因子&#43;&#43;。父亲平衡因子==0，则父亲所在子树高度不变，不再继续往上更新，插入结束。父亲平衡因子==1or-1，父亲所在子树高度变了，继续往上更新。父亲平衡因子==2or-2，父亲所在子树已经不平衡了，需要旋转处理。 节点 插入 bool Insert(const pair&lt;K, V&gt;&amp; kv) { if (_root == nullptr) { _root = new Node(kv); return true; } Node* cur = _root; Node* parent = nullptr; while (cur) { if (cur-&gt;_kv.first &lt; kv.first) { parent = cur; cur = cur-&gt;_right; } else if (cur-&gt;_kv.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T12:06:05+08:00">
    <meta property="article:modified_time" content="2024-07-08T12:06:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】AVL树（旋转、平衡因子）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>🌈个人主页：</strong><a href="https://blog.csdn.net/qinjh_?type=blog" title="秦jh_-CSDN博客">秦jh_-CSDN博客</a><br><strong>🔥 系列专栏：</strong><a href="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482" title="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482">https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482</a></p> 
<p> <img alt="9efbcbc3d25747719da38c01b3fa9b4f.gif" src="https://images2.imgbox.com/2a/06/hBogyQnI_o.gif">​ </p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">AVL树的概念</a></p> 
<p id="%C2%A0%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#%C2%A0%E8%8A%82%E7%82%B9" rel="nofollow"> 节点</a></p> 
<p id="%E6%8F%92%E5%85%A5-toc" style="margin-left:0px;"><a href="#%E6%8F%92%E5%85%A5" rel="nofollow">插入</a></p> 
<p id="AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC%C2%A0-toc" style="margin-left:0px;"><a href="#AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC%C2%A0" rel="nofollow">AVL树的旋转 </a></p> 
<p id="%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%B7%A6%E5%AD%90%E6%A0%91%E7%9A%84%E5%B7%A6%E4%BE%A7---%E5%B7%A6%E5%B7%A6%EF%BC%9A%E5%8F%B3%E5%8D%95%E6%97%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%B7%A6%E5%AD%90%E6%A0%91%E7%9A%84%E5%B7%A6%E4%BE%A7---%E5%B7%A6%E5%B7%A6%EF%BC%9A%E5%8F%B3%E5%8D%95%E6%97%8B%C2%A0" rel="nofollow">新节点插入较高左子树的左侧---左左：右单旋 </a></p> 
<p id="%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7---%E5%8F%B3%E5%8F%B3%EF%BC%9A%E5%B7%A6%E5%8D%95%E6%97%8B-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7---%E5%8F%B3%E5%8F%B3%EF%BC%9A%E5%B7%A6%E5%8D%95%E6%97%8B" rel="nofollow">新节点插入较高右子树的右侧---右右：左单旋</a></p> 
<p id="%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%B7%A6%E5%AD%90%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7---%E5%B7%A6%E5%8F%B3%EF%BC%9A%E5%85%88%E5%B7%A6%E5%8D%95%E6%97%8B%E5%86%8D%E5%8F%B3%E5%8D%95%E6%97%8B-toc" style="margin-left:40px;"><a href="#%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%B7%A6%E5%AD%90%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7---%E5%B7%A6%E5%8F%B3%EF%BC%9A%E5%85%88%E5%B7%A6%E5%8D%95%E6%97%8B%E5%86%8D%E5%8F%B3%E5%8D%95%E6%97%8B" rel="nofollow">新节点插入较高左子树的右侧---左右：先左单旋再右单旋</a></p> 
<p id="%C2%A0%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E5%B7%A6%E4%BE%A7---%E5%8F%B3%E5%B7%A6%EF%BC%9A%E5%85%88%E5%8F%B3%E5%8D%95%E6%97%8B%E5%86%8D%E5%B7%A6%E5%8D%95%E6%97%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E5%B7%A6%E4%BE%A7---%E5%8F%B3%E5%B7%A6%EF%BC%9A%E5%85%88%E5%8F%B3%E5%8D%95%E6%97%8B%E5%86%8D%E5%B7%A6%E5%8D%95%E6%97%8B" rel="nofollow"> 新节点插入较高右子树的左侧---右左：先右单旋再左单旋</a></p> 
<p id="AVL%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81%C2%A0-toc" style="margin-left:0px;"><a href="#AVL%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81%C2%A0" rel="nofollow">AVL树的验证 </a></p> 
<p id="%C2%A0AVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD-toc" style="margin-left:0px;"><a href="#%C2%A0AVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD" rel="nofollow"> AVL树的性能</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">完整代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>    <strong>💬 hello! 各位铁子们大家好哇。</strong></p> 
 <p><strong>             今日更新了AVL树的相关内容</strong><br>     <strong>🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝</strong></p> 
</blockquote> 
<h2 id="AVL%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">AVL树的概念</h2> 
<p> 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查 找元素相当于在顺序表中搜索元素，效率低下。</p> 
<p>解决方案：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。</p> 
<p><img alt="" height="457" src="https://images2.imgbox.com/e8/54/Q6OqIO5m_o.png" width="736"></p> 
<ul><li>它的左右子树都是AVL树</li><li>左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)</li></ul> 
<p><strong>如果一棵二叉搜索树是高度平衡的，它就是AVL树。</strong></p> 
<p>插入的总体原则：</p> 
<blockquote> 
 <ol><li> 按照搜索树规则插入</li><li>更新插入节点的祖先节点的平衡因子。 
   <ol><li>如果插入在父亲左边，父亲的平衡因子--。</li><li>如果插入在父亲右边，父亲的平衡因子++。</li><li>父亲平衡因子==0，则父亲所在子树高度不变，不再继续往上更新，插入结束。</li><li>父亲平衡因子==1or-1，父亲所在子树高度变了，继续往上更新。</li><li>父亲平衡因子==2or-2，父亲所在子树已经不平衡了，需要旋转处理。</li></ol></li></ol> 
</blockquote> 
<h2 id="%C2%A0%E8%8A%82%E7%82%B9"> 节点</h2> 
<p><img alt="" height="703" src="https://images2.imgbox.com/b9/ef/ULnXsKPX_o.png" width="608"></p> 
<h2 id="%E6%8F%92%E5%85%A5">插入</h2> 
<pre><code class="language-cpp">	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		if (_root == nullptr)
		{
			_root = new Node(kv);
			return true;
		}

		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		cur = new Node(kv);
		if (parent-&gt;_kv.first &gt; kv.first)
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}
		cur-&gt;_parent = parent;

		//更新平衡因子
		while (parent) 
		{
			if (cur == parent-&gt;_left)
			{
				parent-&gt;_bf--;
			}
			else
			{
				parent-&gt;_bf++;
			}

			if (parent-&gt;_bf == 0)
			{
				//更新结束
				break;
			}
			else if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)
			{
				//继续往上更新
				cur = parent;
				parent = parent-&gt;_parent;
			}
			else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
			{
				//当前子树出问题了，需要旋转平衡一下

				break;
			}
			else
			{
				//理论而言不可能出现该情况
				assert(false);
			}
		}


		return true;
	}</code></pre> 
<blockquote> 
 <p>上面是插入的大体流程，旋转操作还未给出。</p> 
</blockquote> 
<h2 id="AVL%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC%C2%A0">AVL树的旋转 </h2> 
<p>如果在一棵原本是平衡的AVL树中插入一个新节点，可能造成不平衡，此时必须调整树的结构， 使之平衡化。根据节点插入位置的不同，AVL树的旋转分为四种：</p> 
<h3 id="%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%B7%A6%E5%AD%90%E6%A0%91%E7%9A%84%E5%B7%A6%E4%BE%A7---%E5%B7%A6%E5%B7%A6%EF%BC%9A%E5%8F%B3%E5%8D%95%E6%97%8B%C2%A0">新节点插入较高左子树的左侧---左左：右单旋 </h3> 
<p><img alt="" height="333" src="https://images2.imgbox.com/81/3b/xuF6QEa3_o.png" width="1200"></p> 
<blockquote> 
 <p>这里以抽象图进行分析，因为具体的情况有很多种，无法画出。</p> 
 <p>注意：a子树的情况必须是插入后会引发祖先节点的更新，而不是只是内部变化。如下图情况就不符合要求。<img alt="" height="253" src="https://images2.imgbox.com/4d/ee/a6J3Bpdo_o.png" width="710"></p> 
 <p>旋转流程：新节点插入在a树中，导致以60为根的二叉树不平衡。所以就要右单旋。</p> 
 <p>右单旋：把60的左子树高度减少，即把60取出来，让30的右子树变成60的左子树，再把以60为根的树变成30的右子树。30成为新的根。</p> 
</blockquote> 
<p><img alt="" height="375" src="https://images2.imgbox.com/78/73/SgGjd3Qe_o.png" width="533"></p> 
<pre><code class="language-cpp">	void RotateR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR) //节点可能为空
			subLR-&gt;_parent = parent;

		subL-&gt;_right = parent; //旧父节点变成subL的右节点
		
		Node* ppNode = parent-&gt;_parent;  //该不平衡节点可能不是根节点，所以要找到它的父节点
		parent-&gt;_parent = subL;				

		if (parent == _root)   //如果该节点是根节点
		{
			_root = subL;		
			_root-&gt;_parent = nullptr;
		}
		else  //不平衡节点只是一棵子树
		{
			if (ppNode-&gt;_left == parent)  //如果旧父节点等于爷爷节点的左节点，新父节点为爷爷节点的左节点
			{
				ppNode-&gt;_left = subL;
			}
			else
			{
				ppNode-&gt;_right = subL;
			}

			subL-&gt;_parent = ppNode;	//新父节点指向爷爷节点。
		}

		parent-&gt;_bf = subL-&gt;_bf = 0;  //只需要修改这两个的平衡因子


	}</code></pre> 
<h3 id="%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7---%E5%8F%B3%E5%8F%B3%EF%BC%9A%E5%B7%A6%E5%8D%95%E6%97%8B">新节点插入较高右子树的右侧---右右：左单旋</h3> 
<p><img alt="" height="428" src="https://images2.imgbox.com/bc/d5/9qqENkjI_o.png" width="1200"></p> 
<blockquote> 
 <p>参考右单旋。</p> 
</blockquote> 
<p>左单旋和右单旋的调用如下图：</p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/e8/3a/E5zfSPzk_o.png" width="995"></p> 
<h3 id="%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%B7%A6%E5%AD%90%E6%A0%91%E7%9A%84%E5%8F%B3%E4%BE%A7---%E5%B7%A6%E5%8F%B3%EF%BC%9A%E5%85%88%E5%B7%A6%E5%8D%95%E6%97%8B%E5%86%8D%E5%8F%B3%E5%8D%95%E6%97%8B">新节点插入较高左子树的右侧---左右：先左单旋再右单旋</h3> 
<p><img alt="" height="549" src="https://images2.imgbox.com/01/60/LErD9pxM_o.png" width="1200"></p> 
<blockquote> 
 <p>单旋用在一边一直高的情况。双旋是先一边高再另一边高的情况。</p> 
 <p>双旋的的原理就是把折线变成直线，再像处理直线一样旋转。</p> 
 <p>双旋可以复用单旋，但双旋主要要搞清平衡因子的变化。</p> 
</blockquote> 
<p>第一种情况： </p> 
<p><img alt="" height="727" src="https://images2.imgbox.com/cb/ee/HP78nlwz_o.png" width="1200"></p> 
<blockquote> 
 <p>双旋的结果：60的左边给了30的右边，60的右边给了90的左边，30和90分别成为60的左右，60成为根。</p> 
</blockquote> 
<p>上图是插入b引起的旋转，当插入c时是第二种情况，如下图：</p> 
<p><img alt="" height="712" src="https://images2.imgbox.com/bb/91/3T1osK4k_o.png" width="1200"></p> 
<blockquote> 
 <p>上面两种插入位置的不同，导致最终的平衡因子不同。</p> 
</blockquote> 
<p>第三种情况：</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/a6/df/N5x7SGbx_o.png" width="1200"></p> 
<blockquote> 
 <p>h==0时，60就是新增节点，最终的平衡因子也不同。</p> 
</blockquote> 
<pre><code class="language-cpp">	void RotateLR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right; 

		int bf = subLR-&gt;_bf;  //记录未旋转前subLR的平衡因子

		RotateL(parent-&gt;_left);  
		RotateR(parent);
	
		if (bf == -1)  //如果bf为-1，即插入在subLR的左边
		{
			subLR-&gt;_bf = 0;
			subL-&gt;_bf = 0;
			parent-&gt;_bf = 1;
		}
		else if (bf == 1) //插入在subLR的右边
		{
			subLR-&gt;_bf = 0;
			subL-&gt;_bf = -1;
			parent-&gt;_bf = 0;
		}
		else if (bf == 0)
		{
			subLR-&gt;_bf = 0;
			subL-&gt;_bf = 0;
			parent-&gt;_bf = 0;
		}
		else
		{
			assert(false);
		}
	}</code></pre> 
<h3 id="%C2%A0%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%BE%83%E9%AB%98%E5%8F%B3%E5%AD%90%E6%A0%91%E7%9A%84%E5%B7%A6%E4%BE%A7---%E5%8F%B3%E5%B7%A6%EF%BC%9A%E5%85%88%E5%8F%B3%E5%8D%95%E6%97%8B%E5%86%8D%E5%B7%A6%E5%8D%95%E6%97%8B"> 新节点插入较高右子树的左侧---右左：先右单旋再左单旋</h3> 
<p><img alt="" height="772" src="https://images2.imgbox.com/13/07/6aAiIWce_o.png" width="1200"></p> 
<blockquote> 
 <p>参考左右双旋，注意，这里也要讨论那三种情况。 </p> 
</blockquote> 
<pre><code class="language-cpp">	void RotateRL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;
		int bf = subRL-&gt;_bf;

		RotateR(parent-&gt;_right);
		RotateL(parent);

		subRL-&gt;_bf = 0;
		if (bf == 1)
		{
			subR-&gt;_bf = 0;
			parent-&gt;_bf = -1;
		}
		else if (bf == -1)
		{
			parent-&gt;_bf = 0;
			subR-&gt;_bf = 1;
		}
		else
		{
			parent-&gt;_bf = 0;
			subR-&gt;_bf = 0;
		}
	}</code></pre> 
<h2 id="AVL%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81%C2%A0">AVL树的验证 </h2> 
<p>AVL树是在二叉搜索树的基础上加入了平衡性的限制，因此要验证AVL树，可以分两步：</p> 
<ol><li><strong>验证其为二叉搜索树</strong>。如果中序遍历可得到一个有序的序列，就说明为二叉搜索树</li><li><strong>验证其为平衡树</strong>。每个节点子树高度差的绝对值不超过1(注意节点中如果没有平衡因子) 节点的平衡因子是否计算正确 </li></ol> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/da/1f/eN8Ej9bZ_o.png" width="1078"></p> 
<blockquote> 
 <p> 因为root是私有的，又因为需要递归检查每棵子树是否平衡，所以可以写一个私有的_IsBalance方法，通过公有的IsBalance方法来调用。</p> 
</blockquote> 
<h2 id="%C2%A0AVL%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD"> AVL树的性能</h2> 
<p>AVL树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过1，这 样可以保证查询时高效的时间复杂度，即O(logN)。 但是如果要对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时， 有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑AVL树，但一个结构经常修改，就不太适合。红黑树在经常进行增删的结构中性能比AVL树更优。</p> 
<h2 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">完整代码</h2> 
<pre><code class="language-cpp">template&lt;class K, class V&gt;
struct AVLTreeNode
{
	AVLTreeNode&lt;K, V&gt;* _left;
	AVLTreeNode&lt;K, V&gt;* _right;
	AVLTreeNode&lt;K, V&gt;* _parent;
	pair&lt;K, V&gt; _kv;

	int _bf;

	AVLTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _kv(kv)
		,_bf(0)
	{}
};

template&lt;class K, class V&gt;
class AVLTree
{
	typedef AVLTreeNode&lt;K, V&gt; Node;
public:
	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		if (_root == nullptr)
		{
			_root = new Node(kv);
			return true;
		}

		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		cur = new Node(kv);
		if (parent-&gt;_kv.first &gt; kv.first)
		{
			parent-&gt;_left = cur;
		}
		else
		{
			parent-&gt;_right = cur;
		}
		cur-&gt;_parent = parent;

		//更新平衡因子
		while (parent) 
		{
			if (cur == parent-&gt;_left)
			{
				parent-&gt;_bf--;
			}
			else
			{
				parent-&gt;_bf++;
			}

			if (parent-&gt;_bf == 0)
			{
				//更新结束
				break;
			}
			else if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)
			{
				//继续往上更新
				cur = parent;
				parent = parent-&gt;_parent;
			}
			else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
			{
				//当前子树出问题了，需要旋转平衡一下
				if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1) //左边高，右单旋
				{
					RotateR(parent);
				}
				else if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)//右边高，左单旋
				{
					RotateL(parent);
				}
				else if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1)
				{ 
					RotateRL(parent);
				}
				else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1)
				{
					RotateLR(parent); 
				}

				break;
			}
			else
			{
				//理论而言不可能出现该情况
				assert(false);
			}
		}


		return true;
	}

	Node* Find(const K&amp; key)
	{
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; key)
			{
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; key)
			{
				cur = cur-&gt;_left;
			}
			else
			{
				return cur;
			}
		}
		return nullptr;
	}

	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}

	void RotateR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR) //节点可能为空
			subLR-&gt;_parent = parent;

		subL-&gt;_right = parent; //旧父节点变成subL的右节点
		
		Node* ppNode = parent-&gt;_parent;  //该不平衡节点可能不是根节点，所以要找到它的父节点
		parent-&gt;_parent = subL;				

		if (parent == _root)   //如果该节点是根节点
		{
			_root = subL;		
			_root-&gt;_parent = nullptr;
		}
		else  //不平衡节点只是一棵子树
		{
			if (ppNode-&gt;_left == parent)  //如果旧父节点等于爷爷节点的左节点，新父节点为爷爷节点的左节点
			{
				ppNode-&gt;_left = subL;
			}
			else
			{
				ppNode-&gt;_right = subL;
			}
			subL-&gt;_parent = ppNode;	//新父节点指向爷爷节点。
		}
		parent-&gt;_bf = subL-&gt;_bf = 0;  //只需要修改这两个的平衡因子
	}

	void RotateL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		if (subRL)
			subRL-&gt;_parent = parent;

		subR-&gt;_left = parent;
		Node* ppNode = parent-&gt;_parent;

		parent-&gt;_parent = subR;

		if (parent == _root)
		{
			_root = subR;
			_root-&gt;_parent = nullptr;
		}
		else
		{
			if (ppNode-&gt;_right == parent)
			{
				ppNode-&gt;_right = subR;
			}
			else
			{
				ppNode-&gt;_left = subR;
			}
			subR-&gt;_parent = ppNode;
		}
		parent-&gt;_bf = subR-&gt;_bf = 0;
	}

	void RotateRL(Node* parent)
	{
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;
		int bf = subRL-&gt;_bf;

		RotateR(parent-&gt;_right);
		RotateL(parent);

		subRL-&gt;_bf = 0;
		if (bf == 1)
		{
			subR-&gt;_bf = 0;
			parent-&gt;_bf = -1;
		}
		else if (bf == -1)
		{
			parent-&gt;_bf = 0;
			subR-&gt;_bf = 1;
		}
		else
		{
			parent-&gt;_bf = 0;
			subR-&gt;_bf = 0;
		}
	}

	void RotateLR(Node* parent)
	{
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right; 

		int bf = subLR-&gt;_bf;  //记录未旋转前subLR的平衡因子

		RotateL(parent-&gt;_left);  
		RotateR(parent);
	
		if (bf == -1)  //如果bf为-1，即插入在subLR的左边
		{
			subLR-&gt;_bf = 0;
			subL-&gt;_bf = 0;
			parent-&gt;_bf = 1;
		}
		else if (bf == 1) //插入在subLR的右边
		{
			subLR-&gt;_bf = 0;
			subL-&gt;_bf = -1;
			parent-&gt;_bf = 0;
		}
		else if (bf == 0)
		{
			subLR-&gt;_bf = 0;
			subL-&gt;_bf = 0;
			parent-&gt;_bf = 0;
		}
		else
		{
			assert(false);
		}
	}
	bool IsBalance()
	{
		return _IsBalance(_root);
	}

	int Height() //树的高度
	{
		return _Height(_root);
	}

	int Size()  //插入的节点个数
	{
		return _Size(_root);
	}

private:
	int _Size(Node* root)
	{
		return root == nullptr ? 0 : _Size(root-&gt;_left) + _Size(root-&gt;_right) + 1;
	}

	int _Height(Node* root)
	{
		if (root == nullptr)
			return 0;
		return max(_Height(root-&gt;_left), _Height(root-&gt;_right)) + 1;
	}

	bool _IsBalance(Node* root) 
	{
		if (root == nullptr) 
			return true;
		
		int	leftHeight = _Height(root-&gt;_left);
		int	rightHeight = _Height(root-&gt;_right);
		//如果不平衡
		if (abs(leftHeight - rightHeight) &gt;= 2)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; endl;
			return false;
		}

		//检查平衡因子是否正确
		if (rightHeight - leftHeight != root-&gt;_bf)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; endl;
			return false;
		}

		return _IsBalance(root-&gt;_left)
			&amp;&amp; _IsBalance(root-&gt;_right);
	}
	
	
	void _InOrder(Node* root)
	{
		if (root == nullptr)
			return;

		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_kv.first &lt;&lt; ":" &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;
		_InOrder(root-&gt;_right);
	}

private:
	Node* _root=nullptr; 
};

void AVLTreeTest1()
{
	//int a[] = { 8, 3, 1, 10, 6, 4, 7, 14, 13 };
	int a[] = { 4, 2, 6, 1, 3, 5, 15, 7, 16, 14 };
	AVLTree&lt;int,int&gt; t1;
	for (auto e : a)
	{
		t1.Insert({e,e});

		cout &lt;&lt;"Insert:"&lt;&lt;e&lt;&lt;"-&gt;"&lt;&lt; t1.IsBalance() &lt;&lt; endl;
	}

	t1.InOrder();	

	cout &lt;&lt; t1.IsBalance() &lt;&lt; endl;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d3910126d62b10cde0f7b1402a69ef1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2.5 C#视觉程序开发实例1----CamManager实现模拟相机采集图片(Form_Vision部分代码)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/00e4061de8eb3d7aac2fbcc643d43ee6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(010)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>