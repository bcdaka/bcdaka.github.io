<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】算法复杂度 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/45ee45c0e165d19cdd283363364d203b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】算法复杂度">
  <meta property="og:description" content="目录
正文开始
1. 数据结构前⾔ 1.1 数据结构 数据结构(Data Structure)是计算机存储、组织数据的⽅式，指相互之间存在⼀种或多种特定关系的数据元素的集合。没有⼀种单⼀的数据结构对所有⽤途都有⽤，所以我们要学各式各样的数据结构， 如：线性表、树、图、哈希等 1.2 算法 算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。 如何学好数据结构和算法 2. 算法效率 算法效率是指算法解决问题所需的时间或空间资源。 常用的衡量算法效率的指标有时间复杂度和空间复杂度。 2.1 复杂度的概念 算法在编写成可执⾏程序后，运⾏时需要耗费时间资源和空间(内存)资源 。因此衡量⼀个算法的好 坏，⼀般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。 时间复杂度主要衡量⼀个算法的运⾏快慢，⽽空间复杂度主要衡量⼀个算法运⾏所需要的额外空间。 在计算机发展的早期，计算机的存储容量很⼩。所以对空间复杂度很是在乎。但是经过计算机⾏业的迅速发展，计算机的存储容量已经达到了很⾼的程度。所以我们如今已经不需要再特别关注⼀个算法的空间复杂度。 2.2 复杂度的重要性 复杂度是评估算法或程序性能的重要指标。它衡量了算法在处理输入数据时所需的时间和空间资源。复杂度越低，意味着算法执行所需的资源越少，效率越高。 复杂度的重要性体现在以下几个方面：
时间效率：在大数据量下，算法的执行时间可能会成倍增长。通过比较不同算法的复杂度，可以选择更高效的算法，缩短程序的运行时间。
空间效率：算法的空间复杂度决定了它在内存中所需的资源。随着数据量的增长，算法的空间消耗也会相应增加。通过选择空间复杂度较低的算法，可以最大限度地节省内存资源。
可维护性：复杂度较低的算法往往更易于理解和维护。它们通常具有更少的代码行数和更少的嵌套结构，使得程序的逻辑更加清晰，易于调试和修改。
可拓展性：复杂度较低的算法在处理大规模问题时更具有扩展性。通过优化算法的复杂度，可以使其在处理更大规模的数据时仍能保持较高的效率。
综上所述，复杂度的重要性在于它对算法或程序的性能评估和优化提供了指导。通过对复杂度的分析，可以选择更高效的算法，提高程序的执行效率，并在处理大规模问题时提供良好的扩展性和可维护性。
3. 时间复杂度 定义：在计算机科学中，算法的时间复杂度是⼀个函数式T(N)，它定量描述了该算法的运⾏时间。时间复杂度是衡量程序的时间效率，那么为什么不去计算程序的运⾏时间呢？ 1. 因为程序运⾏时间和编译环境和运⾏机器的配置都有关系，⽐如同⼀个算法程序，⽤⼀个⽼编译 器进⾏编译和新编译器编译，在同样机器下运⾏时间不同。 2. 同⼀个算法程序，⽤⼀个⽼低配置机器和新⾼配置机器，运⾏时间也不同。 3. 并且时间只能程序写好后测试，不能写程序前通过理论思想计算评估。 那么算法的时间复杂度是⼀个函数式T(N)到底是什么呢？这个T(N)函数式计算了程序的执⾏次数。通过c语⾔编译链接章节学习，我们知道算法程序被编译后⽣成⼆进制指令，程序运⾏，就是cpu执⾏这些编译好的指令。那么我们通过程序代码或者理论思想计算出程序的执⾏次数的函数式T(N)，假每句指令执⾏时间基本⼀样(实际中有差别，但是微乎其微)，那么执⾏次数和运⾏时间就是等⽐正相关，这样也脱离了具体的编译运⾏环境。执⾏次数就可以代表程序时间效率的优劣。⽐如解决⼀个问题的算法a程序T(N) = N，算法b程序T(N) = N^2，那么算法a的效率⼀定优于算法b。 案例： // 请计算⼀下Func1中&#43;&#43;count语句总共执⾏了多少 次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; &#43;&#43; i) { for (int j = 0; j &lt; N ; &#43;&#43; j) { &#43;&#43;count; } } for (int k = 0; k &lt; 2 * N ; &#43;&#43; k) { &#43;&#43;count; } int M = 10; while (M--) { &#43;&#43;count; } } Func1 执⾏的基本操作次数： T ( N ) = N 2 &#43; 2 ∗ N &#43; 10 • N = 10 T(N) = 130 • N = 100 T(N) = 10210 • N = 1000 T(N) = 1002010 通过对N取值分析，对结果影响最⼤的⼀项是 N 2 实际中我们计算时间复杂度时，计算的也不是程序的精确的执⾏次数，精确执⾏次数计算起来还是很⿇烦的(不同的⼀句程序代码，编译出的指令条数都是不⼀样的)，计算出精确的执⾏次数意义也不⼤，因为我们计算时间复杂度只是想⽐较算法程序的增⻓量级，也就是当N不断变⼤时T(N)的差别，上⾯我们已经看到了当N不断变⼤时常数和低阶项对结果的影响很⼩，所以我们只需要计算程序能代表增⻓量级的⼤概执⾏次数，复杂度的表⽰通常使⽤⼤O的渐进表⽰法。 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T14:37:32+08:00">
    <meta property="article:modified_time" content="2024-08-13T14:37:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】算法复杂度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="426" src="https://images2.imgbox.com/25/8b/FOleECBy_o.jpg" width="681"></p> 
<p></p> 
<p>目录</p> 
<p></p> 
<blockquote> 
 <p>正文开始</p> 
</blockquote> 
<h4></h4> 
<h2><span style="color:#38d8f0;">1. </span><span style="color:#1f2329;">数据结构前⾔</span></h2> 
<h4></h4> 
<h3><span style="color:#1456f0;">1.1 </span><span style="color:#1f2329;">数据结构 </span></h3> 
<div> 
 <span style="color:#1f2329;">数据结构(Data Structure)是计算机存储、组织数据的⽅式，指相互之间存在⼀种或多种特定关系的数据元素的集合。没有⼀种单⼀的数据结构对所有⽤途都有⽤，所以我们要学各式各样的数据结构， </span> 
</div> 
<div> 
 <span style="color:#1f2329;">如：线性表、树、图、哈希等 </span> 
</div> 
<h4></h4> 
<h3><span style="color:#1456f0;">1.2 </span><span style="color:#1f2329;">算法 </span></h3> 
<div> 
 <span style="color:#1f2329;">算法(Algorithm):就是定义良好的计算过程，他取⼀个或⼀组的值为输⼊，并产⽣出⼀个或⼀组值作为输出。简单来说算法就是⼀系列的计算步骤，⽤来将输⼊数据转化成输出结果。 </span> 
</div> 
<p></p> 
<p></p> 
<div> 
 <span style="color:#fe2c24;"><strong>如何学好数据结构和算法</strong></span> 
</div> 
<div></div> 
<div> 
 <img alt="" height="474" src="https://images2.imgbox.com/3b/04/9qyg78CJ_o.png" width="932"> 
</div> 
<div></div> 
<div></div> 
<div></div> 
<h4></h4> 
<div> 
 <h2><span style="color:#1456f0;">2. </span><span style="color:#1f2329;">算法效率</span></h2> 
</div> 
<div>
  算法效率是指算法解决问题所需的时间或空间资源。 
</div> 
<div>
  常用的衡量算法效率的指标有时间复杂度和空间复杂度。 
</div> 
<div></div> 
<div> 
 <h4></h4> 
 <h3><span style="color:#1456f0;">2.1 </span><span style="color:#1f2329;">复杂度的概念 </span></h3> 
 <div> 
  <span style="color:#1f2329;">算法在编写成可执⾏程序后，运⾏时需要耗费时间资源和空间(内存)资源 。因此<strong>衡量⼀个算法的好 </strong></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;"><strong>坏，⼀般是从时间和空间两个维度来衡量的</strong>，即时间复杂度和空间复杂度。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#1f2329;"><strong>时间复杂度主要衡量⼀个算法的运⾏快慢，⽽空间复杂度主要衡量⼀个算法运⾏所需要的额外空间</strong>。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#1f2329;">在计算机发展的早期，计算机的存储容量很⼩。所以对空间复杂度很是在乎。但是经过计算机⾏业的迅速发展，计算机的存储容量已经达到了很⾼的程度。所以我们如今已经不需要再特别关注⼀个算法的空间复杂度。 </span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<h4></h4> 
<div> 
 <h3><span style="color:#1456f0;">2.2 </span><span style="color:#1f2329;">复杂度的重要性</span></h3> 
</div> 
<div>
  复杂度是评估算法或程序性能的重要指标。它衡量了算法在处理输入数据时所需的时间和空间资源。复杂度越低，意味着算法执行所需的资源越少，效率越高。 
</div> 
<div></div> 
<div> 
 <p>复杂度的重要性体现在以下几个方面：</p> 
 <ol><li> <p><strong>时间效率</strong>：在大数据量下，算法的执行时间可能会成倍增长。通过比较不同算法的复杂度，可以选择更高效的算法，缩短程序的运行时间。</p> </li><li> <p><strong>空间效率</strong>：算法的空间复杂度决定了它在内存中所需的资源。随着数据量的增长，算法的空间消耗也会相应增加。通过选择空间复杂度较低的算法，可以最大限度地节省内存资源。</p> </li><li> <p><strong>可维护性</strong>：复杂度较低的算法往往更易于理解和维护。它们通常具有更少的代码行数和更少的嵌套结构，使得程序的逻辑更加清晰，易于调试和修改。</p> </li><li> <p><strong>可拓展性</strong>：复杂度较低的算法在处理大规模问题时更具有扩展性。通过优化算法的复杂度，可以使其在处理更大规模的数据时仍能保持较高的效率。</p> </li></ol> 
 <p>综上所述，复杂度的重要性在于它对算法或程序的性能评估和优化提供了指导。通过对复杂度的分析，可以选择更高效的算法，提高程序的执行效率，并在处理大规模问题时提供良好的扩展性和可维护性。</p> 
</div> 
<div></div> 
<h4></h4> 
<div> 
 <h2><span style="color:#1456f0;">3. </span><span style="color:#1f2329;">时间复杂度</span></h2> 
</div> 
<div> 
 <div> 
  <span style="color:#1f2329;">定义：在计算机科学中，<strong>算法的时间复杂度是⼀个函数式T(N)</strong>，它定量描述了该算法的运⾏时间。时间复杂度是衡量程序的时间效率，那么为什么不去计算程序的运⾏时间呢？ </span> 
 </div> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#1456f0;">1. </span> 
  <span style="color:#646a73;">因为程序运⾏时间和编译环境和运⾏机器的配置都有关系，⽐如同⼀个算法程序，⽤⼀个⽼编译 </span> 
 </div> 
 <div> 
  <span style="color:#646a73;">器进⾏编译和新编译器编译，在同样机器下运⾏时间不同。 </span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">2. </span> 
  <span style="color:#646a73;">同⼀个算法程序，⽤⼀个⽼低配置机器和新⾼配置机器，运⾏时间也不同。 </span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">3. </span> 
  <span style="color:#646a73;">并且时间只能程序写好后测试，不能写程序前通过理论思想计算评估。 </span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#1f2329;">那么算法的时间复杂度是⼀个函数式T(N)到底是什么呢？这个T(N)函数式计算了程序的执⾏次数。通过c语⾔编译链接章节学习，我们知道算法程序被编译后⽣成⼆进制指令，程序运⾏，就是cpu执⾏这些编译好的指令。那么我们通过程序代码或者理论思想计算出程序的执⾏次数的函数式T(N)，假每句指令执⾏时间基本⼀样(实际中有差别，但是微乎其微)，那么执⾏次数和运⾏时间就是等⽐正相关，这样也脱离了具体的编译运⾏环境。执⾏次数就可以代表程序时间效率的优劣。⽐如解决⼀个问题的算法a程序T(N) = N，算法b程序T(N) = N^2，那么算法a的效率⼀定优于算法b。 </span> 
 </div> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#1f2329;">案例： </span> 
 </div> 
 <div></div> 
 <div> 
  <pre><code class="hljs">// 请计算⼀下Func1中++count语句总共执⾏了多少
次？
void Func1(int N)
{
int count = 0;
for (int i = 0; i &lt; N ; ++ i)
{
for (int j = 0; j &lt; N ; ++ j)
{
++count;
}
}
for (int k = 0; k &lt; 2 * N ; ++ k)
{
++count;
}
int M = 10;
while (M--)
{
++count;
}
}</code></pre> 
  <div> 
   <strong><span style="color:#1f2329;">Func1 执⾏的基本操作次数： </span></strong> 
  </div> 
  <div> 
   <span style="color:#1f2329;"><em>T </em></span> 
   <span style="color:#1f2329;">(</span> 
   <span style="color:#1f2329;"><em>N</em></span> 
   <span style="color:#1f2329;">) = </span> 
   <span style="color:#1f2329;"><em>N</em></span> 
   <span style="color:#1f2329;">2 </span> 
   <span style="color:#1f2329;">+ 2 ∗ </span> 
   <span style="color:#1f2329;"><em>N </em></span> 
   <span style="color:#1f2329;">+ 10 </span> 
  </div> 
  <div> 
   <span style="color:#1456f0;">• </span> 
   <span style="color:#1f2329;">N = 10 T(N) = 130 </span> 
  </div> 
  <div> 
   <span style="color:#1456f0;">• </span> 
   <span style="color:#1f2329;">N = 100 T(N) = 10210 </span> 
  </div> 
  <div> 
   <span style="color:#1456f0;">• </span> 
   <span style="color:#1f2329;">N = 1000 T(N) = 1002010 </span> 
  </div> 
  <div> 
   <span style="color:#1f2329;">通过对N取值分析，对结果影响最⼤的⼀项是 <em>N</em></span> 
   <span style="color:#1f2329;">2 </span> 
  </div> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#1f2329;">实际中我们计算时间复杂度时，计算的也不是程序的精确的执⾏次数，精确执⾏次数计算起来还是很⿇烦的(不同的⼀句程序代码，编译出的指令条数都是不⼀样的)，计算出精确的执⾏次数意义也不⼤，因为我们计算时间复杂度只是想⽐较算法程序的增⻓量级，也就是当N不断变⼤时T(N)的差别，上⾯我们已经看到了当N不断变⼤时常数和低阶项对结果的影响很⼩，所以我们<strong>只需要计算程序能代表增⻓量级的⼤概执⾏次数，复杂度的表⽰通常使⽤⼤O的渐进表⽰法</strong>。 </span> 
 </div> 
</div> 
<h4></h4> 
<p></p> 
<div> 
 <h3><span style="color:#1456f0;">3.1 </span><span style="color:#1f2329;">⼤O的渐进表⽰法 </span></h3> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#1f2329;">⼤O符号（Big O notation）：是⽤于描述函数渐进⾏为的数学符号</span> 
 </div> 
</div> 
<div></div> 
<div> 
 <div></div> 
 <blockquote> 
  <div> 
   <span style="color:#d83931;">推导⼤O阶规则</span> 
  </div> 
  <div></div> 
  <div> 
   <p></p> 
   <div> 
    <span style="color:#1456f0;">1. </span> 
    <span style="color:#1f2329;">时间复杂度函数式</span> 
    <span style="color:#1f2329;">T(N)</span> 
    <span style="color:#1f2329;">中，只保留最⾼阶项，去掉那些低阶项，因为当</span> 
    <span style="color:#1f2329;">N</span> 
    <span style="color:#1f2329;">不断变⼤时， 低阶项对结果影响越来越⼩，当N</span> 
    <span style="color:#1f2329;">⽆穷⼤时，就可以忽略不计了。 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#1456f0;">2. </span> 
    <span style="color:#1f2329;">如果最⾼阶项存在且不是</span> 
    <span style="color:#1f2329;">1</span> 
    <span style="color:#1f2329;">，则去除这个项⽬的常数系数，因为当</span> 
    <span style="color:#1f2329;">N</span> 
    <span style="color:#1f2329;">不断变⼤，这个系数对结果影响越来越⼩，当N</span> 
    <span style="color:#1f2329;">⽆穷⼤时，就可以忽略不计了。 </span> 
   </div> 
   <div></div> 
   <div></div> 
   <div> 
    <span style="color:#1456f0;">3. </span> 
    <span style="color:#1f2329;">T(N)</span> 
    <span style="color:#1f2329;">中如果没有</span> 
    <span style="color:#1f2329;">N</span> 
    <span style="color:#1f2329;">相关的项⽬，只有常数项，⽤常数</span> 
    <span style="color:#1f2329;">1</span> 
    <span style="color:#1f2329;">取代所有加法常数。 </span> 
   </div> 
   <div></div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#1f2329;">通过以上⽅法，可以得到 </span> 
     <span style="color:#1f2329;">Func1 </span> 
     <span style="color:#1f2329;">的时间复杂度为： </span> 
     <span style="color:#1f2329;"><em>O</em></span> 
     <span style="color:#1f2329;">(</span> 
     <span style="color:#1f2329;"><em>N</em></span> 
     <span style="color:#1f2329;">2 </span> 
     <span style="color:#1f2329;">)</span> 
    </div> 
   </div> 
  </div> 
 </blockquote> 
</div> 
<h4></h4> 
<div> 
 <h3><span style="color:#1456f0;">3.2 </span><span style="color:#1f2329;">时间复杂度计算⽰例</span></h3> 
</div> 
<div></div> 
<div> 
 <h4><span style="color:#1456f0;">3.2.1 </span><span style="color:#1f2329;">⽰例1</span></h4> 
</div> 
<div></div> 
<div> 
 <pre><code class="hljs">// 计算Func2的时间复杂度？
void Func2(int N)
{
    int count = 0;
    for (int k = 0; k &lt; 2 * N ; ++ k)
    {
        ++count;
    }
    int M = 10;
    while (M--)
    {
        ++count;
    }
    printf("%d\n", count);
}</code></pre> 
 <div> 
  <span style="color:#1f2329;"><strong>Func2执⾏的基本操作次数</strong>： </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = 2</span> 
  <span style="color:#1f2329;"><em>N </em></span> 
  <span style="color:#1f2329;">+ 10 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">根据推导规则第3条得出 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">Func2的时间复杂度为： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) </span> 
 </div> 
</div> 
<div></div> 
<h4></h4> 
<div> 
 <h4><span style="color:#1456f0;">3.2.2 </span><span style="color:#1f2329;">⽰例2 </span></h4> 
</div> 
<div> 
 <pre><code class="hljs">// 计算Func3的时间复杂度？
void Func3(int N, int M)
{
    int count = 0;
    for (int k = 0; k &lt; M; ++ k)
    {
        ++count;
    }
    for (int k = 0; k &lt; N ; ++k)
    {
        ++count;
    }
    printf("%d\n", count);
}    </code></pre> 
 <div> 
  <strong><span style="color:#1f2329;">Func3执⾏的基本操作次数： </span></strong> 
 </div> 
 <div> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = </span> 
  <span style="color:#1f2329;"><em>M </em></span> 
  <span style="color:#1f2329;">+ </span> 
  <span style="color:#1f2329;"><em>N </em></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">因此：Func2的时间复杂度为： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) </span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<h4></h4> 
<div> 
 <h4><span style="color:#1456f0;">3.2.3 </span><span style="color:#1f2329;">⽰例3</span></h4> 
</div> 
<div> 
 <pre><code class="hljs">// 计算Func4的时间复杂度？
void Func4(int N)
{
    int count = 0;
    for (int k = 0; k &lt; 100; ++ k)
    {
        ++count;
    }
    printf("%d\n", count);
}</code></pre> 
 <div> 
  <strong><span style="color:#1f2329;">Func4执⾏的基本操作次数： </span></strong> 
 </div> 
</div> 
<div> 
 <div> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = 100 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">根据推导规则第1条得出 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">Func2的时间复杂度为： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(1)</span> 
 </div> 
</div> 
<div></div> 
<h4></h4> 
<div> 
 <h4><span style="color:#1456f0;">3.2.4 </span><span style="color:#1f2329;">⽰例4</span></h4> 
</div> 
<div> 
 <pre><code class="hljs">// 计算strchr的时间复杂度？
const char * strchr ( const char* str, int character)
{
    const char* p_begin = s;
    while (*p_begin != character)
    {
        if (*p_begin == '\0')
        return NULL;
        p_begin++;
    }
    return p_begin;
}</code></pre> 
 <div> 
  <strong><span style="color:#1f2329;">strchr执⾏的基本操作次数： </span></strong> 
 </div> 
 <div> 
  <span style="color:#1f2329;">1）若要查找的字符在字符串第⼀个位置，则： </span> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = 1 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">2）若要查找的字符在字符串最后的⼀个位置， 则： </span> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = </span> 
  <span style="color:#1f2329;"><em>N </em></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">3）若要查找的字符在字符串中间位置，则： </span> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = 2 </span> 
  <span style="color:#1f2329;"><em>N </em></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">因此：<strong>strchr的时间复杂度分为： </strong></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">最好情况： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(1) </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">最坏情况： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">平均情况： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) </span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#1f2329;">💡 </span> 
   <span style="color:#d83931;">总结 </span> 
  </div> 
  <div> 
   <span style="color:#1f2329;">        通过上⾯我们会发现，有些算法的时间复杂度存在最好、平均和最坏情况。 </span> 
  </div> 
  <div> 
   <span style="color:#1f2329;">        最坏情况：任意输⼊规模的最⼤运⾏次数(上界) </span> 
  </div> 
  <div> 
   <span style="color:#1f2329;">        平均情况：任意输⼊规模的期望运⾏次数 </span> 
  </div> 
  <div> 
   <span style="color:#1f2329;">        最好情况：任意输⼊规模的最⼩运⾏次数(下界) </span> 
  </div> 
  <div> 
   <strong><span style="color:#1f2329;">        ⼤O的渐进表⽰法在实际中⼀般情况关注的是算法的上界，也就是最坏运⾏情况。 </span></strong> 
  </div> 
 </blockquote> 
</div> 
<div></div> 
<h4></h4> 
<div> 
 <h4><span style="color:#1456f0;">3.2.5 </span><span style="color:#1f2329;">⽰例5 </span></h4> 
</div> 
<div></div> 
<div> 
 <pre><code class="hljs">// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
    assert(a);
    for (size_t end = n; end &gt; 0; --end)
    {
        int exchange = 0;
        for (size_t i = 1; i &lt; end; ++i)
        {
            if (a[i-1] &gt; a[i])
            {
                Swap(&amp;a[i-1], &amp;a[i]);
                exchange = 1;
            }
        }
        if (exchange == 0)
        break;
    }
}</code></pre> 
 <div> 
  <strong><span style="color:#1f2329;">BubbleSort执⾏的基本操作次数：</span></strong> 
 </div> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#1f2329;">1）若数组有序，则： </span> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = </span> 
  <span style="color:#1f2329;"><em>N </em></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">2）若数组有序且为降序，则： </span> 
  <span style="color:#1f2329;"><em>T </em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) = 2 </span> 
  <span style="color:#1f2329;"><em>N </em></span> 
  <span style="color:#1f2329;">∗ (</span> 
  <span style="color:#1f2329;"><em>N </em></span> 
  <span style="color:#1f2329;">+ 1) </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">3）若要查找的字符在字符串中间位 置，则：因此：BubbleSort的时间复杂度取最差情况为： <em>O</em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">2 </span> 
  <span style="color:#1f2329;">) </span> 
 </div> 
</div> 
<div></div> 
<h4></h4> 
<div> 
 <h4><span style="color:#1456f0;">3.2.6 </span><span style="color:#1f2329;">⽰例6 </span></h4> 
</div> 
<div></div> 
<div> 
 <pre><code class="hljs">void func5(int n)
{
    int cnt = 1;
    while (cnt &lt; n)
    {
        cnt *= 2;
    }
}</code></pre> 
 <div> 
  <span style="color:#1f2329;">当n=2时，执⾏次数为1 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">当n=4时，执⾏次数为2 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">当n=16时，执⾏次数为4 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">假设执⾏次数为 </span> 
  <span style="color:#1f2329;"><em>x </em></span> 
  <span style="color:#1f2329;">，则 </span> 
  <span style="color:#1f2329;">2 </span> 
  <span style="color:#1f2329;"><em>x </em></span> 
  <span style="color:#1f2329;">= </span> 
  <span style="color:#1f2329;"><em>n </em></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">因此执⾏次数： </span> 
  <span style="color:#1f2329;"><em>x </em></span> 
  <span style="color:#1f2329;">= log </span> 
  <span style="color:#1f2329;"><em>n </em></span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">因此：func5的时间复杂度取最差情况为： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(log</span> 
  <span style="color:#1f2329;">2 </span> 
  <span style="color:#1f2329;"><em>n</em></span> 
  <span style="color:#1f2329;">) </span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#646a73;">注意课件中和书籍中 </span> 
  <span style="color:#1f2329;">log</span> 
  <span style="color:#1f2329;">2 </span> 
  <span style="color:#1f2329;"><em>n </em></span> 
  <span style="color:#646a73;">、 </span> 
  <span style="color:#1f2329;">log </span> 
  <span style="color:#1f2329;"><em>n </em></span> 
  <span style="color:#646a73;">、 </span> 
  <span style="color:#1f2329;">lg </span> 
  <span style="color:#1f2329;"><em>n </em></span> 
  <span style="color:#646a73;">的表⽰ </span> 
 </div> 
 <div> 
  <span style="color:#646a73;">当n接近⽆穷⼤时，底数的⼤⼩对结果影响不⼤。因此，⼀般情况下不管底数是多少都可以省略不 </span> 
 </div> 
 <div> 
  <span style="color:#646a73;">写，即可以表⽰为 </span> 
  <span style="color:#1f2329;">log </span> 
  <span style="color:#1f2329;"><em>n </em></span> 
 </div> 
 <div> 
  <span style="color:#646a73;">不同书籍的表⽰⽅式不同，以上写法差别不⼤，我们建议使⽤ </span> 
  <span style="color:#1f2329;">log </span> 
  <span style="color:#1f2329;"><em>n</em></span> 
 </div> 
</div> 
<div></div> 
<h4></h4> 
<div> 
 <h4><span style="color:#1456f0;">3.2.7 </span><span style="color:#1f2329;">⽰例7 </span></h4> 
</div> 
<div> 
 <pre><code class="hljs">// 计算阶乘递归Fac的时间复杂度？
long long Fac(size_t N)
{
    if(0 == N)
        return 1;
    return Fac(N-1)*N;
}</code></pre> 
 <div> 
  <span style="color:#1f2329;">调⽤⼀次Fac函数的时间复杂度为 </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(1) </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">⽽在Fac函数中，存在n次递归调⽤Fac函数 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">因此：阶乘递归的时间复杂度为： </span> 
  <span style="color:#1f2329;"><em>O</em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>n</em></span> 
  <span style="color:#1f2329;">)</span> 
 </div> 
</div> 
<div></div> 
<h4></h4> 
<h4></h4> 
<div> 
 <h2><span style="color:#1456f0;">4. </span><span style="color:#1f2329;">空间复杂度 </span></h2> 
</div> 
<div> 
 <div> 
  <span style="color:#1f2329;">空间复杂度也是⼀个数学表达式，是对⼀个算法在运⾏过程中因为算法的需要额外临时开辟的空间。 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">空间复杂度不是程序占⽤了多少bytes的空间，因为常规情况每个对象⼤⼩差异不会很⼤，所以空间复杂度算的是变量的个数。 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">空间复杂度计算规则基本跟实践复杂度类似，也使⽤<strong>⼤O渐进表⽰法</strong>。 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">注意：<strong>函数运⾏时所需要的栈空间(存储参数、局部变量、⼀些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运⾏时候显式申请的额外空间来确定</strong></span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<h4></h4> 
<div> 
 <h3><span style="color:#1456f0;">4.1 </span><span style="color:#1f2329;">空间复杂度计算⽰例</span></h3> 
</div> 
<h4></h4> 
<div> 
 <h4><span style="color:#1456f0;">4.1.1 </span><span style="color:#1f2329;">⽰例1 </span></h4> 
</div> 
<div> 
 <pre><code class="hljs">// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
    assert(a);
    for (size_t end = n; end &gt; 0; --end)
    {
        int exchange = 0;
        for (size_t i = 1; i &lt; end; ++i)
        {
            if (a[i-1] &gt; a[i])
            {
                Swap(&amp;a[i-1], &amp;a[i]);
                exchange = 1;
            }
        }
        if (exchange == 0)
        break;
    }
}</code></pre> 
 <div> 
  <span style="color:#1f2329;">函数栈帧在编译期间已经确定好了，只需要关注函数在运⾏时额外申请的 空间。BubbleSort额外申请的空间有 exchange等有限个局部变量，使⽤了常数个额外空间 因此空间复杂度为 <em>O</em></span> 
  <span style="color:#1f2329;">(1)</span> 
 </div> 
</div> 
<div></div> 
<h4></h4> 
<p></p> 
<div> 
 <h4><span style="color:#1456f0;">4.1.2 </span><span style="color:#1f2329;">⽰例2 </span></h4> 
 <pre><code class="hljs">// 计算阶乘递归Fac的空间复杂度？
long long Fac(size_t N)
{
    if(N == 0)
        return 1;
    return Fac(N-1)*N;
}</code></pre> 
 <div> 
  <span style="color:#1f2329;">Fac递归调⽤了N次，额外开辟了N个函数栈帧，每个栈帧使⽤了常数个空间</span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">因此空间复杂度为： <em>O</em></span> 
  <span style="color:#1f2329;">(</span> 
  <span style="color:#1f2329;"><em>N</em></span> 
  <span style="color:#1f2329;">) </span> 
 </div> 
 <p></p> 
 <h4></h4> 
 <h2><span style="color:#1456f0;">5. </span><span style="color:#1f2329;">常⻅复杂度对⽐ </span></h2> 
 <p><img alt="" height="295" src="https://images2.imgbox.com/39/bd/33Q4f55T_o.png" width="681"></p> 
 <p></p> 
 <p><img alt="" height="386" src="https://images2.imgbox.com/4d/3c/yftEYIc9_o.png" width="682"></p> 
 <p></p> 
 <p></p> 
 <hr> 
 <p>完</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5657d88551a3b090dbb076f67dddc7b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">38-PCB布局实战实战及优化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf4c77c52434c1a8be6b298ed8b19bd8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SSM基于web的火车订票系统设计s5088 座位预定</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>