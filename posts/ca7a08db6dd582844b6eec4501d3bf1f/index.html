<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻松拿捏C语言——自定义类型之【结构体】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ca7a08db6dd582844b6eec4501d3bf1f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="轻松拿捏C语言——自定义类型之【结构体】">
  <meta property="og:description" content="🥰欢迎关注 轻松拿捏C语言系列，来和 小哇 一起进步！✊
🎉创作不易，请多多支持🎉
🌈感谢大家的阅读、点赞、收藏和关注💕
🌹如有问题，欢迎指正
目录
1. 结构体类型的声明🌙
2. 结构体变量的创建和初始化🌙
3. 结构体内存对齐🌙
4. 结构体传参🌙
5. 结构体实现位段🌙
1. 结构体类型的声明🌙 结构体是一些值的集合
这些值叫做 成员或 分量或 域或 项。
结构的每个成员变量可以是不同的类型
例如描述一个学生：
struct Stu { char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[20];//学号 }; //分号不能丢 这是结构体的声明
struct 是结构体关键字，struct Stu 是这个结构体类型名 2. 结构体变量的创建和初始化🌙 #include &lt;stdio.h&gt; struct Stu { char name[20];//名字 int age;//年龄 char sex[5];//性别 char id[20];//学号 }; int main() { //按照结构体成员的顺序初始化 struct Stu s = { &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T16:27:12+08:00">
    <meta property="article:modified_time" content="2024-06-04T16:27:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻松拿捏C语言——自定义类型之【结构体】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p> <img alt="" src="https://images2.imgbox.com/18/93/4Ri1euq5_o.gif"></p> 
 <p><img alt="" height="313" src="https://images2.imgbox.com/0c/2a/AMqEsTjF_o.gif" width="1200"></p> 
 <p><strong>🥰<span style="color:#4da8ee;">欢迎关注 </span><strong><strong><strong><span style="color:#4da8ee;"><a href="https://blog.csdn.net/kiku20231213/category_12648019.html?spm=1001.2014.3001.5482" title="轻松拿捏C语言系列">轻松拿捏C语言系列</a></span></strong></strong></strong><span style="color:#4da8ee;">，来和 小哇 一起进步！</span>✊</strong></p> 
 <p><strong>🎉<span style="color:#956fe7;">创作不易，请多多支持</span>🎉</strong></p> 
 <p><strong>🌈<span style="color:#98c091;">感谢大家的阅读、点赞、收藏和关注</span>💕</strong></p> 
 <p><strong>🌹<span style="color:#b95514;">如有问题，欢迎指正</span></strong></p> 
</blockquote> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E-toc" style="margin-left:0px;"><a href="#1.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E" rel="nofollow">1. 结构体类型的声明🌙</a></p> 
<p id="2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">2. 结构体变量的创建和初始化🌙</a></p> 
<p id="3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-toc" style="margin-left:0px;"><a href="#3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90" rel="nofollow">3. 结构体内存对齐🌙</a></p> 
<p id="4.%20%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82-toc" style="margin-left:0px;"><a href="#4.%20%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82" rel="nofollow">4. 结构体传参🌙</a></p> 
<p id="5.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BD%8D%E6%AE%B5-toc" style="margin-left:0px;"><a href="#5.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BD%8D%E6%AE%B5" rel="nofollow">5. 结构体实现位段🌙</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="1.%20%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span style="color:#38d8f0;"><span style="background-color:#fefcd8;">1. 结构体类型的声明</span></span><strong>🌙</strong></h2> 
<p>结构体是一些值的集合</p> 
<p>这些值叫做 <strong>成员</strong>或 <strong>分量</strong>或 <strong>域</strong>或<strong> 项</strong>。</p> 
<p>结构的每个成员变量可以是不同的类型</p> 
<p>例如描述一个学生：</p> 
<pre><code class="language-cpp">struct Stu
{
 char name[20];//名字
 int age;//年龄
 char sex[5];//性别
 char id[20];//学号
}; //分号不能丢</code></pre> 
<p>这是结构体的声明</p> 
<p>struct 是结构体关键字，struct Stu 是这个结构体类型名 </p> 
<h2 id="2.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span style="color:#956fe7;"><span style="background-color:#fff5e6;">2. 结构体变量的创建和初始化</span></span><strong>🌙</strong></h2> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
struct Stu
{
 char name[20];//名字
 int age;//年龄
 char sex[5];//性别
 char id[20];//学号
};
int main()
{
 //按照结构体成员的顺序初始化
 struct Stu s = { "张三", 20, "男", "20230818001" };
 printf("name: %s\n", s.name);
 printf("age : %d\n", s.age);
 printf("sex : %s\n", s.sex);
 printf("id : %s\n", s.id);
 
 //按照指定的顺序初始化
 struct Stu s2 = { .age = 18, .name = "lisi", .id = "20230818002", .sex = 
"⼥" };
 printf("name: %s\n", s2.name);
 printf("age : %d\n", s2.age);
 printf("sex : %s\n", s2.sex);
 printf("id : %s\n", s2.id);
 return 0;
}
</code></pre> 
<p>在进行结构体声明时，也可以进行不完全声明：</p> 
<pre><code class="language-cpp">//匿名结构体类型
struct
{
 int a;
 char b;
 float c;
}x;

struct
{
 int a;
 char b;
 float c;
}a[20], *p;</code></pre> 
<p>上⾯的两个结构在声明的时候省略掉了结构体标签</p> 
<p><span style="background-color:#fefcd8;">上⾯的两个声明是完全不同的两个类型。</span></p> 
<p><span style="background-color:#fefcd8;">匿名的结构体类型，如果没有对结构体类型重命名的话，基本上只能使⽤⼀次 。</span></p> 
<p></p> 
<p>在结构中包含⼀个类型为该结构本⾝的成员是不可以的</p> 
<p>例如 ：</p> 
<pre><code class="language-cpp">struct Node
{
 int data;
 struct Node next;
};
</code></pre> 
<p>这是错误的用法。</p> 
<p>因为⼀个结构体中再包含⼀个同类型的结构体变量，这样结构体变量的大小就会⽆穷的⼤，是不合理的 </p> 
<p>正确自引用方式：</p> 
<pre><code class="language-cpp">struct NOde
{
 int data;
 struct Node* next;//定义一个结构体类型指针
};</code></pre> 
<p>在结构体自引用使用的过程中，夹杂了 typedef 对匿名结构体类型重命名，也容易引入问题，比如：</p> 
<pre><code class="language-cpp">typedef struct
{
 int data;
 Node* next;
}Node;
</code></pre> 
<p> 这是错误用法，因为Node是对前面的匿名结构体类型的重命名产⽣的，但是在匿名结构体内部提前使用Node类型来创建成员变量，这是不行的</p> 
<p>所以<strong>定义结构体不要使用匿名结构体了</strong></p> 
<pre><code class="language-cpp">typedef struct Node
{
 int data;
 struct Node* next;
}Node;</code></pre> 
<h2 id="3.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span style="color:#956fe7;"><span style="background-color:#fff5e6;">3. 结构体内存对齐</span></span><strong>🌙</strong></h2> 
<p><span style="color:#956fe7;"><span style="background-color:#fff5e6;">结构体成员在内存中存在对齐现象</span></span></p> 
<p>内存对齐的原因：</p> 
<p>        1、平台原因（移植原因）：</p> 
<p>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p> 
<p>        2、性能原因：</p> 
<p>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要⼀次访问。</p> 
<p><strong>所以结构体的内存对齐是拿空间来换取时间的做法，提高程序运行效率，节省空间</strong></p> 
<p><strong>对齐规则：</strong></p> 
<p>        1. 结构体的第⼀个成员对齐到和结构体变量起始位置偏移量为0的地址处</p> 
<p>        2. 其他成员变量的首地址与结构体首地址的偏移量要为 该成员对齐数的整数倍</p> 
<p>               <strong> 对齐数 = 编译器默认的⼀个对齐数 与 该成员变量大小的较小值</strong></p> 
<p><strong>                VS 中默认的值为 8 ， Linux中 gcc 没有默认对齐数，对齐数就是成员自身的大小</strong></p> 
<p><strong>        </strong>3、结构体总大小为最大对齐数（结构体中每个成员变量都有⼀个对齐数，所有对齐数中最大的）的 整数倍</p> 
<p>        4、 如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍。</p> 
<p>如果我们把让占用空间小的成员尽量集中在⼀起，更节省空间，比如：</p> 
<pre><code class="language-cpp">struct S1
{
 char c1;
 int i;
 char c2;
};
struct S2
{
 char c1;
 char c2;
 int i;
};
</code></pre> 
<p>S1中结构体大小为 12字节，S2结构体大小为8，因为S2中两个char类型的变量放在了一起（放在int类型的前后都一样，都是8）.</p> 
<p>我们可以使用<strong>#pragma </strong>这个预处理指令，可以<strong>改变编译器的默认对齐数</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#pragma pack(1)//设置默认对⻬数为1
struct S
{
 char c1;
 int i;
 char c2;
};
int main()
{
 printf("%d\n", sizeof(struct S));
 return 0;
}</code></pre> 
<p>这里结果为6，因为默认对齐系数改为了1，所以是1+4+1 </p> 
<p>可以用<strong>#pragma pack()//取消设置的对齐数，还原为默认</strong></p> 
<h2 id="4.%20%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82"><strong><span style="color:#38d8f0;"><span style="background-color:#fefcd8;">4. 结构体传参</span></span>🌙</strong></h2> 
<p><strong>结构体传参的时候，要传结构体的地址</strong></p> 
<pre><code class="language-cpp">struct S
{
 int data[1000];
 int num;
};
struct S s = {<!-- -->{1,2,3,4}, 1000};
//结构体传参
void print1(struct S s)
{
 printf("%d\n", s.num);
}
//结构体地址传参
void print2(struct S* ps)
{
 printf("%d\n", ps-&gt;num);
}
int main()
{
 print1(s); //传结构体
 print2(&amp;s); //传地址
 return 0;
}</code></pre> 
<p>print1和print2这两个函数中，print2函数更好，</p> 
<p>因为<span style="background-color:#edf6e8;">函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。</span></p> 
<p><span style="background-color:#edf6e8;">如果传递⼀个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。 </span></p> 
<h2 id="5.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%BD%8D%E6%AE%B5"><span style="color:#956fe7;"><span style="background-color:#fff5e6;">5. 结构体实现位段</span></span><strong>🌙</strong></h2> 
<p>位段的声明和结构是类似的，有两个不同：</p> 
<p>1. 位段的成员必须是 int、unsigned int 或signed int 或者是 char 等类型，在C99中位段成员的类型也可以选择其他类型。（一般就是int家族）</p> 
<p>2. 位段的成员名后边有⼀个冒号和⼀个数字。</p> 
<p>例如：</p> 
<pre><code class="language-cpp">struct A
{
 int _a:2;
 int _b:5;
 int _c:10;
 int _d:30;
};
</code></pre> 
<p> 这里位段A所占内存大小为8字节</p> 
<p><strong>位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的</strong></p> 
<p><strong>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段</strong></p> 
<p>跟结构体相比，位段可以达到同样的效果，并且可以很好的节省空间，但是有跨平台的问题存在：</p> 
<p>        1. int 位段被当成有符号数还是无符号数是不确定的。</p> 
<p>         2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。</p> 
<p>        3. 位段中的成员在内存中从左向右分配，还是从右向左分配，标准尚未定义。</p> 
<p>         4. 当⼀个结构包含两个位段，第⼆个位段成员比较大，无法容纳于第⼀个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。</p> 
<p>位段的几个成员共有同⼀个字节，这样有些成员的起始位置并不是某个字节的起始位置，那么这些位 置处是没有地址的。</p> 
<p>内存中每个字节分配⼀个地址，⼀个字节内部的bit位是没有地址的。</p> 
<p>所以不能对位段的成员使用&amp;操作符，这样就不能使用scanf直接给位段的成员输入值，只能是先输入放在⼀个变量中，然后赋值给位段的成员。</p> 
<p>例如：</p> 
<pre><code class="language-cpp">struct A
{int _a : 2;
 int _b : 5;
 int _c : 10;
 int _d : 30;
};
int main()
{
 struct A sa = {0};
 scanf("%d", &amp;sa._b);//这是错误的
 
 //正确的⽰范
 int b = 0;
 scanf("%d", &amp;b);
 sa._b = b;
 return 0;
}</code></pre> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" height="283" src="https://images2.imgbox.com/fd/7c/0qPd39Dz_o.gif" width="283"></p> 
 <p><strong> 🎉🎉🎉<span style="color:#956fe7;">本文内容结束啦，希望各位大佬多多指教！</span></strong></p> 
 <p><strong>🌹🌹<span style="color:#38d8f0;">感谢大家三连支持</span></strong></p> 
 <p><strong>💕<span style="color:#ed7976;">敬请期待下篇~💥</span></strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/587ae0998f856af0b6cdbc86e77c98c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">中学生学人工智能系列：如何用AI学数学</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/176d986c819453afe273dd515e0f54be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">交叉口的车道饱和流量计算（python）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>