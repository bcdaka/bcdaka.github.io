<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL：表的设计原则和聚合函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8df5902433952d899a1d4ccaf0f45041/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MySQL：表的设计原则和聚合函数">
  <meta property="og:description" content="所属专栏：MySQL学习
💎1. 表的设计原则 1. 从需求中找到类，类对应到数据库中的实体，实体在数据库中表现为一张一张的表，类中的属性对应着表中的字段
2. 确定类与类的对应关系
3. 使用SQL去创建具体的表
范式：范式描述的是数据关系的模型（一对一关系，一对多关系，多对多关系）
分类：第一范式（1NF），第二范式（2NF），第三范式(3NF)，BC范式（BCNF）
💎2. 三大范式 💎2.1 第一范式 规定：表中的数据不能再分，在定义表的时候，对照数据中的数据类型，每一个字段都可以用一个数据类型标识，那么当前这个表就满足第一范式
例如：定义一个学生表，其中的字段有：学号，姓名，年龄，班级名，学校名，学校地址，这就符合了第一范式，但是如果是：学号，姓名，年龄，班级名，学校，这就不符合第一范式，因为无法找到一个数据类型来表示学校这个对象
关系型数据库的一个最基本的要求，不满足第一范式就不能称为关系型数据库
💎2.2 第二范式 在满足第一范式的基础上，不存在非关键字段（非主键字段）对任意候选键（主键，外键，没有主键时的唯一键）的部分函数依赖（存在与复合主键的情况下），就满足第二范式，复合主键在上一篇文章中已经介绍过，一个表中不能有两个主键，但是一个主键中可以包含多个列，这时的主键就是复合主键
也就是说，如果这个表不含复合主键，那么这个表就满足第二范式
先来看一个表中存在复合主键的情况下，存在非关键字段对候选键的部分函数依赖的不符合第二范式的反例：
学生选修课成绩表 学号姓名年龄课程名称学分成绩202201张三19MySQL3100 其中，年龄和姓名依赖学号（对应唯一学号），学分依赖课程名称，成绩通过学生和课程共同区分，也就是这个表中可以用学生和课程作为复合主键来确定学生当前的课程成绩，对与其他的，学分和学号，学生姓名等没有关系，学生的姓名和课程名等也没有关系
像这样的，对于由两个或多个关键字段共同决定一条记录（存在复合主键）的情况，如果一行数据中有些字段只与关键字段中的一个有关系，那么就称为只存在部分函数依赖，对于这样的情况就不满足第二范式
接下来看一个正面例子：
对于这样的设计，每张表都有非主键字段，都强依赖与主键，第三个表存在的复合主键，非主键依赖于两个主键的字段，不存在部分函数依赖，满足第二范式
不符合第二范式的时候的弊端：
学生选修课成绩表 学号姓名年龄课程名称学分成绩202201张三19MySQL3100202202李四19MySQL3100202203王五20Java2 95
202204赵六19Java296 1. 数据冗余
学生的年龄和学分大量出现，造成数据冗余
2. 更新异常
如果需要修改MySQL的学分，那么就需要修改表中所有关于MySQL的记录，如果说只有部分数据修改成功，剩余的还是原来的数据，就会出现数据不一致，造成数据混乱
3. 插入异常
当前表格在有学生录入成绩后才能查看课程的学分信息，例如：如果说这时学校加入一门新课，但学生都没有考过试，那么这门新课在数据库就就没有记录
4. 删除异常
同插入异常一样，如果需要删除学生成绩，例如，把选Java的两位同学成绩删除，那么此时在数据库中就又没有Java这门课程的学分信息了
💎2.3 第三范式 在第二范式的基础上，不存在非关键字段对任意候选键的传递依赖
学生表 学号姓名年龄所在学院学院地址 在这个表中，描述的主要对象是学生，所以学号可以作为主键，此时，姓名和年龄与学号是强相关的，学院地址与所在学院是强相关的，描述学生所在学院，只需要把学生和学院建立一个关联关系即可，这两个强相关关系存在传递现象 学号-&gt;所在学院-&gt;学院地址 ，这种传递关系就称为传递依赖，所以说这种设计不满足第三范式
根据学生与学院的关系，拆分为两张表就满足了第三范式：
学院表 学院编号学院名称学院地址 学生表 学号姓名年龄学院编号 这样设计，两张表都依赖与自己表中的主键，学生表可以通过外键与学院之间建立关联关系 💎3. 三种关系 💎3.1 一对一关系 例如设计一个登录界面，输入用户名和密码登录成功之后，显示欢迎用户，这样的场景一般对应两个实体，用户和账号，并且一个用户只对应一个账号，就是一对一的关系
针对一对一关系设计表时有两种方式
第一种就是把两个实体所有的信息放在一张表中
use_idnamephone_numberusernamepassword 第二种就是设计两张表，分别记录用户信息和账号信息，再把两张表关联起来">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T20:17:38+08:00">
    <meta property="article:modified_time" content="2024-08-11T20:17:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL：表的设计原则和聚合函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/60/7e/rhE6CygK_o.gif" width="755"></p> 
</blockquote> 
<p style="text-align:center;"> <strong><span style="color:#38d8f0;">所属专栏：<a class="link-info" href="https://blog.csdn.net/2202_76097976/category_12751130.html?spm=1001.2014.3001.5482" title="MySQL学习">MySQL学习</a></span></strong></p> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/4f/43/xw1Is86z_o.gif"></p> 
<p> </p> 
<h2 style="background-color:transparent;">💎<span style="color:#38d8f0;">1. 表的设计原则</span></h2> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>1. 从需求中找到类，类对应到数据库中的实体，实体在数据库中表现为一张一张的表，类中的属性对应着表中的字段</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>2. 确定类与类的对应关系</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>3. 使用SQL去创建具体的表</strong></span></p> 
</blockquote> 
<p>范式：范式描述的是数据关系的模型（一对一关系，一对多关系，多对多关系）</p> 
<p>分类：第一范式（1NF），第二范式（2NF），第三范式(3NF)，BC范式（BCNF）</p> 
<h2 style="background-color:transparent;"><span style="color:#38d8f0;">💎2. 三大范式</span></h2> 
<h3><br><span style="color:#38d8f0;">💎2.1 第一范式</span></h3> 
<p><strong><span style="color:#956fe7;">规定：表中的数据不能再分，在定义表的时候，对照数据中的数据类型，每一个字段都可以用一个数据类型标识，那么当前这个表就满足第一范式</span></strong></p> 
<p>例如：定义一个学生表，其中的字段有：学号，姓名，年龄，班级名，学校名，学校地址，这就符合了第一范式，但是如果是：学号，姓名，年龄，班级名，学校，这就不符合第一范式，因为无法找到一个数据类型来表示学校这个对象</p> 
<p><strong><span style="color:#fe2c24;">关系型数据库的一个最基本的要求，不满足第一范式就不能称为关系型数据库</span></strong></p> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;">💎2.2 第二范式</span></h3> 
<p><span style="color:#fe2c24;"><strong>在满足第一范式的基础上，不存在非关键字段（非主键字段）对任意候选键（主键，外键，没有主键时的唯一键）的部分函数依赖<span style="background-color:#ffd900;">（存在与复合主键的情况下）</span>，就满足第二范式，复合主键在上一篇文章中已经介绍过，一个表中不能有两个主键，但是一个主键中可以包含多个列，这时的主键就是复合主键</strong></span></p> 
<p><span style="color:#956fe7;"><strong>也就是说，如果这个表不含复合主键，那么这个表就满足第二范式</strong></span></p> 
<p> 先来看一个表中存在复合主键的情况下，存在非关键字段对候选键的部分函数依赖的不符合第二范式的反例：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学生选修课成绩表 
 </caption><tbody><tr><td>学号</td><td>姓名</td><td>年龄</td><td>课程名称</td><td>学分</td><td>成绩</td></tr><tr><td>202201</td><td>张三</td><td>19</td><td>MySQL</td><td>3</td><td>100</td></tr></tbody></table> 
<p></p> 
<p><strong><span style="color:#38d8f0;">其中，年龄和姓名依赖学号（对应唯一学号），学分依赖课程名称，成绩通过学生和课程共同区分，也就是这个表中可以用学生和课程作为复合主键来确定学生当前的课程成绩，对与其他的，学分和学号，学生姓名等没有关系，学生的姓名和课程名等也没有关系</span></strong></p> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>像这样的，对于由两个或多个关键字段共同决定一条记录（存在复合主键）的情况，如果一行数据中有些字段只与关键字段中的一个有关系，那么就称为只存在部分函数依赖，对于这样的情况就不满足第二范式</strong></span></p> 
</blockquote> 
<p>接下来看一个正面例子：</p> 
<p class="img-center"><img alt="" height="214" src="https://images2.imgbox.com/27/e6/us26xnLx_o.png" width="619"></p> 
<p> 对于这样的设计，每张表都有非主键字段，都强依赖与主键，第三个表存在的复合主键，非主键依赖于两个主键的字段，不存在部分函数依赖，满足第二范式</p> 
<p><span style="color:#fe2c24;"><strong> 不符合第二范式的时候的弊端：</strong></span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学生选修课成绩表 
 </caption><tbody><tr><td>学号</td><td>姓名</td><td>年龄</td><td>课程名称</td><td>学分</td><td>成绩</td></tr><tr><td>202201</td><td>张三</td><td>19</td><td>MySQL</td><td>3</td><td>100</td></tr><tr><td>202202</td><td>李四</td><td>19</td><td>MySQL</td><td>3</td><td>100</td></tr><tr><td>202203</td><td>王五</td><td>20</td><td>Java</td><td>2</td><td> <p>95</p> </td></tr><tr><td>202204</td><td>赵六</td><td>19</td><td>Java</td><td>2</td><td>96</td></tr></tbody></table> 
<p><strong><span style="color:#fe2c24;">1. 数据冗余</span></strong></p> 
<p><span style="color:#0d0016;">学生的年龄和学分大量出现，造成数据冗余</span></p> 
<p><strong><span style="color:#fe2c24;">2. 更新异常</span></strong></p> 
<p>如果需要修改MySQL的学分，那么就需要修改表中所有关于MySQL的记录，如果说只有部分数据修改成功，剩余的还是原来的数据，就会出现数据不一致，造成数据混乱</p> 
<p><span style="color:#fe2c24;"><strong>3. 插入异常</strong></span></p> 
<p>当前表格在有学生录入成绩后才能查看课程的学分信息，例如：如果说这时学校加入一门新课，但学生都没有考过试，那么这门新课在数据库就就没有记录</p> 
<p><span style="color:#fe2c24;"><strong>4. 删除异常</strong></span></p> 
<p>同插入异常一样，如果需要删除学生成绩，例如，把选Java的两位同学成绩删除，那么此时在数据库中就又没有Java这门课程的学分信息了</p> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;">💎2.3 第三范式</span></h3> 
<p>在第二范式的基础上，不存在非关键字段对任意候选键的<span style="background-color:#ffd900;">传递依赖</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学生表 
 </caption><tbody><tr><td>学号</td><td>姓名</td><td>年龄</td><td>所在学院</td><td>学院地址</td></tr></tbody></table> 
<blockquote> 
 <p>在这个表中，描述的主要对象是学生，所以学号可以作为主键，此时，姓名和年龄与学号是强相关的，学院地址与所在学院是强相关的，描述学生所在学院，只需要把学生和学院建立一个关联关系即可，这两个强相关关系存在传递现象 <span style="background-color:#ffd900;">学号-&gt;所在学院-&gt;学院地址</span> ，这种传递关系就称为传递依赖，所以说这种设计不满足第三范式</p> 
</blockquote> 
<p>根据学生与学院的关系，拆分为两张表就满足了第三范式：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学院表 
 </caption><tbody><tr><td>学院编号</td><td>学院名称</td><td>学院地址</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学生表 
 </caption><tbody><tr><td>学号</td><td>姓名</td><td>年龄</td><td>学院编号</td></tr></tbody></table> 
<p>这样设计，两张表都依赖与自己表中的主键，学生表可以通过外键与学院之间建立关联关系 </p> 
<h2 style="background-color:transparent;"><span style="color:#38d8f0;">💎3. 三种关系 </span></h2> 
<h3><span style="color:#38d8f0;"> 💎3.1 一对一关系</span></h3> 
<p>例如设计一个登录界面，输入用户名和密码登录成功之后，显示欢迎用户，这样的场景一般对应两个实体，用户和账号，并且一个用户只对应一个账号，就是一对一的关系</p> 
<p>针对一对一关系设计表时有两种方式</p> 
<p>第一种就是把两个实体所有的信息放在一张表中</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>use_id</td><td>name</td><td>phone_number</td><td>username</td><td>password</td></tr></tbody></table> 
<p>第二种就是设计两张表，分别记录用户信息和账号信息，再把两张表关联起来</p> 
<p>1.第一种关联方式就是通过用户id进行关联，场景：当输入用户名和密码并校验成功之后，再通过用户id去查找用户的name</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>user_id</td><td>name</td><td>phone_number</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>account_id</td><td>username</td><td>password</td><td>user_id</td></tr></tbody></table> 
<p> 2.第二种关联方式通过account_id进行关联</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>account_id</td><td>username</td><td>password</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>user_id</td><td>name</td><td>phone_number</td><td>account_id</td></tr></tbody></table> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;">💎3.2 一对多关系 </span></h3> 
<p>一对多关系其实很常见，例如学生和班级的关系：一个班级中可以有多个学生</p> 
<p>创建学生和班级表：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   班级表 
 </caption><tbody><tr><td>class_id</td><td>name</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学生表 
 </caption><tbody><tr><td>student_id</td><td>name</td><td>class_id</td></tr></tbody></table> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;">💎 3.3 多对多关系 </span></h3> 
<p>例如学生进行选课，一个学生可以选多门课，一门课可以被多名学生选择</p> 
<p>分别创建实体表：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   课程表 
 </caption><tbody><tr><td style="width:242px;">course_id</td><td style="width:257px;">name</td></tr><tr><td style="width:242px;">1</td><td style="width:257px;"> <p>MySQL</p> </td></tr><tr><td style="width:242px;">2</td><td style="width:257px;">Java</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学生表 
 </caption><tbody><tr><td>student_id</td><td>name</td><td>age</td></tr><tr><td>202201</td><td>张三</td><td>19</td></tr><tr><td>202202</td><td>李四</td><td>20</td></tr></tbody></table> 
<p> 创建关系表</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   学生选修课程表 
 </caption><tbody><tr><td>id</td><td>student_id</td><td>course_id</td></tr><tr><td>1</td><td>202201</td><td>1</td></tr><tr><td>2</td><td>202202</td><td>1</td></tr><tr><td>3</td><td>202202</td><td>2</td></tr></tbody></table> 
<p>通过关系表，就可以记录每位同学选择的课程，并且符合第二范式，修改学生的年龄字段时也不会影响到关系表</p> 
<p>最后把之前讲到的综合起来创建一张成绩表</p> 
<pre><code class="language-sql">-- 班级表
create table class
(
    class_id bigint primary key auto_increment,
    name     varchar(20) not null
);

-- 学生表
create table student
(
    student_id bigint primary key auto_increment,
    name       varchar(20) not null,
    age        bigint,
    class_id   bigint,
    -- 设置class_id为class表class_id的外键
    foreign key (class_id) references class (class_id)
);

-- 课程表
create table course
(
    course_id bigint primary key auto_increment,
    name      varchar(50) not null
);
-- 成绩表
create table score
(
    score_id   bigint primary key auto_increment,
    student_id bigint,
    course_id  bigint,
    score      decimal(5, 2),
    -- 设置student_id为student表student_id的外键
    foreign key (student_id) references student (student_id),
    -- 设置course_id为course表course_id的外键
    foreign key (course_id) references course (course_id)
);</code></pre> 
<h2 style="background-color:transparent;"><span style="color:#38d8f0;">💎4. 新增</span></h2> 
<p>需求：创建一个新表，把原来的表的数据内容复制到新表中</p> 
<blockquote> 
 <p>我们有以下几种解决方法：</p> 
 <p>1. 一条一条的插入，很明显，这种方法很麻烦，如果数据量很大就不好操作</p> 
 <p>2. 把原来的数据导出来，再把表名修改一下，再改入到目录表中</p> 
 <p>3. 使用<span style="background-color:#ffd900;"> insert into select</span> 语句</p> 
</blockquote> 
<p>第二个方法就是在 navicat 中直接进行表的复制</p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/51/37/xC48eIHP_o.png" width="563"></p> 
<p>下面来看使用 insert into select 语句的方法</p> 
<pre><code class="language-sql">-- 新建一张表，把旧表导入到新表中
create table new_student
(
    id   bigint primary key auto_increment,
    name varchar(50)
);
-- 把在原来的表中查到的数据插入到新的表中
insert into new_student
select id, name
from student;</code></pre> 
<p>需要注意的就是，查询到的列和要插入的列要匹配，不然就会报错</p> 
<h2 style="background-color:transparent;"><span style="color:#38d8f0;">💎5. 聚合函数</span></h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>函数</td><td>说明</td></tr><tr><td>COUNT([DISTINCT] expr)  </td><td>返回查询到的数据的数量</td></tr><tr><td>SUM([DISTINCT] expr)</td><td>返回查询到的数据的总和</td></tr><tr><td>AVG([DISTINCT] expr)</td><td>返回查询到的数据的平均值</td></tr><tr><td>MAX([DISTINCT] expr)</td><td>返回查询到的数据的最大值</td></tr><tr><td>MIN([DISTINCT] expr)</td><td>返回查询到的数据的最小值</td></tr></tbody></table> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;">💎5.1 COUNT() 统计所有行</span></h3> 
<pre><code class="language-sql">-- 统计表中的行数
select count(*)
from student;
-- 也可以传入常量 1
select count(1)
from student;</code></pre> 
<p><span style="color:#956fe7;"><strong>星号（*）并不直接表示表中的任意一列，而是作为一个特殊的指示符，告诉数据库管理系统（DBMS）计算表中的行数，而不关心表中的列内容或是否有NULL值。</strong></span></p> 
<p>还可以指定某一列进行统计：</p> 
<pre><code class="language-sql">-- 指定列统计
select count(id)
from student;

select count(name)
from student;</code></pre> 
<p><img alt="" height="312" src="https://images2.imgbox.com/e5/4c/BkME6djX_o.png" width="932"></p> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;">💎5.2 SUM() 求和 </span></h3> 
<p>创建一张成绩表，计算语文的总成绩</p> 
<pre><code class="language-sql">create table exam
(
    id      bigint primary key auto_increment,
    name    varchar(20),
    chinese decimal(5, 2),
    math    decimal(5, 2)
);
insert into exam(id, name, chinese, math)
values (1, '张三', 98, 95),
       (2, '李四', 97, 99),
       (3, '王五', 96, 98),
       (4, '赵六', 97, 94);
-- 计算语文总成绩
select *
from exam;
select sum(chinese)
from exam;</code></pre> 
<p> </p> 
<p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/b3/33/ZUXoyea7_o.png" width="920"></p> 
<p> 查询到的结果存储在了临时表中，不受字段中长度的约束（<strong><span style="background-color:#ffd900;">decimal(5, 2)</span></strong>）</p> 
<p>如果说求和的那一列存在null的话，会是像之前表达式相加时，null加上任何值都是null的情况吗？</p> 
<pre><code class="language-sql">insert into exam values (5,'钱七',96,null);

select sum(math)
from exam;</code></pre> 
<p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/a7/c9/siHei2CJ_o.png" width="808"></p> 
<p>可以看出，最终的值并没有加上null ，并且，如果是非数值类型求和是没有意义的</p> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;">💎5.3 AVG() 求平均值</span></h3> 
<pre><code class="language-sql">-- 求平均值
select avg(math)
from exam;

-- 参数里边可以包含表达式，结果可以使用别名
select avg(math + chinese) as 总分平均值
from exam;</code></pre> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/1f/f5/3oCMFuYB_o.png" width="300"></p> 
<h3 style="background-color:transparent;"><span style="color:#38d8f0;"><strong>💎5.4 MAX()和MIN()</strong></span></h3> 
<p>求指定列中的最大值和最小值</p> 
<pre><code class="language-sql">-- 求最大值和最小值
select max(chinese) as 语文最大值,
       min(math) as 数学最小值
from exam;</code></pre> 
<p> 可以多个聚合函数使用，同时也可以使用别名</p> 
<p class="img-center"><img alt="" height="111" src="https://images2.imgbox.com/be/e6/wSGlEAus_o.png" width="596"></p> 
<h2 style="background-color:transparent;"></h2> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/56/fc/9D2SFiB8_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3dff640293639c2fe2e647c4a981d186/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【海贼王航海日志：前端技术探索】CSS你了解多少？(三)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7022e767b17419e2f6b5783ea05795db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DataWhaleX魔搭夏令营第四期AIGC方向task01笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>