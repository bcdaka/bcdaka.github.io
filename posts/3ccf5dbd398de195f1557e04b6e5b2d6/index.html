<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JAVASE】带你了解面向对象三大特性之一（继承） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3ccf5dbd398de195f1557e04b6e5b2d6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【JAVASE】带你了解面向对象三大特性之一（继承）">
  <meta property="og:description" content="✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉
🍎个人主页：再无B～U～G-CSDN博客
1.继承 1.1 为什么需要继承 Java 中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。 比如： 狗和猫，它们都是一个动物 。 使用 Java 语言来进行描述，就会设计出： // Dog.java public class Dog{ string name; int age; float weight; public void eat(){ System.out.println(name &#43; &#34;正在吃饭&#34;); } public void sleep(){ System.out.println(name &#43; &#34;正在睡觉&#34;); } void Bark(){ System.out.println(name &#43; &#34;汪汪汪~~~&#34;); } } // Cat.Java public class Cat{ string name; int age; float weight; public void eat(){ System.out.println(name &#43; &#34;正在吃饭&#34;); } public void sleep() { System.out.println(name &#43; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-06T21:17:04+08:00">
    <meta property="article:modified_time" content="2024-04-06T21:17:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JAVASE】带你了解面向对象三大特性之一（继承）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1200" src="https://images2.imgbox.com/5b/53/1YhaqLx8_o.png" width="1200"></p> 
<p>✅作者简介：大家好，我是橘橙黄又青，一个想要与大家共同进步的男人😉😉</p> 
<p>🍎个人主页：<a href="https://blog.csdn.net/chendemingxxx?spm=1011.2266.3001.5343" title="再无B～U～G-CSDN博客">再无B～U～G-CSDN博客</a></p> 
<h2>1.<span style="color:#333333;"><strong>继承</strong></span></h2> 
<h3><span style="color:#333333;"><strong>1.1 </strong></span><span style="color:#333333;"><strong>为什么需要继承 </strong></span></h3> 
<div> 
 <div> 
  <span style="color:#333333;">Java</span> 
  <span style="color:#333333;">中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">比如：</span> 
  <span style="color:#333333;"><strong>狗和猫，它们都是一个动物</strong></span> 
  <span style="color:#333333;">。 </span> 
 </div> 
 <div> 
  <img alt="" height="295" src="https://images2.imgbox.com/ef/4d/X5vtKB3l_o.png" width="198"> 
  <img alt="" height="274" src="https://images2.imgbox.com/40/22/Ely3Uu2l_o.png" width="183"> 
 </div> 
 <div> 
  <div> 
   <span style="color:#333333;">使用</span> 
   <span style="color:#333333;">Java</span> 
   <span style="color:#333333;">语言来进行描述，就会设计出： </span> 
  </div> 
  <div> 
   <pre><code class="language-java">// Dog.java
public class Dog{
    string name;
    int age;
    float weight;
    public void eat(){
        System.out.println(name + "正在吃饭");
    }
    public void sleep(){
        System.out.println(name + "正在睡觉");
    }
    void Bark(){
        System.out.println(name + "汪汪汪~~~");
    }
}
// Cat.Java
public class Cat{
    string name;
    int age;
    float weight;
    public void eat(){
        System.out.println(name + "正在吃饭");
    }
    public void sleep()
    {
        System.out.println(name + "正在睡觉");
    }
    void mew(){
        System.out.println(name + "喵喵喵~~~");
    }
}</code></pre> 
   <div> 
    <span style="color:#333333;">通过观察上述代码会发现，猫和狗的类中存在大量重复，如下所示： </span> 
   </div> 
   <div> 
    <img alt="" height="429" src="https://images2.imgbox.com/f0/36/y9wQA4aU_o.png" width="1120"> 
   </div> 
   <div> 
    <div> 
     <span style="color:#333333;">那能否将这些共性抽取呢？</span> 
     <span style="color:#333333;"><strong>面向对象思想中提出了继承的概念，专门用来进行共性抽取，实现代码复用</strong></span> 
     <span style="color:#333333;">。</span> 
    </div> 
    <h3><span style="color:#333333;"><strong>1.2 </strong></span><span style="color:#333333;"><strong>继承概念</strong></span></h3> 
    <p></p> 
    <div> 
     <span style="color:#333333;"><strong>继承</strong></span> 
     <span style="color:#333333;"><strong>(inheritance)</strong></span> 
     <span style="color:#333333;"><strong>机制</strong></span> 
     <span style="color:#333333;">：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特 性的基础上进行<strong>扩展，增加新功能</strong></span> 
     <span style="color:#333333;">，这样产生新的类，称</span> 
     <span style="color:#333333;"><strong>派生类</strong></span> 
     <span style="color:#333333;">。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是：<strong>共性的抽取，实现代码复用</strong></span> 
     <span style="color:#333333;">。 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#333333;">例如：狗和猫都是动物，那么我们就可以将共性的内容进行抽取，然后采用继承的思想来达到共用。</span> 
    </div> 
    <div> 
     <img alt="" height="528" src="https://images2.imgbox.com/4e/8f/0TuUCdvS_o.png" width="1034"> 
    </div> 
    <div> 
     <div> 
      <span style="color:#333333;">上述图示中，</span> 
      <span style="color:#333333;">Dog</span> 
      <span style="color:#333333;">和</span> 
      <span style="color:#333333;">Cat</span> 
      <span style="color:#333333;">都继承了</span> 
      <span style="color:#333333;">Animal</span> 
      <span style="color:#333333;">类，其中：</span> 
      <span style="color:#333333;">Animal</span> 
      <span style="color:#333333;">类称为父类</span> 
      <span style="color:#333333;">/</span> 
      <span style="color:#333333;">基类或超类，</span> 
      <span style="color:#333333;">Dog</span> 
      <span style="color:#333333;">和</span> 
      <span style="color:#333333;">Cat</span> 
      <span style="color:#333333;">可以称为</span> 
      <span style="color:#333333;">Animal</span> 
      <span style="color:#333333;">的子类/</span> 
      <span style="color:#333333;">派生类，继承之后，子类可以复用父类中成员，子类在实现时只需关心自己新增加的成员即可。 </span> 
     </div> 
     <div> 
      <span style="color:#333333;">从继承概念中可以看出继承最大的作用就是：实现代码复用，还有就是来实现多态</span> 
      <span style="color:#333333;">(</span> 
      <span style="color:#333333;">后序讲</span> 
      <span style="color:#333333;">)</span> 
      <span style="color:#333333;">。 </span> 
     </div> 
     <h3><span style="color:#333333;"><strong>1.3 </strong></span><span style="color:#333333;"><strong>继承的语法</strong></span></h3> 
     <div> 
      <span style="color:#333333;">在</span> 
      <span style="color:#333333;">Java</span> 
      <span style="color:#333333;">中如果要表示类之间的继承关系，需要借助</span> 
      <span style="color:#333333;"><strong>extends</strong></span> 
      <span style="color:#333333;">关键字，具体如下： </span> 
     </div> 
     <div> 
      <span style="color:#333333;">格式：</span> 
     </div> 
     <blockquote> 
      <div> 
       <div> 
        <span style="color:#000000;">修饰符 </span> 
        <span style="color:#770088;">class </span> 
        <span style="color:#0000ff;">子类 </span> 
        <span style="color:#770088;">extends </span> 
        <span style="color:#000000;">父类 </span> 
        <span style="color:#333333;">{ </span> 
       </div> 
       <div> 
        <span style="color:#aa5500;">// ... </span> 
       </div> 
       <div> 
        <span style="color:#333333;">}</span> 
       </div> 
      </div> 
     </blockquote> 
     <div> 
      <pre><code class="language-java">// Animal.java
public class Animal{
String name;
    int age;
    public void eat(){
        System.out.println(name + "正在吃饭");
    }
    public void sleep(){
    System.out.println(name + "正在睡觉");
    }
}
// Dog.java
public class Dog extends Animal{
    void bark(){
        System.out.println(name + "汪汪汪~~~");
    }
}

// Cat.Java
public class Cat extends Animal{
    void mew(){
        System.out.println(name + "喵喵喵~~~");
    }
}
// TestExtend.java
public class TestExtend {
    public static void main(String[] args) {
        Dog dog = new Dog();
        // dog类中并没有定义任何成员变量，name和age属性肯定是从父类Animal中继承下来的
        System.out.println(dog.name);
        System.out.println(dog.age);
        // dog访问的eat()和sleep()方法也是从Animal中继承下来的
        dog.eat();
        dog.sleep();
        dog.bark();
    }
}</code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p> <span style="color:#333333;"><strong>注意：</strong></span></p> 
<blockquote> 
 <p></p> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">子类会将父类中的成员变量或者成员方法继承到子类中了 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;">子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了 </span> 
 </div> 
</blockquote> 
<h3> <span style="color:#333333;"><strong>1.4 </strong></span><span style="color:#333333;"><strong>父类成员访问 </strong></span></h3> 
<div> 
 <span style="color:#333333;">在继承体系中，子类将父类中的方法和字段继承下来了，那在子类中能否直接访问父类中继承下来的成员呢？</span> 
</div> 
<div> 
 <h4><span style="color:#333333;"><strong>1.4.1 </strong></span><span style="color:#333333;"><strong>子类中访问父类的成员变量 </strong></span></h4> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;"><strong>子类和父类不存在同名成员变量</strong></span> 
 </div> 
</div> 
<div> 
 <pre><code class="language-java">public class Base {
    int a;
    int b;
}
public class Derived extends Base{
    int c;
    public void method(){
        a = 10; // 访问从父类中继承下来的a
        b = 20; // 访问从父类中继承下来的b
        c = 30; // 访问子类自己的c
    }
}</code></pre> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;"><strong>子类和父类成员变量同名 </strong></span> 
 </div> 
 <div> 
  <pre><code class="language-java">public class Base {
    int a;
    int b;
    int c;
}
/
public class Derived extends Base{
    int a; // 与父类中成员a同名，且类型相同
    char b; // 与父类中成员b同名，但类型不同
    public void method(){
        a = 100; // 访问父类继承的a，还是子类自己新增的a？
        b = 101; // 访问父类继承的b，还是子类自己新增的b?
        c = 102; // 子类没有c，访问的肯定是从父类继承下来的c
        // d = 103; // 编译失败，因为父类和子类都没有定义成员变量b
    }
}</code></pre> 
  <div> 
   <span style="color:#333333;"><strong>在子类方法中 或者 通过子类对象访问成员时</strong></span> 
   <span style="color:#333333;">：</span> 
  </div> 
  <blockquote> 
   <div> 
    <ol><li><span style="color:#fe2c24;"><strong>如果访问的成员变量子类中有，优先访问自己的成员变量。 </strong></span></li><li><span style="color:#fe2c24;"><strong>如果访问的成员变量子类中无，则访问父类继承下来的，如果父类也没有定义，则编译报错。 </strong></span></li><li><span style="color:#fe2c24;"><strong>如果访问的成员变量与父类中成员变量同名，则优先访问自己的。 </strong></span></li></ol> 
   </div> 
  </blockquote> 
 </div> 
</div> 
<p><span style="color:#333333;"><strong>成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找</strong></span><span style="color:#333333;">。</span> </p> 
<h4><span style="color:#333333;"><strong>1.4.2 </strong></span><span style="color:#333333;"><strong>子类中访问父类的成员方法</strong></span></h4> 
<p><span style="color:#333333;">1. </span><span style="color:#333333;"><strong>成员方法名字不同</strong></span></p> 
<pre><code class="language-java">public class Base {
    public void methodA(){
        System.out.println("Base中的methodA()");
    }
}
public class Derived extends Base{
    public void methodB(){
        System.out.println("Derived中的methodB()方法");
    }
    public void methodC(){
        methodB(); // 访问子类自己的methodB()
        methodA(); // 访问父类继承的methodA()
        // methodD(); // 编译失败，在整个继承体系中没有发现方法methodD()
    }
}</code></pre> 
<div> 
 <span style="color:#333333;">总结：成员方法没有同名时，在子类方法中或者通过子类对象访问方法时，则优先访问自己的，自己没有时再到父类中找，如果父类中也没有则报错。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;"><strong>成员方法名字相同 </strong></span> 
</div> 
<div> 
 <pre><code class="language-java">public class Base {
    public void methodA(){
        System.out.println("Base中的methodA()");
    }
    public void methodB(){
        System.out.println("Base中的methodB()");
    }
}
public class Derived extends Base{
    public void methodA(int a) {
        System.out.println("Derived中的method(int)方法");
    }
    public void methodB(){
        System.out.println("Derived中的methodB()方法");
    }
    public void methodC(){
        methodA(); // 没有传参，访问父类中的methodA()
        methodA(20); // 传递int参数，访问子类中的methodA(int)
        methodB(); // 直接访问，则永远访问到的都是子类中的methodB()，基类的无法访问到
    }
}</code></pre> 
 <h3><span style="color:#333333;"><strong>1.5 super</strong></span><span style="color:#333333;"><strong>关键字</strong></span></h3> 
 <pre><code class="language-java">public class Base {
    int a;
    int b;
    public void methodA(){
        System.out.println("Base中的methodA()");
    }
    public void methodB(){
        System.out.println("Base中的methodB()");
    }
}
public class Derived extends Base{
    int a; // 与父类中成员变量同名且类型相同
    char b; // 与父类中成员变量同名但类型不同
    // 与父类中methodA()构成重载
    public void methodA(int a) {
        System.out.println("Derived中的method()方法");
    }
    // 与基类中methodB()构成重写(即原型一致，重写后序详细介绍)
    public void methodB(){
        System.out.println("Derived中的methodB()方法");
    }
    public void methodC(){
        // 对于同名的成员变量，直接访问时，访问的都是子类的
        a = 100; // 等价于： this.a = 100;
        b = 101; // 等价于： this.b = 101;
        // 注意：this是当前对象的引用
        // 访问父类的成员变量时，需要借助super关键字
        // super是获取到子类对象中从基类继承下来的部分
        super.a = 200;
        super.b = 201;
        // 父类和子类中构成重载的方法，直接可以通过参数列表区分清访问父类还是子类方法
        methodA(); // 没有传参，访问父类中的methodA()
        methodA(20); // 传递int参数，访问子类中的methodA(int)
        // 如果在子类中要访问重写的基类方法，则需要借助super关键字
        methodB(); // 直接访问，则永远访问到的都是子类中的methodA()，基类的无法访问到
        super.methodB(); // 访问基类的methodB()
    }
}</code></pre> 
 <div> 
  <span style="color:#333333;">在子类方法中，如果想要明确访问父类中成员时，借助</span> 
  <span style="color:#333333;">super</span> 
  <span style="color:#333333;">关键字即可。</span> 
 </div> 
 <div> 
  <span style="color:#333333;">【</span> 
  <span style="color:#333333;"><strong>注意事项</strong></span> 
  <span style="color:#333333;">】 </span> 
 </div> 
 <blockquote> 
  <div> 
   <div> 
    <span style="color:#333333;">1. </span> 
    <span style="color:#333333;"><strong>只能在非静态方法中使用 </strong></span> 
   </div> 
   <div> 
    <span style="color:#333333;">2. </span> 
    <span style="color:#333333;"><strong>在子类方法中，访问父类的成员变量和方法</strong></span> 
    <span style="color:#333333;">。</span> 
   </div> 
  </div> 
 </blockquote> 
</div> 
<p> <span style="color:#333333;">super</span><span style="color:#333333;">的其他用法在后文中介绍。</span></p> 
<h3><span style="color:#333333;"><strong>1.6 </strong></span><span style="color:#333333;"><strong>子类构造方法</strong></span></h3> 
<div> 
 <span style="color:#333333;">父子父子，先有父再有子，即：子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法。</span> 
</div> 
<div> 
 <pre><code class="language-java">public class Base {
    public Base(){
        System.out.println("Base()");
    }
}
public class Derived extends Base{
    public Derived(){
        // super(); // 注意子类构造方法中默认会调用基类的无参构造方法：super(),
        // 用户没有写时,编译器会自动添加，而且super()必须是子类构造方法中第一条语句，
        // 并且只能出现一次
        System.out.println("Derived()");
    }
}
public class Test {
    public static void main(String[] args) {
        Derived d = new Derived();
    }
}
//结果打印：
//Base()
//Derived()</code></pre> 
 <div> 
  <span style="color:#333333;">在子类构造方法中，并没有写任何关于基类构造的代码，但是在构造子类对象时，先执行基类的构造方法，然后执行子类的构造方法，因为：<strong>子类对象中成员是有两部分组成的，基类继承下来的以及子类新增加的部分 。父子父子</strong></span> 
  <span style="color:#333333;"><strong>肯定是先有父再有子，所以在构造子类对象时候 ，先要调用基类的构造方法，将从基类继承下来的成员构造完整 </strong></span> 
  <span style="color:#333333;"><strong>，然后再调用子类自己的构造方法，将子类自己新增加的成员初始化完整 </strong></span> 
  <span style="color:#333333;">。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">注意：</span> 
 </div> 
 <blockquote> 
  <div> 
   <div> 
    <span style="color:#fe2c24;"><strong>1. 若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的super()调用，即调用基类构 造方法 </strong></span> 
   </div> 
   <div> 
    <span style="color:#fe2c24;"><strong>2. 如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败。 </strong></span> 
   </div> 
   <div> 
    <span style="color:#fe2c24;"><strong>3. 在子类构造方法中，super(...)调用父类构造时，必须是子类构造函数中第一条语句。 </strong></span> 
   </div> 
   <div> 
    <span style="color:#fe2c24;"><strong>4. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现</strong></span> 
   </div> 
  </div> 
 </blockquote> 
</div> 
<h3> <span style="color:#333333;"><strong>1.7 super</strong></span><span style="color:#333333;"><strong>和</strong></span><span style="color:#333333;"><strong>this </strong></span></h3> 
<p></p> 
<div> 
 <span style="color:#333333;">super</span> 
 <span style="color:#333333;">和</span> 
 <span style="color:#333333;">this</span> 
 <span style="color:#333333;">都可以在成员方法中用来访问：成员变量和调用其他的成员函数，都可以作为构造方法的第一条语句，那他们之间有什么区别呢？ </span> 
</div> 
<div> 
 <span style="color:#333333;">【</span> 
 <span style="color:#333333;"><strong>相同点</strong></span> 
 <span style="color:#333333;">】</span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#fe2c24;"><strong>1. 都是Java中的关键字 </strong></span> 
  </div> 
  <div> 
   <span style="color:#fe2c24;"><strong>2. 只能在类的非静态方法中使用，用来访问非静态成员方法和字段 </strong></span> 
  </div> 
  <div> 
   <span style="color:#fe2c24;"><strong>3. 在构造方法中调用时，必须是构造方法中的第一条语句，并且不能同时存在</strong></span> 
  </div> 
 </div> 
</blockquote> 
<p><span style="color:#333333;">【</span><span style="color:#333333;"><strong>不同点</strong></span><span style="color:#333333;">】 </span> </p> 
<div> 
 <span style="color:#333333;">1. this</span> 
 <span style="color:#333333;">是当前对象的引用，当前对象即调用实例方法的对象，</span> 
 <span style="color:#333333;">super</span> 
 <span style="color:#333333;">相当于是子类对象中从父类继承下来部分成员的引用。</span> 
</div> 
<div> 
 <span style="color:#333333;">直观表示：</span> 
</div> 
<div> 
 <img alt="" height="526" src="https://images2.imgbox.com/9c/45/d4NA3G6V_o.png" width="903"> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;">在</span> 
  <span style="color:#fe2c24;"><strong>非静态成员方法</strong></span> 
  <span style="color:#333333;">中，</span> 
  <span style="color:#333333;">this</span> 
  <span style="color:#333333;">用来访问本类的方法和属性，</span> 
  <span style="color:#333333;">super</span> 
  <span style="color:#333333;">用来访问父类继承下来的方法和属性。</span> 
 </div> 
 <div> 
  <span style="color:#333333;">3. </span> 
  <span style="color:#333333;">在构造方法中：</span> 
  <span style="color:#333333;">this(...)</span> 
  <span style="color:#333333;">用于调用本类构造方法，</span> 
  <span style="color:#333333;">super(...)</span> 
  <span style="color:#333333;">用于调用父类构造方法，两种调用不能同时在构造方法中出现。</span> 
 </div> 
 <div> 
  <span style="color:#333333;">4. </span> 
  <span style="color:#333333;">构造方法中一定会存在</span> 
  <span style="color:#333333;">super(...)</span> 
  <span style="color:#333333;">的调用，用户没有写编译器也会增加，但是</span> 
  <span style="color:#333333;">this(...)</span> 
  <span style="color:#333333;">用户不写则没有。</span> 
 </div> 
</div> 
<p> </p> 
<h3><span style="color:#333333;"><strong>1.8 </strong></span><span style="color:#333333;"><strong>再谈初始化</strong></span></h3> 
<div> 
 <span style="color:#333333;">我们还记得之前讲过的代码块吗？那么继承关系时的执行顺序是怎么样的呢？</span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#777777;">1. </span> 
   <span style="color:#777777;">静态代码块先执行，并且只执行一次，在类加载阶段执行 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">2. </span> 
   <span style="color:#777777;">当有对象创建时，才会执行实例代码块，实例代码块执行完成后，最后构造方法执行 </span> 
  </div> 
 </div> 
</blockquote> 
<p><span style="color:#333333;">【</span><span style="color:#333333;"><strong>继承关系上的执行顺序</strong></span><span style="color:#333333;">】</span></p> 
<p><span style="color:#333333;">案例：</span></p> 
<p> </p> 
<pre><code class="language-java">class Person {
    public String name;
    public int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Person：构造方法执行");
    }
    //代码实例化
    {
        System.out.println("Person：实例代码块执行");
    }
    //静态实例化
    static {
        System.out.println("Person：静态代码块执行");
    }
}
class Student extends Person{
    public Student(String name,int age) {
        super(name,age);
        System.out.println("Student：构造方法执行");
    }
    {
        System.out.println("Student：实例代码块执行");
    }
    static {
        System.out.println("Student：静态代码块执行");
    }
}
public class TestDemo4 {
    public static void main(String[] args) {
        Student student1 = new Student("张三",19);
        System.out.println("===========================");
        Student student2 = new Student("gaobo",20);
    }
    public static void main1(String[] args) {
         Person person1 = new Person("bit",10);
        System.out.println("============================");
        Person person2 = new Person("gaobo",20);
    }
}
</code></pre> 
<p>输出结果：</p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/d3/09/ZZz0TOsG_o.png" width="494"></p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/44/a6/IEyA51qH_o.png" width="1200"></p> 
<p>总结：</p> 
<blockquote> 
 <div> 
  <span style="color:#956fe7;"><strong>1、父类静态代码块优先于子类静态代码块执行，且是最早执行 </strong></span> 
 </div> 
 <div> 
  <span style="color:#956fe7;"><strong>2、父类实例代码块和父类构造方法紧接着执行 </strong></span> 
 </div> 
 <div> 
  <span style="color:#956fe7;"><strong>3、子类的实例代码块和子类构造方法紧接着再执行 </strong></span> 
 </div> 
 <div> 
  <span style="color:#956fe7;"><strong>4、第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行 </strong></span> 
 </div> 
</blockquote> 
<p> </p> 
<h3><span style="color:#333333;"><strong>1.9 protected </strong></span><span style="color:#333333;"><strong>关键字 </strong></span></h3> 
<div> 
 <span style="color:#333333;">在类和对象章节中，为了实现封装特性，</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">中引入了访问限定符，主要限定：类或者类中成员能否在类外或者其 他包中被访问。</span> 
</div> 
<div> 
 <img alt="" height="778" src="https://images2.imgbox.com/9a/dc/8piS9six_o.png" width="1200"> 
</div> 
<div> 
 <span style="color:#fe2c24;"><strong>重点：</strong></span> 
</div> 
<div> 
 <pre><code class="language-java">// extend01包中
public class B {
    private int a;
    protected int b;
    public int c;
    int d;
}


// extend01包中
// 同一个包中的子类
public class D extends B{
    public void method(){
        // super.a = 10; // 编译报错，父类private成员在相同包子类中不可见
        super.b = 20; // 父类中protected成员在相同包子类中可以直接访问
        super.c = 30; // 父类中public成员在相同包子类中可以直接访问
        super.d = 40; // 父类中默认访问权限修饰的成员在相同包子类中可以直接访问
    }
}



// extend02包中
// 不同包中的子类
public class C extends B {
    public void method(){
        // super.a = 10; // 编译报错，父类中private成员在不同包子类中不可见
        super.b = 20; // 父类中protected修饰的成员在不同包子类中可以直接访问
        super.c = 30; // 父类中public修饰的成员在不同包子类中可以直接访问
        //super.d = 40; // 父类中默认访问权限修饰的成员在不同包子类中不能直接访问
    }
}



// extend02包中
// 不同包中的类
public class TestC {
    public static void main(String[] args) {
        C c = new C();
        c.method();
        // System.out.println(c.a); // 编译报错，父类中private成员在不同包其他类中不可见
        // System.out.println(c.b); // 父类中protected成员在不同包其他类中不能直接访问
        System.out.println(c.c); // 父类中public成员在不同包其他类中可以直接访问
        // System.out.println(c.d); // 父类中默认访问权限修饰的成员在不同包其他类中不能直接访问
    }
}</code></pre> 
 <div> 
  <span style="color:#333333;">注意：父类中</span> 
  <span style="color:#333333;">private</span> 
  <span style="color:#333333;">成员变量虽然在子类中不能直接访问，但是也继承到子类中了 </span> 
 </div> 
 <div></div> 
 <div></div> 
 <div> 
  <span style="color:#0d0016;"><strong>什么时候下用哪一种呢?</strong></span> 
  <span style="color:#777777;"><strong> </strong></span> 
 </div> 
 <blockquote> 
  <div> 
   <ul><li><span style="color:#777777;">我们希望类要尽量做到</span><span style="color:#777777;"> "</span><span style="color:#777777;">封装</span><span style="color:#777777;">", </span><span style="color:#777777;">即隐藏内部实现细节</span><span style="color:#777777;">, </span><span style="color:#777777;">只暴露出 </span><span style="color:#777777;"><strong>必要 </strong></span><span style="color:#777777;">的信息给类的调用者。</span></li><li><span style="color:#777777;">因此我们在使用的时候应该尽可能的使用 </span><span style="color:#777777;"><strong>比较严格 </strong></span><span style="color:#777777;">的访问权限</span><span style="color:#777777;">. </span><span style="color:#777777;">例如如果一个方法能用</span><span style="color:#777777;"> private, </span><span style="color:#777777;">就尽量不要用 public.</span></li><li><span style="color:#777777;">另外</span><span style="color:#777777;">, </span><span style="color:#777777;">还有一种 </span><span style="color:#777777;"><strong>简单粗暴 </strong></span><span style="color:#777777;">的做法</span><span style="color:#777777;">: </span><span style="color:#777777;">将所有的字段设为</span><span style="color:#777777;"> private, </span><span style="color:#777777;">将所有的方法设为</span><span style="color:#777777;"> public. </span><span style="color:#777777;">不过这种方式属于是 对访问权限的滥用, </span><span style="color:#777777;">还是更希望同学们能写代码的时候认真思考。</span></li></ul> 
  </div> 
 </blockquote> 
</div> 
<h3> <span style="color:#333333;"><strong>1.10 </strong></span><span style="color:#333333;"><strong>继承方式 </strong></span></h3> 
<p><span style="color:#333333;">在现实生活中，事物之间的关系是非常复杂，灵活多样，比如：</span></p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/1f/ae/L4qzZY15_o.png" width="996"></p> 
<div> 
 <span style="color:#333333;">但在</span> 
 <span style="color:#333333;">Java</span> 
 <span style="color:#333333;">中只支持以下几种继承方式：</span> 
</div> 
<p><img alt="" height="1006" src="https://images2.imgbox.com/eb/82/plBnS1qA_o.png" width="993"></p> 
<div> 
 <span style="color:#333333;"><strong>注意：</strong></span> 
 <span style="color:#333333;"><strong>Java</strong></span> 
 <span style="color:#333333;"><strong>中不支持多继承</strong></span> 
 <span style="color:#333333;">。</span> 
</div> 
<blockquote> 
 <div> 
  <ol><li><span style="color:#777777;">时刻牢记</span><span style="color:#777777;">, </span><span style="color:#777777;">我们写的类是现实事物的抽象</span><span style="color:#777777;">. </span><span style="color:#777777;">而我们真正在公司中所遇到的项目往往业务比较复杂</span><span style="color:#777777;">, </span><span style="color:#777777;">可能会涉及到一系列复杂的概念, </span><span style="color:#777777;">都需要我们使用代码来表示</span><span style="color:#777777;">, </span><span style="color:#777777;">所以我们真实项目中所写的类也会有很多</span><span style="color:#777777;">. </span><span style="color:#777777;">类之间的关系也会更加复杂. </span></li><li><span style="color:#777777;">但是即使如此</span><span style="color:#777777;">, </span><span style="color:#777777;">我们并不希望类之间的继承层次太复杂</span><span style="color:#777777;">. </span><span style="color:#777777;"><strong>一般我们不希望出现超过三层的继承关系</strong></span><span style="color:#777777;">. </span><span style="color:#777777;">如果继承层 </span></li><li><span style="color:#777777;">次太多</span><span style="color:#777777;">, </span><span style="color:#777777;">就需要考虑对代码进行重构了</span><span style="color:#777777;">. </span></li></ol> 
  <div></div> 
  <div> 
   <span style="color:#777777;">如果想从语法上进行限制继承</span> 
   <span style="color:#777777;">, </span> 
   <span style="color:#777777;">就可以使用</span> 
   <span style="color:#777777;"> final </span> 
   <span style="color:#777777;">关键字 </span> 
  </div> 
 </div> 
</blockquote> 
<h3><span style="color:#333333;"><strong>1.11 final </strong></span><span style="color:#333333;"><strong>关键字</strong></span> </h3> 
<div> 
 <span style="color:#333333;">final</span> 
 <span style="color:#333333;">关键可以用来修饰变量、成员方法以及类。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;"><strong>修饰变量或字段，表示常量</strong></span> 
 <span style="color:#333333;"><strong>(</strong></span> 
 <span style="color:#333333;"><strong>即不能修改</strong></span> 
 <span style="color:#333333;"><strong>)</strong></span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <pre><span style="color:#ad720d;"><strong>final int a = 10;
a = 20; // 编译出错
String arr = "  ";
arr = 20; // 编译出错</strong></span></pre> 
  </div> 
 </div> 
</blockquote> 
<p><img alt="" height="197" src="https://images2.imgbox.com/c0/cb/OBt9CcQj_o.png" width="763"> </p> 
<p><span style="color:#333333;">2. </span><span style="color:#333333;"><strong>修饰类：表示此类不能被继承</strong></span> </p> 
<blockquote> 
 <div> 
  <span style="color:#770088;">final public class </span> 
  <span style="color:#0000ff;">Animal </span> 
  <span style="color:#333333;">{ </span> 
 </div> 
 <div> 
  <span style="color:#333333;">... </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#770088;">public class </span> 
  <span style="color:#0000ff;">Bird </span> 
  <span style="color:#770088;">extends </span> 
  <span style="color:#000000;">Animal </span> 
  <span style="color:#333333;">{ </span> 
 </div> 
 <div> 
  <span style="color:#333333;">... </span> 
 </div> 
 <div> 
  <span style="color:#333333;">} </span> 
 </div> 
 <div> 
  <span style="color:#aa5500;">// </span> 
  <span style="color:#aa5500;">编译出错 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">Error</span> 
  <span style="color:#333333;">:(</span> 
  <span style="color:#116644;">3</span> 
  <span style="color:#333333;">, </span> 
  <span style="color:#116644;">27</span> 
  <span style="color:#333333;">) </span> 
  <span style="color:#000000;">java</span> 
  <span style="color:#333333;">: </span> 
  <span style="color:#000000;">无法从最终</span> 
  <span style="color:#000000;">com</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">bit</span> 
  <span style="color:#333333;">.</span> 
  <span style="color:#000000;">Animal</span> 
  <span style="color:#000000;">进行继 </span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">3. </span> 
 <span style="color:#333333;"><strong>修饰方法：表示该方法不能被重写</strong></span> 
 <span style="color:#333333;"><strong>(</strong></span> 
 <span style="color:#333333;"><strong>后序介绍</strong></span> 
 <span style="color:#333333;"><strong>) </strong></span> 
</div> 
<div></div> 
<h3><span style="color:#333333;"><strong>1.12 </strong></span><span style="color:#333333;"><strong>继承与组合</strong></span></h3> 
<p><span style="color:#333333;">和继承类似, </span><span style="color:#333333;">组合也是一种表达类之间关系的方式</span><span style="color:#333333;">, </span><span style="color:#333333;">也是能够达到代码重用的效果。组合并没有涉及到特殊的语法 (诸如</span><span style="color:#333333;"> extends </span><span style="color:#333333;">这样的关键字</span><span style="color:#333333;">), </span><span style="color:#333333;">仅仅是将一个类的实例作为另外一个类的字段。 </span></p> 
<div> 
 <span style="color:#333333;"><strong>继承表示对象之间是</strong></span> 
 <span style="color:#333333;"><strong>is-a</strong></span> 
 <span style="color:#333333;"><strong>的关系</strong></span> 
 <span style="color:#333333;">，比如：狗是动物，猫是动物 </span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>组合表示对象之间是</strong></span> 
 <span style="color:#333333;"><strong>has-a</strong></span> 
 <span style="color:#333333;"><strong>的关系</strong></span> 
 <span style="color:#333333;">，比如：汽车 </span> 
</div> 
<div></div> 
<div> 
 <img alt="" height="394" src="https://images2.imgbox.com/92/e5/gDLgYo0Y_o.png" width="909"> 
</div> 
<div> 
 <img alt="" height="595" src="https://images2.imgbox.com/36/1c/lICmYoz3_o.png" width="898"> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">汽车和其轮胎、发动机、方向盘、车载系统等的关系就应该是组合，因为汽车是有这些部件组成的。</span> 
 </div> 
 <div> 
  <span style="color:#333333;">案例代码：</span> 
 </div> 
 <div> 
  <pre><code class="language-java">// 轮胎类
class Tire{
    // ...
}
// 发动机类
class Engine{
    // ...
}
    // 车载系统类
class VehicleSystem{
    // ...
}
class Car{
    private Tire tire; // 可以复用轮胎中的属性和方法
    private Engine engine; // 可以复用发动机中的属性和方法
    private VehicleSystem vs; // 可以复用车载系统中的属性和方法
    // ...
}
// 奔驰是汽车
class Benz extend Car{
    // 将汽车中包含的：轮胎、发送机、车载系统全部继承下来
}</code></pre> 
  <div> 
   <span style="color:#333333;">组合和继承都可以实现代码复用，应该使用继承还是组合，需要根据应用场景来选择，一般建议：能用组合尽量用组合。</span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#333333;">今天就到这里了，感谢观看。</span> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6af3f3e77a326494e6e85e504cb43da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【附源码】基于flask框架图书管理系统 (python&#43;mysql&#43;论文)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9624819000568d2d0b786b7814b8b48b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据库】国产达梦数据库与mysql特点、区别、发展前景</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>