<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】红黑树的全面探索和深度解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2c105f6604e9864ba00392bcfaefa856/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】红黑树的全面探索和深度解析">
  <meta property="og:description" content="✨ 慢品人间烟火色，闲观万事岁月长 🌏 📃个人主页：island1314
🔥个人专栏：C&#43;&#43;学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
1. 红黑树的概念 📒红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的
📙红黑树由Rudolf Bayer在1972年发明，最初被称为平衡二叉B树（Symmetric Binary B-trees），后来被Guibas和Robert Sedgewick修改为如今的“红黑树”。
2. 红黑树的性质 节点是红色或黑色：每个节点都有一个颜色属性，颜色可以是红色或黑色。
根节点是黑色：树的根节点必须是黑色。
红色节点的子节点是黑色：如果一个节点是红色，则它的两个子节点必须是黑色（即不能有两个连续的红色节点）。
每个节点到其每个叶子节点的路径都包含相同数量的黑色节点：从任何节点到其每个叶子节点的路径上，经过的黑色节点的数量必须相同。
叶子节点是黑色：红黑树的叶子节点（通常是指空节点）被视为黑色。
3. 红黑树的节点结构及定义 红黑树节点的定义通常包含以下几个关键部分：
🧩3.1 基本元素 _left：指向节点的左子节点的指针_right：指向节点的右子节点的指针_parent：指向节点的父节点的指针_kv：一个结构体或配对（pair），包含节点的键值（key）和值（value）。这取决于红黑的具体用途，可能只包含键或包含键值对。_col：表示当前节点的颜色。 🧩3.2 节点颜色（_col） 在上面的定义中，_col 成员变量用于表示节点的颜色，通过 Color 枚举类型来定义，可以是 RED 或 BLACK。 🧩3.3 构造函数 初始化一个新节点时，通常需要一个构造函数，它接受一个键值对（或仅键），并设置节点的左子节点、右子节点、父节点和颜色（初始化为红色） 🧩3.4 BR节点定义： template&lt;class K, class V&gt; struct BSTreeNode { BSTreeNode&lt;K, V&gt;* _left; //左子树 BSTreeNode&lt;K, V&gt;* _right; //右子树 BSTreeNode&lt;K, V&gt;* _parent; //父亲 pair&lt;K, V&gt; _kv; //存放节点值的 string _col; //颜色（通过这个可以直到左右子树存在情况） //构造函数 BSTreeNode(const pair&lt;K, V&gt;&amp; kv) :_left(nullptr) , _right(nullptr) , _parent(nullptr) , _kv(kv) , _col(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T20:20:11+08:00">
    <meta property="article:modified_time" content="2024-07-24T20:20:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】红黑树的全面探索和深度解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0f/ae/nZJpCZKP_o.jpg"></p> 
<p>✨                                                      <span style="color:#956fe7;"> 慢品人间烟火色，闲观万事岁月长</span>      🌏 </p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p>🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12622912.html" title="C++学习">C++学习</a></p> 
<p>🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/9b/S4icUx7R_o.gif"></p> 
<hr> 
<h3>1. 红黑树的概念</h3> 
<blockquote> 
 <p>📒<strong>红黑树</strong>，是一种<strong>二叉搜索树</strong>，但<strong>在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black</strong>。 通过<strong>对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍</strong>，因而是<strong>接近平衡的</strong></p> 
</blockquote> 
<p>📙红黑树由Rudolf Bayer在1972年发明，最初被称为平衡二叉B树（Symmetric Binary B-trees），后来被Guibas和Robert Sedgewick修改为如今的“红黑树”。</p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/f5/ce/TYjl9Afl_o.png" width="852"></p> 
<h3>2. 红黑树的性质</h3> 
<blockquote> 
 <ol><li> <p><strong>节点是红色或黑色</strong>：每个节点都有一个颜色属性，颜色可以是红色或黑色。</p> </li><li> <p><strong>根节点是黑色</strong>：树的根节点必须是黑色。</p> </li><li> <p><strong>红色节点的子节点是黑色</strong>：如果一个节点是红色，则它的两个子节点必须是黑色<strong>（即不能有两个连续的红色节点）。</strong></p> </li><li> <p><strong>每个节点到其每个叶子节点的路径都包含相同数量的黑色节点</strong>：从任何节点到其每个叶子节点的路径上，经过的黑色节点的数量必须相同。</p> </li><li> <p><strong>叶子节点是黑色</strong>：红黑树的叶子节点（通常是指空节点）被视为黑色。</p> </li></ol> 
</blockquote> 
<h3 id="%E4%B8%89%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84">3. 红黑树的节点结构及定义</h3> 
<p><strong>红黑树节点的定义通常包含以下几个关键部分：</strong></p> 
<h4 id="%F0%9F%A7%A91.%20%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0" style="background-color:transparent;">🧩3.<strong>1 基本元素</strong></h4> 
<blockquote> 
 <ul><li>_left：指向节点的左子节点的指针</li><li>_right：指向节点的右子节点的指针</li><li>_parent：指向节点的父节点的指针</li><li>_kv：一个结构体或配对（pair），包含节点的键值（key）和值（value）。这取决于红黑的具体用途，可能只包含键或包含键值对。</li><li>_col：表示当前节点的颜色。</li></ul> 
</blockquote> 
<h4 id="%F0%9F%A7%A92.%C2%A0BST%E5%AE%9A%E4%B9%89%EF%BC%9A">🧩3.2 节点颜色（_col）</h4> 
<blockquote> 
 <ul><li>在上面的定义中，_col 成员变量用于表示节点的颜色，通过 Color 枚举类型来定义，可以是 RED 或 BLACK。</li></ul> 
</blockquote> 
<h4 id="%F0%9F%A7%A93.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">🧩3.3 构造函数</h4> 
<blockquote> 
 <ul><li>初始化一个新节点时，通常需要一个构造函数，它接受一个键值对（或仅键），并设置节点的左子节点、右子节点、父节点和颜色（初始化为红色）</li></ul> 
</blockquote> 
<h4 id="%F0%9F%A7%A9AVL%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89%EF%BC%9A">🧩3.4 BR<strong>节点定义：</strong></h4> 
<pre><code class="language-cpp">template&lt;class K, class V&gt;
struct BSTreeNode
{
	BSTreeNode&lt;K, V&gt;* _left;    //左子树
	BSTreeNode&lt;K, V&gt;* _right;   //右子树
	BSTreeNode&lt;K, V&gt;* _parent;  //父亲
	pair&lt;K, V&gt; _kv;       //存放节点值的
	string _col;    //颜色（通过这个可以直到左右子树存在情况）
 
	//构造函数
	BSTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
		, _kv(kv)
		, _col("RED")     //默认颜色为红色
	{}
};
 </code></pre> 
<p><span style="color:#fe2c24;">红黑树的节点结构与二叉搜索树和<a href="https://so.csdn.net/so/search?q=AVL%E6%A0%91&amp;spm=1001.2101.3001.7020" title="AVL树">AVL树</a>差别不大，最大的差别就是加入了一个新的存储点——颜色</span></p> 
<h3>4. 红黑树的插入</h3> 
<p>🌈<strong>红黑树是在二叉搜索树的基础上加上其平衡限制条件,因此红黑树的插入可分为两步：</strong></p> 
<blockquote> 
 <ul><li>按照<strong>二叉搜索的树规则</strong>插入新节点</li><li>检测新节点插入后，<strong>红黑树的性质是否造到破坏</strong></li></ul> 
</blockquote> 
<p><strong>在我们进行插入操作之前，我们先定义一个红黑树的类</strong></p> 
<p><strong>红黑树定义：</strong></p> 
<pre><code class="language-cpp">template&lt;class K, class V&gt;
class RBTTree
{
	typedef BSTreeNode&lt;K, V&gt; Node;
public:
	// 其他未实现的成员函数
private:
	Node* _root = nullptr;	
};
</code></pre> 
<p><strong>红黑树的插入操作类似于我们之前AVL树的插入，只不过红黑树的插入操作涉及到旋转操作以及考虑其他节点的颜色，前面的操作还是一样的</strong></p> 
<pre><code class="language-cpp">bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		if (_root == nullptr)
		{
			_root = new Node(kv);
			_root-&gt;_col = BLACK;
			return true;
		}

		Node* parent = nullptr;
		Node* cur = _root;

		while (cur)
		{
			parent = cur;
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}

		// 新增节点给红色
		cur = new Node(kv);
		cur-&gt;_col = RED;
		if (parent-&gt;_kv.first &lt; kv.first)
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}
		cur-&gt;_parent = parent;

		// 检测新节点插入后，红黑树的性质是否造到破坏

		return true;
	}
</code></pre> 
<h4 style="background-color:transparent;">🧩检测红黑树是否造到破坏</h4> 
<p>（如果遭到破坏则对当前红黑树进行变色，旋转处理）<br><strong>约定：cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点</strong></p> 
<h5 style="background-color:transparent;"><a name="t7"></a><a id="_169"></a>🌈情况一</h5> 
<p><strong>cur为红，p为红，g为黑，u存在且为红</strong></p> 
<p><img alt="" height="932" src="https://images2.imgbox.com/bd/ea/ezDfsnCv_o.png" width="978"></p> 
<p><strong>解决方式：将parent,uncle改为黑，g改为红，然后把g当成cur，继续向上调整。</strong></p> 
<h5 style="background-color:transparent;">🌈情况二</h5> 
<p><strong>cur为红，p为红，g为黑，u不存在/u存在且为黑</strong></p> 
<p><img alt="" height="647" src="https://images2.imgbox.com/58/99/NYRc3pFk_o.png" width="830"></p> 
<h5>🌈情况三</h5> 
<p><strong>cur为红，p为红，g为黑，u不存在/u存在且为黑</strong></p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/bc/35/AJYPQL3d_o.png" width="1134"></p> 
<p><strong>解决方式：</strong> <strong>p为g的左孩子，cur为p的右孩子，则针对p做左右双旋；p为g的右孩子，cur为p的左孩子，则针对p做右左旋转</strong></p> 
<blockquote> 
 <p><strong>cur、grandfather变色–&gt; c变黑，p变红</strong></p> 
</blockquote> 
<p><strong>检测红黑树是否造到破坏代码演示(C++)：</strong></p> 
<pre><code class="language-cpp">while (parent &amp;&amp; parent-&gt;_col == RED) //当父亲节点为红色，则出现了连续的红色，不符合条件
		{
			Node* grandfather = parent-&gt;_parent;
			//    g
			//  p   u
			if (parent == grandfather-&gt;_left) {	
				Node* uncle = grandfather-&gt;_right;
				if (uncle &amp;&amp; uncle-&gt;_col == RED) //叔叔存在并且为红
				{
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					cur = grandfather;
					parent = cur-&gt;_parent; //往上面走
				}
				else
				{
					//u存在且为黑或不存在 -&gt;变色再继续往上处理 + 变色
					if (cur == parent-&gt;_left) { //cur存在那么cur一定为红色 

						//    g
						//  p   u
						//c
						//单旋，把p旋转上去，p作为子树根节点，g作为p的右
						RotateR(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						//    g
						//  p   u
						//    c
						//双旋，将cur旋转上去，p作为cur的左，然后再旋转把cur旋转上去，g作为cur右边
						RotateL(parent);
						RotateR(grandfather);

						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					break;
				}
			}
			else
			{
				//    g
				//  u   p
				Node* uncle = grandfather-&gt;_left;
				// 叔叔存在且为红，-》变色即可
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					// 继续往上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				else // 叔叔不存在，或者存在且为黑
				{
					// 情况二：叔叔不存在或者存在且为黑
					// 旋转+变色
					//      g
					//   u     p
					//            c
					if (cur == parent-&gt;_right)
					{
						RotateL(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						//		g
						//   u     p
						//      c
						RotateR(parent);
						RotateL(grandfather);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					break;
				}
			}
		}
</code></pre> 
<p>红黑树的旋转和<a href="https://so.csdn.net/so/search?q=AVL&amp;spm=1001.2101.3001.7020" title="AVL">AVL</a>树差不多，我们直接上代码回顾以下：<br><strong>旋转代码示例(C++)：</strong></p> 
<pre><code class="language-cpp">void RotateL(Node* parent) // 左旋
{
	Node* subR = parent-&gt;_right;
	Node* subRL = subR-&gt;_left;

	parent-&gt;_right = subRL;
	subR-&gt;_left = parent;

	Node* Parentparent = parent-&gt;_parent;

	parent-&gt;_parent = subR;
	if (subRL)
		subRL-&gt;_parent = parent;
	
	// 判断parent是不是根节点
	if (_root == parent){
		_root = subR;
		subR-&gt;_parent = nullptr;
	}
	else{
		if (parent == Parentparent-&gt;_left)
			Parentparent-&gt;_left = subR;
	
		else
			Parentparent-&gt;_right = subR;

		subR-&gt;_parent = Parentparent;
	}
}

void RotateR(Node* parent) // 右旋
{
	Node* subL = parent-&gt;_left;
	Node* subLR = subL-&gt;_right;

	parent-&gt;_left = subLR;
	if (subLR)
		subLR-&gt;_parent = parent;
	

	Node* Parentparent = parent-&gt;_parent;

	subL-&gt;_right = parent;
	parent-&gt;_parent = subL;

	if(_root == parent){
		_root = subL;
		subL-&gt;_parent = nullptr;
	}
	else{
		if (parent == Parentparent-&gt;_left)
			Parentparent-&gt;_left = subL;
		
		else
			Parentparent-&gt;_right = subL;

		subL-&gt;_parent = Parentparent;
	}
}
</code></pre> 
<p></p> 
<h3 style="background-color:transparent;">5. 红黑树的验证</h3> 
<p>📝<strong>红黑树的检测分为两步：</strong></p> 
<blockquote> 
 <ul><li>检测其是否满足二叉搜索树(中序遍历是否为有序序列)</li><li>检测其是否满足红黑树的性质</li></ul> 
</blockquote> 
<p><strong>中序遍历代码演示(C++)：</strong></p> 
<pre><code class="language-cpp">void InOrder()
{
	_InOrder(_root);
	cout &lt;&lt; endl;
}
void _InOrder(Node* root)
{
	if (root == nullptr) return;
	_InOrder(root-&gt;_left);
	_cout &lt;&lt; root-&gt;_kv.first &lt;&lt; ":" &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;
	_InOrder(root-&gt;_right);
}</code></pre> 
<p><strong>检测其是否满足红黑树的性质(C++)：</strong></p> 
<pre><code class="language-cpp">bool IsBalance()
{
    if (_root == nullptr)
        return true;

    if (_root-&gt;_col == RED)
    {
        return false;
    }

    // 随便找条路径作为参考值
    int refNum = 0;
    Node* cur = _root;
    while (cur)
    {
        if (cur-&gt;_col == BLACK)
        {
            ++refNum;
        }
        cur = cur-&gt;_left;
    }

    return Check(_root, 0, refNum);
}


bool Check(Node* root, int blackNum, const int refNum)
{
    if (root == nullptr)
    {
        //cout &lt;&lt; blackNum &lt;&lt; endl;
        if (refNum != blackNum)
        {
            cout &lt;&lt; "存在黑色节点的数量不相等的路径" &lt;&lt; endl;
            return false;
        }
        return true;
    }

    if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)
    {
        cout &lt;&lt; root-&gt;_kv.first &lt;&lt; "存在连续的红色节点" &lt;&lt; endl;
        return false;
    }

    if (root-&gt;_col == BLACK)
    {
        blackNum++;
    }

    return Check(root-&gt;_left, blackNum, refNum)
        &amp;&amp; Check(root-&gt;_right, blackNum, refNum);
}</code></pre> 
<p><strong>测试代码用例及结果：</strong></p> 
<h3><img alt="" height="667" src="https://images2.imgbox.com/9b/49/M396BxRB_o.png" width="982"></h3> 
<h3></h3> 
<h3 style="background-color:transparent;">6. 红黑树的完整代码及总结</h3> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;assert.h&gt;
using namespace std;

enum Colour
{
	RED,
	BLACK
};

template&lt;class K, class V&gt;
struct RBTreeNode
{
	pair&lt;K, V&gt; _kv;
	RBTreeNode&lt;K, V&gt;* _left;
	RBTreeNode&lt;K, V&gt;* _right;
	RBTreeNode&lt;K, V&gt;* _parent;
	Colour _col;

	RBTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_kv(kv)
		, _left(nullptr)
		, _right(nullptr)
		, _parent(nullptr)
	{}
};

template&lt;class K, class V&gt;
class RBTree
{
	typedef RBTreeNode&lt;K, V&gt; Node;
public:
	RBTree() = default;

	RBTree(const RBTree&lt;K, V&gt;&amp; t)
	{
		_root = Copy(t._root);
	}

	RBTree&lt;K, V&gt;&amp; operator=(RBTree&lt;K, V&gt; t)
	{
		swap(_root, t._root);
		return *this;
	}

	~RBTree()
	{
		Destroy(_root);
		_root = nullptr;
	}

	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{
		if (_root == nullptr)
		{
			_root = new Node(kv);
			_root-&gt;_col = BLACK; //根节点默认为黑色
			return true;
		}

		Node* parent = nullptr;
		Node* cur = _root;
		while (cur)
		{
			parent = cur;
			if (cur-&gt;_kv.first &lt; kv.first) cur = cur-&gt;_right;
			else if (cur-&gt;_kv.first &gt; kv.first) cur = cur-&gt;_left;
			else return false;
		}

		cur = new Node(kv);
		// 新增节点。颜色红色给红色
		cur-&gt;_col = RED;
		if (parent-&gt;_kv.first &lt; kv.first)
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}
		cur-&gt;_parent = parent;

		while (parent &amp;&amp; parent-&gt;_col == RED) //当父亲节点为红色，则出现了连续的红色，不符合条件
		{
			Node* grandfather = parent-&gt;_parent;
			//    g
			//  p   u
			if (parent == grandfather-&gt;_left) {
				Node* uncle = grandfather-&gt;_right;
				if (uncle &amp;&amp; uncle-&gt;_col == RED) //叔叔存在并且为红
				{
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					cur = grandfather;
					parent = cur-&gt;_parent; //往上面走
				}
				else
				{
					//u存在且为黑或不存在 -&gt;变色再继续往上处理 + 变色
					if (cur == parent-&gt;_left) { //cur存在那么cur一定为红色 

						//    g
						//  p   u
						//c
						//单旋，把p旋转上去，p作为子树根节点，g作为p的右
						RotateR(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						//    g
						//  p   u
						//    c
						//双旋，将cur旋转上去，p作为cur的左，然后再旋转把cur旋转上去，g作为cur右边
						RotateL(parent);
						RotateR(grandfather);

						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					break;
				}
			}
			else
			{
				//    g
				//  u   p
				Node* uncle = grandfather-&gt;_left;
				// 叔叔存在且为红，-》变色即可
				if (uncle &amp;&amp; uncle-&gt;_col == RED)
				{
					parent-&gt;_col = uncle-&gt;_col = BLACK;
					grandfather-&gt;_col = RED;

					// 继续往上处理
					cur = grandfather;
					parent = cur-&gt;_parent;
				}
				else // 叔叔不存在，或者存在且为黑
				{
					// 情况二：叔叔不存在或者存在且为黑
					// 旋转+变色
					//      g
					//   u     p
					//            c
					if (cur == parent-&gt;_right)
					{
						RotateL(grandfather);
						parent-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					else
					{
						//		g
						//   u     p
						//      c
						RotateR(parent);
						RotateL(grandfather);
						cur-&gt;_col = BLACK;
						grandfather-&gt;_col = RED;
					}
					break;
				}
			}
		}

		_root-&gt;_col = BLACK; //无论什么情况根节点都为黑

		return true;
	}

	void InOrder()
	{
		_InOrder(_root);
		cout &lt;&lt; endl;
	}

	int Height()
	{
		return _Height(_root);
	}

	int Size()
	{
		return _Size(_root);
	}

	Node* Find(const K&amp; key)
	{
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; key)
			{
				cur = cur-&gt;_right;
			}
			else if (cur-&gt;_kv.first &gt; key)
			{
				cur = cur-&gt;_left;
			}
			else
			{
				return cur;
			}
		}

		return nullptr;
	}

	bool IsBalance()
	{
		if (_root == nullptr)
			return true;

		if (_root-&gt;_col == RED)
		{
			return false;
		}

		// 随便找条路径作为参考值
		int refNum = 0;
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_col == BLACK)
			{
				++refNum;
			}
			cur = cur-&gt;_left;
		}

		return Check(_root, 0, refNum);
	}


private:
	bool Check(Node* root, int blackNum, const int refNum)
	{
		if (root == nullptr)
		{
			//cout &lt;&lt; blackNum &lt;&lt; endl;
			if (refNum != blackNum)
			{
				cout &lt;&lt; "存在黑色节点的数量不相等的路径" &lt;&lt; endl;
				return false;
			}
			return true;
		}

		if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)
		{
			cout &lt;&lt; root-&gt;_kv.first &lt;&lt; "存在连续的红色节点" &lt;&lt; endl;
			return false;
		}

		if (root-&gt;_col == BLACK)
		{
			blackNum++;
		}

		return Check(root-&gt;_left, blackNum, refNum)
			&amp;&amp; Check(root-&gt;_right, blackNum, refNum);
	}


	int _Size(Node* root)
	{
		return root == nullptr ? 0 : _Size(root-&gt;_left) + _Size(root-&gt;_right) + 1;
	}

	int _Height(Node* root)
	{
		if (root == nullptr)
			return 0;

		int leftHeight = _Height(root-&gt;_left);
		int rightHeight = _Height(root-&gt;_right);

		return leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1;
	}

	void _InOrder(Node* root)
	{
		if (root == nullptr)
		{
			return;
		}

		_InOrder(root-&gt;_left);
		cout &lt;&lt; root-&gt;_kv.first &lt;&lt; ":" &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;
		_InOrder(root-&gt;_right);
	}

	void RotateL(Node* parent)
	{
		_rotateNum++;
		Node* subR = parent-&gt;_right;
		Node* subRL = subR-&gt;_left;

		parent-&gt;_right = subRL;
		if (subRL)
			subRL-&gt;_parent = parent;

		Node* parentParent = parent-&gt;_parent;

		subR-&gt;_left = parent;
		parent-&gt;_parent = subR;

		if (parentParent == nullptr)
		{
			_root = subR;
			subR-&gt;_parent = nullptr;
		}
		else
		{
			if (parent == parentParent-&gt;_left)
			{
				parentParent-&gt;_left = subR;
			}
			else
			{
				parentParent-&gt;_right = subR;
			}

			subR-&gt;_parent = parentParent;
		}
	}

	void  RotateR(Node* parent)
	{
		_rotateNum++;
		Node* subL = parent-&gt;_left;
		Node* subLR = subL-&gt;_right;

		parent-&gt;_left = subLR;
		if (subLR)
			subLR-&gt;_parent = parent;

		Node* parentParent = parent-&gt;_parent;

		subL-&gt;_right = parent;
		parent-&gt;_parent = subL;

		if (parentParent == nullptr)
		{
			_root = subL;
			subL-&gt;_parent = nullptr;
		}
		else
		{
			if (parent == parentParent-&gt;_left)
			{
				parentParent-&gt;_left = subL;
			}
			else
			{
				parentParent-&gt;_right = subL;
			}

			subL-&gt;_parent = parentParent;
		}
	}

	void Destroy(Node* root)
	{
		if (root == nullptr)
			return;

		Destroy(root-&gt;_left);
		Destroy(root-&gt;_right);
		delete root;
	}

	Node* Copy(Node* root)
	{
		if (root == nullptr) return nullptr;

		Node* newRoot = new Node(root-&gt;_kv);
		newRoot-&gt;_left = Copy(root-&gt;_left);
		newRoot-&gt;_right = Copy(root-&gt;_right);

		return newRoot;
	}

private:
	Node* _root = nullptr;

public:
	int _rotateNum = 0;
};



void TestRBTree1()
{
	RBTree&lt;int, int&gt; t;
	//int a[] = { 16, 3, 7, 11, 9, 26, 18, 14, 15 };
	int a[] = { 4, 2, 6, 1, 3, 5, 15, 7, 16, 14 };
	for (auto e : a)
	{
		t.Insert({ e, e });
	}

	t.InOrder();
	cout &lt;&lt; t.IsBalance() &lt;&lt; endl;
}


</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<blockquote> 
 <p>以上就是红黑树的全部内容，红黑树因为其自平衡的特性，及通过节点颜色来操作其树形结构的特点，极大的提高了数据存储及处理的效率，需要我们好好掌握，希望我的博客能够帮助到你，感谢观看。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/88/e0/Po4wADCD_o.gif"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42d24ef03ba8898de14fc054004902b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">卡夫卡（Kafka）框架详解：从背景到应用实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbf36a0a40826f014438e0ebd26ef2a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】二叉树———Lesson2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>