<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;修行之道】C/C&#43;&#43;内存管理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3bc7bf88c57c62dd35e594635f149178/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;修行之道】C/C&#43;&#43;内存管理">
  <meta property="og:description" content="目录
一、C/C&#43;&#43;内存分布 1. 选择题： 2. 填空题： 3. sizeof 和 strlen 区别？ 二、 C语言中动态内存管理方式：malloc/calloc/realloc/free
1.malloc/calloc/realloc的区别是什么？
2.这里需要free(p2)吗？
三、C&#43;&#43;内存管理方式
3.1 new/delete操作内置类型
3.2 new和delete操作自定义类型
四、operator new与operator delete函数（重点讲解）
4.1 operator new与operator delete函数（重点）
五、new和delete的实现原理
5.1 内置类型
示例说明
示例：没有额外开销（40个字节）
示例：有额外开销（44个字节）
5.2 自定义类型 六、定位new表达式(placement-new) （了解） 七、常见面试题 7.1 malloc/free和new/delete的区别
7.2 内存泄漏
7.2.1 什么是内存泄漏，内存泄漏的危害 7.2.2 内存泄漏分类（了解） 7.2.3 如何检测内存泄漏（了解） 7.2.4如何避免内存泄漏 一、C/C&#43;&#43;内存分布 我们先来看下面的一段代码和相关问题
int globalvar = 1; static int staticGlobalvar = 1; void test() { static int staticVar = 1; int localVar = 1; int num[10] = { 1,2,3,4 }; char char2[] = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-20T10:03:59+08:00">
    <meta property="article:modified_time" content="2024-06-20T10:03:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;修行之道】C/C&#43;&#43;内存管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81C%2FC%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81C%2FC%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%C2%A0" rel="nofollow">一、C/C++内存分布 </a></p> 
<p id="1.%20%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#1.%20%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%9A%C2%A0" rel="nofollow">1. 选择题： </a></p> 
<p id="2.%20%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#2.%20%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%9A%C2%A0" rel="nofollow">2. 填空题： </a></p> 
<p id="3.%20sizeof%20%E5%92%8C%20strlen%20%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0-toc" style="margin-left:40px;"><a href="#3.%20sizeof%20%E5%92%8C%20strlen%20%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0" rel="nofollow">3. sizeof 和 strlen 区别？ </a></p> 
<p id="%E4%BA%8C%E3%80%81%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9Amalloc%2Fcalloc%2Frealloc%2Ffree-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9Amalloc%2Fcalloc%2Frealloc%2Ffree" rel="nofollow">二、 C语言中动态内存管理方式：malloc/calloc/realloc/free</a></p> 
<p id="%C2%A01.malloc%2Fcalloc%2Frealloc%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%C2%A01.malloc%2Fcalloc%2Frealloc%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow"> 1.malloc/calloc/realloc的区别是什么？</a></p> 
<p id="2.%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81free(p2)%E5%90%97%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81free%28p2%29%E5%90%97%EF%BC%9F" rel="nofollow">2.这里需要free(p2)吗？</a></p> 
<p id="%E4%B8%89%E3%80%81C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F" rel="nofollow">三、C++内存管理方式</a></p> 
<p id="3.1%20new%2Fdelete%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#3.1%20new%2Fdelete%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">3.1 new/delete操作内置类型</a></p> 
<p id="3.2%20new%E5%92%8Cdelete%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#3.2%20new%E5%92%8Cdelete%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B" rel="nofollow">3.2 new和delete操作自定义类型</a></p> 
<p id="%E5%9B%9B%E3%80%81operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3%EF%BC%89" rel="nofollow">四、operator new与operator delete函数（重点讲解）</a></p> 
<p id="4.1%20operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-toc" style="margin-left:40px;"><a href="#4.1%20operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89" rel="nofollow">4.1 operator new与operator delete函数（重点）</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">五、new和delete的实现原理</a></p> 
<p id="5.1%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#5.1%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">5.1 内置类型</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E" rel="nofollow">示例说明</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B2%A1%E6%9C%89%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80%EF%BC%8840%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89-toc" style="margin-left:120px;"><a href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B2%A1%E6%9C%89%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80%EF%BC%8840%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89" rel="nofollow">示例：没有额外开销（40个字节）</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9C%89%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80%EF%BC%8844%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89-toc" style="margin-left:120px;"><a href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9C%89%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80%EF%BC%8844%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89" rel="nofollow">示例：有额外开销（44个字节）</a></p> 
<p id="5.2%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%C2%A0-toc" style="margin-left:40px;"><a href="#5.2%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%C2%A0" rel="nofollow">5.2 自定义类型 </a></p> 
<p id="%E5%85%AD%E3%80%81%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F(placement-new)%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F%28placement-new%29%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0" rel="nofollow">六、定位new表达式(placement-new) （了解） </a></p> 
<p id="%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0" rel="nofollow">七、常见面试题 </a></p> 
<p id="7.1%20malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#7.1%20malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">7.1 malloc/free和new/delete的区别</a></p> 
<p id="7.2%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:40px;"><a href="#7.2%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" rel="nofollow">7.2 内存泄漏</a></p> 
<p id="7.2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3%C2%A0-toc" style="margin-left:80px;"><a href="#7.2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3%C2%A0" rel="nofollow">7.2.1 什么是内存泄漏，内存泄漏的危害 </a></p> 
<p id="7.2.2%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0-toc" style="margin-left:80px;"><a href="#7.2.2%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0" rel="nofollow">7.2.2 内存泄漏分类（了解） </a></p> 
<p id="7.2.3%20%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0-toc" style="margin-left:80px;"><a href="#7.2.3%20%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0" rel="nofollow">7.2.3 如何检测内存泄漏（了解） </a></p> 
<p id="7.2.4%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#7.2.4%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%C2%A0" rel="nofollow">7.2.4如何避免内存泄漏 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81C%2FC%2B%2B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%C2%A0">一、C/C++内存分布 </h2> 
<p>我们先来看下面的一段代码和相关问题</p> 
<pre><code class="language-cpp">int globalvar = 1;
static int staticGlobalvar = 1;

void test()
{
	static int staticVar = 1;
	int localVar = 1;

	int num[10] = { 1,2,3,4 };
	char char2[] = "abcd";
	const char* pchar3 = "abcd";

	int* ptr1 = (int*)malloc(sizeof(int) * 4);
	int* ptr2 = (int*)calloc(4, sizeof(int) * 4);
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
	free(ptr1);
	free(ptr3);
}
</code></pre> 
<h3 id="1.%20%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%9A%C2%A0">1. 选择题： </h3> 
<blockquote> 
 <p>选项 : A.栈  B.堆  C.数据段(静态区)  D.代码段(常量区)<br> globalVar在哪里？__C__   staticGlobalVar在哪里？__C__<br> staticVar在哪里？__C__   localVar在哪里？__A__<br> num1 在哪里？__A__</p> 
 <p>char2在哪里？__A__ * char2在哪里？__A__<br> pChar3在哪里？__<span style="color:#fe2c24;">A</span>__ * pChar3在哪里？__D__<br> ptr1在哪里？__<span style="color:#fe2c24;">A</span>__ * ptr1在哪里？__B__</p> 
</blockquote> 
<p><img alt="" height="757" src="https://images2.imgbox.com/4d/d6/XgOMVJBk_o.png" width="1200"></p> 
<h3 id="2.%20%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%9A%C2%A0">2. 填空题： </h3> 
<blockquote> 
 <p>sizeof(num1) = __40__; sizeof(char2) = __<span style="color:#fe2c24;">5</span>__; <br> strlen(char2) = __4__;sizeof(pChar3) = __8__;<br> strlen(pChar3) = __4__;sizeof(ptr1) = __8__; </p> 
</blockquote> 
<ul><li>sizeof(pChar3)：这个表达式返回的是指针变量pChar3的大小。指针的大小取决于平台和编译器，<span style="color:#fe2c24;">常见的是4字节（32位系统）或8字节（64位系统）</span>。我们在一个64位系统上，那么sizeof(pChar3)将是8字节。</li><li>strlen(pChar3)：这个函数返回的是pChar3指向的字符串的长度。由于pChar3指向的是字符串"abcd"，所以长度是4。填空处应写4。</li><li>sizeof(ptr1)：这个表达式返回的是指针变量ptr1的大小，和sizeof(pChar3)的情况一样，它取决于系统和编译器。</li></ul> 
<pre><code class="language-cpp">void test02()
{
	// 栈
	const int a = 0;
	int b = 0;
	cout &lt;&lt; &amp;a &lt;&lt; endl;
	cout &lt;&lt; &amp;b &lt;&lt; endl;

	const char* p = "11111111";
	cout &lt;&lt; (void*)p &lt;&lt; endl;
}</code></pre> 
<p><img alt="" height="325" src="https://images2.imgbox.com/d4/dd/IwTouK2I_o.png" width="1036"></p> 
<h3 id="3.%20sizeof%20%E5%92%8C%20strlen%20%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0">3. sizeof 和 strlen 区别？ </h3> 
<ul><li><code>sizeof</code>是一个编译时运算符，用于获取类型或对象在内存中的大小（以字节为单位）。</li><li><code>strlen</code>是一个运行时函数，用于计算C风格字符串的长度（不包括终止的null字符）。</li></ul> 
<p><img alt="" height="664" src="https://images2.imgbox.com/cc/79/BAsj7XIO_o.png" width="1200"></p> 
<p>【说明】</p> 
<ol><li>栈又叫堆栈--非静态局部变量 / 函数参数 / 返回值等等，栈是向下增长的。 </li><li>内存映射段是高效的I / O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。（Linux课程如果没学到这块，现在只需要了解一下） </li><li>堆用于程序运行时动态内存分配，堆是可以上增长的。 </li><li>数据段--存储全局数据和静态数据。 </li><li>代码段--可执行的代码 / 只读常量。</li></ol> 
<h2 id="%E4%BA%8C%E3%80%81%20C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9Amalloc%2Fcalloc%2Frealloc%2Ffree">二、 C语言中动态内存管理方式：malloc/calloc/realloc/free</h2> 
<pre><code class="language-cpp">void Test()
{
	int* p1 = (int*)malloc(sizeof(int));
	free(p1);

	// 1.malloc/calloc/realloc的区别是什么？
	int* p2 = (int*)calloc(4, sizeof(int));
	int* p3 = (int*)realloc(p2, sizeof(int) * 10);

	// 这里需要free(p2)吗？
	free(p3);
}</code></pre> 
<h3 id="%C2%A01.malloc%2Fcalloc%2Frealloc%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"> 1.malloc/calloc/realloc的区别是什么？</h3> 
<ul><li>malloc(size_t size): 为指定字节数的内存块分配空间，并返回指向它的指针。分配的内存块不会初始化，即其内容是不确定的。</li><li>calloc(size_t num, size_t size): 为指定数量和大小的内存块分配空间，并返回指向它的指针。与malloc不同，calloc还会初始化内存块，将其内容设置为0。</li><li>realloc(void* ptr, size_t newSize): 尝试调整之前已分配的内存块大小。ptr是原始内存块的指针，newSize是新的大小。如果调整成功，realloc返回一个新的指针，指向新的内存块；如果失败，返回NULL。</li></ul> 
<p>详细内容见：</p> 
<p><a href="https://blog.csdn.net/2301_79558858/article/details/135051527?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171867122116800215038441%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=171867122116800215038441&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-135051527-null-null.nonecase&amp;utm_term=%E5%86%85%E5%AD%98&amp;spm=1018.2226.3001.4450" title="动态内存分配（malloc和free​、calloc和realloc​）-CSDN博客">动态内存分配（malloc和free​、calloc和realloc​）-CSDN博客</a></p> 
<h3 id="2.%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81free(p2)%E5%90%97%EF%BC%9F">2.这里需要free(p2)吗？</h3> 
<p><strong>不需要，</strong>由于p3接收了realloc的返回值，因此你应该只释放p3，而不需要释放p2。这是<span style="color:#fe2c24;">因为如果realloc成功，p2指向的内存已经被realloc处理过了</span>（无论是被释放还是被重新分配）。</p> 
<h2 id="%E4%B8%89%E3%80%81C%2B%2B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F">三、C++内存管理方式</h2> 
<p>C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力，而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：<strong>通过new和delete操作符进行动态内存管理。</strong></p> 
<h3 id="3.1%20new%2Fdelete%E6%93%8D%E4%BD%9C%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">3.1 new/delete操作内置类型</h3> 
<p><strong>内置类型</strong>对象的申请和释放，<code>new</code>、<code>delete</code>和<code>malloc</code>、<code>free</code>除使用上，<strong>没有任何区别</strong>。</p> 
<pre><code class="language-cpp">void test03()
{
	// 内置类型
	// 动态申请一个int类型的空间
	int* ptr4 = new int;

	// 动态申请一个int类型的空间并初始化为10
	int* ptr5 = new int(10);

	// 动态申请10个int类型的空间
	int* ptr6 = new int[3];

	// 默认不初始化, 但是可以初始化
	int* ptr7 = new int[10] {1, 2, 3, 4};

	delete ptr4;
	delete ptr5;
	delete[] ptr6;
	delete ptr7;// 错误的释放操作
}</code></pre> 
<p><strong>错误释放操作的后果： </strong></p> 
<p><strong>如果内存分配系统没有特殊处理</strong>，<code>delete</code>可能会认为<code>ptr7</code>指向的只是一个单独的对象，从而<span style="color:#fe2c24;">只试图释放该内存块的第一部分</span>。这个操作的结果在某些情况下可能是没有释放整个数组，从而导致内存泄漏。   </p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/8d/42/gefjDiJ4_o.png" width="564"></p> 
<p>注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]，匹配起来使用。<strong>不然</strong><span style="color:#fe2c24;">内存管理系统的行为会导致未定义行为</span>，这样就会造成内存泄漏。</p> 
<p><img alt="" height="528" src="https://images2.imgbox.com/e1/6a/KytqYH5I_o.png" width="1200"></p> 
<h3 id="3.2%20new%E5%92%8Cdelete%E6%93%8D%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">3.2 new和delete操作自定义类型</h3> 
<p>我们可以看出new/delete 和 malloc/free最大区别是 new/delete对于<strong>自定义类型</strong>除了开辟空间还会调用构造函数和析构函数</p> 
<p><strong>测试类A：</strong></p> 
<pre><code class="language-cpp">class A
{
public:
	A(int a = 0)
		:_a(a)
	{
		cout &lt;&lt; "A(int a)" &lt;&lt; this &lt;&lt; endl;
	}

	A(int a1, int a2)
	{
		cout &lt;&lt; "A(int a1, int a2)" &lt;&lt; this &lt;&lt; endl;
	}

	A(const A&amp; aa)
		:_a(aa._a)
	{
		cout &lt;&lt; "A(const A&amp; aa)" &lt;&lt; this &lt;&lt; endl;
	}

	A&amp; operator=(const A&amp; aa)
	{
		cout &lt;&lt; "A&amp; operator=(const A&amp; aa)" &lt;&lt; this &lt;&lt; endl;
		if (this != &amp;aa)
		{
			_a = aa._a;
		}
		return *this;
	}

	~A()
	{
		cout &lt;&lt; "~A()" &lt;&lt; this &lt;&lt; endl;
	}

private:
	int _a;
};
</code></pre> 
<pre><code class="language-cpp">void test04()
{
	 自定义类型, new才能嗲用构造初始化, malloc不再适用
	//A* p1 = (A*)malloc(sizeof(A));
	 p1-&gt;_a = 0;
	 私有的,无法初始化

	//free(p1);

	// 开空间/是否空间, 还会调用构造和析构
	A* p2 = new A;
	A* p3 = new A(2);

	delete p2;
	delete p3;

	//A aa1(1);
	//A aa2(2);
	//A aa3(3);
	//A* p4 = new A[10]{ aa1,aa2,aa3 };
	
	A* p4 = new A[10]{ 1,2,3,4,5,{6,7} };
	delete[] p4;

	return ;
}</code></pre> 
<p><strong>注意：在申请自定义类型的空间时，new会调用构造函数，delete会调用析构函数，而malloc与free不会</strong> 。</p> 
<p><img alt="" height="413" src="https://images2.imgbox.com/36/ce/qk23Y2Th_o.png" width="620"></p> 
<p><img alt="" height="1028" src="https://images2.imgbox.com/a1/f2/3oKj4BFe_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B%E3%80%81operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%B2%E8%A7%A3%EF%BC%89">四、operator new与operator delete函数（重点讲解）</h2> 
<h3 id="4.1%20operator%20new%E4%B8%8Eoperator%20delete%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89">4.1 operator new与operator delete函数（重点）</h3> 
<p><strong>new和delete</strong>是用户进行<span style="color:#fe2c24;">动态内存申请和释放的操作符</span>，<strong>operator new 和operator delete</strong>是系统提供的<strong>全局函数</strong>，并且<strong>operator new和operator delete也不是对new和delete的重载</strong>，<strong>new在底层调用operator new</strong>全局函数来申请空间，<strong>delete在底层通过operator delete</strong>全局函数来释放空间。以下是operator new与operator delete函数的源代码：</p> 
<pre><code class="language-cpp">/*
operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间
失败，尝试执行空               间不足应对措施，如果改应对措施用户设置了，则继续申请，否
则抛异常。
*/
void* __CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)
{
	// try to allocate size bytes
	void* p;
	while ((p = malloc(size)) == 0)
		if (_callnewh(size) == 0)
		{
			// report no memory
			// 如果申请内存失败了，这里会抛出bad_alloc 类型异常
			static const std::bad_alloc nomem;
			_RAISE(nomem);
		}
	return (p);
}
/*
operator delete: 该函数最终是通过free来释放空间的
*/
void operator delete(void* pUserData)
{
	_CrtMemBlockHeader* pHead;
	RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
	if (pUserData == NULL)
		return;
	_mlock(_HEAP_LOCK);  /* block other threads */
	__TRY
		        /* get a pointer to memory block header */
		pHead = pHdr(pUserData);
	         /* verify block type */
	_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));
	_free_dbg(pUserData, pHead-&gt;nBlockUse);
	__FINALLY
		_munlock(_HEAP_LOCK);  /* release other threads */
	__END_TRY_FINALLY
		return;
}
/*
free的实现
*/
#define   free(p)               _free_dbg(p, _NORMAL_BLOCK)</code></pre> 
<p><strong>严格来说operator new 和 operator delete这两个函数不是重载，是在 C++ 中是特殊的全局函数</strong></p> 
<p>通过上述两个全局函数的实现知道，<strong>operator new 实际也是通过malloc来申请空间</strong>，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。<strong>operator delete 最终是通过free来释放空间的。</strong></p> 
<pre><code class="language-cpp">void test05()
{
	// operator new-&gt; (malloc) + 构造函数
	A* p2 = new A;

	// 析构释放的是A对象上需要清理的资源
	// 析构 + operator delete
	// delete释放的是p2指向的空间
	delete p2;

	stack&lt;int&gt;* p3 = new stack&lt;int&gt;;
	delete p3;

}</code></pre> 
<pre><code class="language-cpp">A* p2 = new A;</code></pre> 
<p><strong><code>new代码实现逻辑</code>： </strong></p> 
<pre><code class="language-cpp">void* rawMemory = operator new(sizeof(A)); // 类似于malloc，分配原始内存
A* p2 = new (rawMemory) A; // 在分配的内存上调用构造函数，构造对象
</code></pre> 
<p><code>new A</code>会执行以下几个步骤： </p> 
<ol><li><strong>调用<code>operator new</code></strong>：<code>new</code>运算符调用<code>operator new</code>，类似于C语言中的<code>malloc</code>，为<code>A</code>对象分配足够的内存。</li><li><strong>调用构造函数</strong>：分配内存后，<code>new</code>运算符会调用<code>A</code>类的构造函数来初始化对象。构造函数负责设置对象的初始状态。</li><li><strong>返回指针</strong>：<code>new</code>运算符返回指向分配内存的指针，这个指针指向新创建的<code>A</code>对象。</li></ol> 
<pre><code class="language-cpp">delete p2;
</code></pre> 
<p><strong>delete代码实现逻辑：</strong></p> 
<pre><code class="language-cpp">if (p2) {
    p2-&gt;~A(); // 手动调用析构函数
    operator delete(p2); // 释放内存
}
</code></pre> 
<p><code>delete p2</code>会执行以下几个步骤： </p> 
<ol><li><strong>调用析构函数</strong>：<code>delete</code>运算符首先调用<code>A</code>对象的析构函数，负责清理对象占用的资源（例如释放动态分配的内存、关闭文件等）。</li><li><strong>调用<code>operator delete</code></strong>：析构函数执行完毕后，<code>delete</code>运算符调用<code>operator delete</code>释放对象的内存，类似于<code>free</code>。</li></ol> 
<p><img alt="" height="595" src="https://images2.imgbox.com/21/0a/blP8Zyup_o.png" width="1200"></p> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">五、new和delete的实现原理</h2> 
<h3 id="5.1%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">5.1 内置类型</h3> 
<p>如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：<br> new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL。</p> 
<p>operator new 函数（底层还是使用malloc申请空间）是 new 的底层实现。<br> operator delete 函数（底层还是使用free释放空间）是 delete 的底层实现。<br> operator new[] 函数是 new 类型[ ]的实现。<br> operator delete[] 函数是 delete[] 的实现。</p> 
<pre><code class="language-cpp">// 结论: 不要错误匹配使用, 一定得匹配使用, 否则结果是不确定的
void test08()
{
	// A* p1 = new A;
	A* p2 = new A[10];// 44 or 40
	// 多开了四个字节用来存储内存大小(开辟空间的个数)
	// free(p2);
	// delete p2;
	delete[] p2;

	int* p3 = new int[10];// 40
	//free(p3);
}
</code></pre> 
<h4 id="%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E">示例说明</h4> 
<h5 id="%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B2%A1%E6%9C%89%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80%EF%BC%8840%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89">示例：没有额外开销（40个字节）</h5> 
<p>如果编译器没有添加额外的内存管理信息，那么内存分配仅仅是所需数据的大小：</p> 
<pre><code class="language-cpp">A* p2 = new A[10]; // 分配了10个A类型的对象 
// 如果sizeof(A) == 4，则总共需要 4 * 10 = 40 个字节</code></pre> 
<p>在这种情况下，总共分配的内存是40个字节。</p> 
<h5 id="%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9C%89%E9%A2%9D%E5%A4%96%E5%BC%80%E9%94%80%EF%BC%8844%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89">示例：有额外开销（44个字节）</h5> 
<p>如果编译器添加了4个字节的管理信息来记录数组的大小，那么总共分配的内存就是：</p> 
<pre><code class="language-cpp">A* p2 = new A[10]; // 分配了10个A类型的对象 
// 如果sizeof(A) == 4，管理信息额外4个字节，总共需要 40 + 4 = 44 个字节</code></pre> 
<p>在这种情况下，总共分配的内存是44个字节。</p> 
<h3 id="5.2%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%C2%A0">5.2 自定义类型 </h3> 
<ul><li><strong>new的原理</strong> 
  <ol><li>调用operator new函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ol></li><li><strong>delete的原理</strong> 
  <ol><li>在空间上执行析构函数，完成对象中资源的清理工作</li><li>调用operator delete函数释放对象的空间</li></ol></li><li><strong>new T[N]的原理</strong> 
  <ol><li>调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请</li><li>在申请的空间上执行N次构造函数</li></ol></li><li><strong>delete[]的原理</strong> 
  <ol><li>在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理</li><li>调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间</li></ol></li></ul> 
<p></p> 
<h2 id="%E5%85%AD%E3%80%81%E5%AE%9A%E4%BD%8Dnew%E8%A1%A8%E8%BE%BE%E5%BC%8F(placement-new)%20%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0">六、定位new表达式(placement-new) （了解） </h2> 
<p>定位new表达式是在<span style="color:#fe2c24;">已分配的原始内存空间中调用构造函数初始化一个对象。</span><br> 使用格式：<br><strong>new (place_address) type</strong>或者<strong>new (place_address) type(initializer-list)</strong><br><strong>place_address必须是一个指针，initializer-list是类型的初始化列表</strong><br><strong>使用场景：</strong><br> 定位new表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用new的定义表达式进行显示调构造函数进行初始化。</p> 
<pre><code class="language-cpp">class A
{
public:
	A(int a = 0)
		: _a(a)
	{
		cout &lt;&lt; "A():" &lt;&lt; this &lt;&lt; endl;
	}
	~A()
	{
		cout &lt;&lt; "~A():" &lt;&lt; this &lt;&lt; endl;
	}
private:
	int _a;
};

// 定位new/replacement new
int main()
{
	// p1现在指向的只不过是与A对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行
	A* p1 = (A*)malloc(sizeof(A));
	new(p1)A; // 注意：如果A类的构造函数有参数时，此处需要传参
	p1-&gt;~A();
	free(p1);
	A* p2 = (A*)operator new(sizeof(A));
	new(p2)A(10);
	p2-&gt;~A();
	operator delete(p2);
	return 0;
}
</code></pre> 
<pre><code class="language-cpp">	// p1现在指向的只不过是与A对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行
	A* p1 = (A*)malloc(sizeof(A));
	new(p1)A; // 注意：如果A类的构造函数有参数时，此处需要传参
	p1-&gt;~A();
	free(p1);</code></pre> 
<p> 使用malloc为A对象分配内存，地址存于p1。此时，这块内存还不是有效的A对象，因构造函数未调用。接着，用定位new在p1内存上调用A的构造函数，使p1指向有效A对象。若A构造函数需参数，则此处需传递。然后，手动调用析构函数销毁对象，并释放malloc分配的内存。</p> 
<pre><code class="language-cpp">	A* p2 = (A*)operator new(sizeof(A));
	new(p2)A(10);
	p2-&gt;~A();
	operator delete(p2);</code></pre> 
<p></p> 
<p>之后，使用operator new分配内存，地址存于p2。在p2指向的内存上使用定位new调用A的构造函数，并传参10，使p2指向有效A对象。同样，手动调用析构函数销毁对象，并使用operator delete释放内存。</p> 
<ul><li> <p><strong>构造函数</strong>：</p> 
  <ul><li><code>A(int a = 0)</code>: 这是一个构造函数，接收一个整数参数<code>a</code>（默认为<code>0</code>），用于初始化私有成员变量<code>_a</code>。</li><li><code>cout &lt;&lt; "A():" &lt;&lt; this &lt;&lt; endl;</code>: 输出对象构造时的地址信息，方便观察对象的构造过程。</li></ul></li><li> <p><strong>析构函数</strong>：</p> 
  <ul><li><code>~A()</code>: 这是析构函数，输出对象析构时的地址信息，用于观察对象的销毁过程。</li></ul></li></ul> 
<pre><code class="language-cpp">void test09()
{
	// A* p1 = new A;
	//A* p1 = MemoryPool.Alloc(sizeof(A));
	A* p1 = (A*)operator new(sizeof(A));
	// 不支持这样显示调用构造
	
	//p1-&gt;A();// 不能这样显示的调用构造
	//new(p1)A;// 对已有空间，显示调用构造
	//new(p1)A(10);//对已有空间，显示调用构造
	//new(p1)A[10]{ 1,2,3,4 };// 对已有空间，显示调用构造

	// A* p1 = pool.alloc(sizeof(A));
	new(p1)A(10);// 对已有空间，显示调用构造

	// delete p1
	// p1-&gt;~A();
	operator delete(p1);
	// free(p1);

	// new []
	A* p2 = (A*)operator new(sizeof(A) * 10);
	int n = 10;
	for (int i = 0; i &lt; n; i++)
		new(p2 + i)A(10);
	// 对已有空间，显示调用构造

	// delete[]
	for (int i = 0; i &lt; 10; i++)
	{
		(p2 + i)-&gt;~A();
	}
	operator delete[](p2);

}
</code></pre> 
<pre><code class="language-cpp">    // A* p1 = new A;
    // A* p1 = MemoryPool.Alloc(sizeof(A));
    A* p1 = (A*)operator new(sizeof(A));
    // 不支持这样显式调用构造
    
    // p1-&gt;A(); // 不能这样显式的调用构造
    new(p1)A; // 对已有空间，显式调用构造
    new(p1)A(10); // 对已有空间，显式调用构造
    new(p1)A[10]{ 1,2,3,4 }; // 对已有空间，显式调用构造</code></pre> 
<ul><li><code>new(p1)A</code>和<code>new(p1)A(10)</code>是定位<code>new</code>的用法。</li><li>定位<code>new</code>允许我们在已有的内存空间上显式地调用构造函数。</li><li>这意味着我们在<code>p1</code>指向的内存上直接构造一个<code>A</code>对象（或带参数<code>10</code>的<code>A</code>对象）。</li><li><code>new(p1)A;</code>：调用默认构造函数。</li><li><code>new(p1)A(10);</code>：调用带参数的构造函数，初始化对象。</li></ul> 
<p> <strong>手动管理内存和对象生命周期</strong></p> 
<pre><code class="language-cpp">	// new []
	A* p2 = (A*)operator new(sizeof(A) * 10);
	int n = 10;
	for (int i = 0; i &lt; n; i++)
		new(p2 + i)A(10);
	// 对已有空间，显示调用构造

	// delete[]
	for (int i = 0; i &lt; 10; i++)
	{
		(p2 + i)-&gt;~A();
	}
	operator delete[](p2);</code></pre> 
<p><strong>定位<code>new</code></strong>：</p> 
<ul><li><code>new(p2 + i)A(10)</code>在<code>p2 + i</code>指向的内存位置上显式调用<code>A</code>的构造函数，传递参数<code>10</code>。其中<code>p2 + i</code>表示指针<code>p2</code>加上<code>i</code>个<code>A</code>对象的偏移量，指向第<code>i</code>个<code>A</code>对象的位置。</li><li>这意味着在<code>p2</code>指向的内存上，依次构造10个带参数<code>10</code>的<code>A</code>对象。</li></ul> 
<p>通过手动分配内存并在其中构造对象，可以减少内存分配和释放的频率，从而提高性能。常规的<code>new[]</code>操作需要两步：首先分配内存，然后调用构造函数初始化对象。而使用定位<code>new</code>只需要分配一次内存，然后在已有的内存上进行初始化。</p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/69/9c/mDDQvqdm_o.png" width="1200"></p> 
<p></p> 
<p> <img alt="" height="571" src="https://images2.imgbox.com/f8/d0/JG0PU94F_o.png" width="608"></p> 
<h2 id="%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0">七、常见面试题 </h2> 
<h3 id="7.1%20malloc%2Ffree%E5%92%8Cnew%2Fdelete%E7%9A%84%E5%8C%BA%E5%88%AB" style="background-color:transparent;">7.1 malloc/free和new/delete的区别</h3> 
<p>malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。不同的地方是：</p> 
<ol><li>malloc和free是函数，new和delete是操作符</li><li>malloc申请的空间不会初始化，new可以初始化</li><li>malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可， 如果是多个对象，[]中指定对象个数即可</li><li>malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型</li><li>malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常</li><li>申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理</li></ol> 
<h3 id="7.2%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">7.2 内存泄漏</h3> 
<h4 id="7.2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3%C2%A0">7.2.1 什么是内存泄漏，内存泄漏的危害 </h4> 
<p>什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，<span style="color:#fe2c24;">因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费</span>。</p> 
<p>内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。</p> 
<pre><code class="language-cpp">void MemoryLeaks()
{
   // 1.内存申请了忘记释放
  int* p1 = (int*)malloc(sizeof(int));
  int* p2 = new int;
  
  // 2.异常安全问题
  int* p3 = new int[10];
  
  Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.
  
  delete[] p3;
}
</code></pre> 
<pre><code class="language-cpp">   // 1.内存申请了忘记释放
  int* p1 = (int*)malloc(sizeof(int));
  int* p2 = new int;</code></pre> 
<ul><li><code>p1</code>和<code>p2</code>分别通过<code>malloc</code>和<code>new</code>动态分配了内存。</li><li>由于在函数末尾缺少相应的<code>free</code>和<code>delete</code>操作，这些内存无法被释放，导致内存泄漏。</li></ul> 
<pre><code class="language-cpp">int* p3 = new int[10];

Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.

delete[] p3;
</code></pre> 
<ul><li><code>p3</code>通过<code>new</code>分配了一个包含10个整数的数组。</li><li>如果<code>Func()</code>函数抛出异常，<code>delete[] p3</code>这行代码将不会被执行，导致内存泄漏。</li></ul> 
<h4 id="7.2.2%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0">7.2.2 内存泄漏分类（了解） </h4> 
<p>C/C++程序中一般我们关心两种方面的内存泄漏：</p> 
<ul><li><strong>堆内存泄漏(Heap leak) </strong></li></ul> 
<p>堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，<span style="color:#fe2c24;">用完后必须通过调用相应的 free或者delete 删掉</span>。<span style="color:#0d0016;">假设程序的设计错误导致这部分内存没有被释放</span>，那么以后这部分空间将无法再被使用，就会产生Heap Leak。</p> 
<ul><li><strong>系统资源泄漏</strong></li></ul> 
<p>指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 </p> 
<h4 id="7.2.3%20%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89%C2%A0">7.2.3 如何检测内存泄漏（了解） </h4> 
<p>在vs下，可以使用windows操作系统提供的_CrtDumpMemoryLeaks() 函数进行简单检测，该函数只报出了大概泄漏了多少个字节，没有其他更准确的位置信息。</p> 
<pre><code class="language-cpp">int main()
{
 int* p = new int[10];
 // 将该函数放在main函数之后，每次程序退出的时候就会检测是否存在内存泄漏
 _CrtDumpMemoryLeaks();
 return 0;
}

// 程序退出后，在输出窗口中可以检测到泄漏了多少字节，但是没有具体的位置
Detected memory leaks!
Dumping objects -&gt;
{79} normal block at 0x00EC5FB8, 40 bytes long.
Data: &lt;                &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
Object dump complete.</code></pre> 
<h3 id="7.2.4%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%C2%A0">7.2.4如何避免内存泄漏 </h3> 
<ol><li>工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps：这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。</li><li>采用RAII思想或者智能指针来管理资源。</li><li>有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。</li><li>出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。</li></ol> 
<p>总结一下:<br> 内存泄漏非常常见，解决方案分为两种：</p> 
<p>1、事前预防型。如智能指针等。</p> 
<p>2、事后查错型。如泄漏检测工具。</p> 
<p>今天就先到这了！！！</p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/8f/a8/XBZBSXIO_o.png" width="1200"></p> 
<p>看到这里了还不给博主扣个：<br> ⛳️ 点赞☀️收藏 ⭐️ 关注！</p> 
<p>你们的点赞就是博主更新最大的动力！<br> 有问题可以评论或者私信呢秒回哦。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb626a644cb94c398236d055338d8af5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL：SELECT list is not in GROUP BY clause 报错 解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdde8ccf0fa83db82ca7a694af57c05a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解Qt中connect()函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>