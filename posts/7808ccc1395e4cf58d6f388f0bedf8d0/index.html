<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>列表和列表项 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7808ccc1395e4cf58d6f388f0bedf8d0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="列表和列表项">
  <meta property="og:description" content="一、列表和列表项简介 列表是 FreeRTOS 中的一个数据结构，列表被用来跟踪 FreeRTOS中的任务（任务当前的状态），列表项就是存放在列表中的项目 列表相当于链表，列表项相当于节点，FreeRTOS 中的列表是一个双向循环链表 列表项间的地址非连续的，列表项的数目随时可以改变
列表项的指向前一个、后一个指针，就相当于人的左右手，整个列表就相当于N个人互相拉着手，围成一个圈，而列表是管理这个圈
二、 列表与列表项 2.1 列表结构体 typedef struct xLIST { listFIRST_LIST_INTEGRITY_CHECK_VALUE	/* 校验值 */ volatile UBaseType_t uxNumberOfItems;	/* 列表中的列表项数量 */ ListItem_t * configLIST_VOLATILE pxIndex	/* 用于遍历列表项的指针 */ MiniListItem_t xListEnd	/* 末尾列表项 */ listSECOND_LIST_INTEGRITY_CHECK_VALUE	/* 校验值 */ } List_t; 成员说明：
成员描述 listFIRST_LIST_INTEGRITY_CHECK_VALUE
listSECOND_LIST_INTEGRITY_CHECK_VALUE
具有确定已知常量的宏
FreeRTOS通过检查这两个常量的值，来判断列表的数据在程序运行过程中，是否遭到破坏 ，该功能一般用于调试， 默认是不开启的
uxNumberOfItems用于记录列表中列表项的个数（不包含 xListEnd）pxIndex用于指向列表中的某个列表项，一般用于遍历列表中的所有列表项 xListEnd一个迷你列表项，排在最末尾 列表结构示意图： 2.2 列表项结构体 struct xLIST_ITEM { listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	/* 用于检测列表项的数据完整性 */ configLIST_VOLATILE TickType_t xItemValue	/* 列表项的值 */ struct xLIST_ITEM * configLIST_VOLATILE pxNext	/* 下一个列表项 */ struct xLIST_ITEM * configLIST_VOLATILE pxPrevious /* 上一个列表项 */ void * pvOwner	/* 列表项的拥有者 */ struct xLIST * configLIST_VOLATILE pxContainer; /* 列表项所在列表 */ listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE	/* 用于检测列表项的数据完整性*/ }; typedef struct xLIST_ITEM ListItem_t; 成员说明：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-02T11:39:45+08:00">
    <meta property="article:modified_time" content="2024-06-02T11:39:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">列表和列表项</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、列表和列表项简介</h2> 
<p><span style="color:#002060;">      </span><span style="color:#0d0016;">  列表是 FreeRTOS 中的一个数据结构，列表被用来跟踪 FreeRTOS中的任务（</span><span style="color:#fe2c24;">任务当前的状态</span><span style="color:#0d0016;">），列表项就是存放在列表中的项目 </span></p> 
<p><img alt="" height="392" src="https://images2.imgbox.com/f3/de/LZU9nA0d_o.png" width="847"></p> 
<p><span style="color:#002060;">       </span><span style="color:#0d0016;"> 列表相当于链表，列表项相当于节点，FreeRTOS 中的列表是一个</span><span style="color:#fe2c24;">双向循环链表  </span></p> 
<p><span style="color:#0d0016;">        列表项间的</span><span style="color:#fe2c24;">地址非连续</span><span style="color:#0d0016;">的，列表项的</span><span style="color:#fe2c24;">数目</span><strong><span style="color:#0d0016;">随时可以改变</span></strong></p> 
<p>        列表项的<strong>指向前一个、后一个指针</strong>，就相当于<strong>人的左右手</strong>，整个列表就相当于N个人互相拉着手，围<strong>成一个圈，</strong>而列表是管理这个圈</p> 
<p><strong><span style="color:#0d0016;">        </span></strong></p> 
<h2><span style="color:#0d0016;">二、 列表与列表项</span></h2> 
<h3 style="background-color:transparent;"><span style="color:#0d0016;">2.1 列表结构体</span></h3> 
<pre><code>typedef struct xLIST
{
  	 listFIRST_LIST_INTEGRITY_CHECK_VALUE		    /* 校验值 */
   	 volatile UBaseType_t uxNumberOfItems;			/* 列表中的列表项数量 */
   	 ListItem_t * configLIST_VOLATILE pxIndex		/* 用于遍历列表项的指针 */
   	 MiniListItem_t xListEnd					    /* 末尾列表项 */
   	 listSECOND_LIST_INTEGRITY_CHECK_VALUE		    /* 校验值 */
} List_t;
</code></pre> 
<p>成员说明：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;">成员</td><td style="text-align:center;">描述</td></tr><tr><td> <p style="text-align:center;"><span style="color:#0d0016;">listFIRST_LIST_INTEGRITY_CHECK_VALUE</span></p> <p style="text-align:center;"><span style="color:#0d0016;">listSECOND_LIST_INTEGRITY_CHECK_VALUE</span></p> </td><td> <p style="text-align:center;"><span style="color:#0d0016;">具有确定已知常量的宏</span></p> <p style="text-align:center;"><span style="color:#0d0016;">FreeRTOS通过检查这两个常量的值，来判断列表的数据在程序运行过程中，是否遭到破坏 ，该功能一般用于调试， 默认是不开启的</span></p> </td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">uxNumberOfItems</span></td><td style="text-align:center;"><span style="color:#0d0016;">用于记录列表中</span><span style="color:#ff9900;">列表项的个数</span><span style="color:#0d0016;">（</span><span style="color:#fe2c24;">不包含 xListEnd</span><span style="color:#0d0016;">）</span></td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">pxIndex</span></td><td style="text-align:center;"><span style="color:#0d0016;">用于</span><span style="color:#fe2c24;">指向列表中的某个列表项</span><span style="color:#0d0016;">，一般</span><span style="color:#fe2c24;">用于遍历列表</span><span style="color:#0d0016;">中的所有列表项 </span></td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">xListEnd</span></td><td style="text-align:center;"><span style="color:#0d0016;">一个</span><span style="color:#fe2c24;">迷你列表项</span><span style="color:#0d0016;">，</span><span style="color:#fe2c24;">排在最末尾 </span></td></tr></tbody></table> 
<p>列表结构示意图： </p> 
<p class="img-center"><img alt="" height="473" src="https://images2.imgbox.com/50/b8/em6XvaZp_o.png" width="304"></p> 
<h3 style="background-color:transparent;">2.2 列表项结构体</h3> 
<pre><code>struct xLIST_ITEM
{
    	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/* 用于检测列表项的数据完整性 */
    	configLIST_VOLATILE TickType_t xItemValue			/* 列表项的值 */
     	struct xLIST_ITEM * configLIST_VOLATILE pxNext		/* 下一个列表项 */
  	    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious  /* 上一个列表项 */
    	void * pvOwner							            /* 列表项的拥有者 */
    	struct xLIST * configLIST_VOLATILE pxContainer; 	/* 列表项所在列表 */
    	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/* 用于检测列表项的数据完整性*/
};
typedef struct xLIST_ITEM ListItem_t; </code></pre> 
<p>成员说明：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><span style="color:#0d0016;">成员</span></td><td style="text-align:center;"><span style="color:#0d0016;">描述</span></td></tr><tr><td> <p style="text-align:center;"><span style="color:#0d0016;">listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</span></p> <p style="text-align:center;"><span style="color:#0d0016;">listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALU</span></p> </td><td style="text-align:center;"><span style="color:#0d0016;">用于检测列表项的数据完整性</span></td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">xItemValue</span></td><td style="text-align:center;"><span style="color:#0d0016;"><strong>列表项的值</strong>，多用于将列表中的列表项按</span><span style="color:#fe2c24;">升序排序 </span></td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">pxNext</span></td><td style="text-align:center;"><span style="color:#0d0016;">指向列表中列表项的下一个列表项</span></td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">pxPrevious</span></td><td style="text-align:center;"><span style="color:#0d0016;">指向列表中列表项的上一个列表项 </span></td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">pvOwner</span></td><td style="text-align:center;"><span style="color:#0d0016;">用于<strong>指向包含列表项的对象</strong>（通常是</span><span style="color:#fe2c24;">任务控制块</span><span style="color:#0d0016;">） </span></td></tr><tr><td style="text-align:center;"><span style="color:#0d0016;">pxContainer</span></td><td style="text-align:center;"><span style="color:#0d0016;">用于<strong>指向列表项所在列表</strong></span></td></tr></tbody></table> 
<p>列表项结构示意图： </p> 
<p class="img-center"><img alt="" height="346" src="https://images2.imgbox.com/f1/ac/dX2932Yp_o.png" width="281"></p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/77/d0/2Aedm7qF_o.png" width="1200"></p> 
<h3 style="background-color:transparent;"> 2.3 迷你列表项（末尾列表项）</h3> 
<p style="text-align:left;"><span style="color:#0d0016;">迷你列表项也是列表项，但迷你列表项仅用于</span><span style="color:#fe2c24;">标记列表的末尾</span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;">挂载其他插入列表中的列表项</span><span style="color:#0d0016;">（将<strong>要插入的列表项连接在一起</strong>）</span></p> 
<pre><code>struct xMINI_LIST_ITEM
{
    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE 			   /* 用于检测数据完整性 */
	configLIST_VOLATILE TickType_t xItemValue;			   /* 列表项的值 */
    struct xLIST_ITEM * configLIST_VOLATILE pxNext;		   /* 上一个列表项 */
   	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;    /* 下一个列表项 */
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;
</code></pre> 
<p>成员说明： </p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>成员</td><td>描述</td></tr><tr><td>listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE</td><td>用于检测数据完整性</td></tr><tr><td><span style="color:#c55a11;">xItemValue</span></td><td>列表项的值，<span style="color:#002060;">多用于按升序对列表中的列表项进行排序 </span></td></tr><tr><td> <p><span style="color:#c55a11;">pxNext</span></p> <p><span style="color:#c55a11;">pxPrevious</span></p> </td><td><span style="color:#002060;">用于指向列表中列表项的下一个列表项和上一个列表项 </span></td></tr></tbody></table> 
<p>        与正常列表项，缺少<strong>列表项拥有者、列表项所在列表</strong>成员 ，以节省内存开销</p> 
<p>迷你列表项结构示意图：</p> 
<p class="img-center"><img alt="" height="272" src="https://images2.imgbox.com/62/b5/Mbfkb3R3_o.png" width="300"></p> 
<h2>三、列表相关API函数</h2> 
<table border="1" cellspacing="0" style="width:464pt;"><tbody><tr><td style="background-color:#4472c4;border-color:#ffffff;text-align:center;vertical-align:middle;width:195pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#ffffff;"><strong>函数</strong></span></p> </td><td style="background-color:#4472c4;border-color:#ffffff;text-align:center;vertical-align:middle;width:269pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#ffffff;"><strong>描述</strong></span></p> </td></tr><tr><td style="background-color:#cfd5ea;border-color:#ffffff;vertical-align:middle;width:195pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">vListInitialise</span><span style="color:#002060;">() </span></p> </td><td style="background-color:#cfd5ea;border-color:#ffffff;vertical-align:middle;width:269pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">初始化列表</span></p> </td></tr><tr><td style="background-color:#e9ebf5;border-color:#ffffff;vertical-align:middle;width:195pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">vListInitialiseItem</span><span style="color:#002060;">() </span></p> </td><td style="background-color:#e9ebf5;border-color:#ffffff;vertical-align:middle;width:269pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">初始化列表项</span></p> </td></tr><tr><td style="background-color:#cfd5ea;border-color:#ffffff;vertical-align:middle;width:195pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">vListInsertEnd() </span></p> </td><td style="background-color:#cfd5ea;border-color:#ffffff;vertical-align:middle;width:269pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">列表</span><span style="color:#fe2c24;">末尾插入</span><span style="color:#002060;">列表项</span></p> </td></tr><tr><td style="background-color:#e9ebf5;border-color:#ffffff;vertical-align:middle;width:195pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">vListInsert() </span></p> </td><td style="background-color:#e9ebf5;border-color:#ffffff;vertical-align:middle;width:269pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">列表插入列表项（</span><span style="color:#fe2c24;">升序插入</span><span style="color:#002060;">）</span></p> </td></tr><tr><td style="background-color:#cfd5ea;border-color:#ffffff;vertical-align:middle;width:195pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">uxListRemove</span><span style="color:#002060;">() </span></p> </td><td style="background-color:#cfd5ea;border-color:#ffffff;vertical-align:middle;width:269pt;"> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">列表移除列表项</span></p> </td></tr></tbody></table> 
<p> </p> 
<h3>3.1 初始化列表：vListInitialise( )</h3> 
<pre><code>void vListInitialise( List_t * const pxList )
{
    /*  初始化时，列表中只有 xListEnd，因此 pxIndex 指向 xListEnd */
    pxList-&gt;pxIndex = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); 
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &amp;( pxList-&gt;xListEnd ) );

    /* xListEnd 的值初始化为最大值，用于列表项升序排序时，排在最后 */
    pxList-&gt;xListEnd.xItemValue = portMAX_DELAY;

    /* 初始化时，列表中只有 xListEnd，因此上一个和下一个列表项都为 xListEnd 本身 */
    pxList-&gt;xListEnd.pxNext = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );    
    pxList-&gt;xListEnd.pxPrevious = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); 

    /* 初始化时，列表中的列表项数量为 0（不包含 xListEnd） */
    pxList-&gt;uxNumberOfItems = ( UBaseType_t ) 0U;

    /* 检查数据的完整性 */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}</code></pre> 
<p>参数说明： </p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;">参数</td><td style="text-align:center;">说明</td></tr><tr><td style="text-align:center;">pxList</td><td style="text-align:center;">待初始化的列表</td></tr></tbody></table> 
<p>列表初始化后的结构示意图： </p> 
<p class="img-center"><img alt="" height="651" src="https://images2.imgbox.com/ba/db/Aj343VO3_o.png" width="438"></p> 
<h3><span style="color:#0d0016;">3.2 列表项初始化：vListInitialiseItem()</span></h3> 
<pre><code>void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* 初始化时，列表项所在列表设为空  */
    pxItem-&gt;pxContainer = NULL;

    /* 初始化用于检测列表项数据完整性的校验值  */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}</code></pre> 
<p>        其他成员变量根据实际使用情况进行初始化 </p> 
<p>参数说明： </p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>参数</td><td>说明</td></tr><tr><td>pxItem</td><td>待初始化的列表项</td></tr></tbody></table> 
<p>列表初始化后的结构示意图： </p> 
<p class="img-center"><img alt="" height="572" src="https://images2.imgbox.com/88/3c/2s7PjL48_o.png" width="413"></p> 
<h3 style="background-color:transparent;">3.3 列表插入列表项（升序插入）：vListInsert()</h3> 
<p>函数功能：<span style="color:#0d0016;">将待插入列表的列表项按照列表项值</span><span style="color:#fe2c24;">升序插入</span><span style="color:#0d0016;">，</span><span style="color:#fe2c24;">有序</span><span style="color:#0d0016;">地插入到列表中</span></p> 
<pre><code>void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    /*获取列表项的数值依据数值升序排列 */
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue;

    /* 检查参数是否正确  */
    listTEST_LIST_INTEGRITY( pxList );
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* 如果待插入列表项的值为最大值，插入的位置为列表 xListEnd 前面  */
    if( xValueOfInsertion == portMAX_DELAY )
    {
        pxIterator = pxList-&gt;xListEnd.pxPrevious;
    }
    else
    {
       /*遍历列表中的列表项，找到插入的位置*/ 
        for( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion; pxIterator = pxIterator-&gt;pxNext ) 
           
        }
    }
    /* 将待插入的列表项插入指定位置 */ 
    pxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext;
    pxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem;
    pxNewListItem-&gt;pxPrevious = pxIterator;
    pxIterator-&gt;pxNext = pxNewListItem;

    /*更新待插入列表项所在列表  */
    pxNewListItem-&gt;pxContainer = pxList;
    
    /* 更新列表中列表项的数量 */ 
    ( pxList-&gt;uxNumberOfItems )++;
}</code></pre> 
<p> 参数说明：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;">参数</td><td style="text-align:center;">说明</td></tr><tr><td> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">pxList </span></p> </td><td style="text-align:center;">列表</td></tr><tr><td> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">pxNewListItem</span></p> </td><td style="text-align:center;">待插入列表项</td></tr></tbody></table> 
<p></p> 
<h3 style="background-color:transparent;"><span style="color:#0d0016;">3.4 列表末尾插入： vListInsertEnd()</span></h3> 
<p>函数功能：<span style="color:#002060;">将待插入列表的列表项插入到</span><span style="color:#0d0016;">列表</span><span style="color:#002060;"> </span><span style="color:#ff0000;">pxIndex</span> <span style="color:#ff0000;">指针指向的列表项前面</span><span style="color:#0d0016;">（初始化时：pxIndex指向迷你列表项）</span><span style="color:#002060;">，是一种</span><span style="color:#fe2c24;">无序</span><span style="color:#002060;">的插入方法</span> </p> 
<pre><code>void vListInsertEnd (  List_t * const pxList ,   ListItem_t * const pxNewListItem  )
{
	 /* 获取列表 pxIndex 指向的列表项 */
	ListItem_t * const pxIndex = pxList-&gt;pxIndex;

	/* 更新待插入列表项的指针成员变量 */	
    pxNewListItem-&gt;pxNext = pxIndex;	
    pxNewListItem-&gt;pxPrevious = pxIndex-&gt;pxPrevious;
 	
    /* 更新列表中原本列表项的指针成员变量 */	
    pxIndex-&gt;pxPrevious-&gt;pxNext = pxNewListItem;
    pxIndex-&gt;pxPrevious = pxNewListItem;

    /* 更新待插入列表项的所在列表成员变量 */	
    pxNewListItem-&gt;pxContainer = pxList;

    /* 更新列表中列表项的数量 */
    ( pxList-&gt;uxNumberOfItems )++;
} 
</code></pre> 
<p>参数说明：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;">参数</td><td style="text-align:center;">说明</td></tr><tr><td> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">pxList </span></p> </td><td style="text-align:center;">列表</td></tr><tr><td> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">pxNewListItem</span></p> </td><td style="text-align:center;">待插入列表项</td></tr></tbody></table> 
<p></p> 
<p></p> 
<h3><span style="color:#0d0016;">2.5 移出列表项：uxListRemove()</span></h3> 
<pre><code>UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) 
{
	List_t * const pxList = pxItemToRemove-&gt;pxContainer; 

    /* 从列表中移除列表项 */ 
	pxItemToRemove-&gt;pxNext-&gt;pxPrevious = pxItemToRemove-&gt;pxPrevious;
	pxItemToRemove-&gt;pxPrevious-&gt;pxNext = pxItemToRemove-&gt;pxNext; 	
 
    /*如果 pxIndex 正指向待移除的列表项 */ 
	if( pxList-&gt;pxIndex == pxItemToRemove ) 
	{
        /*pxIndex 指向上一个列表项*/ 
	 	pxList-&gt;pxIndex = pxItemToRemove-&gt;pxPrevious;
	} 
    else 
	{ 
		mtCOVERAGE_TEST_MARKER(); 
	} 

    /*将待移除的列表项的所在列表指针清空*/ 
	pxItemToRemove-&gt;pxContainer = NULL; 

    /*更新列表中列表项的数量*/ 
	( pxList-&gt;uxNumberOfItems )--; 

	return pxList-&gt;uxNumberOfItems; 
}

</code></pre> 
<p>参数说明：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;">参数</td><td style="text-align:center;">说明</td></tr><tr><td style="text-align:center;">pxItemToRemove</td><td style="text-align:center;">待移出的列表项</td></tr><tr><td> <p style="margin-left:0in;text-align:center;"><span style="color:#002060;">返回值</span></p> </td><td style="text-align:center;">移除后，列表剩余的列表项数量</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/742816895d2e7db8b7efadbc23363f25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【深入学习Redis丨第二篇】Redis集群部署详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6832eb0c8be73d4e064ba877f4c07953/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法学习笔记——对数器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>