<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【前端缓存】localStorage是同步还是异步的？为什么？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/099ba5096bba8b06b65a5a581d5d7247/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【前端缓存】localStorage是同步还是异步的？为什么？">
  <meta property="og:description" content="写在开头 点赞 &#43; 收藏 === 学会
首先明确一点，localStorage是同步的
一、首先为什么会有这样的问题 localStorage 是 Web Storage API 的一部分，它提供了一种存储键值对的机制。localStorage 的数据是持久存储在用户的硬盘上的，而不是内存。这意味着即使用户关闭浏览器或电脑，localStorage 中的数据也不会丢失，除非主动清除浏览器缓存或者使用代码删除。
当你通过 JavaScript 访问 localStorage 时，浏览器会从硬盘中读取数据或向硬盘写入数据。然而，在读写操作期间，数据可能会被暂时存放在内存中，以提高处理速度。但主要的特点是它的持久性，以及它不依赖于会话的持续性。
二、硬盘不是io设备吗？io读取不都是异步的吗？ 是的，硬盘确实是一个 IO 设备，而大部分与硬盘相关的操作系统级IO操作确实是异步进行的，以避免阻塞进程。不过，在 Web 浏览器环境中，localStorage 的API是设计为同步的，即使底层的硬盘读写操作有着IO的特性。
js代码在访问 localStorage 时，浏览器提供的API接口通常会处于js执行线程上下文中直接调用。这意味着尽管硬盘是IO设备，当一个js执行流程访问 localStorage 时，它将同步地等待数据读取或写入完成，该过程中js执行线程会阻塞。
这种同步API设计意味着开发者在操作 localStorage 时不需要考虑回调函数或者Promise等异步处理模式，可以按照同步代码的方式来编写。不过，这也意味着如果涉及较多数据的读写操作时，可能对性能产生负面影响，特别是在主线程上，因为它会阻塞UI的更新和其他js的执行。
三、完整操作流程 localStorage 实现同步存储的方式就是阻塞 JavaScript 的执行，直到数据的读取或者写入操作完成。这种同步操作的实现可以简单概述如下：
js线程调用: 当 JavaScript 代码执行一个 localStorage 的操作，比如 localStorage.getItem(&#39;key&#39;) 或 localStorage.setItem(&#39;key&#39;, &#39;value&#39;)，这个调用发生在 js 的单个线程上。浏览器引擎处理: 浏览器的 js 引擎接收到调用请求后，会向浏览器的存储子系统发出同步IO请求。此时 js 引擎等待IO操作的完成。文件系统的同步IO: 浏览器存储子系统对硬盘执行实际的存储或检索操作。尽管操作系统层面可能对文件访问进行缓存或优化，但从浏览器的角度看，它会进行一个同步的文件系统操作，直到这个操作返回结果。操作完成返回: 一旦IO操作完成，数据要么被写入硬盘，要么被从硬盘读取出来，浏览器存储子系统会将结果返回给 js 引擎。JavaScript线程继续执行: js 引擎在接收到操作完成的信号后，才会继续执行下一条 js 代码。 在同步的 localStorage 操作期间，由于 js 的单线程性质，整个线程会阻塞，即不会执行其他任何js代码，也不会进行任何渲染操作，直到 localStorage 调用返回。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-23T11:02:54+08:00">
    <meta property="article:modified_time" content="2024-04-23T11:02:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【前端缓存】localStorage是同步还是异步的？为什么？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>写在开头</h2> 
<p>点赞 + 收藏 === 学会</p> 
<blockquote> 
 <p>首先明确一点，localStorage是同步的</p> 
</blockquote> 
<h2> 一、首先为什么会有这样的问题</h2> 
<p>localStorage 是 Web Storage API 的一部分，它提供了一种存储键值对的机制。localStorage 的数据是持久存储在用户的硬盘上的，而不是内存。这意味着即使用户关闭浏览器或电脑，localStorage 中的数据也不会丢失，除非主动清除浏览器缓存或者使用代码删除。</p> 
<p>当你通过 JavaScript 访问 localStorage 时，浏览器会从硬盘中读取数据或向硬盘写入数据。然而，在读写操作期间，数据可能会被暂时存放在内存中，以提高处理速度。但主要的特点是它的持久性，以及它不依赖于会话的持续性。</p> 
<h2> 二、硬盘不是io设备吗？io读取不都是异步的吗？</h2> 
<p>是的，硬盘确实是一个 IO 设备，而大部分与硬盘相关的操作系统级IO操作确实是异步进行的，以避免阻塞进程。不过，在 Web 浏览器环境中，localStorage 的API是设计为同步的，即使底层的硬盘读写操作有着IO的特性。</p> 
<p>js代码在访问 localStorage 时，浏览器提供的API接口通常会处于js执行线程上下文中直接调用。这意味着尽管硬盘是IO设备，当一个js执行流程访问 localStorage 时，它将同步地等待数据读取或写入完成，该过程中js执行线程会阻塞。</p> 
<p>这种同步API设计意味着开发者在操作 localStorage 时不需要考虑回调函数或者Promise等异步处理模式，可以按照同步代码的方式来编写。不过，这也意味着如果涉及较多数据的读写操作时，可能对性能产生负面影响，特别是在主线程上，因为它会阻塞UI的更新和其他js的执行。</p> 
<h2> 三、完整操作流程</h2> 
<p>localStorage 实现同步存储的方式就是阻塞 JavaScript 的执行，直到数据的读取或者写入操作完成。这种同步操作的实现可以简单概述如下：</p> 
<ol><li><strong>js线程调用</strong>: 当 JavaScript 代码执行一个 localStorage 的操作，比如 localStorage.getItem('key') 或 localStorage.setItem('key', 'value')，这个调用发生在 js 的单个线程上。</li><li><strong>浏览器引擎处理</strong>: 浏览器的 js 引擎接收到调用请求后，会向浏览器的存储子系统发出同步IO请求。此时 js 引擎等待IO操作的完成。</li><li><strong>文件系统的同步IO</strong>: 浏览器存储子系统对硬盘执行实际的存储或检索操作。尽管操作系统层面可能对文件访问进行缓存或优化，但从浏览器的角度看，它会进行一个同步的文件系统操作，直到这个操作返回结果。</li><li><strong>操作完成返回</strong>: 一旦IO操作完成，数据要么被写入硬盘，要么被从硬盘读取出来，浏览器存储子系统会将结果返回给 js 引擎。</li><li><strong>JavaScript线程继续执行</strong>: js 引擎在接收到操作完成的信号后，才会继续执行下一条 js 代码。</li></ol> 
<p>在同步的 localStorage 操作期间，由于 js 的单线程性质，整个线程会阻塞，即不会执行其他任何js代码，也不会进行任何渲染操作，直到 localStorage 调用返回。</p> 
<h2> 四、localStorage限制容量都是因为同步会阻塞的原因吗？</h2> 
<ol><li><strong>资源公平分享</strong>：同一用户可能会访问大量不同的网站，如果没有限制，随着时间的积累，每个网站可能会消耗大量的本地存储资源。这样会导致本地存储空间被少数几个站点占用，影响到用户访问其他网页的体验。限制大小可以确保所有网站都有公平的存储机会。</li><li><strong>防止滥用</strong>：如果没有存储限制，网站可能会滥用 localStorage，存储大量数据在用户的设备上，这可能导致设备存储空间迅速耗尽，也可能侵犯用户的隐私。</li><li><strong>性能限制</strong>：如之前提到的，localStorage 的操作是阻塞的。如果网站能够存储大量数据，就会加剧读写操作对页面性能的影响。</li><li><strong>存储效率</strong>：localStorage 存储的是字符串形式的数据，不是为存储大量或结构化数据设计的。当尝试存储过多数据时，效率会降低。</li><li><strong>历史和兼容性</strong>：5MB 的限制很早就已经被大多数浏览器实现，并被作为一个非正式的标准被采纳。尽管现在有些浏览器支持更大的 localStorage，但出于跨浏览器兼容性的考虑，开发者通常会假设这个限制。</li><li><strong>浏览器政策</strong>：浏览器厂商可能会依据自己的政策来设定限制，可能是出于提供用户更一致体验的角度，或者是出于管理用户数据的方便。</li></ol> 
<h2> 五、那indexDB会造成滥用吗？</h2> 
<p>虽然它们提供了更大的存储空间和更丰富的功能，但确实潜在地也可能被滥用。但是与相比 localStorage 增加了一些特性用来降低被滥用的风险：</p> 
<ol><li><strong>异步操作</strong>：IndexedDB 是一个异步API，即使它被用来处理更大量的数据，也不会像 localStorage 那样阻塞主线程，从而避免了对页面响应性的直接影响。</li><li><strong>用户提示和权限</strong>：对于某些浏览器，当网站尝试存储大量数据时，浏览器可能会弹出提示，要求用户授权。这意味着用户有机会拒绝超出合理范围的存储请求。</li><li><strong>存储配额和限制</strong>：尽管 IndexedDB 提供的存储容量比 localStorage 大得多，但它也不是无限的。浏览器会为 IndexedDB 设定一定的存储配额，这个配额可能基于可用磁盘空间的一个百分比或者是一个事先设定的限额。配额超出时，浏览器会拒绝更多的存储请求。</li><li><strong>更清晰的存储管理</strong>：IndexedDB 的数据库形式允许有组织的存储和更容易的数据管理。用户或开发者可以更容易地查看和清理占用的数据。</li><li><strong>逐渐增加的存储</strong>：某些浏览器实现 IndexedDB 存储时，可能会在数据库大小增长到一定阈值时，提示用户是否允许继续存储，而不是一开始就分配一个很大的空间。</li></ol> 
<h2> 六、一个例子简单测试一下</h2> 
<p>其实也不用测，平时写的时候你也没用异步的方式写localStorage吧，我们这里简单写个例子</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;script&gt;
        const testLocalStorage = () =&gt; {
            console.log("==========&gt; 设置localStorage之前");
            localStorage.setItem('testLocalStorage', '我是同步的');
            console.log("==========&gt; 获取localStorage之前");
            console.log('=========获取localStorage', localStorage.getItem('testLocalStorage'))
            console.log("==========&gt; 获取localStorage之后");
        }

        testLocalStorage()
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
<p><img alt="" height="379" src="https://images2.imgbox.com/db/08/6opjst5B_o.png" width="532"></p> 
<p></p> 
<h2> 写在最后</h2> 
<p>如果您看到这里了，并且觉得这篇文章对您有所帮助，希望您能够点赞和收藏⭐支持一下作者，感谢！如果文中有任何不准确之处，也欢迎您指正，共同进步。感谢您的阅读，期待您的点赞和收藏⭐！</p> 
<p></p> 
<p><br> 原文链接：<br> https://juejin.cn/post/7359405716090011659</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bed33520b6fbff8b24f99eecec52df4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">智能优化算法的原理分类，为什么要用最新的算法？为什么要掌握多种算法？（附2023/2024最新智能优化算法合集matlab代码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5016c9c35278f4757275233a3cd7fa43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot3 实现webclient 通用方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>