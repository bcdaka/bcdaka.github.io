<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kafka - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/51be25b0145a0beca811de24a62b5cb4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Kafka">
  <meta property="og:description" content="1.Kafka简介 消息队列 消息队列——用于存放消息的组件程序员可以将消息放入到队列中，也可以从消息队列中获取消息很多时候消息队列不是一个永久性的存储，是作为临时存储存在的（设定一个期限：设置消息在MQ中保存10天）消息队列中间件：消息队列的组件，例如：Kafka、Active MQ、RabbitMQ、RocketMQ、ZeroMQ Kafka的应用场景 异步处理 可以将一些比较耗时的操作放在其他系统中，通过消息队列将需要进行处理的消息进行存储，其他系统可以消费消息队列中的数据比较常见的：发送短信验证码、发送邮件 系统解耦 原先一个微服务是通过接口（HTTP）调用另一个微服务，这时候耦合很严重，只要接口发生变化就会导致系统不可用使用消息队列可以将系统进行解耦合，现在第一个微服务可以将消息放入到消息队列中，另一个微服务可以从消息队列中把消息取出来进行处理。进行系统解耦 流量削峰 因为消息队列是低延迟、高可靠、高吞吐的，可以应对大量并发 日志处理 可以使用消息队列作为临时存储，或者一种通信管道 消息队列的两种模型 生产者、消费者模型 生产者负责将消息生产到MQ中消费者负责从MQ中获取消息生产者和消费者是解耦的，可能是生产者一个程序、消费者是另外一个程序 消息队列的模式 点对点：一个消费者消费一个消息发布订阅：多个消费者可以消费一个消息 Kafka集群搭建 使用docker安装kafka version: &#39;3&#39; services: zookeeper-kafka: image: wurstmeister/zookeeper restart: unless-stopped hostname: zookeeper-kafka container_name: zookeeper-kafka ports: - 2181:2181 volumes: - ./data:/data - ./datalog:/datalog kafka: image: wurstmeister/kafka:2.12-2.4.1 depends_on: - zookeeper-kafka container_name: kafka ports: - 9092:9092 environment: KAFKA_ADVERTISED_HOST_NAME: kafka KAFKA_BROKER_ID: 0 KAFKA_ZOOKEEPER_CONNECT: 192.168.200.135:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.200.135:9092 KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092 restart: unless-stopped volumes: - ./docker.sock:/var/run/docker.sock ip要改成自己的ip 云服务器需要开放端口 出现报错可以查看docker容器日志排查">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-16T13:21:41+08:00">
    <meta property="article:modified_time" content="2024-03-16T13:21:41+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kafka</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="QcZOg">1.Kafka简介</h3> 
<h4 id="NUpZE">消息队列</h4> 
<ul><li id="u5eb5a5e9">消息队列——用于存放消息的组件</li><li id="u9908fd13">程序员可以将消息放入到队列中，也可以从消息队列中获取消息</li><li id="u5011dc02">很多时候消息队列不是一个永久性的存储，是作为临时存储存在的（设定一个期限：设置消息在MQ中保存10天）</li><li id="uef58b8a3">消息队列中间件：消息队列的组件，例如：Kafka、Active MQ、RabbitMQ、RocketMQ、ZeroMQ</li></ul> 
<h4 id="eEKSf">Kafka的应用场景</h4> 
<ul><li id="u670af4c4">异步处理</li></ul> 
<ul><li> 
  <ul><li id="ucebece57">可以将一些比较耗时的操作放在其他系统中，通过消息队列将需要进行处理的消息进行存储，其他系统可以消费消息队列中的数据</li><li id="u994f48ad">比较常见的：发送短信验证码、发送邮件</li></ul></li></ul> 
<p id="ub561f4aa"></p> 
<p class="img-center"><img alt="" height="354" id="u4a90b043" src="https://images2.imgbox.com/03/aa/X9VNEvrH_o.png" width="795"></p> 
<ul><li id="uf642864a">系统解耦</li></ul> 
<ul><li> 
  <ul><li id="u8f3a0d80">原先一个微服务是通过接口（HTTP）调用另一个微服务，这时候耦合很严重，只要接口发生变化就会导致系统不可用</li><li id="uf29d42ba">使用消息队列可以将系统进行解耦合，现在第一个微服务可以将消息放入到消息队列中，另一个微服务可以从消息队列中把消息取出来进行处理。进行系统解耦</li></ul></li></ul> 
<p id="ud7eeeed6"></p> 
<p class="img-center"><img alt="" height="361" id="ubde47b83" src="https://images2.imgbox.com/7e/c4/CYP5DPdS_o.png" width="783"></p> 
<ul><li id="u47d5cb23">流量削峰</li></ul> 
<ul><li> 
  <ul><li id="ueba84f7e">因为消息队列是低延迟、高可靠、高吞吐的，可以应对大量并发</li></ul></li></ul> 
<p id="ud83da6d5"></p> 
<p class="img-center"><img alt="" height="363" id="ub0e46c55" src="https://images2.imgbox.com/fd/2c/31blDQAL_o.png" width="733"></p> 
<ul><li id="uac312601">日志处理</li></ul> 
<ul><li> 
  <ul><li id="ue5770504">可以使用消息队列作为临时存储，或者一种通信管道</li></ul></li></ul> 
<p id="u6c1c6f8c"></p> 
<p class="img-center"><img alt="" height="294" id="u6d3b4f84" src="https://images2.imgbox.com/93/36/Sm0HctHk_o.png" width="782"></p> 
<h4 id="wXkNV">消息队列的两种模型</h4> 
<ul><li id="u60434316">生产者、消费者模型</li></ul> 
<ul><li> 
  <ul><li id="u87e96fba">生产者负责将消息生产到MQ中</li><li id="ue77e092b">消费者负责从MQ中获取消息</li><li id="u4aa35df4">生产者和消费者是解耦的，可能是生产者一个程序、消费者是另外一个程序</li></ul></li></ul> 
<ul><li id="u3fa5d04c">消息队列的模式</li></ul> 
<ul><li> 
  <ul><li id="u2d4eb45f">点对点：一个消费者消费一个消息</li><li id="u4586e428">发布订阅：多个消费者可以消费一个消息</li></ul></li></ul> 
<h3 id="V1shq">Kafka集群搭建</h3> 
<ul><li id="u77933710">使用docker安装kafka</li></ul> 
<pre id="DV3H8"><code>version: '3'
services:
  zookeeper-kafka:
    image: wurstmeister/zookeeper
    restart: unless-stopped
    hostname: zookeeper-kafka
    container_name: zookeeper-kafka
    ports:
      - 2181:2181
    volumes:
      - ./data:/data
      - ./datalog:/datalog
  kafka:
    image: wurstmeister/kafka:2.12-2.4.1
    depends_on: 
      - zookeeper-kafka
    container_name: kafka
    ports:
      - 9092:9092
    environment:
      KAFKA_ADVERTISED_HOST_NAME: kafka
      KAFKA_BROKER_ID: 0
      KAFKA_ZOOKEEPER_CONNECT: 192.168.200.135:2181      
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://192.168.200.135:9092
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
    restart: unless-stopped
    volumes:
      - ./docker.sock:/var/run/docker.sock</code></pre> 
<p id="u990ba39c">ip要改成自己的ip 云服务器需要开放端口 出现报错可以查看docker容器日志排查</p> 
<ul><li id="u8fcd7aeb">搭建集群过程</li></ul> 
<p id="u887e19f9">1. 将Kafka的安装包上传到虚拟机，并解压</p> 
<table id="I989p"><tbody><tr><td> <p id="u24d9a0e2">cd /export/software/</p> <p id="uba3140b2">tar -xvzf kafka_2.12-2.4.1.tgz -C ../server/</p> <p id="u1152d013">cd /export/server/kafka_2.12-2.4.1/</p> </td></tr></tbody></table> 
<p id="uab9e09d4">2. 修改 server.properties</p> 
<table id="J6rQg"><tbody><tr><td> <p id="u913aaedc">cd /export/server/kafka_2.12-2.4.1/config</p> <p id="uaf604990">vim server.properties</p> <p id="u8aee8580"># 指定broker的id</p> <p id="u284c02ec">broker.id=0</p> <p id="u29c97336"># 指定Kafka数据的位置</p> <p id="ubaddac1c">log.dirs=/export/server/kafka_2.12-2.4.1/data</p> <p id="ufdb54888"># 配置zk的三个节点</p> <p id="uaeeb7800">zookeeper.connect=node1.itcast.cn:2181,node2.itcast.cn:2181,node3.itcast.cn:2181</p> </td></tr></tbody></table> 
<p id="u4878621f">3. 将安装好的kafka复制到另外两台服务器</p> 
<table id="TfCkz"><tbody><tr><td> <p id="u72840938">cd /export/server</p> <p id="u618e3eac">scp -r kafka_2.12-2.4.1/ node2.itcast.cn:$PWD</p> <p id="uaa0b643f">scp -r kafka_2.12-2.4.1/ node3.itcast.cn:$PWD</p> <p id="uc23f709e"></p> <p id="ub9b601d2">修改另外两个节点的broker.id分别为1和2</p> <p id="u30b1852d">---------node2.itcast.cn--------------</p> <p id="u59103273">cd /export/server/kafka_2.12-2.4.1/config</p> <p id="uc157d801">vim erver.properties</p> <p id="u25b24810">broker.id=1</p> <p id="u3d1b9f89"></p> <p id="ucb59567b">--------node3.itcast.cn--------------</p> <p id="ue1d04fa4">cd /export/server/kafka_2.12-2.4.1/config</p> <p id="u2e4b1435">vim server.properties</p> <p id="u32115b2a">broker.id=2</p> </td></tr></tbody></table> 
<p id="u531583ce">4. 配置KAFKA_HOME环境变量</p> 
<table id="fcGFr"><tbody><tr><td> <p id="u46437676">vim /etc/profile</p> <p id="uf69e6be7">export KAFKA_HOME=/export/server/kafka_2.12-2.4.1</p> <p id="ue3fd8eca">export PATH=:$PATH:${KAFKA_HOME}</p> <p id="u1f70bf2a"></p> <p id="u634c32cd">分发到各个节点</p> <p id="uebb65fae">scp /etc/profile node2.itcast.cn:$PWD</p> <p id="u7ed2118a">scp /etc/profile node3.itcast.cn:$PWD</p> <p id="u8eb2e883">每个节点加载环境变量</p> <p id="u885b8e5a">source /etc/profile</p> </td></tr></tbody></table> 
<p id="u64bf32ba">5. 启动服务器</p> 
<table id="QaTJF"><tbody><tr><td> <p id="ub16f6e8d"># 启动ZooKeeper</p> <p id="ud3f84efc">nohup bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</p> <p id="u177bf2af"># 启动Kafka</p> <p id="ue4f5dfb6">cd /export/server/kafka_2.12-2.4.1</p> <p id="ua3206dbb">nohup bin/kafka-server-start.sh config/server.properties &amp;</p> <p id="uf92c22c9"># 测试Kafka集群是否启动成功</p> <p id="ue37f8f68">bin/kafka-topics.sh --bootstrap-server node1.itcast.cn:9092 --list</p> </td></tr></tbody></table> 
<ul><li id="ufeaf5add">Kafka集群是必须要有ZooKeeper的</li></ul> 
<p id="u25072994">注意：</p> 
<ul><li id="u7295aa0c">每一个Kafka的节点都需要修改broker.id（每个节点的标识，不能重复）</li><li id="u7ce78302">log.dir数据存储目录需要配置</li></ul> 
<p id="u7adb0bfb">kafka的目录结构:</p> 
<table id="OQeLp"><tbody><tr><td> <p id="uac17beb5">目录名称</p> </td><td> <p id="u278593ab">说明</p> </td></tr><tr><td> <p id="u1eeb45bf">bin</p> </td><td> <p id="u929a334d">Kafka的所有执行脚本都在这里。例如：启动Kafka服务器、创建Topic、生产者、消费者程序等等</p> </td></tr><tr><td> <p id="u16c52d07">config</p> </td><td> <p id="u0726e960">Kafka的所有配置文件</p> </td></tr><tr><td> <p id="u8502e30b">libs</p> </td><td> <p id="u56df67cf">运行Kafka所需要的所有JAR包</p> </td></tr><tr><td> <p id="ub8373b2d">logs</p> </td><td> <p id="u28438a14">Kafka的所有日志文件，如果Kafka出现一些问题，需要到该目录中去查看异常信息</p> </td></tr><tr><td> <p id="u44ccfc89">site-docs</p> </td><td> <p id="ued38a1a7">Kafka的网站帮助文件</p> </td></tr></tbody></table> 
<h4 id="uL9of">Kafka的生产者/消费者/工具</h4> 
<ul><li id="uc083a327">安装Kafka集群，可以测试以下</li></ul> 
<ul><li> 
  <ul><li id="uf2b059fe">创建一个topic主题（消息都是存放在topic中，类似mysql建表的过程）</li><li id="u0143cd36">基于kafka的内置测试生产者脚本来读取标准输入（键盘输入）的数据，并放入到topic中</li><li id="ueb6a4431">基于kafka的内置测试消费者脚本来消费topic中的数据</li></ul></li></ul> 
<ul><li id="uee043f94">推荐大家开发的使用Kafka Tool</li></ul> 
<ul><li> 
  <ul><li id="u0ce45d30">浏览Kafka集群节点、多少个topic、多少个分区</li><li id="ue49426dd">创建topic/删除topic</li><li id="udd052a8b">浏览ZooKeeper中的数据</li></ul></li></ul> 
<ul><li id="u6df9c8ee">工具下载</li></ul> 
<p><a href="https://www.kafkatool.com/download.html" rel="nofollow" title="Offset Explorer">Offset Explorer</a></p> 
<p>工具使用步骤</p> 
<p id="ub78f5585"></p> 
<p class="img-center"><img alt="" height="407" id="ufc6c9d43" src="https://images2.imgbox.com/f2/2e/5Ltn8nSP_o.png" width="711"></p> 
<p id="udc87465d"></p> 
<p class="img-center"><img alt="" height="397" id="uef9f8743" src="https://images2.imgbox.com/04/fc/TC0nTJk8_o.png" width="711"></p> 
<p id="u8c9fbd88"></p> 
<p class="img-center"><img alt="" height="402" id="ud526c6fb" src="https://images2.imgbox.com/df/20/1RYAscgI_o.png" width="710"></p> 
<p id="u920998c7"></p> 
<p class="img-center"><img alt="" height="410" id="u56295430" src="https://images2.imgbox.com/4e/ca/XGC9dNgt_o.png" width="718"></p> 
<p id="u3c19bc85"></p> 
<p class="img-center"><img alt="" height="406" id="u9a14fd0e" src="https://images2.imgbox.com/05/e4/aU8K4TGm_o.png" width="720"></p> 
<p id="ub26a0525"></p> 
<p class="img-center"><img alt="" height="411" id="u7df3200d" src="https://images2.imgbox.com/1b/64/6YLO3Adm_o.png" width="718"></p> 
<h4 id="Gsq5W">Kafka的基准测试工具</h4> 
<ul><li id="ud4f4f6f2">Kafka中提供了内置的性能测试工具</li></ul> 
<ul><li> 
  <ul><li id="u0e259323">生产者：测试生产每秒传输的数据量（多少条数据、多少M的数据）5000000 records sent, 11825.446943 records/sec (11.28 MB/sec), 2757.61 ms avg latency</li><li id="uf45af0a8">消费者：测试消费每条拉取的数据量</li></ul></li></ul> 
<ul><li id="ubf524cca">对比生产者和消费者：消费者的速度更快</li><li id="u5b01c76b">参考文档进行测试,根电脑性能有关,一共有三种方式.</li></ul> 
<h4 id="ooCSu">Kafka的Eagle监控工具</h4> 
<p id="u7b6133c7">Kafka Eagle是一款结合了目前大数据Kafka监控工具的特点，重新研发的一块开源免费的Kafka集群优秀的监控工具。它可以非常方便的监控生产环境中的offset、lag变化、partition分布、owner等。</p> 
<p id="uf783a486">官网: <a href="https://www.kafka-eagle.org/" rel="nofollow" title="EFAK">EFAK</a></p> 
<p>采用Docker进行安装</p> 
<ol><li id="u039381a2">拉取镜像</li></ol> 
<p id="uad907995">docker pull nickzurich/efak:latest</p> 
<ol><li id="u478666f2">使用以下命令启动容器(记得开放相关端口)</li></ol> 
<pre id="dv6CD"><code>docker run -d --name kafka-eagle -p 8048:8048 -e EFAK_CLUSTER_ZK_LIST="116.62.237.97:2181" nickzurich/efak:latest</code></pre> 
<p id="u1f2af324"><strong>EFAK_CLUSTER_ZK_LIST</strong>：配置的是zookeeper服务的地址</p> 
<ol><li id="u7ad770fe">在游览器中输入<a href="http://127.0.0.1:8048" rel="nofollow" title="http://ip:8048">http://ip:8048</a> 即可访问,初始账号密码: admin/123456</li></ol> 
<ol><li id="u70146f9f">开启Kafka JMX端口</li></ol> 
<p id="u26bdaec5">JMX(Java Management Extensions)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。很多的一些软件都提供了JMX接口，来实现一些管理、监控功能。</p> 
<p id="ub7943648">在启动Kafka的脚本前，添加：</p> 
<pre id="CW3qA"><code>cd ${KAFKA_HOME}
export JMX_PORT=9988
nohup bin/kafka-server-start.sh config/server.properties &amp;</code></pre> 
<ol><li id="u5815ff23">安装Kafka-Eagle</li></ol> 
<p id="u55117f50">安装JDK，并配置好JAVA_HOME。</p> 
<p id="ufa0a9a4f">将kafka_eagle上传，并解压到 /export/server 目录中。</p> 
<pre id="NUvNO"><code>cd cd /export/software/
tar -xvzf kafka-eagle-bin-1.4.6.tar.gz -C ../server/
cd /export/server/kafka-eagle-bin-1.4.6/ 
tar -xvzf kafka-eagle-web-1.4.6-bin.tar.gz
cd /export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6</code></pre> 
<p id="u1c1a24d6">配置kafka_eagle 环境变量。</p> 
<pre id="XDGHP"><code>vim /etc/profile
export KE_HOME=/export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6
export PATH=$PATH:$KE_HOME/bin
source /etc/profile</code></pre> 
<p id="u8b9a8677">配置kafka_eagle。使用vi打开conf目录下的system-config.properties</p> 
<pre id="Runhx"><code>vim conf/system-config.properties
# 修改第4行，配置kafka集群别名
kafka.eagle.zk.cluster.alias=cluster1
# 修改第5行，配置ZK集群地址
cluster1.zk.list=node1.itcast.cn:2181,node2.itcast.cn:2181,node3.itcast.cn:2181
# 注释第6行
#cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181

# 修改第32行，打开图标统计
kafka.eagle.metrics.charts=true
kafka.eagle.metrics.retain=30

# 注释第69行，取消sqlite数据库连接配置
#kafka.eagle.driver=org.sqlite.JDBC
#kafka.eagle.url=jdbc:sqlite:/hadoop/kafka-eagle/db/ke.db
#kafka.eagle.username=root
#kafka.eagle.password=www.kafka-eagle.org

# 修改第77行，开启mys
kafka.eagle.driver=com.mysql.jdbc.Driver
kafka.eagle.url=jdbc:mysql://node1.itcast.cn:3306/ke?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull
kafka.eagle.username=root
kafka.eagle.password=123456</code></pre> 
<p id="u55b2c2f3">配置JAVA_HOME</p> 
<pre id="u4Veq"><code>cd /export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6/bin
vim ke.sh
# 在第24行添加JAVA_HOME环境配置
export JAVA_HOME=/export/server/jdk1.8.0_241</code></pre> 
<p id="u6a579c0f">修改Kafka eagle可执行权限</p> 
<pre id="ZFS6b"><code>cd /export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6/bin
chmod +x ke.sh</code></pre> 
<p id="ub944992e">启动kafka_eagle。</p> 
<pre id="lQ2It"><code>./ke.sh start</code></pre> 
<p id="uff8b0ef1">访问Kafka eagle，默认用户为admin，密码为：123456</p> 
<pre id="FnF0u"><code>http://ip:8048/ke</code></pre> 
<p id="u66c097f2"></p> 
<p class="img-center"><img alt="" height="118" id="ucd30873e" src="https://images2.imgbox.com/9c/a0/tK9Yv4GQ_o.png" width="705"></p> 
<p id="u78e5a922"></p> 
<p class="img-center"><img alt="" height="116" id="u15b9a3d7" src="https://images2.imgbox.com/41/4b/mNi9FvkN_o.png" width="698"></p> 
<p id="u207c1135">Kafka度量指标</p> 
<p id="ubfa32d28">topic list</p> 
<p id="u504e5e30">点击Topic下的List菜单，就可以展示当前Kafka集群中的所有topic。</p> 
<p id="u0ebb40ea"></p> 
<p class="img-center"><img alt="" height="601" id="u769ecd33" src="https://images2.imgbox.com/4a/f4/b2L0CYqx_o.png" width="727"></p> 
<table id="gI9ep"><tbody><tr><td> <p id="u3deec05a">指标</p> </td><td> <p id="ucba78cdb">意义</p> </td></tr><tr><td> <p id="ue7d399f2">Brokers Spread</p> </td><td> <p id="u90400016">broker使用率</p> </td></tr><tr><td> <p id="ubecb29db">Brokers Skew</p> </td><td> <p id="u1b3913e2">分区是否倾斜</p> </td></tr><tr><td> <p id="udf61cab2">Brokers Leader Skew</p> </td><td> <p id="u2418dae0">leader partition是否存在倾斜</p> </td></tr></tbody></table> 
<p id="u8fe52eb1">生产者消息总计</p> 
<p id="uc3f50506"></p> 
<p class="img-center"><img alt="" height="202" id="uec82d4a4" src="https://images2.imgbox.com/5c/58/J4ENDKdx_o.png" width="726"></p> 
<h3 id="nKTVj">Kafka Java API开发</h3> 
<pre id="PWsge"><code>&lt;!-- kafka客户端工具 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
  &lt;version&gt;2.4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>小tips 将日志输出到文件</p> 
<ol><li id="u3cceaefe">导入log4J的依赖</li></ol> 
<p id="u19f57390">&lt;!-- SLF桥接LOG4J日志--&gt;<br> &lt;<strong>dependency</strong>&gt;<br> &lt;<strong>groupId</strong>&gt;org.slf4j&lt;/<strong>groupId</strong>&gt;<br> &lt;<strong>artifactId</strong>&gt;slf4j-log4j12&lt;/<strong>artifactId</strong>&gt;<br> &lt;<strong>version</strong>&gt;1.7.6&lt;/<strong>version</strong>&gt;<br> &lt;/<strong>dependency</strong>&gt;<br> &lt;!-- SLOG4J日志--&gt;<br> &lt;<strong>dependency</strong>&gt;<br> &lt;<strong>groupId</strong>&gt;log4j&lt;/<strong>groupId</strong>&gt;<br> &lt;<strong>artifactId</strong>&gt;log4j&lt;/<strong>artifactId</strong>&gt;<br> &lt;<strong>version</strong>&gt;1.2.16&lt;/<strong>version</strong>&gt;<br> &lt;/<strong>dependency</strong>&gt;</p> 
<ol><li id="u320a9366">将log4j.properties配置文件放入到resources文件夹中</li></ol> 
<p id="ua247a29c"><strong>log4j.rootLogger</strong>=<strong>INFO,stdout</strong><br><strong>log4j.appender.stdout</strong>=<strong>org.apache.log4j.ConsoleAppender </strong><br><strong>log4j.appender.stdout.layout</strong>=<strong>org.apache.log4j.PatternLayout </strong><br><strong>log4j.appender.stdout.layout.ConversionPattern</strong>=<strong>%5p - %m%n</strong></p> 
<h4 id="xRz3D">生产者程序开发</h4> 
<p><a href="http://kafka.apache.org/24/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html" rel="nofollow" title="kafka 2.4.0 API">kafka 2.4.0 API</a></p> 
<ol><li id="u291f1240">创建连接</li></ol> 
<ul><li> 
  <ul><li id="ua1afee23">bootstrap.servers：Kafka的服务器地址</li><li id="uc696321b">acks：表示当生产者生产数据到Kafka中，Kafka中会以什么样的策略返回</li><li id="uf6762c3a">key.serializer：Kafka中的消息是以key、value键值对存储的，而且生产者生产的消息是需要在网络上传到的，这里指定的是StringSerializer方式，就是以字符串方式发送（将来还可以使用其他的一些序列化框架：Google ProtoBuf、Avro）</li><li id="u12bfd816">value.serializer：同上</li></ul></li></ul> 
<ol><li id="u133c01c4">创建一个生产者对象KafkaProducer</li><li id="u1ea42636">调用send方法发送消息（ProducerRecor，封装是key-value键值对）</li><li id="u5424c14b">调用Future.get表示等带服务端的响应</li><li id="uf24feb63">关闭生产者</li></ol> 
<pre id="MDOaw"><code>// 1. 创建用于连接Kafka的Properties配置
        Properties props = new Properties();
        props.put("bootstrap.servers", "116.62.237.97:9092");
        props.put("acks", "all");
        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

        // 2. 创建一个生产者对象KafkaProducer
        KafkaProducer&lt;String, String&gt; kafkaProducer = new KafkaProducer&lt;&gt;(props);

        // 3. 发送1-100的消息到指定的topic中
        for (int i = 0; i &lt; 100; ++i) {
            // 构建一条消息，直接new ProducerRecord
            ProducerRecord&lt;String, String&gt; producerRecord = new ProducerRecord&lt;&gt;("test", null, i + "");
            Future&lt;RecordMetadata&gt; future = kafkaProducer.send(producerRecord);
            // 调用Future的get方法等待响应
            future.get();
            System.out.println("第" + i + "条消息写入成功！");
        }

        // 4.关闭生产者
        kafkaProducer.close();</code></pre> 
<h4 id="MW3oG">消费者程序开发</h4> 
<ul><li id="u45cc05f1">group.id：消费者组的概念，可以在一个消费组中包含多个消费者。如果若干个消费者的group.id是一样的，表示它们就在一个组中，一个组中的消费者是共同消费Kafka中topic的数据。</li><li id="u6096b29d">Kafka是一种拉消息模式的消息队列，在消费者中会有一个offset，表示从哪条消息开始拉取数据</li><li id="u84a25488">kafkaConsumer.poll：Kafka的消费者API是一批一批数据的拉取</li></ul> 
<pre id="yvMUQ"><code>/**
 * 消费者程序
 * &lt;p&gt;
 * 1.创建Kafka消费者配置
 * Properties props = new Properties();
 * props.setProperty("bootstrap.servers", "node1.itcast.cn:9092");
 * props.setProperty("group.id", "test");
 * props.setProperty("enable.auto.commit", "true");
 * props.setProperty("auto.commit.interval.ms", "1000");
 * props.setProperty("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
 * props.setProperty("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
 * &lt;p&gt;
 * 2.创建Kafka消费者
 * 3.订阅要消费的主题
 * 4.使用一个while循环，不断从Kafka的topic中拉取消息
 * 5.将将记录（record）的offset、key、value都打印出来
 */
public class KafkaConsumerOne {
    public static void main(String[] args) {
        // 1.创建Kafka消费者配置
        Properties props = new Properties();
        props.setProperty("bootstrap.servers", "116.62.237.97:9092");
        // 消费者组（可以使用消费者组将若干个消费者组织到一起），共同消费Kafka中topic的数据
        // 每一个消费者需要指定一个消费者组，如果消费者的组名是一样的，表示这几个消费者是一个组中的
        props.setProperty("group.id", "test");
        // 自动提交offset
        props.setProperty("enable.auto.commit", "true");
        // 自动提交offset的时间间隔
        props.setProperty("auto.commit.interval.ms", "1000");
        // 拉取的key、value数据的
        props.setProperty("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
        props.setProperty("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

        // 2.创建Kafka消费者
        KafkaConsumer&lt;String, String&gt; kafkaConsumer = new KafkaConsumer&lt;&gt;(props);

        // 3. 订阅要消费的主题
        // 指定消费者从哪个topic中拉取数据
        kafkaConsumer.subscribe(Arrays.asList("test"));

        // 4.使用一个while循环，不断从Kafka的topic中拉取消息
        while (true) {
            // Kafka的消费者一次拉取一批的数据
            ConsumerRecords&lt;String, String&gt; consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(5));
            // 5.将将记录（record）的offset、key、value都打印出来
            for (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) {
                // 主题
                String topic = consumerRecord.topic();
                // offset：这条消息处于Kafka分区中的哪个位置
                long offset = consumerRecord.offset();
                // key\value
                String key = consumerRecord.key();
                String value = consumerRecord.value();

                System.out.println("topic: " + topic + " offset:" + offset + " key:" + key + " value:" + value);
            }
        }
    }
}</code></pre> 
<h4 id="n7QUz">生产者使用异步方式生产消息</h4> 
<ul><li id="u980a8f32">获取生产者消息是否成功,或者成功生产消息到Kafka中后,执行一些其他操作.</li><li id="ue17bc616">使用匿名内部类实现Callback接口，该接口中表示Kafka服务器响应给客户端，会自动调用onCompletion方法</li></ul> 
<ul><li> 
  <ul><li id="ubefaefef">metadata：消息的元数据（属于哪个topic、属于哪个partition、对应的offset是什么）</li><li id="u2c2d098f">exception：这个对象Kafka生产消息封装了出现的异常，如果为null，表示发送成功，如果不为null，表示出现异常。</li></ul></li></ul> 
<pre id="B2Nvd"><code>// 二、使用异步回调的方式发送消息
ProducerRecord&lt;String, String&gt; producerRecord = new ProducerRecord&lt;&gt;("test", null, i + "");
kafkaProducer.send(producerRecord, new Callback() {
    @Override
    public void onCompletion(RecordMetadata metadata, Exception exception) {
        // 1. 判断发送消息是否成功
        if(exception == null) {
            // 发送成功
            // 主题
            String topic = metadata.topic();
            // 分区id
            int partition = metadata.partition();
            // 偏移量
            long offset = metadata.offset();
            System.out.println("topic:" + topic + " 分区id：" + partition + " 偏移量：" + offset);
        }
        else {
            // 发送出现错误
            System.out.println("生产消息出现异常！");
            // 打印异常消息
            System.out.println(exception.getMessage());
            // 打印调用栈
            System.out.println(exception.getStackTrace());
        }
    }
});</code></pre> 
<h3 id="QjShm">Kafka中的重要概念</h3> 
<ul><li id="u253df75c">broker</li></ul> 
<ul><li> 
  <ul><li id="ua9e9a92a">Kafka服务器进程，生产者、消费者都要连接broker</li><li id="u5360cd1c">一个集群由多个broker组成，功能实现Kafka集群的负载均衡、容错</li></ul></li></ul> 
<p id="u477df0f0"></p> 
<p class="img-center"><img alt="" height="353" id="u5daa0a4b" src="https://images2.imgbox.com/46/f9/C3Doi79P_o.png" width="772"></p> 
<ul><li id="u7d9e77f6">producer：生产者</li><li id="ua3c862ad">consumer：消费者</li><li id="u3c0d30ce">topic：主题，一个Kafka集群中，可以包含多个topic。一个topic可以包含多个分区</li></ul> 
<ul><li> 
  <ul><li id="ud1dc85b0">是一个逻辑结构，生产、消费消息都需要指定topic</li></ul></li></ul> 
<ul><li id="udee77267">partition：Kafka集群的分布式就是由分区来实现的。一个topic中的消息可以分布在topic中的不同partition中</li><li id="u318b1624">replica：副本，实现Kafkaf集群的容错，实现partition的容错。一个topic至少应该包含大于1个的副本</li><li id="u01d43edc">consumer group：消费者组，一个消费者组中的消费者可以共同消费topic中的分区数据。每一个消费者组都一个唯一的名字。配置group.id一样的消费者是属于同一个组中</li><li id="u5a453d8f">offset：偏移量。相对消费者、partition来说，可以通过offset来拉取数据</li></ul> 
<p id="u31da02fb"></p> 
<p class="img-center"><img alt="" height="387" id="u5bade4a7" src="https://images2.imgbox.com/37/41/BrBjKXIF_o.png" width="812"></p> 
<h4 id="Kc28G">消费者组</h4> 
<ul><li id="ub8887074">一个消费者组中可以包含多个消费者，共同来消费topic中的数据</li><li id="u0f7ab501">一个topic中如果只有一个分区，那么这个分区只能被某个组中的一个消费者消费</li><li id="ud2090e2c">有多少个分区，那么就可以被同一个组内的多少个消费者消费</li></ul> 
<h4 id="Dc9bZ">幂等性</h4> 
<ul><li id="u3d7e88fe">生产者消息重复问题</li></ul> 
<ul><li> 
  <ul><li id="u027d872a">Kafka生产者生产消息到partition，如果直接发送消息，kafka会将消息保存到分区中，但Kafka会返回一个ack给生产者，表示当前操作是否成功，是否已经保存了这条消息。如果ack响应的过程失败了，此时生产者会重试，继续发送没有发送成功的消息，Kafka又会保存一条一模一样的消息</li></ul></li></ul> 
<p id="u84129299"></p> 
<p class="img-center"><img alt="" height="275" id="uf1bb1730" src="https://images2.imgbox.com/7e/d7/Qzmo8DpF_o.png" width="780"></p> 
<ul><li id="u76fac7ab">在Kafka中可以开启幂等性</li></ul> 
<pre id="rWCuY"><code>props.put("enable.idempotence",true);</code></pre> 
<ul><li> 
  <ul><li id="u89623daa">当Kafka的生产者生产消息时，会增加一个pid（生产者的唯一编号）和sequence number（针对消息的一个递增序列）</li><li id="u8a6a3742">发送消息，会连着pid和sequence number一块发送</li><li id="ub14de252">kafka接收到消息，会将消息和pid、sequence number一并保存下来</li><li id="u1de04751">如果ack响应失败，生产者重试，再次发送消息时，Kafka会根据pid、sequence number是否需要再保存一条消息</li><li id="uf3cd42b8">判断条件：生产者发送过来的sequence number 是否小于等于 partition中消息对应的sequence</li></ul></li></ul> 
<h3 id="nvaFw">事务编程</h3> 
<ul><li id="u4264500d">Kafka事务指的是生产者生产消息以及消费者提交offset的操作可以在一个原子操作中，要么都成功，要么都失败。</li></ul> 
<p id="u0a205d6e"></p> 
<p class="img-center"><img alt="" height="301" id="u493439dd" src="https://images2.imgbox.com/3c/26/B6NX5GWk_o.png" width="732"></p> 
<ul><li id="ufded6c14">开启事务的条件</li></ul> 
<ul><li> 
  <ul><li id="u8f2cbd6a">生产者</li></ul></li></ul> 
<pre id="XYUel"><code>// 开启事务必须要配置事务的ID
props.put("transactional.id", "dwd_user");</code></pre> 
<ul><li> 
  <ul><li id="u50ebc2bb">消费者</li></ul></li></ul> 
<pre id="TCgkB"><code>// 配置事务的隔离级别
props.put("isolation.level","read_committed");
// 关闭自动提交，一会我们需要手动来提交offset，通过事务来维护offset
props.setProperty("enable.auto.commit", "false");</code></pre> 
<ul><li> 
  <ul><li id="ua49b4cf9">生产者</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u6508538d">初始化事务 initTransactions</li><li id="udd997da5">开启事务 beginTransaction</li><li id="u8d9beeed">需要使用producer来将消费者的offset提交到事务中 sendOffsetsToTransaction</li><li id="u7497f77b">提交事务 commitTransaction</li><li id="u533aed65">如果出现异常回滚事务 abortTransaction</li></ul></li></ul></li></ul> 
<p id="ud4296eb2">如果使用了事务，不要使用异步发送</p> 
<pre id="s2pWQ"><code>public class TransactionProgram {
    public static void main(String[] args) {
        // 1. 调用之前实现的方法，创建消费者、生产者对象
        KafkaConsumer&lt;String, String&gt; consumer = createConsumer();
        KafkaProducer&lt;String, String&gt; producer = createProducer();

        // 2. 生产者调用initTransactions初始化事务
        producer.initTransactions();

        // 3. 编写一个while死循环，在while循环中不断拉取数据，进行处理后，再写入到指定的topic
        while(true) {
            try {
                // (1)	生产者开启事务
                producer.beginTransaction();

                // 这个Map保存了topic对应的partition的偏移量
                Map&lt;TopicPartition, OffsetAndMetadata&gt; offsetMap = new HashMap&lt;&gt;();

                // 从topic中拉取一批的数据
                // (2)	消费者拉取消息
                ConsumerRecords&lt;String, String&gt; concumserRecordArray = consumer.poll(Duration.ofSeconds(5));
                // (3)	遍历拉取到的消息，并进行预处理
                for (ConsumerRecord&lt;String, String&gt; cr : concumserRecordArray) {
                    // 将1转换为男，0转换为女
                    String msg = cr.value();
                    String[] fieldArray = msg.split(",");

                    // 将消息的偏移量保存
                    // 消费的是ods_user中的数据
                    String topic = cr.topic();
                    int partition = cr.partition();
                    long offset = cr.offset();

                	int i = 1 / 0;

                    // offset + 1：offset是当前消费的记录（消息）对应在partition中的offset，而我们希望下一次能继续从下一个消息消息
                    // 必须要+1，从能消费下一条消息
                    offsetMap.put(new TopicPartition(topic, partition), new OffsetAndMetadata(offset + 1));

                    // 将字段进行替换
                    if(fieldArray != null &amp;&amp; fieldArray.length &gt; 2) {
                        String sexField = fieldArray[1];
                        if(sexField.equals("1")) {
                            fieldArray[1] = "男";
                        }
                        else if(sexField.equals("0")){
                            fieldArray[1] = "女";
                        }
                    }

                    // 重新拼接字段
                    msg = fieldArray[0] + "," + fieldArray[1] + "," + fieldArray[2];

                    // (4)	生产消息到dwd_user topic中
                    ProducerRecord&lt;String, String&gt; dwdMsg = new ProducerRecord&lt;&gt;("dwd_user", msg);
                    // 发送消息
                    Future&lt;RecordMetadata&gt; future = producer.send(dwdMsg);
                    try {
                        future.get();
                    } catch (Exception e) {
                        e.printStackTrace();
                        producer.abortTransaction();
                    }
//                            new Callback()
//                    {
//                        @Override
//                        public void onCompletion(RecordMetadata metadata, Exception exception) {
//                            // 生产消息没有问题
//                            if(exception == null) {
//                                System.out.println("发送成功:" + dwdMsg);
//                            }
//                            else {
//                                System.out.println("生产消息失败:");
//                                System.out.println(exception.getMessage());
//                                System.out.println(exception.getStackTrace());
//                            }
//                        }
//                    });
                }

                producer.sendOffsetsToTransaction(offsetMap, "ods_user");

                // (6)	提交事务
                producer.commitTransaction();
            }catch (Exception e) {
                e.printStackTrace();
                // (7)	捕获异常，如果出现异常，则取消事务
                producer.abortTransaction();
            }
        }
    }

    // 一、创建一个消费者来消费ods_user中的数据
    private static KafkaConsumer&lt;String, String&gt; createConsumer() {
        // 1. 配置消费者的属性（添加对事务的支持）
        Properties props = new Properties();
        props.setProperty("bootstrap.servers", "node1.itcast.cn:9092");
        props.setProperty("group.id", "ods_user");
        // 配置事务的隔离级别
        props.put("isolation.level","read_committed");
        // 关闭自动提交，一会我们需要手动来提交offset，通过事务来维护offset
        props.setProperty("enable.auto.commit", "false");
        // 反序列化器
        props.setProperty("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
        props.setProperty("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

        // 2. 构建消费者对象
        KafkaConsumer&lt;String, String&gt; kafkaConsumer = new KafkaConsumer&lt;&gt;(props);

        // 3. 订阅一个topic
        kafkaConsumer.subscribe(Arrays.asList("ods_user"));

        return kafkaConsumer;

    }

    // 二、编写createProducer方法，用来创建一个带有事务配置的生产者
    private static KafkaProducer&lt;String, String&gt; createProducer() {
        // 1. 配置生产者带有事务配置的属性
        Properties props = new Properties();
        props.put("bootstrap.servers", "node1.itcast.cn:9092");
        // 开启事务必须要配置事务的ID
        props.put("transactional.id", "dwd_user");
        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

        // 2. 构建生产者
        KafkaProducer&lt;String, String&gt; kafkaProducer = new KafkaProducer&lt;&gt;(props);

        return kafkaProducer;
    }
}
</code></pre> 
<h3 id="qhxcg">Kafka中的分区副本机制</h3> 
<h4 id="rvBM3">生产者的分区写入策略</h4> 
<ul><li id="uc2004b24">轮询（按照消息尽量保证每个分区的负载）策略，消息会均匀地分布到每个partition</li></ul> 
<ul><li> 
  <ul><li id="u2ac3a670">写入消息的时候，key为null的时候，默认使用的是轮询策略</li><li id="u01f94f6d">默认的策略，也是使用最多的策略，可以最大限度保证所有消息平均分配到一个分区</li></ul></li></ul> 
<p id="ue6654fea"></p> 
<p class="img-center"><img alt="" height="358" id="u80aac46e" src="https://images2.imgbox.com/f7/22/Usma9qvz_o.png" width="577"></p> 
<ul><li id="u99fbfcb6">随机策略（不使用）</li><li id="u259f33de">按key写入策略，key.hash() % 分区的数量</li></ul> 
<p id="u584a4cda"></p> 
<p class="img-center"><img alt="" height="352" id="u63ef42d3" src="https://images2.imgbox.com/a6/6c/jj8ifRvV_o.png" width="583"></p> 
<ul><li id="u927ce07b">自定义分区策略（类似于MapReduce指定分区）</li></ul> 
<p id="u14ace8e4">乱序问题</p> 
<ul><li id="ufaf33b50">在Kafka中生产者是有写入策略，如果topic有多个分区，就会将数据分散在不同的partition中存储</li><li id="ua7fe2f4b">当partition数量大于1的时候，数据（消息）会打散分布在不同的partition中</li><li id="ue4d9571a">如果只有一个分区，消息是有序的</li></ul> 
<p id="ua2f541b3">自定义分区策略：</p> 
<ol><li id="u407a7e08">创建自定义分区器</li></ol> 
<pre id="NMLxl"><code>public class KeyWithRandomPartitioner implements Partitioner {

    private Random r;

    @Override
    public void configure(Map&lt;String, ?&gt; configs) {
        r = new Random();
    }

    @Override
    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {
        // cluster.partitionCountForTopic 表示获取指定topic的分区数量
        return r.nextInt(1000) % cluster.partitionCountForTopic(topic);
    }

    @Override
    public void close() {
    }
}</code></pre> 
<ol><li id="u172079f6">在Kafka生产者配置中，自定使用自定义分区器的类名</li></ol> 
<pre id="sokXS"><code>props.
put(ProducerConfig.PARTITIONER_CLASS_CONFIG, KeyWithRandomPartitioner.class.getName());</code></pre> 
<h4 id="aRviJ">消费组Consumer Group Rebalance机制</h4> 
<ul><li id="ue75de1ca">再均衡：在某些情况下，消费者组中的消费者消费的分区会产生变化，会导致消费者分配不均匀（例如：有两个消费者消费3个，因为某个partition崩溃了，还有一个消费者当前没有分区要削峰），Kafka Consumer Group就会启用rebalance机制，重新平衡这个Consumer Group内的消费者消费的分区分配。</li><li id="ud83e67fd">触发时机</li></ul> 
<ul><li> 
  <ul><li id="ub9aab4f1">消费者数量发生变化</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u5d202f61">某个消费者crash</li><li id="ude6f63b4">新增消费者</li></ul></li></ul></li></ul> 
<ul><li> 
  <ul><li id="u90f59c84">topic的数量发生变化</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="uf0a5c6f4">某个topic被删除</li></ul></li></ul></li></ul> 
<ul><li> 
  <ul><li id="u7736b81e">partition的数量发生变化</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u61411a00">删除partition</li><li id="u5b7cf512">新增partition</li></ul></li></ul></li></ul> 
<ul><li id="ua9a6b5ba">不良影响</li></ul> 
<ul><li> 
  <ul><li id="u085a698d">发生rebalance，所有的consumer将不再工作，共同来参与再均衡，直到每个消费者都已经被成功分配所需要消费的分区为止（rebalance结束）</li></ul></li></ul> 
<h4 id="Ou2e6">消费者的分区分配策略</h4> 
<p id="u350f4dff">分区分配策略：保障每个消费者尽量能够均衡地消费分区的数据，不能出现某个消费者消费分区的数量特别多，某个消费者消费的分区特别少</p> 
<ul><li id="ufc3acc04">Range分配策略（范围分配策略）：Kafka默认的分配策略</li></ul> 
<ul><li> 
  <ul><li id="u2fac014d">n：分区的数量 / 消费者数量</li><li id="u64fbab1c">m：分区的数量 % 消费者数量</li><li id="u800424bf">前m个消费者消费n+1个分区</li><li id="u0287cd35">剩余的消费者消费n个分区</li></ul></li></ul> 
<p id="u23763b9a"></p> 
<p class="img-center"><img alt="" height="314" id="ua68c26ef" src="https://images2.imgbox.com/c8/41/3aM1jVy6_o.png" width="706"></p> 
<p id="u2eac3c25"></p> 
<p class="img-center"><img alt="" height="332" id="u4df100b2" src="https://images2.imgbox.com/fb/a6/3Roes2cx_o.png" width="706"></p> 
<ul><li id="uc2efa1c4">RoundRobin分配策略（轮询分配策略）</li></ul> 
<ul><li> 
  <ul><li id="udd2461fa">消费者挨个分配消费的分区</li><li id="u8563002b">配置消费者的partition.assignment.strategy为org.apache.kafka.clients.consumer.RoundRobinAssignor。</li></ul></li></ul> 
<p id="ud6da3a20"></p> 
<p class="img-center"><img alt="" height="306" id="u2a587a51" src="https://images2.imgbox.com/c5/57/lxlNGRp8_o.png" width="680"></p> 
<ul><li id="u6ebf5504">Striky粘性分配策略</li></ul> 
<ul><li> 
  <ul><li id="uc6ab4a4a">在没有发生rebalance跟轮询分配策略是一致的</li><li id="u84943513">发生了rebalance，轮询分配策略，重新走一遍轮询分配的过程。而粘性会保证跟上一次的尽量一致，只是将新的需要分配的分区，均匀的分配到现有可用的消费者中即可</li><li id="ue89c5680">减少上下文的切换</li><li id="ufa80d680">Striky粘性分配策略，保留rebalance之前的分配结果。</li></ul></li></ul> 
<p id="u11e5f6f0"></p> 
<p class="img-center"><img alt="" height="318" id="u3f0cfdad" src="https://images2.imgbox.com/5d/29/CtqlyQAv_o.png" width="663"></p> 
<p id="u912526ba"></p> 
<p class="img-center"><img alt="" height="339" id="u65e1b01a" src="https://images2.imgbox.com/e2/39/edyuJi4w_o.png" width="700"></p> 
<p id="u1997f3c1"></p> 
<p class="img-center"><img alt="" height="334" id="u1a509068" src="https://images2.imgbox.com/56/56/YPKQ2K5w_o.png" width="689"></p> 
<h4 id="p9UD9">副本的ACK机制</h4> 
<p id="uab084d38">producer是不断地往Kafka中写入数据，写入数据会有一个返回结果，表示是否写入成功。这里对应有一个ACKs的配置。</p> 
<pre id="I0akZ"><code>Properties props = new Properties();
props.put("bootstrap.servers", "node1.itcast.cn:9092");
props.put("acks", "all");
props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");</code></pre> 
<ul><li id="u5386c85a">acks = 0：生产者只管写入，不管是否写入成功，可能会数据丢失。性能是最好的</li></ul> 
<p id="ue6804c77"></p> 
<p class="img-center"><img alt="" height="301" id="u6ed0dc57" src="https://images2.imgbox.com/97/d5/fYl9zA0m_o.png" width="651"></p> 
<ul><li id="ubfaa2192">acks = 1：生产者会等到leader分区写入成功后，返回成功，接着发送下一条</li></ul> 
<p id="ud3313718"></p> 
<p class="img-center"><img alt="" height="295" id="u2d5c79ad" src="https://images2.imgbox.com/1e/60/6S6T02ze_o.png" width="654"></p> 
<ul><li id="u09f3320e">acks = -1/all：确保消息写入到leader分区、还确保消息写入到对应副本都成功后，接着发送下一条，性能是最差的</li></ul> 
<p id="uc367127e"></p> 
<p class="img-center"><img alt="" height="294" id="uf6fb868e" src="https://images2.imgbox.com/a5/50/Gwnfpk12_o.png" width="663"></p> 
<p id="u9f594f5f">根据业务情况来选择ack机制，是要求性能最高，一部分数据丢失影响不大，可以选择0/1。如果要求数据一定不能丢失，就得配置为-1/all。</p> 
<p id="uddbb1892">分区中是有leader和follower的概念，为了确保消费者消费的数据是一致的，只能从分区leader去读写消息，follower做的事情就是同步数据，Backup。</p> 
<h4 id="gomGx">高级API（High-Level API）、低级API（Low-Level API）</h4> 
<ul><li id="u4b35d3a4">高级API就是直接让Kafka帮助管理、处理分配、数据</li></ul> 
<ul><li> 
  <ul><li id="u4ec36e2e">offset存储在ZK中</li><li id="udc281b8c">由kafka的rebalance来控制消费者分配的分区</li><li id="ue2fe7f9b">开发起来比较简单，无需开发者关注底层细节</li><li id="u5e46f30f">无法做到细粒度的控制</li></ul></li></ul> 
<pre id="ZMtUi"><code>/**
 * 消费者程序：从test主题中消费数据
 */
public class _2ConsumerTest {
    public static void main(String[] args) {
        // 1. 创建Kafka消费者配置
        Properties props = new Properties();
        props.setProperty("bootstrap.servers", "192.168.88.100:9092");
        props.setProperty("group.id", "test");
        props.setProperty("enable.auto.commit", "true");
        props.setProperty("auto.commit.interval.ms", "1000");
        props.setProperty("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
        props.setProperty("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

        // 2. 创建Kafka消费者
        KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);

        // 3. 订阅要消费的主题
        consumer.subscribe(Arrays.asList("test"));

        // 4. 使用一个while循环，不断从Kafka的topic中拉取消息
        while (true) {
            // 定义100毫秒超时
            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100));
            for (ConsumerRecord&lt;String, String&gt; record : records)
                System.out.printf("offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value());
        }
    }
}</code></pre> 
<ul><li id="u32abbefc">低级API：由编写的程序自己控制逻辑</li></ul> 
<ul><li> 
  <ul><li id="ub945c1eb">自己来管理Offset，可以将offset存储在ZK、MySQL、Redis、HBase、Flink的状态存储</li><li id="ua1eb1338">指定消费者拉取某个分区的数据</li><li id="u51718b79">可以做到细粒度的控制</li><li id="u5703bfc4">原有的Kafka的策略会失效，需要我们自己来实现消费机制</li></ul></li></ul> 
<pre id="x3fQj"><code>String topic = "test";
TopicPartition partition0 = new TopicPartition(topic, 0);
TopicPartition partition1 = new TopicPartition(topic, 1);
consumer.assign(Arrays.asList(partition0, partition1));</code></pre> 
<h3 id="x6euQ">Kafka原理</h3> 
<h4 id="YRa68">leader和follower</h4> 
<ul><li id="u82a9136f">Kafka中的leader和follower是相对分区有意义，不是相对broker</li><li id="u16f75b57">Kafka在创建topic的时候，会尽量分配分区的leader在不同的broker中，其实就是负载均衡</li><li id="u9672ce46">leader职责：读写数据</li><li id="u4c45ba30">follower职责：同步数据、参与选举（leader crash之后，会选举一个follower重新成为分区的leader</li><li id="uc5bfe49c">注意和ZooKeeper区分</li></ul> 
<ul><li> 
  <ul><li id="u074e6a04">ZK的leader负责读、写，follower可以读取</li><li id="u301c5546">Kafka的leader负责读写、follower不能读写数据（确保每个消费者消费的数据是一致的），Kafka一个topic有多个分区leader，一样可以实现数据操作的负载均衡.</li></ul></li></ul> 
<h4 id="HLrK1">AR\ISR\OSR</h4> 
<ul><li id="u10c085e9">AR表示一个topic下的所有副本</li><li id="u586c5b51">ISR：In Sync Replicas，正在同步的副本（可以理解为当前有几个follower是存活的）</li><li id="u3bc244c1">OSR：Out of Sync Replicas，不再同步的副本</li><li id="u5a17c056">AR = ISR + OSR</li></ul> 
<h4 id="zZNCX">leader选举</h4> 
<ul><li id="u5a0298aa">Controller：controller是kafka集群的老大，是针对Broker的一个角色</li></ul> 
<ul><li> 
  <ul><li id="u1c6180c0">Controller是高可用的，是用过ZK来进行选举</li></ul></li></ul> 
<ul><li id="u4f0dc961">Leader：是针对partition的一个角色</li></ul> 
<ul><li> 
  <ul><li id="u80fc93af">Leader是通过ISR来进行快速选举</li></ul></li></ul> 
<ul><li id="u391664af">如果Kafka是基于ZK来进行选举，ZK的压力可能会比较大。例如：某个节点崩溃，这个节点上不仅仅只有一个leader，是有不少的leader需要选举。通过ISR快速进行选举。</li><li id="u1dc16259">leader的负载均衡</li></ul> 
<ul><li> 
  <ul><li id="ude0e53aa">如果某个broker crash之后，就可能会导致partition的leader分布不均匀，就是一个broker上存在一个topic下不同partition的leader</li><li id="u99dc2502">通过以下指令，可以将leader分配到优先的leader对应的broker，确保leader是均匀分配的</li></ul></li></ul> 
<pre id="V20pM"><code>bin/kafka-leader-election.sh --bootstrap-server node1.itcast.cn:9092 --topic test --partition=2 --election-type preferred</code></pre> 
<h4 id="VyoAd">Kafka读写流程</h4> 
<ul><li id="u5c42049e">写流程</li></ul> 
<ul><li> 
  <ul><li id="u993972e3">通过ZooKeeper找partition对应的leader，leader是负责写的</li><li id="uac61f377">producer开始写入数据</li><li id="ud91e3958">ISR里面的follower开始同步数据，并返回给leader ACK</li><li id="u5fd0bff4">返回给producer ACK</li></ul></li></ul> 
<ul><li id="u8fa13580">读流程</li></ul> 
<ul><li> 
  <ul><li id="ubc697570">通过ZooKeeper找partition对应的leader，leader是负责读的</li><li id="u0f1626ad">通过ZooKeeper找到消费者对应的offset</li><li id="u313e4dc1">然后开始从offset往后顺序拉取数据</li><li id="u2ad93887">提交offset（自动提交——每隔多少秒提交一次offset、手动提交——放入到事务中提交）</li></ul></li></ul> 
<h4 id="pedh0">Kafka的物理存储</h4> 
<ul><li id="u088f727f">Kafka的数据组织结构</li></ul> 
<ul><li> 
  <ul><li id="ub87d352a">topic</li><li id="u1912e508">partition</li><li id="u68c10152">segment</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="ub51fb5db">.log数据文件</li><li id="ua2da2bb1">.index（稀疏索引）</li><li id="u9d4df8e6">.timeindex（根据时间做的索引）</li></ul></li></ul></li></ul> 
<ul><li id="u915697ff">深入了解读数据的流程</li></ul> 
<ul><li> 
  <ul><li id="ub7d69503">消费者的offset是一个针对partition全局offset</li><li id="u0ce28125">可以根据这个offset找到segment段</li><li id="ub46ebf4a">接着需要将全局的offset转换成segment的局部offset</li><li id="u6e996c51">根据局部的offset，就可以从（.index稀疏索引）找到对应的数据位置</li><li id="ud512011b">开始顺序读取</li></ul></li></ul> 
<h4 id="fjtHG">消息传递的语义性</h4> 
<p id="ub3b33fbe">Flink里面有对应的每种不同机制的保证，提供Exactly-Once保障（二阶段事务提交方式）</p> 
<ul><li id="uef55fb64">At-most once：最多一次（只管把数据消费到，不管有没有成功，可能会有数据丢失）</li><li id="u1ecab2c5">At-least once：最少一次（有可能会出现重复消费）</li><li id="u2a4f31ce">Exactly-Once：仅有一次（事务性性的保障，保证消息有且仅被处理一次）</li></ul> 
<h4 id="a00Qi">Kafka的消息不丢失</h4> 
<ul><li id="u7bd4f244">broker消息不丢失：因为有副本relicas的存在，会不断地从leader中同步副本，所以，一个broker crash，不会导致数据丢失，除非是只有一个副本。</li><li id="ufabe9a32">生产者消息不丢失：ACK机制（配置成ALL/-1）、配置0或者1有可能会存在丢失</li><li id="ucf6c61e6">消费者消费不丢失：重点控制offset</li></ul> 
<ul><li> 
  <ul><li id="u228ae629">At-least once：一种数据可能会重复消费</li><li id="u4f474575">Exactly-Once：仅被一次消费</li></ul></li></ul> 
<h4 id="i2dQT">数据积压</h4> 
<ul><li id="u1bbe87a9">数据积压指的是消费者因为有一些外部的IO、一些比较耗时的操作（Full GC——Stop the world），就会造成消息在partition中一直存在得不到消费，就会产生数据积压</li><li id="ue39611cd">在企业中，我们要有监控系统，如果出现这种情况，需要尽快处理。虽然后续的Spark Streaming/Flink可以实现背压机制，但是数据累积太多一定对实时系统它的实时性是有说影响的</li></ul> 
<h4 id="EpJho">数据清理&amp;配额限速</h4> 
<ul><li id="u05313e43">数据清理</li></ul> 
<ul><li> 
  <ul><li id="ua8c4cab3">Log Deletion（日志删除）：如果消息达到一定的条件（时间、日志大小、offset大小），Kafka就会自动将日志设置为待删除（segment端的后缀名会以 .delete结尾），日志管理程序会定期清理这些日志</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u0da71571">默认是7天过期</li></ul></li></ul></li></ul> 
<ul><li> 
  <ul><li id="u29ae1145">Log Compaction（日志合并）</li></ul></li></ul> 
<ul><li> 
  <ul><li> 
    <ul><li id="u09460a08">如果在一些key-value数据中，一个key可以对应多个不同版本的value</li><li id="uf8b7cf51">经过日志合并，就会只保留最新的一个版本</li></ul></li></ul></li></ul> 
<ul><li id="u658be504">配额限速</li></ul> 
<ul><li> 
  <ul><li id="u337fba59">可以限制Producer、Consumer的速率</li><li id="u21150b77">防止Kafka的速度过快，占用整个服务器（broker）的所有IO资源</li></ul></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72545ff0a7d3fa0614a64711ce5b0fa5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 10 设置安装白名单，禁止其他app安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/57d4c13ae79e3ce349fbcf265fd9e52a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用pdfjs报错：Failed to load module script: Expected a JavaScript module script but the server responded</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>