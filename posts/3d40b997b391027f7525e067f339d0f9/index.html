<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】一文掌握C&#43;&#43;的四种类型转换 --- static_cast、reinterpret_cast、const_cast、dynamic_cast - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3d40b997b391027f7525e067f339d0f9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】一文掌握C&#43;&#43;的四种类型转换 --- static_cast、reinterpret_cast、const_cast、dynamic_cast">
  <meta property="og:description" content="当面对两个选择时，抛硬币总能奏效。 并不是因为它总能给出对的答案， 而是在你把它抛在空中的那一秒里。 你突然就知道，你希望的结果是什么了。 --- 曾小贤 《爱情公寓》--- 一文掌握C&#43;&#43;的四种类型转换 1 C&#43;&#43;中的类型2 类型转换3 四种类型转换3.1 static_cast 静态转换3.2 reinterpret_cast 重新解释3.3 const_cast 去常转换3.4 dynamic_cast 动态转换3.5 RTTI（了解） 4 使用建议 1 C&#43;&#43;中的类型 C&#43;&#43;中类型分为两种：内置类型和自定义类型。内置类型中分为算术类型和空类型。其中算术类型包含字符，整型，布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。
类型含义尺寸bool布尔类型只有一位 1表示True 0表示False 有数据表示为True,0表示为Falsechar字符8 位wchar_t宽字符16位char16_tUnicode字符16位char32_tUnicode字符32位short短整型C&#43;&#43;要求short类型不少于16位 ，一般为16位int整型C&#43;&#43;要求int类型至少与short类型一样长，一般为32位long长整型C&#43;&#43;要求long至少为32位，且至少与int一样长 ， 一般为32位long long长整型C&#43;&#43;要求long long至少为64位，且至少与long一样长，一般为64位float单精度浮点型C&#43;&#43;要求至少为32位。后缀F or fdouble双精度浮点型C&#43;&#43;要求至少为48位，且不少于floatlong double扩展精度浮点型C&#43;&#43;要求为80，96，128位，至少和double类型位数一样多 对于这些内置类型，在使用时将一个类型赋值给另一个类型或者是在进行运算时，如果两个类型有关联就会发生隐式类型转换，这种转换不需要程序员介入，是自动执行的，这种转换是有可能造成数据丢失的！
2 类型转换 在C语言中，如果赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化，C语言中总共有两种形式的类型转换：隐式类型转换和显式类型转换。
隐式类型转化：编译器在编译阶段自动进行，能转就转（有关联才能转），不能转就编译失败。整型之间，浮点数和整型之间显式类型转化（强制类型转换）：需要用户自己处理，各类指针是可以显式类型转换的！ 在C&#43;&#43;中同样支持C语言风格的类型转换，并且新增了内置类型向自定义类型的转换和自定义类型向内置类型的转换！
我们来写一个类来看看：
class A { public: //explicit A(int a1) 这样不支持隐式类型转换！ A(int a1) :_a1(a1) {} private: int _a1; int _a2; }; int main() { A aa1 = 1; return 0; } 像这样的单参数构造函数的类支持隐式类型转换！多参数的构造函数就需要使用{ } 来进行列表初始化，才可以做到类型转换！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-15T15:21:30+08:00">
    <meta property="article:modified_time" content="2024-08-15T15:21:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】一文掌握C&#43;&#43;的四种类型转换 --- static_cast、reinterpret_cast、const_cast、dynamic_cast</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/1d/01/xKtVatpJ_o.png" alt="在这里插入图片描述"></p> 
<div align="center"> 
 <font color="#42d7f9" size="5">当面对两个选择时，抛硬币总能奏效。 </font> 
 <div align="center"> 
  <font color="#42d7f9" size="5">并不是因为它总能给出对的答案， </font> 
  <div align="center"> 
   <font color="#42d7f9" size="5">而是在你把它抛在空中的那一秒里。 </font> 
   <div align="center"> 
    <font color="#42d7f9" size="5">你突然就知道，你希望的结果是什么了。 </font> 
    <div align="center"> 
     <font color="#42d7f9" size="5"> --- 曾小贤 《爱情公寓》--- </font> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>一文掌握C++的四种类型转换</h4> 
 <ul><li><a href="#1_C_10" rel="nofollow">1 C++中的类型</a></li><li><a href="#2__30" rel="nofollow">2 类型转换</a></li><li><a href="#3__81" rel="nofollow">3 四种类型转换</a></li><li><ul><li><a href="#31_static_cast__93" rel="nofollow">3.1 static_cast 静态转换</a></li><li><a href="#32_reinterpret_cast__109" rel="nofollow">3.2 reinterpret_cast 重新解释</a></li><li><a href="#33_const_cast__115" rel="nofollow">3.3 const_cast 去常转换</a></li><li><a href="#34_dynamic_cast__139" rel="nofollow">3.4 dynamic_cast 动态转换</a></li><li><a href="#35_RTTI_177" rel="nofollow">3.5 RTTI（了解）</a></li></ul> 
  </li><li><a href="#4__183" rel="nofollow">4 使用建议</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_C_10"></a>1 C++中的类型</h2> 
<p>C++中类型分为两种：内置类型和自定义类型。内置类型中分为算术类型和空类型。其中算术类型包含字符，整型，布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。</p> 
<table><thead><tr><th>类型</th><th>含义</th><th>尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>只有一位 1表示True 0表示False 有数据表示为True,0表示为False</td></tr><tr><td>char</td><td>字符</td><td>8 位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr><tr><td>short</td><td>短整型</td><td>C++要求short类型不少于16位 ，一般为16位</td></tr><tr><td>int</td><td>整型</td><td>C++要求int类型至少与short类型一样长，一般为32位</td></tr><tr><td>long</td><td>长整型</td><td>C++要求long至少为32位，且至少与int一样长 ， 一般为32位</td></tr><tr><td>long long</td><td>长整型</td><td>C++要求long long至少为64位，且至少与long一样长，一般为64位</td></tr><tr><td>float</td><td>单精度浮点型</td><td>C++要求至少为32位。后缀F or f</td></tr><tr><td>double</td><td>双精度浮点型</td><td>C++要求至少为48位，且不少于float</td></tr><tr><td>long double</td><td>扩展精度浮点型</td><td>C++要求为80，96，128位，至少和double类型位数一样多</td></tr></tbody></table> 
<p>对于这些内置类型，在使用时将一个类型赋值给另一个类型或者是在进行运算时，如果两个类型有关联就会发生隐式类型转换，这种转换不需要程序员介入，是自动执行的，这种转换是有可能造成数据丢失的！</p> 
<h2><a id="2__30"></a>2 类型转换</h2> 
<p>在C语言中，如果赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化，C语言中总共有两种形式的类型转换：隐式类型转换和显式类型转换。</p> 
<ol><li>隐式类型转化：编译器在编译阶段自动进行，能转就转（有关联才能转），不能转就编译失败。整型之间，浮点数和整型之间</li><li>显式类型转化（强制类型转换）：需要用户自己处理，各类指针是可以显式类型转换的！</li></ol> 
<p>在C++中同样支持C语言风格的类型转换，并且新增了内置类型向自定义类型的转换和自定义类型向内置类型的转换！<br> 我们来写一个类来看看：</p> 
<pre><code class="prism language-cpp">
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//explicit A(int a1) 这样不支持隐式类型转换！</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a1</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A aa1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>像这样的单参数构造函数的类支持隐式类型转换！多参数的构造函数就需要使用<code>{ } </code>来进行列表初始化，才可以做到类型转换！<br> 如果不希望该类进行隐式类型转换，可以使用<code>explicit</code>关键字进行修饰，这样就不支持内置类型向自定义类型的隐式类型转换了！</p> 
<p>在来看自定义类型如何向内置类型进行转换呢？C++通过了一个十分直接的方法，想转什么类型就<code>operator</code>重载什么类型：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//explicit A(int a1) 这样不支持隐式类型转换！</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a1</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _a1 <span class="token operator">+</span> _a2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>很简单的操作逻辑，这就是C++支持的自定义类型向内置类型的转换，这个不太常用，只要是在<code>IO</code>流中的对象中会有<code>operator bool()</code>来支持进行布尔的判断！</p> 
<p>自定义类型之间的类型转换可以通过拷贝构造来进行！</p> 
<h2><a id="3__81"></a>3 四种类型转换</h2> 
<p>C风格的转换格式很简单，但是有不少缺点的：</p> 
<ol><li>隐式类型转化有些情况下可能会出问题：比如数据精度丢失</li><li>显式类型转换将所有情况混合在一起，代码不够清晰</li></ol> 
<p>因此C++提出了自己的类型转化风格，注意因为C++要兼容C语言，所以C++中还可以使用C语言的转化风格：</p> 
<ol><li>隐式类型转换（静态转换）：static_cast</li><li>强制类型转换（重新解释）：reinterpret_cast</li><li>去常转换：const_cast</li><li>动态转换：dynamic_cast</li></ol> 
<h3><a id="31_static_cast__93"></a>3.1 static_cast 静态转换</h3> 
<p>static_cast用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用static_cast，但它不能用于两个不相关的类型进行转换。也就是说，只要是C风格的类型转换，可以都套上<code>static_cast</code>!</p> 
<p>任何具有明确定义的类型转换，只有是不包括底层const，都可以使用static_cast!<br> <img src="https://images2.imgbox.com/ed/2a/cMFbPg0c_o.png" alt="在这里插入图片描述"><br> 注意：隐式类型转换不支持的转换，套上static_cast也不支持！</p> 
<p>如果我们将一些需要进行强制类型转换的场景也套上 static_cast，这时就会发生报错了！这保证了不能乱用<br> 对于需要强制类型转换的场景需要使用<code>reinterpret_cast</code><br> 总结：</p> 
<ol><li>static_cast 可以用于基本类型的转换</li><li>static_cast 不能用于基本类型指针间的转换（需要强制类型转换）</li><li>static_cast可以用于有继承关系类对象之间的转换和类指针之间的转换<br> (派生类转换成基类时安全(上行转换)，基类转换成派生类时不安全(下行转换))<br> <img src="https://images2.imgbox.com/12/4c/d8IiChZq_o.png" alt="在这里插入图片描述"></li></ol> 
<h3><a id="32_reinterpret_cast__109"></a>3.2 reinterpret_cast 重新解释</h3> 
<p>在隐式类型转换不能进行转换时，我们就需要强制类型转换。强制类型转换很有可能会造成运行时的错误！</p> 
<p>reinterpret_cast操作符通常为操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不同的类型</p> 
<h3><a id="33_const_cast__115"></a>3.3 const_cast 去常转换</h3> 
<p>const_cast 只能改变运算对象的底层const。只有 const_cast 可以做到去常，并且还要配合使用<code>volatie</code>关键字。const_cast最常用的用途就是删除变量的const属性，方便赋值。会将一个稳定的变量变成不稳定的！<br> <img src="https://images2.imgbox.com/d2/1f/LPENcNSl_o.png" alt="在这里插入图片描述"></p> 
<p>去常操作常常在函数重载中进行使用：比如在类内我们要实习一个功能：比较两个字符串的大小。为了适配常量字符串和非常量字符串，我们需要进行一个函数重载：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> string<span class="token operator">&amp;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1 <span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1  <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
string<span class="token operator">&amp;</span> <span class="token function">func</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s1 <span class="token punctuation">,</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1  <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的场景是很常见的，如果遇到函数实现比较复杂的情况，在使用上面的做法就有些冗余了，我们可以在上层对<code>const</code>版本的函数进行一次包装，来适配正常版本：</p> 
<pre><code class="prism language-cpp">string<span class="token operator">&amp;</span> <span class="token function">func</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s1 <span class="token punctuation">,</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span> <span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样就简单通过一个<code>const</code>版本的函数，通过<strong>去常操作</strong>实现了非<code>const</code>版本的函数！这是十分安全的操作！</p> 
<h3><a id="34_dynamic_cast__139"></a>3.4 dynamic_cast 动态转换</h3> 
<p>dynamic_cast用于将一个父类对象的指针/引用转换为子类对象的指针或引用(动态转换)<br> 向上转换：子类对象指针/引用-&gt;父类指针/引用(不需要转换，赋值兼容规则)<br> 向下转换：父类对象指针/引用-&gt;子类指针/引用(用dynamic_cast转型是安全的)</p> 
<p>学习过继承之后，我们知道派生类内部是包含一个基类，可以通过切片的方式来转换成基类！甚至不需要产生临时对象！这是天然支持的！但是对于基类转换为子类就有点复杂了！</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>A<span class="token operator">*</span> pa<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span>pa<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对于这样一个函数，基类指针会强制类型转换为子类指针，当pa指针本来就是指向的是一个B对象，在转换回去，没有问题。但是当pa指针指向的是A对象，那么强行转换会造成越界的问题！在读取时会造成崩溃！</p> 
<p>为了解决这个问题，可以使用 <code>dynamic_cast</code> :</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>A<span class="token operator">*</span> pa<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pb<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> pb <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		pb<span class="token operator">-&gt;</span>_b1<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"转换失败！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果pa指针指向的是B对象，转换成功！<br> 如果pa指针指向的是A对象，转换失败！返回空！</p> 
<p>总结：</p> 
<ol><li>dynamic_cast<strong>只能用于父类含有虚函数的类</strong></li><li>dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回0</li></ol> 
<h3><a id="35_RTTI_177"></a>3.5 RTTI（了解）</h3> 
<p>RTTI：<code>Run-time Type identification</code>的简称，即：运行时类型识别。<br> C++通过以下方式来支持RTTI：</p> 
<ol><li>typeid 运算符</li><li>dynamic_cast 运算符</li><li>decltype</li></ol> 
<h2><a id="4__183"></a>4 使用建议</h2> 
<p>强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员避免使用强制类型转换。这个建议对于<code>reinterpret_cast</code>尤其适用，因为此类类型转换总是充满了风险。</p> 
<p>在有重载函数的上下文中使用<code>const cast</code>无可厚非，但是在其他情况下使用<code>const cast</code>也就意味着程序存在某种设计缺陷。其他强制类型转换，比如<code>static_cast</code>和<code>dynamic_cast</code>,都不应该频繁使用。</p> 
<p><font color="red"><strong>每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标</strong>。<strong>就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会</strong>。</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f9e7ed4431051624df89943f81000c4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RabbitMQ的消息确认机制Ack Mode</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d29dcad1f9ea79a404c8992f81bd97c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot-03-整合Redis</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>