<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python爬虫爬取微博评论--完整版(超详细，大学生不骗大学生) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bdfa268afe7f36090e1ce31d4d8e70c9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="python爬虫爬取微博评论--完整版(超详细，大学生不骗大学生)">
  <meta property="og:description" content="目录
一、找到页面
二、学会使用检查元素
2.1 打开检查元素界面
2.2 找到所有评论所在的位置
2.2.1 搜索评论
2.2.2 找到data表
三、基础部分代码实现 四、格式化输出
4.1 了解存储格式
4.2 单独取出内容
4.3 取出所有评论内容
4.4 格式化读取信息
五、导出成表格形式
六、了解分页
6.1 查看分页
6.2 寻找分页的规律
七、多页实现 八、完整代码
九、大多数报错原因
一、找到页面 首先你需要找到一个你想要爬取的页面
（这里我是随机找的一个微博帖子）
它的评论内容是这样的
然后我们今天的内容就是从这个页面的评论里面提取我们想要的
（其实学会了之后不只可以爬取评论的内容喔！！）
二、学会使用检查元素 2.1 打开检查元素界面 在你打开的页面-&gt;单机右键-&gt;检查元素(或者是审查元素)，然后我们就可以看到这个界面
这里你的上面一行表头可能会是英文嘟没关系(我会把英文界面该点的标在括号里)
我们主要用的是网络（network）这部分 点击网络（network） 如果点击小放大镜后界面和我这个差不多那就大概率是对的 如果你没有这小放大镜可以换个浏览器
(我目前用下来，苹果自带的Safari浏览器是不行的，我用的这个例子里是360浏览器，是OK嘟，大家可以参考一下)
2.2 找到所有评论所在的位置 2.2.1 搜索评论 这里我们在搜索的界面输入我们这个帖子里面随便一条评论的内容，点击搜索 如果你在这里黏贴了评论的内容但是，显示搜索不到结果你可以试一试
不关闭检查元素的界面-&gt;退出当前网页或者你随机点一个人的主页-&gt;再回到评论界面-&gt;搜索评论内容就会出现了！
2.2.2 找到data表 下一步我们 点击搜索出的结果
显示的界面是这样的
然后我们点击这个预览(preview)
再说一次喔，有可能大家的检查元素打开的是全英文的，但是没关系我会把英文该点的标在括号里
（后面的大部分操作都是在这个预览界面的） 点击data旁边的小三角，展开data
展现的结果是这样的 然后这个里面的0-19，就是0-19条评论的数据，包括一些评论内容，评论人的ID，评论被点赞的数量等等，我们一会要爬取的数据就是从这里来的
三、基础部分代码实现 首先我们要知道想要爬取一个网站的数据我们首先需要访问网站
我们的代码需要通过网站的url来找到网站
下面我们先将爬取网站的基础格式写出来
#requets是一个爬虫的第三方库，需要单独安装 import requests #url是一访问网站的地址(这个不是很了解，但是我们代码是需要通过url来找到你要爬取的网页) url = &#39;&#39; #1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-29T17:31:31+08:00">
    <meta property="article:modified_time" content="2024-05-29T17:31:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python爬虫爬取微博评论--完整版(超详细，大学生不骗大学生)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%89%BE%E5%88%B0%E9%A1%B5%E9%9D%A2-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%89%BE%E5%88%B0%E9%A1%B5%E9%9D%A2" rel="nofollow">一、找到页面</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0" rel="nofollow"> 二、学会使用检查元素</a></p> 
<p id="2.1%20%E6%89%93%E5%BC%80%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E7%95%8C%E9%9D%A2-toc" style="margin-left:40px;"><a href="#2.1%20%E6%89%93%E5%BC%80%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E7%95%8C%E9%9D%A2" rel="nofollow">2.1 打开检查元素界面</a></p> 
<p id="2.2%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#2.2%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow">2.2 找到所有评论所在的位置</a></p> 
<p id="2.2.1%20%E6%90%9C%E7%B4%A2%E8%AF%84%E8%AE%BA-toc" style="margin-left:80px;"><a href="#2.2.1%20%E6%90%9C%E7%B4%A2%E8%AF%84%E8%AE%BA" rel="nofollow">2.2.1 搜索评论</a></p> 
<p id="2.2.2%20%C2%A0%E6%89%BE%E5%88%B0data%E8%A1%A8-toc" style="margin-left:80px;"><a href="#2.2.2%20%C2%A0%E6%89%BE%E5%88%B0data%E8%A1%A8" rel="nofollow">2.2.2  找到data表</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">三、基础部分代码实现 </a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA" rel="nofollow"> 四、格式化输出</a></p> 
<p id="2.1%20%E4%BA%86%E8%A7%A3%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.1%20%E4%BA%86%E8%A7%A3%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F" rel="nofollow">4.1 了解存储格式</a></p> 
<p id="2.2%20%E5%8D%95%E7%8B%AC%E5%8F%96%E5%87%BA%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#2.2%20%E5%8D%95%E7%8B%AC%E5%8F%96%E5%87%BA%E5%86%85%E5%AE%B9" rel="nofollow">4.2 单独取出内容</a></p> 
<p id="2.3%20%E5%8F%96%E5%87%BA%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA%E5%86%85%E5%AE%B9-toc" style="margin-left:40px;"><a href="#2.3%20%E5%8F%96%E5%87%BA%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA%E5%86%85%E5%AE%B9" rel="nofollow">4.3 取出所有评论内容</a></p> 
<p id="2.4%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%8F%96%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#2.4%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%8F%96%E4%BF%A1%E6%81%AF" rel="nofollow">4.4 格式化读取信息</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%AF%BC%E5%87%BA%E6%88%90%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F(%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%9B%B4%E6%8E%A5%E7%9C%8B%E8%BF%99)-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%AF%BC%E5%87%BA%E6%88%90%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F%28%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%9B%B4%E6%8E%A5%E7%9C%8B%E8%BF%99%29" rel="nofollow">五、导出成表格形式</a></p> 
<p id="%E5%85%AD%E3%80%81%E4%BA%86%E8%A7%A3%E5%88%86%E9%A1%B5-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E4%BA%86%E8%A7%A3%E5%88%86%E9%A1%B5" rel="nofollow">六、了解分页</a></p> 
<p id="6.1%20%E6%9F%A5%E7%9C%8B%E5%88%86%E9%A1%B5-toc" style="margin-left:40px;"><a href="#6.1%20%E6%9F%A5%E7%9C%8B%E5%88%86%E9%A1%B5" rel="nofollow">6.1 查看分页</a></p> 
<p id="6.2%20%E5%AF%BB%E6%89%BE%E5%88%86%E9%A1%B5%E7%9A%84%E8%A7%84%E5%BE%8B-toc" style="margin-left:40px;"><a href="#6.2%20%E5%AF%BB%E6%89%BE%E5%88%86%E9%A1%B5%E7%9A%84%E8%A7%84%E5%BE%8B" rel="nofollow">6.2 寻找分页的规律</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%A4%9A%E9%A1%B5%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%A4%9A%E9%A1%B5%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">七、多页实现 </a></p> 
<p id="%E5%85%AB%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">八、完整代码</a></p> 
<p id="%E4%B9%9D%E3%80%81%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0" rel="nofollow">九、大多数报错原因</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%89%BE%E5%88%B0%E9%A1%B5%E9%9D%A2">一、找到页面</h2> 
<blockquote> 
 <p>首先你需要找到一个你想要爬取的页面</p> 
</blockquote> 
<p>（这里我是随机找的一个微博帖子）</p> 
<p><img alt="" src="https://images2.imgbox.com/55/91/ok72KlWc_o.png"></p> 
<p></p> 
<blockquote> 
 <p>它的评论内容是这样的</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/6c/d2/Sq2Igqk6_o.png"></p> 
<p>然后我们今天的内容就是从这个页面的评论里面提取我们想要的</p> 
<p>（其实学会了之后不只可以爬取评论的内容喔！！）</p> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0"> 二、学会使用检查元素</h2> 
<h3 id="2.1%20%E6%89%93%E5%BC%80%E6%A3%80%E6%9F%A5%E5%85%83%E7%B4%A0%E7%95%8C%E9%9D%A2">2.1 打开检查元素界面</h3> 
<blockquote> 
 <p>在你打开的页面-&gt;单机右键-&gt;检查元素(或者是审查元素)，然后我们就可以看到这个界面</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/ba/c1/M18MHvHu_o.png"></p> 
<p>这里你的上面一行表头可能会是英文嘟没关系(我会把英文界面该点的标在括号里)</p> 
<p>我们主要用的是网络（network）这部分 </p> 
<p></p> 
<blockquote> 
 <p>点击网络（network） </p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/60/b3/gft7Y5aU_o.png"></p> 
<p>如果点击小放大镜后界面和我这个差不多那就大概率是对的 </p> 
<p>如果你没有这小放大镜可以换个浏览器</p> 
<p>(我目前用下来，苹果自带的Safari浏览器是不行的，我用的这个例子里是360浏览器，是OK嘟，大家可以参考一下)</p> 
<h3 id="2.2%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA%E6%89%80%E5%9C%A8%E7%9A%84%E4%BD%8D%E7%BD%AE">2.2 找到所有评论所在的位置</h3> 
<h4 id="2.2.1%20%E6%90%9C%E7%B4%A2%E8%AF%84%E8%AE%BA">2.2.1 搜索评论</h4> 
<blockquote> 
 <p>这里我们在搜索的界面输入我们这个帖子里面随便一条评论的内容，点击搜索 </p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/4c/f7/elZ9xG5Z_o.png"></p> 
<p>如果你在这里黏贴了评论的内容但是，显示搜索不到结果你可以试一试</p> 
<p>不关闭检查元素的界面-&gt;退出当前网页或者你随机点一个人的主页-&gt;再回到评论界面-&gt;搜索评论内容就会出现了！</p> 
<h4 id="2.2.2%20%C2%A0%E6%89%BE%E5%88%B0data%E8%A1%A8">2.2.2  找到data表</h4> 
<blockquote> 
 <p>下一步我们 点击搜索出的结果</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/2b/4d/WFDGpEbZ_o.png"></p> 
<p></p> 
<blockquote> 
 <p>显示的界面是这样的</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/f3/bd/ss6rUnrK_o.png"></p> 
<p></p> 
<blockquote> 
 <p>然后我们点击这个预览(preview)</p> 
</blockquote> 
<p>再说一次喔，有可能大家的检查元素打开的是全英文的，但是没关系我会把英文该点的标在括号里</p> 
<p>（后面的大部分操作都是在这个预览界面的） </p> 
<p><img alt="" src="https://images2.imgbox.com/de/56/MDe1SjOt_o.png"></p> 
<p></p> 
<blockquote> 
 <p>点击data旁边的小三角，展开data</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/38/9d/N10EHdn4_o.png"></p> 
<p></p> 
<blockquote> 
 <p>展现的结果是这样的 </p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/ba/54/aur6YqRv_o.png"></p> 
<p>然后这个里面的0-19，就是0-19条评论的数据，包括一些评论内容，评论人的ID，评论被点赞的数量等等，我们一会要爬取的数据就是从这里来的</p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0">三、基础部分代码实现 </h2> 
<p>首先我们要知道想要爬取一个网站的数据我们首先需要访问网站</p> 
<blockquote> 
 <p>我们的代码需要通过网站的url来找到网站</p> 
</blockquote> 
<blockquote> 
 <p>下面我们先将爬取网站的基础格式写出来</p> 
</blockquote> 
<pre><code>#requets是一个爬虫的第三方库，需要单独安装
import requests

#url是一访问网站的地址(这个不是很了解，但是我们代码是需要通过url来找到你要爬取的网页)
url = ''

#1.发送请求(定义一个response变量用来存储从url所对应的网页得到的信息)
response = requests.get(url=url)

#2.打印请求状态（response有很多属性，比如text等等，但是直接打印response是打印当前请求的状态码，200是成功，404是错误）
print(response)</code></pre> 
<p>从上面的几行代码我们就能实现对网站的访问,但是，我们该怎么获取一个网站的url呢？</p> 
<p></p> 
<blockquote> 
 <p>找到我们有data列表的那个检查元素界面-&gt;点击标头(headers)</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/f5/ca/tRGfkTuW_o.png"></p> 
<p>在这里可以看到一个 “请求网址” （URL），这个就是我们的请求头</p> 
<p>将这个URL复制到我们代码里面</p> 
<pre><code>#requets是一个爬虫的第三方库，需要单独安装
import requests

#url是一访问网站的地址
url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291&amp;fetch_level=0&amp;locale=zh-CN'

#1.发送请求
response = requests.get(url=url)

#2.打印请求状态
print(response)</code></pre> 
<blockquote> 
 <p>这里我用PyCharm运行一下代码</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/1f/6f/GUhEGY4z_o.png"></p> 
<p>可以看到输出显示 &lt;Response [200]&gt;，代表着我们访问成功了</p> 
<p></p> 
<blockquote> 
 <p>下一步我们可以试着把网页的数据用 .text的方式拿出来 </p> 
</blockquote> 
<pre><code>#requets是一个爬虫的第三方库，需要单独安装
import requests

#url是一访问网站的地址
url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291&amp;fetch_level=0&amp;locale=zh-CN'

#1.发送请求
response = requests.get(url=url)

#2.打印网页数据
print(response.text)</code></pre> 
<blockquote> 
 <p>我们运行一下</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/23/bc/GXxpdbXt_o.png"></p> 
<p></p> 
<blockquote> 
 <p> 但是我们发现这个并不是像我们想的一样，将网页的文本用文字的方式呈现，那么接下来我们要用到一个方法，让我们能够用文字的方式输出网页数据-----&gt;定义请求头</p> 
</blockquote> 
<pre><code>import requests

# 请求头
headers = {
    # 用户身份信息
    'cookie' : '',
    # 防盗链
    'referer' : '',
    # 浏览器基本信息
    'user-agent' : ''
}

url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291'
# 1.发送请求
response = requests.get(url=url,headers=headers)

#2.打印网页数据
print(response.text)</code></pre> 
<p>为什么要定义请求头，因为从网站的设置初衷，它是不想服务于我们的爬虫程序的，网站正常只想服务于客户的访问服务，那么我们要将我们的爬虫程序伪装成为正常的服务。</p> 
<blockquote> 
 <p>此时我们需要定义一些数据来伪装，通常我们只需要设置 cookie 、referee、user-agent就够了(如果有些特殊的网站可能需要我们有其他的参数) </p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>那么我们cookie这些数据从哪里来呢，我们回到网站的那个请求头(headers)的检查元素界面 </p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/c6/c0/MpbX9yAU_o.png"></p> 
<p></p> 
<blockquote> 
 <p>在这个界面向下划动，找到 cookie 、referer 、user-agent </p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/0b/7c/1Hf4ghuv_o.png"></p> 
<p></p> 
<p>我们将 cookie 、referer 、user-agent 的数据分别粘贴在代码里面</p> 
<pre><code>import requests

# 请求头
headers = {
    # 用户身份信息
    'cookie' : 'XSRF-TOKEN=KVMLznKAi1u5t7UavCDVyD0I; _s_tentry=weibo.com; Apache=3869338173200.8403.1711845564842; SINAGLOBAL=3869338173200.8403.1711845564842; ULV=1711845565244:1:1:1:3869338173200.8403.1711845564842:; PC_TOKEN=dcbe0bd978; SUB=_2A25LDMCxDeRhGeFJ71sS8CvLzTmIHXVoYFx5rDV8PUNbmtB-LVD9kW9Nf6JZvhCZ3PGanwgbD1yc6zGrHhnf6wrq; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9W586R5s7_p1VykF21DkOu3L5JpX5o275NHD95QNS0B4e05fS0qfWs4DqcjAMJv09CH8SE-4BC-RSFH8SCHFxb-ReEH8SFHFBC-RBbH8Sb-4SEHWSCH81FHWxCHFeFH8Sb-4BEHWB7tt; ALF=1712450401; SSOLoginState=1711845601; WBPSESS=7dB0l9FjbY-Rzc9u1r7G0AeIukWsnj2u9VSmMssaP8z8nNdVQm3MrakDKiijTO3Y_iL6pEDJ8mgGw5Ql6jIh-aVUQoUZdu9LfLYmAiNsLqi43OBU2ZJdNYv4zIWorgKZiAz8JGn2kAugZwnStCVYKw==',
    # 防盗链
    'referer' : 'https://weibo.com/2810373291/O7pPo1Ptb',
    # 浏览器基本信息
    'user-agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.95 Safari/537.36'
}
url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291'
# 1.发送请求
response = requests.get(url=url,headers=headers)

#2.打印网页数据
print(response.text)
</code></pre> 
<blockquote> 
 <p>运行一下 </p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/64/d8/wCGVgHBM_o.png"></p> 
<p> 在这里可以看到，我们已经拿到文字式的数据，但是数据过于多和复杂，没办法很好的现实提取评论内容</p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"> 四、格式化输出</h2> 
<p>那么接下来，我们想要将这些数据更加规整的输出</p> 
<h3 id="2.1%20%E4%BA%86%E8%A7%A3%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F">4.1 了解存储格式</h3> 
<blockquote> 
 <p>1.那么我们首先要观察这些数据的存储方式</p> 
</blockquote> 
<blockquote> 
 <p>打开网页 -&gt; 单击右键 -&gt; 审查元素 -&gt; 搜索一条评论 -&gt; 点击预览(preview) -&gt; 点击data旁边的小箭头 -&gt; 点击 0 旁边的小箭头<img alt="" src="https://images2.imgbox.com/a4/33/JdHb1Ty7_o.png"></p> 
</blockquote> 
<p>那么在这林我们可以看到这里存有很多关于评论的数据，例如text_raw是评论的文本内容，source是发表评论人的ip来源地，id是发表评论人的id等等等</p> 
<p></p> 
<h3 id="2.2%20%E5%8D%95%E7%8B%AC%E5%8F%96%E5%87%BA%E5%86%85%E5%AE%B9">4.2 单独取出内容</h3> 
<blockquote> 
 <p>那么我们先将第一个评论的text_raw用代码取出来试一下</p> 
</blockquote> 
<pre><code>import requests
# 请求头
headers = {
    # 用户身份信息
    'cookie' : 'XSRF-TOKEN=KVMLznKAi1u5t7UavCDVyD0I; _s_tentry=weibo.com; Apache=3869338173200.8403.1711845564842; SINAGLOBAL=3869338173200.8403.1711845564842; ULV=1711845565244:1:1:1:3869338173200.8403.1711845564842:; PC_TOKEN=dcbe0bd978; SUB=_2A25LDMCxDeRhGeFJ71sS8CvLzTmIHXVoYFx5rDV8PUNbmtB-LVD9kW9Nf6JZvhCZ3PGanwgbD1yc6zGrHhnf6wrq; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9W586R5s7_p1VykF21DkOu3L5JpX5o275NHD95QNS0B4e05fS0qfWs4DqcjAMJv09CH8SE-4BC-RSFH8SCHFxb-ReEH8SFHFBC-RBbH8Sb-4SEHWSCH81FHWxCHFeFH8Sb-4BEHWB7tt; ALF=1712450401; SSOLoginState=1711845601; WBPSESS=7dB0l9FjbY-Rzc9u1r7G0AeIukWsnj2u9VSmMssaP8z8nNdVQm3MrakDKiijTO3Y_iL6pEDJ8mgGw5Ql6jIh-aVUQoUZdu9LfLYmAiNsLqi43OBU2ZJdNYv4zIWorgKZiAz8JGn2kAugZwnStCVYKw==',
    # 防盗链
    'referer' : 'https://weibo.com/2810373291/O7pPo1Ptb',
    # 浏览器基本信息
    'user-agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.95 Safari/537.36'
}
url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291'
# 1.发送请求
response = requests.get(url=url,headers=headers)
#2.打印网页数据
# .text:获取文本数据
# .json():json字符串数据
# .content:获取二进制数据
# 这里如果我们想要单独取出数据，我们需要用json格式，它是一个格式化的数据
# 用json格式获取数据后我们要找到第一条评论的内容
# 我们把preview界面看作一个文件夹，那么我们首先打开的是 data ，然后是 0 ，然后是 text_raw
# 这里注意 data、text_raw 是字符串要加单引号，但是 0 是整数不用单引号
# 最后用类似于数组的方式访问
print(response.json()['data'][0]['text_raw'])</code></pre> 
<blockquote> 
 <p>运行一下</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/2b/8b/lPG60302_o.png"></p> 
<p>可以看到我们顺利取到了第一条评论的内容</p> 
<p></p> 
<h3 id="2.3%20%E5%8F%96%E5%87%BA%E6%89%80%E6%9C%89%E8%AF%84%E8%AE%BA%E5%86%85%E5%AE%B9">4.3 取出所有评论内容</h3> 
<blockquote> 
 <p>接下来我们将所有的评论内容都取出来，但是我们也不能一条一条写01234，所以，这里我们会用到循环</p> 
 <p></p> 
 <pre><code>import requests
# 请求头
headers = {
    # 用户身份信息
    'cookie' : 'XSRF-TOKEN=KVMLznKAi1u5t7UavCDVyD0I; _s_tentry=weibo.com; Apache=3869338173200.8403.1711845564842; SINAGLOBAL=3869338173200.8403.1711845564842; ULV=1711845565244:1:1:1:3869338173200.8403.1711845564842:; PC_TOKEN=dcbe0bd978; SUB=_2A25LDMCxDeRhGeFJ71sS8CvLzTmIHXVoYFx5rDV8PUNbmtB-LVD9kW9Nf6JZvhCZ3PGanwgbD1yc6zGrHhnf6wrq; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9W586R5s7_p1VykF21DkOu3L5JpX5o275NHD95QNS0B4e05fS0qfWs4DqcjAMJv09CH8SE-4BC-RSFH8SCHFxb-ReEH8SFHFBC-RBbH8Sb-4SEHWSCH81FHWxCHFeFH8Sb-4BEHWB7tt; ALF=1712450401; SSOLoginState=1711845601; WBPSESS=7dB0l9FjbY-Rzc9u1r7G0AeIukWsnj2u9VSmMssaP8z8nNdVQm3MrakDKiijTO3Y_iL6pEDJ8mgGw5Ql6jIh-aVUQoUZdu9LfLYmAiNsLqi43OBU2ZJdNYv4zIWorgKZiAz8JGn2kAugZwnStCVYKw==',
    # 防盗链
    'referer' : 'https://weibo.com/2810373291/O7pPo1Ptb',
    # 浏览器基本信息
    'user-agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.95 Safari/537.36'
}
url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291'
# 1.发送请求
response = requests.get(url=url,headers=headers)
# 2.打印网页数据
# 定义一个json_data来存储 response.json()的数据
json_data = response.json()
# 定义一个data_list取出所有data中的数据
data_list = json_data['data']
# 定义一个data数据，让它便利data_list里面的对象
# 这里怎么理解呢，data_list看作一个数组，我让data等于数组的第一个数
# 然后执行操作，执行完之后返回for，我们再另data等于数组的第二个数执行操作
# 循环往复
for data in data_list:
    # 这里 data 代表着 data_list的第一个数也就是 ['data'][0]
    text_raw = data['text_raw']
    print(text_raw)</code></pre> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>运行一下</p> 
 <p><img alt="" src="https://images2.imgbox.com/69/27/9DLmwGa1_o.png"></p> 
</blockquote> 
<p></p> 
<h3 id="2.4%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%8F%96%E4%BF%A1%E6%81%AF">4.4 格式化读取信息</h3> 
<blockquote> 
 <p>可以看到我们已经取出了所有的评论，那么可能大家还需要爬取这个评论的其他数据，例如发评论人的id，昵称和该条评论的点赞数量</p> 
</blockquote> 
<pre><code>import requests
# 请求头
headers = {
    # 用户身份信息
    'cookie' : 'XSRF-TOKEN=KVMLznKAi1u5t7UavCDVyD0I; _s_tentry=weibo.com; Apache=3869338173200.8403.1711845564842; SINAGLOBAL=3869338173200.8403.1711845564842; ULV=1711845565244:1:1:1:3869338173200.8403.1711845564842:; PC_TOKEN=dcbe0bd978; SUB=_2A25LDMCxDeRhGeFJ71sS8CvLzTmIHXVoYFx5rDV8PUNbmtB-LVD9kW9Nf6JZvhCZ3PGanwgbD1yc6zGrHhnf6wrq; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9W586R5s7_p1VykF21DkOu3L5JpX5o275NHD95QNS0B4e05fS0qfWs4DqcjAMJv09CH8SE-4BC-RSFH8SCHFxb-ReEH8SFHFBC-RBbH8Sb-4SEHWSCH81FHWxCHFeFH8Sb-4BEHWB7tt; ALF=1712450401; SSOLoginState=1711845601; WBPSESS=7dB0l9FjbY-Rzc9u1r7G0AeIukWsnj2u9VSmMssaP8z8nNdVQm3MrakDKiijTO3Y_iL6pEDJ8mgGw5Ql6jIh-aVUQoUZdu9LfLYmAiNsLqi43OBU2ZJdNYv4zIWorgKZiAz8JGn2kAugZwnStCVYKw==',
    # 防盗链
    'referer' : 'https://weibo.com/2810373291/O7pPo1Ptb',
    # 浏览器基本信息
    'user-agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.95 Safari/537.36'
}
url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291'
# 1.发送请求
response = requests.get(url=url,headers=headers)
# 2.打印网页数据
json_data = response.json()
data_list = json_data['data']

for data in data_list:
    text_raw = data['text_raw']
    id = data['id'] # 发表评论人的id
    created_at = data['created_at'] # 评论发表在什么时候
    like_counts = data['like_counts'] # 该评论的点赞数量
    total_number = data['total_number'] # 该条评论被别人回复的数量
    screen_name = data['user']['screen_name'] # 发表评论人的昵称
    print(id,screen_name,text_raw,like_counts,total_number,created_at)</code></pre> 
<p></p> 
<blockquote> 
 <p>运行一下</p> 
 <p><img alt="" src="https://images2.imgbox.com/38/99/rl3tucFq_o.png"></p> 
</blockquote> 
<p>可以看现在的输出数据已经很规整了</p> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81%E5%AF%BC%E5%87%BA%E6%88%90%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F(%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%9B%B4%E6%8E%A5%E7%9C%8B%E8%BF%99)">五、导出成表格形式</h2> 
<blockquote> 
 <p>我们将输出的数据导出成表格形式，更加方便我们观察与使用</p> 
</blockquote> 
<pre><code>import requests
import csv

f = open('评论.csv',mode='a',encoding='utf-8-sig',newline='')
csv_write = csv.writer((f))
csv_write.writerow(['id','screen_name','text_raw','like_counts','total_number','created_at'])
# 请求头
headers = {
    # 用户身份信息
    'cookie' : 'XSRF-TOKEN=KVMLznKAi1u5t7UavCDVyD0I; _s_tentry=weibo.com; Apache=3869338173200.8403.1711845564842; SINAGLOBAL=3869338173200.8403.1711845564842; ULV=1711845565244:1:1:1:3869338173200.8403.1711845564842:; PC_TOKEN=dcbe0bd978; SUB=_2A25LDMCxDeRhGeFJ71sS8CvLzTmIHXVoYFx5rDV8PUNbmtB-LVD9kW9Nf6JZvhCZ3PGanwgbD1yc6zGrHhnf6wrq; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9W586R5s7_p1VykF21DkOu3L5JpX5o275NHD95QNS0B4e05fS0qfWs4DqcjAMJv09CH8SE-4BC-RSFH8SCHFxb-ReEH8SFHFBC-RBbH8Sb-4SEHWSCH81FHWxCHFeFH8Sb-4BEHWB7tt; ALF=1712450401; SSOLoginState=1711845601; WBPSESS=7dB0l9FjbY-Rzc9u1r7G0AeIukWsnj2u9VSmMssaP8z8nNdVQm3MrakDKiijTO3Y_iL6pEDJ8mgGw5Ql6jIh-aVUQoUZdu9LfLYmAiNsLqi43OBU2ZJdNYv4zIWorgKZiAz8JGn2kAugZwnStCVYKw==',
    # 防盗链
    'referer' : 'https://weibo.com/2810373291/O7pPo1Ptb',
    # 浏览器基本信息
    'user-agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.95 Safari/537.36'
}
url = 'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5017675820436181&amp;is_show_bulletin=2&amp;is_mix=0&amp;count=10&amp;uid=2810373291'
# 1.发送请求
response = requests.get(url=url,headers=headers)
# 2.获取数据

# 3.提取数据
json_data = response.json()
data_list = json_data['data']

for data in data_list:
    text_raw = data['text_raw']
    id = data['id']
    created_at = data['created_at']
    like_counts = data['like_counts']
    total_number = data['total_number']
    screen_name = data['user']['screen_name']
    print(id,screen_name,text_raw,like_counts,total_number,created_at)
    # 4.保存数据
     csv_write.writerow([id,screen_name,text_raw,like_counts,total_number,created_at])</code></pre> 
<blockquote> 
 <p>运行一下</p> 
 <p><img alt="" src="https://images2.imgbox.com/af/03/7Wq8w8PH_o.png"></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>我们可以看到，有一个格式是 .csv 的文件生成了，我们可以在访问中打开它</p> 
 <p><img alt="" src="https://images2.imgbox.com/fc/e4/g7lsMNho_o.png"></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p>打开表格</p> 
 <p><img alt="" src="https://images2.imgbox.com/44/be/JXKPTmQh_o.png"></p> 
 <p><img alt="" src="https://images2.imgbox.com/7d/7a/9xQl5mkL_o.png"></p> 
</blockquote> 
<p>太棒啦能看到这里！！！！！！！（加油加油加油）</p> 
<p></p> 
<h2 id="%E5%85%AD%E3%80%81%E4%BA%86%E8%A7%A3%E5%88%86%E9%A1%B5">六、了解分页</h2> 
<h3 id="6.1%20%E6%9F%A5%E7%9C%8B%E5%88%86%E9%A1%B5">6.1 查看分页</h3> 
<p>这里为了方便演示多页的评论，我寻找了一个评论在两千条左右的帖子</p> 
<blockquote> 
 <p>找到页面 -&gt; 单机右键 -&gt; 检查元素(审查元素) -&gt; 点击网络(network) -&gt; 点击小的放大镜（搜索）-&gt; 复制一条评论 -&gt; 进行搜索 -&gt; 点击标头(headers) </p> 
 <p>PS：之前的文章里有详细的一步一步的操作演示，如果有遇到问题的可以去看一下</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/0d/d2/zaTCQbfP_o.png"></p> 
<p> 我们能看到这个界面，这是你复制的那条评论所对应的分页的一个URL</p> 
<p></p> 
<blockquote> 
 <p>在这里我们可以看到这个“buildComments”，这是对应的整篇帖子的评论的包，我们复制这一小部分</p> 
</blockquote> 
<p><img alt="" height="944" src="https://images2.imgbox.com/1e/2c/m4xEOCHN_o.png" width="1200"></p> 
<p>注意不要复制多了真正需要复制的其实只有buildComments，也可以自己打，但是为了避免手打出现错误我是比较推荐复制</p> 
<p></p> 
<blockquote> 
 <p>将这一小部分粘贴至过滤(filter) -&gt; 回车</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/c7/7a/8wiPD2Ps_o.png"></p> 
<p>此时我们会看到，立即出现一个分页的搜索结果</p> 
<p></p> 
<blockquote> 
 <p>然后不关闭检查元素的界面 -&gt; 我们将鼠标移到帖子的部分，向下划动贴子中的评论，此时我们会发现，随着我们不断向下划动，会逐渐出现更多的搜索结果</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/c9/37/17gcUqaZ_o.png"></p> 
<p></p> 
<h3 id="6.2%20%E5%AF%BB%E6%89%BE%E5%88%86%E9%A1%B5%E7%9A%84%E8%A7%84%E5%BE%8B">6.2 寻找分页的规律</h3> 
<blockquote> 
 <p>首先我们观察一下第一个分页的URL</p> 
 <p>点击第一个搜索的结果（就是名称下面的那四行，我们先点击第一行）</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/d6/c5/gRW1Udoj_o.png"></p> 
<p></p> 
<p>在这里我们可以看到第一个页面的URL是这样的</p> 
<p></p> 
<blockquote> 
 <p>然后我们查看第二个页面的URL</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/1d/f5/jGgCrQQA_o.png"></p> 
<p></p> 
<blockquote> 
 <p>我们观察一下这两个URL的区别</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/03/8c/hPIccxSj_o.png"></p> 
<p>我们发现绿色框住的是第一个分页的，它是“count=10”没有max_id，二粉色框住的URL是有max_id的，不知道大家之前有没有印象，在我们预览(preview)界面中，我们是见到过max_id的，所以我们观察一下第一个分页的max_id</p> 
<p></p> 
<blockquote> 
 <p>打开第一个分页的预览（preview）界面</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/93/fb/we8iqLuC_o.png"></p> 
<p>我们发现第一个分页的max_id和第二个分页URL中的max_id是完全一样的，我们可以多观察几组（例如第二个分页的max_id和第三个分页URL中的max_id）</p> 
<p>然后我们就发现了不同分页之间的规律</p> 
<p></p> 
<h2 id="%E4%B8%83%E3%80%81%E5%A4%9A%E9%A1%B5%E5%AE%9E%E7%8E%B0%C2%A0">七、多页实现 </h2> 
<blockquote> 
 <p>在前面的代码中我们已经实现了单页的评论爬取，在这里我们是需要对URL进行修改就可</p> 
 <p>（下面演示的代码是不完全，只写出来新加的代码）</p> 
</blockquote> 
<pre><code>headers = {
    # 之前的headers的值
}
# 定义一个get_next宏函数，在函数立里面定一个next变量，它的初值是 count=10
def get_next(next='count=10’):
# 然后我们把URL这里的 count=10 替换成 next 变量的值
    url = f'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5003170104741808&amp;is_show_bulletin=2&amp;is_mix=0&amp;{next}&amp;uid=7190522839&amp;fetch_level=0&amp;locale=zh-CN’

    response = requests.get(url=url,headers=headers)
    json_data = response.json()

    data_list = json_data['data']
    max_id = json_data['max_id’]  # 这里是单独获取这个分页的max_id
    
    #这里是正常的格式化获取数据代码，为了方便观察新代码的结构我没写上

    # 这里把单纯的 max_id 的数字加上 max_id=
    max_str = 'max_id='+str(max_id)
    # 调用get_next，且更行next的值
    get_next(max_str)
# 调用方法
get_next()</code></pre> 
<h2 id="%E5%85%AB%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">八、完整代码</h2> 
<blockquote> 
 <p>我们把之前的代码加上</p> 
</blockquote> 
<pre><code>import requests
import csv

f = open('评论.csv',mode='a',encoding='utf-8-sig',newline='')
csv_write = csv.writer(f)
csv_write.writerow(['id','screen_name','text_raw','like_counts','total_number','created_at'])
# 请求头
headers = {
        # 用户身份信息
        'cookie': 'SINAGLOBAL=3869338173200.8403.1711845564842; SUB=_2A25LDMCxDeRhGeFJ71sS8CvLzTmIHXVoYFx5rDV8PUNbmtB-LVD9kW9Nf6JZvhCZ3PGanwgbD1yc6zGrHhnf6wrq; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9W586R5s7_p1VykF21DkOu3L5JpX5o275NHD95QNS0B4e05fS0qfWs4DqcjAMJv09CH8SE-4BC-RSFH8SCHFxb-ReEH8SFHFBC-RBbH8Sb-4SEHWSCH81FHWxCHFeFH8Sb-4BEHWB7tt; ALF=1712450401; ULV=1711898034864:2:2:2:7503967975067.276.1711898034641:1711845565244; XSRF-TOKEN=aCKBvTY69V5X8kKbW1jSLjdj; WBPSESS=7dB0l9FjbY-Rzc9u1r7G0AeIukWsnj2u9VSmMssaP8z8nNdVQm3MrakDKiijTO3Y_iL6pEDJ8mgGw5Ql6jIh-fzvfDRMIeuWHMU2fJkIgYlwx20EQfKsyJ2pPS9worRswHbmrN7qQifEsHMJ5esrgA==',
        # 防盗链
        'referer': 'https://weibo.com/7190522839/O1kt4jTyM',
        # 浏览器基本信息
        'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.95 Safari/537.36'
    }


def get_next( next = 'count=10'):
    url = f'https://weibo.com/ajax/statuses/buildComments?is_reload=1&amp;id=5003170104741808&amp;is_show_bulletin=2&amp;is_mix=0&amp;{next}&amp;uid=7190522839&amp;fetch_level=0&amp;locale=zh-CN'

    response = requests.get(url=url,headers=headers)
    json_data = response.json()

    data_list = json_data['data']
    max_id = json_data['max_id']
    for data in data_list:
        text_raw = data['text_raw']
        id = data['id']
        created_at = data['created_at']
        like_counts = data['like_counts']
        total_number = data['total_number']
        screen_name = data['user']['screen_name']
        print(id,screen_name,text_raw,like_counts,total_number,created_at)

        csv_write.writerow([id,screen_name,text_raw,like_counts,total_number,created_at])

    max_str = 'max_id='+str(max_id)
    get_next(max_str)
get_next()
</code></pre> 
<p>但是我每次爬的话最多是爬五百条左右，就感觉进度不怎么动了</p> 
<p>到这第一步就彻底成功喽！！！！！！</p> 
<p>打开生成的表格之前的文章里面有！</p> 
<h2 id="%E4%B9%9D%E3%80%81%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0">九、大多数报错原因</h2> 
<blockquote> 
 <p>我的电脑是苹果的，它的user-agent可能和大家的电脑不一样，如果报json或者data的错误，可以尝试：</p> 
 <p>referer是网址，你打开网址检查元素，看一下url和cookie还有user-agent是不是一样的，然后修改一下，再看看能不能运行</p> 
</blockquote> 
<p>有任何问题或者写的有错误，都可以在评论区和我说，虽然我不一定会，因为我也是刚入门！！</p> 
<hr> 
<p>就是之前这篇文章是分上中下写的，后面怕大家感觉麻烦我就把上中下合成一个了</p> 
<p>欢迎大家给我指出错误或者和我交流！！！！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/516438853795a5c04975d3c430a6192c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端canvas实现图片涂鸦(Vue2、Vue3都支持)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/40ab985dbb6468ba045b428b38cfacf7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">新版IDEA没有办法选择Java8版本解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>