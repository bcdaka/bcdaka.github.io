<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android AndServer本地服务器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7967f7370438e9b4fad392e99ba9d8ff/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android AndServer本地服务器">
  <meta property="og:description" content="1.AndServer简介 官方文档：https://github.com/yanzhenjie/AndServer AndServer 是一个 HTTP 和反向代理服务器。Android平台的Web服务器和Web框架。它提供了像SpringMVC一样的注解，如果你熟悉SpringMVC，你可以很快掌握它。
1.web网站部署。 2.动态http api部署。 3.反向代理服务器。 2.AndServer使用 1.项目使用依赖添加 App目录 build.gradle，如果您使用的是 Kotlin，请替换annotationProcessor为kapt.
plugins { id &#39;com.android.application&#39; } apply plugin: &#39;com.yanzhenjie.andserver&#39; ...
...
dependencies { implementation &#39;com.yanzhenjie.andserver:api:2.1.12&#39; annotationProcessor &#39;com.yanzhenjie.andserver:processor:2.1.12&#39; } project build.gradle中 buildscript { dependencies { classpath &#39;com.yanzhenjie.andserver:plugin:2.1.12&#39; } } 2. web网站部署。 web项目文件位置设置，比如vue3，导出dist文件，并放在如下位置，并在AppConfig中配置该位置目录。 @Config public class AppConfig implements WebConfig { @Override public void onConfig(Context context, Delegate delegate) { // 增加一个位于assets的web目录的网站 delegate.addWebsite(new AssetsWebsite(context, &#34;/dist/&#34;)); // 增加一个位于/sdcard/Download/AndServer/目录的网站 // delegate.addWebsite(new StorageWebsite(context, &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-06T21:10:09+08:00">
    <meta property="article:modified_time" content="2024-01-06T21:10:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android AndServer本地服务器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1.AndServer简介</h4> 
<h4>官方文档：<a href="https://github.com/yanzhenjie/AndServer" title="https://github.com/yanzhenjie/AndServer">https://github.com/yanzhenjie/AndServer</a></h4> 
<p><span style="color:#1f2328;"><span style="background-color:#ffffff;">AndServer 是一个 HTTP 和反向代理服务器。</span></span><span style="color:#1f2328;"><span style="background-color:#ffffff;">Android平台的Web服务器和Web框架。它提供了像SpringMVC一样的注解，如果你熟悉SpringMVC，你可以很快掌握它。</span></span></p> 
<h5>   1.web网站部署。</h5> 
<h5>   2.动态http api部署。</h5> 
<h5>   3.反向代理服务器。</h5> 
<h4> 2.AndServer使用</h4> 
<h5>1.项目使用依赖添加</h5> 
<p>App目录 build.gradle，如果您使用的是 Kotlin，请替换<code>annotationProcessor</code>为<code>kapt</code>.</p> 
<blockquote> 
 <pre>plugins {
    id 'com.android.application'
}
apply plugin: 'com.yanzhenjie.andserver'</pre> 
 <p>...</p> 
 <p>...</p> 
 <pre>dependencies {
implementation 'com.yanzhenjie.andserver:api:2.1.12'
annotationProcessor 'com.yanzhenjie.andserver:processor:2.1.12'
}
</pre> 
</blockquote> 
<p>project build.gradle中 </p> 
<blockquote> 
 <pre>buildscript {
    dependencies {
        classpath 'com.yanzhenjie.andserver:plugin:2.1.12'
    }
}</pre> 
</blockquote> 
<h5>2. web网站部署。</h5> 
<h6>web项目文件位置设置，比如vue3，导出dist文件，并放在如下位置，并在AppConfig中配置该位置目录。</h6> 
<p><img alt="" height="204" src="https://images2.imgbox.com/12/bc/R8zqYpau_o.png" width="1078"></p> 
<blockquote> 
 <pre>@Config
public class AppConfig implements WebConfig {

    @Override
    public void onConfig(Context context, Delegate delegate) {
        // 增加一个位于assets的web目录的网站
        delegate.addWebsite(new AssetsWebsite(context, "/dist/"));

        // 增加一个位于/sdcard/Download/AndServer/目录的网站
//        delegate.addWebsite(new StorageWebsite(context, "/sdcard/Download/AndServer/"));
    }
}</pre> 
</blockquote> 
<p></p> 
<h6> 新建Web服务，并开启</h6> 
<p>若不适用inetAddress设置地址，则Android ip改变后，服务器ip也会随之改变，能更好的适配网络的变动。</p> 
<blockquote> 
 <pre>     Server     mServer = AndServer.webServer(context)
//              .inetAddress(add.getAddress())
                .port(33333)
                .timeout(10, TimeUnit.SECONDS)
                .listener(new Server.ServerListener() {
                    @Override
                    public void onStarted() {
                        Log.e(TAG,"onStarted"+mServer.getInetAddress());
                    }

                    @Override
                    public void onStopped() {
                        Log.e(TAG,"onStopped");
                    }

                    @Override
                    public void onException(Exception e) {
                        Log.e(TAG,"onException"+e.getMessage());
                    }
                })
                .build();
</pre> 
 <pre>mServer.startup();//开启服务</pre> 
 <pre>mServer.shutdown();//关闭服务</pre> 
</blockquote> 
<h5> 3.动态http api部署</h5> 
<h6>部署服务器</h6> 
<p>它还具有一些功能，例如<code>inetAddress(InetAddress)</code>、<code>serverSocketFactory(ServerSocketFactory)</code>和<code>sslContext(SSLContext)</code>，具体取决于您想要实现的目标。</p> 
<blockquote> 
 <pre>Server server = AndServer.webServer(context)
    .port(8080)
    .timeout(10, TimeUnit.SECONDS)
    .build();

// startup the server.
server.startup();

...

// shutdown the server.
server.shutdown();</pre> 
</blockquote> 
<h6>生成HTTP API</h6> 
<p>POST http://.../user/login<br> GET http://.../user/uid_001?fields=id,name,age<br> PUT http://.../user/uid_001</p> 
<blockquote> 
 <pre>@RestController
@RequestMapping(path = "/user")
public class UserController {
    @PostMapping("/login")
    public String login(@RequestParam("account") String account,
                        @RequestParam("password") String password) {
        ...
        return "Successful.";
    }
    @GetMapping(path = "/{userId}")
    public User info(@PathVariable("userId") String userId,
                     @QueryParam("fields") String fields) {
        User user = findUserById(userId, fields);
        ...
        return user;
    }
    @PutMapping(path = "/{userId}")
    public void modify(@PathVariable("userId") String userId
                       @RequestParam("age") int age) {
        ...
    }
}</pre> 
</blockquote> 
<h6>文件上传</h6> 
<blockquote> 
 <p>@RestController<br> @RequestMapping(path = "/user")<br> public class ServerController {<!-- --><br>     private String TAG = "ServerController";<br>     @CrossOrigin(methods = {RequestMethod.POST, RequestMethod.GET})<br>     @PostMapping(path = "/upload", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)<br>     String upload(@RequestParam(name = "file") final MultipartFile file, @RequestParam(name = "single_file_name") String fileName) {<!-- --><br>         StandardMultipartFile multipartFile= (StandardMultipartFile) file;<br>         Log.i(TAG,"文件名："+fileName);<br>         //直接对临时文件重命名，不进行复制操作<br>         DiskFileItem fileItem = (DiskFileItem) multipartFile.getFileItem();<br>         String name = fileItem.getName();<br>         if(name.indexOf(".")&gt;0){<!-- --><br>             name= name.replace(".", "_" + System.currentTimeMillis() + ".");<br>         }else{<!-- --><br>             name=name+"_"+System.currentTimeMillis();<br>         }<br>         UploadFileInfo uploadFileInfo=new UploadFileInfo();<br>         try {<!-- --><br>             if(fileItem.isInMemory()){<!-- --><br>                 File dest = new File(Constants.UPLOAD_CACHE_FOLDER, name);<br>                 file.transferTo(dest);<br>                 uploadFileInfo.setFilePath(dest.getAbsolutePath());<br>             }else{<!-- --><br>                 Path sourcePath=Paths.get(fileItem.getStoreLocation().getAbsolutePath());<br>                 Path renamedPath = Paths.get(sourcePath.getParent().toString(),name);<br>                 Files.move(sourcePath,renamedPath);<br>                 uploadFileInfo.setFilePath(renamedPath.toString());<br>             }<br>             uploadFileInfo.setFileName(name);<br>             uploadFileInfo.setUploadProgress(100);<br>             Log.i(TAG,Thread.currentThread().getName());<br>             // We use a sub-thread to process files so that the api '/upload' can respond faster<br>             RxBus.get().post(BusAction.ADD_UPLOAD_FILE,uploadFileInfo);<br>         } catch (IOException e) {<!-- --><br>             e.printStackTrace();<br>         }<br>         return uploadFileInfo.getFilePath();<br>     }<br>     @CrossOrigin(methods = {RequestMethod.POST, RequestMethod.GET})<br>     @PostMapping(path = "/upload/count", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)<br>     boolean uploadCount(@RequestParam(name = "upload_count") final Integer count) {<!-- --><br>         Log.i(TAG,"uploadCount:"+count);<br>         RxBus.get().post(BusAction.ADD_UPLOAD_NUMBER,count);<br>         return true;<br>     }</p> 
 <p>    @GetMapping("/login")<br>     public String login() {<!-- --><br>         Log.e(TAG,"login---");<br>         return "HelloWord";<br>     }<br> }</p> 
</blockquote> 
<h4> 3.<span style="color:#1f2328;"><span style="background-color:#ffffff;">反向代理服务器</span></span></h4> 
<blockquote> 
 <pre>Server server = AndServer.proxyServer()
    .addProxy("www.example1.com", "http://192.167.1.11:8080")
    .addProxy("example2.com", "https://192.167.1.12:9090")
    .addProxy("55.66.11.11", "http://www.google.com")
    .addProxy("192.168.1.11", "https://github.com:6666")
    .port(80)
    .timeout(10, TimeUnit.SECONDS)
    .build();

// startup the server.
server.startup();

// shutdown the server.
server.shutdown();</pre> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/735bd4bcfd252f704e0fe98a8cb2bad0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mysql为什么只能支持2000w左右的数据量？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9af2c2e5aceb2c954320058f1a5b6ee2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac环境下安装python3</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>