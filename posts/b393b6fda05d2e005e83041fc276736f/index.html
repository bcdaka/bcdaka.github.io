<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1V1音视频实时互动直播系统 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b393b6fda05d2e005e83041fc276736f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="1V1音视频实时互动直播系统">
  <meta property="og:description" content="李超老师的项目
先肯定分为两个两个端，一个是服务器端一个是客户端。客户端用于UI界面的显示，服务器端用于处理客户端发来的消息。
我们先搭建stun和turn服务器
首先介绍一下什么是stun协议，
它是用来干什么的？
stun协议存在的目的就是进行NAT穿越。stun是典型的客户端、服务器模式。客户端发送请求，服务器进行响应。
那么是什么NAT穿越呢？
首先我们先了解一下为什么要进行NAT穿越。下面举个例子，在两个浏览器之间进行实时的音视频互动，对于底层来说，这就是两个端点之间进行高效的网络传输。
为了解决音视频网络传输的问题，webrtc引入了一些网络传输协议。
1.NAT：那么此时我们介绍NAT，简单理解为将内网的地址转换为公网的地址，内网地址无法通讯，通过NAT转换为公网之后，才有通信的可能。
2.说到这里那么顺便介绍一下stun，这个stun充当的是中介的作用，在NAT的基础上，交换两个公网的信息，使得；两个公网之间可以建立连接。
3.turn，stun是有一定几率是不成功的，因此turn会在云端架设一个服务器，在p2p连接不成功的情况下，保证音视频的互通，它就相当于一个中转站。
4.ICE， 罗列所有通信可能性，选择最优解。
NAT又分为四种类型：
完全锥型
地址限制锥型
端口限制锥型
对称型
根据图中所示很好理解，caller与信令服务器连接，同时callee也跟信令服务器连接，第二个callee也跟信令服务器连接；caller向信令服务器发出join请求，信令服务器响应返回joined信息，第一个callee同理，但是第二个callee发送完join之后服务器发现成员已满，因此返回一个full信息，该callee不能join。然后caller和callee进行媒体协商，协商成功之后进行媒体流的数据传输。之后callee主动发出leave请求，服务器响应跟caller发出bye信息并返回callee leaved信息。
我们来看一下服务器端的代码。主要就是处理客户端发来的信令消息。也就是以上的流程转换为代码。
io.sockets.on(&#39;connection&#39;, (socket)=&gt; { socket.on(&#39;message&#39;, (room, data)=&gt;{ socket.to(room).emit(&#39;message&#39;,room, data); }); socket.on(&#39;join&#39;, (room)=&gt;{ socket.join(room); var myRoom = io.sockets.adapter.rooms[room]; var users = (myRoom)? Object.keys(myRoom.sockets).length : 0; logger.debug(&#39;the user number of room is: &#39; &#43; users); if(users &lt; USERCOUNT){ socket.emit(&#39;joined&#39;, room, socket.id); //发给自己 if(users &gt; 1){ socket.to(room).emit(&#39;otherjoin&#39;, room, socket.id);//发给除自己之外的房间内的所有人 } }else{ socket.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T10:59:13+08:00">
    <meta property="article:modified_time" content="2024-06-04T10:59:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1V1音视频实时互动直播系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>李超老师的项目</p> 
<p>先肯定分为两个两个端，一个是服务器端一个是客户端。客户端用于UI界面的显示，服务器端用于处理客户端发来的消息。</p> 
<p>我们先搭建stun和turn服务器</p> 
<p>首先介绍一下什么是stun协议，</p> 
<p>它是用来干什么的？</p> 
<p>stun协议存在的目的就是进行NAT穿越。stun是典型的客户端、服务器模式。客户端发送请求，服务器进行响应。</p> 
<p>那么是什么NAT穿越呢？</p> 
<p>首先我们先了解一下为什么要进行NAT穿越。下面举个例子，在两个浏览器之间进行实时的音视频互动，对于底层来说，这就是两个端点之间进行高效的网络传输。</p> 
<p>为了解决音视频网络传输的问题，webrtc引入了一些网络传输协议。</p> 
<p>1.NAT：那么此时我们介绍NAT，简单理解为将内网的地址转换为公网的地址，内网地址无法通讯，通过NAT转换为公网之后，才有通信的可能。</p> 
<p>2.说到这里那么顺便介绍一下stun，这个stun充当的是中介的作用，在NAT的基础上，交换两个公网的信息，使得；两个公网之间可以建立连接。</p> 
<p>3.turn，stun是有一定几率是不成功的，因此turn会在云端架设一个服务器，在p2p连接不成功的情况下，保证音视频的互通，它就相当于一个中转站。</p> 
<p>4.ICE， 罗列所有通信可能性，选择最优解。</p> 
<p>NAT又分为四种类型：</p> 
<p>完全锥型</p> 
<p>地址限制锥型</p> 
<p>端口限制锥型</p> 
<p>对称型</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/8f/71/ssEFLlpm_o.png" width="756"></p> 
<p></p> 
<p><img alt="" height="804" src="https://images2.imgbox.com/51/86/iUaJ9VwZ_o.png" width="951"></p> 
<p>根据图中所示很好理解，caller与信令服务器连接，同时callee也跟信令服务器连接，第二个callee也跟信令服务器连接；caller向信令服务器发出join请求，信令服务器响应返回joined信息，第一个callee同理，但是第二个callee发送完join之后服务器发现成员已满，因此返回一个full信息，该callee不能join。然后caller和callee进行媒体协商，协商成功之后进行媒体流的数据传输。之后callee主动发出leave请求，服务器响应跟caller发出bye信息并返回callee leaved信息。</p> 
<p></p> 
<p>我们来看一下服务器端的代码。主要就是处理客户端发来的信令消息。也就是以上的流程转换为代码。</p> 
<pre><code class="language-javascript">io.sockets.on('connection', (socket)=&gt; {

	socket.on('message', (room, data)=&gt;{
		socket.to(room).emit('message',room, data);
	});

	socket.on('join', (room)=&gt;{
		socket.join(room);
		var myRoom = io.sockets.adapter.rooms[room]; 
		var users = (myRoom)? Object.keys(myRoom.sockets).length : 0;
		logger.debug('the user number of room is: ' + users);

		if(users &lt; USERCOUNT){
			socket.emit('joined', room, socket.id); //发给自己
			if(users &gt; 1){
				socket.to(room).emit('otherjoin', room, socket.id);//发给除自己之外的房间内的所有人
			}
		
		}else{
			socket.leave(room);	
			socket.emit('full', room, socket.id);
		}
		//socket.emit('joined', room, socket.id); //发给自己
		//socket.broadcast.emit('joined', room, socket.id); //发给除自己之外的这个节点上的所有人
		//io.in(room).emit('joined', room, socket.id); //发给房间内的所有人
	});

	socket.on('leave', (room)=&gt;{
		var myRoom = io.sockets.adapter.rooms[room]; 
		var users = (myRoom)? Object.keys(myRoom.sockets).length : 0;
		logger.debug('the user number of room is: ' + (users-1));
		//socket.emit('leaved', room, socket.id);
		//socket.broadcast.emit('leaved', room, socket.id);
		socket.to(room).emit('bye', room, socket.id);
		socket.emit('leaved', room, socket.id);
		//io.in(room).emit('leaved', room, socket.id);
	});

});</code></pre> 
<p><img alt="" height="330" src="https://images2.imgbox.com/d7/9c/JesdMt4j_o.png" width="621"></p> 
<p>iceRestart是一个很好的方案，能够帮助我们重新选择数据传输的线路</p> 
<p></p> 
<p>下面了解一下状态机是什么这点蛮重要</p> 
<p><img alt="" height="766" src="https://images2.imgbox.com/62/76/BU7iac3x_o.png" width="642"></p> 
<p></p> 
<p>下面介绍一下客户端代码编写的流程图</p> 
<p><img alt="" height="816" src="https://images2.imgbox.com/8b/93/rCtgpTfH_o.png" width="958"></p> 
<p>首先写函数start</p> 
<p>start函数用于采集音视频数据</p> 
<p>采集成功则与信令服务器连接，并注册信令函数<img alt="" height="582" src="https://images2.imgbox.com/7c/1b/y1Deixq7_o.png" width="688"></p> 
<p>注册以上这些消息的处理函数</p> 
<p>如果是joined则设置状态为joined，创建PC并绑定媒体流。</p> 
<p>如果是otherjoin，则判断自身的状态是否为joined_unbind，如果是则需要重新创建PC并绑定媒体流并将状态设置为joined_conn，如果一开始状态为joined则直接将状态转换为joined_conn，接着开始媒体协商。</p> 
<p>如果是full则状态设置为full并关闭PC，并关闭本地媒体流</p> 
<p>客户端的实现需要注意的几点是</p> 
<p>1.网络连接要在音视频数据获取到之后，否则可能导致绑定音视频流失败</p> 
<p>2.当一端退出房间之后，另一端的PeerConnection要关闭重建，否则与新用户互通时媒体协商会失败。</p> 
<p>3.所有的处理流程为异步处理</p> 
<p>这里要了解一下什么是异步处理：</p> 
<p>异步事件处理：要等待收到一个消息或事件后，才能做下一步的操作</p> 
<p>同步处理：做完一步，直接做下一步</p> 
<p>接下来我们介绍一下客户端的代码</p> 
<p>首先先了解一个api</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/c7/97/mgVttQLj_o.png" width="1052"></p> 
<p>其中较为关键的是iceServers</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/91/c2/MQluJE2j_o.png" width="795"></p> 
<h2><img alt="" height="674" src="https://images2.imgbox.com/a3/3b/r8SDWgdX_o.png" width="1007"></h2> 
<p>第二个api</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/3b/1b/ElaJfFn1_o.png" width="525"></p> 
<p></p> 
<p>根据流程写以下代码：</p> 
<p>首先start函数获取音视频数据</p> 
<pre><code class="language-javascript">function start(){

	if(!navigator.mediaDevices ||
		!navigator.mediaDevices.getUserMedia){
		console.error('the getUserMedia is not supported!');
		return;
	}else {

		var constraints;

		if( shareDeskBox.checked &amp;&amp; shareDesk()){

			constraints = {
				video: false,
				audio:  {
					echoCancellation: true,
					noiseSuppression: true,
					autoGainControl: true
				}
			}

		}else{
			constraints = {
				video: true,
				audio:  {
					echoCancellation: true,
					noiseSuppression: true,
					autoGainControl: true
				}
			}
		}

		navigator.mediaDevices.getUserMedia(constraints)
					.then(getMediaStream)
					.catch(handleError);
	}

}</code></pre> 
<p></p> 
<p>与信令服务器连接，注册处理函数</p> 
<pre><code class="language-javascript">function conn(){

	socket = io.connect();

	socket.on('joined', (roomid, id) =&gt; {
		console.log('receive joined message!', roomid, id);
		state = 'joined'

		//如果是多人的话，第一个人不该在这里创建peerConnection
		//都等到收到一个otherjoin时再创建
		//所以，在这个消息里应该带当前房间的用户数
		//
		//create conn and bind media track
		createPeerConnection();
		bindTracks();

		btnConn.disabled = true;
		btnLeave.disabled = false;
		console.log('receive joined message, state=', state);
	});

	socket.on('otherjoin', (roomid) =&gt; {
		console.log('receive joined message:', roomid, state);

		//如果是多人的话，每上来一个人都要创建一个新的 peerConnection
		//
		if(state === 'joined_unbind'){
			createPeerConnection();
			bindTracks();
		}

		state = 'joined_conn';
		call();

		console.log('receive other_join message, state=', state);
	});

	socket.on('full', (roomid, id) =&gt; {
		console.log('receive full message', roomid, id);
		hangup();
		closeLocalMedia();
		state = 'leaved';
		console.log('receive full message, state=', state);
		alert('the room is full!');
	});

	socket.on('leaved', (roomid, id) =&gt; {
		console.log('receive leaved message', roomid, id);
		state='leaved'
		socket.disconnect();
		console.log('receive leaved message, state=', state);

		btnConn.disabled = false;
		btnLeave.disabled = true;
	});

	socket.on('bye', (room, id) =&gt; {
		console.log('receive bye message', roomid, id);
		//state = 'created';
		//当是多人通话时，应该带上当前房间的用户数
		//如果当前房间用户不小于 2, 则不用修改状态
		//并且，关闭的应该是对应用户的peerconnection
		//在客户端应该维护一张peerconnection表，它是
		//一个key:value的格式，key=userid, value=peerconnection
		state = 'joined_unbind';
		hangup();
		offer.value = '';
		answer.value = '';
		console.log('receive bye message, state=', state);
	});

	socket.on('disconnect', (socket) =&gt; {
		console.log('receive disconnect message!', roomid);
		if(!(state === 'leaved')){
			hangup();
			closeLocalMedia();

		}
		state = 'leaved';
	
	});

	socket.on('message', (roomid, data) =&gt; {
		console.log('receive message!', roomid, data);

		if(data === null || data === undefined){
			console.error('the message is invalid!');
			return;	
		}

		if(data.hasOwnProperty('type') &amp;&amp; data.type === 'offer') {
			
			offer.value = data.sdp;

			pc.setRemoteDescription(new RTCSessionDescription(data));

			//create answer
			pc.createAnswer()
				.then(getAnswer)
				.catch(handleAnswerError);

		}else if(data.hasOwnProperty('type') &amp;&amp; data.type == 'answer'){
			answer.value = data.sdp;
			pc.setRemoteDescription(new RTCSessionDescription(data));
		
		}else if (data.hasOwnProperty('type') &amp;&amp; data.type === 'candidate'){
			var candidate = new RTCIceCandidate({
				sdpMLineIndex: data.label,
				candidate: data.candidate
			});
			pc.addIceCandidate(candidate);	
		
		}else{
			console.log('the message is invalid!', data);
		
		}
	
	});


	roomid = getQueryVariable('room');
	socket.emit('join', roomid);

	return true;
}
</code></pre> 
<p>媒体协商call函数</p> 
<pre><code class="language-javascript">function call(){
	
	if(state === 'joined_conn'){

		var offerOptions = {
			offerToRecieveAudio: 1,
			offerToRecieveVideo: 1
		}

		pc.createOffer(offerOptions)
			.then(getOffer)
			.catch(handleOfferError);
	}
}
function getOffer(desc){
	pc.setLocalDescription(desc);
	offer.value = desc.sdp;
	offerdesc = desc;

	//send offer sdp
	sendMessage(roomid, offerdesc);	

}
function getAnswer(desc){
	pc.setLocalDescription(desc);
	answer.value = desc.sdp;

	//send answer sdp
	sendMessage(roomid, desc);
}</code></pre> 
<p>每个端都维护一个自己的peerconnection</p> 
<pre><code class="language-javascript">var pcConfig = {
  'iceServers': [{
    'urls': 'turn:stun.al.learningrtc.cn:3478',
    'credential': "mypasswd",
    'username': "garrylea"
  }]
};
function createPeerConnection(){

	//如果是多人的话，在这里要创建一个新的连接.
	//新创建好的要放到一个map表中。
	//key=userid, value=peerconnection
	console.log('create RTCPeerConnection!');
	if(!pc){
		pc = new RTCPeerConnection(pcConfig);

		pc.onicecandidate = (e)=&gt;{

			if(e.candidate) {
				sendMessage(roomid, {
					type: 'candidate',
					label:event.candidate.sdpMLineIndex, 
					id:event.candidate.sdpMid, 
					candidate: event.candidate.candidate
				});
			}else{
				console.log('this is the end candidate');
			}
		}

		pc.ontrack = getRemoteStream;
	}else {
		console.warning('the pc have be created!');
	}

	return;	
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/163a391d23f20142be6e294e3aee397e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SD NAND（贴片式TF卡）在储能领域的应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d2a9d28a02929e929a95d40f0f14055/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">8 款 Stable Diffusion 最新写实风格 SDXL 大模型推荐！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>