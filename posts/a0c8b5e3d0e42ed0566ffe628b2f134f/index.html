<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Web 开发安全与最佳实践：MVC、会话管理与常见攻击防御 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a0c8b5e3d0e42ed0566ffe628b2f134f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Web 开发安全与最佳实践：MVC、会话管理与常见攻击防御">
  <meta property="og:description" content="MVC模式 MVC（Model-View-Controller）是一种广泛使用的软件设计模式，用于简化应用程序的开发过程。它通过分离数据访问、用户界面和业务逻辑，使得应用程序的结构更加清晰。
MVC的组成部分 1. Model（模型） 定义：代表应用程序的数据和业务逻辑。职责： 与数据库进行交互处理数据的逻辑操作在JavaWeb中的实现： 使用POJO（Plain Old Java Object）类，通常与数据库表一一对应DAO（Data Access Object）负责数据库交互Service层实现业务逻辑可使用ORM（Object-Relational Mapping）框架如Hibernate来简化数据库操作 2. View（视图） 定义：负责将模型的数据呈现给用户。职责：展示数据，提供用户界面。在JavaWeb中的实现： 常用JSP（JavaServer Pages）也可使用现代模板引擎如Thymeleaf 3. Controller（控制器） 定义：处理用户请求，协调模型和视图。职责： 接收用户输入调用模型的业务逻辑更新视图在JavaWeb中的实现： 传统方式使用Servlet在Spring框架中使用@Controller注解的类 JSP内置对象 JSP提供了几个内置对象，极大地简化了Web开发过程。以下是主要内置对象的概述：
request (HttpServletRequest) 传递客户端发送给服务端的请求包含参数、URL、头信息等response (HttpServletResponse) 承载服务端向客户端发送的响应可设置响应头、状态码等pageContext (PageContext) 提供对其他内置对象的访问包含页面范围的方法，如属性的获取、设置和删除session (HttpSession) 存储会话期间的状态信息application (ServletContext) 在整个应用程序范围内共享数据out (JspWriter) 向客户端发送HTML内容config (ServletConfig) 包含初始化Servlet的参数page (Object) 表示当前Servlet对象exception (Throwable) 仅在错误页面（isErrorPage=true）中使用包含异常信息 这些内置对象极大地便利了HTTP请求的处理过程。例如：
使用request获取用户的请求内容使用session获取会话的状态信息使用out发送HTML给客户端 JSP 和 Servlet 比较 JSP（JavaServer Pages）和Servlet都是JavaWeb开发中常用的技术，主要用于生成动态网页内容。虽然它们的目标相似，但在使用方式和适用场景上有明显区别。
1. 语法和易用性 JSP 基于HTML，允许在HTML中嵌入Java代码支持表达式语言（EL）和JSTL，简化了数据访问和常见操作更适合于生成和展示视图（View） Servlet 纯Java代码在生成HTML时相对繁琐更适合处理复杂的业务逻辑 2. 编译方式 JSP 首次请求时编译代码变更后自动重新编译，无需重启服务器 Servlet 服务器启动或首次请求时编译编译一次后不再重新编译，代码更改需重启服务器 3. 主要用途 JSP 生成和展示视图（HTML页面）适合处理简单的展示逻辑 Servlet 处理业务逻辑处理表单提交、数据库查询等后端操作 4.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-16T08:00:00+08:00">
    <meta property="article:modified_time" content="2024-08-16T08:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Web 开发安全与最佳实践：MVC、会话管理与常见攻击防御</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>MVC模式</h2> 
<p>MVC（Model-View-Controller）是一种广泛使用的软件设计模式，用于简化应用程序的开发过程。它通过分离数据访问、用户界面和业务逻辑，使得应用程序的结构更加清晰。</p> 
<h3>MVC的组成部分</h3> 
<h4>1. Model（模型）</h4> 
<ul><li><strong>定义</strong>：代表应用程序的数据和业务逻辑。</li><li><strong>职责</strong>： 
  <ul><li>与数据库进行交互</li><li>处理数据的逻辑操作</li></ul></li><li><strong>在JavaWeb中的实现</strong>： 
  <ul><li>使用POJO（Plain Old Java Object）类，通常与数据库表一一对应</li><li>DAO（Data Access Object）负责数据库交互</li><li>Service层实现业务逻辑</li><li>可使用ORM（Object-Relational Mapping）框架如Hibernate来简化数据库操作</li></ul></li></ul> 
<h4>2. View（视图）</h4> 
<ul><li><strong>定义</strong>：负责将模型的数据呈现给用户。</li><li><strong>职责</strong>：展示数据，提供用户界面。</li><li><strong>在JavaWeb中的实现</strong>： 
  <ul><li>常用JSP（JavaServer Pages）</li><li>也可使用现代模板引擎如Thymeleaf</li></ul></li></ul> 
<h4>3. Controller（控制器）</h4> 
<ul><li><strong>定义</strong>：处理用户请求，协调模型和视图。</li><li><strong>职责</strong>： 
  <ul><li>接收用户输入</li><li>调用模型的业务逻辑</li><li>更新视图</li></ul></li><li><strong>在JavaWeb中的实现</strong>： 
  <ul><li>传统方式使用Servlet</li><li>在Spring框架中使用@Controller注解的类</li></ul></li></ul> 
<h2>JSP内置对象</h2> 
<p>JSP提供了几个内置对象，极大地简化了Web开发过程。以下是主要内置对象的概述：</p> 
<ol><li><strong>request</strong> (HttpServletRequest) 
  <ul><li>传递客户端发送给服务端的请求</li><li>包含参数、URL、头信息等</li></ul></li><li><strong>response</strong> (HttpServletResponse) 
  <ul><li>承载服务端向客户端发送的响应</li><li>可设置响应头、状态码等</li></ul></li><li><strong>pageContext</strong> (PageContext) 
  <ul><li>提供对其他内置对象的访问</li><li>包含页面范围的方法，如属性的获取、设置和删除</li></ul></li><li><strong>session</strong> (HttpSession) 
  <ul><li>存储会话期间的状态信息</li></ul></li><li><strong>application</strong> (ServletContext) 
  <ul><li>在整个应用程序范围内共享数据</li></ul></li><li><strong>out</strong> (JspWriter) 
  <ul><li>向客户端发送HTML内容</li></ul></li><li><strong>config</strong> (ServletConfig) 
  <ul><li>包含初始化Servlet的参数</li></ul></li><li><strong>page</strong> (Object) 
  <ul><li>表示当前Servlet对象</li></ul></li><li><strong>exception</strong> (Throwable) 
  <ul><li>仅在错误页面（isErrorPage=true）中使用</li><li>包含异常信息</li></ul></li></ol> 
<p>这些内置对象极大地便利了HTTP请求的处理过程。例如：</p> 
<ul><li>使用<code>request</code>获取用户的请求内容</li><li>使用<code>session</code>获取会话的状态信息</li><li>使用<code>out</code>发送HTML给客户端</li></ul> 
<h2>JSP 和 Servlet 比较</h2> 
<p>JSP（JavaServer Pages）和Servlet都是JavaWeb开发中常用的技术，主要用于生成动态网页内容。虽然它们的目标相似，但在使用方式和适用场景上有明显区别。</p> 
<h3>1. 语法和易用性</h3> 
<h4>JSP</h4> 
<ul><li>基于HTML，允许在HTML中嵌入Java代码</li><li>支持表达式语言（EL）和JSTL，简化了数据访问和常见操作</li><li>更适合于生成和展示视图（View）</li></ul> 
<h4>Servlet</h4> 
<ul><li>纯Java代码</li><li>在生成HTML时相对繁琐</li><li>更适合处理复杂的业务逻辑</li></ul> 
<h3>2. 编译方式</h3> 
<h4>JSP</h4> 
<ul><li>首次请求时编译</li><li>代码变更后自动重新编译，无需重启服务器</li></ul> 
<h4>Servlet</h4> 
<ul><li>服务器启动或首次请求时编译</li><li>编译一次后不再重新编译，代码更改需重启服务器</li></ul> 
<h3>3. 主要用途</h3> 
<h4>JSP</h4> 
<ul><li>生成和展示视图（HTML页面）</li><li>适合处理简单的展示逻辑</li></ul> 
<h4>Servlet</h4> 
<ul><li>处理业务逻辑</li><li>处理表单提交、数据库查询等后端操作</li></ul> 
<h3>4. 在MVC模式中的应用</h3> 
<p>在实际开发中，JSP和Servlet通常结合使用，实现MVC（Model-View-Controller）设计模式：</p> 
<ul><li><strong>Controller</strong>：Servlet 处理用户请求，执行业务逻辑</li><li><strong>Model</strong>：POJO（Plain Old Java Object）实现，存储应用层数据</li><li><strong>View</strong>：JSP 展示数据给用户</li></ul> 
<p>这种组合充分发挥了两者的优势，提高了代码的可维护性和可扩展性。</p> 
<h2>Session 和 Cookie 比较</h2> 
<p>Session和Cookie都是用于存储用户信息的重要Web技术，但它们在多个方面有显著差异。</p> 
<h3>1. 存储位置</h3> 
<ul><li><strong>Session</strong>: 存储在服务器端，每个用户有唯一的session。</li><li><strong>Cookie</strong>: 存储在客户端（浏览器），通过HTTP响应头部设置。</li></ul> 
<h3>2. 存储容量</h3> 
<ul><li><strong>Cookie</strong>: 容量小，通常不超过4KB。</li><li><strong>Session</strong>: 理论上没有限制，但过多可能占用大量服务器内存。</li></ul> 
<h3>3. 数据类型</h3> 
<ul><li><strong>Cookie</strong>: 只能存储字符串，特殊字符需编码。</li><li><strong>Session</strong>: 可存储任何数据类型（如字符串、数字、对象等）。</li></ul> 
<h3>4. 生命周期</h3> 
<ul><li><strong>Cookie</strong>: 
  <ul><li>可设置明确的过期时间。</li><li>无过期时间设置时，仅在当前浏览器会话有效。</li></ul></li><li><strong>Session</strong>: 
  <ul><li>由服务器控制，通常设置一个失效时间。</li><li>用户长时间无活动时，服务器可能自动删除。</li></ul></li></ul> 
<h3>5. 安全性</h3> 
<ul><li><strong>Cookie</strong>: 存储在客户端，安全性较低，可能被窃取或修改。</li><li><strong>Session</strong>: 存储在服务器，用户无法直接访问，安全性较高。</li></ul> 
<h3>6. 应用场景</h3> 
<ul><li><strong>Cookie</strong>: 适合存储少量、安全要求不高的数据。</li><li><strong>Session</strong>: 适合存储大量、安全性要求高的数据。</li></ul> 
<h3>7. 性能影响</h3> 
<ul><li><strong>Cookie</strong>: 每次HTTP请求都会携带，可能影响网络传输效率。</li><li><strong>Session</strong>: 不影响网络传输，但可能增加服务器负载。</li></ul> 
<h3>选择建议</h3> 
<ul><li>需要存储大量数据且安全性要求高：使用Session。</li><li>只需存储小部分数据且安全性要求不高：使用Cookie。</li><li>考虑结合使用：Cookie存储Session ID，Session存储具体数据。</li></ul> 
<h2>单点登录: Cookie被禁用时的解决方案</h2> 
<p>单点登录（Single Sign-On, SSO）是一种允许用户通过一次身份验证即可访问多个相关系统或服务的方法。传统上，SSO依赖Cookie来追踪用户的会话状态。然而，当Cookie被禁用时，我们需要采用替代方案。以下是几种可行的解决方法，每种都有其优缺点：</p> 
<h3>1. URL重写</h3> 
<p><strong>原理：</strong> 在URL中附加会话标识符（如SessionID）。</p> 
<p><strong>优点：</strong></p> 
<ul><li>简单易实现</li><li>不依赖客户端存储</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>安全风险：SessionID可能被截获或泄露</li><li>URL变得冗长且不美观</li><li>可能影响SEO</li></ul> 
<p><strong>使用场景：</strong> 适用于安全要求不高的内部系统</p> 
<h3>2. 隐藏表单字段</h3> 
<p><strong>原理：</strong> 在HTML表单中添加隐藏字段存储会话信息。</p> 
<p><strong>优点：</strong></p> 
<ul><li>相对安全，不直接暴露在URL中</li><li>实现简单</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>仅适用于基于表单的交互</li><li>无法处理非表单请求（如AJAX）</li></ul> 
<p><strong>使用场景：</strong> 适合以表单为主的传统Web应用</p> 
<h3>3. Web Storage (localStorage/sessionStorage)</h3> 
<p><strong>原理：</strong> 利用HTML5的Web Storage API在客户端存储会话信息。</p> 
<p><strong>优点：</strong></p> 
<ul><li>数据持久性（localStorage）或会话期间持久（sessionStorage）</li><li>较大的存储容量</li><li>不随HTTP请求自动发送，可控制数据传输</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>需要JavaScript支持</li><li>潜在的XSS安全风险</li></ul> 
<p><strong>使用场景：</strong> 适合现代Web应用，特别是单页应用（SPA）</p> 
<h3>4. 基于令牌的认证（如JWT）</h3> 
<p><strong>原理：</strong> 服务器生成包含用户身份信息的令牌，客户端存储并在每次请求中包含该令牌。</p> 
<p><strong>优点：</strong></p> 
<ul><li>无状态，利于扩展</li><li>跨域支持好</li><li>可包含丰富的用户信息</li><li>安全性高（如果正确实现）</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>实现相对复杂</li><li>令牌管理（如刷新、撤销）需要额外考虑</li></ul> 
<p><strong>使用场景：</strong> 适合需要高安全性和可扩展性的现代Web应用和API</p> 
<h3>选择建议</h3> 
<ul><li>对于安全性要求高的应用，避免使用URL重写</li><li>如果是基于HTML5的现代应用，优先考虑Web Storage或基于令牌的方法</li><li>对于需要高度安全性和可扩展性的系统，推荐使用JWT等基于令牌的认证方式</li><li>在可能的情况下，组合使用多种方法以提高兼容性和安全性</li></ul> 
<p>记住，无论选择哪种方法，都要充分考虑安全性，并在实现过程中遵循最佳实践。</p> 
<p></p> 
<h2>Web应用中会话（Session）的删除</h2> 
<p>在Web应用中，会话（Session）可能因以下几个因素而被删除：</p> 
<h3>1. 会话超时</h3> 
<p>大多数框架都允许设置超时时间。如果特定会话在这段时间内未访问服务器，它将自动被删除。</p> 
<ul><li><strong>示例</strong>：在Java Servlet中，可以通过配置<code>web.xml</code>文件中的<code>&lt;session-config&gt;</code>来设置超时时间。</li></ul> 
<h3>2. 手动删除</h3> 
<p>应用程序代码可以显式地删除会话。</p> 
<ul><li><strong>示例</strong>：在Java Servlet中，可以使用<code>HttpSession.invalidate()</code>方法来删除会话。</li></ul> 
<h3>3. 服务器重启</h3> 
<ul><li><strong>默认情况</strong>：服务器重启时，所有内存中的会话都会被删除。</li><li><strong>例外情况</strong>：某些服务器可以将会话持久化到磁盘，并在重启后恢复它们。</li></ul> 
<h3>4. 浏览器关闭</h3> 
<ul><li>对于基于cookie的会话（最常见的实现），会话cookie通常在浏览器关闭时被删除。</li><li>这并不会立即删除服务器端的会话，除非设置了会话超时或服务器采取了行动。</li></ul> 
<h3>5. 服务器特定行为</h3> 
<p>会话管理由Web服务器处理，不同服务器之间可能存在差异：</p> 
<ul><li>有些服务器定期进行超时检查并删除过期会话。</li><li>其他服务器可能在接收请求时检查会话超时。</li></ul> 
<h3>最佳实践</h3> 
<ol><li>根据应用程序的安全需求设置适当的超时时间。</li><li>实现手动注销功能，以便用户完成操作后能主动使会话失效。</li><li>考虑使用安全的、HTTPOnly的cookie来存储会话ID，以增强安全性。</li><li>了解您所使用的特定服务器的会话管理策略。</li></ol> 
<p>注意：具体行为可能因Web服务器、应用程序框架和配置设置而异。</p> 
<h2>Tomcat创建Servlet实例的过程</h2> 
<p>Tomcat作为一个实现Servlet规范的Web容器，负责创建和管理Servlet对象的生命周期。以下是Tomcat创建和管理Servlet实例的详细过程：</p> 
<h3>1. 加载Servlet类</h3> 
<p>当Tomcat接收到一个请求并需要创建特定Servlet类时：</p> 
<ul><li>调用类加载器(ClassLoader)加载指定的类</li><li>如果类已被加载，则跳过此步骤</li></ul> 
<h3>2. 实例化Servlet类</h3> 
<ul><li>Tomcat使用Java反射机制的<code>Class.newInstance()</code>方法创建Servlet实例</li><li>此方法调用Servlet类的无参构造方法</li><li>注意：如果类没有无参构造方法或构造方法不可访问（如私有），将抛出异常</li></ul> 
<h3>3. 初始化Servlet对象</h3> 
<ul><li>Tomcat调用Servlet实例的<code>init(ServletConfig config)</code>方法</li><li>传入<code>ServletConfig</code>对象，包含初始化参数</li><li>此步骤允许Servlet执行任何必要的设置操作</li></ul> 
<h3>4. 处理请求（调用服务方法）</h3> 
<ul><li>初始化完成后，Tomcat调用Servlet的<code>service()</code>方法处理请求</li><li><code>service()</code>方法通常接收两个参数： 
  <ul><li><code>HttpServletRequest</code>实例：表示客户端请求</li><li><code>HttpServletResponse</code>实例：表示服务器响应</li></ul></li></ul> 
<h3>5. Servlet生命周期管理</h3> 
<ul><li>Servlet实例通常是单例的，每个Servlet类只创建一个实例</li><li>在多线程环境中，每个客户端请求由一个独立线程处理</li><li>开发者需确保Servlet的线程安全性</li></ul> 
<h3>6. Servlet销毁</h3> 
<ul><li>当Servlet不再需要或者服务器关闭时，Tomcat调用Servlet的<code>destroy()</code>方法</li><li>此方法用于释放资源，执行清理操作</li></ul> 
<h3>注意事项</h3> 
<ol><li><strong>反射机制</strong>：<code>newInstance()</code>方法是Java反射API的一部分，允许在运行时动态创建对象</li><li><strong>线程安全</strong>：由于Servlet是单例的，在多线程环境中需要特别注意线程安全问题</li><li><strong>性能考虑</strong>：Servlet的单例特性有助于提高性能，但也带来了线程安全的挑战</li><li><strong>错误处理</strong>：在整个过程中，Tomcat需要妥善处理可能出现的异常，如类加载失败、实例化错误等</li></ol> 
<p>通过这个过程，Tomcat能够灵活地管理Servlet的生命周期，实现了Servlet容器的核心功能。</p> 
<p></p> 
<h2>SQL注入攻击及其防范措施</h2> 
<p>SQL注入是一种常见且危险的网络攻击方式。攻击者通过在用户输入中插入恶意SQL代码，试图操纵数据库查询，从而获取敏感信息或篡改数据。为有效预防SQL注入攻击，可采取以下关键措施：</p> 
<ol><li><strong>使用预编译语句（Prepared Statements）</strong> 
  <ul><li>原理：在执行SQL语句前，先确定查询结构，再传入参数。</li><li>优势：参数不会被解释为SQL代码，有效防止注入。</li><li>实现：如在Java中使用<code>PreparedStatement</code>类。</li></ul></li><li><strong>采用参数化查询</strong> 
  <ul><li>与预编译语句类似，确保用户输入被视为数据而非代码。</li><li>适用于各种编程语言和数据库系统。</li></ul></li><li><strong>严格的用户输入验证</strong> 
  <ul><li>对所有用户输入进行过滤和验证。</li><li>例如：限制用户名只能包含字母和数字。</li><li>拒绝或转义潜在危险的字符。</li></ul></li><li><strong>实施最小权限原则</strong> 
  <ul><li>严格控制数据库访问权限。</li><li>只赋予用户完成必要操作的最小权限。</li><li>即使发生注入，也可限制潜在危害。</li></ul></li></ol> 
<p>通过综合应用这些方法，可以显著降低SQL注入攻击的风险。需要注意的是，安全措施应该是多层次的，不应仅依赖单一防御手段。持续的安全意识和定期的代码审查同样重要，有助于及时发现和修复潜在漏洞。</p> 
<p></p> 
<h2>XSS攻击与防御简介</h2> 
<h3>XSS攻击</h3> 
<p>XSS（跨站脚本攻击）是一种在网页上注入恶意脚本的攻击方式，使得这些脚本可以在其他用户的浏览器上运行。当用户访问含有恶意脚本的网页时，这些脚本会在用户的浏览器中执行，从而进行恶意操作，如：</p> 
<ul><li>获取用户信息</li><li>篡改网页内容</li><li>执行未经授权的操作</li></ul> 
<h3>防止XSS的方法</h3> 
<ol><li><strong>转义用户输入</strong>：对所有用户提供的数据进行转义处理，确保浏览器将其解析为纯文本，而不会执行为脚本。</li><li><strong>内容安全策略（CSP）</strong>：CSP是一种浏览器的安全机制，可以有效限制浏览器资源的运行和加载。例如，限制网页只能运行和加载来自同一域名的脚本，可以有效防止XSS。</li><li><strong>输入验证</strong>：对用户提交的信息进行校验，当发现含有可能引起XSS注入的内容时拒绝处理。</li><li><strong>使用HTTP-only Cookies</strong>：使用HTTP-only标志来修饰含有敏感信息的cookie，可以防止cookie内容被JavaScript获取或修改。</li><li><strong>避免使用不安全的JS代码</strong>：某些JS方法（如innerHTML）存在安全隐患，应尽量避免使用。</li></ol> 
<p>为了有效防御XSS攻击，最好结合使用上述多种方法，构建多层防御机制。定期的安全审计和更新也是保持网站安全的重要措施。</p> 
<p></p> 
<h2>CSRF</h2> 
<p>CSRF(跨站请求伪造)是一种网络安全攻击,利用用户在受信任网站上的已认证身份,执行未经授权的操作。攻击过程如下:</p> 
<ol><li>攻击者构造一个恶意网站或链接。</li><li>诱导目标用户点击该链接或访问恶意网站。</li><li>如果用户当前已登录目标网站,其身份认证信息(如cookies)会随请求自动发送。</li><li>攻击者利用这些认证信息,以用户的身份向目标网站发送伪造请求。</li><li>目标网站无法分辨这些请求是否由真实用户发起,从而执行了未经授权的操作。</li></ol> 
<p>CSRF攻击的危险在于,它能绕过身份认证,在用户不知情的情况下执行各种操作,如修改账户信息、进行交易等。为防范CSRF攻击,网站需要实施额外的安全措施,如使用anti-CSRF令牌、验证Referer头等。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e503bbe8795f54543f761ab154832d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL进阶之路】MySQL基础——从零认识MySQL</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34eea215fd881f977c3714b84e54a9bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Whisper Android 项目使用教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>