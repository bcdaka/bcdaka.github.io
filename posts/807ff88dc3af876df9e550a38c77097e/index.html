<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kotlin基础知识点 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/807ff88dc3af876df9e550a38c77097e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="kotlin基础知识点">
  <meta property="og:description" content="前言： 想象一下，你走进一家餐馆，菜单上有你熟悉的老派Java汉堡，还有新推出的Kotlin牛排。Kotlin不仅看起来更美味，还附带了免费的甜点——更简洁的语法和更少的错误。学习Kotlin的必要性，就像是选择更健康、更美味的餐点一样，让你在编程的世界里更加游刃有余。而且，你不需要担心适应问题，因为Kotlin和Java一样，都是熟悉的味道。为什么不来一份Kotlin大餐，让你的编程生活更滋味呢？
学习Kotlin，是每一位追求技术进步的开发者不可忽视的一步。Kotlin以其简洁优雅的语法和强大的功能，正在迅速成为现代编程语言的翘楚。作为一种与Java完全兼容的语言，Kotlin不仅能够提高开发效率，还能大幅减少代码中的错误，提升代码的可读性和可维护性。这些特性使得Kotlin不仅适用于新项目的开发，更是优化和升级现有Java项目的理想选择。
在当今竞争激烈的技术领域，掌握Kotlin无疑会让你在职业发展中占据一席之地。Kotlin已经成为Android开发的首选语言，同时也在后端开发、数据分析和多平台开发中展现出强大的生命力。通过学习Kotlin，你不仅能紧跟技术发展的潮流，还能为自己打开更多职业发展的机会之门。
现在，正是你抓住机遇、迎接挑战的时刻。每一次新的学习，都是一次自我提升的机会。让我们一起投入到Kotlin的世界中，探索更多的可能性，拓宽我们的技术视野。相信在不久的将来，你会因为今天的选择而感到自豪。加油，未来因你而更加精彩！
话不多说，直接进入学习。 数组的创建及使用数组的建立： val a = intArrayof(1,2,3,4).或 val a = IntArray(5){it&#43;1}.（第二种相当于是new了一个对象创建数组）
建立的数组是不可以修改的。
想要访问数组的内容可以通过遍历的方式、直接索引、或者把整体访问。
遍历 val a = intArratyof(1,2,3,4,5)
a.forEach{element-&gt;
println(element)
}
或
for(element in a){
println(element)
}
直接索引 val a = intArratyof(1,2,3,4,5)
a[0] 取出来的结果是1
3.整体访问
val a = intArratyof(1,2,3,4,5)
println(a.contentToString)
Kotlin数据类型和字符比较 在申明变量的时候，可以用val和var
val是申明一个不能被改变的变量，像java中给加上final
var是申明一个变量。
例如： var a=2
也可以补变量类型。var:int = 2 var:String = “hello world ”
申明Long类型的变量的时候，必须用大写的L，避免歧义。
var a =123456L
对于无符号类型，只用在类型的前面加上U，val a:Uint = 10u
字符串比较：
字符串的比较可以用 = = 和= = =。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T14:37:00+08:00">
    <meta property="article:modified_time" content="2024-07-24T14:37:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kotlin基础知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="background-color:transparent;margin-left:.0001pt;text-align:justify;">前言：</h4> 
<p style="background-color:transparent;margin-left:.0001pt;text-align:justify;"><strong>想象一下，你走进一家餐馆，菜单上有你熟悉的老派Java汉堡，还有新推出的Kotlin牛排。Kotlin不仅看起来更美味，还附带了免费的甜点——更简洁的语法和更少的错误。学习Kotlin的必要性，就像是选择更健康、更美味的餐点一样，让你在编程的世界里更加游刃有余。而且，你不需要担心适应问题，因为Kotlin和Java一样，都是熟悉的味道。为什么不来一份Kotlin大餐，让你的编程生活更滋味呢？</strong></p> 
<p><strong>学习Kotlin，是每一位追求技术进步的开发者不可忽视的一步。Kotlin以其简洁优雅的语法和强大的功能，正在迅速成为现代编程语言的翘楚。作为一种与Java完全兼容的语言，Kotlin不仅能够提高开发效率，还能大幅减少代码中的错误，提升代码的可读性和可维护性。这些特性使得Kotlin不仅适用于新项目的开发，更是优化和升级现有Java项目的理想选择。</strong></p> 
<p><strong>在当今竞争激烈的技术领域，掌握Kotlin无疑会让你在职业发展中占据一席之地。Kotlin已经成为Android开发的首选语言，同时也在后端开发、数据分析和多平台开发中展现出强大的生命力。通过学习Kotlin，你不仅能紧跟技术发展的潮流，还能为自己打开更多职业发展的机会之门。</strong></p> 
<p><strong>现在，正是你抓住机遇、迎接挑战的时刻。每一次新的学习，都是一次自我提升的机会。让我们一起投入到Kotlin的世界中，探索更多的可能性，拓宽我们的技术视野。相信在不久的将来，你会因为今天的选择而感到自豪。加油，未来因你而更加精彩！</strong></p> 
<p style="background-color:transparent;margin-left:.0001pt;text-align:justify;"></p> 
<p style="background-color:transparent;margin-left:.0001pt;text-align:justify;"><strong>话不多说，直接进入学习。                                        </strong><br>                               </p> 
<h4 style="background-color:transparent;margin-left:.0001pt;text-align:justify;"></h4> 
<h4 style="background-color:transparent;margin-left:.0001pt;text-align:justify;"></h4> 
<h4 style="background-color:transparent;margin-left:.0001pt;text-align:justify;">                                  数组的创建及使用数组的建立：</h4> 
<p style="margin-left:.0001pt;">val  a = intArrayof(1,2,3,4).或 val a = IntArray(5){it+1}.（第二种相当于是new了一个对象创建数组）</p> 
<p style="margin-left:.0001pt;">建立的数组是不可以修改的。</p> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;">想要访问数组的内容可以通过遍历的方式、直接索引、或者把整体访问。</p> 
<ol><li>遍历</li></ol> 
<p style="margin-left:.0001pt;">val a = intArratyof(1,2,3,4,5)</p> 
<p style="margin-left:.0001pt;">        a.forEach{element-&gt;</p> 
<p style="margin-left:.0001pt;">        println(element)</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">或</p> 
<p style="margin-left:.0001pt;">for(element in a){<!-- --></p> 
<p style="margin-left:.0001pt;">        println(element)</p> 
<p style="margin-left:.0001pt;">}</p> 
<ol><li>直接索引</li></ol> 
<p style="margin-left:.0001pt;">val a = intArratyof(1,2,3,4,5)</p> 
<p style="margin-left:.0001pt;">a[0]   取出来的结果是1</p> 
<p style="margin-left:.0001pt;">3.整体访问</p> 
<p style="margin-left:.0001pt;">val a = intArratyof(1,2,3,4,5)</p> 
<p style="margin-left:.0001pt;">println(a.contentToString)</p> 
<h4 style="background-color:transparent;margin-left:.0001pt;text-align:center;">Kotlin数据类型和字符比较</h4> 
<p style="margin-left:.0001pt;">在申明变量的时候，可以用val和var</p> 
<p style="margin-left:.0001pt;">val是申明一个不能被改变的变量，像java中给加上final</p> 
<p style="margin-left:.0001pt;">var是申明一个变量。</p> 
<p style="margin-left:.0001pt;">例如： var a=2</p> 
<p style="margin-left:.0001pt;">也可以补变量类型。var:int = 2     var:String = “hello world ”</p> 
<p style="margin-left:.0001pt;">申明Long类型的变量的时候，必须用大写的L，避免歧义。</p> 
<p style="margin-left:.0001pt;">var  a =123456L</p> 
<p style="margin-left:.0001pt;">对于无符号类型，只用在类型的前面加上U，val a:Uint = 10u</p> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;">字符串比较：</p> 
<p style="margin-left:.0001pt;"> 字符串的比较可以用 = = 和= = =。</p> 
<p style="margin-left:.0001pt;">a = = b相当于java中的equals，比较是 a和b两个的内容。</p> 
<p style="margin-left:.0001pt;">a= = = b 比较是否为同一个对象。</p> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;">raw String:用于书写很长的字符。</p> 
<p style="margin-left:.0001pt;">val n里面写的就是 raw String。</p> 
<p style="margin-left:.0001pt;">  trimIndent()方法可以把前面共同的空格去掉。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/a7/4b/3zY1xI4H_o.png"></p> 
<h4 style="margin-left:.0001pt;text-align:center;">Kotlin函数和方法的定义</h4> 
<p style="margin-left:.0001pt;">定义一个函数：</p> 
<p style="margin-left:.0001pt;">fun main(a:Array&lt;String&gt;):Unit{<!-- --></p> 
<p style="margin-left:.0001pt;">        println(a.contentToString())</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">fun 表示这是一个函数   main是指函数名，a是参数的形参</p> 
<p style="margin-left:.0001pt;">Arrat&lt;String&gt;是参数的类型，最后Unit是函数的返回值。Unit是指返回值为空。</p> 
<p style="margin-left:.0001pt;">定义一个方法：</p> 
<p style="margin-left:.0001pt;">方法可以看成一个特殊的函数，有receiver（也就是在类里面）的函数称为方法</p> 
<p style="margin-left:.0001pt;">class Text(){<!-- --></p> 
<p style="margin-left:.0001pt;">fun main(a:int):Int{<!-- --></p> 
<p style="margin-left:.0001pt;">        return a</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;">函数的引用：</p> 
<p style="margin-left:.0001pt;">fun a(){}</p> 
<p style="margin-left:.0001pt;"> ::a</p> 
<p style="margin-left:.0001pt;">也可以去接收这些函数的引用</p> 
<p style="margin-left:.0001pt;">val c:() -&gt;Unit = ::a</p> 
<p style="margin-left:.0001pt;">方法的引用：<br> class Text{<!-- --></p> 
<p style="margin-left:.0001pt;">         fun a(e:String)：Unit{}</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;"> Text:a</p> 
<p style="margin-left:.0001pt;">如果要接收这个方法</p> 
<p style="margin-left:.0001pt;">val c:(Text,String) -&gt; Unit=Text:a</p> 
<p style="margin-left:.0001pt;">或</p> 
<p style="margin-left:.0001pt;">val c:Text.(String) -&gt; Unit=Text:a</p> 
<p style="margin-left:.0001pt;">或</p> 
<p style="margin-left:.0001pt;">val c:Function2(Text,String,Unit) =Text:a</p> 
<p style="margin-left:.0001pt;">在函数内调用类中的方法：</p> 
<p style="margin-left:.0001pt;">class Text{<!-- --></p> 
<p style="margin-left:.0001pt;">         fun a(e:String)：Unit{}</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">fun t1(u:(Text,String)-&gt;Unit){<!-- --></p> 
<p style="margin-left:.0001pt;">        u(Text(),”1”)</p> 
<p style="margin-left:.0001pt;">或</p> 
<p style="margin-left:.0001pt;">u.invoke(Text(),”1”)</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;">定义一个变长参数</p> 
<p style="margin-left:.0001pt;"> fun a(vararg args:String){<!-- --></p> 
<p style="margin-left:.0001pt;">        println(args.contentToString())</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">定义多返回值:</p> 
<p style="margin-left:.0001pt;">fun a():Triple&lt;Int,Long,Double&gt;{<!-- --></p> 
<p style="margin-left:.0001pt;">        ReturnTriple(1,3L,4.0)</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">Triple是三个返回值</p> 
<p style="margin-left:.0001pt;">Pair是两个返回值</p> 
<p style="margin-left:.0001pt;"> 具名参数：</p> 
<p style="margin-left:.0001pt;">fun a(x:Int=1,y:String=””)Pair&lt;Int,String&gt;{<!-- --></p> 
<p style="margin-left:.0001pt;">        return Pair(x,y)</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">再调用的时候可以只传入一个，就会有默认值</p> 
<p style="margin-left:.0001pt;">        a(y=”1”)</p> 
<p style="margin-left:.0001pt;">此时的x就会是默认值的1</p> 
<h4 style="margin-left:.0001pt;text-align:center;">kotlin中的区间</h4> 
<p style="margin-left:.0001pt;">区间的创建：</p> 
<p style="margin-left:.0001pt;">val a = 1..10 从1取到10</p> 
<p style="margin-left:.0001pt;">val a = ’a’..’z’从a取到z</p> 
<p style="margin-left:.0001pt;">val a = 1L..10L 从1L取到10L</p> 
<p style="margin-left:.0001pt;">取值1-10的整型，属于离散型。1L-10L 属于连续型。</p> 
<p style="margin-left:.0001pt;"></p> 
<p style="margin-left:.0001pt;">val a = 1 until 10// [1,10)  从1取到9</p> 
<p style="margin-left:.0001pt;">如果想要倒序的区间</p> 
<p style="margin-left:.0001pt;">val a = 10 downTo 1//[10…,1]</p> 
<p style="margin-left:.0001pt;">想要有间隔的区间</p> 
<p style="margin-left:.0001pt;">val a = 1..10 step 2  取值是1、3、5、7、9</p> 
<p style="margin-left:.0001pt;">想要把整型区间打印出来，可以用joinToString()方法</p> 
<p style="margin-left:.0001pt;">val a = 1..10</p> 
<p style="margin-left:.0001pt;">println(a.joinToString())</p> 
<p style="margin-left:.0001pt;">想要打出离散型,只能打出一段描述</p> 
<p style="margin-left:.0001pt;">val a=1f..2f</p> 
<p style="margin-left:.0001pt;">println(a.toString())// 结果是1.0 .. 2.0</p> 
<p style="margin-left:.0001pt;">遍历区间：</p> 
<p style="margin-left:.0001pt;">1.val a = intArrayOf(1,3,5,7)</p> 
<p style="margin-left:.0001pt;">for(i in o until a.size){<!-- --></p> 
<p style="margin-left:.0001pt;">        println(a[i])</p> 
<p style="margin-left:.0001pt;">}</p> 
<p style="margin-left:.0001pt;">或</p> 
<p style="margin-left:.0001pt;">for(i in a.indices){<!-- --></p> 
<p style="margin-left:.0001pt;">        println(i)</p> 
<p style="margin-left:.0001pt;">}</p> 
<h4 style="margin-left:.0001pt;text-align:center;">Kotlin集合</h4> 
<p style="margin-left:.0001pt;text-align:left;">分为可变List（MutableList）、不可变List。可变Map（MutableMap）、不可变Map</p> 
<p style="margin-left:.0001pt;text-align:left;">可变Set、不可变Set（MutableSet）</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/38/d0/ixPANZtY_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;">创建一个集合</p> 
<p style="margin-left:.0001pt;text-align:left;">val a:List&lt;Int&gt; = listof(1，2，3)</p> 
<p style="margin-left:.0001pt;text-align:left;">Val b:MutableList&lt;Int&gt; = mutableListOf(1,2,3)</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">遍历集合：</p> 
<p style="margin-left:.0001pt;text-align:left;">a.forEach{element-&gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">  println(element)</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">for(element in a){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println(element)</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">Map键值对的创建</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">val a:Map&lt;String,Any&gt; = mapof(“age” to “18”)</p> 
<p style="margin-left:.0001pt;text-align:left;">val a:Map&lt;String,Any&gt; = mutableMapOf(“age” to “18”)</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">遍历map：</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">for(element in a.entries){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println(“${element.key}, ${element.value}”)</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<ol><li style="text-align:left;">forEach{<!-- --></li></ol> 
<p style="margin-left:.0001pt;text-align:left;">   Println(it)</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">修改集合  可以用:</p> 
<p style="margin-left:.0001pt;text-align:left;">val a:MutableList&lt;String&gt; = mutableListOf(“s”)</p> 
<ol><li style="text-align:left;">add(“t”)  也同等于 a +=  “t”</li></ol> 
<ol><li style="text-align:left;">remove(“s”)</li></ol> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">Pair类</p> 
<p style="margin-left:.0001pt;text-align:left;">两种创建方式：</p> 
<p style="margin-left:.0001pt;text-align:left;">val a= ”age” to “18”</p> 
<p style="margin-left:.0001pt;text-align:left;">val a=Pair(“age”,”18”)</p> 
<p style="margin-left:.0001pt;text-align:left;">获取对应的元素：</p> 
<p style="margin-left:.0001pt;text-align:left;">val first = pair.first</p> 
<p style="margin-left:.0001pt;text-align:left;">val second= pair.second</p> 
<p style="margin-left:.0001pt;text-align:left;">val (x,y) = a</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">Triple类</p> 
<p style="margin-left:.0001pt;text-align:left;">两种创建方式：</p> 
<p style="margin-left:.0001pt;text-align:left;">val a=Triple(“age”,”18”,”20”)</p> 
<p style="margin-left:.0001pt;text-align:left;">获取对应的元素：</p> 
<p style="margin-left:.0001pt;text-align:left;">val first = triple.first</p> 
<p style="margin-left:.0001pt;text-align:left;">val second= triple.second</p> 
<p style="margin-left:.0001pt;text-align:left;">val third= triple.third</p> 
<p style="margin-left:.0001pt;text-align:left;">val (x,y,z) = a</p> 
<h4 style="margin-left:.0001pt;text-align:center;">类和接口</h4> 
<p style="margin-left:.0001pt;text-align:left;">在kotlin中，类默认是Public，定义成员的时候，必须给赋值。</p> 
<p style="margin-left:.0001pt;text-align:left;">类的构造方法有三种写法：常用的是最后一种，主构造器，是定义在类定义那一行，在类实例化的时候，一定会被执行的主构造器。</p> 
<p style="margin-left:.0001pt;text-align:left;">class  Text{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val a:Int = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">        constructor(x:Int){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                this.x = x</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">或</p> 
<p style="margin-left:.0001pt;text-align:left;">class Text constructor(x:Int){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val a:Int = x</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">或</p> 
<p style="margin-left:.0001pt;text-align:left;">class Text(val a:Int){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">类的实例化：</p> 
<p style="margin-left:.0001pt;text-align:left;">val a = Text(5)</p> 
<p style="margin-left:.0001pt;text-align:left;">如果类里面有个属性x，可以用a.x拿个这个值。一定要和a::x区别开，a::x只是拿个引用。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">类中方法的调用和引用也是同理。假设Text类中有一个方法 fun fuction(){}</p> 
<p style="margin-left:.0001pt;text-align:left;">val a=Text(5) 这里也是先取到Text的实例化对象。</p> 
<ol><li style="text-align:left;">fuction()  这个是调用     a::fuction</li></ol> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">接口的定义：</p> 
<p style="margin-left:.0001pt;text-align:left;">interface IText{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">  fun a(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">接口的实现：</p> 
<p style="margin-left:.0001pt;text-align:left;">class a():Text{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        override fun a(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">抽象类的定义：  在其中  抽象方法没有方法体，普通方法如果不加open 继承的时候就没有办法复写，普通方法可以有方法体。</p> 
<p style="margin-left:.0001pt;text-align:left;">abstract class AText{<!-- --><br> abstract fun a  ()</p> 
<p style="margin-left:.0001pt;text-align:left;">         Open fun b (){}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">抽象类的继承：继承的类在冒号：后面跟()</p> 
<p style="margin-left:.0001pt;text-align:left;">class T:AText(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        override fun a(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">        override fun b(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">如果继承的方法在前面再加上一个final，那么就不能继承再次继承这个方法。</p> 
<p style="margin-left:.0001pt;text-align:left;">例如：</p> 
<p style="margin-left:.0001pt;text-align:left;">abstract class A(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        open fun a(){}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">Open class b():A(){          //这个类如果不加open是不能被下面的继承。</p> 
<p style="margin-left:.0001pt;text-align:left;">        final override fun a(){}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">class c():b(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">   //  在C这个类中就不能继承B中的方法。因为B中的方法是final。</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">在kotlin中定义一个property 是自动包含set和get：</p> 
<p style="margin-left:.0001pt;text-align:left;">class a(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val a1:Int=0</p> 
<p style="margin-left:.0001pt;text-align:left;">        set(value){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                field = value   //这是将set的值value给到之前的值field，实现覆盖。</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">        get(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                return field     //这里的field指的是值</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">属性引用</p> 
<p style="margin-left:.0001pt;text-align:left;">Class A(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val a1:Int=0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">        val c = A::a1</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">val a = A()    //  这一行相当于new了一个A类出来。</p> 
<p style="margin-left:.0001pt;text-align:left;">c.set(a,5)    //这里c并没有绑定receiver ，所以在传递参数的时候需要绑定。</p> 
<p style="margin-left:.0001pt;text-align:left;">a.set(5)     //a已经绑定好了receiver，就不需要再重复进行绑定。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h4 style="margin-left:.0001pt;text-align:center;">扩展方法和扩展属性</h4> 
<p style="margin-left:.0001pt;text-align:left;">  在方法的前面加上类，就是扩展方法：</p> 
<p style="margin-left:.0001pt;text-align:left;">class Utils(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var c:Boolean = true</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">fun Utils.isPass(passWord:String=””):Boolean{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val isRight = passWord ==””</p> 
<p style="margin-left:.0001pt;text-align:left;">        return isRight</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">在属性的定义前面加上类就是扩展：属性的扩展没有field只有get和set。</p> 
<p style="margin-left:.0001pt;text-align:left;">field是一种状态。</p> 
<p style="margin-left:.0001pt;text-align:left;">var Utils.check:Boolean</p> 
<p style="margin-left:.0001pt;text-align:left;">        get(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                return this.c</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">        set(value){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                this.c = value</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">在接口里面定义属性，只有属性的get 和 set，field是一种状态，但是可以定义行为。</p> 
<p style="margin-left:.0001pt;text-align:left;">在接口中定义方法的时候，也只能是行为而不能是状态，传递数据。</p> 
<p style="margin-left:.0001pt;text-align:left;">Interface  Text{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var simple:String</p> 
<p style="margin-left:.0001pt;text-align:left;">        fun t(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                println(“”)</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">扩展方法的引用：</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">①没有receive的</p> 
<p style="margin-left:.0001pt;text-align:left;">class Utils(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var c:Boolean = true</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">fun Utils.isPass(passWord:String=””):Boolean{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">val isRight = passWord ==””</p> 
<p style="margin-left:.0001pt;text-align:left;">  return isRight</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#00ffff;">Utils::ispass</span>      (Utils,Boolean ) -&gt;Boolean</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">②绑定了receive</p> 
<p style="margin-left:.0001pt;text-align:left;">true::ispass       (Boolean)   -&gt; Boolean</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h4 style="margin-left:.0001pt;text-align:center;">空类型安全</h4> 
<p style="margin-left:.0001pt;text-align:left;">在kotlin中，定义变量默认是不可以为空的。</p> 
<p style="margin-left:.0001pt;text-align:left;">var i: String =”  ”</p> 
<p style="margin-left:.0001pt;text-align:left;">i = null   //会报错，不能为空。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">如果想要定义了有可能为空，可以用强制类型转换。</p> 
<p style="margin-left:.0001pt;text-align:left;">var i: String？ =”  ”</p> 
<p style="margin-left:.0001pt;text-align:left;">i = null   </p> 
<p style="margin-left:.0001pt;text-align:left;">println(i!!.length)  //用了强制转换，让i.length不为空，这只是保证不为空，但还是有可能</p> 
<p style="margin-left:.0001pt;text-align:left;">                 空，不安全。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">强制转换还是很不安全，不建议使用，可以换一种温柔的方法使用。</p> 
<p style="margin-left:.0001pt;text-align:left;">var i: String？ =”  ”</p> 
<p style="margin-left:.0001pt;text-align:left;">var length:Int = i?.length ?: 0 //前面的i?  表示有可能为空。?: 叫做elvis表达式，会在为空的时候返回 0</p> 
<p style="margin-left:.0001pt;text-align:left;">println(length)</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">跨平台编译的时候，平台类型不一样，不可以转换，一定要防止为空。</p> 
<p style="margin-left:.0001pt;text-align:left;">平台客观存在，不能主观定义。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/8a/37/0ID4Wiz0_o.png"></p> 
<h4 style="margin-left:.0001pt;text-align:center;">使用Retrofit</h4> 
<p style="margin-left:.0001pt;text-align:left;">①先定义一个接口，根据使用类型命名，比如获取GitHub的内容。</p> 
<p style="margin-left:.0001pt;text-align:left;">interface GitHuber {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">    @GET("/repos/{owner}/{repo}")</p> 
<p style="margin-left:.0001pt;text-align:left;">    fun getRepository(</p> 
<p style="margin-left:.0001pt;text-align:left;">        @Path("owner") owner:String,</p> 
<p style="margin-left:.0001pt;text-align:left;">        @Path("repo") repo: String</p> 
<p style="margin-left:.0001pt;text-align:left;">    ):retrofit2.Call&lt;Repository&gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">其中@GET是一个注解，repos指定仓库的固定部分。owner和repo 是路径占位符，可以在传入的时候灵活改变。</p> 
<p style="margin-left:.0001pt;text-align:left;">retrofit2.Call&lt;Repository&gt; 是异步请求的结果，Repository指向的是一个json转Kotlin的类型（可以使用快捷键alt+k的方式，快速打开json转换）</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/41/cf/hJgUH90l_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;">②配置Retrofit的实例</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/a9/a0/vaG4MNIW_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;">Retrofit.Builder() 进行实例构造。返回的类型结果是Retrofit.Builder</p> 
<p style="margin-left:.0001pt;text-align:left;">用连点的形式，.baseUrl()  里面传入基本的URL，所有设置的API都会基于这个URL</p> 
<p style="margin-left:.0001pt;text-align:left;">.addConverterFactory,添加一个转换工厂，这里使用Gson将JSON转换成Kotlin对象。</p> 
<p style="margin-left:.0001pt;text-align:left;">.build() 构建Retrofit实例。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">生成的retrofit属性，类型属于Retrofit.builder</p> 
<p style="margin-left:.0001pt;text-align:left;">val gitHuberApi = retrofit.create(GitHuber::class.java)  利用反射的形式生成上面接口的服务。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">val respose = gitHuberApi.getRepository("JetBrains","Kotlin").execute()</p> 
<p style="margin-left:.0001pt;text-align:left;">getRepository传入的两个参数，第一个指向owner，第二个指向repo。</p> 
<p style="margin-left:.0001pt;text-align:left;">.execute()是一个同步方法，只有等一个执行完后，才能执行下一个。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">respose.body()是拿到所有的信息。</p> 
<p style="margin-left:.0001pt;text-align:left;">然后先判断是否为空，为空就打印报错代码和信息。</p> 
<p style="margin-left:.0001pt;text-align:left;">否则里面有智能空类型转换，就能直接输出想要的信息了。</p> 
<h4 style="margin-left:.0001pt;text-align:center;">变量和常量</h4> 
<p style="margin-left:.0001pt;text-align:left;">在kotlin中定义只读变量：</p> 
<p style="margin-left:.0001pt;text-align:left;"> val a:Int = 0   //  因为可以用get去设置return的返回值，所以是只读变量。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">定义常量前面加上关键字const就可以了</p> 
<p style="margin-left:.0001pt;text-align:left;">const val a:Int = 0    //加上const后，只能定义全局范围，只能修饰基本类型，必须初始化。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">常量引用：</p> 
<p style="margin-left:.0001pt;text-align:left;">val person = Person(18,”xiaoming”)  //person 是一个常量引用</p> 
<p style="margin-left:.0001pt;text-align:left;">person.age = 19   //对象改变但引用没变</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">编译器常量：</p> 
<p style="margin-left:.0001pt;text-align:left;">const val a:Int = 0    //编译的时候确定的值</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">运行时常量：</p> 
<p style="margin-left:.0001pt;text-align:left;"> val a:Int = 0       // 运行的时候才能确定的值</p> 
<h4 style="margin-left:.0001pt;text-align:center;">分支表达式</h4> 
<ul><li style="text-align:left;">if else</li></ul> 
<p style="margin-left:.0001pt;text-align:left;">if else可以作为三元表达式：</p> 
<p style="margin-left:.0001pt;text-align:left;">  c=if(a==3) 4 else 5    //先判断a是否等于3  等于3，把4赋值给c，否则把5赋值给c。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">if else  基础写法：</p> 
<p style="margin-left:.0001pt;text-align:left;">If(a==3){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        c=4</p> 
<p style="margin-left:.0001pt;text-align:left;">}else{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        c=5</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">②when表达式，也就是java中的switch</p> 
<p style="margin-left:.0001pt;text-align:left;">when (a){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        0 -&gt; c = 5   //当a等于0的时候，c赋值为5</p> 
<p style="margin-left:.0001pt;text-align:left;">        1 -&gt; c = 7   //当a等于1的时候，c赋值为7</p> 
<p style="margin-left:.0001pt;text-align:left;">        else -&gt; c = 20  //其他情况，c赋值为20</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">还可以把c提出来写:</p> 
<p style="margin-left:.0001pt;text-align:left;">c=when (a){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        0 -&gt; 5   //当a等于0的时候，c赋值为5</p> 
<p style="margin-left:.0001pt;text-align:left;">        1 -&gt; 7   //当a等于1的时候，c赋值为7</p> 
<p style="margin-left:.0001pt;text-align:left;">        else -&gt; 20  //其他情况，c赋值为20</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">还可以把() 括号中的变量去掉。放在里面：</p> 
<p style="margin-left:.0001pt;text-align:left;">when {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        a = 0 -&gt; c = 5   //当a等于0的时候，c赋值为5</p> 
<p style="margin-left:.0001pt;text-align:left;">        a = 1 -&gt; c = 7   //当a等于1的时候，c赋值为7</p> 
<p style="margin-left:.0001pt;text-align:left;">        else -&gt; c = 20  //其他情况，c赋值为20</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">when的()里面还可以做一些赋值:</p> 
<p style="margin-left:.0001pt;text-align:left;">var e = when (val a = readLine()) {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        null -&gt; 0</p> 
<p style="margin-left:.0001pt;text-align:left;">        else -&gt; a.length</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">try...catch 分支</p> 
<p style="margin-left:.0001pt;text-align:left;">fun pp(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val a:Int = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">        val b:Int = 5</p> 
<p style="margin-left:.0001pt;text-align:left;">        var c:Int</p> 
<p style="margin-left:.0001pt;text-align:left;">        if(5==2){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        c = 9</p> 
<p style="margin-left:.0001pt;text-align:left;">        }else{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                c = 15</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">try {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        c = a/b</p> 
<p style="margin-left:.0001pt;text-align:left;">        }catch (e:Exception){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                e.printStackTrace()</p> 
<p style="margin-left:.0001pt;text-align:left;">                c = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">还可以把里面的c提出来。</p> 
<p style="margin-left:.0001pt;text-align:left;">c=try {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        a/b</p> 
<p style="margin-left:.0001pt;text-align:left;">        }catch (e:Exception){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                e.printStackTrace()</p> 
<p style="margin-left:.0001pt;text-align:left;">                0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h4 style="margin-left:.0001pt;text-align:center;">运算符的重载和中缀表达式</h4> 
<p style="margin-left:.0001pt;text-align:left;">运算符的重载：</p> 
<p style="margin-left:.0001pt;text-align:left;">在使用类进行运算的时候，可以通过重载运算符完成运算。</p> 
<p style="margin-left:.0001pt;text-align:left;">fun main(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">    val c = Compare(3,5)</p> 
<p style="margin-left:.0001pt;text-align:left;">    println((c - 5))    //打印出来的结果是     real：-2    image：5</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">class Compare(var real:Int,var image:Int ){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">    override fun toString() = "real:${real}    image:${image}"   // 如果不复写toString方法的话，返回的是对象类名+哈希码</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">operator fun Compare.minus(value: Int): Compare {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">    return Compare(this.real-value,this.image)</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">中缀表达式：</p> 
<p style="margin-left:.0001pt;text-align:left;">先用关键字infix 申明</p> 
<p style="margin-left:.0001pt;text-align:left;">infix fun &lt;A,B&gt; A.to(x:B):Int(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        Return ....</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">先用关键字infix申明，A和B代表两个类型，中间的“to”可以换成你想要的任何字符。</p> 
<p style="margin-left:.0001pt;text-align:left;">x表示变量名，:Int表示返回值的类型。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">按照上面的写出来的中缀表达式就是：</p> 
<p style="margin-left:.0001pt;text-align:left;">A to B</p> 
<p style="margin-left:.0001pt;text-align:left;">或</p> 
<p style="margin-left:.0001pt;text-align:left;">A.to(B)</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h4 style="margin-left:.0001pt;text-align:center;">Kotlin中lambda表达式</h4> 
<p style="margin-left:.0001pt;text-align:left;">匿名函数的写法：</p> 
<p style="margin-left:.0001pt;text-align:left;">val text :(Int) -&gt;Unit = fun(p:Int){      //  把一个匿名函数赋值给了一个变量text，调用时需要传入的                                                           参数为    Int，返回值是Unit</p> 
<p style="margin-left:.0001pt;text-align:left;">        println(p.toString)            </p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">调用匿名函数，可以用text(5)  或  text.invoke(5)    //都是一样的效果</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">Lambda表达式：</p> 
<p style="margin-left:.0001pt;text-align:left;">val text: (Int) - &gt; Int= {p:Int - &gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">        println(“”)       //:(Int)表示传入参数的类型是Int。- &gt;Int，表示返回值是Int。</p> 
<p style="margin-left:.0001pt;text-align:left;">        123            //返回值的类型跟代码的最后一行有关。</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">可以进行类型推导，省略参数类型代码：</p> 
<p style="margin-left:.0001pt;text-align:left;">val text= {p:Int - &gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">        println(“”)       </p> 
<p style="margin-left:.0001pt;text-align:left;">        123           </p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">或者是</p> 
<p style="margin-left:.0001pt;text-align:left;">val text: Function1&lt;Int,Unit&gt;= {p - &gt;</p> 
<p style="margin-left:.0001pt;text-align:left;">        println(“”)       </p> 
<p style="margin-left:.0001pt;text-align:left;">          </p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">如果lambda只有一个参数，可以省略不写。</p> 
<p style="margin-left:.0001pt;text-align:left;">val text: Function1&lt;Int,Unit&gt;= {     //这里只有一个参数，不写的情况，默认就是it。</p> 
<p style="margin-left:.0001pt;text-align:left;">        println(it)       </p> 
<p style="margin-left:.0001pt;text-align:left;">           </p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h4 style="margin-left:.0001pt;text-align:center;">HashSet中hashCode和equals方法</h4> 
<p style="margin-left:.0001pt;text-align:left;">在HashSet中本质上用的HashMap，不过在HashMap中每一个元素是 key-value，HashSet是使用Key作为传入的元素，value是默认值都是一样的。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">无论是HashSet还是HashMap中，都会先比较hashCode，hashCode比较的是哈希值，如果两个不一样，直接添加进去。如果一样的话，再调用equals方法，判断是否一样。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">如果想要将相同值的对象添加进HashSet中，需要重写hashCode方法和equals方法。</p> 
<p style="margin-left:.0001pt;text-align:left;">：</p> 
<p style="margin-left:.0001pt;text-align:left;">fun main(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val teach = HashSet&lt;Teach&gt;()</p> 
<p style="margin-left:.0001pt;text-align:left;">        (0..5).forEach{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                teach.add(Teach("math",5))</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">        println(teach.size)</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">class Teach (var t:String, var u:Int){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        override fun hashCode(): Int {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                var resultU = u</p> 
<p style="margin-left:.0001pt;text-align:left;">                return 31*resultU+t.hashCode()</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">        override fun equals(other: Any?): Boolean {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                val compare = (other as? Teach)?:return false</p> 
<p style="margin-left:.0001pt;text-align:left;">                return this.t == other.t &amp;&amp; this.u == other.u</p> 
<p style="margin-left:.0001pt;text-align:left;">                return true</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">在kotlin中 == 是判断内容是否相等。  ===是判断对象是否相同。</p> 
<h4 style="margin-left:.0001pt;text-align:center;">重载String运算</h4> 
<p style="margin-left:.0001pt;text-align:justify;">在重载实现的过程中，写到了minus、times、div</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">在实现对String中的删除字符用replace方法：</p> 
<p style="margin-left:.0001pt;text-align:justify;">operator fun String.minus(right:Any?):String{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    return this.replaceFirst(right.toString(),"")</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">Replace(oldValue: String, newValue: String, ignoreCase: Boolean = false)方法三个参数，第一个是要被替换的内容，第二个是替换成什么内容，第三个是是否忽视大小写，默认是不忽视。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">在实现对String中times（也就是*）的功能时，用到joinToString方法：</p> 
<p style="margin-left:.0001pt;text-align:justify;">operator fun String.times(right: Int):String{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:justify;">    return (1..right).joinToString(separator = "", transform = {this})</p> 
<p style="margin-left:.0001pt;text-align:justify;">}</p> 
<p style="margin-left:.0001pt;text-align:justify;">joinToString()</p> 
<p style="margin-left:.0001pt;text-align:justify;">separator: 分隔符，默认为 ", "。</p> 
<p style="margin-left:.0001pt;text-align:justify;">prefix: 前缀，默认为空字符串。</p> 
<p style="margin-left:.0001pt;text-align:justify;">postfix: 后缀，默认为空字符串。</p> 
<p style="margin-left:.0001pt;text-align:justify;">limit: 限制要连接的元素数量，超过数量的元素会用 truncated 替换。</p> 
<p style="margin-left:.0001pt;text-align:justify;">truncated: 当元素数量超过 limit 时，用于替换多余元素的字符串，默认为 "..."。</p> 
<p style="margin-left:.0001pt;text-align:justify;">transform: 一个可选的 lambda 表达式，用于转换每个元素。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">在实现对String中div 的widowed方法：</p> 
<p style="margin-left:.0001pt;text-align:justify;">operator fun String.div(right: Any?):Int<span style="background-color:#ffff00;"><span style="color:#000000;">{<!-- --></span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#000000;">    val tRight = right.toString()</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#000000;">    return this.windowed(tRight.length,1){it == right</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;"><span style="color:#000000;">    }</span></span>.count(){it}      //标黄部分返回的是一个List列表，通过数正确的数，返回this中包</p> 
<p style="margin-left:.0001pt;text-align:justify;">}                    含多少个right。</p> 
<p style="margin-left:.0001pt;text-align:justify;">Windowed()方法有以下参数：</p> 
<p style="margin-left:.0001pt;text-align:justify;">size: 每个窗口的大小。</p> 
<p style="margin-left:.0001pt;text-align:justify;">step: 每次滑动的步幅（默认为 1）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">partialWindows: 是否包含不完整的窗口（即不足 size 大小的窗口）（默认为 false）。</p> 
<p style="margin-left:.0001pt;text-align:justify;">transform: 转换函数，可以将每个窗口转换成不同的类型（可选）。</p> 
<h4 style="margin-left:.0001pt;text-align:center;">高阶函数</h4> 
<p style="margin-left:.0001pt;text-align:left;">高阶函数的定义：在函数的参数或者在返回类型为函数的时候，称为高阶函数。</p> 
<p style="margin-left:.0001pt;text-align:left;">①在函数的参数部分传入函数：</p> 
<p style="margin-left:.0001pt;text-align:left;">fun costTime(cost:()-&gt; Unit){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val sTime = System.currentTimeMillis()   //  记录当前的时间</p> 
<p style="margin-left:.0001pt;text-align:left;">        cost() //运行参数中的函数的代码</p> 
<p style="margin-left:.0001pt;text-align:left;">        println (System.currentTimeMillis()-sTime) //最后返回运行代码花费多少时间</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">在costTime函数的参数，传入了一个函数，里面函数的参数为空，返回值为Unit。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">调用costTime高阶函数：</p> 
<p style="margin-left:.0001pt;text-align:left;">costTime(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        //这里面写cost做的事情</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">在调用的时候，这里实际上是一个lambda表达式，把括号里面的函数写成大括号,如果里面只有一个参数，可以把小括号省略掉。</p> 
<p style="margin-left:.0001pt;text-align:left;">比如：</p> 
<p style="margin-left:.0001pt;text-align:left;">costTime{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        //这里面写cost做的事情</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">②在函数的返回类型传入函数：</p> 
<p style="margin-left:.0001pt;text-align:left;">fun fibonacci():()-&gt;Long{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var first = 0L</p> 
<p style="margin-left:.0001pt;text-align:left;">        var second = 1L</p> 
<p style="margin-left:.0001pt;text-align:left;">        return {                 //这里的返回是一个匿名函数，也可以看出闭包。</p> 
<p style="margin-left:.0001pt;text-align:left;">                val next = first+second //闭包就可以获取函数变量外部的值</p> 
<p style="margin-left:.0001pt;text-align:left;">                val current = first</p> 
<p style="margin-left:.0001pt;text-align:left;">                first = second</p> 
<p style="margin-left:.0001pt;text-align:left;">                second = next</p> 
<p style="margin-left:.0001pt;text-align:left;">                current</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">上面的fibonacci也是一个高阶函数，可以获取斐波那契函数。</p> 
<p style="margin-left:.0001pt;text-align:left;">调用fibonacci函数：</p> 
<p style="margin-left:.0001pt;text-align:left;">val  fib  = fibonacci()      //获取fibonacci函数的实例，fib后面隐藏了</p> 
<p style="margin-left:.0001pt;text-align:left;"> //如果把上面的fib写全，应该是 val fib:()-&gt;Long = fibonacci()</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<h4 style="margin-left:.0001pt;text-align:center;">内联函数</h4> 
<p style="margin-left:.0001pt;text-align:left;">内联函数的作用：</p> 
<p style="margin-left:.0001pt;text-align:left;">把函数的调用，转换成实际函数体的调用。可以减少函数调用开销，提高性能。</p> 
<p style="margin-left:.0001pt;text-align:left;">通常配合高阶函数一起使用，同时还能减少高阶函数中lambda表达式的对象创建和内存分配。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">①定义内联函数：</p> 
<p style="margin-left:.0001pt;text-align:left;">给函数定义的最前面加上 inline：</p> 
<p style="margin-left:.0001pt;text-align:left;">inline fun cTime(cost:()-&gt;Unit):Long{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val cS = System.currentTimeMillis()</p> 
<p style="margin-left:.0001pt;text-align:left;">        cost()</p> 
<p style="margin-left:.0001pt;text-align:left;">        return System.currentTimeMillis()-cS</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">②调用内联函数：</p> 
<p style="margin-left:.0001pt;text-align:left;">  cTime{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println(“调用内联函数”)</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">调用的结果相当于：</p> 
<p style="margin-left:.0001pt;text-align:left;">val cS = System.currentTimeMillis()</p> 
<p style="margin-left:.0001pt;text-align:left;">println(“调用内联函数”)</p> 
<p style="margin-left:.0001pt;text-align:left;">return System.currentTimeMillis()-cS</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">③在使用forEach中如果想要对某次的值进行跳出：</p> 
<p style="margin-left:.0001pt;text-align:left;">val i = intArrayOf(1,2,3,4)</p> 
<p style="margin-left:.0001pt;text-align:left;">i.forEach{element-&gt;    //默认是it，可以通过这样的方式改变为element</p> 
<p style="margin-left:.0001pt;text-align:left;">if(element == 3 ) return @forEach    //在element为3的时候，跳过这次循环。element等于4还是会</p> 
<p style="margin-left:.0001pt;text-align:left;">                                 正常执行</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">④non-local return    非本地退出 :</p> 
<p style="margin-left:.0001pt;text-align:left;">inline fun cTime(cost:()-&gt;Unit):Long{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val cS = System.currentTimeMillis()</p> 
<p style="margin-left:.0001pt;text-align:left;">        cost()</p> 
<p style="margin-left:.0001pt;text-align:left;">        return System.currentTimeMillis()-cS</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">fun main(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        cTime{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        return                 //这里因为ruturn跳出了main函数的循环了</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">        println("这一行不能被打印，因为前面return了")</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">⑤如果有可能存在不合法的non-local return，加关键字crossinline：</p> 
<p style="margin-left:.0001pt;text-align:left;">inline fun Runnable(crossinline block:()- Unit):Runnable{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">⑥没有被赋值的属性，可以内联。</p> 
<p style="margin-left:.0001pt;text-align:left;">class Bi(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var pocket = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">        var money: Int</p> 
<p style="margin-left:.0001pt;text-align:left;">        inline get() {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                return 0</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">        inline set(value) {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                pocket = value</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">⑦内联函数的限制：</p> 
<p style="margin-left:.0001pt;text-align:left;">内联函数只能访问public 成员：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/e1/ed/AYWMFm1i_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;">内联函数参数不能被存储：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/25/WeVkT3XP_o.png"></p> 
<p style="margin-left:.0001pt;text-align:left;">内联函数的内联参数只能传递给其他内联函数参数：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/65/50/oq99UQdV_o.png"></p> 
<h4 style="margin-left:.0001pt;text-align:center;">常见的高阶函数</h4> 
<p style="margin-left:.0001pt;text-align:left;">五个常见的高阶函数，let、run、also、apply、use。</p> 
<p style="margin-left:.0001pt;text-align:left;">①let函数，默认it作为参数传入，返回lambda表达式的return：</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">class Bi(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var pocket = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">fun main(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        bi.let {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                println(it.pocket)</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">②run函数，指定了receiver，返回lambda表达式的return：</p> 
<p style="margin-left:.0001pt;text-align:left;">class Bi(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var pocket = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">fun main(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        bi.run{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                println(run.pocket)</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">③also函数，默认指定it，返回Unit：</p> 
<p style="margin-left:.0001pt;text-align:left;">class Bi(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var pocket = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">fun main(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        bi.also {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                it.pocket = 5</p> 
<p style="margin-left:.0001pt;text-align:left;">                println("also打印的结果是${it.pocket}")</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">④apply函数，指定了receiver，返回Unit：</p> 
<p style="margin-left:.0001pt;text-align:left;">class Bi(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        var pocket = 0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">fun main(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        bi.apply {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                this.pocket = 7</p> 
<p style="margin-left:.0001pt;text-align:left;">                println("apply打印的结果是${this.pocket}")</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">⑤use函数，默认是it，返回的是lambda表达式的返回值</p> 
<p style="margin-left:.0001pt;text-align:left;">use函数可以自动关闭资源：</p> 
<p style="margin-left:.0001pt;text-align:left;">fun main() {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        val file = File("example.txt")</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">        // 使用 use 读取文件内容</p> 
<p style="margin-left:.0001pt;text-align:left;">        file.bufferedReader().use { reader -&gt;    //默认是it，这里进行了更改为reader</p> 
<p style="margin-left:.0001pt;text-align:left;">        val content = reader.readText()</p> 
<p style="margin-left:.0001pt;text-align:left;">        println(content)</p> 
<p style="margin-left:.0001pt;text-align:left;">        }</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<h4 style="margin-left:.0001pt;text-align:center;">集合的变化和序列</h4> 
<p style="margin-left:.0001pt;text-align:left;">集合的映射操作：filter、map、flatMap</p> 
<p style="margin-left:.0001pt;text-align:left;">①filter的使用有两种，一种是饿汉式，另外一种懒汉列</p> 
<p style="margin-left:.0001pt;text-align:left;">饿汉式：</p> 
<p style="margin-left:.0001pt;text-align:left;">val lo = listOf&lt;Int&gt;(1,2,3)</p> 
<p style="margin-left:.0001pt;text-align:left;">lo.filter {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println("饿汉式会立即执行${it}")     //立即执行，打印结果</p> 
<p style="margin-left:.0001pt;text-align:left;">        it%2 ==0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">懒汉式：</p> 
<p style="margin-left:.0001pt;text-align:left;">lo.asSequence().filter {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println("懒汉式不会立即执行${it}")   //不会立即执行</p> 
<p style="margin-left:.0001pt;text-align:left;">        it%2 ==0</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">懒汉式不会立即执行，需要显式调用获取结果。</p> 
<p style="margin-left:.0001pt;text-align:left;">②map，会把元素映射成元素。</p> 
<p style="margin-left:.0001pt;text-align:left;">在map的使用过程中，也会分为饿汉式和懒汉式。</p> 
<p style="margin-left:.0001pt;text-align:left;">饿汉式：</p> 
<p style="margin-left:.0001pt;text-align:left;">lo.map {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println("饿汉式执行map的结果为${it}")  //饿汉式，输出的是元素</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">懒汉式：</p> 
<p style="margin-left:.0001pt;text-align:left;">lo.asSequence().map(){<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println("懒汉式执行map的结果为${it}")  //不会立即执行</p> 
<p style="margin-left:.0001pt;text-align:left;">}.toList()</p> 
<p style="margin-left:.0001pt;text-align:left;">不会立即执行打印，会在显示调用，也就是toList()后，再执行里面的打印。</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">③flatMap，会把元素映射成集合，并且返回调用的类型。</p> 
<p style="margin-left:.0001pt;text-align:left;">饿汉式：</p> 
<p style="margin-left:.0001pt;text-align:left;">val lo = listOf&lt;Int&gt;(1,2,3)</p> 
<p style="margin-left:.0001pt;text-align:left;">val fm = lo.flatMap {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        0 until it</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">println(fm)   //立即调用，执行的结果是[0,0,1,0,1,2 ]</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">懒汉式：</p> 
<p style="margin-left:.0001pt;text-align:left;">val fma = lo.asSequence().flatMap {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">        println(it)</p> 
<p style="margin-left:.0001pt;text-align:left;">        (0 until it).asSequence()</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">}.joinToString()    //通过joinToString显式调用</p> 
<p style="margin-left:.0001pt;text-align:left;">println(fma.toString())</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">④fold函数：</p> 
<p style="margin-left:.0001pt;text-align:left;">val numbers = listOf(1, 2, 3, 4, 5)</p> 
<p style="margin-left:.0001pt;text-align:left;">    val sum = numbers.fold(0) { acc, number -&gt;      //初始化值 0.   0第一次会给到acc</p> 
<p style="margin-left:.0001pt;text-align:left;">        acc + number                      //acc 和number可以变化，number会逐个取值。</p> 
<p style="margin-left:.0001pt;text-align:left;">0+1=1 算完一次后，会把结果给acc，再进行下次计算</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;">println(sum) // 输出: 15</p> 
<h4 style="margin-left:.0001pt;text-align:center;">SAM转换和匿名内部类</h4> 
<ol><li style="text-align:left;">匿名内部类：</li></ol> 
<p style="margin-left:.0001pt;text-align:left;">interface  A{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">    fun a(){}</p> 
<p style="margin-left:.0001pt;text-align:left;">}</p> 
<p style="margin-left:.0001pt;text-align:left;"></p> 
<p style="margin-left:.0001pt;text-align:left;">val ascasv = object : A{<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                    override fun a() {<!-- --></p> 
<p style="margin-left:.0001pt;text-align:left;">                     println("")</p> 
<p style="margin-left:.0001pt;text-align:left;">                    }</p> 
<p style="margin-left:.0001pt;text-align:left;">           }</p> 
<ol><li style="text-align:left;">kotlin中的SAM：</li></ol> 
<p style="margin-left:.0001pt;text-align:left;">与java中的SAM不一样，kotlin只是支持SAM的调用，返回的是一个函数。</p> 
<p style="margin-left:.0001pt;text-align:left;">Java中的SAM返回的是一个确定的对象。</p> 
<p style="margin-left:.0001pt;text-align:left;">所以在类似于监听的时候，需要指的类型：</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" height="615" src="https://images2.imgbox.com/fb/92/6eTTJHtS_o.png" width="653"></p> 
<p style="margin-left:.0001pt;text-align:left;">也可以用简写：</p> 
<p style="margin-left:.0001pt;text-align:center;"><br><img alt="" src="https://images2.imgbox.com/b2/0f/zNyi9TkI_o.png"></p> 
<p style="margin-left:.0001pt;text-align:center;"></p> 
<p style="margin-left:.0001pt;text-align:left;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/42907f7fc305b6f30948449b725491b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">配置sublime的中的C&#43;&#43;编译器(.sublime-build)，实现C&#43;&#43;20</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7229746d08bb57292d22946c33793a48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构 | 哈希表】一文了解哈希表(散列表)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>