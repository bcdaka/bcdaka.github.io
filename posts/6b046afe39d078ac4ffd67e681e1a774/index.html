<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】条件变量及生产者消费者模型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6b046afe39d078ac4ffd67e681e1a774/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Linux】条件变量及生产者消费者模型">
  <meta property="og:description" content="为什么要将这两者放在一起进行呢？
主要是因为生产消费与条件变量关系密切，正好相辅相成。
目录 条件变量：条件变量的引出：条件变量的解释与接口：测试代码： 生产者消费者模型：概念：代码实现Blocking Queue：完整代码：测试结果：一些问题： 条件变量： 条件变量的引出： 我们假设有一个自习室，这个自习室每次只能有一个人进入（使用挂在自习室门前钥匙），其他的人都要排队（排队之前都去试图找钥匙）。
今天小A起了个大早去拿钥匙，一直学到中午，此时饿得受不了了，于是想出去吃饭，他就走到门前打算归还钥匙，可是刚挂到门前就后悔了，因为她不想排队那么久才能继续学习，于是又拿着钥匙将门打开，但是又很饿，就这样循环往复，自己没有得到知识，外面的人也只能干排队等待。
与之对应：
自习室就相当于临界资源，钥匙就是锁，当其中一个线程拿到锁就可以访问临界资源，其他的线程都陷入阻塞状态。
由于线程A继续访问临界资源已经没有意义，但是竞争锁的能力很强，因为距离自己很近，造成了其他线程饥饿问题。
虽然线程A这样做合法，但是不道德。
我们此时需要制定规则，保证过程具有一定顺序性，也就是同步。
而条件变量就是确保这个顺序性的！
条件变量的解释与接口： 我们知道了条件变量的作用，但是还是并不清楚条件变量是什么。
我们再来一个例子进行解释。
假设有一个游戏，一个蒙眼拿盘子中的苹果，一个睁眼将苹果放入盘子。
现在我们就可以对应一下了。
铃铛就是条件变量，他是一个队列，可以让线程进行等待
他的唤醒有两种策略，全部唤醒与单个唤醒。
我们也就可以对应一下条件变量的接口了。
有些接口与锁很类似。
其中init是条件变量初始化的函数，与锁一致。
signal与broadcast就是通知接口，signal是一次通知一个，boardcast就是全部通知
wait就是去铃铛下等待，也就是去条件变量下等待。
timedwait我们不管。
desory就是销毁条件。
关于这里还有一个细节，为什么条件变量要把锁业传入？
后面会进行解释。
测试代码： 我们目前可以浅浅的使用一下条件变量，熟悉一下接口。
我们现在要实现一个场景，
主要逻辑是先创建一批线程并进行管理，每个创建好的线程都去执行各自的任务，任务是个死循环，每次进入在条件变量下等待被唤醒。
#include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; const int N = 5; pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER; void *Run(void *args) { while (true) { pthread_mutex_lock(&amp;g_mutex); pthread_cond_wait(&amp;g_cond, &amp;g_mutex); std::cout &lt;&lt; &#34;i am new thread-&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T17:45:23+08:00">
    <meta property="article:modified_time" content="2024-07-23T17:45:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】条件变量及生产者消费者模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>为什么要将这两者放在一起进行呢？<br> 主要是因为生产消费与条件变量关系密切，正好相辅相成。</p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">条件变量：</a></li><li><ul><li><a href="#_5" rel="nofollow">条件变量的引出：</a></li><li><a href="#_17" rel="nofollow">条件变量的解释与接口：</a></li><li><a href="#_41" rel="nofollow">测试代码：</a></li></ul> 
  </li><li><a href="#_95" rel="nofollow">生产者消费者模型：</a></li><li><ul><li><a href="#_96" rel="nofollow">概念：</a></li><li><a href="#Blocking_Queue_127" rel="nofollow">代码实现Blocking Queue：</a></li><li><a href="#_275" rel="nofollow">完整代码：</a></li><li><a href="#_413" rel="nofollow">测试结果：</a></li><li><a href="#_419" rel="nofollow">一些问题：</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_4"></a>条件变量：</h2> 
<h3><a id="_5"></a>条件变量的引出：</h3> 
<p>我们假设有一个自习室，这个自习室每次只能有一个人进入（使用挂在自习室门前钥匙），其他的人都要排队（排队之前都去试图找钥匙）。</p> 
<p>今天小A起了个大早去拿钥匙，一直学到中午，此时饿得受不了了，于是想出去吃饭，他就走到门前打算归还钥匙，可是刚挂到门前就后悔了，因为她不想排队那么久才能继续学习，于是又拿着钥匙将门打开，但是又很饿，就这样循环往复，自己没有得到知识，外面的人也只能干排队等待。</p> 
<p>与之对应：<br> 自习室就相当于临界资源，钥匙就是锁，当其中一个线程拿到锁就可以访问临界资源，其他的线程都陷入阻塞状态。<br> 由于线程A继续访问临界资源已经没有意义，但是<code>竞争锁的能力</code>很强，因为距离自己很近，造成了其他线程<code>饥饿问题</code>。</p> 
<p>虽然线程A这样做合法，但是不道德。<br> 我们此时需要制定规则，保证过程具有一定顺序性，也就是同步。<br> 而条件变量就是确保这个顺序性的！</p> 
<h3><a id="_17"></a>条件变量的解释与接口：</h3> 
<p>我们知道了条件变量的作用，但是还是并不清楚条件变量是什么。</p> 
<p>我们再来一个例子进行解释。</p> 
<p>假设有一个游戏，一个蒙眼拿盘子中的苹果，一个睁眼将苹果放入盘子。</p> 
<p><img src="https://images2.imgbox.com/0c/e1/IsfsVe9I_o.png" alt="在这里插入图片描述"></p> 
<p>现在我们就可以对应一下了。<br> 铃铛就是条件变量，他是一个队列，可以让线程进行等待<br> 他的唤醒有两种策略，全部唤醒与单个唤醒。</p> 
<p>我们也就可以对应一下条件变量的接口了。<br> 有些接口与锁很类似。<br> <img src="https://images2.imgbox.com/6a/cb/AKFr6t4m_o.png" alt="在这里插入图片描述"><br> 其中init是条件变量初始化的函数，与锁一致。<br> signal与broadcast就是通知接口，signal是一次通知一个，boardcast就是全部通知<br> wait就是去铃铛下等待，也就是去条件变量下等待。<br> timedwait我们不管。<br> desory就是销毁条件。</p> 
<p>关于这里还有一个细节，为什么条件变量要把锁业传入？<br> 后面会进行解释。</p> 
<h3><a id="_41"></a>测试代码：</h3> 
<p>我们目前可以浅浅的使用一下条件变量，熟悉一下接口。</p> 
<p>我们现在要实现一个场景，<img src="https://images2.imgbox.com/11/64/4yFBBUXd_o.png" alt="在这里插入图片描述"><br> 主要逻辑是先创建一批线程并进行管理，每个创建好的线程都去执行各自的任务，任务是个死循环，每次进入在条件变量下等待被唤醒。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

pthread_mutex_t g_mutex <span class="token operator">=</span> PTHREAD_MUTEX_INITIALIZER<span class="token punctuation">;</span>
pthread_cond_t g_cond <span class="token operator">=</span> PTHREAD_COND_INITIALIZER<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>g_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>g_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>g_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am new thread-"</span> <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>g_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    pthread_t thds<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thds<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> Run<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 唤醒</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>g_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>val <span class="token operator">:</span> thds<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_join</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>现象：<br> <img src="https://images2.imgbox.com/3a/cd/yJvQxfDa_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_95"></a>生产者消费者模型：</h2> 
<h3><a id="_96"></a>概念：</h3> 
<p>条件变量暂时说到这里，我们先来谈一谈这个模型。</p> 
<p>我们依旧是拿具体场景进行解释：<br> 这是最简单的一个图示<br> <img src="https://images2.imgbox.com/9e/17/4R2ZgIVJ_o.png" alt="在这里插入图片描述"><br> 实际上，我们的生产者代表的就是供货商，超市是一块缓存，顾客就是消费者。</p> 
<p>这个模型有3大优点：</p> 
<ol><li>协调忙闲不均：<br> 当生产慢时而消费又多，我们就可以提前生产一批产品到超市；<br> 当生产快时而消费又慢，我们就可以提前让消费者来到超市；</li><li>效率高：<br> 你在买东西时，供应商在生产，达到了消费生产并发<br> 你在处理你买的东西时，供应商把商品放入超市，达到放入处理并发</li><li>解耦：<br> 生产者与消费者互不影响：比如一共有10个供货商，其中一个倒闭了，并不影响你买商品；当你吃泡面撒掉了，也不会影响供应商供货。</li></ol> 
<p>高度提炼一下可以简记为：1 2 3 原则。<br> 1：一个交易场所（一段内存空间）<br> 2：两种角色（生产角色，消费角色）<br> 3：三种关系（生产与生产，消费与消费，生产与消费）<br> 其中这三种关系分别为互斥，互斥，互斥&amp;&amp;同步。</p> 
<p>相信前两个都很好理解，第三个呢？</p> 
<p>比如供应商生产好商品还没录入数据就肯定不能被顾客拿走，这就是互斥。<br> 这就像你在写数据，还没写完就被读走了一样，他们之间也是需要互斥的。<br> 同样，如果超市没货了，我们要要依靠超市通知供应商，等有货了在反过来通知顾客。这就是同步。</p> 
<h3><a id="Blocking_Queue_127"></a>代码实现Blocking Queue：</h3> 
<p>为什么写单对单？因为他简单！为什么不吃牛，因为他善！<img src="https://images2.imgbox.com/f3/4e/7qNtueRw_o.png" alt="在这里插入图片描述"><br> 不过为什么单对单简单，因为我们的1 2 3原则中有三个关系，生产与生产，消费与消费，生产与消费，单对单就不需要考虑前两种，自然而言的简单了许多。<br> 这里我们要解决一个历史问题：为什么wait要传入锁？</p> 
<p>在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者和消费者模型的数据结构。<br> 其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；<br> 当队列满时，往队列里存放元素的操作也会被阻塞，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)<br> <img src="https://images2.imgbox.com/b1/ce/dZeeGxc5_o.png" alt="在这里插入图片描述"></p> 
<p>那么我们现在就要有一个大概的轮廓：</p> 
<p>生产者一直写，消费者一直读即可，很基础的框架，有了框架我们就知道如何下手实现主要功能了。</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"BlockingQueue.hpp"</span></span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">Consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BlockingQueue <span class="token operator">*</span>bq <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span>BlockingQueue<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 接收数据</span>

        bp<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 处理数据</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">Producer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BlockingQueue <span class="token operator">*</span>bq <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span>BlockingQueue<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 构建数据</span>

        bp<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BlockingQueue pc<span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> Producer<span class="token punctuation">,</span> static_cast<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> Consumer<span class="token punctuation">,</span> static_cast<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这是我们的阻塞队列，里面有对于一些点的详细注释，<br> 比如cond为什么要传入锁？唤醒在哪个位置进行唤醒？<br> 而又因为我们也不确定用户使用的是什么类型，设计为模板即可。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BlockingQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_cap</span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 所以这里的wait为什么要传锁就一目了然了</span>
            <span class="token comment">// 因为如果你带着锁去wait，那么别的线程只会一直阻塞，不会拿到锁</span>
            <span class="token comment">// 所以wait还要进行解锁，等被唤醒在继续抢锁。</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 出来了就代表肯定不是满的，此时push数据即可。</span>
        _q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 注意这里的唤醒放在解锁的上或下都可以，当放在下时，我们还是以单对单为例</span>
        <span class="token comment">// 假设我们此时队列中还没有数据，消费者在wait中解锁阻塞，生产者生产完数据进行解锁再唤醒消费者，</span>
        <span class="token comment">// 而这时消费者会和生产者再次抢锁，因为消费者会从wait中被唤醒需要抢锁，而生产者在lock中抢锁。</span>
        <span class="token comment">// 如果消费者抢到了就罢了，直接进行写入数据；但是如果生产者抢到了，那就继续生产数据，</span>
        <span class="token comment">// 我们假设生产者一直将队列写满，那么他就会在wait中进行阻塞，让消费者写入数据在解锁唤醒。</span>
        <span class="token comment">// 同理，实际上因为锁的钳制，在解锁前或后唤醒都是可以的</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">Pop</span><span class="token punctuation">(</span>T <span class="token operator">*</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 出来了就代表此时数据肯定不为空，可以写给消费者了。</span>
        <span class="token operator">*</span>val <span class="token operator">=</span> _q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">BlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">IsFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _cap <span class="token operator">==</span> _q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">bool</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _cap<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> _q<span class="token punctuation">;</span>
    pthread_mutex_t _mutex<span class="token punctuation">;</span>
    pthread_cond_t _cond_p<span class="token punctuation">;</span>
    pthread_cond_t _cond_c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>但是这里还有一个细节，我们判断空或满时使用了if，这在某些情况下是会出问题的。</p> 
<p>比如当前队列中没有数据。<br> 有一个生产者，两个消费者。<br> 当生产者刚刚生产完，进行了broadcast唤醒，导致两个消费者线程都被唤醒我们假设生产者此时不会抢到锁，所以目前只会有一个消费者线程抢到锁，当其中一个A抢到后，进行写入数据并pop，这都是没有问题的，但是如果A解锁后被另一个消费者B抢到，那么B又会继续写入并进行pop。<br> 问题就出现了，因为唯一的一个数据已经被A拿走了，此时就会出现err，所以我们要对<code>if进行一下修改，改为while</code>，这样就避免了因为B抢到锁而继续pop造成的err。</p> 
<h3><a id="_275"></a>完整代码：</h3> 
<pre><code class="prism language-cpp">
```cpp
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BlockingQueue</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">BlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_cap</span><span class="token punctuation">(</span>cap<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">IsFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 所以这里的wait为什么要传锁就一目了然了</span>
            <span class="token comment">// 因为如果你带着锁去wait，那么别的线程只会一直阻塞，不会拿到锁</span>
            <span class="token comment">// 所以wait还要进行解锁，等被唤醒在继续抢锁。</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 出来了就代表肯定不是满的，此时push数据即可。</span>
        _q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 注意这里的唤醒放在解锁的上或下都可以，当放在下时，我们还是以单对单为例</span>
        <span class="token comment">// 假设我们此时队列中还没有数据，消费者在wait中解锁阻塞，生产者生产完数据进行解锁再唤醒消费者，</span>
        <span class="token comment">// 而这时消费者会和生产者再次抢锁，因为消费者会从wait中被唤醒需要抢锁，而生产者在lock中抢锁。</span>
        <span class="token comment">// 如果消费者抢到了就罢了，直接进行写入数据；但是如果生产者抢到了，那就继续生产数据，</span>
        <span class="token comment">// 我们假设生产者一直将队列写满，那么他就会在wait中进行阻塞，让消费者写入数据在解锁唤醒。</span>
        <span class="token comment">// 同理，实际上因为锁的钳制，在解锁前或后唤醒都是可以的</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">Pop</span><span class="token punctuation">(</span>T <span class="token operator">*</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 出来了就代表此时数据肯定不为空，可以写给消费者了。</span>
        <span class="token operator">*</span>val <span class="token operator">=</span> _q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        _q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">BlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_cond_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">IsFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _cap <span class="token operator">==</span> _q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">bool</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> _q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _cap<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> _q<span class="token punctuation">;</span>
    pthread_mutex_t _mutex<span class="token punctuation">;</span>
    pthread_cond_t _cond_p<span class="token punctuation">;</span>
    pthread_cond_t _cond_c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>main函数代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"BlockingQueue.hpp"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;random&gt;</span></span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">Consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BlockingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">*</span>bq <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>BlockingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 接收数据</span>
        <span class="token keyword">int</span> val<span class="token punctuation">;</span>
        bq<span class="token operator">-&gt;</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 处理数据</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Consumer receive a data: "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">Producer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BlockingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">*</span>bq <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>BlockingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 构建数据</span>
        <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// [1, 10]</span>
        bq<span class="token operator">-&gt;</span><span class="token function">Push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Producer produce a data: "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BlockingQueue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pc<span class="token punctuation">;</span>
    pthread_t t1<span class="token punctuation">,</span> t2<span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> Producer<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> Consumer<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_413"></a>测试结果：</h3> 
<p><img src="https://images2.imgbox.com/f6/b1/oSoYxrif_o.png" alt="在这里插入图片描述"><br> 观察到生产者生产顺序为1 9 6 6 6…而消费者也正好是1 9 6 6 6…</p> 
<p>注意：我们的生产者消费者不仅仅只能传递最简单的内置类型，也可以进行传递自定义类型！可调用对象也是可以的！</p> 
<h3><a id="_419"></a>一些问题：</h3> 
<p>我们的多生产多消费不需要修改代码，因为锁已经帮我们搞定了生产与生产，消费与消费之间的关系。</p> 
<p>为什么明明一次只能有一个线程访问队列，但还是说生产消费模型效率高？<br> 因为我们不能只关注生产与消费在缓存的时间！<br> 我们的生产任务或数据需要时间，处理任务或数据需要时间。<br> 也就是说：当其中一个生产者在放任务，其他的生产者在生产任务；<br> 其中一个消费者在拿任务，其他消费者在处理任务。<br> 这种并发才让我们的效率变高!</p> 
<p>为什么要在锁之后再进行条件变量wait？<br> 这是因为我们push或pop之前一定会临街资源，临界资源一定是被锁保护起来的，所以设计者才会这样设计接口，我们也才要这样使用。</p> 
<p>完~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4fab37cc8bd24243d393a1547add5ac8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Coolmuster Android Assistant: 手机数据管理的全能助手</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ee9ff9a6719fe102fd05eb8f3742149/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">剖析 Kafka 消息丢失的原因</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>