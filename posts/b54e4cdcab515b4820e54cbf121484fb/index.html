<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【SpringCloud】负载均衡 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b54e4cdcab515b4820e54cbf121484fb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【SpringCloud】负载均衡">
  <meta property="og:description" content="目录 负载均衡什么是负载均衡生活场景为什么需要负载均衡负载均衡手段负载均衡总的来说有两种实现手段负载均衡具体可以通过多种手段来实现 SpringCloud中的负载均衡组件Ribbon VS Nginx负载均衡区别集中式LB进程内LB RibbonRibbon的工作原理Ribbon在工作时分成两步 使用1.提供者集群2.引入依赖4.测试 Ribbon的负载均衡策略核心组件轮询随机代码案例 权重代码案例 最小连接数代码案例 重试代码案例 可用性敏感策略代码案例 区域敏感策略代码案例 总结 负载均衡 什么是负载均衡 负载均衡（Load Balancing）是指在分布式系统中，将工作负载（Workload）平均分配给多个服务器或计算机资源，以提高系统的性能、可靠性和可扩展性。
生活场景 我们在日常生活中经常免不了要去一些比较拥挤的地方，比如地铁站、火车站、电影院、银行等。无论是买票，还是排队入场，这些场所一般都会设置多个服务点或者入口的。如果没有人引导的话，大多数情况下，最近的入口会挤满人。而哪些距离较远的服务点或者入口就宽松很多。
这种情况下，就会大大浪费资源，因为如果可以把这些排队的人很好的分散到各个入口的话会大大缩短排队时间。其实，软件的建设也是一样的。为了提升系统的服务能力，很多网站采用集群部署，就像话剧院有多个入口一样。这时候，就需要一个协调者，来均衡的分配这些用户的请求，可以让用户的可以均匀的分派到不同的服务器上。 为什么需要负载均衡 负载均衡是一种分配和管理网络流量的技术，主要用于确保网络服务的高可用性、可扩展性和性能优化。以下是需要负载均衡的主要原因：
高可用性：负载均衡可以将流量分配到多个服务器上，当其中一台服务器发生故障时，流量会自动转移到其他正常工作的服务器上，从而确保服务的连续性和可用性。
扩展性：负载均衡可以将流量分布到多个服务器上，允许系统根据需要动态地添加或删除服务器。这样可以更好地应对流量的增长和业务的扩展。
性能优化：负载均衡可以根据服务器的负载情况将流量分配到最空闲或最适合处理当前请求的服务器上，从而提高系统的响应速度和吞吐量。
故障恢复：当一台服务器发生故障时，负载均衡可以自动将流量转移到其他正常工作的服务器上，从而实现快速的故障恢复，减少服务中断时间。
节约成本：通过负载均衡，可以充分利用服务器的资源，提高服务器的利用率，从而减少不必要的硬件投入和维护成本。
总的来说，负载均衡是一种提高系统性能、可用性和可扩展性的重要技术，适用于各种网络应用和服务。
负载均衡手段 负载均衡总的来说有两种实现手段 一种是服务端负载均衡器，另一种是客户端负载均衡器
服务端负载均衡器的问题是，它提供了更强的流量控制权，但无法满足不同的消费者希望使用不同负载均衡策略的需求，而使用不同负载均衡策略的场景确实是存在的，所以客户端负载均衡就提供了这种灵活性。客户端负载均衡也有其缺点，如果配置不当，可能会导致服务提供者出现热点，或者压根就拿不到任何服务的情况服务端负载均衡器和客户端负载均衡器的区别如下图所示
客户端负载均衡器的实现原理是通过注册中心，如 Nacos，将可用的服务列表拉取到本地（客户端），再通过客户端负载均衡器（设置的负载均衡策略）获取到某个服务器的具体 ip 和端口，然后再通过 Http 框架请求服务并得到结果，其执行流程如下图所示：
负载均衡具体可以通过多种手段来实现 以下是一些常见的负载均衡手段：
基于DNS的负载均衡：通过使用DNS来将流量分布到不同的服务器上。在DNS解析请求时，返回多个服务器的IP地址，客户端根据返回的IP地址选择一个服务器进行连接。
集中式负载均衡：使用专门的负载均衡设备（如负载均衡器或负载均衡服务器）来分发流量。这些设备通常位于服务器和客户端之间，根据特定的算法将流量分配到不同的服务器上。
分布式负载均衡：将负载均衡的功能分散到多个服务器上，每个服务器都负责分发一部分的流量。这种方式可以提高系统的扩展性和容错性。
会话保持（Session Affinity）：某些应用需要保持与特定服务器的会话状态，这需要负载均衡器将同一用户的请求始终分发到同一台服务器上，以保证会话的连续性。
基于内容的负载均衡：根据请求的内容或URL等特征来进行负载均衡。例如，可以根据请求的路径将静态资源请求分发到专门处理静态资源的服务器。
哈希负载均衡：根据客户端请求的特征（如IP地址、用户标识等）计算哈希值，将相同哈希值的请求定向到同一台服务器上。这可以保证相同请求始终分发到同一台服务器上。
需要注意的是，不同的负载均衡手段适用于不同的场景和需求，需要根据具体的应用和系统来选择合适的负载均衡策略。
SpringCloud中的负载均衡组件 在spring cloud H版大部分使用的负载均衡组件就是Ribbon和OpenFegin而在spring cloud跟新后官方宣布在 SpringCloud 2020版本以后 SpringCloud剔除掉了 除了eureka-server与 eureka-client 除外的所有 Netflix组件，spring也给出了使用spring cloud Loadbalancer替代的方案但就在目前，Ribbon以及OpenFegin仍然是主流的负载均衡的方案 Ribbon VS Nginx负载均衡区别 Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后由Nginx实现转发请求。即负载均衡是由服务端实现的。Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。 集中式LB 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方； 进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。 Ribbon Ribbon 是 Spring Cloud 技术栈中非常重要的基础框架，它为 Spring Cloud 提供了负载均衡的能力比如 Fegin 和 OpenFegin 都是基于 Ribbon 实现的，就连 Nacos 中的负载均衡也使用了 Ribbon 框架。Ribbon 框架的强大之处在于，它不仅内置了 7 种负载均衡策略，同时还支持用户自定义负载均衡策略，所以其开放性和便利性也是它得以流行的主要原因。 简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T15:29:54+08:00">
    <meta property="article:modified_time" content="2024-05-27T15:29:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SpringCloud】负载均衡</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">负载均衡</a></li><li><ul><li><a href="#_2" rel="nofollow">什么是负载均衡</a></li><li><a href="#_5" rel="nofollow">生活场景</a></li><li><a href="#_13" rel="nofollow">为什么需要负载均衡</a></li><li><a href="#_27" rel="nofollow">负载均衡手段</a></li><li><ul><li><a href="#_28" rel="nofollow">负载均衡总的来说有两种实现手段</a></li><li><a href="#_39" rel="nofollow">负载均衡具体可以通过多种手段来实现</a></li></ul> 
   </li><li><a href="#SpringCloud_59" rel="nofollow">SpringCloud中的负载均衡组件</a></li><li><ul><li><a href="#Ribbon_VS_Nginx_63" rel="nofollow">Ribbon VS Nginx负载均衡区别</a></li><li><ul><li><a href="#LB_66" rel="nofollow">集中式LB</a></li><li><a href="#LB_68" rel="nofollow">进程内LB</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#Ribbon_75" rel="nofollow">Ribbon</a></li><li><ul><li><a href="#Ribbon_84" rel="nofollow">Ribbon的工作原理</a></li><li><ul><li><a href="#Ribbon_86" rel="nofollow">Ribbon在工作时分成两步</a></li></ul> 
   </li><li><a href="#_90" rel="nofollow">使用</a></li><li><ul><li><a href="#1_91" rel="nofollow">1.提供者集群</a></li><li><a href="#2_95" rel="nofollow">2.引入依赖</a></li><li><a href="#4_107" rel="nofollow">4.测试</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Ribbon_110" rel="nofollow">Ribbon的负载均衡策略</a></li><li><ul><li><a href="#_111" rel="nofollow">核心组件</a></li><li><a href="#_116" rel="nofollow">轮询</a></li><li><a href="#_120" rel="nofollow">随机</a></li><li><ul><li><a href="#_122" rel="nofollow">代码案例</a></li></ul> 
   </li><li><a href="#_138" rel="nofollow">权重</a></li><li><ul><li><a href="#_141" rel="nofollow">代码案例</a></li></ul> 
   </li><li><a href="#_155" rel="nofollow">最小连接数</a></li><li><ul><li><a href="#_158" rel="nofollow">代码案例</a></li></ul> 
   </li><li><a href="#_172" rel="nofollow">重试</a></li><li><ul><li><a href="#_175" rel="nofollow">代码案例</a></li></ul> 
   </li><li><a href="#_196" rel="nofollow">可用性敏感策略</a></li><li><ul><li><a href="#_198" rel="nofollow">代码案例</a></li></ul> 
   </li><li><a href="#_213" rel="nofollow">区域敏感策略</a></li><li><ul><li><a href="#_215" rel="nofollow">代码案例</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_231" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>负载均衡</h2> 
<h3><a id="_2"></a>什么是负载均衡</h3> 
<ul><li>负载均衡（Load Balancing）是指在分布式系统中，将工作负载（Workload）平均分配给多个服务器或计算机资源，以提高系统的性能、可靠性和可扩展性。<br> <img src="https://images2.imgbox.com/9a/fc/SWgaeTKs_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="_5"></a>生活场景</h3> 
<ul><li>我们在日常生活中经常免不了要去一些比较拥挤的地方，比如地铁站、火车站、电影院、银行等。无论是买票，还是排队入场，这些场所一般都会设置多个服务点或者入口的。如果没有人引导的话，大多数情况下，最近的入口会挤满人。而哪些距离较远的服务点或者入口就宽松很多。<br> <img src="https://images2.imgbox.com/fa/2b/GJEir4Nr_o.png" alt="在这里插入图片描述"></li><li>这种情况下，就会大大浪费资源，因为如果可以把这些排队的人很好的分散到各个入口的话会大大缩短排队时间。其实，软件的建设也是一样的。为了提升系统的服务能力，很多网站采用集群部署，就像话剧院有多个入口一样。这时候，就需要一个协调者，来均衡的分配这些用户的请求，可以让用户的可以均匀的分派到不同的服务器上。</li></ul> 
<p><img src="https://images2.imgbox.com/f1/7e/jxFQvppw_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_13"></a>为什么需要负载均衡</h3> 
<p>负载均衡是一种分配和管理网络流量的技术，主要用于确保网络服务的高可用性、可扩展性和性能优化。以下是需要负载均衡的主要原因：</p> 
<ol><li> <p>高可用性：负载均衡可以将流量分配到多个服务器上，当其中一台服务器发生故障时，流量会自动转移到其他正常工作的服务器上，从而确保服务的连续性和可用性。</p> </li><li> <p>扩展性：负载均衡可以将流量分布到多个服务器上，允许系统根据需要动态地添加或删除服务器。这样可以更好地应对流量的增长和业务的扩展。</p> </li><li> <p>性能优化：负载均衡可以根据服务器的负载情况将流量分配到最空闲或最适合处理当前请求的服务器上，从而提高系统的响应速度和吞吐量。</p> </li><li> <p>故障恢复：当一台服务器发生故障时，负载均衡可以自动将流量转移到其他正常工作的服务器上，从而实现快速的故障恢复，减少服务中断时间。</p> </li><li> <p>节约成本：通过负载均衡，可以充分利用服务器的资源，提高服务器的利用率，从而减少不必要的硬件投入和维护成本。</p> </li></ol> 
<p>总的来说，负载均衡是一种提高系统性能、可用性和可扩展性的重要技术，适用于各种网络应用和服务。</p> 
<h3><a id="_27"></a>负载均衡手段</h3> 
<h4><a id="_28"></a>负载均衡总的来说有两种实现手段</h4> 
<p>一种是服务端负载均衡器，另一种是客户端负载均衡器</p> 
<ul><li>服务端负载均衡器的问题是，它提供了更强的流量控制权，但无法满足不同的消费者希望使用不同负载均衡策略的需求，而使用不同负载均衡策略的场景确实是存在的，所以客户端负载均衡就提供了这种灵活性。</li><li>客户端负载均衡也有其缺点，如果配置不当，可能会导致服务提供者出现热点，或者压根就拿不到任何服务的情况</li><li>服务端负载均衡器和客户端负载均衡器的区别如下图所示<br> <img src="https://images2.imgbox.com/2c/0f/7cpqOFRc_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/65/a2/6pXQxezR_o.png" alt="在这里插入图片描述"></li><li>客户端负载均衡器的实现原理是通过注册中心，如 Nacos，将可用的服务列表拉取到本地（客户端），再通过客户端负载均衡器（设置的负载均衡策略）获取到某个服务器的具体 ip 和端口，然后再通过 Http 框架请求服务并得到结果，其执行流程如下图所示：<br> <img src="https://images2.imgbox.com/75/37/4jBep2A2_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="_39"></a>负载均衡具体可以通过多种手段来实现</h4> 
<p>以下是一些常见的负载均衡手段：</p> 
<ol><li> <p>基于DNS的负载均衡：通过使用DNS来将流量分布到不同的服务器上。在DNS解析请求时，返回多个服务器的IP地址，客户端根据返回的IP地址选择一个服务器进行连接。</p> </li><li> <p>集中式负载均衡：使用专门的负载均衡设备（如负载均衡器或负载均衡服务器）来分发流量。这些设备通常位于服务器和客户端之间，根据特定的算法将流量分配到不同的服务器上。</p> </li><li> <p>分布式负载均衡：将负载均衡的功能分散到多个服务器上，每个服务器都负责分发一部分的流量。这种方式可以提高系统的扩展性和容错性。</p> </li><li> <p>会话保持（Session Affinity）：某些应用需要保持与特定服务器的会话状态，这需要负载均衡器将同一用户的请求始终分发到同一台服务器上，以保证会话的连续性。</p> </li><li> <p>基于内容的负载均衡：根据请求的内容或URL等特征来进行负载均衡。例如，可以根据请求的路径将静态资源请求分发到专门处理静态资源的服务器。</p> </li><li> <p>哈希负载均衡：根据客户端请求的特征（如IP地址、用户标识等）计算哈希值，将相同哈希值的请求定向到同一台服务器上。这可以保证相同请求始终分发到同一台服务器上。</p> </li></ol> 
<p>需要注意的是，不同的负载均衡手段适用于不同的场景和需求，需要根据具体的应用和系统来选择合适的负载均衡策略。</p> 
<h3><a id="SpringCloud_59"></a>SpringCloud中的负载均衡组件</h3> 
<ul><li>在spring cloud H版大部分使用的负载均衡组件就是Ribbon和OpenFegin</li><li>而在spring cloud跟新后官方宣布在 SpringCloud 2020版本以后 SpringCloud剔除掉了 除了eureka-server与 eureka-client 除外的所有 Netflix组件，spring也给出了使用spring cloud Loadbalancer替代的方案</li><li>但就在目前，Ribbon以及OpenFegin仍然是主流的负载均衡的方案</li></ul> 
<h4><a id="Ribbon_VS_Nginx_63"></a>Ribbon VS Nginx负载均衡区别</h4> 
<ul><li>Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后由Nginx实现转发请求。即负载均衡是由服务端实现的。</li><li>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</li></ul> 
<h5><a id="LB_66"></a>集中式LB</h5> 
<ul><li>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；</li></ul> 
<h5><a id="LB_68"></a>进程内LB</h5> 
<ul><li>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</li><li>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</li></ul> 
<p><img src="https://images2.imgbox.com/5b/51/fPRhmivG_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/a0/5c/j8wnTKZQ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Ribbon_75"></a>Ribbon</h2> 
<ul><li>Ribbon 是 Spring Cloud 技术栈中非常重要的基础框架，它为 Spring Cloud 提供了负载均衡的能力</li><li>比如 Fegin 和 OpenFegin 都是基于 Ribbon 实现的，就连 Nacos 中的负载均衡也使用了 Ribbon 框架。</li><li>Ribbon 框架的强大之处在于，它不仅内置了 7 种负载均衡策略，同时还支持用户自定义负载均衡策略，所以其开放性和便利性也是它得以流行的主要原因。</li></ul> 
<p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。</p> 
<ul><li>Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。</li><li>简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。</li><li>我们很容易使用Ribbon实现自定义的负载均衡算法。</li></ul> 
<h3><a id="Ribbon_84"></a>Ribbon的工作原理</h3> 
<p><img src="https://images2.imgbox.com/67/8a/lvThOETs_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Ribbon_86"></a>Ribbon在工作时分成两步</h4> 
<ul><li>第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server.</li><li>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</li><li>其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。</li></ul> 
<h3><a id="_90"></a>使用</h3> 
<h4><a id="1_91"></a>1.提供者集群</h4> 
<p>复制几个demo-user-provider服务，只需要保证端口不一致就可以，其他配置一致，尤其是服务名称必须要一致，因为对于注册中心而言，多个demo-user-provider服务实例的作用都是一样的，就像是在食堂打饭，多个窗口的饭是一样的，就是多个实例，但是都同属于一个服务<br> <img src="https://images2.imgbox.com/f5/56/4P5NWjxb_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_95"></a>2.引入依赖</h4> 
<ul><li>其实引入了Eureka的坐标即可，<code>spring-cloud-starter-netflix-eureka-client</code>自带了<code>spring-cloud-starter-ribbon</code>引用</li></ul> 
<pre><code class="prism language-xml">      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7a/b2/HMIihV5m_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="4_107"></a>4.测试</h4> 
<p>访问：<code>localhost:8084/consumer/doLogin</code><br> <img src="https://images2.imgbox.com/17/c4/9zoiswhw_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Ribbon_110"></a>Ribbon的负载均衡策略</h2> 
<h3><a id="_111"></a>核心组件</h3> 
<ul><li>根据特定算法中从服务列表中选取一个要访问的服务</li><li>通过在容器中注入这个接口的不同实现类就可以实现不同的负载均很算法<br> <img src="https://images2.imgbox.com/fb/c4/TOEWnpQY_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="_116"></a>轮询</h3> 
<ul><li>由上图可知，Ribbon 默认的负载均衡策略是轮询模式</li><li>轮询策略：RoundRobinRule，按照一定的顺序依次调用服务实例。</li><li>比如一共有 3 个服务，第一次调用服务 1，第二次调用服务 2，第三次调用服务3，依次类推</li></ul> 
<h3><a id="_120"></a>随机</h3> 
<ul><li>随机策略：RandomRule，从服务提供者的列表中随机选择一个服务实例</li></ul> 
<h4><a id="_122"></a>代码案例</h4> 
<p>添加配置类</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回随机策略的Bean</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>再访问：<br> <img src="https://images2.imgbox.com/53/82/CV9j35ps_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_138"></a>权重</h3> 
<ul><li>权重策略：WeightedResponseTimeRule，根据每个服务提供者的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性也就越低。</li><li>它的实现原理是，刚开始使用轮询策略并开启一个计时器，每一段时间收集一次所有服务提供者的平均响应时间，然后再给每个服务提供者附上一个权重，权重越高被选中的概率也越大</li></ul> 
<h4><a id="_141"></a>代码案例</h4> 
<p>配置类</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//return new RandomRule(); // 返回随机策略的Bean</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WeightedResponseTimeRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回权重策略的Bean</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_155"></a>最小连接数</h3> 
<ul><li>最小连接数策略：BestAvailableRule，也叫最小并发数策略，它是遍历服务提供者列表，选取连接数最小的⼀个服务实例。</li><li>如果有相同的最小连接数，那么会调用轮询策略进行选取</li></ul> 
<h4><a id="_158"></a>代码案例</h4> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//return new RandomRule(); // 返回随机策略的Bean</span>
        <span class="token comment">//return new WeightedResponseTimeRule(); // 返回权重策略的Bean</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BestAvailableRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回最小连接数策略的Bean</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_172"></a>重试</h3> 
<ul><li>重试策略：RetryRule，按照轮询策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试来获取服务</li><li>如果超过指定时间依然没获取到服务实例则返回 null</li></ul> 
<h4><a id="_175"></a>代码案例</h4> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonConfiguration</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IClientConfig</span> <span class="token function">ribbonClientConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">DefaultClientConfigImpl</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultClientConfigImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> config<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token class-name">IClientConfig</span> config<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//return new RandomRule(); // 返回随机策略的Bean</span>
        <span class="token comment">//return new WeightedResponseTimeRule(); // 返回权重策略的Bean</span>
        config<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token class-name">IClientConfigKey<span class="token punctuation">.</span>Keys<span class="token punctuation">.</span>ConnectTimeout</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置连接超时为2000毫秒</span>
        config<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token class-name">IClientConfigKey<span class="token punctuation">.</span>Keys<span class="token punctuation">.</span>ReadTimeout</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置读取超时为5000毫秒</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BestAvailableRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回最小连接数策略的Bean</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_196"></a>可用性敏感策略</h3> 
<ul><li>可用敏感性策略：AvailabilityFilteringRule，先过滤掉非健康的服务实例，然后再选择连接数较小的服务实例</li></ul> 
<h4><a id="_198"></a>代码案例</h4> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token class-name">IClientConfig</span> config<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//return new RandomRule(); // 返回随机策略的Bean</span>
        <span class="token comment">//return new WeightedResponseTimeRule(); // 返回权重策略的Bean</span>
        <span class="token comment">//return new BestAvailableRule(); // 返回最小连接数策略的Bean</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AvailabilityFilteringRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回可用性敏感策略的Bean</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_213"></a>区域敏感策略</h3> 
<ul><li>区域敏感策略：ZoneAvoidanceRule，根据服务所在区域（zone）的性能和服务的可用性来选择服务实例，在没有区域的环境下，该策略和轮询策略类似。</li></ul> 
<h4><a id="_215"></a>代码案例</h4> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RibbonConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token class-name">IClientConfig</span> config<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//return new RandomRule(); // 返回随机策略的Bean</span>
        <span class="token comment">//return new WeightedResponseTimeRule(); // 返回权重策略的Bean</span>
        <span class="token comment">//return new BestAvailableRule(); // 返回最小连接数策略的Bean</span>
        <span class="token comment">//return new AvailabilityFilteringRule(); // 返回可用性敏感策略的Bean</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ZoneAvoidanceRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回区域敏感策略的Bean</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_231"></a>总结</h2> 
<table><thead><tr><th align="left">类 型</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">WeightedResponseTimeRule</td><td align="left"><strong>权重</strong>：根据响应时间分配一个weight（权重），响应时间越长，weight越小，被选中的可能性越低</td></tr><tr><td align="left">RoundRobinRule</td><td align="left"><strong>轮询</strong>：轮询选择server（此为默认的负载均衡策略）</td></tr><tr><td align="left">RandomRule</td><td align="left"><strong>随机</strong>：随机选择一个server</td></tr><tr><td align="left">ZoneAvoidanceRule</td><td align="left"><strong>区域敏感策略</strong>：复合判断server所在区域的性能和server的可用性选择server</td></tr><tr><td align="left">RetryRule</td><td align="left"><strong>重试</strong>：在一个配置时间段内，当选择server不成功时一直尝试重新选择</td></tr><tr><td align="left">BestAvailableRule</td><td align="left"><strong>最小连接</strong>：选择一个并发请求最小的server</td></tr><tr><td align="left">AvailabilityFilteringRule</td><td align="left"><strong>可用性敏感策略</strong>：过滤掉那些因为一直连接失败而被标记为circuit tripped的server，并过滤掉那些高并发的server（active connections 超过配置的阈值）</td></tr></tbody></table> 
<ul><li>Ribbon 为客户端负载均衡器，相比于服务端负载均衡器的统一负载均衡策略来说，它提供了更多的灵活性。</li><li>Ribbon 内置了 7 种负载均衡策略：轮询策略、权重策略、随机策略、最小连接数策略、重试策略、可用性敏感策略、区域性敏感策略</li><li>并且用户可以通过继承 RoundRibbonRule 来实现自定义负载均衡策略。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ffc1d2e50d95dee49960503c43c234e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">字符串函数（2）＜C语言＞</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46d8da8602cea8cf5cc3927362fb2428/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能时代的程序设计教学与课程设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>