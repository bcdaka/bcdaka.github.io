<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【常见开源库的二次开发】基于openssl的加密与解密——SHA算法源码解析（六） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8827d4462c1ffb44d643eccf629ac1ca/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【常见开源库的二次开发】基于openssl的加密与解密——SHA算法源码解析（六）">
  <meta property="og:description" content="目录
一、SHA-1算法分析：
1.1 Merkle Tree可信树
1.2 源码实现：
1.3 哈希计算功能
1.4 两种算法的区别： 1.4.1 目的
1.4.2 实现机制
1.4.3 输出
1.4.4 应用场景：
1.4 运行演示：
二、SHA-2算法分析： 2.1哈希算法简介 2.2 比特币挖矿与工作量证明
2.3 安全性 2.4 SHA-2算法概述
2.4.1. 消息填充
2.4.2 初始化链接变量缓冲区（SHA-256）
2.4.3 SHA-512 处理
2.4.4 SHA-384 和 SHA-512 的迭代函数
三、模拟比特币挖矿
3.1 区块的结构
3.2. 挖矿过程
3.3 TARGET 的计算
3.4 源码演示
3.5 算法思路
1. 目标定义:
2. 数据准备:
3. 哈希计算:
4. 有效性检查:
5. 输出结果:
总结：
一、SHA-1算法分析： 安全散列算法是一种加密散列函数，生成固定长度的散列值（或摘要），用于确保数据完整性和验证数据的真实性。
SHA-1是SHA系列中的一种，产生160比特（20字节）的散列值。其散列值通常表示为40个十六进制字符。SHA-1的散列值格式为`H0 H1 H2 H3 H4`，每个部分代表散列的不同部分。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T15:44:53+08:00">
    <meta property="article:modified_time" content="2024-07-24T15:44:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【常见开源库的二次开发】基于openssl的加密与解密——SHA算法源码解析（六）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cd/cc/pFuBoiIW_o.jpg"></p> 
<blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="-toc" style="margin-left:0px;"></p> 
 <p id="%E4%B8%80%E3%80%81SHA-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81SHA-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow">一、SHA-1算法分析：</a></p> 
 <p id="1.1%C2%A0Merkle%20Tree%E5%8F%AF%E4%BF%A1%E6%A0%91-toc" style="margin-left:40px;"><a href="#1.1%C2%A0Merkle%20Tree%E5%8F%AF%E4%BF%A1%E6%A0%91" rel="nofollow">1.1 Merkle Tree可信树</a></p> 
 <p id="1.2%20%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.2%20%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">1.2 源码实现：</a></p> 
 <p id="1.3%20%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#1.3%20%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E5%8A%9F%E8%83%BD" rel="nofollow">1.3 哈希计算功能</a></p> 
 <p id="1.4%20%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#1.4%20%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%C2%A0" rel="nofollow">1.4 两种算法的区别： </a></p> 
 <p id="1.4.1%20%E7%9B%AE%E7%9A%84-toc" style="margin-left:80px;"><a href="#1.4.1%20%E7%9B%AE%E7%9A%84" rel="nofollow">1.4.1 目的</a></p> 
 <p id="%C2%A01.4.2%C2%A0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#%C2%A01.4.2%C2%A0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6" rel="nofollow"> 1.4.2 实现机制</a></p> 
 <p id="1.4.3%C2%A0%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#1.4.3%C2%A0%E8%BE%93%E5%87%BA" rel="nofollow">1.4.3 输出</a></p> 
 <p id="1.4.4%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.4.4%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A" rel="nofollow">1.4.4 应用场景：</a></p> 
 <p id="1.4%C2%A0%E8%BF%90%E8%A1%8C%E6%BC%94%E7%A4%BA%EF%BC%9A-toc" style="margin-left:40px;"><a href="#1.4%C2%A0%E8%BF%90%E8%A1%8C%E6%BC%94%E7%A4%BA%EF%BC%9A" rel="nofollow">1.4 运行演示：</a></p> 
 <p id="%E4%BA%8C%E3%80%81SHA-2%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81SHA-2%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0" rel="nofollow">二、SHA-2算法分析： </a></p> 
 <p id="2.1%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%C2%A0-toc" style="margin-left:40px;"><a href="#2.1%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%C2%A0" rel="nofollow">2.1哈希算法简介 </a></p> 
 <p id="%C2%A02.2%C2%A0%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E-toc" style="margin-left:40px;"><a href="#%C2%A02.2%C2%A0%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E" rel="nofollow"> 2.2 比特币挖矿与工作量证明</a></p> 
 <p id="2.3%C2%A0%E5%AE%89%E5%85%A8%E6%80%A7%C2%A0-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E5%AE%89%E5%85%A8%E6%80%A7%C2%A0" rel="nofollow">2.3 安全性 </a></p> 
 <p id="%C2%A02.4%20SHA-2%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#%C2%A02.4%20SHA-2%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0" rel="nofollow"> 2.4 SHA-2算法概述</a></p> 
 <p id="2.4.1.%20%E6%B6%88%E6%81%AF%E5%A1%AB%E5%85%85-toc" style="margin-left:80px;"><a href="#2.4.1.%20%E6%B6%88%E6%81%AF%E5%A1%AB%E5%85%85" rel="nofollow">2.4.1. 消息填充</a></p> 
 <p id="2.4.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E6%8E%A5%E5%8F%98%E9%87%8F%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88SHA-256%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.4.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E6%8E%A5%E5%8F%98%E9%87%8F%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88SHA-256%EF%BC%89" rel="nofollow">2.4.2 初始化链接变量缓冲区（SHA-256）</a></p> 
 <p id="2.4.3%C2%A0SHA-512%20%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#2.4.3%C2%A0SHA-512%20%E5%A4%84%E7%90%86" rel="nofollow">2.4.3 SHA-512 处理</a></p> 
 <p id="2.4.4%C2%A0SHA-384%20%E5%92%8C%20SHA-512%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.4.4%C2%A0SHA-384%20%E5%92%8C%20SHA-512%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0" rel="nofollow">2.4.4 SHA-384 和 SHA-512 的迭代函数</a></p> 
 <p id="%C2%A0%E4%B8%89%E3%80%81%E6%A8%A1%E6%8B%9F%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E6%A8%A1%E6%8B%9F%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF" rel="nofollow"> 三、模拟比特币挖矿</a></p> 
 <p id="3.1%20%E5%8C%BA%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#3.1%20%E5%8C%BA%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">3.1 区块的结构</a></p> 
 <p id="3.2.%20%E6%8C%96%E7%9F%BF%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#3.2.%20%E6%8C%96%E7%9F%BF%E8%BF%87%E7%A8%8B" rel="nofollow">3.2. 挖矿过程</a></p> 
 <p id="3.3%20TARGET%20%E7%9A%84%E8%AE%A1%E7%AE%97-toc" style="margin-left:40px;"><a href="#3.3%20TARGET%20%E7%9A%84%E8%AE%A1%E7%AE%97" rel="nofollow">3.3 TARGET 的计算</a></p> 
 <p id="3.4%20%E6%BA%90%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3.4%20%E6%BA%90%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">3.4 源码演示</a></p> 
 <p id="%C2%A03.5%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%C2%A03.5%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF" rel="nofollow"> 3.5 算法思路</a></p> 
 <p id="1.%C2%A0%E7%9B%AE%E6%A0%87%E5%AE%9A%E4%B9%89%3A-toc" style="margin-left:80px;"><a href="#1.%C2%A0%E7%9B%AE%E6%A0%87%E5%AE%9A%E4%B9%89%3A" rel="nofollow">1. 目标定义:</a></p> 
 <p id="2.%C2%A0%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87%3A-toc" style="margin-left:80px;"><a href="#2.%C2%A0%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87%3A" rel="nofollow">2. 数据准备:</a></p> 
 <p id="3.%C2%A0%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%3A-toc" style="margin-left:80px;"><a href="#3.%C2%A0%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%3A" rel="nofollow">3. 哈希计算:</a></p> 
 <p id="4.%C2%A0%E6%9C%89%E6%95%88%E6%80%A7%E6%A3%80%E6%9F%A5%3A-toc" style="margin-left:80px;"><a href="#4.%C2%A0%E6%9C%89%E6%95%88%E6%80%A7%E6%A3%80%E6%9F%A5%3A" rel="nofollow">4. 有效性检查:</a></p> 
 <p id="5.%C2%A0%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%3A-toc" style="margin-left:80px;"><a href="#5.%C2%A0%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%3A" rel="nofollow">5. 输出结果:</a></p> 
 <p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">总结：</a></p> 
 <hr id="hr-toc"> 
 <p></p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81SHA-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A">一、SHA-1算法分析：</h2> 
<p><span style="color:#fe2c24;"><strong>安全散列算法是一种加密散列函数</strong></span>，生成固定长度的散列值（或摘要），用于确保数据完整性和验证数据的真实性。</p> 
<p> SHA-1是SHA系列中的一种，<span style="color:#fe2c24;"><strong>产生160比特（20字节）的散列值</strong></span>。其散列值通常表示为40个十六进制字符。SHA-1的散列值格式为`H0 H1 H2 H3 H4`，每个部分代表散列的不同部分。</p> 
<p> 尽管SHA-1曾被广泛使用，但它已经被证明存在弱点，尤其是对碰撞攻击的脆弱性。在2005年，研究人员王小云成功攻破了SHA-1，展示了其产生相同散列值的可能性，这就是所谓的<span style="color:#fe2c24;"><strong>“碰撞”</strong></span>。消息摘要是通过散列函数生成的数据摘要，它是输入数据的唯一表示。消息摘要用于确保数据在传输或存储过程中未被篡改。</p> 
<p><span style="color:#fe2c24;"><strong>MD4是早期的散列算法，而MD5是由MD4算法衍生而来。</strong></span>MD5生成128比特的散列值，广泛用于数据完整性校验，但同样也被发现存在安全漏洞。SHA系列，特别是SHA-1，确实是受到MD4的影响。尽管SHA-1和MD5具有不同的结构和输出长度，但它们在设计理念上有相似之处。</p> 
<h3 id="1.1%C2%A0Merkle%20Tree%E5%8F%AF%E4%BF%A1%E6%A0%91">1.1 Merkle Tree可信树</h3> 
<p><img alt="" height="528" src="https://images2.imgbox.com/d1/61/LISIsh5C_o.png" width="598"></p> 
<p><span style="color:#fe2c24;"><strong>Merkle树是一种哈希树</strong></span>，叶子节点代表数据块（如交易）的哈希值，而非叶子节点的哈希值则是其子节点哈希值的组合。</p> 
<p>Merkle树的底部是交易的哈希（即叶子节点），而每对叶子节点的哈希值会组合成其父节点的哈希，直到最终形成根哈希（Merkle根）。这个根哈希代表了整个树的所有交易摘要。</p> 
<p>在比特币中，交易哈希使用双SHA-256哈希算法进行计算。即每一笔交易在生成哈希时，首先计算SHA-256哈希，然后再对该哈希值计算一次SHA-256，从而增强安全性。</p> 
<h3 id="1.2%20%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A">1.2 源码实现：</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt; // 引入输入输出流库，以便使用 cout 和 cerr
#include &lt;openssl/md5.h&gt; // 引入 OpenSSL 的 MD5 相关函数
#include &lt;openssl/sha.h&gt; // 引入 OpenSSL 的 SHA 相关函数
#include &lt;fstream&gt; // 引入文件流库，以便读取文件
#include &lt;iomanip&gt; // 引入用于格式化输入输出的库，例如设置输出宽度
#include &lt;thread&gt; // 引入线程库，以便使用睡眠功能
#include &lt;vector&gt; // 引入 STL 的 vector 容器

using namespace std; // 使用标准命名空间，方便后续使用标准库中的元素

// 计算文件的MD5哈希值
string GetFileListHash(const string&amp; filepath)
{
    // 以二进制方式打开文件
    ifstream ifs(filepath, ios::binary); // 创建文件流对象以二进制模式打开指定路径的文件
    if (!ifs) { // 检查文件是否成功打开
        cerr &lt;&lt; "Failed to open file: " &lt;&lt; filepath &lt;&lt; endl; // 输出错误信息到标准错误流
        return ""; // 返回空字符串表示失败
    }

    int block_size = 128; // 定义一次读取的块大小为 128 字节
    unsigned char buf[block_size] = { 0 }; // 创建一个缓冲区用于存放读取的数据，初始化为 0
    unsigned char out[MD5_DIGEST_LENGTH] = { 0 }; // 创建输出数组，用于存放 MD5 哈希结果

    MD5_CTX c; // 定义 MD5 上下文结构体
    MD5_Init(&amp;c); // 初始化 MD5 上下文

    while (!ifs.eof()) { // 当文件没有到达末尾时循环
        ifs.read(reinterpret_cast&lt;char*&gt;(buf), block_size); // 从文件中读取数据到 buf 缓冲区
        int read_size = ifs.gcount(); // 获取实际读取的字节数
        if (read_size &gt; 0) { // 如果读取的字节数大于 0
            MD5_Update(&amp;c, buf, read_size); // 将读取的数据更新到 MD5 上下文中
        }
    }

    MD5_Final(out, &amp;c); // 完成 MD5 计算并将结果存入 out 数组
    ifs.close(); // 关闭文件流

    return string(reinterpret_cast&lt;char*&gt;(out), MD5_DIGEST_LENGTH); // 将 MD5 结果转换为字符串并返回
}

// 文件可信树 Hash
std::string GetFileMerkleHash(std::string filepath) {
    std::string hash; // 定义哈希字符串
    std::vector&lt;std::string&gt; hashes; // 定义一个字符串向量用于存放中间哈希值
    std::ifstream ifs(filepath, std::ios::binary); // 以二进制方式打开文件

    if (!ifs) return hash; // 如果文件未打开，返回空哈希值

    unsigned char buf[1024] = { 0 }; // 创建缓冲区用于读取文件数据
    unsigned char out[SHA_DIGEST_LENGTH]; // 创建输出数组，用于存放 SHA1 哈希结果

    int block_size = 128; // 定义一次读取的块大小为 128 字节
    while (!ifs.eof()) { // 当文件没有到达末尾时循环
        ifs.read(reinterpret_cast&lt;char*&gt;(buf), block_size); // 从文件中读取数据到 buf
        int read_size = ifs.gcount(); // 获取实际读取的字节数
        if (read_size &lt;= 0) break; // 如果没有读取到数据，跳出循环

        SHA1(buf, read_size, out); // 计算 SHA1 哈希并存储到 out 数组中
        hashes.push_back(std::string(reinterpret_cast&lt;char*&gt;(out), SHA_DIGEST_LENGTH)); // 将哈希值转换为字符串并添加到 hashes 向量中
    }

    // 计算 Merkle 哈希
    while (hashes.size() &gt; 1) { // 当 hashes 向量中有多个哈希值时
        if (hashes.size() &amp; 1) { // 如果 hashes 的大小是奇数
            hashes.push_back(hashes.back()); // 将最后一个哈希值复制一份到末尾，保证成对
        }

        for (size_t i = 0; i &lt; hashes.size() / 2; i++) { // 遍历哈希值的成对组合
            std::string tmp_hash = hashes[i * 2]; // 获取第一个哈希值
            tmp_hash += hashes[i * 2 + 1]; // 拼接第二个哈希值
            SHA1(reinterpret_cast&lt;const unsigned char*&gt;(tmp_hash.data()), tmp_hash.size(), out); // 计算拼接后字符串的 SHA1 哈希
            hashes[i] = std::string(reinterpret_cast&lt;char*&gt;(out), SHA_DIGEST_LENGTH); // 更新哈希值到 hashes 向量
        }
        hashes.resize(hashes.size() / 2); // 将 hashes 向量的大小减半
    }

    if (hashes.size() == 0) return hash; // 如果 hashes 向量为空，返回空哈希值
    return hashes[0]; // 返回 Merkle 树的根哈希值
}

// 以十六进制格式输出数据
void PrintHex(const string&amp; data) {
    for (unsigned char c : data) { // 遍历数据中的每一个字节
        cout &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; (int)c; // 将每个字节以十六进制格式输出
    }
    cout &lt;&lt; endl; // 输出换行符
}

int main() {
    cout &lt;&lt; "Test Hash" &lt;&lt; endl; // 输出测试信息

    unsigned char data[] = "测试MD5数据"; // 定义要进行MD5哈希的数据
    unsigned char out[MD5_DIGEST_LENGTH] = { 0 }; // 创建输出数组，用于存放 MD5 哈希结果
    int len = sizeof(data) - 1; // 计算数据长度，减去 1 是因为 sizeof 包含字符串末尾的 '\0'

    // 对数据进行 MD5 哈希计算
    MD5(data, len, out); // 计算 MD5 哈希
    // 输出哈希结果
    for (int i = 0; i &lt; MD5_DIGEST_LENGTH; i++) { // 遍历哈希结果
        cout &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; (int)out[i]; // 输出哈希值的每一个字节
    }
    cout &lt;&lt; endl; // 输出换行符

    data[1] = 9; // 修改数据
    MD5(data, len, out); // 再次计算 MD5 哈希
    for (int i = 0; i &lt; MD5_DIGEST_LENGTH; i++) { // 遍历哈希结果
        cout &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; (int)out[i]; // 输出新的哈希值
    }
    cout &lt;&lt; endl; // 输出换行符

    string filepath = "/home/book/Desktop/test.txt"; // 指定要读取的文件路径
    auto hash1 = GetFileListHash(filepath); // 计算文件的 MD5 哈希值
    PrintHex(hash1); // 输出文件的哈希值

    for (;;) { // 无限循环
        auto hash = GetFileListHash(filepath); // 重新计算文件哈希值
        auto thash = GetFileMerkleHash(filepath); // 计算文件的 Merkle 哈希值

        if (hash != hash1) { // 如果文件哈希值与之前的哈希不相等
            cout &lt;&lt; "文件被修改" &lt;&lt; endl; // 输出文件被修改的警告
            cout &lt;&lt; "HashList:\t"; // 输出哈希列表的提示
            PrintHex(hash); // 输出新的哈希值
            hash1 = hash; // 更新之前的哈希值

            cout &lt;&lt; "MerkleTree:\t"; // 输出 Merkle 树的提示
            PrintHex(thash); // 输出 Merkle 哈希值
        }
        this_thread::sleep_for(chrono::seconds(1)); // 每秒检查一次
    }

    return 0; // 程序正常结束
}
</code></pre> 
<p><strong>makefile</strong></p> 
<pre><code class="language-bash">first_openss:test_openssl.cpp
	g++ $^ -o $@ -I/usr/local/include -L/usr/local/lib -lcrypto -std=c++11
</code></pre> 
<h3 id="1.3%20%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E5%8A%9F%E8%83%BD">1.3 哈希计算功能</h3> 
<p><strong>1. MD5 哈希计算</strong> (<code>GetFileListHash</code> 函数)</p> 
<ul><li>该函数用于计算<strong><span style="color:#fe2c24;">指定文件的 MD5 哈希值</span></strong>。</li><li>以二进制模式打开文件，逐块读取文件数据（128 字节为一块），并将读取的数据传递给 MD5 上下文进行更新。</li><li>文件读取完成后，调用 <code>MD5_Final</code> 完成哈希计算，并返回哈希值。</li></ul> 
<p><strong>2. Merkle 哈希计算</strong> (<code>GetFileMerkleHash</code> 函数)</p> 
<ul><li>该函数实现了<span style="color:#fe2c24;"><strong>基于文件内容的 Merkle 树哈希计算</strong></span>。</li><li>逐块读取文件数据，并对每一块数据计算 SHA-1 哈希，存储在一个 <code>std::vector</code> 中。</li><li>通过将相邻的哈希值成对拼接并计算新的 SHA-1 哈希，逐步构建 Merkle 树，直到只剩下一个根哈希。</li></ul> 
<h3 id="1.4%20%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%C2%A0">1.4 两种算法的区别： </h3> 
<h4 id="1.4.1%20%E7%9B%AE%E7%9A%84">1.4.1 目的</h4> 
<p><strong>（1）. MD5 哈希计算 (<code>GetFileListHash</code> 函数)</strong></p> 
<ul><li>主要用于<span style="color:#fe2c24;"><strong>生成文件的唯一标识符（哈希值）</strong></span>，以便快速验证文件内容的完整性。</li><li>当文件内容发生变化时，MD5 哈希值会变化，从而可以用于检测文件是否被修改。</li></ul> 
<p><strong>（2）. Merkle 哈希计算</strong> (<code>GetFileMerkleHash</code> 函数) </p> 
<ul><li>主要用于<span style="color:#fe2c24;"><strong>构建 Merkle 树</strong></span>，提供一种结构化的方法来验证数据完整性和一致性。</li><li>Merkle 树允许验证文件中的特定部分（例如，分块数据），并且在分布式系统（如区块链）中非常常见，能够支持高效的证明和检查。</li></ul> 
<h4 id="%C2%A01.4.2%C2%A0%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"> 1.4.2 实现机制</h4> 
<p><strong>（1）. MD5 哈希计算</strong></p> 
<ul><li>整个文件数据一次性地计算一个 MD5 哈希值。</li><li>逐块读取文件（每块 128 字节），将读取到的数据传递到 MD5 上下文进行更新。</li><li>最终通过调用 <code>MD5_Final</code> 完成哈希计算，返回一个固定大小的 128 位（16 字节）MD5 哈希值。</li></ul> 
<p><strong>（2）. Merkle 哈希计算</strong></p> 
<ul><li>将文件分成多个块，对每个块计算 SHA-1 哈希，得到每个块的哈希值，并将它们存储在一个向量中。</li><li>接着，将相邻的哈希值成对拼接，计算新的 SHA-1 哈希，重复这个过程，最终构建出一个根哈希（Merkle 根）。</li><li>这一过程允许逐渐合并和验证多个哈希，能够高效地构建树状结构，有助于快速验证数据的完整性。</li></ul> 
<h4 id="1.4.3%C2%A0%E8%BE%93%E5%87%BA">1.4.3 输出</h4> 
<p><strong>（1）. MD5 哈希计算：</strong></p> 
<ul><li>输出的结果是一个单一的 MD5 哈希值，通常以十六进制字符串形式表示。</li></ul> 
<p><strong>（2）. Merkle 哈希计算</strong></p> 
<ul><li>输出的是一个根哈希值（Merkle 根），它代表了整个文件内容的哈希结构，可以视为整个文件的完整唯一标识。</li></ul> 
<h4 id="1.4.4%20%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A">1.4.4 应用场景：</h4> 
<p><strong>（1）. MD5 哈希计算</strong> 更加简单，主要用于快速验证文件是否已被修改，适合单一文件检查。</p> 
<p><strong>（2）. Merkle 哈希计算</strong> 则更复杂，适用于需要验证数据完整性和一致性的场景，尤其是当涉及多个数据块或分布式系统时。它通过构建树形结构提高了数据验证的效率和灵活性。</p> 
<h3 id="1.4%C2%A0%E8%BF%90%E8%A1%8C%E6%BC%94%E7%A4%BA%EF%BC%9A">1.4 运行演示：</h3> 
<p><img alt="" height="358" src="https://images2.imgbox.com/a5/8c/TRODNXfV_o.png" width="1200"></p> 
<h2 id="%E4%BA%8C%E3%80%81SHA-2%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0" style="background-color:transparent;">二、SHA-2算法分析： </h2> 
<p><span style="color:#fe2c24;"><strong>SHA-256、SHA-384 和 SHA-512 是三种不同的安全哈希算法，它们都是 SHA-2（安全哈希算法2）系列的一部分。</strong></span>它们在比特币挖矿的工作量证明（Proof of Work）机制中扮演着重要角色。</p> 
<h3 id="2.1%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%C2%A0">2.1哈希算法简介 </h3> 
<p><strong>1. SHA-256</strong>: </p> 
<ul><li>输出长度：256位（32字节）。</li><li>是比特币网络中使用的主要哈希函数。</li><li>具有较强的安全性，目前尚未发现有效的攻击方式。</li></ul> 
<p><strong> 2. SHA-384</strong>:</p> 
<ul><li>输出长度：384位（48字节）。</li><li>通常用于需要更高安全性要求的场合，但在比特币挖矿中并不常用。</li></ul> 
<p><strong>3.  SHA-512</strong>:</p> 
<ul><li>输出长度：512位（64字节）。</li><li>也提供了较高的安全性和抗碰撞能力，适用于对数据完整性有极高要求的应用场景。</li></ul> 
<h3 id="%C2%A02.2%C2%A0%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AF%81%E6%98%8E"> 2.2 比特币挖矿与工作量证明</h3> 
<p><strong>1. 工作量证明机制</strong>:</p> 
<ul><li>在比特币网络中，工作量证明是用于验证和确认交易的一种机制。矿工通过计算哈希值来竞争生成新区块。</li><li>矿工需要找到一个满足特定条件的哈希值（即小于某个目标值）。为此，他们会不断调整输入数据（包括随机数 nonce）并计算哈希，直到找到符合条件的哈希值。</li></ul> 
<p><strong>2.</strong> <strong>SHA-256 在比特币挖矿中的应用</strong>:</p> 
<ul><li><span style="color:#fe2c24;"><strong>比特币挖矿主要使用 SHA-256 算法</strong></span>。矿工通过对区块头信息应用 SHA-256 哈希，试图找到一个符合难度目标的哈希值。</li><li>挖矿的过程是一个计算密集型的过程，不断地尝试生成一个新的哈希值，每一次尝试都需要消耗计算资源。这也是导致比特币挖矿需要大量电力和硬件资源的原因。</li></ul> 
<p><img alt="" height="448" src="https://images2.imgbox.com/ae/44/Na5KEpF1_o.png" width="1200"> </p> 
<h3 id="2.3%C2%A0%E5%AE%89%E5%85%A8%E6%80%A7%C2%A0">2.3 安全性 </h3> 
<ul><li>目前，SHA-2 系列（包括 SHA-256、SHA-384 和 SHA-512）尚<span style="color:#fe2c24;"><strong>未被成功攻克</strong></span>。尽管 SHA-1 在安全性上已被广泛认为不再安全，但 SHA-2 仍然被认为是安全的。</li><li>这些哈希算法能够有效防止碰撞攻击（即不可能找到两个不同的输入生成相同的哈希值），并且提供良好的抗预映射攻击（即从哈希值推断出原始输入的难度）。</li></ul> 
<h3 id="%C2%A02.4%20SHA-2%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"> 2.4 SHA-2算法概述</h3> 
<h4 id="2.4.1.%20%E6%B6%88%E6%81%AF%E5%A1%AB%E5%85%85">2.4.1. 消息填充</h4> 
<p>在 SHA 系列哈希算法中，<span style="color:#fe2c24;"><strong>消息填充是将输入消息调整到特定长度的过程</strong></span>，以便满足算法处理的要求。</p> 
<p><strong>消息填充模 512 与 448 同余</strong>:</p> 
<p>        （1）SHA-256 和 SHA-512 都采用类似的填充机制，以<span style="color:#fe2c24;"><strong>确保输入消息的长度在处理之前符合特定要求。</strong></span></p> 
<p>        （2）消息的长度在被填充后，需要满足以下条件：</p> 
<p>                   填充后的消息长度要<strong>对 512 取模</strong>，且<strong>填充后的长度要为 448 位</strong>，即填充后的消息长度为 𝐿 ≡ 448 mod  512。</p> 
<p>                  填充过程一般是<strong>先添加一个 "1" 位（0x80），然后添加足够的 "0" 位，使得消息长度（以比特为单位）达到 448 位。</strong>最后，附加一个 64 位的表示原始消息长度的值，确保最终的消息长度是 512 位的整数倍。</p> 
<h4 id="2.4.2%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E6%8E%A5%E5%8F%98%E9%87%8F%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88SHA-256%EF%BC%89"><strong>2.4.2 初始化链接变量缓冲区（SHA-256）</strong></h4> 
<p><strong><span style="color:#fe2c24;">SHA-256 初始化时使用</span></strong> <span style="color:#fe2c24;"><strong>8 个 32 位的寄存器</strong></span>，这些寄存器通常称为链值（chain values），用于存储哈希计算的中间结果。</p> 
<p><strong>链接变量：</strong></p> 
<p>这些链接变量的初始值取自<strong>前 8 个素数的平方根的小数部分</strong>，具体是：2、3、5、7、11、13、17、19 的平方根小数部分的前 32 位二进制表示。</p> 
<p><strong>初始值为：</strong></p> 
<blockquote> 
 <p></p> 
 <ul><li>h0​=6a09e667</li><li>ℎ1=𝑏𝑏67𝑎𝑒85</li><li>ℎ2=3𝑐6𝑒𝑓372</li><li>ℎ3=𝑎54𝑓𝑓53𝑎</li><li>ℎ4=510𝑒527𝑓</li><li>ℎ5=9𝑏05688𝑐</li><li>ℎ6=1𝑓83𝑑9𝑎𝑏</li><li>ℎ7=5𝑏𝑒0𝑐𝑑19</li></ul> 
</blockquote> 
<h4 id="2.4.3%C2%A0SHA-512%20%E5%A4%84%E7%90%86">2.4.3 SHA-512 处理</h4> 
<p><span style="color:#fe2c24;"><strong>SHA-512 和 SHA-256 相似，但使用的是 64 位的寄存器</strong></span>，<span style="color:#fe2c24;"><strong>并以 1024 位（128 字节）为一个分组进行处理。</strong></span></p> 
<p><strong>初始化链接变量</strong>:</p> 
<p>SHA-512 使用 8 个 64 位的寄存器，初始化值取自前 8 个素数的平方根小数部分的前 64 位二进制表示。</p> 
<p><strong>分组和循环</strong>:</p> 
<p>SHA-512 将输入消息分成 1024 位的块进行处理，每个块经过 80 轮的迭代（<span style="color:#fe2c24;"><strong>与 SHA-256 的 64 轮相比，SHA-512 具有更多的迭代</strong></span>）。</p> 
<p>每一轮都使用特定的计算函数（如选择、置换等）和常数值，对每个分组进行复杂的运算。</p> 
<h4 id="2.4.4%C2%A0SHA-384%20%E5%92%8C%20SHA-512%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0">2.4.4 SHA-384 和 SHA-512 的迭代函数</h4> 
<p>SHA-384 和 SHA-512 虽然在位数和寄存器大小上有所不同，但它们也<span style="color:#fe2c24;"><strong>都使用了 6 个迭代函数来处理输入块。</strong></span></p> 
<blockquote> 
 <ul><li><strong>Ch</strong>（选择）：根据条件选择输入位。</li><li><strong>Maj</strong>（多数）：计算三个输入位的多数。</li><li><strong>Σ0 和 Σ1</strong>：旋转和位移操作，用于产生混淆和扩散。</li><li><strong>σ0 和 σ1</strong>：类似于 Σ，但在处理中使用不同的旋转和位移位数。</li></ul> 
</blockquote> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E6%A8%A1%E6%8B%9F%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF"> 三、模拟比特币挖矿</h2> 
<h3 id="3.1%20%E5%8C%BA%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84">3.1 区块的结构</h3> 
<p>一个区块包含多个字段，每个字段在挖矿过程中都有特定的作用：</p> 
<p><strong>（1）版本（version）:</strong>表示区块的版本号，提供了协议的版本信息，可能影响区块的创建或验证方式。</p> 
<p><strong>（2）上一个区块的哈希值（prev_hash）:</strong>这是前一个区块的 SHA-256 哈希值，用于连接区块链。确保每个区块都有效地链接到前一个区块，形成不可篡改的链条。</p> 
<p><strong>（3）交易记录的哈希树值（merkle_root）:</strong>这是当前区块中所有交易的 Merkle 树根哈希，提供了一种高效验证区块内所有交易是否被篡改的方式。</p> 
<p><strong>（4）更新时间（ntime）：</strong>该字段记录当前区块创建的时间戳，通常以 Unix 时间戳表示。</p> 
<p><strong>（5）当前难度（nbits）：</strong>该字段表示目标的难度级别，影响挖矿时需要找到的哈希值的范围。</p> 
<h3 id="3.2.%20%E6%8C%96%E7%9F%BF%E8%BF%87%E7%A8%8B">3.2. 挖矿过程</h3> 
<p>挖矿过程的核心是<span style="color:#fe2c24;"><strong>找到一个有效的 nonce 值，使得生成的区块哈希满足特定的难度目标。</strong></span></p> 
<p><strong>1. 构造区块头:</strong></p> 
<p>区块头由以下字段组成：</p> 
<blockquote> 
 <ul><li><code>version</code></li><li><code>prev_hash</code></li><li><code>merkle_root</code></li><li><code>ntime</code></li><li><code>nbits</code></li><li><code>nonce</code>（初始值为 0）</li></ul> 
</blockquote> 
<p><strong>2. 计算哈希:</strong></p> 
<p><strong>        </strong>使用 SHA-256 两次对区块头进行哈希计算：<br>            <img alt="" height="56" src="https://images2.imgbox.com/3c/39/CzN7Kh1d_o.png" width="969"></p> 
<p>        这里的 `||` 表示将各个字段串联在一起。</p> 
<p><strong>3. 比较哈希与目标:</strong></p> 
<p>        计算出的哈希值需要与一个预定义的目标（TARGET）进行比较。</p> 
<p>        如果计算出的哈希值小于或等于 TARGET，则该 nonce 是有效的，矿工成功找到一个有效的区块。</p> 
<p><strong>4. 调整难度:</strong></p> 
<p><strong>        </strong>TARGET 由当前难度决定，难度会根据网络的算力变化而调整，以确保新区块的生成时间大约为 10 分钟。TARGET 的计算公式通常与 nbits 相关。</p> 
<h3 id="3.3%20TARGET%20%E7%9A%84%E8%AE%A1%E7%AE%97">3.3 TARGET 的计算</h3> 
<p>TARGET 可以根据当前的难度 (nbits) 计算得出：</p> 
<p>        nbits 是一个表示难度的 32 位数字，通常以十六进制表示，前面的字节用于表示目标的位数（例如，00000000），后面的部分表示目标值的具体大小（例如，FFFF）。</p> 
<p>        计算出的 TARGET 值越小，挖矿难度越高。</p> 
<p>比特币挖矿的过程涉及到多个关键的区块字段和复杂的哈希计算，以确保区块链的安全性和完整性。矿工通过不断尝试不同的 nonce 值，来寻找满足当前难度目标的有效哈希值，以便成功添加新区块到区块链中。</p> 
<h3 id="3.4%20%E6%BA%90%E7%A0%81%E6%BC%94%E7%A4%BA" style="background-color:transparent;">3.4 源码演示</h3> 
<pre><code class="language-cpp">#include &lt;iostream&gt; // 引入输入输出流库，以便使用 cout 和 cerr
#include &lt;openssl/md5.h&gt; // 引入 OpenSSL 的 MD5 相关函数
#include &lt;openssl/sha.h&gt; // 引入 OpenSSL 的 SHA 相关函数
#include &lt;fstream&gt; // 引入文件流库，以便读取文件
#include &lt;iomanip&gt; // 引入用于格式化输入输出的库，例如设置输出宽度
#include &lt;thread&gt; // 引入线程库，以便使用睡眠功能
#include &lt;vector&gt; // 引入 STL 的 vector 容器
#include &lt;cstring&gt; // 引入 C 字符串库，以便使用 strlen 和 memcpy

using namespace std; // 使用标准命名空间，方便后续使用标准库中的元素

void TestBit() // 定义 TestBit 函数
{
    unsigned char data[128] = "测试比特币挖矿，模拟交易链"; // 定义一个字符数组并初始化为测试字符串
    unsigned int nonce = 0; // 定义 nonce 变量并初始化为 0，用于寻找有效 nonce
    int data_size = strlen((char*)data); // 获取数据大小，返回字符串的长度
    unsigned char md1[1024] = { 0 }; // 定义 md1 数组用于存储第一次 SHA-256 哈希结果，初始化为 0
    unsigned char md2[1024] = { 0 }; // 定义 md2 数组用于存储第二次 SHA-256 哈希结果，初始化为 0
    for (;;) // 无限循环，直到找到满足条件的 nonce
    {
        nonce++; // 增加 nonce 值
        memcpy(data + data_size, &amp;nonce, sizeof(nonce)); // 将当前 nonce 值复制到 data 数组的末尾
        SHA256(data, data_size + sizeof(nonce), md1); // 计算 data 的 SHA-256 哈希，结果存入 md1
        SHA256(md1, 64, md2); // 计算 md1 的 SHA-256 哈希，结果存入 md2
        //工作量的难度
        if (md2[0] == 0) break; // 如果 md2 的第一个字节为 0，则跳出循环
    }
    cout &lt;&lt; "nonce = " &lt;&lt; nonce &lt;&lt; endl; // 输出找到的 nonce 值
}

int main() { // 主函数入口
    cout &lt;&lt; "Test Bit" &lt;&lt; endl; // 输出测试信息
    TestBit(); // 调用 TestBit 函数

    return 0; // 程序正常结束
}
</code></pre> 
<p><strong>运行效果：</strong></p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/f1/db/t8vltIbR_o.png" width="1002"></p> 
<p><strong>当我们增加难度以后：</strong></p> 
<pre><code class="language-cpp">if (md2[0] == 0) break;//原代码难度

if (md2[0] == 0 &amp;&amp; md2[1] == 0) break;//修改代码难度</code></pre> 
<p><strong> 再次运行效果：</strong></p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/91/48/sxluQ23A_o.png" width="1072"></p> 
<h3 id="%C2%A03.5%20%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"> 3.5 算法思路</h3> 
<h4 id="1.%C2%A0%E7%9B%AE%E6%A0%87%E5%AE%9A%E4%B9%89%3A">1. <strong>目标定义</strong>:</h4> 
<p>挖矿的目标是<span style="color:#fe2c24;"><strong>找到一个满足特定条件的哈希值。</strong></span>在比特币网络中，通常是使得哈希值的前面若干位为零。这个条件可以通过调整 <code>nonce</code> 值来实现。</p> 
<h4 id="2.%C2%A0%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87%3A">2. <strong>数据准备</strong>:</h4> 
<p>挖矿过程中，矿工需要准备一个数据块<span style="color:#0d0016;"><strong>，</strong></span><span style="color:#fe2c24;"><strong>这个数据块通常包含交易信息、时间戳、前一个区块的哈希值等。</strong></span>在这里，代码使用了一个简单的字符串 <code>"测试比特币挖矿，模拟交易链"</code> 作为基础数据。</p> 
<p><span style="color:#fe2c24;"><strong><code>nonce</code> 是一个用于生成哈希值的随机数</strong></span>，它会随着每次尝试而变化。</p> 
<h4 id="3.%C2%A0%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%3A"><strong>3.</strong> <strong>哈希计算</strong>:</h4> 
<p>使用<span style="color:#fe2c24;"><strong> SHA-256 哈希算法对数据进行多次哈希计算</strong></span>。在每次尝试中，程序将当前的 <code>nonce</code> 值附加到数据块中，然后计算哈希值。</p> 
<p>具体流程如下：</p> 
<p>        （1）计算当前数据块的哈希（<code>SHA256(data)</code>），这个哈希值存储在 <code>md1</code> 中。</p> 
<p>        （2）再对 <code>md1</code> 进行一次哈希（<code>SHA256(md1)</code>），结果存储在 <code>md2</code> 中。这个双重哈希的目的是增加安全性和复杂性。</p> 
<h4 id="4.%C2%A0%E6%9C%89%E6%95%88%E6%80%A7%E6%A3%80%E6%9F%A5%3A">4. <strong>有效性检查</strong>:</h4> 
<p>在每次哈希计算后，检查 <code>md2</code> 的第一个字节是否为 0。<span style="color:#fe2c24;"><strong>如果满足条件，说明找到了符合挖矿要求的哈希值，程序就可以停止查找。</strong></span></p> 
<h4 id="5.%C2%A0%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%3A">5. <strong>输出结果</strong>:</h4> 
<p>一旦找到了有效的 <code>nonce</code>，程序会将其打印输出。这告诉矿工他们成功地找到了一个有效的哈希。</p> 
<h4 id="%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</h4> 
<blockquote> 
 <ul><li><strong>初始化</strong>: 准备数据和 <code>nonce</code>，计算数据的初始大小。</li><li><strong>循环尝试</strong>: 通过无限循环，不断增加 <code>nonce</code> 值，更新数据，计算哈希。</li><li><strong>哈希计算</strong>: 每次尝试都计算两次哈希值，增加难度和安全性。</li><li><strong>条件检查</strong>: 检查计算出的哈希值是否满足特定条件以决定是否继续。</li><li><strong>结果输出</strong>: 找到有效 <code>nonce</code> 后打印结果。</li></ul> 
</blockquote> 
<blockquote> 
 <ul><li><strong>暴力搜索</strong>: <span style="color:#fe2c24;"><strong>这个算法实际上是一种暴力搜索策略</strong></span>。通过不断尝试不同的 <code>nonce</code> 值，直到找到一个合适的哈希值。这是挖矿过程中常见的做法。</li><li><strong>安全性和复杂性</strong>: 通过双重哈希计算，增加了找到哈希的复杂性和安全性，防止简单的逆向工程和破解。</li><li><strong>分布式系统特性</strong>: 由于比特币网络是去中心化的，许多矿工在全球范围内同时进行这个过程，从而竞争解决问题并获得奖励。</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd7db7edfca3be61b58415203fa93556/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构之《栈》</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7be6dabc29f6829d0ad7d28f170610a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux添加普通用户后无法使用K8S的kubectl命令怎么办/Linux普通用户管理K8S/Linux下普通用户无法使用K8S命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>