<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【学习笔记】程序设计竞赛 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a9ea7114d918713bcbca8f62ce6f90d9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【学习笔记】程序设计竞赛">
  <meta property="og:description" content="程序设计竞赛 文章目录 程序设计竞赛0x00 基本操作指南0x01 算法分析0x02 STL和基本数据结构栈队列集合map 0x03 排序插入排序归并排序（Merge Sort)快速排序 0x04 搜索技术BFSDFS回溯与剪枝 深度迭代ID A*A star双向广搜 0x05 递推方程0x06 高级数据结构并查集二叉树二叉搜索树退化树Treap树（堆）伸展树Splay线段树树状数组 0x07 分治法*一般方法求最大最小元二分搜索排序问题选择问题斯特拉森 0x08 动态规划（Dynamic Programming，DP）*定义硬币组合0/1 背包问题滚动数组最短路径问题最长公共子序列（LCS）最少拦截问题 =&gt; LIS 最长递增子序列矩阵连乘问题 0x09 基础语法0x10 二分答案概念练习整数域二分实数域二分 0x11 贪心法（Greedy）*导言背包问题0/1 背包问题一般背包问题 活动安排问题最佳合并模式 0x12 数论质数快速幂矩阵快速幂约数扩欧算法 0x13 图论基本概念无向图和有向图的连通性 0x14 回溯法*基本概念涂色问题4/n-皇后问题0/1背包问题 0x15 分支限界法*4-皇后问题 0x16 优先队列 0x00 基本操作指南 输入的结束,推荐使用下面的非~：位运算符，按位取反；只有当x值为-1时（-1的补码：11111111），~x的值才为0
while(~scanf(&#34;%d%d&#34;, &amp;a, &amp;b)) 指定数据个数结束，提高程序编写效率
int main(){ int n, a, b; scanf(&#34;%d&#34;, &amp;n); while(n -- ){ } } 以特定元素作结束符，以读取到0结束为例
while(~scanf(&#34;%d&#34;, &amp;n) &amp;&amp; n) 测试的两种方法：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-06T15:18:04+08:00">
    <meta property="article:modified_time" content="2024-07-06T15:18:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【学习笔记】程序设计竞赛</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>程序设计竞赛</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_0" rel="nofollow">程序设计竞赛</a></li><li><ul><li><a href="#0x00__2" rel="nofollow">0x00 基本操作指南</a></li><li><a href="#0x01__224" rel="nofollow">0x01 算法分析</a></li><li><a href="#0x02_STL_326" rel="nofollow">0x02 STL和基本数据结构</a></li><li><ul><li><a href="#_360" rel="nofollow">栈</a></li><li><a href="#_364" rel="nofollow">队列</a></li><li><a href="#_370" rel="nofollow">集合</a></li><li><a href="#map_398" rel="nofollow">map</a></li></ul> 
   </li><li><a href="#0x03__418" rel="nofollow">0x03 排序</a></li><li><ul><li><a href="#_420" rel="nofollow">插入排序</a></li><li><a href="#Merge_Sort_443" rel="nofollow">归并排序（Merge Sort)</a></li><li><a href="#_451" rel="nofollow">快速排序</a></li></ul> 
   </li><li><a href="#0x04__457" rel="nofollow">0x04 搜索技术</a></li><li><ul><li><a href="#BFS_471" rel="nofollow">BFS</a></li><li><a href="#DFS_517" rel="nofollow">DFS</a></li><li><ul><li><a href="#_523" rel="nofollow">回溯与剪枝</a></li></ul> 
    </li><li><a href="#_551" rel="nofollow">深度迭代</a></li><li><a href="#ID_A_557" rel="nofollow">ID A*</a></li><li><a href="#A_star_563" rel="nofollow">A star</a></li><li><a href="#_573" rel="nofollow">双向广搜</a></li></ul> 
   </li><li><a href="#0x05__585" rel="nofollow">0x05 递推方程</a></li><li><a href="#0x06__627" rel="nofollow">0x06 高级数据结构</a></li><li><ul><li><a href="#_629" rel="nofollow">并查集</a></li><li><a href="#_701" rel="nofollow">二叉树</a></li><li><a href="#_709" rel="nofollow">二叉搜索树</a></li><li><a href="#_740" rel="nofollow">退化树</a></li><li><a href="#Treap_752" rel="nofollow">Treap树（堆）</a></li><li><a href="#Splay_810" rel="nofollow">伸展树Splay</a></li><li><a href="#_822" rel="nofollow">线段树</a></li><li><a href="#_832" rel="nofollow">树状数组</a></li></ul> 
   </li><li><a href="#0x07__842" rel="nofollow">0x07 分治法*</a></li><li><ul><li><a href="#_844" rel="nofollow">一般方法</a></li><li><a href="#_863" rel="nofollow">求最大最小元</a></li><li><a href="#_982" rel="nofollow">二分搜索</a></li><li><a href="#_1054" rel="nofollow">排序问题</a></li><li><a href="#_1208" rel="nofollow">选择问题</a></li><li><a href="#_1228" rel="nofollow">斯特拉森</a></li></ul> 
   </li><li><a href="#0x08_Dynamic_ProgrammingDP_1240" rel="nofollow">0x08 动态规划（Dynamic Programming，DP）*</a></li><li><ul><li><a href="#_1242" rel="nofollow">定义</a></li><li><a href="#_1262" rel="nofollow">硬币组合</a></li><li><a href="#01__1276" rel="nofollow">0/1 背包问题</a></li><li><a href="#_1355" rel="nofollow">滚动数组</a></li><li><a href="#_1361" rel="nofollow">最短路径问题</a></li><li><a href="#LCS_1377" rel="nofollow">最长公共子序列（LCS）</a></li><li><a href="#__LIS__1431" rel="nofollow">最少拦截问题 =&gt; LIS 最长递增子序列</a></li><li><a href="#_1498" rel="nofollow">矩阵连乘问题</a></li></ul> 
   </li><li><a href="#0x09__1545" rel="nofollow">0x09 基础语法</a></li><li><a href="#0x10__1558" rel="nofollow">0x10 二分答案</a></li><li><ul><li><a href="#_1560" rel="nofollow">概念</a></li><li><a href="#_1694" rel="nofollow">练习</a></li><li><a href="#_1959" rel="nofollow">整数域二分</a></li><li><a href="#_1973" rel="nofollow">实数域二分</a></li></ul> 
   </li><li><a href="#0x11_Greedy_1993" rel="nofollow">0x11 贪心法（Greedy）*</a></li><li><ul><li><a href="#_1995" rel="nofollow">导言</a></li><li><a href="#_2037" rel="nofollow">背包问题</a></li><li><ul><li><a href="#01__2039" rel="nofollow">0/1 背包问题</a></li><li><a href="#_2049" rel="nofollow">一般背包问题</a></li></ul> 
    </li><li><a href="#_2071" rel="nofollow">活动安排问题</a></li><li><a href="#_2081" rel="nofollow">最佳合并模式</a></li></ul> 
   </li><li><a href="#0x12__2095" rel="nofollow">0x12 数论</a></li><li><ul><li><a href="#_2097" rel="nofollow">质数</a></li><li><a href="#_2105" rel="nofollow">快速幂</a></li><li><a href="#_2183" rel="nofollow">矩阵快速幂</a></li><li><a href="#_2211" rel="nofollow">约数</a></li><li><a href="#_2224" rel="nofollow">扩欧算法</a></li></ul> 
   </li><li><a href="#0x13__2238" rel="nofollow">0x13 图论</a></li><li><ul><li><a href="#_2240" rel="nofollow">基本概念</a></li><li><a href="#_2244" rel="nofollow">无向图和有向图的连通性</a></li></ul> 
   </li><li><a href="#0x14__2258" rel="nofollow">0x14 回溯法*</a></li><li><ul><li><a href="#_2260" rel="nofollow">基本概念</a></li><li><a href="#_2284" rel="nofollow">涂色问题</a></li><li><a href="#4n_2300" rel="nofollow">4/n-皇后问题</a></li><li><a href="#01_2330" rel="nofollow">0/1背包问题</a></li></ul> 
   </li><li><a href="#0x15__2340" rel="nofollow">0x15 分支限界法*</a></li><li><ul><li><a href="#4_2342" rel="nofollow">4-皇后问题</a></li></ul> 
   </li><li><a href="#0x16__2367" rel="nofollow">0x16 优先队列</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="0x00__2"></a>0x00 基本操作指南</h3> 
<p>输入的结束,推荐使用下面的非~：位运算符，按位取反；只有当x值为-1时（-1的补码：11111111），~x的值才为0</p> 
<pre><code class="prism language-c++">while(~scanf("%d%d", &amp;a, &amp;b))
</code></pre> 
<p>指定数据个数结束，提高程序编写效率</p> 
<pre><code class="prism language-c++">int main(){
    int n, a, b;
    scanf("%d", &amp;n);
    while(n -- ){
        
    }
}
</code></pre> 
<p>以特定元素作结束符，以读取到0结束为例</p> 
<pre><code class="prism language-c++">while(~scanf("%d", &amp;n) &amp;&amp; n)   
</code></pre> 
<ul><li> <p>测试的两种方法：</p> 
  <ul><li>在程序中加入测试代码</li></ul> <pre><code class="prism language-c++">#include&lt;stdio.h&gt;
#define mytest
int main(){
    int n;
    #ifdef mytest
	freopen("test.in", "r", stdin);   //将stdin重定向到test.in文件，file redirect 不需要从键盘输入了
	//freopen("test.out", "w", stdout);
#endif
    while(~scanf("%d", &amp;n) &amp;&amp; n){
        printf("%d\n", n * n);
    }
    return 0;
}
</code></pre> 
  <ul><li>在命令行中重定向 好处在于不需要修改源代码适合测多个文件</li></ul> <pre><code class="prism language-c++">#include&lt;stdio.h&gt;
int main(){
    int n;
    while(~scanf("%d", &amp;n) &amp;&amp; n){
        printf("%d\n", n * n);
    }
    return 0;
}
</code></pre> <p>上面文件abc.cpp 一定注意要把源文件进行编译 生成exe文件</p> <p>然后在相同位置 创建test.in文件 记事本</p> <p>在该位置进入到当前目录 执行命令</p> <p><code>abc &lt; test1.in &gt; test1.out</code></p> <p><img src="https://images2.imgbox.com/b8/e4/iP5DGZMb_o.png" alt="image-20240227082155639"></p> <p><code>&lt;</code> : 输入</p> <p><code>&gt;</code> : 输出重定向</p> <p>把结果存入到test1.out</p> <p><img src="https://images2.imgbox.com/99/cb/x6Sa7muP_o.png" alt="image-20240227082213277"></p> <p>然后对比我们的结果和答案(答案是我们预测的结果）是否相同</p> <p><code>fc test1.out answer.out</code></p> <p><img src="https://images2.imgbox.com/f8/e0/PMJXeWFZ_o.png" alt="image-20240227082145535"></p> <p>命令进阶版</p> <p>创建xxx.bat文件 批量化执行命令脚本</p> <pre><code class="prism language-bash">abc <span class="token operator">&lt;</span>test1.in<span class="token operator">&gt;</span> test1.out
abc <span class="token operator">&lt;</span>test2.in<span class="token operator">&gt;</span> test2.out
abc <span class="token operator">&lt;</span>test3.in<span class="token operator">&gt;</span> test3.out
fc test1.out answer1.out
fc test2.out answer2.out
fc test3.out answer3.out
pause
</code></pre> </li></ul> 
<p>提速：</p> 
<ol><li>使用STL库</li><li>不使用动态调试 而是通过打印中间信息</li><li>模板</li></ol> 
<p>算法证明 ：</p> 
<ul><li>归纳法</li><li>反证法</li></ul> 
<p>在c++ 中引入c的函数进行提速文件头</p> 
<pre><code class="prism language-c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;

using namespace std;

int main(){
    
    return 0;
}
</code></pre> 
<ul><li>题目类型： 
  <ul><li>Ad Hoc，杂题；</li><li>Complete Search（Iterative/Recursive)，穷举搜索</li><li>Divide and Conquer，分治法</li><li>Greedy，贪心法</li><li>Dynamic Programming，动态规划</li><li>Graph，图论</li><li>Mathmatics，数学</li><li>String Processing，字符串处理</li><li>Computation Geometry，计算几何</li><li>Some Harder，罕见问题</li></ul> </li><li>代码规范 
  <ul><li>少用</li></ul> </li></ul> 
<p>课本推荐的题目全部要做掉 没时间做来上课干嘛</p> 
<p>int最大：2147483647 20多个亿</p> 
<ul><li>报错：</li></ul> 
<p>RE：Runtime Error 运行错误 大部分都是数组越界 特殊：除0越界</p> 
<p>MLE：数组开太大</p> 
<ul><li>区分scanf和cin的区别</li></ul> 
<p>主要是在输入一个数字+一段字符时容易出错</p> 
<p>cin cout 提速代码： 数据达到百万级 注意：如果进行了加速 scanf 和printf就必须禁用</p> 
<pre><code class="prism language-c++">ios::sync_with_stdio(flase);
cin.tie(0);
cout.tie(0);
</code></pre> 
<ul><li>bug 避坑</li></ul> 
<p>如果创建副本 会导致执行相同的exe文件 所以需要修改前面的命名</p> 
<ul><li>大数据测试方法：</li></ul> 
<p>记事本打不开 直接死掉</p> 
<p>使用fopen</p> 
<pre><code class="prism language-c++">freopen("1.in","r",stdin);
//输出
freopen("1.txt", "w", stdout);
</code></pre> 
<ul><li> <p>数组建议从1开始 因为在搜索的时候 地图如果从0开始可能有问题</p> </li><li> <p>double 类型的数据 在读入的时候是lf 但是输出本身就是f</p> </li><li></ul> 
<h3><a id="0x01__224"></a>0x01 算法分析</h3> 
<ul><li>多项式复杂度</li><li>指数复杂度(一般是暴力求解出现)</li></ul> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
         
         
           2 
          
         
           n 
          
         
        
          ) 
         
        
          &lt; 
         
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ! 
         
        
          ) 
         
        
          &lt; 
         
        
          O 
         
        
          ( 
         
         
         
           n 
          
         
           n 
          
         
        
          ) 
         
        
       
         O(2^n) &lt; O(n!) &lt; O(n^n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7144em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7144em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p> 
<p>最快的方法：打表法</p> 
<p>只输出结果</p> 
<p>打表法：以素数个数求解</p> 
<pre><code class="prism language-c++">float Sum(float list[], const int n){
    float tempsum = 0.0;
    count ++;
    for(int i = 0; i &lt; n; i++){
        count ++;
        tempsum += list[i];
        count ++;
    }
    count ++;
    count ++;
    return tempsum;
}
</code></pre> 
<p>确定问题的规模 根据<code>count ++</code>的数量 <code>T(n) = 2 * n + 3</code></p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          2 
         
        
          n 
         
        
          + 
         
        
          3 
         
        
          = 
         
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
         
        
          当 
         
        
          n 
         
        
          ≥ 
         
        
          3 
         
        
          时 
         
        
       
         f(n) = 2n +3 = O(n)\\ 当n\ge3时 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.8193em; vertical-align: -0.136em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord">3</span><span class="mord cjk_fallback">时</span></span></span></span></span></span></p> 
<p>一点一点放<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          10 
         
         
         
           n 
          
         
           2 
          
         
        
          + 
         
        
          4 
         
        
          n 
         
        
          + 
         
        
          2 
         
         
        
          当 
         
        
          n 
         
        
          ≥ 
         
        
          2 
         
        
          时，原式 
         
        
          ≤ 
         
        
          10 
         
         
         
           n 
          
         
           2 
          
         
        
          + 
         
        
          5 
         
        
          n 
         
         
        
          当 
         
        
          n 
         
        
          ≥ 
         
        
          5 
         
        
          是，上式 
         
        
          ≤ 
         
        
          10 
         
         
         
           n 
          
         
           2 
          
         
        
          + 
         
         
         
           n 
          
         
           2 
          
         
        
          = 
         
        
          11 
         
         
         
           n 
          
         
           2 
          
         
        
          = 
         
        
          &gt; 
         
        
          O 
         
        
          ( 
         
         
         
           n 
          
         
           2 
          
         
        
          ) 
         
        
       
         10n^2 + 4n +2\\ 当n\ge2时，原式\le10n^2 +5n \\ 当n\ge5是，上式\le10n^2+n^2 = 11n^2 =&gt;O(n^2) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9474em; vertical-align: -0.0833em;"></span><span class="mord">10</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.8193em; vertical-align: -0.136em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8193em; vertical-align: -0.136em;"></span><span class="mord">2</span><span class="mord cjk_fallback">时，原式</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.9474em; vertical-align: -0.0833em;"></span><span class="mord">10</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">5</span><span class="mord mathnormal">n</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.8193em; vertical-align: -0.136em;"></span><span class="mord cjk_fallback">当</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.8193em; vertical-align: -0.136em;"></span><span class="mord">5</span><span class="mord cjk_fallback">是，上式</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.9474em; vertical-align: -0.0833em;"></span><span class="mord">10</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8641em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.9032em; vertical-align: -0.0391em;"></span><span class="mord">11</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.1141em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p> 
<p>反证法<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          10 
         
         
         
           n 
          
         
           2 
          
         
        
          + 
         
        
          9 
         
        
          ≠ 
         
        
          O 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         10n^2 + 9 \neq O(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9474em; vertical-align: -0.0833em;"></span><span class="mord">10</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8641em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord">9</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0278em;" class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p> 
<ul><li>矩阵乘法</li></ul> 
<pre><code class="prism language-c++">for(i = 0; i &lt; n; i++){
    for(j = 0; j &lt; n; j++){
        c[i][j] = 0;
        for(k = 2; k &lt; n; k++){
            xxx
            ...
            xxx
        }
    }
}
</code></pre> 
<p>O（n次方）</p> 
<p>主方法：</p> 
<p>理解与应用</p> 
<p>证明不会重点考查</p> 
<p>除法相对于其他运算会非常慢 所以一般采用移位进行做除法</p> 
<p>增长率计算方法：https://blog.csdn.net/qq_37657182/article/details/102826437</p> 
<p><img src="https://images2.imgbox.com/b8/be/FTCcf87Q_o.png" alt="image-20240426170756203"></p> 
<p><img src="https://images2.imgbox.com/d0/66/bVPRsJTN_o.png" alt="image-20240426170813472"></p> 
<h3><a id="0x02_STL_326"></a>0x02 STL和基本数据结构</h3> 
<ul><li>STL</li></ul> 
<p>Standard Template Library，C++的标准模板库，竞赛中常用的数据结构和算法可以直接调用。</p> 
<p>容器：存放数据的，如Vector list queue stack map(映射) set（集合）</p> 
<p>​ 容器适配器：在别的容器的基础上加上外壳 把原有的容器的基础上做一些限制和处理 如stack queue priority_queue</p> 
<p>​ 关联容器：set map multiset（关键词可以重复） multimap</p> 
<p>​ 无序关联容器：真正使用哈希表 从c++11开始 在关联容器的前面+unordered_</p> 
<p>​ 通用功能：</p> 
<p>​ begin() 存在数据 end() 无数据</p> 
<p>迭代器：容器和算法之间的桥梁，可以认为是一个特殊的指针，指明数据的来源和去处</p> 
<p>算法：如sort</p> 
<p>函数对象：谓词，比如在排序的时候按照从大到小还是从小到大 利用函数对象进行说明</p> 
<p>在竞赛中尽量不用vector 推荐数组 Vector为动态数组</p> 
<h4><a id="_360"></a>栈</h4> 
<p>hdu 1237 自己做</p> 
<h4><a id="_364"></a>队列</h4> 
<p>大量删除操作 绝对别用vector</p> 
<h4><a id="_370"></a>集合</h4> 
<p>set和map 本质是红黑树 Red Black Tree</p> 
<p>本身是有序的</p> 
<p>1 3 5 7 9</p> 
<p>使用必须有序</p> 
<p>A.lower_bound(k) x&gt;=</p> 
<p>A.upper_bound() x &gt;</p> 
<p>hdu 2094</p> 
<p>凡是选手进第一个集合</p> 
<p>失败者进第二个集合</p> 
<p>最终比较两个集合的差 如果差是1 产生冠军 否则没有冠军</p> 
<h4><a id="map_398"></a>map</h4> 
<p>关联容器 键值对 key =&gt; value 映射</p> 
<p>hdu 2648</p> 
<hr> 
<p>homework</p> 
<p>提交解题报告 用到哪些原理 基础知识 算法 源程序</p> 
<p>每一个程序至少5个测试数据 需要大规模测试数据 不能常规的</p> 
<h3><a id="0x03__418"></a>0x03 排序</h3> 
<h4><a id="_420"></a>插入排序</h4> 
<p>打扑克牌的插入方法，在部分有序的数列中不断插入新的元素</p> 
<pre><code class="prism language-c++">//c++
template&lt;class Type&gt;   //把类型抽象成参数  不再依赖于具体的数据类型
void insertion_sort(Type *a, int n){
    Type key;
    for(int i = 1; i &lt; n; i++){
        key = a[i];
        int j = i - 1;
        while(j &gt;= 0 &amp;&amp; a[j] &gt; key){
            a[j + 1] = a[j];
            j--;
        }
        a[i + 1] = key;
    }
}
</code></pre> 
<h4><a id="Merge_Sort_443"></a>归并排序（Merge Sort)</h4> 
<h4><a id="_451"></a>快速排序</h4> 
<h3><a id="0x04__457"></a>0x04 搜索技术</h3> 
<p>BFS DFS 深搜 广搜</p> 
<p>本质就是暴力搜索，走投无路就暴搜</p> 
<p>广搜索：一层一层拨开，先离我距离为1的 再距离我为我2的 采用队列！</p> 
<h4><a id="BFS_471"></a>BFS</h4> 
<p>宽搜：绝对不要自己手写队列</p> 
<pre><code class="prism language-c++">/*
  来存一个BFS的模板 
*/ 
int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};
int vis[1005][1005];   //做标记 是否访问过 
struct P{
    int x,y,z;
};

bool BFS(int x, int y, int mid){
	queue&lt;P&gt; q;
	q.push({x, y, a[x][y]});
	while(!q.empty()){
		P x = q.front();
		q.pop();
		//
		if(a[x.x][x.y] &lt;= mid){
			//如果走到头了   直接返回true 
			if(x.x == n) return true;
			//没走到头 继续往下走
			for(int k = 0; k &lt; 4; k++){
				int nx = x.x + dx[k];
				int ny = x.y + dy[k];
				//矩阵范围判断 
				if(nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m &amp;&amp; vis[nx][ny] == 0 &amp;&amp; a[nx][ny] &lt;= mid){
					q.push({nx, ny, max(x.z, a[nx][ny])});
					vis[nx][ny] = 1; //表示访问过了 
				}
			} 
			 
		} 
	}
    return false; 
}
</code></pre> 
<h4><a id="DFS_517"></a>DFS</h4> 
<p>深搜：自己手写栈</p> 
<h5><a id="_523"></a>回溯与剪枝</h5> 
<p>如果明确知道某个分支下面不可行 则不再向下走</p> 
<p>八皇后问题：</p> 
<p>不在一个斜线：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ∣ 
         
        
          i 
         
        
          − 
         
        
          j 
         
        
          ∣ 
         
        
          = 
         
        
          ∣ 
         
         
         
           x 
          
         
           i 
          
         
        
          − 
         
         
         
           x 
          
         
           j 
          
         
        
          ∣ 
         
        
       
         |i - j| = |x_i - x_j| 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.0572em;" class="mord mathnormal">j</span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span style="margin-right: 0.0572em;" class="mord mathnormal mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></span><br> 剪枝的过程中要不断check</p> 
<blockquote> 
 <pre><code class="prism language-c++">bool check(int c, int r){
for(int i = 0; i &lt; r; i++){
  if(col[i] != c &amp;&amp; abs(i - r) != abs(col[i] - c)){

  }
}
}
</code></pre> 
</blockquote> 
<h4><a id="_551"></a>深度迭代</h4> 
<h4><a id="ID_A_557"></a>ID A*</h4> 
<h4><a id="A_star_563"></a>A star</h4> 
<p>曼哈顿启发式算法<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ∣ 
         
         
         
           x 
          
         
           1 
          
         
        
          − 
         
         
         
           x 
          
         
           2 
          
         
        
          ∣ 
         
        
          + 
         
        
          ∣ 
         
         
         
           y 
          
         
           1 
          
         
        
          − 
         
         
         
           y 
          
         
           2 
          
         
        
          ∣ 
         
        
       
         |x_1 - x_2| + |y_1 - y_2| 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord"><span style="margin-right: 0.0359em;" class="mord mathnormal">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span style="margin-right: 0.0359em;" class="mord mathnormal">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></span></p> 
<h4><a id="_573"></a>双向广搜</h4> 
<h3><a id="0x05__585"></a>0x05 递推方程</h3> 
<p>分解问题的规模，以及问题的相关性</p> 
<p>列出递推方程进行求解问题</p> 
<ul><li> <p>必须有一个初始条件</p> </li><li> <p>计算时的常用三种方法：</p> 
  <ul><li> <p>替换法：首先猜测递推式的解，然后使用归纳法证明，如解决汉诺塔问题<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
          
           
            
            
              T 
             
            
              ( 
             
            
              n 
             
            
              ) 
             
            
              = 
             
             
             
               { 
              
              
               
                
                 
                  
                  
                    1 
                   
                  
                                                   
                   
                  
                    n 
                   
                  
                    = 
                   
                  
                    1 
                   
                  
                 
                
               
               
                
                 
                  
                  
                    2 
                   
                  
                    T 
                   
                  
                    ( 
                   
                  
                    n 
                   
                  
                    − 
                   
                  
                    1 
                   
                  
                    ) 
                   
                  
                    + 
                   
                  
                    1 
                   
                  
                             
                   
                  
                    n 
                   
                  
                    &gt; 
                   
                  
                    1 
                   
                  
                 
                
               
              
             
            
           
             T(n)= \begin{cases} 1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~n=1\\ 2T(n-1) + 1~~~~~~~~n&gt;1 \end{cases} 
            
           
         </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span style="margin-right: 0.1389em;" class="mord mathnormal">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 3em; vertical-align: -1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size4">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.69em;"><span class="" style="top: -3.69em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord">1</span></span></span><span class="" style="top: -2.25em;"><span class="pstrut" style="height: 3.008em;"></span><span class="mord"><span class="mord">2</span><span style="margin-right: 0.1389em;" class="mord mathnormal">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.19em;"><span class=""></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> <pre><code class="prism language-c++">void Hanoi(int n, tower x, tower y, tower z){
    if(n){
        Hanoi(n-1, x, y, z);
        Move(n, x, y);
        Hanoi(n-1, z, y, x);
    }
}
</code></pre> </li><li> <p>迭代法：针对T（n）进行推导 不带入具体数据</p> </li><li> <p>主方法：</p> </li></ul> </li></ul> 
<p>递归树：把中间的节点一分为2</p> 
<h3><a id="0x06__627"></a>0x06 高级数据结构</h3> 
<h4><a id="_629"></a>并查集</h4> 
<p>指的是不想交的集合 disjoint</p> 
<p>经典应用：连通子图、最小生成树Kruskal算法 最近共同祖先</p> 
<p>实现代码：</p> 
<pre><code class="prism language-c++">int parent[105];

// 并查集初始化
void UFset() {
    for (int i = 1; i &lt;= n; i++) {
        parent[i] = -1;
    }
}

int find(int i) {
	//update the value of temp
    int temp;
    for (temp = i; parent[temp] &gt;= 0; temp = parent[temp]);
    
    while (temp != i) {
        int t = parent[i];
        parent[i] = temp;
        i = t;
    }
    return temp;
}

// 合并两个集合
void merge(int a, int b) {
    int r1 = find(a);
    int r2 = find(b);
    int tmp = parent[r1] + parent[r2];
    if (parent[r1] &gt; parent[r2]) {
        parent[r1] = r2;
        parent[r2] = tmp;
    } else {
        parent[r2] = r1;
        parent[r1] = tmp;
    }
}

// Kruskal算法求最小生成树的总权值
int kruskal() {
    int sumWeight = 0;

    UFset(); // 初始化并查集
    for (int i = 1; i &lt;= m; i++) {
        int u = edges[i].u;
        int v = edges[i].v;
        // 如果 u 和 v 不在同一个集合中，选择该边
        if (find(u) != find(v)) {
            sumWeight += edges[i].w;
            merge(u, v); // 合并 u 和 v 所在的集合
            cnt++;
        }
        // 已选择的边数达到 n-1 条时，退出循环
        if (cnt == n - 1) {
            break;
        }
    }
    return sumWeight;
}
</code></pre> 
<h4><a id="_701"></a>二叉树</h4> 
<p>后序遍历：</p> 
<p>先往下走 先左后右 无右向上</p> 
<h4><a id="_709"></a>二叉搜索树</h4> 
<p>BST，比左孩子大，比右孩子小</p> 
<p>红黑树是其中一种 set和map就是基于红黑树的一种</p> 
<p>Treap树：在二叉搜索树的基础上增加了优先级</p> 
<p>意味着成为一个树堆（大根堆、小根堆）</p> 
<p>旋转：</p> 
<pre><code class="prism language-c++">void rotate(Node* &amp;o, int d){
    Node *k = o -&gt; son[d ^ 1];
    o 
}
</code></pre> 
<p>注意son[0] 表示左孩子</p> 
<p>son[1] 表示右孩子</p> 
<p>在竞赛中尽量别用平衡二叉树 太繁琐</p> 
<h4><a id="_740"></a>退化树</h4> 
<h4><a id="Treap_752"></a>Treap树（堆）</h4> 
<p>插入：</p> 
<p>删除：</p> 
<p>struct 可以视为一个类</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

struct Node{
    int x, y;
    Node(int x, int y){
        this -&gt; x = x;
        this -&gt; y = y;
    }
    void print(){
        cout &lt;&lt; x &lt;&lt; y;
    }
}

//或者真正用类  但是注意其他的方法都是private 所以需要先声明权限
class Node{
    public:
    int x, y;
    Node(int x, int y){
        this -&gt; x = x;
        this -&gt; y = y;
    }
    //或者：Node(int x, int y):x(x),y(y){}
    void print(){
        cout &lt;&lt; x &lt;&lt; y;
    }
}
int main(){
    
}
</code></pre> 
<h4><a id="Splay_810"></a>伸展树Splay</h4> 
<p>不要求树是平衡的 允许把任何结点放到根上去</p> 
<p>单旋</p> 
<p>三点共线旋</p> 
<p>三点不共线旋</p> 
<h4><a id="_822"></a>线段树</h4> 
<p>考查较少</p> 
<h4><a id="_832"></a>树状数组</h4> 
<p>往往和折半查找混合在一起用</p> 
<h3><a id="0x07__842"></a>0x07 分治法*</h3> 
<h4><a id="_844"></a>一般方法</h4> 
<p>分-将要求解的较大规模的问题分割成k个更小规模的子问题 注意子问题和子问题之间是独立的</p> 
<p>合-将求解出的小规模的问题的解合并为一个更大规模问题的解，自底向上逐步求出原来问题的解</p> 
<pre><code class="prism language-c++">SolutionType DandC(ProblemType P){
    ProblemType P1, P2,..., Pk;
    if(Small(P)) return S(P);
    else{
        Divide(P, P1, P2, P3, ... , Pk);
        Return Combine(DandC(P1), DandC(P2), ... , DandC(Pk));
    }
}
</code></pre> 
<h4><a id="_863"></a>求最大最小元</h4> 
<p>说白了就是求最大值和最小值</p> 
<p>传统法：规模不大可以用</p> 
<pre><code class="prism language-c++">maxmin(float a[], int n){
    max = min = a[0];
    for(int i = 1; i &lt; n; i++){
        if(max &lt; a[i]) max = a[i];
        else if(min &gt; a[i]) min = a[i];
    }
}
</code></pre> 
<p>分治法：</p> 
<p>构造树，每个子树的范围为除以二</p> 
<p>扩展：求次最大元 次最小元</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;climits&gt;

using namespace std;

const int N = 100;
float a[N];

void maxmin(int left, int right, float &amp;max, float &amp;second_max, float &amp;min, float &amp;second_min) {
    if (left == right) {
        max = a[left];
        second_max = INT_MIN;
        min = a[left];
        second_min = INT_MAX;
    } else if (left + 1 == right) {
        if (a[left] &gt; a[right]) {
            max = a[left];
            second_max = a[right];
            min = a[right];
            second_min = a[left];
        } else {
            max = a[right];
            second_max = a[left];
            min = a[left];
            second_min = a[right];
        }
    } else {
        int mid = left + (right - left) / 2;
        float lmax, left_second_max, lmin, left_second_min;
        float rmax, right_second_max, rmin, right_second_min;
        maxmin(left, mid, lmax, left_second_max, lmin, left_second_min);
        maxmin(mid + 1, right, rmax, right_second_max, rmin, right_second_min);

        // Update max
        if (lmax &gt; rmax) {
            max = lmax;
            // Check if rmax is greater than left_second_max or not
            if (rmax &gt; left_second_max) {
                second_max = rmax;
            } else {
                second_max = left_second_max;
            }
        } else {
            max = rmax;
            // Check if lmax is greater than right_second_max or not
            if (lmax &gt; right_second_max) {
                second_max = lmax;
            } else {
                second_max = right_second_max;
            }
        }

        // Update min
        if (lmin &lt; rmin) {
            min = lmin;
            // Check if rmin is less than left_second_min or not
            if (rmin &lt; left_second_min) {
                second_min = rmin;
            } else {
                second_min = left_second_min;
            }
        } else {
            min = rmin;
            // Check if lmin is less than right_second_min or not
            if (lmin &lt; right_second_min) {
                second_min = lmin;
            } else {
                second_min = right_second_min;
            }
        }
    }
}

int main() {
    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }

    float max, second_max, min, second_min;
    maxmin(0, n - 1, max, second_max, min, second_min);

    cout &lt;&lt; max &lt;&lt; " " &lt;&lt; second_max &lt;&lt; endl;
    cout &lt;&lt; second_min &lt;&lt; " " &lt;&lt; min &lt;&lt; endl;

    return 0;
}
</code></pre> 
<h4><a id="_982"></a>二分搜索</h4> 
<p>每次砍一半，效率较高</p> 
<p>扩展：三分搜索</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

/*
三分搜索
*/

const int N = 101;
int a[N];
int n;

int ternarySearch(int find){
	int left = 0;
	int right = n - 1;
	
	while(left &lt;= right){
		int mid1 = left + (right - left) / 3;
		int mid2 = right - (right - left) / 3;
		
		//给出结果 
		if(a[mid1] == find){
			return mid1;
		}
		if(a[mid2] == find){
			return mid2;
		}
		
		//调整查找范围
		if(find &lt; a[mid1]){
			right = mid1 - 1;
		} 
		else if(find &gt; a[mid2]){
			left = mid2 + 1;
		}
		//在中间 
		else{
			left = mid1 + 1;
			right = mid2 - 1;
		}
		
	}
	return -1; 
}


int main(){
	cin &gt;&gt; n;   
	for(int i = 0; i &lt; n; i++){
		cin &gt;&gt; a[i];
	}
	int find;
	cin &gt;&gt; find;
	int re = ternarySearch(find);
	cout &lt;&lt; re;
	return 0;
}
</code></pre> 
<h4><a id="_1054"></a>排序问题</h4> 
<ul><li>二路归并排序</li></ul> 
<p>两段有序序列</p> 
<p>然后谁小把谁拉下来</p> 
<pre><code class="prism language-c++">//Merge

</code></pre> 
<ul><li>快速排序</li></ul> 
<p>划分：选定一个记录作为轴值，以轴值为基准将整个序列划分为两个子序列，把比轴值小的放左边，比轴值大的放右边</p> 
<p>左右寻找的方法：最左边放i 最右边放j 然后同时向中间缩，根据大小不断交换</p> 
<pre><code class="prism language-c++">void QuickSort(int a[], int p, int r){
    if(p &lt; r){
        int q = Partition(a, p, r);
        QuickSort(a, p, p - 1);  //对左半段排序
        QuickSort(a, p + 1, r);  //对右半段排序
    }
}
</code></pre> 
<pre><code class="prism language-c++">int Partition(int a[], int p, int r){
    int i = p, j = r + 1;
    int x = a[p];
    while(ture){
        while(a[++i] &lt; x);
        while(a[--j] &gt; x);
        
    }
}
</code></pre> 
<p><strong>主元选择：</strong></p> 
<ul><li>随机选(不做要求)</li></ul> 
<pre><code class="prism language-c++">
</code></pre> 
<ul><li>线性时间选择</li></ul> 
<pre><code class="prism language-c++">int RandomizedSelect(int a[], int p, int r, int k){
    if(p == r) return a[p];
    int i = RandomizedPartition(a, p, r);
    j = i - p + 1;
    if(k &lt;= j) return RandomizedSelect(a, p, i, k);
    else return RandomizedSelect(a, i + 1, r, k - j);
}
</code></pre> 
<p>划分：n -&gt; 3/4 n</p> 
<p>五个一组进行划分 然后每组组内进行排序</p> 
<blockquote> 
 <p>1 2 3 4 5</p> 
 <p>2 3 4 5 6</p> 
 <p>. . . | . . .</p> 
 <hr> 
 <p>. . . | . . .</p> 
 <p>. . . | . . .</p> 
</blockquote> 
<p>这样划分后左上角一定比中间的小 右下角一定比中间的大</p> 
<p>前面找一个大的 与后面找一个小的地方进行交换</p> 
<blockquote> 
 <p>原理：</p> 
 <p>选择一个基准元素</p> 
 <p>然后从两端向基准元素探测，直到右边的比基准元素小，左边的比基准元素大，我们进行比较，如果这两个探测的元素还是原位置，没有交界，则这两个元素互换位置。因为我们的目的就是基准元素左边的比它小，右边的比它大</p> 
 <p>当ij相遇，则交换基准元素位置和相遇位置元素</p> 
 <p>对左右分割段采用递归调用重复操作</p> 
</blockquote> 
<p>完整代码：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt; 
using namespace std;

/**
* 分治法实现快速排序
**/ 
int a[100005];
int n;
 
int Partition(int l, int r){
	int i = l - 1;
	int j = r + 1;
	int x = i + j &gt;&gt; 1; //选择主元      右除 
	while(i &lt; j){
		do{
			i ++;
		}while(a[i] &lt; a[x]);
		do{
			j --;
		}while(a[j] &gt; a[x]);
		if(i &lt; j) swap(a[i], a[j]);
	}
	return j; 
} 
 
void quickSort(int l, int r){
	if(l &lt; r){
		//pos作为分隔元素 对前后进行排练 
		int pos = Partition(l, r);
		quickSort(l, pos);
		quickSort(pos + 1, r); 
	}
}
//数组就从下标为0开始吧 
int main(){
	cin &gt;&gt; n;
	for(int i = 0; i &lt; n; i ++){
		cin &gt;&gt; a[i];
	}	
	quickSort(0, n - 1);
	
	for(int i = 0; i &lt; n; i++){
		cout &lt;&lt; a[i] &lt;&lt; " ";
	}
	return 0;
}
</code></pre> 
<h4><a id="_1208"></a>选择问题</h4> 
<p>选第k小</p> 
<p>分治法思想：</p> 
<p>一趟划分 分成两个左右子表 主元是随机选的</p> 
<p>然后主元+左子表个数为p 如果k=p直接找到 如果k&lt;p 则只在前面找 后面直接舍弃</p> 
<p>注意如果k &gt; p时 在右边找的话要找第p-k小</p> 
<p>二次选中法确定主元</p> 
<h4><a id="_1228"></a>斯特拉森</h4> 
<h3><a id="0x08_Dynamic_ProgrammingDP_1240"></a>0x08 动态规划（Dynamic Programming，DP）*</h3> 
<h4><a id="_1242"></a>定义</h4> 
<p>运筹学的一个分支</p> 
<p>与分治法的区别：</p> 
<ul><li> <p>子问题与子问题之间有交叉，重叠子问题 只解一次 =&gt; 所以效率比较高</p> </li><li> <p>并且这个问题满足最优性原理（问题的最优解包含了子问题的最优解）</p> </li><li> <p>无后向性</p> </li></ul> 
<p>满足上面三个条件，可用DP</p> 
<p>实质就是动态的表格题， 用数组来保存结果, 就是在填dp数组的表</p> 
<p>表格是动态的，每次都在修订</p> 
<blockquote> 
 <p>大部分是从后往前搞，把原问题转化为子问题，缩小问题规模 即自底向上</p> 
</blockquote> 
<h4><a id="_1262"></a>硬币组合</h4> 
<h4><a id="01__1276"></a>0/1 背包问题</h4> 
<p>特殊点在于物品无法分割 ，只能全放或者全不放，这如果使用贪心算法就可能会存在一些空间的过度浪费</p> 
<p>从右边往左边选f（j，X） = max{f(j-1, X), f(j-1, X-wj) + pj}</p> 
<p>两步：</p> 
<pre><code class="prism language-c++">dp[i][j] = max{dp[i][j-1], dp[i-wj][j-1] + vj}
</code></pre> 
<p>构造两个二维表格进行存储数据</p> 
<p><img src="https://images2.imgbox.com/3e/5c/Y8DSvu7A_o.png" alt="image-20240521110611820"></p> 
<blockquote> 
 <p>解释含义：</p> 
 <p>c 表示当背包容量为c的时候 能放入的最大价值</p> 
 <p>i 表示只选择i个的物品的情况，注意这里按顺序选择就好 比如i = 2就是计算装前两个的情况</p> 
</blockquote> 
<p>表格数据推导：</p> 
<p>当i = 1的时候，只判断第1个物品，c为1到9都装不下 当c=10 也就是背包容量为10的时候，可以装装下，价值为24，当背包容量继续扩大，那包装下的啊</p> 
<p>当i = 2的时候，判断第1个和第2个物品，当c=1的时候，针对物品2列式子，有两种可能 针对上一个判断</p> 
<p>f（2,1）= f(1, 1-3) + 2 = f(1, -2) + 2 装入</p> 
<p>f（2,1） = f（1，1） 不装入</p> 
<p>在f函数中第一个参数表示第几个物品，第二个参数表示背包容量情况</p> 
<p>因为-2不符合实际要求，所以只能不装入，值为f（1,1）= 0</p> 
<p>以此类推，当c=3时</p> 
<p>f（2,3）=f(1, 3-3) + 2 = f(1, 0) + 2 = 2 装入</p> 
<p>f（2,3）=f（1,3） = 0 不装入</p> 
<p>选较大值 即为2</p> 
<p>代码实现：</p> 
<pre><code class="prism language-c++">//初始化  n行 m列
for(int i = 0; i &lt;= n; i++) f[i][0] = 0;
for(int i = 0; i &lt;= m; i++) f[0][i] = 0;
for(int i = 1; i &lt;= n; i++){
    for(int j = 1; j &lt;= m; j++){
        //放
        if(j &gt;= w[i]){
            f[i][j] = max(f[i - 1][j - w[i]] + p[i], f[i - 1][j]);
        }
        //不放
        else{
            f[i][j] = f[i - 1][j];
        }
    }
}
printf("%d\n", f[n][m]);
</code></pre> 
<p>例题：</p> 
<p><img src="https://images2.imgbox.com/0b/7e/OfH5xUPO_o.png" alt="image-20240608002609033"></p> 
<p><img src="https://images2.imgbox.com/b1/5b/u4i66ZCD_o.png" alt="image-20240608002621921"></p> 
<p><img src="https://images2.imgbox.com/21/58/elJ3gp9D_o.png" alt="image-20240608002630493"></p> 
<p>参考：https://cloud.tencent.com/developer/article/2109840</p> 
<h4><a id="_1355"></a>滚动数组</h4> 
<h4><a id="_1361"></a>最短路径问题</h4> 
<p>例题：</p> 
<p><img src="https://images2.imgbox.com/57/b6/bSzyZ61F_o.png" alt="image-20240608001557178"></p> 
<p>从结果往前推，一层一层进行</p> 
<p><img src="https://images2.imgbox.com/0e/46/A76nYyGe_o.png" alt="image-20240608001632681"></p> 
<p><img src="https://images2.imgbox.com/a7/aa/IQDL9KOE_o.png" alt="image-20240608001641617"></p> 
<h4><a id="LCS_1377"></a>最长公共子序列（LCS）</h4> 
<p>实例：</p> 
<p>X : A <mark>B</mark> <mark>C</mark> <mark>B</mark> D <mark>A</mark> B</p> 
<p>y : <mark>B</mark> D <mark>C</mark> A <mark>B</mark> <mark>A</mark></p> 
<p>子序列的定义就是按照下标严格递增</p> 
<p>考察末尾字符</p> 
<p>如果想要进行切分，条件在于末尾字符要相同，否则去掉末尾字符可能会遗漏一些公共子序列</p> 
<p>相等的话则一定是公共子序列啦，所以 是删除后求最优解 然后结果加上末尾相同的个数</p> 
<p>构建过程：</p> 
<p><img src="https://images2.imgbox.com/b4/6b/r8eT8vEF_o.png" alt="image-20240521092805873"></p> 
<p>回溯代码：</p> 
<pre><code class="prism language-c++">void LCS(int i, int j, X, S){
    if(i == 0 || j == 0) return;
    if(S[i][j] == 1){
        LCS(i - 1, j - 1);
        cout &lt;&lt; a[i];
    }
    else if(S[i][j] == 2) LCS(i - 1, j);
    else LSC(i, j - 1);
}
</code></pre> 
<p>时间复杂度 ： O（m + n)</p> 
<p>例题：</p> 
<p><img src="https://images2.imgbox.com/c7/d6/EmNsH9vO_o.png" alt="image-20240608001808421"></p> 
<p><img src="https://images2.imgbox.com/84/a6/bTQ51s1U_o.png" alt="image-20240608001818304"></p> 
<p>简单来说就是如果行列的字符相同 则是左上角的值+1</p> 
<p>如果不相同，则是左边和上面的值比较 取较大值 如果两值相等 直接数据来源于上方</p> 
<p>参考：https://blog.csdn.net/2301_79582459/article/details/139198609</p> 
<h4><a id="__LIS__1431"></a>最少拦截问题 =&gt; LIS 最长递增子序列</h4> 
<p>hdu1257</p> 
<p>举例:</p> 
<pre><code class="prism language-txt">3 1 5 2 4 6

递增序列：
1 2 4 6 （LIS）
1 5 6
3 4 6
1 5
</code></pre> 
<blockquote> 
 <p>以3结尾：dp[0] = 1 数据长度</p> 
 <p>以1结尾：dp[1] = 1</p> 
 <p>dp[2] = 2</p> 
 <p>dp[i] = max{dp[i], dp[j]} + 1 (a[j] &lt; a[i])</p> 
</blockquote> 
<blockquote> 
 <ol><li>找出最优解的性质，并刻画其结构特征</li><li>递归地定义最优值</li><li>以自底向上</li><li></ol> 
</blockquote> 
<p>存模板：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100010;
int a[N],q[N];     //a是原数组  q是需要维护的数组存储递增子序列 
int n;
int main()
{
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i ++ ) scanf("%d", &amp;a[i]);
    int len = 0;
    for (int i = 0; i &lt; n; i ++ )
    {
        int l = 0, r = len;
        //二分 不理解？？ 
        while (l &lt; r)
        {
            int mid = l + r + 1 &gt;&gt; 1;
            if (q[mid] &lt; a[i]) l = mid;
            else r = mid - 1;
    	}
        len = max(len, r + 1);
        q[r + 1] = a[i];    //不断给q插值 
    }
    printf("%d\n", len);
    return 0;
}
</code></pre> 
<h4><a id="_1498"></a>矩阵连乘问题</h4> 
<p>每行 和 每列 连乘相加 放到元素位置</p> 
<p>乘法次数 10 * 100 100 * 5 = &gt; 10 * 100 * 5 ！是这样的</p> 
<p>在位置k处切一道 左边最小 + 右边最小</p> 
<p>画表 记录 在数组中</p> 
<p>两个矩阵为4,6 6,10</p> 
<p>次数为4 * 6 * 10</p> 
<p>一般设置两个表</p> 
<p>一个存放最优解的值 另一个存放如何切分才能得到最优解</p> 
<p>设置数组</p> 
<p>对于一系列矩阵<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           A 
          
         
           i 
          
         
         
         
           A 
          
          
          
            i 
           
          
            + 
           
          
            1 
           
          
         
        
          . 
         
        
          . 
         
        
          . 
         
         
         
           A 
          
         
           j 
          
         
         
        
          m 
         
        
          [ 
         
        
          i 
         
        
          ] 
         
        
          [ 
         
        
          j 
         
        
          ] 
         
        
          表示 
         
         
         
           A 
          
         
           i 
          
         
        
          到 
         
         
         
           A 
          
         
           j 
          
         
        
          的最小乘法次数 
         
        
       
         A_iA_{i+1}...A_j\\ m[i][j]表示A_i到A_j的最小乘法次数 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9694em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span style="margin-right: 0.0572em;" class="mord mathnormal mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 1.0361em; vertical-align: -0.2861em;"></span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span style="margin-right: 0.0572em;" class="mord mathnormal">j</span><span class="mclose">]</span><span class="mord cjk_fallback">表示</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">到</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span style="margin-right: 0.0572em;" class="mord mathnormal mtight">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">的最小乘法次数</span></span></span></span></span></span></p> 
<p><img src="https://images2.imgbox.com/60/02/DXk5902T_o.png" alt="image-20240607205019552"></p> 
<p><img src="https://images2.imgbox.com/5f/fc/nrFJYZN3_o.png" alt="image-20240607205413732"></p> 
<p>对于n个矩阵 使用q这个一维数组 n+1个元素就够了</p> 
<p>例题：</p> 
<p><img src="https://images2.imgbox.com/3f/78/TI0hjOSl_o.png" alt="image-20240608001717948"></p> 
<p><img src="https://images2.imgbox.com/45/58/YjmhrebA_o.png" alt="image-20240608001741257"></p> 
<h3><a id="0x09__1545"></a>0x09 基础语法</h3> 
<p>引用：</p> 
<pre><code class="prism language-c++">int a = 5;
int &amp;x = a;   //x作为a的一个引用
x = 4;
printf("%d", a);  //输出是4
</code></pre> 
<h3><a id="0x10__1558"></a>0x10 二分答案</h3> 
<h4><a id="_1560"></a>概念</h4> 
<p>使用二分查找需要满足：一定要有序 单调性</p> 
<p>识别题目：存在最大的最少 最少的最大这类字眼</p> 
<pre><code class="prism language-c++">#include &lt;cstdio&gt;
int a[1000000], n;  //全局变量自动赋值为0
//如果是局部变量 记得赋值0 然后使用sum++ 这类函数 否则是随机数进行++

/**
 * 基本二分查找实现
*/
int check(int key){
    int left = 0, right = n - 1, mid;
    while(left &lt;= right){   //一定是小于等于
        mid = (left + right) &gt;&gt; 1;   //这就是除2  其实右移和除2不是一回事 因为在正数情况下无影响 负数存在向0取整-3 右移是-2  除2是-1
        if(key == a[mid]) return 1;
        if(key &gt; a[mid]){
            left = mid + 1;
        }
        else if(key &lt; a[mid]){
            right = mid - 1;
        }

    }
    return 0;   //在win下不写也能过 但是在Linux中有问题
}
</code></pre> 
<p>例题：洛谷 P1873</p> 
<p>看完题目一定要看一下题目范围 初步判断一下这个题目是否需要开long long</p> 
<pre><code class="prism language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

/**
 * 定义变量：
 * 1. 尽量全局
 * 2. 尽量见词知意
 * 
*/
int n, m, l, r = 1e9, mid;    //1e9=10的9次方
long long a[1000005], sum;

int main(){
    scanf("%d%d", &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++){
        scanf("%lld", &amp;a[i]);
    }
    while(l &lt;= r){ //二分结果：1. rl位置关系 2. l = r + 1 
        sum = 0;  //清零
        mid = (l + r) / 2;
        for(int i = 1; i &lt;= n; i ++){
            if(a[i] &gt; mid){
                sum += a[i] - mid;
            }
        }
        //可以写sum &gt;= m  然后可以删除掉最后else的部分 因为相等时l定住不动 r一点点靠近
        if(sum &gt; m){
            l = mid + 1;
        }
        else if(sum &lt; m){
            r = mid - 1;
        }
        //仅仅这个题中符合该条件
        else{
            cout &lt;&lt; mid;
            return 0;
        }
    }
    cout &lt;&lt; r;   //需要分析清楚
    return 0;
}
</code></pre> 
<p>P1182 数列分段 SectionII</p> 
<p>P1824 进击的奶牛</p> 
<pre><code class="prism language-c++">//P1824 进击的奶牛
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,c,a[100005];
int check(int mid){
	int pos=1;
	int k=c;
	while(--k){
		pos=lower_bound(a+1, a+n+1, a[pos]+mid)-a;
		if(pos==n+1) {
			return 0;
		}
	}
	return 1;	
}
int main(){
	scanf("%d%d",&amp;n,&amp;c);
	for(int i=1; i&lt;=n; i++) scanf("%d",&amp;a[i]);
	sort(a+1, a+n+1);
	int l=1,r=1e9;
	while(l&lt;=r){
		int mid=(l+r)&gt;&gt;1;
		if(check(mid)) l=mid+1;
		else r=mid-1;		
	}
	cout&lt;&lt;r;
	return 0;
}

/*
二分答案
这里二分的是奶牛之间的间隔 

*/
</code></pre> 
<h4><a id="_1694"></a>练习</h4> 
<p>课后oj例题：</p> 
<p>A：奶茶店选址</p> 
<p>B：野外探险</p> 
<blockquote> 
 <p>分析：</p> 
 <p>D天活动，N份干粮，N份粮食进行编号，小明从小到大开始吃 花费D天全部吃完</p> 
 <p>每份粮食能量值为Hi 每天获得能量是当天吃下的所有干粮的能量值之和 （每天吃或者不吃 吃多少都不一定）</p> 
 <p>每天的能量会在第二天开始时消耗掉一半 注意是整除的一半</p> 
 <p>设计方案，让小明获得能量值最小的那一天最大 ！ 关键字眼（最小的最大）</p> 
</blockquote> 
<blockquote> 
 <p>思考：</p> 
 <p>对答案进行二分</p> 
 <p>答案的最小值是1 最大一定要设置的大一点 预测一下答案范围</p> 
</blockquote> 
<blockquote> 
 <p>解决：</p> 
 <p>每一天都要大于mid 所以不断吃 直到大于mid换下一天 看看能否正好满足天数</p> 
</blockquote> 
<p>代码：</p> 
<pre><code class="prism language-c++">#include&lt;bits/stdc++.h&gt;

using namespace std;
int N, D;
int a[50005];

int check(int mid){
	int k = 1;  //表示第几份食物 
	int sum[D + 5];
	//该函数的作用是给sum赋值为0  N个食物  D天 
	memset(sum, 0, sizeof(sum));
	//第1天灌食   因为mid是最小 所以每天获得的大于mid才能到下一天 
	while(sum[1] &lt; mid &amp;&amp; k &lt;= N){
		sum[1] += a[k];   //吃能量 
		k++;
	} 
	if(sum[1] &lt; mid){
		return 0;
	}    
	//第2天往后 
	for(int i = 2; i &lt;= D; i++){
		sum[i] = sum[i - 1] / 2;      //获取前一天的能量值 
		while(sum[i] &lt; mid &amp;&amp; k &lt;= N){    //注意啊 N份食物 可以一直吃 所以有等号 要不然结果不对！ 
			sum[i] += a[k];
			k++; 
		} 
		if(sum[i] &lt; mid){
			return 0;
		}      
	} 
	return 1;
}

int main(){
	scanf("%d%d", &amp;N, &amp;D); 
	for(int i = 1; i &lt;= N ; i++){
		scanf("%d", &amp;a[i]); 
	}
	//需要思考 二分的是答案 对答案进行二分查找 作为最后的结果不断带进场景中做check 
	int l = 1, r = 1e9; 
	while(l &lt;= r){
		int mid = (l + r) &gt;&gt; 1;
		if(check(mid)){
			l = mid + 1;
		} 
		else r = mid - 1;
	} 
	cout &lt;&lt; r;
	return 0;
} 
</code></pre> 
<p>C：龙年邮票</p> 
<blockquote> 
 <p>分析：集邮票活动，一套完整的龙年邮票共有n种不同的造型</p> 
 <p>小明有第i种造型的邮票ai张，m张万能邮票</p> 
 <p>万能邮票可以抵任意一张，问一共能集齐多少套邮票</p> 
 <p>非常像之前支付宝的集五福啊！还有一个万能福</p> 
</blockquote> 
<blockquote> 
 <p>思考：</p> 
 <p>同样是对答案进行二分查找</p> 
</blockquote> 
<p>代码：(有点想不到)</p> 
<pre><code class="prism language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n, m;
int a[100]; 
int b[100];


int check(int mid){
	int sum=0;     //记录万能票使用数量 
    memcpy(b,a,sizeof b); //把a的值赋给b  对b进行操作 
    for(int i = 1;i &lt;= n; i++)
    {
        int x = mid - a[i];   //套数 - 当前品种数量    1 2 3   3       0 1
		//如果套数小于当前品种邮票数量 正常执行 检测下一个品种的邮票 
        if(x &lt;= 0)
          continue;
        //如果当前品种邮票不足以支撑目标套数 则启动万能票  差x张     2        3
        else
        {
            for(int j = 1; j &lt;= n; j++)
            {
                if(i != j &amp;&amp; b[j] &lt; x) //如果存在其他品种 比当前差值还少 直接完蛋 因为万能票只能用一次 
                  return 0;
                else if(i != j)     //否则 对其他品种减去万能票数 
                   b[j] -= x;
            }
        }
        sum += x;
    }
    if(sum &lt;= m)
      return 1;
    return 0;
	
	
}

int main(){
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1; i &lt;= n; i++){
		cin &gt;&gt; a[i];
	}
	//把所有存在的邮票 按数量从小到大排列 
	sort(a + 1, a + 1 + n);
	
	int l = 1, r = 1e9;
	while(l &lt;= r){
		int mid = (l + r) &gt;&gt; 1;
		if(check(mid)){
			l = mid + 1;
		}
		else{
			r = mid - 1;
		}
	}
	cout &lt;&lt; r;
	return 0;
} 
</code></pre> 
<p>D : 消耗的能量</p> 
<blockquote> 
 <p>分析：n行 m列数字矩阵 第一行均为0 从第一行出发 到第n行任意位置结束</p> 
 <p>规定消耗能量为每行行走过的格子各自和的最大值</p> 
 <p>求所有路径中，小明消耗能量的最小是多少</p> 
</blockquote> 
<blockquote> 
 <p>思考：最大 最小！！！ 二分答案的关键词！！！</p> 
 <p>然后涉及到路径 那么我们考虑使用bfs 去探测路径</p> 
 <p>然后在探测路径的过程中，需要去对每一行的横向进行能量探测，如果能量大于我们的二分答案值 则换下一个答案</p> 
</blockquote> 
<pre><code class="prism language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int n, m;
int a[1005][1005];


/*
  来存一个BFS的模板 
*/ 
int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};
int vis[1005][1005];   //做标记 是否访问过 
struct P{
    int x,y,z;
};

bool BFS(int x, int y, int mid){
	queue&lt;P&gt; q;
	q.push({x, y, a[x][y]});
	while(!q.empty()){
		P x = q.front();
		q.pop();
		//
		if(a[x.x][x.y] &lt;= mid){
			//如果走到头了   直接返回true 
			if(x.x == n) return true;
			//没走到头 继续往下走
			for(int k = 0; k &lt; 4; k++){
				int nx = x.x + dx[k];
				int ny = x.y + dy[k];
				//矩阵范围判断 
				if(nx &gt;= 1 &amp;&amp; ny &gt;= 1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m &amp;&amp; vis[nx][ny] == 0 &amp;&amp; a[nx][ny] &lt;= mid){
					q.push({nx, ny, max(x.z, a[nx][ny])});
					vis[nx][ny] = 1; //表示访问过了 
				}
			} 
			 
		} 
	}
    return false; 
}
int check(int mid){ 
	memset(vis, 0, sizeof vis); //对vis数组 全部赋值 为0  表示没有访问过
	bool ans = false;
	for(int i = 1; i &lt;= m; i++){
		ans = ans || BFS(2, i, mid);  //第1行是初始行 全部为0 所以从第2行开始BFS 
	} 
	return ans;
}
int main(){
	cin &gt;&gt; n &gt;&gt; m;
	for(int i = 1; i &lt;= n; i++){
		for(int j = 1; j &lt;= m; j++){
			cin &gt;&gt; a[i][j];
		}
	}
	int l = 1, r = 1005;
	while(l &lt;= r){
		int mid = (l + r) &gt;&gt; 1;
		if(!check(mid)){    //思考一下返回的是什么 不要光想着套模板！！ 
			l = mid + 1;
		}
		else{
			r = mid - 1;
		}
	}
	cout &lt;&lt; l;
	return 0;
}
</code></pre> 
<h4><a id="_1959"></a>整数域二分</h4> 
<p>洛谷 P1577 切绳子</p> 
<p>有一个问题就是如果答案结果是1.99</p> 
<p>与2.00进行相减判断 但是不通过 因为二进制表示的问题，0.1无法用二进制精确表示，所以在二进制相减中可能存在问题</p> 
<p>Specual Judge问题，不用太在意格式 因为最终的评判标准时是与标准值作差 然后进行评判的 一般说保留三位 但是要考虑精度问题 尽量保留5位</p> 
<p>转换方法：将小数转化到整数 先扩大 后结果缩小</p> 
<h4><a id="_1973"></a>实数域二分</h4> 
<p>P1570 KC 喝咖啡</p> 
<p>P1678 烦恼的高考志愿</p> 
<h3><a id="0x11_Greedy_1993"></a>0x11 贪心法（Greedy）*</h3> 
<h4><a id="_1995"></a>导言</h4> 
<p>找零问题：</p> 
<p>每一步的判断<strong>是当前的最优选择</strong>，但是需要思考局部最优能否达到全局最优的问题</p> 
<p>局部最优代替整体最优，其最终结果近似最优解</p> 
<p>有点像背包问题啊</p> 
<blockquote> 
 <p>给个例子：</p> 
 <p>xi = {1, 5, 10, 20, 50, 100}</p> 
 <p>y = <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ∑ 
          
          
          
            w 
           
          
            i 
           
          
          
          
            x 
           
          
            i 
           
          
         
        
          \sum w_ix_i 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.6em; vertical-align: -0.55em;"></span><span class="mop op-symbol large-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span style="margin-right: 0.0269em;" class="mord mathnormal">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> 
 <p>求min<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           ∑ 
          
          
          
            w 
           
          
            i 
           
          
         
        
          \sum w_i 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.6em; vertical-align: -0.55em;"></span><span class="mop op-symbol large-op" style="position: relative; top: 0em;">∑</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span style="margin-right: 0.0269em;" class="mord mathnormal">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> 
</blockquote> 
<p>可行解：问题给定一些约束条件，可以满足</p> 
<p>最优解：</p> 
<hr> 
<p>通过分步决策的方法，每一步决策产生一个向量</p> 
<hr> 
<p>流程：</p> 
<ol><li>存在可能解的集合</li></ol> 
<hr> 
<h4><a id="_2037"></a>背包问题</h4> 
<h5><a id="01__2039"></a>0/1 背包问题</h5> 
<p>物体不能分割 只有两种状态 装入或者不装</p> 
<h5><a id="_2049"></a>一般背包问题</h5> 
<p>物体可分割，可以把物体x的xi部分装入到背包中</p> 
<blockquote> 
 <p>贪心思路：</p> 
 <ol><li>价值最大</li><li>重量最轻</li><li>单位重量价值最大</li></ol> 
</blockquote> 
<p>方案一：按物体价值降序装包</p> 
<p>方案二：按物品重量非降序装包</p> 
<p>方案三：按物体价值与重量比值的降序装包 先装最大的</p> 
<h4><a id="_2071"></a>活动安排问题</h4> 
<p>按结束的时间进行排列</p> 
<h4><a id="_2081"></a>最佳合并模式</h4> 
<p>类似于哈夫曼树</p> 
<h3><a id="0x12__2095"></a>0x12 数论</h3> 
<h4><a id="_2097"></a>质数</h4> 
<h4><a id="_2105"></a>快速幂</h4> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
         
         
           a 
          
         
           b 
          
         
        
          ) 
         
        
            
         
        
          m 
         
        
          o 
         
        
          d 
         
        
            
         
        
          n 
         
        
       
         (a^b) ~mod~ n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.1491em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8991em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace nobreak"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace nobreak"> </span><span class="mord mathnormal">n</span></span></span></span></span></span></p> 
<p>快速幂就是解决上述问题</p> 
<p>算法的思想是：分治</p> 
<blockquote> 
 <p>区分一下分治和二分的区别：</p> 
 <p>二分是舍弃掉一半，而分治是不断划分 然后合而治之</p> 
</blockquote> 
<p><strong>模板：</strong></p> 
<p>递归代码：</p> 
<pre><code class="prism language-c++">int quickPow(int a, int b){
    if(b == 1) return a;
    if(b % 2 == 0){
        int t = quickPow(a, b/2);
        return t * t % mod;
    }
    else{
        int t = quickPow(a, b/2);
        t = t * t % mod;
        t = t * a % mod;
        return t;
    }
}
</code></pre> 
<p>非递归代码1：</p> 
<pre><code class="prism language-c++">int quickPow(int a, int b){
    int t = 
}
</code></pre> 
<p>补充：</p> 
<pre><code class="prism language-c++">while(b){
    b = b / 2;
}
</code></pre> 
<p>该式的时间复杂度为log n 级别的</p> 
<p>例题：P1226</p> 
<p>例题2：</p> 
<p><strong>数列求值</strong></p> 
<h4><a id="_2183"></a>矩阵快速幂</h4> 
<p>单位矩阵：主对角线上的元素都是1</p> 
<pre><code class="prism language-c++">void matrixMulti(){
    for(int i = 1; i &lt;= m; i++){
        for(int)
    }
}
</code></pre> 
<p>最关键的地方：</p> 
<p>不是矩阵乘幂的计算，而是如何得到一个可以用来形成乘幂计算的矩阵</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           S 
          
         
           n 
          
         
        
          = 
         
        
          1 
         
        
          ∗ 
         
         
         
           S 
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
        
          + 
         
        
          1 
         
        
          ∗ 
         
         
         
           f 
          
         
           n 
          
         
        
          + 
         
        
          0 
         
        
          ∗ 
         
         
         
           f 
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
         
         
         
           f 
          
          
          
            n 
           
          
            + 
           
          
            1 
           
          
         
        
          = 
         
        
          0 
         
        
          ∗ 
         
         
         
           S 
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
        
          + 
         
        
          1 
         
        
          ∗ 
         
         
         
           f 
          
         
           n 
          
         
        
          + 
         
        
          1 
         
        
          ∗ 
         
         
         
           f 
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
         
         
         
           f 
          
         
           n 
          
         
        
          = 
         
        
          0 
         
        
          ∗ 
         
         
         
           S 
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
        
          + 
         
        
          1 
         
        
          ∗ 
         
         
         
           f 
          
         
           n 
          
         
        
          + 
         
        
          0 
         
        
          ∗ 
         
         
         
           f 
          
          
          
            n 
           
          
            − 
           
          
            1 
           
          
         
        
       
         S_n=1*S_{n-1}+1*f_n+0*f_{n-1}\\ f_{n+1}=0*S_{n-1}+1*f_n+1*f_{n-1}\\ f_n=0*S_{n-1}+1*f_n+0*f_{n-1} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span style="margin-right: 0.0576em;" class="mord mathnormal">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8917em; vertical-align: -0.2083em;"></span><span class="mord"><span style="margin-right: 0.0576em;" class="mord mathnormal">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.9028em; vertical-align: -0.2083em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.9028em; vertical-align: -0.2083em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8917em; vertical-align: -0.2083em;"></span><span class="mord"><span style="margin-right: 0.0576em;" class="mord mathnormal">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.9028em; vertical-align: -0.2083em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8917em; vertical-align: -0.2083em;"></span><span class="mord"><span style="margin-right: 0.0576em;" class="mord mathnormal">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0576em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.9028em; vertical-align: -0.2083em;"></span><span class="mord"><span style="margin-right: 0.1076em;" class="mord mathnormal">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.1076em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2083em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></p> 
<h4><a id="_2211"></a>约数</h4> 
<p>求N的正约数集合：</p> 
<ul><li>试除法</li><li>倍数法</li></ul> 
<p>最大公约数和最小公倍数 P1029</p> 
<h4><a id="_2224"></a>扩欧算法</h4> 
<p>贝祖定理（斐蜀定理）</p> 
<h3><a id="0x13__2238"></a>0x13 图论</h3> 
<h4><a id="_2240"></a>基本概念</h4> 
<h4><a id="_2244"></a>无向图和有向图的连通性</h4> 
<p>割点：去掉这个点之后 剩下的图不连通 那么这个点就是割点</p> 
<p>割边：</p> 
<p>双连通问题：</p> 
<h3><a id="0x14__2258"></a>0x14 回溯法*</h3> 
<h4><a id="_2260"></a>基本概念</h4> 
<p>需要找出问题的最优解 在一定的约束下进行，使用回溯法</p> 
<p>设置一个目标函数，用来衡量每一个可能解的情况</p> 
<blockquote> 
 <p>搜索：</p> 
 <ol><li>以深度优先方式搜索解空间</li><li>在搜索过程中使用剪枝函数，避免无效搜索</li></ol> 
 <p>常用剪枝函数： 舍得！不行的就放弃 别挣扎</p> 
 <ol><li>用约束函数在扩展结点处减去不满足约束的子树 （不满足不可行）</li><li>用限界函数剪去得不到最优解的字数 （可行但不最优）</li></ol> 
</blockquote> 
<h4><a id="_2284"></a>涂色问题</h4> 
<blockquote> 
 <p>前提：</p> 
 <ul><li>不是优化问题，没有限界函数</li><li>搜索策略：深度优先</li><li>约束条件：相邻结点，不同颜色</li></ul> 
</blockquote> 
<h4><a id="4n_2300"></a>4/n-皇后问题</h4> 
<p>解向量 ：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          ( 
         
         
         
           x 
          
         
           1 
          
         
        
          , 
         
         
         
           x 
          
         
           2 
          
         
        
          , 
         
        
          . 
         
        
          . 
         
        
          . 
         
        
          , 
         
         
         
           x 
          
         
           n 
          
         
        
          ) 
         
        
       
         (x_1,x_2,...,x_n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span><br> 注意这个写法 直接限制了每一行只能放一个</p> 
<p>设置约束条件：</p> 
<p>限制列：i != j</p> 
<p>限制对角线：</p> 
<p>程序：</p> 
<pre><code class="prism language-c++">bool Place(int k, int i, int* ){
    for()
}
</code></pre> 
<h4><a id="01_2330"></a>0/1背包问题</h4> 
<h3><a id="0x15__2340"></a>0x15 分支限界法*</h3> 
<h4><a id="4_2342"></a>4-皇后问题</h4> 
<p>广度优先</p> 
<pre><code class="prism language-c++">//结构体模板
template &lt;class T&gt;
struct Node{
    T cost;
    Node* parent;
}

Node&lt;int&gt; t;  //创建结构体 意味着上面模板中的T为int
</code></pre> 
<p>注意上下界问题</p> 
<h3><a id="0x16__2367"></a>0x16 优先队列</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04c1f2eff839c3331d378058090f0bc6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java - JDK17语法新增特性（如果想知道Java - JDK17语法新增常见的特性的知识点，那么只看这一篇就足够了！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f53230ca56f5126a6bbfed6ec406b546/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AIGC专栏12——EasyAnimateV3发布详解 支持图&amp;文生视频 最大支持960x960x144帧视频生成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>