<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【递归、搜索与回溯】综合练习一 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/108d9078e1571fda80b633da2382dc4f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【递归、搜索与回溯】综合练习一">
  <meta property="og:description" content="综合练习一 1.找出所有子集的异或总和再求和2.全排列 II3.电话号码的字母组合4.括号生成 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.找出所有子集的异或总和再求和 题目链接：1863. 找出所有子集的异或总和再求和
题目描述：
先找出所有子集，然后把每个子集异或的和加起来返回去。
算法原理：
这道题和我们上一道思路完全是一模一样，
先画出决策树设计代码
全局变量
递归函数
细节：回溯、剪枝、递归出口 因为我们有上一道题的基础，我们直接就画出决策树
这里我们需要两个全局变量，一个path记录到沿途每个子集的异或，然后sum负责每个字节的异或和加起来。dfs函数，还是需要一个pos记录当前异或的位置，dfs(nums,pos)，回溯利用异或的规则，两个相同的数异或为0。这里也没有剪枝， 递归出口 循环结束就是递归出口。
class Solution { int sum=0; int path=0; public: int subsetXORSum(vector&lt;int&gt;&amp; nums) { dfs(nums,0); return sum; } void dfs(vector&lt;int&gt;&amp; nums,int pos) { sum&#43;=path; for(int i=pos;i&lt;nums.size();&#43;&#43;i) { path^=nums[i]; dfs(nums,i&#43;1); path^=nums[i]; // 恢复现场 } } }; 2.全排列 II 题目链接：47. 全排列 II
题目分析：
重复的数全排列后会有重复的结果，这道题就是要求去掉重乎之后的全排列
算法原理：
这道题几乎和全排列1 一模一样，我们就不在细说那些决策树怎么画，代码应该怎么写等等。这里主要就是剪枝的问题。
下面我们边画决策树变分析问题，把全排列所有不重复不漏的情况画出来，越详细越好。 我们只用关心四个位置，每个位置每次从数组中4个数选择一个树放到一个位置上就行了。只用选四次就行了。
第一次可以选第一个1、第二个1、第三个1、2，但是注意这里就存在剪枝的问题了，如果第一个位置还把第二个1和第三个1选上，此时就会存在重复问题！因为后面三个位置是从112中选的。
此时就出现了第一种剪枝情况
同一个节点的所有分支中，相同的元素只能选择一次
然后我们再往下走，第二个位置也可以从数组中4个数字中选任意一个。但是第一个1我们要把它剪掉，因为第一个位置已经把第一个1选过了，只能选一次。此时就有了第二种剪枝情况，这个是和全排列1一模一样的。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T14:45:21+08:00">
    <meta property="article:modified_time" content="2024-06-13T14:45:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【递归、搜索与回溯】综合练习一</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>综合练习一</h4> 
 <ul><li><a href="#1_7" rel="nofollow">1.找出所有子集的异或总和再求和</a></li><li><a href="#2_II_53" rel="nofollow">2.全排列 II</a></li><li><a href="#3_156" rel="nofollow">3.电话号码的字母组合</a></li><li><a href="#4_205" rel="nofollow">4.括号生成</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/bf/8f/H6aKUeM9_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<h2><a id="1_7"></a>1.找出所有子集的异或总和再求和</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/description/" rel="nofollow">1863. 找出所有子集的异或总和再求和</a></p> 
<p><strong>题目描述：</strong></p> 
<p><img src="https://images2.imgbox.com/b1/d7/i4VLv7e8_o.png" alt="在这里插入图片描述"></p> 
<p>先找出所有子集，然后把每个子集异或的和加起来返回去。<br> <img src="https://images2.imgbox.com/c1/64/8fuyU1nz_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong><br> 这道题和我们上一道思路完全是一模一样，</p> 
<ol><li>先画出决策树</li><li>设计代码<br> 全局变量<br> 递归函数<br> 细节：回溯、剪枝、递归出口</li></ol> 
<p>因为我们有上一道题的基础，我们直接就画出决策树<br> <img src="https://images2.imgbox.com/4b/f5/q92rVURC_o.png" alt="在这里插入图片描述"><br> 这里我们需要两个<strong>全局变量</strong>，一个path记录到沿途每个子集的异或，然后sum负责每个字节的异或和加起来。<strong>dfs函数</strong>，还是需要一个pos记录当前异或的位置，dfs(nums,pos)，<strong>回溯</strong>利用异或的规则，两个相同的数异或为0。这里也没有<strong>剪枝，</strong> <strong>递归出口</strong> 循环结束就是递归出口。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> path<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">subsetXORSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        sum<span class="token operator">+=</span>path<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>pos<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            path<span class="token operator">^=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            path<span class="token operator">^=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 恢复现场</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="2_II_53"></a>2.全排列 II</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/permutations-ii/description/" rel="nofollow">47. 全排列 II</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/0e/0e/7fBLaBLL_o.png" alt="在这里插入图片描述"></p> 
<p>重复的数全排列后会有重复的结果，这道题就是要求去掉重乎之后的全排列</p> 
<p><img src="https://images2.imgbox.com/09/7e/FmHwST0N_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong><br> 这道题几乎和全排列1 一模一样，我们就不在细说那些决策树怎么画，代码应该怎么写等等。这里主要就是剪枝的问题。</p> 
<p>下面我们边画决策树变分析问题，把全排列所有不重复不漏的情况画出来，越详细越好。 我们只用关心四个位置，每个位置每次从数组中4个数选择一个树放到一个位置上就行了。只用选四次就行了。</p> 
<p>第一次可以选第一个1、第二个1、第三个1、2，但是注意这里就存在剪枝的问题了，如果第一个位置还把第二个1和第三个1选上，此时就会存在重复问题！因为后面三个位置是从112中选的。<br> <img src="https://images2.imgbox.com/c0/e8/bOmqtkzT_o.png" alt="在这里插入图片描述"><br> 此时就出现了<strong>第一种剪枝情况</strong></p> 
<p><strong>同一个节点的所有分支中，相同的元素只能选择一次</strong></p> 
<p><img src="https://images2.imgbox.com/c8/19/lKYYDtJK_o.png" alt="在这里插入图片描述"></p> 
<p>然后我们再往下走，第二个位置也可以从数组中4个数字中选任意一个。但是第一个1我们要把它剪掉，因为第一个位置已经把第一个1选过了，只能选一次。此时就有了<strong>第二种剪枝情况</strong>，这个是和全排列1一模一样的。</p> 
<p><strong>同一个位置的数，只能使用一次</strong> ，<br> 还是用bool类型的check数组可以实现，check[i] = true 表明已经使用过了，<br> check[i] = false 说明还没有使用过。<br> <img src="https://images2.imgbox.com/7f/d7/D8ButwSi_o.png" alt="在这里插入图片描述"></p> 
<p>但是这里还会出现剪枝情况，第一个1不能用，那我可以把第二个1放在第二个位置，但是第三个1不能出现了，因为同一个节点分支相同的数只能出现一次！</p> 
<p><img src="https://images2.imgbox.com/22/87/C3DYdeHV_o.png" alt="在这里插入图片描述"><br> 接下来我们就不画了，我们就可以写代码了。代码逻辑和全排列1几乎一模一样，这里我们主要分析，剪枝应该怎么写。剪枝可以从两个角度写。其实就是两个if判定语句。<br> <strong>1.只关心 “不合法” 的分支。</strong> 不合法的直接不让递归下去<br> <strong>2.只关心 “合法” 的分支</strong> 合法的就递归<br> 虽然是两个角度，但是最终得到结果都是一样的。</p> 
<blockquote> 
 <p><strong>只关心 “不合法” 的分支</strong></p> 
</blockquote> 
<ol><li>当有一个位置已经选了这个数了下一个位置就不能在选这个位置，<strong>check[i] == true</strong></li><li>属于同一个分支节点，前面的数和当前的数相等 就不能选当前的数了。<strong>nums[i] == nums[i-1]</strong>，但是这里有一个问题，我们这个数组里面的数字是有序的，可以这样写，如果无序就不能这样写，因此<strong>最开始先对数组进行排序</strong>。但是还是有问题，目前nums[i] == nums[i-1]这个条件太广泛了，注意看它目前只适用于第一个位置中不选择相同数，但是在第二个位置中又出现第二个1可以选第三个1不选的情况。因此还要再加条件，注意我们是从第一个位置递归下去到第二个位置然后出现相同的位置不选，但是当我们递归返回的时候这个数又可以选了。这个check[i]==true是上一层的和当前属于第二层无关！我们关注的是同一层相同元素只能选一次。因此这个条件是<br> nums[i] == nums[i-1] &amp;&amp; check[i-1] == false，但是还不够，可能会有越界的风险，因此这个条件最终是 <strong>i != 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; check[i-1] == false</strong></li></ol> 
<p><img src="https://images2.imgbox.com/90/74/DfmKbdc3_o.png" alt="在这里插入图片描述"><br> 把上面两个条件组合在一起就得到<strong>只关心 “不合法” 的分支</strong><br> <img src="https://images2.imgbox.com/70/d3/5C9CfeTY_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>只关心 “合法” 的分支</strong></p> 
</blockquote> 
<ol><li>当一个数没人选的时候可以选这个数 <strong>check[i] == false</strong>，</li><li>但注意到同一层可能有相同的数，第一个相同的数没人选因为是第一次出现确实是可以选的，但是如果当前的数和前面的数相同即使当前数没人选也是不能选的，因此 还要满足 <strong>nums[i] != num[i-1]</strong> 只要这个数不和前面相同说明就是第一次出现了绝对可以选！。但是还有一种情况，如果有相同的数字，也就是 nums[i] != num[i-1] 不满足的情况，那就是满足 nums[i] == num[i-1] 前面数和后面数相同的情况，如果上一个位置选了前面的数，那走下到下一个位置的时候，因为这个数已经选过了check[i] == true，其实也就说明这个数是上一个位置的数，和我本次第二个位置选数无关，即使是相同的数子也没有关系，我也是能够选择这个后面相同的数。也就是要满足 <strong>check[i-1] == true</strong> 前面的相同数被上一个位置选了。还有最后一个情况，刚开始i==0肯定是第一次出现的数并且这个数字没人选的时候，可以选。</li></ol> 
<p><img src="https://images2.imgbox.com/16/69/SFb2F6wP_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> ret<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> check<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">permuteUnique</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 剪枝</span>
            <span class="token comment">// 1.只关心不合法</span>
            <span class="token comment">// if(check[i] == true ||(i != 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; check[i-1] == false))</span>
            <span class="token comment">//     continue;</span>
            
            <span class="token comment">// path.push_back(nums[i]);</span>
            <span class="token comment">// check[i]=true;</span>
            <span class="token comment">// dfs(nums);</span>
            <span class="token comment">// check[i]=false;</span>
            <span class="token comment">// path.pop_back();//恢复现场</span>


            <span class="token comment">// 2.只关心合法</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> check<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                check<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
                check<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
                path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//恢复现场</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="3_156"></a>3.电话号码的字母组合</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/" rel="nofollow">17. 电话号码的字母组合<br> </a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/28/40/TGnZY3ad_o.png" alt="在这里插入图片描述"><br> 就是数字对应的字符串进行排列组合。对于这种搜索啊、暴搜啊，我们已经知道要用到递归，回溯、剪枝了。<br> <img src="https://images2.imgbox.com/5c/49/o8h0fZ5s_o.png" alt="在这里插入图片描述"><br> <strong>算法原理：</strong><br> 有了前面的基础，这个题我们就不写那么步骤了，画出决策树，我们直接写出对应需要的东西。不过在此之前我们需要先将<strong>数字与字符串映射关系</strong>搞和，我们可以用哈希表映射，或者其他方法，这里最简单的就是弄一个字符串数组把数字和字符串映射一下。</p> 
<p>接下来就是画出决策树然后分析一下，首先需要两个<strong>全局变量</strong> ret记录结果，path记录每条路径到叶子节点的组合，<strong>递归函数</strong> 给我一个digits和数字然后递归函数把组合后的结果返回出来，相信它一定能完成任务。<strong>dfs(digits,pos)</strong>，然后<strong>回溯</strong> 记得恢复现场，<strong>递归出口</strong> 到叶子节点，这道题没有<strong>剪枝</strong>。</p> 
<p><img src="https://images2.imgbox.com/f2/60/wj3uss0K_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    string numberletter<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"abc"</span><span class="token punctuation">,</span><span class="token string">"def"</span><span class="token punctuation">,</span><span class="token string">"ghi"</span><span class="token punctuation">,</span><span class="token string">"jkl"</span><span class="token punctuation">,</span><span class="token string">"mno"</span><span class="token punctuation">,</span><span class="token string">"pqrs"</span><span class="token punctuation">,</span><span class="token string">"tuv"</span><span class="token punctuation">,</span><span class="token string">"wxyz"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>
    string path<span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>string digits<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ret<span class="token punctuation">;</span>

        <span class="token function">dfs</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> digits<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pos <span class="token operator">==</span> digits<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        string str<span class="token operator">=</span>numberletter<span class="token punctuation">[</span>digits<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            path<span class="token operator">+=</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4_205"></a>4.括号生成</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/generate-parentheses/description/" rel="nofollow">22. 括号生成</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/73/d2/YfXb7nNG_o.png" alt="在这里插入图片描述"><br> 给几对括号，然后把括号组合一下形成 有效括号<br> <img src="https://images2.imgbox.com/96/31/yVAHvagP_o.png" alt="在这里插入图片描述"><br> <strong>算法原理：</strong><br> 首先我们要知道什么是 <strong>有效括号的组合</strong><br> 1.左括号的数量 = 右括号的数量<br> 2.从头开始的任意一个子串，左括号数量 &gt;= 右括号数量</p> 
<p>如下面第二种情况，虽然满足条件1但是并不满足条件2，画线字串右括号数量 &gt; 左括号数量<br> <img src="https://images2.imgbox.com/8e/f9/fAGCfcbQ_o.png" alt="在这里插入图片描述"></p> 
<p>对于这样暴力枚举的所有情况的问题，我们还是画一颗决策树，把所有情况不重不漏的情况都画出来，然后根据这棵树我们写代码。</p> 
<p>每个位置都有两种选择，但是注意到刚开始就有剪枝的情况，刚开始不能选右括号，因为不满足条件2，所以右括号我们要分情况剪枝。当右括号数量大于等于左括号的数量时此时不能添加右括号 <strong>right &gt;= left</strong>。还有当左括号的数量大于等于n时此时就没有左括号可以选了，<strong>left &gt;= n</strong>。后面情况都是这样分析的，因此我们就可以做写代码的准备了。<br> <img src="https://images2.imgbox.com/80/67/GlZWYTqH_o.png" alt="在这里插入图片描述"><br> <strong>全局变量</strong>，需要一个 left 记录左括号的数量，right 记录右括号的数量，还有一个n记录有几对括号要组合。还需要一个ret记录结果，path记录每条路径的结果。<strong>递归函数</strong> 每个位置都有两种选择。因为上面都是用的全局变量，因此递归函数参数什么都不用传了。dfs()。<strong>回溯</strong> 当把path放到ret里，返回后要恢复现场。pop掉path最后一个位置元素。<strong>剪枝</strong> 前面已经分析了。<strong>递归出口</strong> 当right==n的时候说明括号组合完了。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>
    string path<span class="token punctuation">;</span>

    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> n<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ret<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token comment">//添加左括号</span>
        <span class="token punctuation">{<!-- --></span>
            path<span class="token operator">+=</span><span class="token char">'('</span><span class="token punctuation">;</span><span class="token operator">++</span>left<span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>left<span class="token punctuation">;</span><span class="token comment">//恢复现场</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>left<span class="token punctuation">)</span><span class="token comment">//添加右括号</span>
        <span class="token punctuation">{<!-- --></span>
            path<span class="token operator">+=</span><span class="token char">')'</span><span class="token punctuation">;</span><span class="token operator">++</span>right<span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span>right<span class="token punctuation">;</span><span class="token comment">//恢复现场</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32de81c53fc1077cbb27ac65410244ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大数据】Spark使用大全:下载安装、RDD操作、JAVA编程、SQL</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27e0857863133ae84ef6f2ccf7837f6f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL】索引</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>