<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>快速学习“堆“排序（C语言数据结构） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/72ccb399322704a6be17521af76b2bf4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="快速学习“堆“排序（C语言数据结构）">
  <meta property="og:description" content="前言： 堆的实现其实并不难，难的是要用堆实现排序，也就是堆的运用。
下面需要探究一下堆的排序是怎样的。
如何利用堆进行升序或者降序的排序。
&#34;堆排序&#34;： 原理： 例如：此时要将数组里的数组int arr[] = {12,20,26,8,1,2,3}进行升序或者降序排序。
第一步：把数放进堆里面，但是究竟是放在大堆还是小堆里面呢？
如果需要升序就需要放进大堆里面！
如果需要降序就需要放进小堆里面！
（原因后续画图讲解）
如何将一个数组直接放在大堆当中呢？
可以直接遍历数组，将数一个一个放入。
代码如下：
typedef int HPDataType; void AdjustUp(HPDataType* a, int child) { int parent = (child - 1) / 2; while (child &gt; 0) { if (a[child] &gt; a[parent]) { swap(&amp;a[child], &amp;a[parent]); child = parent; parent = (child - 1) / 2; } else { break; } } } void HeapPush(Heap* hp, HPDataType x) { assert(hp); if (hp-&gt;_capacity == hp-&gt;_size) { int newcapacity = hp-&gt;_capacity == 0 ?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-26T09:36:11+08:00">
    <meta property="article:modified_time" content="2024-08-26T09:36:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">快速学习“堆“排序（C语言数据结构）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2><img alt="" height="168" src="https://images2.imgbox.com/d0/5f/u54XGhsB_o.png" width="168">前言：</h2> 
<p>        堆的实现其实并不难，难的是要用堆实现排序，也就是<strong><span style="color:#fe2c24;">堆的运用</span></strong>。</p> 
<p>        <strong><span style="background-color:#fefcd8;">下面需要探究一下堆的排序是怎样的。</span></strong></p> 
<p>  <strong><span style="color:#fe2c24;">      如何利用堆进行升序或者降序的排序。</span></strong></p> 
<h2>"堆排序"：</h2> 
<h3>   原理：</h3> 
<p>        例如：此时要将数组里的数组<strong><span style="color:#ff9900;">int arr[] = {12,20,26,8,1,2,3}进行</span><span style="color:#fe2c24;">升序或者降序排序</span></strong>。</p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/22/45/ERuHaYhb_o.png" width="454"></p> 
<p><span style="color:#0d0016;"><strong>第一步</strong></span>：把数放进堆里面，<strong><span style="color:#1c7892;"><span style="background-color:#fefcd8;">但是究竟是放在大堆还是小堆里面呢？</span></span></strong></p> 
<blockquote> 
 <p>如果需要<strong><span style="color:#fe2c24;">升序</span></strong><span style="color:#fe2c24;">就需要放进</span><strong><span style="color:#fe2c24;">大堆</span></strong>里面！</p> 
 <p>如果需要<strong><span style="color:#fe2c24;">降序</span></strong><span style="color:#fe2c24;">就需要放进</span><strong><span style="color:#fe2c24;">小堆</span></strong>里面！</p> 
 <p>（原因后续画图讲解）</p> 
</blockquote> 
<p><img alt="" height="463" src="https://images2.imgbox.com/89/e3/8SxFcc3H_o.png" width="1143"></p> 
<p>如何将一个数组直接放在大堆当中呢？</p> 
<p><strong><span style="color:#be191c;">可以直接遍历数组，将数一个一个放入。</span></strong></p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">typedef int HPDataType;
void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &gt; a[parent])
		{
			swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}
void HeapPush(Heap* hp, HPDataType x)
{
	assert(hp);
	if (hp-&gt;_capacity == hp-&gt;_size)
	{
		int newcapacity = hp-&gt;_capacity == 0 ? 4 : hp-&gt;_capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(hp-&gt;_a, newcapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("malloc::error");
			exit(-1);
		}
		hp-&gt;_capacity = newcapacity;
		hp-&gt;_a = tmp;
	}
	hp-&gt;_a[hp-&gt;_size] = x;
	hp-&gt;_size++;
	AdjustUp(hp-&gt;_a, hp-&gt;_size - 1);
}
void test2()
{
	Heap hp;
	HeapInit(&amp;hp);
	int arr[] = {12,20,26,8,1,2,3};
	int i = 0;
	int size = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i &lt; size; i++)
	{
		HeapPush(&amp;hp, arr[i]);
	}

}</code></pre> 
<p>此时就直接形成了”<strong><span style="color:#fe2c24;">大堆</span></strong>“。</p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">第二步</span></strong>：每次需要<strong><span style="color:#fe2c24;">交换首和尾</span></strong></p> 
 <p>              交换之后将除了<span style="color:#be191c;"><strong>新的尾的数之外的数进行向下调整</strong></span>，</p> 
</blockquote> 
<p>              也就是将除了26以外的数进行向下调整：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/12/99/2AepQe3f_o.png" width="549"></p> 
<p><strong><span style="color:#ff9900;">向下调整：</span></strong></p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/71/c9/iImKA1Ve_o.png" width="827"></p> 
<p>第三步：以此类推，直到遍历到第一个数为止。</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/bd/15/D1GZlV51_o.png" width="353"><img alt="" height="215" src="https://images2.imgbox.com/f0/00/K82wUD2h_o.png" width="322"></p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/6f/cc/geMfSGLt_o.png" width="307"><img alt="" height="245" src="https://images2.imgbox.com/91/47/gmr6wio3_o.png" width="360"></p> 
<p><img alt="" height="273" src="https://images2.imgbox.com/6a/95/EwOC8SgX_o.png" width="400"></p> 
<p>大家可以亲自动手画一画，很有助于理解。</p> 
<p>我把这个方法称之为“<strong><span style="color:#fe2c24;">沉淀法</span></strong>”！</p> 
<p><strong><span style="color:#be191c;"><span style="background-color:#fefcd8;">此时最后就是一个升序的树，可以直接按照顺序打印出来。</span></span></strong></p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">void AdjustUp(HPDataType* a, int child)
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (a[child] &gt; a[parent])
		{
			swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}
void HeapPush(Heap* hp, HPDataType x)
{
	assert(hp);
	if (hp-&gt;_capacity == hp-&gt;_size)
	{
		int newcapacity = hp-&gt;_capacity == 0 ? 4 : hp-&gt;_capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(hp-&gt;_a, newcapacity * sizeof(HPDataType));
		if (tmp == NULL)
		{
			perror("malloc::error");
			exit(-1);
		}
		hp-&gt;_capacity = newcapacity;
		hp-&gt;_a = tmp;
	}
	hp-&gt;_a[hp-&gt;_size] = x;
	hp-&gt;_size++;
	AdjustUp(hp-&gt;_a, hp-&gt;_size - 1);
}
void HeapInit(Heap* hp)
{
	assert(hp);
	hp-&gt;_a = NULL;
	hp-&gt;_capacity = hp-&gt;_size = 0;
}
void AdjustDown(HPDataType* a, int size, int parent)
{
	//假设最大的孩子的值是左孩子对应的数值
	int childmax = (parent * 2) + 1;
	while (childmax &lt; size)
	{
		//如果右有孩子并且右孩子的值是大于左孩子将最大的孩子换成右孩子
		if (childmax + 1 &lt; size &amp;&amp; a[childmax + 1] &gt; a[childmax])
		{
			childmax = childmax + 1;
		}
		if (a[parent] &lt; a[childmax])
		{
			swap(&amp;a[parent], &amp;a[childmax]);
			parent = childmax;
			childmax = (parent * 2) + 1;
		}
		else
		{
			break;
		}
	}
}
void test2()
{
	Heap hp;
	HeapInit(&amp;hp);
	int arr[] = {12,20,26,8,1,2,3};
	int i = 0;
	int size = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i &lt; size; i++)
	{
		HeapPush(&amp;hp, arr[i]);
	}
	for (i = 0; i &lt; size; i++)
	{
		//交换首尾
		swap(&amp;hp._a[0], &amp;hp._a[hp._size - 1 - i]);
		//向下调整
		AdjustDown(hp._a, hp._size-1-i, 0);
	}
	for (i = 0; i &lt; size; i++)
	{
		arr[i] = hp._a[i];
	}
	for (i = 0; i &lt; size; i++)
	{
		printf("%d ", arr[i]);
	}
}
int main()
{
	//test1();
	test2();
	return 0;
}</code></pre> 
<h2>"十万个数据"进行堆排序：</h2> 
<p>        大数据时代，如果有10万个数据要进行排序，该怎么排序。</p> 
<p>        究竟是用哪种排序的方式时间复杂度最低呢？</p> 
<p>     在这之前需要我们<span style="color:#ff9900;">计算一下”堆排序“的时间复杂度!</span></p> 
<h3>建堆的时间复杂度：</h3> 
<h3><img alt="" height="515" src="https://images2.imgbox.com/19/37/lr7UzTsC_o.png" width="1183"></h3> 
<h3><img alt="" height="208" src="https://images2.imgbox.com/96/50/898jLa6c_o.png" width="580"><br> 堆排序的时间复杂度：</h3> 
<h3><img alt="" height="826" src="https://images2.imgbox.com/3c/a9/ILFHhuH1_o.png" width="1200">        </h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a7f002d13bb45fec4dcfc7953463c33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(100)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec2574e102b50737d9686b6d7aebca28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入MySQL</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>