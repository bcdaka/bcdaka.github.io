<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（java）websocket服务的两种实现方式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5e6e9b5a1c6af29c8d42282e1b49e697/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="（java）websocket服务的两种实现方式">
  <meta property="og:description" content="1.基于java注解实现websocket服务器端 1.1需要的类 1.1.1服务终端类 用java注解来监听连接@ServerEndpoint、连接成功@OnOpen、连接失败@OnClose、收到消息等状态@OnMessage
1.1.2配置类 把spring中的ServerEndpointExporter对象注入进来
2.1代码示例 2.1.1 maven配置 &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.heima&lt;/groupId&gt; &lt;artifactId&gt;ws-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.22&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-websocket --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;2.7.14&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.1.2 WsServerEndpoint类 package com.heima; import lombok.extern.slf4j.Slf4j; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; import javax.websocket.OnClose; import javax.websocket.OnMessage; import javax.websocket.OnOpen; import javax.websocket.Session; import javax.websocket.server.ServerEndpoint; import java.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-12T16:02:14+08:00">
    <meta property="article:modified_time" content="2024-05-12T16:02:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（java）websocket服务的两种实现方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2>1.基于java注解实现websocket服务器端</h2> 
<h3>1.1需要的类</h3> 
<h4>1.1.1服务终端类</h4> 
<p>用java注解来监听连接@ServerEndpoint、连接成功@OnOpen、连接失败@OnClose、收到消息等状态@OnMessage</p> 
<h4>1.1.2配置类</h4> 
<p>把spring中的ServerEndpointExporter对象注入进来</p> 
<h3>2.1代码示例</h3> 
<h4>2.1.1 maven配置</h4> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.heima&lt;/groupId&gt;
    &lt;artifactId&gt;ws-demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
           &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.16.22&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-websocket --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
            &lt;version&gt;2.7.14&lt;/version&gt;
        &lt;/dependency&gt;



    &lt;/dependencies&gt;

&lt;/project&gt;</code></pre> 
<h4>2.1.2 WsServerEndpoint类</h4> 
<pre><code class="language-java">package com.heima;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/***
 * 监听websocket地址  /myWs
 */
@ServerEndpoint("/myWs")
@Component
@Slf4j
@EnableScheduling
public class WsServerEndpoint {

    static Map&lt;String,Session&gt; map = new ConcurrentHashMap&lt;String,Session&gt;();

    /***
     * 连接建立时执行的操作
     * @param session
     */
    @OnOpen
    public void onOpen(Session session)
    {
        map.put(session.getId(),session);
        log.info("websocket is open");
    }

    /***
     * 收到客户端消息执行的操作
     * @param text
     */
    @OnMessage
    public String OnMessage(String text)
    {
        log.info("收到了一条信息"+text);
        return "已收到你的信息" ;
    }

    /***
     * 连接关闭时执行的操作
     * @param session
     */
    @OnClose
    public void OnClose(Session session)
    {
        map.remove(session.getId());
        log.info("连接关闭时执行的操作");
    }

    /***
     * 向客户端发送信息
     */
    @Scheduled(fixedRate = 2000)
    public void sendMsg() throws IOException {
        for (String key : map.keySet())
        {
            map.get(key).getBasicRemote().sendText("你好，你好");
        }
    }
}
</code></pre> 
<p>2.1.3 WebSocketConfig</p> 
<pre><code class="language-java">package com.heima;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

@Configuration
public class WebSocketConfig {


    @Bean
 public ServerEndpointExporter serverEndpointExporter()
 {
     return new ServerEndpointExporter();
 }



}
</code></pre> 
<h4>2.1.3 前端测试代码</h4> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;wsClient&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;
     // 创建websocket
    let ws = new WebSocket("ws://localhost:8080/myWs")
     //向服务器发送hello
    ws.onopen=function (){
        ws.send("hello")
    }
    //监听数据ws://localhost:8080/myWs
    ws.onmessage=function (message){
        console.log(message.data)
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4>2.1.4测试结果</h4> 
<h5>2.1.4.1 当打开浏览器时</h5> 
<p><img alt="" height="1030" src="https://images2.imgbox.com/cd/e2/8V571ipc_o.png" width="1200"></p> 
<h5>2.1.4.2 当关闭浏览器时</h5> 
<p><img alt="" height="162" src="https://images2.imgbox.com/08/d8/y48Kmny1_o.png" width="1200"></p> 
<h5>2.1.4.3 当刷新浏览器的时候</h5> 
<p><img alt="" height="259" src="https://images2.imgbox.com/7a/e1/InEasRjI_o.png" width="1200"></p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/d3/87/Ig0efyxo_o.png" width="686"></p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/3a/b0/bM8FpWbE_o.png" width="488"></p> 
<h2>2.基于spring提供的类和接口刷新websocket服务器端</h2> 
<h4 style="background-color:transparent;">2.1：HttpSessionHandShakeInter 握手拦截器</h4> 
<pre><code class="language-java">package com.spring;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;

import java.util.Map;

/***
 * 握手拦截器
 */
@Component
@Slf4j
public class MyWsInterceptor extends HttpSessionHandshakeInterceptor {


    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception {
        log.info(request.getRemoteAddress().toString()+"开始握手");
        return super.beforeHandshake(request, response, wsHandler, attributes);
    }

    @Override
    public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) {
         log.info(request.getRemoteAddress().toString()+"完成握手");
        super.afterHandshake(request, response, wsHandler, ex);
    }
}
</code></pre> 
<h4>2.2  MyWsHandler 主处理程序</h4> 
<h5>sessionbean封装类</h5> 
<pre><code class="language-java">import lombok.AllArgsConstructor;
import lombok.Data;
import org.springframework.web.socket.WebSocketSession;

@Data
@AllArgsConstructor
public class SessionBean {
    private WebSocketSession webSocketSession;
    private Integer clientId;
}
</code></pre> 
<h5> 主处理程序</h5> 
<pre><code class="language-java">package com.spring;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.web.servlet.server.Session;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.AbstractWebSocketHandler;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/***
 * webSocket 主处理程序
 */
@Component
@Slf4j
@EnableScheduling
public class MyWsHandler extends AbstractWebSocketHandler {
    //map有并发线程问题  所以用ConcurrentHashMap
    private static Map&lt;String, SessionBean&gt; map ;
    //id有并发问题 所以用Integer的安全类型
    private static AtomicInteger clientIdMaker;
    static {

        map = new ConcurrentHashMap&lt;&gt;();
        clientIdMaker=new AtomicInteger(0);
    }
    //连接建立
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        super.afterConnectionEstablished(session);
        //将session 进一步封装  id采用的是自增
        SessionBean sessionBean = new SessionBean(session, clientIdMaker.getAndIncrement());
        map.put(session.getId(),sessionBean);
        log.info(map.get(session.getId()).getClientId()+"建立了连接");
    }

    //收到消息
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        super.handleTextMessage(session, message);
        log.info(map.get(session.getId()).getClientId()+":"+message.getPayload());
    }

    //传输异常
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        super.handleTransportError(session, exception);

        if (session.isOpen())
        {
            session.close();
        }
        map.remove(session.getId());

    }
    //连接关闭
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        super.afterConnectionClosed(session, status);
        log.info(map.get(session.getId()).getClientId()+"关闭连接");
    }

    /***
     * 向客户端发送信息
     */
    @Scheduled(fixedRate = 2000)
    public void sendMsg() throws IOException {
        for (String key : map.keySet())
        {
            map.get(key).getWebSocketSession().sendMessage(new TextMessage("hello," +
                    "spring socket"));
        }
    }
}
</code></pre> 
<h4>2.3 WebSocketConfigurer 注册拦截器和主处理程序以及监听路径</h4> 
<pre><code class="language-java">package com.spring;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

import javax.annotation.Resource;

@Configuration
@EnableWebSocket
public class MyWsConfig implements WebSocketConfigurer {
    @Resource
    private MyWsHandler wsHandler;
    @Resource
    private MyWsInterceptor wsInterceptor;
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(wsHandler,"/myWs1").addInterceptors(wsInterceptor).setAllowedOriginPatterns("*");
    }
}
</code></pre> 
<h4>2.4 前端测试</h4> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;wsClient&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;script&gt;
     // 创建websocket
    let ws = new WebSocket("ws://localhost:8080/myWs1")
     //向服务器发送hello
    ws.onopen=function (){
        ws.send("hello")
    }
    //监听数据ws://localhost:8080/myWs
    ws.onmessage=function (message){
        console.log(message.data)
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b82e83bb5ca348de384f5ab167640e63/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何查看PostgreSQL的版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21de001b8078cca99004d603317a91c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[数据结构]动画详解单链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>