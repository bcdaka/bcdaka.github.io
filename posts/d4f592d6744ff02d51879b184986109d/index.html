<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣每日一题 6/13 反悔贪心算法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d4f592d6744ff02d51879b184986109d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="力扣每日一题 6/13 反悔贪心算法">
  <meta property="og:description" content="博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 2813.子序列最大优雅度【困难】 题目： 给你一个长度为 n 的二维整数数组 items 和一个整数 k 。
items[i] = [profiti, categoryi]，其中 profiti 和 categoryi 分别表示第 i 个项目的利润和类别。
现定义 items 的 子序列 的 优雅度 可以用 total_profit &#43; distinct_categories2 计算，其中 total_profit 是子序列中所有项目的利润总和，distinct_categories 是所选子序列所含的所有类别中不同类别的数量。
你的任务是从 items 所有长度为 k 的子序列中，找出 最大优雅度 。
用整数形式表示并返回 items 中所有长度恰好为 k 的子序列的最大优雅度。
注意：数组的子序列是经由原数组删除一些元素（可能不删除）而产生的新数组，且删除不改变其余元素相对顺序。
示例 1：
输入：items = [[3,2],[5,1],[10,1]], k = 2 输出：17 解释： 在这个例子中，我们需要选出长度为 2 的子序列。 其中一种方案是 items[0] = [3,2] 和 items[2] = [10,1] 。 子序列的总利润为 3 &#43; 10 = 13 ，子序列包含 2 种不同类别 [2,1] 。 因此，优雅度为 13 &#43; 22 = 17 ，可以证明 17 是可以获得的最大优雅度。 示例 2：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T18:02:33+08:00">
    <meta property="article:modified_time" content="2024-06-13T18:02:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣每日一题 6/13 反悔贪心算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li><strong>博客主页：<a href="https://blog.csdn.net/Xxy_1008?type=blog" title="誓则盟约">誓则盟约</a></strong></li><li><strong>系列专栏：<a href="https://blog.csdn.net/xxy_1008/category_12662512.html?spm=1001.2014.3001.5482" title="IT竞赛 专栏">IT竞赛 专栏</a></strong></li><li><strong>关注博主，后期持续更新系列文章</strong></li><li><strong>如果有错误感谢请大家批评指出，及时修改</strong></li><li><strong>感谢大家点赞👍收藏⭐评论✍</strong> </li></ul> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d7/5b/lQydCLrX_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/10/33/65kC1t2J_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8d/d2/yXTRGcbB_o.gif"></p> 
<p></p> 
<h3>2813.子序列最大优雅度【<span style="color:#fe2c24;">困难</span>】</h3> 
<h4><span style="color:#a2e043;">题目：</span></h4> 
<p>给你一个长度为 <code>n</code> 的二维整数数组 <code>items</code> 和一个整数 <code>k</code> 。</p> 
<p><code>items[i] = [profiti, categoryi]</code>，其中 <code>profiti</code> 和 <code>categoryi</code> 分别表示第 <code>i</code> 个项目的利润和类别。</p> 
<p>现定义 <code>items</code> 的 <strong>子序列</strong> 的 <strong>优雅度</strong> 可以用 <code>total_profit + distinct_categories2</code> 计算，其中 <code>total_profit</code> 是子序列中所有项目的利润总和，<code>distinct_categories</code> 是所选子序列所含的所有类别中不同类别的数量。</p> 
<p>你的任务是从 <code>items</code> 所有长度为 <code>k</code> 的子序列中，找出 <strong>最大优雅度</strong> 。</p> 
<p>用整数形式表示并返回 <code>items</code> 中所有长度恰好为 <code>k</code> 的子序列的最大优雅度。</p> 
<p><strong>注意：</strong>数组的子序列是经由原数组删除一些元素（可能不删除）而产生的新数组，且删除不改变其余元素相对顺序。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>items = [[3,2],[5,1],[10,1]], k = 2
<strong>输出：</strong>17
<strong>解释：
</strong>在这个例子中，我们需要选出长度为 2 的子序列。
其中一种方案是 items[0] = [3,2] 和 items[2] = [10,1] 。
子序列的总利润为 3 + 10 = 13 ，子序列包含 2 种不同类别 [2,1] 。
因此，优雅度为 13 + 22 = 17 ，可以证明 17 是可以获得的最大优雅度。 
</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>items = [[3,1],[3,1],[2,2],[5,3]], k = 3
<strong>输出：</strong>19
<strong>解释：</strong>
在这个例子中，我们需要选出长度为 3 的子序列。 
其中一种方案是 items[0] = [3,1] ，items[2] = [2,2] 和 items[3] = [5,3] 。
子序列的总利润为 3 + 2 + 5 = 10 ，子序列包含 3 种不同类别 [1, 2, 3] 。 
因此，优雅度为 10 + 32 = 19 ，可以证明 19 是可以获得的最大优雅度。</pre> 
<p><strong>示例 3：</strong></p> 
<pre><strong>输入：</strong>items = [[1,1],[2,1],[3,1]], k = 3
<strong>输出：</strong>7
<strong>解释：
</strong>在这个例子中，我们需要选出长度为 3 的子序列。
我们需要选中所有项目。
子序列的总利润为 1 + 2 + 3 = 6，子序列包含 1 种不同类别 [1] 。
因此，最大优雅度为 6 + 12 = 7 。</pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= items.length == n &lt;= 10**5</code></li><li><code>items[i].length == 2</code></li><li><code>items[i][0] == profiti</code></li><li><code>items[i][1] == categoryi</code></li><li><code>1 &lt;= profiti &lt;= 10**9</code></li><li><code>1 &lt;= categoryi &lt;= n </code></li><li><code>1 &lt;= k &lt;= n</code></li></ul> 
<p></p> 
<h4><span style="color:#a2e043;">分析问题：</span></h4> 
<p>        解这道题主要还是要有一定的思维能力，对贪心算法有一定的知识储备。因为这道题考察的内容确实有点多，在它的标签里列出了 <strong>贪心，栈，数组，哈希表，排序，堆（优先队列）</strong>；可见这题考的内容之丰富，不过不用慌，在Python中列表可以充当大部分的数据结构，把列表运用好可以解决大多数问题。</p> 
<p>那么这道题的话思路如下：</p> 
<p>先把items按照利润大小排序(假设从大到小排序)，然后先取前k个，计算出当前的value值；</p> 
<p>然后考虑k+1以及之后的元素，首先要明白k+1后面的元素的利润值都是低于之前的任何一个的，那么分类讨论：</p> 
<ul><li>如果k+1的种类存在于前k个元素中，那么把k+1加进去没有任何意义，种类重复利润还少，直接跳过即可。</li><li>如果k+1的种类不存在于前k个元素中，那么我们要选一个种类重复的且利润最小的元素出来和他交换，这时候利润虽然减小了但是种类+1了，记录此时的a_value值,于原value值相比，谁大取谁作为value。</li></ul> 
<p>        按照这个思路，往下遍历，计算优雅度，取最大值即可。 不过要注意的是这里要记录种类重复的元素，以及将他们按照利润大小排序。这里可以直接用一个列表和一个集合实现，因为遍历的顺序是按照利润从大到小，所以加入到ls里面的元素的<strong>顺序一定是按照利润值从大到小的，直接将其翻转，先拿小的交换</strong>，这里需要一个指针，交换一次指针向前走一步，标记要被交换的元素。<strong>接下来看具体的代码实现：</strong></p> 
<hr> 
<h4><span style="color:#a2e043;">代码实现：</span></h4> 
<pre><code class="language-python">class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -&gt; int:
        items.sort(key= lambda items:items[0],reverse=True)
        ls=items[:k] # 先按利益大小取前k个最大的元素
        seen,ll,su=set(),[],0 # seen用来标记出现过的种类
        for i,j in ls:
            if j not in seen: seen.add(j)
            else: ll.append([i,j])
            su+=i
        value=su+len(seen)**2  # 计算当前最大优雅度
        if len(ll)==0: return value
        ll,re=ll[::-1],0  # re 指针 用来标记要和ll中的哪个元素比较
        for q in items[k:]:
            if q[1] not in seen and re&lt;=len(ll)-1:
                key=q[0]-ll[re][0]
                seen.add(q[1])
                su+=key
                re+=1
                a_va=su+(len(seen))**2
                if a_va&gt;value:
                    value=a_va
        return value</code></pre> 
<p style="text-align:center;"><img alt="" height="336" src="https://images2.imgbox.com/44/d0/Ot9xfOqB_o.png" width="608"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/03/cc/H1PljTIY_o.png"></p> 
<hr> 
<h4 style="text-align:center;"><img alt="" height="689" src="https://images2.imgbox.com/d5/aa/5Z7XUbXX_o.jpg" width="689"></h4> 
<h4><span style="color:#a2e043;">总结：</span></h4> 
<p><span style="color:#fe2c24;"><strong>代码逐行解释：</strong></span></p> 
<ol><li> <p>函数定义</p> 
  <ul><li>定义了名为 <code>findMaximumElegance</code> 的函数，接受 <code>items</code> 列表和整数 <code>k</code> 作为参数。</li></ul></li><li> <p>初始化操作</p> 
  <ul><li>对 <code>items</code> 按照第一项（利益大小）进行降序排序。</li><li>取出前 <code>k</code> 个元素存储在 <code>ls</code> 列表中。</li><li>创建空集合 <code>seen</code> 用于标记出现过的种类。</li><li>创建空列表 <code>ll</code> 用于存储重复种类的元素。</li><li>初始化变量 <code>su</code> 为 0，用于累计利益总和。</li></ul></li><li> <p>计算初始优雅度</p> 
  <ul><li>遍历 <code>ls</code> 中的每个元素 <code>[i, j]</code> ，如果 <code>j</code> 不在 <code>seen</code> 中，将其添加到 <code>seen</code> 中；否则，将该元素添加到 <code>ll</code> 中。</li><li>累加 <code>ls</code> 中元素的利益到 <code>su</code> 。</li><li>计算初始优雅度 <code>value</code> 为 <code>su + len(seen) ** 2</code> 。</li></ul></li><li> <p>处理剩余元素以优化优雅度</p> 
  <ul><li>如果 <code>ll</code> 不为空，将其反转。</li><li>遍历 <code>items</code> 中 <code>k</code> 之后的元素 <code>q</code> 。</li><li>如果 <code>q</code> 的种类不在 <code>seen</code> 中且 <code>re</code> 指针未超出 <code>ll</code> 的范围，计算用 <code>q</code> 替换 <code>ll[re]</code> 带来的利益变化 <code>key</code> 。</li><li>更新 <code>seen</code> 、 <code>su</code> ，计算新的优雅度 <code>a_va</code> 。</li><li>如果 <code>a_va</code> 大于当前的 <code>value</code> ，更新 <code>value</code> 。</li></ul></li><li> <p>返回结果</p> 
  <ul><li>函数最终返回计算得到的最大优雅度 <code>value</code> 。</li></ul></li></ol> 
<hr> 
<h4> <strong>考查内容：</strong></h4> 
<ol><li>排序算法的应用：通过对 <code>items</code> 列表按照特定规则（第一项的利益大小）进行排序，为后续的选择操作奠定基础。</li><li>数据结构的运用：使用集合 <code>seen</code> 来快速判断元素的种类是否已经出现，利用列表 <code>ll</code> 存储重复种类的元素。</li><li>贪心算法的思想：先选择前 <code>k</code> 个利益最大的元素，然后通过逐步替换来尝试优化结果，体现了贪心选择局部最优以期望达到全局最优的思路。</li><li>逻辑推理和计算能力：在计算优雅度、判断是否替换元素以及更新相关变量时，需要准确的逻辑推理和计算。</li></ol> 
<p></p> 
<h4><strong>学到的内容：</strong></h4> 
<ol><li>熟练掌握排序函数的使用，能够根据具体需求对数据进行排序。</li><li>学会运用合适的数据结构来提高算法的效率和便捷性，例如集合的快速查找和去重特性。</li><li>深入理解贪心算法的策略，以及如何在特定问题中应用贪心思想来解决优化问题。</li><li>提升了对复杂逻辑的分析和处理能力，包括条件判断、变量更新和结果优化。</li><li>培养了通过逐步推导和计算来求解最优解的思维方式，同时也学会了如何在算法中有效地管理和利用数据。</li></ol> 
<h3><span style="color:#ff9900;"><span style="background-color:#1c7331;">To sum up: 这道题的算法有另一个好听的名字叫 反悔贪心，难度还是在线的，多思考，多理解。 </span></span></h3> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5d/35/dL5opdkf_o.jpg"></p> 
<h3 style="text-align:center;"><span style="color:#0d0016;"><span style="background-color:#38d8f0;">“江流天地外，山色有无中。”——王维 </span></span></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03235c3038fe565bb74947e7e7fcf097/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;高阶】C&#43;&#43;继承学习手册：全面解析继承的各个方面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf22d1abdab36c5f48a3c02f6626236b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac 下载并激活IDEA</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>