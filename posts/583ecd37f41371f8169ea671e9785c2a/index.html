<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java八股面试文（带答案，万字总结，精心打磨，建议收藏）堪称2024最强 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/583ecd37f41371f8169ea671e9785c2a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="java八股面试文（带答案，万字总结，精心打磨，建议收藏）堪称2024最强">
  <meta property="og:description" content="多同学会问Java面试八股文有必要背吗？
我的回答是：很有必要。你可以讨厌这种模式，但你一定要去背，因为不背你就进不了大厂。
国内的互联网面试，恐怕是现存的、最接近科举考试的制度。
一、java （1）集合 1.list：LinkedList、ArrayList和Vector LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全Vector 接口实现类 数组， 同步， 线程安全 2.set：HashSet和TreeSet HashSet 使用哈希表存储元素，元素可以是null LinkedHashSet 链表维护元素的插入次序TreeSet 底层实现为红黑树，元素排好序，元素不可以是null 3.map：HashMap、TreeMap和HashTable 线程安全 HshaMap线程不安全TreeMap线程不安全HashTable线程安全空值 HashMap一个null key,多个null valueTreeMap不能null key，多个null valueHashTable都不能有null 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套面试笔记的【点击此处即可】即可免费获取
继承和接口 HashMap继承AbstractMap，实现接口MapTreeMap继承AbstractMap，实现接口NavigableMap(SortMap的一种)HashTable继承Dictionary，实现接口Map顺序 HashMap中key是无序的TreeMap是有序的HashTable是无序的构造函数 HashMap有调优初始容量和负载因子TreeMap没有HashTable有数据结构 HashMap是链表&#43;数组&#43;红黑树TreeMap是红黑树HashTable是链表&#43;数组 4.list、set和map的区别 list：元素按进入先后有序保存，可重复set：不可重复，并做内部排序map:代表具有映射关系的集合，其所有的key是一个Set集合，即key无序且不能重复。 5.HashMap扩容机制 数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。 6.HashMap中的循环链表是如何产生的（jdk1.7） 由于jdk1.7中采用头插法，在多线程中，存在两个线程同时对链表进行扩容的情况，执行transfer函数（链表数据转移）会导致链表数据倒置，当两个线程同时此操作，就导致链表死循环 7.B树和B&#43;树的区别 B树是二叉排序树进化而来；B&#43;树是分块查找进化而来B&#43;树叶节点包含所有数据，非叶节点仅起到索引作用；B树终端节点及以上都包含数据且不重复（叶节点只是一个概念，并不存在）B&#43;树叶节点包含了全部关键字B&#43;树支持顺序查找和多路查找，B树只支持多路查找 8. HashMap为什么用红黑树而不是AVL树或者B&#43;树 AVL树更加严格平衡，因此可以提供更快的査找效果。因此，对于查找密集型任务使用AVL树没毛病。 但是对于插入密集型任务，红黑树要好一些。B/B&#43;树的节点可以存储多个数据，当数据量不够多时，数据都会”挤在“一个节点中，查询效率会退化为链表。 9.CopyOnWriteArrayList的原理 线程并发访问进行读操作时，没有加锁限制写操作时，先将容器复制一份，再在新的副本上执行写操作，此时写操作是上锁的。结束之后再将原容器的引用指向新容器。注意，在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上。因此上锁的写操作不会影响到并发访问的读操作。 10.BlockingQueue中有哪些方法 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题
需要全套面试笔记的【点击此处即可】即可免费获取
共四组增删API
抛异常：如果操作无法立即执行，则抛一个异常；特定值：如果操作无法立即执行，则返回一个特定的值(一般是 true / false)。阻塞：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；超时：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true / false)。 （2）多线程 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-29T14:02:47+08:00">
    <meta property="article:modified_time" content="2024-06-29T14:02:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java八股面试文（带答案，万字总结，精心打磨，建议收藏）堪称2024最强</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>多同学会问Java面试八股文有必要背吗？</p> 
<p>我的回答是：<strong>很有必要</strong>。你可以讨厌这种模式，但你一定要去背，因为不背你就进不了大厂。</p> 
<p>国内的互联网面试，恐怕是现存的、最接近科举考试的制度。</p> 
<h4><a name="t0"></a>一、java</h4> 
<h6><a name="t2"></a><a id="1_3"></a>（1）集合</h6> 
<h6><a id="1listLinkedListArrayListVector_4"></a>1.list：LinkedList、ArrayList和Vector</h6> 
<ul><li>LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全</li><li>ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全</li><li>Vector 接口实现类 数组， 同步， 线程安全</li></ul> 
<h6><a id="2setHashSetTreeSet_8"></a>2.set：HashSet和TreeSet</h6> 
<ul><li>HashSet 使用哈希表存储元素，元素可以是null 
  <ul><li>LinkedHashSet 链表维护元素的插入次序</li></ul></li><li>TreeSet 底层实现为红黑树，元素排好序，元素不可以是null</li></ul> 
<h6><a id="3mapHashMapTreeMapHashTable_12"></a>3.map：HashMap、TreeMap和HashTable</h6> 
<ul><li>线程安全 
  <ul><li>HshaMap线程不安全</li><li>TreeMap线程不安全</li><li>HashTable线程安全</li></ul></li><li>空值 
  <ul><li>HashMap一个null key,多个null value</li><li>TreeMap不能null key，多个null value</li><li>HashTable都不能有null</li></ul></li><li> 
  <blockquote> 
   <p><strong>篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p> 
   <p><strong> 需要全套面试笔记的<strong><a href="https://docs.qq.com/doc/DQXdYWE9LZ2ZHZ1ho" rel="nofollow" title="【点击此处即可】">【点击此处即可】</a></strong>即可免费获取</strong></p> 
  </blockquote> 继承和接口 
  <ul><li>HashMap继承AbstractMap，实现接口Map</li><li>TreeMap继承AbstractMap，实现接口NavigableMap(SortMap的一种)</li><li>HashTable继承Dictionary，实现接口Map</li></ul></li><li>顺序 
  <ul><li>HashMap中key是无序的</li><li>TreeMap是有序的</li><li>HashTable是无序的</li></ul></li><li>构造函数 
  <ul><li>HashMap有调优初始容量和负载因子</li><li>TreeMap没有</li><li>HashTable有</li></ul></li><li>数据结构 
  <ul><li>HashMap是链表+数组+红黑树</li><li>TreeMap是红黑树</li><li>HashTable是链表+数组</li></ul></li></ul> 
<h6><a id="4listsetmap_37"></a>4.list、set和map的区别</h6> 
<ul><li>list：元素按进入先后有序保存，可重复</li><li>set：不可重复，并做内部排序</li><li>map:代表具有映射关系的集合，其所有的key是一个Set集合，即key无序且不能重复。</li></ul> 
<h6><a id="5HashMap_41"></a>5.HashMap扩容机制</h6> 
<ul><li>数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。</li><li>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</li><li>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。</li><li>对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。</li></ul> 
<h6><a id="6HashMapjdk17_46"></a>6.HashMap中的循环链表是如何产生的（jdk1.7）</h6> 
<ul><li>由于jdk1.7中采用头插法，在多线程中，存在两个线程同时对链表进行扩容的情况，执行transfer函数（链表数据转移）会导致链表数据倒置，当两个线程同时此操作，就导致链表死循环</li></ul> 
<h6><a id="7BB_48"></a>7.B树和B+树的区别</h6> 
<ul><li>B树是二叉排序树进化而来；B+树是分块查找进化而来</li><li>B+树叶节点包含所有数据，非叶节点仅起到索引作用；B树终端节点及以上都包含数据且不重复（叶节点只是一个概念，并不存在）</li><li>B+树叶节点包含了全部关键字</li><li>B+树支持顺序查找和多路查找，B树只支持多路查找</li></ul> 
<h6><a id="8_HashMapAVLB_53"></a>8. HashMap为什么用红黑树而不是AVL树或者B+树</h6> 
<ul><li>AVL树更加严格平衡，因此可以提供更快的査找效果。因此，对于查找密集型任务使用AVL树没毛病。 但是对于插入密集型任务，红黑树要好一些。</li><li>B/B+树的节点可以存储多个数据，当数据量不够多时，数据都会”挤在“一个节点中，查询效率会退化为链表。</li></ul> 
<h6><a id="9CopyOnWriteArrayList_56"></a>9.CopyOnWriteArrayList的原理</h6> 
<ul><li>线程并发访问进行读操作时，没有加锁限制</li><li>写操作时，先将容器复制一份，再在新的副本上执行写操作，此时写操作是上锁的。结束之后再将原容器的引用指向新容器。注意，在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上。因此上锁的写操作不会影响到并发访问的读操作。</li></ul> 
<h6><a id="10BlockingQueue_59"></a>10.BlockingQueue中有哪些方法</h6> 
<blockquote> 
 <p><strong> 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p> 
 <p><strong> 需要全套面试笔记的<strong><strong><strong><a href="https://docs.qq.com/doc/DQXdYWE9LZ2ZHZ1ho" rel="nofollow" title="【点击此处即可】">【点击此处即可】</a></strong></strong></strong>即可免费获取</strong></p> 
</blockquote> 
<ul><li>共四组增删API<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/15/a0/eC2iYiWB_o.png"></li><li>抛异常：如果操作无法立即执行，则抛一个异常；</li><li>特定值：如果操作无法立即执行，则返回一个特定的值(一般是 true / false)。</li><li>阻塞：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；</li><li>超时：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true / false)。</li></ul> 
<h6><a name="t3"></a><a id="2_66"></a>（2）多线程</h6> 
<h6><a id="1Java_67"></a>1.Java中线程安全的基本数据结构</h6> 
<ul><li>string</li><li>HashTable</li><li>ConcurrentHashMap</li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li>Vector</li><li>stringBuffer</li></ul> 
<h6><a id="2_75"></a>2.创建线程有哪几种方式</h6> 
<ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li><li>线程池 
  <ul><li>七大参数 
    <ul><li>核心线程数</li><li>最大线程数</li><li>空闲线程存活时间</li><li>时间单位</li><li>任务队列</li><li>线程工厂</li><li>拒绝策略 
      <ul><li>拒绝并抛出异常</li><li>拒绝忽略任务</li><li>抛弃队列头部任务</li><li>返回给调用线程执行</li></ul></li></ul></li></ul></li></ul> 
<h6><a id="3_92"></a>3.线程的生命周期</h6> 
<ul><li>线程的状态有五种：新建(new)、就绪(start())、运行(分配到cpu)、阻塞和死亡</li><li>CPU在多条线程之间切换，于是线程状态也会多次在运行、就绪之间切换。</li><li>出现阻塞的情况 
  <ul><li>线程调用sleep()方法主动放弃所占用的处理器资源。</li><li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。</li><li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。</li><li>线程在等待某个通知（notify）</li><li>程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。</li></ul></li><li>解除阻塞重新进入就绪状态的情况 
  <ul><li>调用sleep()方法的线程经过了指定时间</li><li>线程调用的阻塞式IO方法已经返回。</li><li>线程成功地获得了试图取得的同步监视器。</li><li>线程正在等待某个通知时，其他线程发出了一个通知。</li><li>处于挂起状态的线程被调用了resume()恢复方法。</li></ul></li><li>出现死亡的情况 
  <ul><li>run()或call()方法执行完成，线程正常结束</li><li>线程抛出一个未捕获的Exception或Error。</li><li>直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用</li></ul></li></ul> 
<h6><a id="4_111"></a>4.如何实现线程同步</h6> 
<ul><li>同步方法（synchronized）</li><li>同步代码块</li><li>ReentrantLock</li><li>volatile 
  <blockquote> 
   <p><strong> 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p> 
   <p><strong> 需要全套面试笔记的<strong><strong><strong><a href="https://docs.qq.com/doc/DQXdYWE9LZ2ZHZ1ho" rel="nofollow" title="【点击此处即可】">【点击此处即可】</a></strong></strong></strong>即可免费获取</strong></p> 
  </blockquote> </li></ul> 
<h6><a id="5Java_116"></a>5.Java多线程之间的通信方式</h6> 
<ul><li>wait()、notify()、notifyAll()。采用采用synchronized来保证线程安全</li><li>await()、signal()、signalAll()。采用lock保证线程安全</li><li>BlockingQueue。当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。</li></ul> 
<h6><a id="6sleepwait_120"></a>6.sleep()和wait()的区别</h6> 
<ul><li>sleep()是Thread类中的静态方法，而wait()是Object类中的成员方法；</li><li>sleep()可以在任何地方使用，而wait()只能在同步方法或同步代码块中使用</li><li>sleep()不会释放锁，而wait()会释放锁，并需要通过notify()/notifyAll()重新获取锁。</li></ul> 
<h6><a id="7synchronizedLock_124"></a>7.synchronized与Lock的区别</h6> 
<ul><li>synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁</li><li>synchronized可以用在代码块上、方法上；Lock只能写在代码里。</li><li>synchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁。</li><li>synchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间。</li><li>synchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功。</li><li>synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平/不公平，并可以细分读写锁以提高效率</li></ul> 
<h6><a id="8_131"></a>8.乐观锁和悲观锁的区别</h6> 
<h6><a id="9_132"></a>9.公平锁与非公平锁</h6> 
<ul><li>非公平锁: 当线程争夺锁的过程中，会先进行一次CAS尝试获取锁，若失败，则进入acquire(1)函数，进行一次tryAcquire再次尝试获取锁，若再次失败，那么就通过addWaiter将当前线程封装成node结点加入到Sync队列，这时候该线程只能乖乖等前面的线程执行完再轮到自己了</li><li>公平锁: 当线程在获取锁的时候，会先判断Sync队列中是否有在等待获取资源的线程。若没有，则尝试获取锁，若有，那么就那么就通过addWaiter将当前线程封装成node结点加入到Sync队列中</li></ul> 
<h6><a id="10volatile_135"></a>10.volatile</h6> 
<ul><li>保证可见性，不保证原子性</li><li>禁止指令重排</li></ul> 
<h6><a name="t4"></a><a id="3_138"></a>（3）其他</h6> 
<h6><a id="1_139"></a>1.面向对象三大特性</h6> 
<ul><li>封装：（将数据和代码捆绑在一起，防止外界干扰）把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</li><li>继承：（让一个类型的对象拥有另一个类型的对象的属性的方法）可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</li><li>多态：（就是一个事物拥有不同形式的能力）父类引用指向子类对象，从而具备多种形态</li></ul> 
<h6><a id="2Object_143"></a>2.Object类的常用方法</h6> 
<ul><li>equals()</li><li>hashCode()</li><li>toString()</li><li>getClass()</li><li>wait()</li><li>notify()</li><li>notifyall()</li><li>clone()</li><li>finalize()</li></ul> 
<h6><a id="3stringstringBufferstringBuilder_153"></a>3.string、stringBuffer和stringBuilder</h6> 
<ul><li>string不可变、线程安全</li><li>stringBuffer可变，效率低，线程安全</li><li>stringBuilder可变、效率高，线程不安全</li></ul> 
<h6><a id="4_157"></a>4.抽象类与接口的区别</h6> 
<ul><li>抽象类属于继承，只能继承一个；接口可以实现多个</li><li>抽象类有构造方法；接口没有构造方法</li><li>抽象类的成员变量可以是变量也可以是常量；接口的成员变量只能是常量，默认修饰符public static final</li><li>抽象类的成员方法可以是抽象的也可以是具体实现的；接口在jdk1.7只能是抽象的成员方法，jdk1.8之后可以有具体实现且必须用default修饰。并且接口也可以有静态方法，static修饰。</li><li>抽象类和接口的选择：如果关注的是一个事务的本质，就用抽象类；关注一个操作的时候就用接口。比如，关注一个人，男人或女人，这时候关注的是本质，就用抽象类。关注每种人吃东西，睡觉各种动作不同，就需要用接口，定义一个模板，分别去实现。</li></ul> 
<h6><a id="5java_163"></a>5.java的基本数据类型</h6> 
<ul><li>byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。</li><li>short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。</li><li>int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。</li><li>long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。</li><li>float：4字节（32位），数据范围大约是 -3.4<em>10^38 ~ 3.4</em>10^38。</li><li>double：8字节（64位），数据范围大约是 -1.8<em>10^308 ~ 1.8</em>10^308。</li><li>char：2字节（16位），数据范围是 \u0000 ~ \uffff。</li><li>boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。</li></ul> 
<h6><a id="6java_172"></a>6.java代码块执行顺序</h6> 
<ul><li>父类静态代码块</li><li>子类静态代码块</li><li>父类构造代码块</li><li>父类构造方法</li><li>子类构造代码块</li><li>子类构造方法</li><li>普通代码块</li></ul> 
<h6><a id="7static_180"></a>7.static关键字</h6> 
<ul><li>修饰成员变量：该静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间</li><li>修饰成员方法：调用该方法只需类名.方法名；静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的。在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都必须依赖具体的对象才能够被调用。</li><li>修饰代码块：在类初次被加载的时候，会按照static块的顺序来依次执行每个static块，并且只会执行一次。</li><li>修饰内部类：静态内部类不能直接访问外部类的非静态成员，但，可以通过new 外部类().成员的方式访问；</li></ul> 
<h6><a id="8_185"></a>8.覆盖（重写）和重载的区别</h6> 
<ul><li>重写一般是子类重写父类方法（一对一），垂直关系；重载一般是一个类中多个方法重载（多个之间），水平关系</li><li>重写方法之间参数相同；重载方法之间参数不同</li><li>重写不可以修改返回值类型；重载可以修改返回值类型</li></ul> 
<h6><a id="9java_189"></a>9.java四个访问修饰符</h6> 
<ul><li>private：本类中</li><li>default：本包中</li><li>protected：不同包的子类</li><li>public：所有</li></ul> 
<h6><a id="10_194"></a>10.全局变量和局部变量的区别</h6> 
<ul><li> <p>成员变量：</p> 
  <ul><li> <p>成员变量是在类的范围里定义的变量；</p> </li><li> <p>成员变量有默认初始值；</p> </li><li> <p>未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；</p> </li><li> <p>被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。</p> </li></ul></li><li> <p>局部变量：</p> 
  <ul><li> <p>局部变量是在方法里定义的变量；</p> </li><li> <p>局部变量没有默认初始值；</p> </li><li> <p>局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。</p> </li></ul></li></ul> 
<h6><a id="11hashCodeequals_212"></a>11.hashCode()和equals()的关系</h6> 
<ul><li>hashCode求的是对象的散列码（一般是对象的储存地址），equals是根据地址比较对象是否相同</li><li>如果两个对象相等，则它们必须有相同的哈希码</li><li>如果两个对象有相同的哈希码，则它们未必相等</li></ul> 
<h6><a id="12hashCodeequals_216"></a>12.为什么要重写hashCode()和equals()</h6> 
<ul><li>Object类提供的equals()方法默认是用==来进行比较的，也就是说只有两个对象是同一个对象时，才能返回相等的结果。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。</li></ul> 
<h6><a id="13_218"></a>13.反射</h6> 
<ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li></ul> 
<h6><a id="14cookiesession_220"></a>14.cookie和session的区别</h6> 
<ul><li>存储位置不同：cookie存放于客户端；session存放于服务端。</li><li>隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</li><li>生命周期不同：设置cookie的属性，达到cookie长期有效的效果；session只需关闭窗口该session就会失效，因此session不能长期有效。</li><li>cookie有存储上限，3k左右；session没有 
  <blockquote> 
   <p><strong> 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p> 
   <p><strong> 需要全套面试笔记的<strong><strong><strong><a href="https://docs.qq.com/doc/DQXdYWE9LZ2ZHZ1ho" rel="nofollow" title="【点击此处即可】">【点击此处即可】</a></strong></strong></strong>即可免费获取</strong></p> 
  </blockquote> </li></ul> 
<h6><a id="15getpost_225"></a>15.get和post请求的区别</h6> 
<ul><li>url可见性：get，参数url可见；post，url参数不可见</li><li>数据传输上：get，通过拼接url进行传递参数；post，通过body体传输参数</li><li>缓存性：get请求是可以缓存的；post请求不可以缓存</li><li>后退页面的反应:get请求页面后退时，不产生影响;post请求页面后退时，会重新提交请求</li><li>安全性:这个也是最不好分析的，原则上post肯定要比get安全，毕竟传输参数时url不可见。</li><li>get一般传输数据大小不超过2k-4k;post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大。</li></ul> 
<h6><a id="16_232"></a>16.前后端数据交互</h6> 
<ul><li> <p>form表单</p> </li><li> <p>HttpServletRequest/HttpServletResponse</p> </li><li> <p>@RequestParam</p> 
  <ul><li>数据在url后 path?id=1<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/1d/9c/Uk6jGREA_o.png"></li><li>@PathVariable 
    <ul><li>数据在url后 path/{id}</li></ul></li></ul><p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/fe/5b/iksWokxU_o.png"></p> 
  <ul><li>@RequestBody 
    <ul><li>以json数据为例，首先有一个类<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/cd/a4/5XTgKE4E_o.png"></li><li>然后前端传过来数据<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/47/59/XFyTvix5_o.png"></li><li>后端接收</li></ul></li></ul></li></ul> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/bd/11/Upc3qgmT_o.png"><br> - ModelAndView（只向前端传输数据）<br> - 配置视图解析器<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ca/1c/10SIJnRE_o.png"><br> - 创建ModelAndView对象，添加返回的数据和地址<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/4a/67/mIznXGc7_o.png"><br> - model<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/cd/12/lyexnqJG_o.png"></p> 
<ul><li>jquery实现的ajax 
  <ul><li>前端<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/06/86/h6BwuvGn_o.png"></li><li>eg: 
    <ul><li> <p>数据传输载体类<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9b/df/FQQwNHeH_o.png"></p> </li><li> <p>前端部分<img alt="在这里插入图片描述" src="https://images2.imgbox.com/d0/09/2vQoJIE4_o.png"></p> </li><li> <p>后台部分<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/96/02/Rvw7CPrq_o.png"></p> </li></ul></li></ul></li></ul> 
<h6><a id="17IO_267"></a>17.IO分类</h6> 
<ul><li>按流方向分：输入流，输出流</li><li>按数据单位分：字节流，字符流 
  <blockquote> 
   <p><strong> 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p> 
   <p><strong> 需要全套面试笔记的<strong><strong><strong><a href="https://docs.qq.com/doc/DQXdYWE9LZ2ZHZ1ho" rel="nofollow" title="【点击此处即可】">【点击此处即可】</a></strong></strong></strong>即可免费获取</strong></p> 
  </blockquote> </li><li>按功能分：节点流，处理流</li></ul> 
<h6><a id="18_271"></a>18.处理哈希冲突的方法</h6> 
<ul><li>开放定址法（再散列法） 
  <ul><li>线性探测再散列</li><li>二次探测再散列</li><li>伪随机探测再散列</li></ul></li><li>再哈希法</li><li>拉链法</li></ul> 
<h6><a id="19throwthrows_278"></a>19.throw和throws的区别</h6> 
<ul><li>throws跟在方法声明后，后面跟的是异常类名；throw在方法内，后面跟的是异常类实例</li><li>throws后面可以跟多个异常类；throw只能抛出一个异常对象</li><li>throws抛出异常，异常由调用者处理；throw由方法体内的语句来处理</li></ul> 
<h6><a id="2023_283"></a>20.23种设计模式</h6> 
<ul><li>创建型（5）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型（7）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型（11）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul> 
<h6><a id="21_288"></a>21.设计模式的几个原则</h6> 
<ul><li>单一职责原则</li><li>接口隔离原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特原则</li><li>依赖倒置原则</li><li>合成复用原则</li></ul> 
<h6><a id="22spring_296"></a>22.spring中涉及的设计模式</h6> 
<ul><li>工厂模式：BeanFactory和ApplicationContext来创建对象</li><li>单例模式：Bean默认为单例模式</li><li>代理模式：AOP动态代理</li><li>模板方法：jdbcTemplete,restTemplete(http请求工具)</li><li>适配器模式：mvc中的处理器适配</li><li>观察者模式：spring时间驱动</li></ul> 
<h4><a name="t1"></a><a name="t5"></a><a id="JVM_304"></a>二、JVM</h4> 
<h6><a name="t6"></a><a id="1JVM_305"></a>1.JVM包含哪几部分</h6> 
<ul><li>类加载器</li><li>运行时数据区（堆、栈、方法区、本地方法栈和程序计数器） 
  <ul><li>方法区：静态变量、常量、类信息和运行时常量池</li><li>程序计数器：每个线程都有一个程序计数器，就像一个指针，指向方法去中的方法字节码（比如每次读下一条指令的时候给它+1）</li><li>本地方法栈：登记native方法，在执行引擎的时候加载本地库</li><li>栈：生命周期和线程同步；不存在垃圾回收问题；存放八大基本类型、对象引用变量名、实例的方法</li><li>堆：类的实例、字符串常量池 
    <ul><li>新生区：伊甸园区、幸存0区、幸存1区</li><li>养老区</li><li>永久区（方法区的具体实现，jdk1.8后改为叫元空间，一部分人认为他不应该划分在堆内，一部分人认为应该划分在堆内）</li></ul></li></ul></li><li>执行引擎</li><li>本地库接口<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/8a/c8/l9ac5XJa_o.png"></li></ul> 
<h6><a name="t7"></a><a id="2_319"></a>2.双亲委派机制</h6> 
<ul><li>类加载器收到类加载的请求</li><li>将这个请求委托给父类加载器去完成，一直向上委托，直到启动类加载器</li><li>启动类加载器能执行就结束，否则抛出异常，依次向下通知子类进行加载</li><li>优点： 
  <ul><li>从最内层开始加载，外层恶意同名类得不到加载从而无法使用</li><li>严格通过包来区分了访问域，外层恶意的类通过内置代码也无法访问到内层类</li></ul></li></ul> 
<h6><a name="t8"></a><a id="3_326"></a>3.创建对象内存分析</h6> 
<p>（案例取自遇见狂神说的java课程视频）<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ef/61/03wUbaLH_o.png"></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a7/69/4W1DW8na_o.png"></p> 
<h6><a name="t9"></a><a id="4JAVA_332"></a>4.JAVA对象实例化过程</h6> 
<ul><li>类的加载初始化 
  <ul><li>加载：载入class对象，不一定是从class文件获取，可以是jar包，或者动态生成的class</li><li>连接 
    <ul><li>验证：校验class字节流是否符合当前jvm规范</li><li>准备：为 类变量 分配内存并设置变量的初始值( 默认值 )。如果是final修饰的对象则是赋值声明值</li><li>解析：将常量池的符号引用替换为直接引用</li></ul></li><li>初始化</li><li>使用</li><li>卸载</li></ul></li><li>对象的初始化<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/1e/ff/GxAG3vmi_o.png"></li></ul> 
<h6><a name="t10"></a><a id="5GC_344"></a>5.GC时候哪些需要回收</h6> 
<ul><li>引用计数算法</li><li>可达性分析算法</li></ul> 
<h6><a name="t11"></a><a id="6GC_347"></a>6.三种基本的GC算法</h6> 
<ul><li>标记-清除算法<br> 内存中的对象构成一棵树，当有效的内存被耗尽的时候，程序就会停止，做两件事，第一：标记，标记从树根可达的对象，第二：清除不可达的对象。标记清除的时候程序会停止运行<br> 缺点：递归效率低性能低；释放空间不连续容易导致内存碎片；会停止整个程序运行；</li><li>复制算法<br> 把内存分成两块区域：空闲区域和活动区域，第一还是标记，标记之后把可达的对象复制到空闲区，将空闲区变成活动区，同时把以前活动区对象清除，变成空闲区。<br> 缺点：速度快但耗费空间</li><li>标记-整理算法<br> 在标记清除算法之后不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</li><li>分代收集算法，即新生代、老年代、永久代</li><li>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度）</li><li>内存整齐度：复制算法=标记压缩算法&gt;标记清除算法</li><li>内存利用率：复制算法&lt;标记清除算法=标记压缩算法</li></ul> 
<h6><a name="t12"></a><a id="7jdkjrejvm_360"></a>7.jdk、jre和jvm</h6> 
<ul><li>jdk：java开发工具包。包括java运行环境(jre)，java工具，java基础的类库</li><li>jre：java运行环境。包括jvm标准实现及java核心类库</li><li>jvm：java虚拟机，一种抽象化的计算机</li></ul> 
<h4><a name="t13"></a><a id="mysql_364"></a>三、mysql</h4> 
<h6><a name="t14"></a><a id="1_365"></a>1.数据库三大范式</h6> 
<ul><li>第一范式：强调的是列的原子性，即列不能够再分成其他几列。</li><li>第二范式：在第一范式基础上，必须有一个主键其他字段必须完全依赖于主键，而不能只依赖于主键的一部分。</li><li>第三范式：在前两个范式基础上，非主键列必须直接依赖于主键，不能存在传递依赖。</li></ul> 
<h6><a name="t15"></a><a id="2sql_369"></a>2.防止sql注入</h6> 
<ul><li>代码层防止sql注入攻击的最佳方案就是sql预编译（prepareedstatement类）</li><li>规定数据长度，能在一定程度上防止sql注入</li><li>严格限制数据库权限，能最大程度减少sql注入的危害 
  <blockquote> 
   <p><strong> 篇幅限制下面就只能给大家展示小册部分内容了。包括了：Java面试、Spring、JVM、MyBatis、Redis、MySQL、并发编程、微服务、Linux、Springboot、SpringCloud、MQ、Kafka 面试专题</strong></p> 
   <p><strong> 需要全套面试笔记的<strong><strong><strong><a href="https://docs.qq.com/doc/DQXdYWE9LZ2ZHZ1ho" rel="nofollow" title="【点击此处即可】">【点击此处即可】</a></strong></strong></strong>即可免费获取</strong></p> 
  </blockquote> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3026229c5dc090684f61f146baa0d07f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【postgresql初级使用】数据库安全防护，核心数据是黑客的终极大boss，多层次建立安全体系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e753e31b16add9fb9007a968d9446c08/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入解析链表：解锁数据结构核心奥秘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>