<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法总结（4） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/55f1f68c96d04f931b5127389cffb591/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="贪心算法总结（4）">
  <meta property="og:description" content="一、跳跃游戏I 55. 跳跃游戏 - 力扣（LeetCode）
class Solution { public: bool canJump(vector&lt;int&gt;&amp; nums) { //贪心&#43;双指针 用left和right指向两个区间 然后maxpos表示下一层的最右端点 int left=0,right=0,maxpos=0,n=nums.size(); while(left&lt;=right) //有可能会跳不到n-1的位置 比如说出现了很多个0 { if(maxpos&gt;=n-1) return true; for(int i=left;i&lt;=right;&#43;&#43;i) maxpos=max(maxpos,nums[i]&#43;i); //找到之后更新区间 left=right&#43;1; right=maxpos; } return false; } }; 二、跳跃游戏II 45. 跳跃游戏 II - 力扣（LeetCode）
解法1 ：动态规划
class Solution { public: int jump(vector&lt;int&gt;&amp; nums) { //动态规划的思想 dp[i]表示以i位置为结尾时的最小步数 int n=nums.size(); vector&lt;int&gt; dp(n,INT_MAX); dp[0]=0; for(int i=1;i&lt;n;&#43;&#43;i) for(int j=0;j&lt;i;&#43;&#43;j) if(nums[j]&#43;j&gt;=i) dp[i]=min(dp[i],dp[j]&#43;1); return dp[n-1]; } }; 解法2：贪心 &#43;双指针">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-16T08:57:38+08:00">
    <meta property="article:modified_time" content="2024-08-16T08:57:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法总结（4）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="272" src="https://images2.imgbox.com/3b/a9/Nz5i5Lu3_o.gif" width="530"></h2> 
<h2>一、跳跃游戏I</h2> 
<p><a href="https://leetcode.cn/problems/jump-game/description/" rel="nofollow" title="55. 跳跃游戏 - 力扣（LeetCode）">55. 跳跃游戏 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="861" src="https://images2.imgbox.com/fa/cb/rhHrNOEF_o.png" width="1184"></p> 
<p><img alt="" height="891" src="https://images2.imgbox.com/39/ea/ipljF6pP_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
          //贪心+双指针   用left和right指向两个区间 然后maxpos表示下一层的最右端点
        int left=0,right=0,maxpos=0,n=nums.size();
        while(left&lt;=right) //有可能会跳不到n-1的位置 比如说出现了很多个0
        {
            if(maxpos&gt;=n-1) return true;
            for(int i=left;i&lt;=right;++i) maxpos=max(maxpos,nums[i]+i);
            //找到之后更新区间
            left=right+1;
            right=maxpos;
        }
        return false;
    }
};</code></pre> 
<h2>二、跳跃游戏II</h2> 
<p><a href="https://leetcode.cn/problems/jump-game-ii/description/" rel="nofollow" title="45. 跳跃游戏 II - 力扣（LeetCode）">45. 跳跃游戏 II - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1095" src="https://images2.imgbox.com/02/cf/C2FWEvkC_o.png" width="1176"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7e/72/lx7cwlkc_o.png" width="1200"> 解法1 ：动态规划</p> 
<pre><code class="language-cpp">class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
   //动态规划的思想 dp[i]表示以i位置为结尾时的最小步数
       int n=nums.size();
       vector&lt;int&gt; dp(n,INT_MAX);
       dp[0]=0;
       for(int i=1;i&lt;n;++i)
         for(int j=0;j&lt;i;++j)
          if(nums[j]+j&gt;=i) dp[i]=min(dp[i],dp[j]+1);
        return dp[n-1];
    }
};</code></pre> 
<p>解法2：贪心 +双指针</p> 
<pre><code class="language-cpp">class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        //贪心+双指针   用left和right指向两个区间 然后maxpos表示下一层的最右端点
        int left=0,right=0,maxpos=0,ret=0,n=nums.size();
        while(left&lt;=right) //有可能会跳不到n-1的位置 比如说出现了很多个0
        {
            if(maxpos&gt;=n-1) return ret;
            for(int i=left;i&lt;=right;++i) maxpos=max(maxpos,nums[i]+i);
            //找到之后更新区间
            left=right+1;
            right=maxpos;
            ++ret;
        }
        return -1;
    }
};</code></pre> 
<h2>三、加油站</h2> 
<p><a href="https://leetcode.cn/problems/gas-station/description/" rel="nofollow" title="134. 加油站 - 力扣（LeetCode）">134. 加油站 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1156" src="https://images2.imgbox.com/c6/04/1btb9vZ2_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d1/d0/Ka7rOPgC_o.png" width="1200"></p> 
<h2>四、距离相等的条形码</h2> 
<p><a href="https://leetcode.cn/problems/distant-barcodes/description/" rel="nofollow" title="1054. 距离相等的条形码 - 力扣（LeetCode）">1054. 距离相等的条形码 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="840" src="https://images2.imgbox.com/f7/89/LBNccB8j_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/3c/c2/0ArUM1T2_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt;&amp; nums) {
      //贪心  隔一个放一个 要顺便统计最多的那个
      int n=nums.size();
      unordered_map&lt;int,int&gt; hash;
      int maxval=0,maxcount=0;
      for(auto&amp;e:nums)
        if(maxcount&lt;++hash[e])
        {
            maxcount=hash[e];
            maxval=e;
        }
      //开始先放最大的数
      vector&lt;int&gt; ret(n);
      int index=0;
      for(int i=0;i&lt;maxcount;++i)
      {
         ret[index]=maxval;
         index+=2;
      }
      hash.erase(maxval);
      //开始放后面的数字
      for(auto&amp;[x,y]:hash)
         for(int i=0;i&lt;y;++i)
         {
            if(index&gt;=n) index=1;
            ret[index]=x;
            index+=2;
         }
      return ret;
    }
};</code></pre> 
<h2>五、合并区间</h2> 
<p><a href="https://leetcode.cn/problems/merge-intervals/" rel="nofollow" title="56. 合并区间 - 力扣（LeetCode）">56. 合并区间 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="933" src="https://images2.imgbox.com/b2/22/VGUzeZZc_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/74/62/DS9FQOiY_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
       //区间问题  按照左端点排序
       sort(nums.begin(),nums.end());
       int n=nums.size();
       //合并区间
       //用left和right来标记两个区间
       //如果left right     a   b   如果重叠了a&lt;=right right=max(right,b)
                                    //如果没有重叠 将left和right丢到ret中  然后更新
        int left=nums[0][0],right=nums[0][1];
        vector&lt;vector&lt;int&gt;&gt; ret;
        for(int i=1;i&lt;n;++i)
        {
            int a=nums[i][0],b=nums[i][1];
            if(a&lt;=right) right=max(right,b);
            else 
            {
              ret.push_back({left,right});
              left=a,right=b;
            }
        }
        ret.push_back({left,right});
        return ret;
    }
};</code></pre> 
<h2>六、无重叠区间</h2> 
<p><a href="https://leetcode.cn/problems/non-overlapping-intervals/" rel="nofollow" title="435. 无重叠区间 - 力扣（LeetCode）">435. 无重叠区间 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1063" src="https://images2.imgbox.com/16/be/H9kHACgO_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/86/cf/ymPLhunH_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        int n=nums.size();
        int ret=0;
        int left=nums[0][0],right=nums[0][1];
        for(int i=1;i&lt;n;++i)
        {
            int a=nums[i][0],b=nums[i][1];
            if(a&lt;right) 
            {
                right=min(right,b);
                ++ret;
            } //移除右端点较大的区间  更新右区间
            else right=b;
        }
        return ret;
    }
};</code></pre> 
<h2>七、用最少数量的箭引爆气球</h2> 
<p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/" rel="nofollow" title="452. 用最少数量的箭引爆气球 - 力扣（LeetCode）">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="1049" src="https://images2.imgbox.com/35/17/yhldeLJu_o.png" width="1178"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c5/78/arfSQ3hl_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
      //只要出现重叠区间，就可以用一只箭射穿
      sort(nums.begin(),nums.end());
      int n =nums.size();
      int left=nums[0][0],right=nums[0][1]; //保留的是交集
      int ret=1;
      for(int i=1;i&lt;n;++i)
      {
        int a=nums[i][0],b=nums[i][1];
        if(a&lt;=right)//如果有交集 
        {
          right=min(right,b);
        }
        else //说明没有交集
        {
            right=b;
            ++ret;
        }
      }
      return ret;
    }
};</code></pre> 
<p></p> 
<h2>八、俄罗斯套娃信封问题</h2> 
<p><a href="https://leetcode.cn/problems/russian-doll-envelopes/" rel="nofollow" title="354. 俄罗斯套娃信封问题 - 力扣（LeetCode）">354. 俄罗斯套娃信封问题 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="985" src="https://images2.imgbox.com/34/c9/Tce0U4Bd_o.png" width="1178"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/cf/50/bsk0Wy1B_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; e) {
       //重写排序+贪心+二分
       int n=e.size();
       sort(e.begin(),e.end(),[&amp;e](const vector&lt;int&gt;&amp;v1, const vector&lt;int&gt;&amp;v2){
             return v1[0]!=v2[0]?v1[0]&lt;v2[0]:v1[1]&gt;v2[1];
       });
       vector&lt;int&gt; ret;
       ret.emplace_back(e[0][1]);
       for(int i=1;i&lt;n;++i)
       {
          int b=e[i][1];
         //如果我比最后一个都大 我直接尾插
         if(b&gt;ret.back()) ret.emplace_back(b);
         else //否则就二分
         {
             int left=0,right=ret.size()-1;
             while(left&lt;right)
             {
               int mid=(left+right)&gt;&gt;1;
               if(ret[mid]&lt;b) left=mid+1;
               else right=mid;
             }
             ret[left]=b;
         }
       }
       return ret.size();
    }
};</code></pre> 
<h2>九、堆箱子</h2> 
<p><a href="https://leetcode.cn/problems/pile-box-lcci/" rel="nofollow" title="面试题 08.13. 堆箱子 - 力扣（LeetCode）">面试题 08.13. 堆箱子 - 力扣（LeetCode）</a></p> 
<p><img alt="" height="698" src="https://images2.imgbox.com/2d/cd/DFegV9pp_o.png" width="1170"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int pileBox(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {
       sort(nums.begin(),nums.end());
       int n=nums.size();
       //23 54 64 67
       //dp[i]表示以i位置为结尾的最长递增子序列的长度
       vector&lt;int&gt; dp(n);
       for(int i=0;i&lt;n;++i) dp[i]=nums[i][2];
       for(int i=1;i&lt;n;++i)
          //开始往前找
          for(int j=0;j&lt;i;++j) 
          if(nums[i][0]&gt;nums[j][0]&amp;&amp;nums[i][1]&gt;nums[j][1]&amp;&amp;nums[i][2]&gt;nums[j][2])
           dp[i]=max(dp[i],dp[j]+nums[i][2]);
        return *max_element(dp.begin(),dp.end()); 
    }
};</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d8/60/zGCCwMhN_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5af0012a89d7ad78df0eae44034ff48/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python酷库之旅-第三方库Pandas(082)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42ae6082c445599672906a1be352c7d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【爬虫新手村】零基础入门到实战：解锁互联网数据收集的密钥，爬虫技术全攻略</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>