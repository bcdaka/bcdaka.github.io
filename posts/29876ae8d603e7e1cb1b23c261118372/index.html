<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;必修：探索C&#43;&#43;的内存管理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/29876ae8d603e7e1cb1b23c261118372/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;必修：探索C&#43;&#43;的内存管理">
  <meta property="og:description" content="✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：C&#43;&#43;学习
贝蒂的主页：Betty’s blog
1. C/C&#43;&#43;的内存分布 我们首先来看一段代码及其相关问题
int globalVar = 1; static int staticGlobalVar = 1; void Test() { static int staticVar = 1; int localVar = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = &#34;abcd&#34;; const char* pChar3 = &#34;abcd&#34;; int* ptr1 = (int*)malloc(sizeof(int) * 4); int* ptr2 = (int*)calloc(4, sizeof(int)); int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4); free(ptr1); free(ptr3); } 选择题：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-10T19:00:17+08:00">
    <meta property="article:modified_time" content="2024-06-10T19:00:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;必修：探索C&#43;&#43;的内存管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><img src="https://images2.imgbox.com/6a/53/uEcSk2gb_o.png" alt=""></p> 
 <p>✨✨ 欢迎大家来到贝蒂大讲堂✨✨</p> 
 <p>🎈🎈养成好习惯，先赞后看哦~🎈🎈</p> 
 <p>所属专栏：<a href="http://t.csdnimg.cn/mF5s8" rel="nofollow">C++学习</a><br> 贝蒂的主页：<a href="https://blog.csdn.net/Bettysweetyaaa?type=lately">Betty’s blog</a></p> 
</blockquote> 
<h3><a id="1_CC_9"></a>1. C/C++的内存分布</h3> 
<p>我们首先来看一段代码及其相关问题</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> globalVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> staticGlobalVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> staticVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> localVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> num1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> char2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pChar3 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>选择题：</p> 
<p>选项: A.栈 B.堆 C.数据段(静态区) D.代码段(常量区)</p> 
<blockquote> 
 <ol><li><code>globalVar</code>在哪里？<strong>C</strong> <code>staticGlobalVar</code>在哪里？<strong>C</strong></li></ol> 
 <ul><li>解析：<code>globalVar</code>为全局变量放在数据段(静态区)，<code>staticGlobalVar</code>也是全局变量放在数据段(静态区)。两者之间主要区别在：普通全局变量作用于整个代码，可被其他文件访问或修改。而被<code>static</code>修饰的静态全局变量只作用于当前文件，其他文件不可见。</li></ul> 
 <ol start="2"><li><code>staticVar</code>在哪里？<strong>C</strong> <code>localVar</code>在哪里？<strong>A</strong></li></ol> 
 <ul><li>解析：被<code>static</code>修饰的局部变量<code>staticVar</code>放在静态区，普通的局部变量<code>localVar</code>放在栈区。两者之间主要区别在：被<code>static</code>修饰的局部变量的生命周期只会在程序结束后结束，而普通的局部变量的生命周期出了当前作用域就会结束。</li></ul> 
 <ol start="3"><li><code>num1</code> 在哪里？<strong>A</strong></li></ol> 
 <ul><li>解析：<code>num1</code>也是一个局部变量，放在栈区。</li></ul> 
 <ol start="4"><li><code>char2</code>在哪里？<strong>A</strong> <code>*char2</code>在哪里？<strong>A</strong></li></ol> 
 <ul><li>解析：<code>char2</code>也是一个局部变量，放在栈区，常量字符串<code>"abcd"</code>放在代码段(常量区)，数组开辟的空间放在栈区。在数组开辟时，常量字符串中字符会被一个一个拷贝进入数组，而数组名是首元素地址，所以<code>*char2</code>得到数组第一个元素，放在栈区。</li></ul> 
 <ol start="5"><li><code>pChar3</code>在哪里？<strong>A</strong> <code>*pChar3</code>在哪里？<strong>D</strong></li></ol> 
 <ul><li>解析：<code>char2</code>也是一个局部指针变量，指向一个放在代码段(常量区)的常量字符串<code>"abcd"</code>。所以<code>*pChar3</code>得到常量字符串的第一个字符，放在代码段(常量区)。</li></ul> 
 <ol start="6"><li><code>ptr1</code>在哪里？<strong>A</strong> <code>*ptr1</code>在哪里？<strong>B</strong></li></ol> 
 <ul><li>解析：<code>ptr1</code>是一个局部指针变量，放在栈区。而其指向的内存区域是由动态内存开辟的，所以<code>*ptr1</code>放在堆区。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d3/00/xVu0PW7I_o.png" alt="img"></p> 
<blockquote> 
 <ol><li><strong>栈区</strong>：又叫堆栈，存放非静态局部变量/函数参数/返回值等等，并且栈是向下增长的 。</li><li><strong>堆区</strong>：一般由程序员分配释放， 若程序员不释放，会造成内存泄漏，并且堆是向上增长的</li><li>**内存映射段：**是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。</li><li><strong>数据段（静态区）</strong>：存放全局变量、静态数据。程序结束后由系统释放。</li><li><strong>代码段（常量区）</strong>：存放函数体（类成员函数和全局函数）的二进制代码与只读常量。</li></ol> 
</blockquote> 
<ol start="2"><li>填空题：</li></ol> 
<blockquote> 
 <ol><li><code>sizeof(num1)</code> = <strong>40</strong>;</li></ol> 
 <ul><li>sizeof(数组名)计算的是整个数组的大小，<code>4×10=40</code>。</li></ul> 
 <ol start="2"><li><code>sizeof(char2)</code> = <strong>5</strong>; <code>strlen(char2)</code> = <strong>4</strong>;</li></ol> 
 <ul><li>sizeof(数组名)计算的是整个数组的大小，包括<code>'\0'</code>。strlen不包括<code>'\0'</code>。</li></ul> 
 <ol start="3"><li><code>sizeof(pChar3)</code> = <strong>4/8</strong>; <code>strlen(pChar3)</code> = <strong>4</strong>;</li></ol> 
 <ul><li><code>pChar3</code>是指针变量，在32位平台下是4个字节，在64位平台下为8个字节。</li></ul> 
 <ol start="4"><li><code>sizeof(ptr1)</code> = <strong>4/8</strong>;</li></ol> 
 <ul><li><code>ptr1</code>是指针变量，在32位平台下是4个字节，在64位平台下为8个字节。</li></ul> 
</blockquote> 
<p>问答题：</p> 
<blockquote> 
 <ol><li><strong>数据结构中的栈与内存管理中的栈有什么联系吗？</strong></li></ol> 
 <ul><li>两者之间并没有太大联系。在数据结构中栈是一种线性数据结构，它的特点是后进先出（LIFO，Last In First Out）。而在内存管理中，栈是一种用于存储函数调用、局部变量、函数参数以及函数调用上下文等信息的内存区域，但是每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行“入栈”操作，而向上回溯阶段则会执行“出栈”操作，这一点与数据结构栈的操作非常类似。</li></ul> 
 <ol><li><strong>数据结构中的堆与内存管理中的堆有什么联系吗？</strong></li></ol> 
 <ul><li>尽管它们都被称为“堆”，但数据结构中的堆和内存管理中的堆其实是两个完全不同的概念，它们之间并没有直接的联系。在数据结构中，堆是一种特殊的树形数据结构，通常是一个完全二叉树，其中每个节点的值都大于等于（或小于等于）其子节点的值。计算机系统内存中的堆是动态内存分配的一部分，程序在运行时可以使用它来存储数据。程序员可以请求一定量的堆内存，用于存储如对象和数组等复杂结构。当这些数据不再需要时，程序员需要释放这些内存，以防止内存泄露。</li></ul> 
</blockquote> 
<h3><a id="2_C_104"></a>2. C语言中的内存管理</h3> 
<h5><a id="211_malloc_106"></a>2.1.1. malloc</h5> 
<blockquote> 
 <ol><li>头文件#include &lt;stdlib.h&gt;</li><li>声明：void* malloc (size_t size);</li></ol> 
 <ul><li><strong>size</strong> – 内存块的大小，以字节为单位</li><li>如果参数 size 为0，malloc的⾏为是标准是未定义的，取决于编译器。</li></ul> 
 <ol start="3"><li>作用：向内存申请⼀块<strong>连续可⽤</strong>的空间，并返回指向这块空间的指针</li></ol> 
 <ul><li>如果开辟成功，则返回⼀个指向开辟好空间的指针。</li><li>如果开辟失败，则返回⼀个 NULL 指针，因此malloc的返回值⼀定要做检查。</li></ul> 
 <ol start="4"><li>返回值：返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使⽤的时候使⽤者⾃⼰来决定。</li></ol> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//申请大小为一个整型的空间</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//检查是否分配失败</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc fail:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="212_calloc_130"></a>2.1.2. calloc</h5> 
<blockquote> 
 <ol><li>头文件：#include &lt;stdlib.h&gt;</li><li>声明：void *calloc(size_t nitems, size_t size)</li></ol> 
 <ul><li><strong>nitems</strong> – 要被分配的元素个数。</li><li><strong>size</strong> – 元素的大小。</li></ul> 
 <ol start="3"><li> <p>作用： 分配所需的内存空间，并返回一个指向它的指针</p> </li><li> <p>返回值：该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL。</p> </li></ol> 
 <ul><li><strong>malloc</strong> 和 <strong>calloc</strong> 之间的不同点是，malloc 不会设置内存为零，而 <strong>calloc会初始化分配的内存为零。</strong></li></ul> 
</blockquote> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//分配10个大小为整型的空间，并初始化为0</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//检查是否分配失败</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"calloc fail:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="213_realloc_154"></a>2.1.3. realloc</h5> 
<blockquote> 
 <ol><li>头文件：#include &lt;stdlib.h&gt;</li><li>声明：void *realloc(void *ptr, size_t size)</li></ol> 
 <ul><li><strong>ptr</strong> – 指针指向一个要重新分配内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针。</li><li><strong>size</strong> – 内存块的新的大小，以字节为单位。如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。</li></ul> 
 <ol start="3"><li> <p>作用：尝试重新调整之前调用 <strong>malloc</strong> 或 <strong>calloc</strong> 所分配的 <strong>ptr</strong> 所指向的内存块的大小。</p> </li><li> <p>返回值：该函数返回一个指针 ，指向重新分配大小的内存。如果请求失败，则返回 NULL。</p> </li></ol> 
</blockquote> 
<pre><code class="prism language-c">	<span class="token keyword">int</span><span class="token operator">*</span> ptr3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr3 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//检查是否分配失败</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc fail:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span><span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重新分配内存</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//检查是否分配失败</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"realloc fail:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	ptr3 <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token comment">//重新指向那块空间</span>
</code></pre> 
<h3><a id="3_C_182"></a>3. C++中的内存管理</h3> 
<p>C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过<strong>new</strong>和<strong>delete</strong>操作符进行动态内存管理。</p> 
<h4><a id="31_newdelete_186"></a>3.1. new与delete操作内置类型</h4> 
<p>使用new与delete操作内置类型十分简单，我们直接通过代码示例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestNew1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//开辟一个整型大小的空间</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
	<span class="token comment">//开辟一个整型大小的空间并初始化为1</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//开辟一个双精度浮点型大小的空间</span>
	<span class="token keyword">double</span><span class="token operator">*</span> ptr3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">;</span>
	<span class="token comment">//开辟一个双精度浮点型大小的空间并初始化为0.1</span>
	<span class="token keyword">double</span><span class="token operator">*</span> ptr4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//以此内推......</span>
	<span class="token comment">//与C语言free功能类似，释放空间防止内存泄漏</span>
	<span class="token keyword">delete</span> ptr1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ptr2<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ptr3<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ptr4<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>除了开辟整型，浮点型这类空间外，我们还能动态开辟数组。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestNew2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//开辟大小为10个整型的数组</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//开辟大小为10个整型的数组,并初始化</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//开辟大小为10个双精度浮点型的数组</span>
	<span class="token keyword">double</span><span class="token operator">*</span> ptr3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">//开辟大小为10个双精度浮点型的数组,并初始化</span>
	<span class="token keyword">double</span><span class="token operator">*</span> ptr4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.2</span><span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//数组释放空间需要使用 delete[]</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr2<span class="token punctuation">;</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr3<span class="token punctuation">;</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ptr4<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p><strong>注意：</strong></p> 
<ul><li><strong>new单个类型与new一个数组，释放空间要分别与delete和delete[]配套使用，否则可能出现未知的结果。</strong></li><li><strong>在动态内存开辟数组时初始化与C语言数组初始化一样，未注明该初始化某个数值时，默认为0。并且对动态内存开辟数组时初始化是C++11支持的。</strong></li></ul> 
<p><img src="https://images2.imgbox.com/51/f8/EqrGnzB5_o.png" alt="img"></p> 
<h4><a id="32_newdelete_239"></a>3.2. new与delete操作自定义类型</h4> 
<p>new/delete操作内置类型其实与C语言中的malloc/free并没有本质的区别，但是自定义类型就不一样了。请看下面这段代码。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Betty</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Betty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Betty()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">Betty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Betty()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">TestNew3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Betty<span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span>Betty<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Betty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Betty<span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token keyword">new</span> Betty<span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ptr2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/63/c0/RPRgJFi7_o.png" alt="img"></p> 
<ul><li>从这里我们就知道：<strong>new创建自定义类型时会自动调用其构造函数，delete释放其空间时会自动调用其析构函数。</strong></li></ul> 
<h4><a id="33_operator_newoperator_delete_271"></a>3.3. <strong>operator new与operator delete函数</strong></h4> 
<p>new和delete是用户进行动态内存申请和释放的操作符，而<strong>operator new 和operator delete是系统提供的全局函数，并且operator new和operator delete也不是对new和delete的重载，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间</strong>。以下是operator new与operator delete函数的源代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> __CRTDECL <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token function">_THROW1</span><span class="token punctuation">(</span>_STD bad_alloc<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// try to allocate size bytes</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_callnewh</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">// report no memory</span>
			<span class="token comment">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常</span>
			<span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>bad_alloc nomem<span class="token punctuation">;</span>
			<span class="token function">_RAISE</span><span class="token punctuation">(</span>nomem<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
operator delete: 该函数最终是通过free来释放空间的
*/</span>
<span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> pUserData<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_CrtMemBlockHeader<span class="token operator">*</span> pHead<span class="token punctuation">;</span>
	<span class="token function">RTCCALLBACK</span><span class="token punctuation">(</span>_RTC_Free_hook<span class="token punctuation">,</span> <span class="token punctuation">(</span>pUserData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pUserData <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">_mlock</span><span class="token punctuation">(</span>_HEAP_LOCK<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* block other threads */</span>
	__TRY
		<span class="token comment">/* get a pointer to memory block header */</span>
		pHead <span class="token operator">=</span> <span class="token function">pHdr</span><span class="token punctuation">(</span>pUserData<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* verify block type */</span>
	<span class="token function">_ASSERTE</span><span class="token punctuation">(</span><span class="token function">_BLOCK_TYPE_IS_VALID</span><span class="token punctuation">(</span>pHead<span class="token operator">-&gt;</span>nBlockUse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">_free_dbg</span><span class="token punctuation">(</span>pUserData<span class="token punctuation">,</span> pHead<span class="token operator">-&gt;</span>nBlockUse<span class="token punctuation">)</span><span class="token punctuation">;</span>
	__FINALLY
		<span class="token function">_munlock</span><span class="token punctuation">(</span>_HEAP_LOCK<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* release other threads */</span>
	__END_TRY_FINALLY
		<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过上述两个全局函数的实现知道，<strong>operator new 实际也是通过malloc来申请空间</strong>，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常<strong>operator delete 最终是通过free来释放空间的</strong>。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestNew4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Betty<span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span>Betty<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Betty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Betty<span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span>Betty<span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Betty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">operator</span> <span class="token keyword">delete</span> <span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>通过观察我们发现operator new与operator delete函数对于自定义类型一样不会调用其构造函数与析构函数。</li></ul> 
<h4><a id="34_newdelete_327"></a>3.4. new与delete的实现</h4> 
<p>通过上述的学习之后，我们就可以来简单探究一下new与delete的实现原理，请看下面这段代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestNew5</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span><span class="token comment">//内置类型</span>
	Betty<span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token keyword">new</span> Betty<span class="token punctuation">;</span><span class="token comment">//自定义类型</span>
	<span class="token keyword">delete</span> ptr1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ptr2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们可以通过查看反汇编来具体观察new与delete是如何运作的：</p> 
<p><img src="https://images2.imgbox.com/76/59/geanxjra_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/5f/d3/1dlSwQPE_o.png" alt="img"></p> 
<p>通过观察我们总结出以下这些规律：</p> 
<ol><li><strong>对于内置类型</strong></li></ol> 
<blockquote> 
 <p>如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new / delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL。</p> 
</blockquote> 
<ol><li><strong>对于自定义类型</strong></li></ol> 
<blockquote> 
 <ol><li><strong>new的原理</strong></li></ol> 
 <ul><li>调用operator new函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ul> 
 <ol start="2"><li><strong>delete的原理</strong></li></ol> 
 <ul><li>在空间上执行析构函数，完成对象中资源的清理工作</li><li>调用operator delete函数释放对象的空间</li></ul> 
 <ol start="3"><li><strong>new T[N]的原理</strong></li></ol> 
 <ul><li>调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请</li><li>在申请的空间上执行N次构造函数</li></ul> 
 <ol start="4"><li><strong>delete[]的原理</strong></li></ol> 
 <ul><li>在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理</li><li>调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释<br> 放空间</li></ul> 
</blockquote> 
<h4><a id="35_new_376"></a>3.5. 定位new表达式</h4> 
<p>我们知道我们可以在类外直接显示调用析构函数，但是无法直接调用构造函数。如果想在类外调用，则需要使用定位new，定位new简单来说就是**对已分配的原始内存空间中调用构造函数初始化一个对象。**其语法形式如下：</p> 
<blockquote> 
 <p>new (place_address) type或者new(place_address) type(initializer - list)</p> 
 <p>place_address必须是一个指针，initializer - list是类型的初始化列表</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(int a = 0)："</span><span class="token operator">&lt;&lt;</span>_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">TestNew6</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 注意：如果A类的构造函数有参数时，此处需要传参</span>
	<span class="token keyword">new</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>A<span class="token punctuation">;</span> 
	p1<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">new</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p2<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/dc/20/fbjAO8ZT_o.png" alt="img"></p> 
<h3><a id="4_mallocfreenewdelete_417"></a>4. <strong>malloc/free和new/delete的区别</strong></h3> 
<p>malloc / free和new / delete的共同点是：<strong>都是从堆上申请空间，并且需要用户手动释放</strong>。不同的地方是：</p> 
<blockquote> 
 <ol><li>malloc和free是函数，new和delete是操作符。</li><li>malloc申请的空间不会初始化，new可以初始化。</li><li>malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可，如果是多个对象，[]中指定对象个数即可。</li><li>malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型。</li><li>malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常。</li><li>申请自定义类型对象时，malloc / free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理。</li></ol> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0676b2152270cf7f9890ed30eb8900f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Navicat导入json文件（json文件数据导入到MySQL表中）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/362983b48e930b0943d19342735d8f35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】详解堆排序当中的topk问题（leetcode例题）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>