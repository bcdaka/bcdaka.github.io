<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java本地缓存(map,Guava,echcache,caffeine)优缺点，以及适用场景 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0075ebed4ce4c016c8370afbc2156b4f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="java本地缓存(map,Guava,echcache,caffeine)优缺点，以及适用场景">
  <meta property="og:description" content="前言 在高并发系统环境下，jvm本地缓存扮演着至关重要的角色，合理的应用能够使系统响应迅速，提高用户体验感，而分布式缓存redis则存在着网络io，以及流量消耗问题，需要和本地缓存搭配使用，才能使系统请求更快，下面我们分别介绍一下四种本地缓存
ConcurrentHashMap (Java 标准库) 介绍
ConcurrentHashMap 是 Java 标准库中的线程安全的哈希表实现，它支持并发访问和修改。通过锁分段机制（segment locking）实现高并发访问，允许多个线程并发地读取和写入。
优点
线程安全：内部实现了细粒度的锁，允许高并发访问。
简单易用：Java 标准库类，无需额外依赖。
性能优越：适用于高并发场景，读写性能较好。
缺点
缺少高级功能：没有内置的过期策略、最大容量控制、缓存统计等高级功能。
没有持久化：数据仅存在于内存中，程序结束后数据丢失。
适用场景
简单的缓存需求，例如会话缓存、短期数据缓存等。
高并发环境下的基本缓存使用
Guava Cache 介绍
Guava 是 Google 提供的一个开源 Java 库，其中的 Cache 类提供了一个轻量级的本地缓存实现，支持各种缓存策略。
优点
简单易用：API 设计简洁明了，易于使用。
灵活配置：支持多种缓存策略，如基于时间、基于大小的过期和自动刷新。
高效：适用于中等规模的缓存需求，性能良好。
缺点
功能有限：不支持持久化和分布式缓存，仅限于本地内存缓存。
依赖库：需要引入 Guava 库。
适用场景
中等规模的应用程序，适合需要灵活过期策略的缓存需求。
缓存配置较简单，不需要持久化存储
Ehcache 介绍
Ehcache 是一个广泛使用的开源 Java 缓存库，功能丰富，支持多种缓存策略，并且可以持久化到磁盘，还提供高可用性和分布式缓存支持。
优点
功能丰富：支持多种缓存策略、持久化到磁盘、分布式缓存等高级功能。
高度可配置：提供丰富的配置选项，能精细调整缓存行为。
持久化支持：数据可以持久化到磁盘，适合长期数据缓存需求。
与 Spring 和 Hibernate 集成良好：提供与这些框架的无缝集成。
缺点
配置复杂：配置选项繁多，初学者需要一定的学习成本。
性能开销：功能丰富带来的性能开销，不适合极高性能要求的场景。
适用场景
企业级应用，需要高级功能如持久化、分布式缓存、复杂缓存策略的场景。
与 Spring 和 Hibernate 集成的项目，缓存数据库查询结果、会话数据等">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-17T13:48:44+08:00">
    <meta property="article:modified_time" content="2024-06-17T13:48:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java本地缓存(map,Guava,echcache,caffeine)优缺点，以及适用场景</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>在高并发系统环境下，jvm本地缓存扮演着至关重要的角色，合理的应用能够使系统响应迅速，提高用户体验感，而分布式缓存redis则存在着网络io，以及流量消耗问题，需要和本地缓存搭配使用，才能使系统请求更快，下面我们分别介绍一下四种本地缓存</p> 
<h3><a id="ConcurrentHashMap_Java__2"></a>ConcurrentHashMap (Java 标准库)</h3> 
<p>介绍<br> ConcurrentHashMap 是 Java 标准库中的线程安全的哈希表实现，它支持并发访问和修改。通过锁分段机制（segment locking）实现高并发访问，允许多个线程并发地读取和写入。</p> 
<p>优点<br> 线程安全：内部实现了细粒度的锁，允许高并发访问。<br> 简单易用：Java 标准库类，无需额外依赖。<br> 性能优越：适用于高并发场景，读写性能较好。<br> 缺点<br> 缺少高级功能：没有内置的过期策略、最大容量控制、缓存统计等高级功能。<br> 没有持久化：数据仅存在于内存中，程序结束后数据丢失。<br> 适用场景<br> 简单的缓存需求，例如会话缓存、短期数据缓存等。<br> 高并发环境下的基本缓存使用</p> 
<h3><a id="Guava_Cache_16"></a>Guava Cache</h3> 
<p>介绍<br> Guava 是 Google 提供的一个开源 Java 库，其中的 Cache 类提供了一个轻量级的本地缓存实现，支持各种缓存策略。</p> 
<p>优点<br> 简单易用：API 设计简洁明了，易于使用。<br> 灵活配置：支持多种缓存策略，如基于时间、基于大小的过期和自动刷新。<br> 高效：适用于中等规模的缓存需求，性能良好。<br> 缺点<br> 功能有限：不支持持久化和分布式缓存，仅限于本地内存缓存。<br> 依赖库：需要引入 Guava 库。<br> 适用场景<br> 中等规模的应用程序，适合需要灵活过期策略的缓存需求。<br> 缓存配置较简单，不需要持久化存储</p> 
<h3><a id="Ehcache_30"></a>Ehcache</h3> 
<p>介绍<br> Ehcache 是一个广泛使用的开源 Java 缓存库，功能丰富，支持多种缓存策略，并且可以持久化到磁盘，还提供高可用性和分布式缓存支持。</p> 
<p>优点<br> 功能丰富：支持多种缓存策略、持久化到磁盘、分布式缓存等高级功能。<br> 高度可配置：提供丰富的配置选项，能精细调整缓存行为。<br> 持久化支持：数据可以持久化到磁盘，适合长期数据缓存需求。<br> 与 Spring 和 Hibernate 集成良好：提供与这些框架的无缝集成。<br> 缺点<br> 配置复杂：配置选项繁多，初学者需要一定的学习成本。<br> 性能开销：功能丰富带来的性能开销，不适合极高性能要求的场景。<br> 适用场景<br> 企业级应用，需要高级功能如持久化、分布式缓存、复杂缓存策略的场景。<br> 与 Spring 和 Hibernate 集成的项目，缓存数据库查询结果、会话数据等</p> 
<h3><a id="Caffeine_46"></a>Caffeine</h3> 
<p>介绍<br> Caffeine 是一个高性能的 Java 缓存库，由 Google 的 Guava Cache 发展而来，提供更高效的缓存实现和更多的配置选项。</p> 
<p>优点<br> 高性能：Caffeine 在并发性能和缓存效率上表现卓越。<br> 灵活配置：支持多种缓存策略，如基于时间的过期、基于引用的过期、大小限制等。<br> 主动驱逐：支持基于权重的主动驱逐策略，适合高频访问的缓存场景。<br> 良好的统计信息：提供丰富的缓存统计信息，便于监控和调优。<br> 缺点<br> 无持久化：不支持持久化存储，数据仅存在于内存中。<br> 依赖库：需要引入 Caffeine 库。<br> 适用场景<br> 高并发、高性能要求的应用，如 Web 应用中的热点数据缓存。<br> 需要灵活配置缓存策略但不需要持久化存储的场景</p> 
<h3><a id="_62"></a>总结对比</h3> 
<table><thead><tr><th>缓存库</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>ConcurrentHashMap</td><td>线程安全、简单易用、性能优越、Java 标准库</td><td>缺少高级功能、没有持久化</td><td>简单的高并发缓存需求，如会话缓存、短期数据缓存</td></tr><tr><td>Guava</td><td>简单易用、灵活配置、高效、Google 维护</td><td>功能有限、不支持持久化和分布式缓存</td><td>中等规模的应用，需要灵活过期策略的缓存需求</td></tr><tr><td>Ehcache</td><td>功能丰富、持久化支持、高度可配置、与 Spring 和 Hibernate 集成良好</td><td>配置复杂、性能开销相对较大</td><td>需要高级功能的企业级应用，如持久化、分布式缓存</td></tr><tr><td>Caffine</td><td>高性能、灵活配置、主动驱逐、良好的统计信息</td><td>无持久化、依赖库</td><td>高并发、高性能要求的应用，如 Web 热点数据缓存</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7462d5ba202971a0a3c5d1377ba518f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为 huawei 交换机配置 Dot1q 终结子接口接入 L3VPN 示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b40b2664a5c3870a9f26471750638e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解各种LLM系列｜（5）LLaMA 3模型解析（Meta重磅发布！）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>