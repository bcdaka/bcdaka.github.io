<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Golang】Go语言中defer与return的精妙交织：探索延迟执行与返回顺序的微妙关系 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9e147330e8a12125b950d3b287bc9640/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Golang】Go语言中defer与return的精妙交织：探索延迟执行与返回顺序的微妙关系">
  <meta property="og:description" content="【Golang】Go语言中defer与return的精妙交织：探索延迟执行与返回顺序的微妙关系 大家好 我是寸铁👊
总结了一篇defer 和 return 返回值 的执行顺序探讨的文章✨
喜欢的小伙伴可以点点关注 💝
前言 在Go语言中，defer 和return是两个非常重要的关键字，它们在函数执行过程中起着至关重要的作用。defer 用于延迟执行一个函数调用，通常用于在函数执行结束后进行一些清理工作或资源释放操作。而return则用于从函数中返回结果并终止函数的执行。在Go语言中，defer 语句的执行时机和返回值的处理方式涉及到一些微妙的规则，特别是在 defer 和 return 同时出现时，其执行顺序可能会引发一些混淆和困惑。
本文将深入探讨Go语言中 defer 和return的执行顺序，并解释它们之间的关系。我们将详细讨论在不同情况下，defer 和 return 的执行顺序及其影响，以帮助读者更好地理解和使用这两个关键字，从而写出更加健壮、清晰的代码。
defer与return常考点 简述 defer 和 return 返回值 的执行顺序？如果要返回一个 defer 执行后的值, 可以通过哪些方式？
程序1 不返回具体变量 执行顺序：
进入test函数
先把返回的结果赋值执行defer函数如果说defer函数中存在打印输出的内容，则先输出defer语句的内容。
按照指定的顺序输出，后进先出的顺序输出再返回到主函数main中，把之前赋值的返回的结果输出来 注意：return的结果是不会受defer函数而影响的，但是假如在defer外 在return之前进行赋值
则会返回当前更新的值。
demo
func Test() int { a := 1 defer func() { fmt.Println(&#34;a&#34;, a) // a 1 a = 4 fmt.Println(&#34;2&#34;, a) // 2 4 }() return a // 1 } func main() { fmt.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-10T20:21:29+08:00">
    <meta property="article:modified_time" content="2024-06-10T20:21:29+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Golang】Go语言中defer与return的精妙交织：探索延迟执行与返回顺序的微妙关系</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="GolangGodeferreturn_0"></a>【Golang】Go语言中defer与return的精妙交织：探索延迟执行与返回顺序的微妙关系</h2> 
<blockquote> 
 <p>大家好 我是寸铁👊<br> 总结了一篇defer 和 return 返回值 的执行顺序探讨的文章✨<br> 喜欢的小伙伴可以点点关注 💝</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6d/59/ADXrIpwy_o.gif" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_11"></a>前言</h3> 
<p>在Go语言中，<code>defer </code>和<code>return</code>是两个非常重要的关键字，它们在函数执行过程中起着至关重要的作用。<code>defer</code> 用于延迟执行一个函数调用，通常用于在函数执行结束后进行一些清理工作或资源释放操作。而<code>return</code>则用于从函数中返回结果并终止函数的执行。在Go语言中，defer 语句的执行时机和返回值的处理方式涉及到一些微妙的规则，特别是在 defer 和 return 同时出现时，其执行顺序可能会引发一些<strong>混淆和困惑</strong>。<br> 本文将<strong>深入探讨</strong>Go语言中<code> defer</code> 和<code>return</code>的执行顺序，并解释它们之间的关系。我们将详细讨论在不同情况下，<code>defer</code> 和 <code>return </code>的执行顺序及其影响，以帮助读者更好地理解和使用这两个关键字，从而写出更加健壮、清晰的代码。</p> 
<h3><a id="deferreturn_15"></a>defer与return常考点</h3> 
<blockquote> 
 <p><strong>简述 <code>defer </code>和 <code>return</code> 返回值 的执行顺序？如果要返回一个 defer 执行后的值, 可以通过哪些方式？</strong></p> 
</blockquote> 
<hr> 
<h3><a id="1_20"></a>程序1</h3> 
<h4><a id="_22"></a>不返回具体变量</h4> 
<p><strong>执行顺序：</strong><br> <strong>进入test函数</strong></p> 
<ol><li>先把返回的结果赋值</li><li>执行<code>defer</code>函数</li><li>如果说<code>defer</code>函数中存在打印输出的内容，则先输出<code>defer</code>语句的内容。<br> <strong>按照指定的顺序输出，后进先出的顺序输出</strong></li><li>再返回到主函数main中，把之前赋值的返回的结果输出来</li></ol> 
<blockquote> 
 <p>注意：return的结果是不会受<code>defer</code>函数而影响的，但是假如在<code>defer外</code> 在<code>return之前</code>进行赋值<br> 则会返回<code>当前更新</code>的值。</p> 
</blockquote> 
<p>demo</p> 
<pre><code class="prism language-go">
<span class="token keyword">func</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{<!-- --></span>
    a <span class="token operator">:=</span> <span class="token number">1</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">// a 1 </span>
        a <span class="token operator">=</span> <span class="token number">4</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">// 2 4</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> a <span class="token comment">// 1</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//1</span>

<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="2_53"></a>程序2</h3> 
<h4><a id="_55"></a>返回指定的变量</h4> 
<p>执行顺序：<br> 进入test函数</p> 
<ol><li>先把返回的结果赋值</li><li>执行<code>defer</code>函数</li><li>如果说<code>defer</code>函数中存在打印输出的内容，则先输出<code>defer</code>函数语句的内容。<br> <strong>按照指定的顺序输出，后进先出的顺序输出</strong></li><li>再返回到主函数main中，把之前赋值的返回的结果输出来</li></ol> 
<blockquote> 
 <p>注意：函数中先对返回的结果进行定义<code>:=</code> 而不是直接赋值<code>=</code>，return的结果是<code>不会受defer函数而影响的</code>，但是假如<code>在defer外 </code>在<code>return之前</code>进行赋值 则会返回<code>当前更新</code>的值。如下demo1和demo2</p> 
</blockquote> 
<hr> 
<h5><a id="_67"></a>函数内先对返回值定义:=</h5> 
<p>demo1</p> 
<pre><code class="prism language-go">

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    t <span class="token operator">:=</span> <span class="token number">5</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        t <span class="token operator">=</span> t <span class="token operator">+</span> <span class="token number">5</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> t
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//5</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<p><strong>验证一下return的结果会不会受到defer函数的影响</strong><br> <strong>根据输出结果，是不会受到影响的！</strong></p> 
<p>demo2</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    t <span class="token operator">:=</span> <span class="token number">5</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        t <span class="token operator">=</span> t <span class="token operator">+</span> <span class="token number">5</span>
        t <span class="token operator">=</span> <span class="token number">12</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    t <span class="token operator">=</span> <span class="token number">20</span>
    <span class="token keyword">return</span> t <span class="token comment">//此时t从5 --&gt; 20</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//20</span>
<span class="token punctuation">}</span>

</code></pre> 
<hr> 
<p><strong>再来看这种情况,与上面的demo不同的点在于返回参数<code>result</code>在defer中参与了运算</strong></p> 
<p>demo3</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">deferFuncReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>result <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    i <span class="token operator">:=</span> <span class="token number">5</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       result <span class="token operator">+=</span> <span class="token number">5</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> i <span class="token comment">//这里由于返回的result参与了运算,所以会经过defer处理,返回的结果为10</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>函数说明：</p> 
<blockquote> 
 <p>函数拥有一个具名返回值<code>result</code>，函数内部声明一个变量<code>i</code>，<code>defer</code>指定一个延迟函数，最后返回变量i。延迟函数中增加<code>result</code>。</p> 
</blockquote> 
<p>参考答案：</p> 
<blockquote> 
 <p>函数输出10。函数的return语句并不是原子的，实际执行分为设置返回值—&gt;ret，defer语句实际执行在返回前，即拥有defer的函数返回过程是：设置返回值—&gt;执行defer—&gt;ret。所以return语句先把result设置为i的值，即5，defer语句中又把result递增5，所以最终返回10。</p> 
</blockquote> 
<p>小结：<br> 所以，这里的关键点在于<code>具名返回值</code>（也就是返回的参数列表中的变量）是否参与<code>defer</code> 运算，参与运算则返回值会受到<code>defer</code>的处理影响，不参与则与之无关。</p> 
<hr> 
<h5><a id="_131"></a>函数内没有对返回值进行定义</h5> 
<p><strong>函数中没有对返回值进行定义(:=) 函数返回值先进行初始化 之后在函数内进行赋值 之后defer函数可以返回经过defer操作后的值</strong></p> 
<p><strong>返回值是与defer中的程序有关</strong><br> demo</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>t <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    t <span class="token operator">=</span> <span class="token number">5</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       t <span class="token operator">=</span> t <span class="token operator">+</span> <span class="token number">5</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> t <span class="token comment">//返回值是与defer中的程序有关 </span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>分析：defer在return之后执行，但是在函数退出之前，defer可以修改返回值。这里是先对返回值赋值为5 之后待返回值赋值后 执行defer函数 对t的值进行修改 之后返回的值t也会被defer函数所修改。</p> 
</blockquote> 
<hr> 
<p><strong>再来看一下这一组demo</strong></p> 
<p><strong>返回值是与defer中的程序有关 如果在defer的外面重新给t赋值后 则返回的结果值会随之修改</strong></p> 
<p>demo</p> 
<pre><code class="prism language-go">
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>t <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    t <span class="token operator">=</span> <span class="token number">5</span>
    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       t <span class="token operator">=</span> t <span class="token operator">+</span> <span class="token number">5</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    t  <span class="token operator">=</span> <span class="token number">12</span>
    <span class="token keyword">return</span> t <span class="token comment">//返回值是与defer中的程序有关 如果在defer的外面重新给t赋值后 则返回的结果值会随之修改</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//17</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>分析：这里先对返回值t进行赋值 此时t为5 此时还没执行defer函数 是在赋值给return 的结果完毕后才执行defer函数 很明显 这里t又被修改为12 此时t的值赋值完毕 开始执行defer函数，对t的值进行修改，此时t = 12 + 5 = 17 返回给主函数 输出17</p> 
</blockquote> 
<h5><a id="defer_181"></a>返回一个defer执行后的值</h5> 
<p><strong>如果要返回一个 defer 执行后的值, 可以通过那些方式？</strong><br> 见上：<code>函数中没有对返回值进行定义的情况</code></p> 
<blockquote> 
 <p>简述：函数中没有对返回值进行定义(:=) 函数返回值先进行初始化 之后在函数内进行赋值 之后defer函数可以返回经过defer操作后的值</p> 
</blockquote> 
<hr> 
<h3><a id="_189"></a>结语</h3> 
<blockquote> 
 <p>通过本文的讨论，我们更深入地理解了Go语言中 defer 和 return 的执行顺序以及它们之间的关系。defer 语句的延迟执行在函数返回前确保了一些清理工作的完成，而 return 的执行顺序则会受到 defer 的影响，需要注意避免出现意外情况。在编写Go语言程序时，合理使用 defer 和 return 可以使代码更加清晰、简洁，并保证资源的正确释放和程序逻辑的正确执行。希望本文能够帮助读者更好地理解和应用这两个关键字，从而写出高质量的Go语言代码。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>看到这里的小伙伴，恭喜你又掌握了一个知识点👊<br> 后续有更新和变动，会在这里统一做更新，大家可以关注一波🙌<br> 希望大家能取得胜利，坚持就是胜利💪<br> 我是寸铁！我们下期再见💕</p> 
</blockquote> 
<hr> 
<h3><a id="two_hearts_199"></a>往期好文💕</h3> 
<h4><a id="_201"></a>保姆级教程</h4> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135901228?spm=1001.2014.3001.5501">【保姆级教程】Windows11下go-zero的etcd安装与初步使用</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135888765?spm=1001.2014.3001.5502">【保姆级教程】Windows11安装go-zero代码生成工具goctl、protoc、go-zero</a></strong></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135922507?spm=1001.2014.3001.5501"><strong>【Go-Zero】手把手带你在goland中创建api文件并设置高亮</strong></a></p> 
<hr> 
<h4><a id="_211"></a>报错解决</h4> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136037952?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error: user.api 27:9 syntax error: expected ‘:‘ | ‘IDENT‘ | ‘INT‘, got ‘(‘ 报错解决方案及api路由注意事项</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136029821?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error: only one service expected goctl一键转换生成rpc服务错误解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136021340?spm=1001.2014.3001.5501"><strong>【Go-Zero】【error】 failed to initialize database, got error Error 1045 (28000):报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136014038?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES)报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136005713?spm=1001.2014.3001.5501"><strong>【Go-Zero】type mismatch for field “Auth.AccessSecret“, expect “string“, actual “number“报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136002880?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error: user.api 30:2 syntax error: expected ‘)‘ | ‘KEY‘, got ‘IDENT‘报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135921378?spm=1001.2014.3001.5501"><strong>【Go-Zero】Windows启动rpc服务报错panic:context deadline exceeded解决方案</strong></a></p> 
<hr> 
<h4><a id="Go_236"></a>Go面试向</h4> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135777735?spm=1001.2014.3001.5502">【Go面试向】defer与time.sleep初探</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135686421?spm=1001.2014.3001.5502">【Go面试向】defer与return的执行顺序初探</a></strong></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135723403?spm=1001.2014.3001.5502"><strong>【Go面试向】Go程序的执行顺序</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135723403?spm=1001.2014.3001.5502"><strong>【Go面试向】rune和byte类型的认识与使用</strong></a></p> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135722887?spm=1001.2014.3001.5502">【Go面试向】实现map稳定的有序遍历的方式</a></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13a3ffa92d48245eb8d82c31780cf04f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Golang Context详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/df43ad4203293807036bf054d632bb7e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024华为OD机试题库-(A卷&#43;B卷&#43;C卷&#43;D卷)-(JAVA、Python、C&#43;&#43;)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>