<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】深度解析：用 C&#43;&#43; 模拟实现 list 类，探索其底层实现细节 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f3bf345820b7fd4bd018bb03373b5ff5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】深度解析：用 C&#43;&#43; 模拟实现 list 类，探索其底层实现细节">
  <meta property="og:description" content="目录
list介绍
list模拟实现
list 节点类
list 的迭代器
定义 构造函数
解引用
operator前置&#43;&#43;和--与后置&#43;&#43;和--
operator==与operator!=
list 类
构造函数
begin()和end()
拷贝构造
erase()
clear()
析构函数
insert
push_back 和 push_front
pop_back 和 pop_front
完整代码
⭐list介绍 list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。list的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。list与forward_list非常相似：最主要的不同在于forward_list是单链表，只能朝前迭代，已让其更简单高效。与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list 的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素)。 ⭐list模拟实现 list的底层是双向链表结构，包含有一个哨兵节点。模拟实现list，要实现下列三个类： ①list节点类 ②迭代器的类 ③list主要功能的类(size()，empty()...) 模拟实现list的类的基本功能（增删等操作）要建立在迭代器类和节点类均已实现好的情况下才得以完成。
✨list 节点类 定义list中的节点ListNode，包含前驱指针，后驱指针和数据变量；使用struct而不使用class定义类，是为了方便访问每个一个节点 ，struct默认是pbulic，而class中成员变量要定义为private，不方便访问。 template&lt;class T&gt; struct ListNode { ListNode&lt;T&gt;* _next; ListNode&lt;T&gt;* _prev; T _data; ListNode(const T&amp; x = T()) :_next(nullptr) ,_prev(nullptr) ,_data(x) {} }; ✨list 的迭代器 迭代器有两种实现方式，具体应根据容器底层数据结构实现：
1. 原生态指针，比如：vector
2. 将原生态指针进行封装，因迭代器使用形式与指针完全相同，因此在自定义的类中必须实现以下方法：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T12:26:20+08:00">
    <meta property="article:modified_time" content="2024-07-25T12:26:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】深度解析：用 C&#43;&#43; 模拟实现 list 类，探索其底层实现细节</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/a1/19/KmWcg6Hf_o.png"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="list%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#list%E4%BB%8B%E7%BB%8D" rel="nofollow">list介绍</a></p> 
<p id="list%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#list%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">list模拟实现</a></p> 
<p id="list%20%E8%8A%82%E7%82%B9%E7%B1%BB-toc" style="margin-left:40px;"><a href="#list%20%E8%8A%82%E7%82%B9%E7%B1%BB" rel="nofollow">list 节点类</a></p> 
<p id="list%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:40px;"><a href="#list%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">list 的迭代器</a></p> 
<p id="%E5%AE%9A%E4%B9%89%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E4%B9%89%C2%A0" rel="nofollow">定义 </a></p> 
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">构造函数</a></p> 
<p id="%E8%A7%A3%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E5%BC%95%E7%94%A8" rel="nofollow">解引用</a></p> 
<p id="operator%E5%89%8D%E7%BD%AE%2B%2B%E5%92%8C--%E4%B8%8E%E5%90%8E%E7%BD%AE%2B%2B%E5%92%8C---toc" style="margin-left:80px;"><a href="#operator%E5%89%8D%E7%BD%AE%2B%2B%E5%92%8C--%E4%B8%8E%E5%90%8E%E7%BD%AE%2B%2B%E5%92%8C--" rel="nofollow">operator前置++和--与后置++和--</a></p> 
<p id="3.5%20operator%3D%3D%E4%B8%8Eoperator!%3D-toc" style="margin-left:80px;"><a href="#3.5%20operator%3D%3D%E4%B8%8Eoperator!%3D" rel="nofollow">operator==与operator!=</a></p> 
<p id="list%20%E7%B1%BB-toc" style="margin-left:40px;"><a href="#list%20%E7%B1%BB" rel="nofollow">list 类</a></p> 
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">构造函数</a></p> 
<p id="4.2%20begin()%E5%92%8Cend()-toc" style="margin-left:80px;"><a href="#4.2%20begin%28%29%E5%92%8Cend%28%29" rel="nofollow"> begin()和end()</a></p> 
<p id="%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0" rel="nofollow"> 拷贝构造</a></p> 
<p id="erase()-toc" style="margin-left:80px;"><a href="#erase%28%29" rel="nofollow">erase()</a></p> 
<p id="clear()-toc" style="margin-left:80px;"><a href="#clear%28%29" rel="nofollow">clear()</a></p> 
<p id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">析构函数</a></p> 
<p id="insert-toc" style="margin-left:80px;"><a href="#insert" rel="nofollow">insert</a></p> 
<p id="4.8%20push_back%20%E5%92%8C%20push_front-toc" style="margin-left:80px;"><a href="#4.8%20push_back%20%E5%92%8C%20push_front" rel="nofollow"> push_back 和 push_front</a></p> 
<p id="4.10%20pop_back%20%E5%92%8C%20pop_front-toc" style="margin-left:80px;"><a href="#4.10%20pop_back%20%E5%92%8C%20pop_front" rel="nofollow">pop_back 和 pop_front</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">完整代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/0a/05/9OQnE8BM_o.gif"></p> 
<h2 id="list%E4%BB%8B%E7%BB%8D">⭐list介绍</h2> 
<ol><li>list是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代。</li><li>list的底层是<strong><span style="color:#38d8f0;"><span style="background-color:#f3f3f4;">双向链表结构</span></span></strong>，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。</li><li>list与forward_list非常相似：最主要的不同在于<strong><span style="color:#38d8f0;"><span style="background-color:#f3f3f4;">forward_list是单链表</span></span></strong>，只能朝前迭代，已让其更简单高效。</li><li>与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。</li><li>与其他序列式容器相比，<strong><span style="color:#38d8f0;"><span style="background-color:#f3f3f4;">list和forward_list最大的缺陷是不支持任意位置的随机访问</span></span></strong>，比如：要访问list 的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素)。</li></ol> 
<p><img alt="" height="465" src="https://images2.imgbox.com/8c/5b/KEVVTbBq_o.png" width="660"></p> 
<h2 id="list%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">⭐list模拟实现</h2> 
<blockquote> 
 <ol><li>list的底层是双向链表结构，包含有一个哨兵节点。</li><li>模拟实现list，要实现下列三个类：</li></ol> 
 <ul><li>        ①list节点类</li><li>        ②迭代器的类</li><li>        ③list主要功能的类(size()，empty()...)</li></ul> 
 <p>模拟实现list的类的基本功能（增删等操作）要建立在迭代器类和节点类均已实现好的情况下才得以完成。</p> 
</blockquote> 
<h3 id="list%20%E8%8A%82%E7%82%B9%E7%B1%BB">✨list 节点类</h3> 
<ul><li>定义list中的节点ListNode，包含前驱指针，后驱指针和数据变量；</li><li>使用struct而不使用class定义类，是为了方便访问每个一个节点 ，struct默认是pbulic，而class中成员变量要定义为private，不方便访问。</li></ul> 
<pre><code class="language-cpp">	template&lt;class T&gt;
	struct ListNode
	{
		ListNode&lt;T&gt;* _next;
		ListNode&lt;T&gt;* _prev;
		T _data;

		ListNode(const T&amp; x = T())
			:_next(nullptr)
			,_prev(nullptr)
			,_data(x)
		{}
	};</code></pre> 
<h3 id="list%20%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">✨list 的迭代器</h3> 
<p>迭代器有两种实现方式，具体应根据容器底层数据结构实现：</p> 
<p>1. 原生态指针，比如：vector</p> 
<p>2. 将原生态指针进行封装，因迭代器使用形式与指针完全相同，因此在自定义的类中必须实现以下方法：</p> 
<ol><li>指针可以解引用，迭代器的类中必须重载operator*()</li><li>指针可以通过-&gt;访问其所指空间成员，迭代器类中必须重载oprator-&gt;()</li><li>指针可以++向后移动，迭代器类中必须重载operator++()与operator++(int)</li><li>至于operator--()/operator--(int)释放需要重载，根据具体的结构来抉择，双向链表可以向前移动，所以需要重载，如果是forward_list就不需要重载--</li><li>迭代器需要进行是否相等的比较，因此还需要重载operator==()与operator!=()</li></ol> 
<h4 id="%E5%AE%9A%E4%B9%89%C2%A0">📖定义 </h4> 
<pre><code class="language-cpp">	template&lt;class T,class Ref,class Ptr&gt;
	struct ListIterator
	{
		typedef ListNode&lt;T&gt; Node;
		typedef ListIterator&lt;T,Ref,Ptr&gt; Self;

		//内置类型 指针
		Node* _node;
    }</code></pre> 
<ul><li>可以发现这里list的模板含有三个类型参数，这样做是为了方便让编译器能依照模板自动生成一个const迭代器，而不需要我们手动写。</li><li>两个参数名Ref（reference:引用）和Ptr（pointer:指针），见名知义。</li></ul> 
<h4 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">📖构造函数</h4> 
<pre><code class="language-cpp">		ListIterator(Node* node)
			:_node(node)
		{}</code></pre> 
<p> 迭代器指向所传节点</p> 
<h4 id="%E8%A7%A3%E5%BC%95%E7%94%A8">📖解引用</h4> 
<pre><code class="language-cpp">//*it 解引用
//T&amp; operator*()
Ref operator*()
{
	return _node-&gt;_data;
}
//it-&gt;
//T* operator-&gt;()
Ptr operator-&gt;()
{
	return &amp;_node-&gt;_data;
}</code></pre> 
<ul><li>重载 * ，解引用就可以直接访问到节点里面的数据data </li><li>如果访问的数据是Date类型的，那么重载 -&gt; 就可以访问到Date类里面的_year、_day等（如果是Date类，那data就说Date类里面的数据） </li></ul> 
<p><img alt="" height="500" src="https://images2.imgbox.com/c8/3a/jArzp3Ya_o.png" width="967"></p> 
<h4 id="operator%E5%89%8D%E7%BD%AE%2B%2B%E5%92%8C--%E4%B8%8E%E5%90%8E%E7%BD%AE%2B%2B%E5%92%8C--">📖operator前置++和--与后置++和--</h4> 
<pre><code class="language-cpp">//前置++
Self&amp; operator++()
{
	_node = _node-&gt;_next;
	return *this;
}
//后置++
Self operator++(int)
{
	Self tmp(*this);
	_node = _node-&gt;_next;
	return tmp; // tmp 是一个局部变量，它在函数返回后将不再存在，所以不能返回引用
}
//前置--
Self&amp; operator--()
{
	_node = _node-&gt;_prev;
	return *this;
}
//后置--
Self operator--(int)
{
	Self tmp(*this);
	_node = _node-&gt;_prev;
	return tmp;// tmp 是一个局部变量，它在函数返回后将不再存在，所以不能返回引用
}</code></pre> 
<p><strong>注：</strong></p> 
<ul><li>这里值得注意的是，为了区分前置和后置，我们会在后置的重载函数中传缺省值int，从而与前置构成重载 </li><li>局部变量不能返回引用</li></ul> 
<h4 id="3.5%20operator%3D%3D%E4%B8%8Eoperator!%3D">📖operator==与operator!=</h4> 
<pre><code class="language-cpp">bool operator!=(const Self&amp; it)
{
	return _node != it._node;
}
bool operator==(const Self&amp; it)
{
	return _node == it._node;
} </code></pre> 
<ul><li>这个比较的就是两个迭代器中指向的节点的地址是否相等，从而可以判断迭代器是否指向了end() 。</li></ul> 
<h3 id="list%20%E7%B1%BB">✨list 类</h3> 
<pre><code class="language-cpp">template&lt;class T&gt;
class list
{
	 typedef ListNode&lt;T&gt; Node;

public :

	typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;
	typedef ListIterator&lt;T,const T&amp;,const T*&gt; const_iterator;
private:

	Node* _head;
	size_t _size;
}</code></pre> 
<ul><li>迭代器写成三个参数类型的模板，可以让编译器生成两个类，一个普通的iterator和一个const_iterator</li><li><code>const_iterator</code> 只能读取它所指向的元素，不能修改。</li></ul> 
<h4>📖构造函数</h4> 
<pre><code class="language-cpp">//带头双向循环链表的构造函数
list()
{
	_head = new Node;
	_head-&gt;_next = _head;
	_head-&gt;_prev = _head;
}</code></pre> 
<ul><li>初始化时，new一个头节点，然后使这个头节点的前后指针都指向自己 </li></ul> 
<h4 id="4.2%20begin()%E5%92%8Cend()">📖begin()和end()</h4> 
<pre><code class="language-cpp">iterator begin()
{
	return _head-&gt;_next;//也可以直接这么写，进行隐式类型转换（单参数的构造函数支持隐式类型转换）
}
iterator end()
{
	return iterator(_head);//匿名对象，局部变量 不能返回引用
}
//const迭代器需要的是迭代器指向的内容不能修改
//const iterator 是迭代器本身不能修改
const_iterator begin() const
{
	return _head-&gt;_next;
}
const_iterator end()const
{
	return const_iterator(_head);
}</code></pre> 
<ul><li>返回时使用了匿名对象，不用实例化一个新的对象</li><li>不能引用返回的匿名对象</li><li>const迭代器指向的内容不能修改 </li></ul> 
<h4 id="%C2%A0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"> 📖拷贝构造</h4> 
<pre><code class="language-cpp">//lt2(lt)
list(const list&lt;T&gt;&amp; lt) 
{
	empty_init();
	for (auto&amp; e : lt)
	{
		push_back(e);
	}	
}</code></pre> 
<ul><li>list的每个节点不连续，需要一个个拷贝 </li><li>需要析构的时候，一般就需要自己写深拷贝</li></ul> 
<h4 id="erase()">📖erase()</h4> 
<pre><code class="language-cpp">iterator erase(iterator pos)
{
	//prev cur next
	Node* cur = pos._node;
	Node* prev = cur-&gt;_prev;
	Node* next = cur-&gt;_next;
	_size--;
	prev-&gt;_next = next;
	next-&gt;_prev = prev;
	delete cur;
	return iterator(next);//匿名对象，局部变量 不能返回引用
}</code></pre> 
<ul><li> <p><span style="color:#0d0016;">delete删除节点,每一个节点都是动态开辟出来的</span></p> </li><li>返回被删除元素后面一个元素的迭代器位置</li></ul> 
<h4 id="clear()">📖clear()</h4> 
<pre><code class="language-cpp">void clear()
{
	iterator it = begin();
	while (it != end())
	{
		it = erase(it);
	}
	//不清除头节点 
}</code></pre> 
<ul><li>erase之后，it更新到下一个节点的位置继续erase</li><li>clear()不删除头节点</li></ul> 
<h4 id="%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">📖析构函数</h4> 
<pre><code class="language-cpp">~list()
{
	clear();
	delete _head;
	_head = nullptr;
}</code></pre> 
<ul><li>clear()删除除去头节点以外的所有节点</li><li>delete删除头节点</li></ul> 
<h4 id="insert">📖insert</h4> 
<pre><code class="language-cpp">void insert(iterator pos, const T&amp; val)
{
	Node* cur = pos._node;
	Node* newnode = new Node(val);
	Node* prev = cur-&gt;_prev;
	_size++;
	//prev newnode cur
	prev-&gt;_next = newnode;
	newnode-&gt;_prev = prev;
	newnode-&gt;_next = cur;
	cur-&gt;_prev = newnode;
}</code></pre> 
<ul><li>插入到pos位置之前 </li></ul> 
<h4 id="4.8%20push_back%20%E5%92%8C%20push_front"> 📖push_back 和 push_front</h4> 
<pre><code class="language-cpp">void push_back(const T&amp; x)
{
	insert(end(), x);
}
void push_front(const T&amp; x)
{
	insert(begin(), x);
}</code></pre> 
<ul><li>复用insert ()</li></ul> 
<h4 id="4.10%20pop_back%20%E5%92%8C%20pop_front">📖pop_back 和 pop_front</h4> 
<pre><code class="language-cpp">void pop_back()
{
	erase(--end());
}
void pop_front()
{
	erase(begin());
}</code></pre> 
<ul><li>复用erase() </li></ul> 
<h3 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">✨完整代码</h3> 
<pre><code class="language-cpp">template&lt;class T&gt;
	struct ListNode
	{
		ListNode&lt;T&gt;* _next;
		ListNode&lt;T&gt;* _prev;
		T _data;

		ListNode(const T&amp; x = T())
			:_next(nullptr)
			,_prev(nullptr)
			,_data(x)
		{}
	};

	template&lt;class T,class Ref,class Ptr&gt;
	struct ListIterator
	{
		typedef ListNode&lt;T&gt; Node;
		typedef ListIterator&lt;T,Ref,Ptr&gt; Self;

		//内置类型 指针
		Node* _node;

		ListIterator(Node* node)
			:_node(node)
		{}

		//*it 解引用
		//T&amp; operator*()
		Ref operator*()
		{
			return _node-&gt;_data;
		}
		//it-&gt;
		//T* operator-&gt;()
		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}
		//前置++
		Self&amp; operator++()
		{
			_node = _node-&gt;_next;
			return *this;
		}
		//后置++
		Self operator++(int)
		{
			Self tmp(*this);
			_node = _node-&gt;_next;
			return tmp; // tmp 是一个局部变量，它在函数返回后将不再存在，所以不能返回引用
		}

		//前置--
		Self&amp; operator--()
		{
			_node = _node-&gt;_prev;
			return *this;
		}
		//后置--
		Self operator--(int)
		{
			Self tmp(*this);
			_node = _node-&gt;_prev;
			return tmp;// tmp 是一个局部变量，它在函数返回后将不再存在，所以不能返回引用
		}

		bool operator!=(const Self&amp; it)
		{
			return _node != it._node;
		}
		bool operator==(const Self&amp; it)
		{
			return _node == it._node;
		} 
	};

	template&lt;class T&gt;
	class list
	{
		 typedef ListNode&lt;T&gt; Node;

	public :
		//typedef ListIterator&lt;T&gt; iterator;
		//typedef ListConstIterator&lt;T&gt; const_iterator;//重新写一个ListConstIterator类(这个方法比较冗余)

		typedef ListIterator&lt;T, T&amp;, T*&gt; iterator;
		typedef ListIterator&lt;T,const T&amp;,const T*&gt; const_iterator;//写成模板,让编译器生成两个类，而不是我们自己写
		/*iterator begin()
		{
			return iterator(_head-&gt;_next);
		}*/
		iterator begin()
		{
			return _head-&gt;_next;//也可以直接这么写，进行隐式类型转换（单参数的构造函数支持隐式类型转换）
		}
		iterator end()
		{
			return iterator(_head);//匿名对象，局部变量 不能返回引用
		}
		//const迭代器需要的是迭代器指向的内容不能修改
		//const iterator 是迭代器本身不能修改
		const_iterator begin() const
		{
			return _head-&gt;_next;
		}
		const_iterator end()const
		{
			return const_iterator(_head);
		}
		void empty_init()
		{
			_head = new Node;
			_head-&gt;_next = _head;
			_head-&gt;_prev = _head;
			_size = 0;
		}
		list()
		{
			//this-&gt;empty_init();
			empty_init();
		}
		//lt2(lt)
		list(const list&lt;T&gt;&amp; lt) 
		{
			empty_init();
			for (auto&amp; e : lt)
			{
				push_back(e);
			}
		}
		//需要析构，一般就需要自己写深拷贝
		void swap(list&lt;T&gt;&amp; lt)
		{
			//lt是局部变量
			std::swap(_head, lt._head);
			std::swap(_size, lt._size);
		}
		//lt1 = lt3
		list&lt;T&gt;&amp; operator=(list&lt;T&gt; lt)
		{
			swap(lt);
			return *this;
		}
		void clear()
		{
			iterator it = begin();
			while (it != end())
			{
				it = erase(it);
			}
			//不清除头节点 
		}
		~list()
		{
			clear();
			delete _head;
			_head = nullptr;
		}
		/*void push_back(const T&amp; x)
		{
			Node* newnode = new Node(x);
			Node* tail = _head-&gt;_prev;
			tail-&gt;_next = newnode;
			newnode-&gt;_prev = tail;
			newnode-&gt;_next = _head;
			_head-&gt;_prev = newnode;
		}*/
		void push_back(const T&amp; x)
		{
			insert(end(), x);
		}
		void push_front(const T&amp; x)
		{
			insert(begin(), x);
		}

		void pop_back()
		{
			erase(--end());
		}
		void pop_front()
		{
			erase(begin());
		}
		void insert(iterator pos, const T&amp; val)
		{
			Node* cur = pos._node;
			Node* newnode = new Node(val);
			Node* prev = cur-&gt;_prev;
			_size++;
			//prev newnode cur
			prev-&gt;_next = newnode;
			newnode-&gt;_prev = prev;
			newnode-&gt;_next = cur;
			cur-&gt;_prev = newnode;
		}
		iterator erase(iterator pos)
		{
			Node* cur = pos._node;
			Node* prev = cur-&gt;_prev;
			Node* next = cur-&gt;_next;
			_size--;
			prev-&gt;_next = next;
			next-&gt;_prev = prev;
			delete cur;
			return iterator(next);//匿名对象，局部变量 不能返回引用
		}
		size_t size()const
		{
			return _size;
		}
		bool empty()
		{
			return _size == 0;
		}
	private:
		Node* _head;
		size_t _size;
	};</code></pre> 
<p>____________________</p> 
<p>⭐感谢你的阅读，希望本文能够对你有所帮助。如果你喜欢我的内容，记得点赞关注收藏我的博客，我会继续分享更多的内容。⭐</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b56008c1fb781454dc2691d4c0c8fc5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu22.04安装Go语言的几种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/553711279c2068273c26e84c5a4d8af0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LeetCode 2844.生成特殊数字的最少操作（哈希表 &#43; 贪心）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>