<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;/STL】：list容器的深度剖析及模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/91b03a7a8a953102572cc9fdc59823cd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;/STL】：list容器的深度剖析及模拟实现">
  <meta property="og:description" content="目录 🚀前言🚀一，节点类🚀二，迭代器类1，普通迭代器类的实现2，-&gt;运算符的使用场景3，const迭代器类的实现4，通过模板参数，把两个类型的迭代器类结合5，迭代器类的一些问题的思考 🚀三，list 类1，list类的结构2，迭代器的实现3，插入数据insert4，删除数据erase5，头插，头删，尾插，尾删6，常见构造函数的实现7，析构函数 🚀前言 点击跳转到文章：【list的基本使用】
要模拟实现list，必须要熟悉list的底层结构以及其接口的含义，list的底层是带头双向循环链表，通过上一篇文章的学习，这些内容已基本掌握，现在我们来模拟实现list容器的主要接口。
与前面的vector类似，由于使用了模板，也只分成.cpp和.h两个文件。
.cpp文件里放节点类，迭代器类，list类及其成员函数，测试函数的实现，在.h文件里进行测试。
本文的重点是：对三个类的区分与理解，迭代器类的实现。
🚀一，节点类 1.为什么定义节点结构体时使用struct而不是class?
答：(1)其实用class也可以，但是class与struct默认的访问限定不同，当没有声明公有，私有时，struct内容默认是公有，class内容默认的私有，所以用class要加上public。
(2)当我们用class没有加上public，也没有实例化对象时，编译不会报错(报私有成员的错误)，因为模版是不会被细节编译的。只有当我们实例化出对象，模版才会被编译，并且类的实例化并不是对所有成员函数都实例化，而是调用哪个成员函数就实例化哪个。这叫做按需实例化。
2.可用匿名对象初始化。如果T是自定义类型，则调用其默认构造，并且T是内置类型也升级成了有默认构造的概念了。
template &lt;class T&gt; struct ListNode { ListNode&lt;T&gt;* _next; ListNode&lt;T&gt;* _prev; T _data; ListNode(const T&amp; data = T()) :_next(nullptr) ,_prev(nullptr) ,_data(data) {} }; 🚀二，迭代器类 前面学习的string类和vector的迭代器用的是原生指针类型，即T*。但是在list容器中是不能这样的，因为前面两者的底层物理空间是连续的，符合迭代器&#43;&#43;与- -的行为。但是list是由一个一个节点构成的，物理空间不连续，Node*的&#43;&#43;和- -不符合迭代器的行为，无法变遍历。
所以用一个类把Node* 封装，就可以重载运算符，使得用起来像内置类型，但会转换成函数调用，继而控制Node*的行为。
1，普通迭代器类的实现 遍历需要的核心运算符重载是 *，!=，&#43;&#43; 和 -&gt;。所以只需要利用带头双向循环链表的特性，对Node * 进行封装，从而控制Node * 的行为。
class ListIterator { typedef ListNode&lt;T&gt; Node; typedef ListIterator&lt;T&gt; Self;//名字变得简短 public: Node* _node;//定义一个节点指针 ListIterator(Node* node) :_node(node) {} //前置:返回之后的值 //&#43;&#43;it;//返回与自己一样的类型 Self&amp; operator&#43;&#43;() { _node = _node-&gt;_next; return *this; } Self&amp; operator--() { _node = _node-&gt;_prev; return *this; } //后置:返回之前的值 Self operator&#43;&#43;(int) { Self tmp(*this); _node = _node-&gt;_next; return tmp; } Self operator--(int) { Self tmp(*this); _node = _node-&gt;_prev; return tmp; } T&amp; operator*() { return _node-&gt;_data; } //返回的是数据的地址 T* operator-&gt;() { return &amp;_node-&gt;_data; } bool operator!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-23T14:17:39+08:00">
    <meta property="article:modified_time" content="2024-06-23T14:17:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;/STL】：list容器的深度剖析及模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">🚀前言</a></li><li><a href="#_11" rel="nofollow">🚀一，节点类</a></li><li><a href="#_36" rel="nofollow">🚀二，迭代器类</a></li><li><ul><li><a href="#1_41" rel="nofollow">1，普通迭代器类的实现</a></li><li><a href="#2_107" rel="nofollow">2，-&gt;运算符的使用场景</a></li><li><a href="#3const_186" rel="nofollow">3，const迭代器类的实现</a></li><li><a href="#4_280" rel="nofollow">4，通过模板参数，把两个类型的迭代器类结合</a></li><li><a href="#5_347" rel="nofollow">5，迭代器类的一些问题的思考</a></li></ul> 
  </li><li><a href="#list__356" rel="nofollow">🚀三，list 类</a></li><li><ul><li><a href="#1list_358" rel="nofollow">1，list类的结构</a></li><li><a href="#2_382" rel="nofollow">2，迭代器的实现</a></li><li><a href="#3insert_408" rel="nofollow">3，插入数据insert</a></li><li><a href="#4erase_428" rel="nofollow">4，删除数据erase</a></li><li><a href="#5_448" rel="nofollow">5，头插，头删，尾插，尾删</a></li><li><a href="#6_485" rel="nofollow">6，常见构造函数的实现</a></li><li><a href="#7_528" rel="nofollow">7，析构函数</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>🚀前言</h2> 
<p>点击跳转到文章：<a href="http://t.csdnimg.cn/Thq8c" rel="nofollow">【list的基本使用】</a><br> 要模拟实现list，必须要熟悉list的底层结构以及其接口的含义，<strong>list的底层是带头双向循环链表</strong>，通过上一篇文章的学习，这些内容已基本掌握，现在我们来模拟实现list容器的主要接口。</p> 
<p>与前面的vector类似，由于使用了模板，也只分成.cpp和.h两个文件。</p> 
<p><strong>.cpp文件里放节点类，迭代器类，list类及其成员函数，测试函数的实现，在.h文件里进行测试</strong>。</p> 
<p>本文的重点是：<strong>对三个类的区分与理解，迭代器类的实现</strong>。</p> 
<h2><a id="_11"></a>🚀一，节点类</h2> 
<p><strong>1.为什么定义节点结构体时使用struct而不是class?</strong></p> 
<p>答：(1)其实用class也可以，<strong>但是class与struct默认的访问限定不同</strong>，当没有声明公有，私有时，struct内容默认是公有，class内容默认的私有，<strong>所以用class要加上public</strong>。</p> 
<p>(2)当我们用class没有加上public，也没有实例化对象时，编译不会报错(报私有成员的错误)，<em><strong>因为模版是不会被细节编译的。只有当我们实例化出对象，模版才会被编译，并且类的实例化并不是对所有成员函数都实例化，而是调用哪个成员函数就实例化哪个</strong></em>。这叫做<mark>按需实例化</mark>。</p> 
<p>2.<strong>可用匿名对象初始化</strong>。如果T是自定义类型，则调用其默认构造，并且T是内置类型也升级成了有默认构造的概念了。</p> 
<pre><code class="prism language-c">template <span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _next<span class="token punctuation">;</span>
	ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _prev<span class="token punctuation">;</span>

	T _data<span class="token punctuation">;</span>

	<span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_next</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_prev</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_36"></a>🚀二，迭代器类</h2> 
<p>前面学习的string类和vector的迭代器用的是原生指针类型，即T*。但是在list容器中是不能这样的，因为前面两者的底层物理空间是连续的，符合迭代器++与- -的行为。<strong>但是list是由一个一个节点构成的，物理空间不连续，Node*的++和- -不符合迭代器的行为，无法变遍历</strong>。</p> 
<p><mark>所以用一个类把Node* 封装，就可以重载运算符，使得用起来像内置类型，但会转换成函数调用，继而控制Node*的行为</mark>。</p> 
<h3><a id="1_41"></a>1，普通迭代器类的实现</h3> 
<p>遍历需要的<strong>核心运算符重载是 *，!=，++ 和 -&gt;</strong>。所以只需要利用带头双向循环链表的特性，对Node * 进行封装，从而控制Node * 的行为。</p> 
<pre><code class="prism language-c">class ListIterator
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> ListIterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Self<span class="token punctuation">;</span><span class="token comment">//名字变得简短</span>

public<span class="token operator">:</span>
	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span><span class="token comment">//定义一个节点指针</span>

	<span class="token function">ListIterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token comment">//前置:返回之后的值</span>
	<span class="token comment">//++it;//返回与自己一样的类型</span>
	Self<span class="token operator">&amp;</span> operator<span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Self<span class="token operator">&amp;</span> operator<span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//后置:返回之前的值</span>
	Self operator<span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Self operator<span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	T<span class="token operator">&amp;</span> operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//返回的是数据的地址</span>
	T<span class="token operator">*</span> operator<span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool operator<span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> it<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">!=</span> it<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool operator<span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> it<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">==</span> it<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="2_107"></a>2，-&gt;运算符的使用场景</h3> 
<p>假设某个场景下存在一个坐标类：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> <span class="token class-name">Pos</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> _row<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _col<span class="token punctuation">;</span>

	<span class="token function">Pos</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_row</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_col</span><span class="token punctuation">(</span>col<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果我们插入坐标，并且想要打印出坐标，该如何遍历？</p> 
<p><strong>错误示范</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">test_list2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	list<span class="token operator">&lt;</span>Pos<span class="token operator">&gt;</span> lt1<span class="token punctuation">;</span>
	lt1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Pos</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用匿名对象</span>
	lt1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Pos</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	lt1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Pos</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//这里的it是Pos*,是结构体指针</span>
	list<span class="token operator">&lt;</span>Pos<span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lt1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lt1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment">//err</span>
		<span class="token operator">++</span>it<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>原因：<strong>因为这里的*it返回的是Pos自定义类型，而访问自定义类型需要需要在类中自己重载流插入(&lt;&lt;)，这里并没有重载，所以报错</strong>。</p> 
<p><strong>正确操遍历的两种方式</strong>：</p> 
<p>方式1：通过.操作符直接访问结构体的成员变量(一般不这样访问数据)。</p> 
<pre><code class="prism language-c">cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>_row <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>_col <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//ok</span>
</code></pre> 
<p>方式2：通过重载-&gt;运算符，对结构体指针进行解引用。</p> 
<pre><code class="prism language-c">cout <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>operator<span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_row <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>operator<span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>_col <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//ok</span>
</code></pre> 
<p>注意：<mark>其实这里严格来说是有两个箭头,第一个运算符重载的调用 it.operator-&gt;() 返回的是 Pos*，第二个箭头才是原生指针，Pos*再用箭头访问。为了可读性，省略了一个-&gt;</mark>。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">test_list2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	list<span class="token operator">&lt;</span>Pos<span class="token operator">&gt;</span> lt1<span class="token punctuation">;</span>
	lt1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Pos</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用匿名对象</span>
	lt1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Pos</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	lt1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Pos</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">//这里的it是Pos*,是结构体指针</span>
	list<span class="token operator">&lt;</span>Pos<span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lt1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lt1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>	
		<span class="token comment">//方式1：</span>
		<span class="token comment">//cout &lt;&lt; (*it)._row &lt;&lt; ":" &lt;&lt; (*it)._col &lt;&lt; endl;//ok</span>
		<span class="token comment">//*it就是Pos结构体，再用.操作符访问成员</span>
		
		<span class="token comment">//方式2：</span>
		cout <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>_row <span class="token operator">&lt;&lt;</span> <span class="token string">":"</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>_col <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//ok</span>
		<span class="token comment">//cout &lt;&lt; it.operator-&gt;()-&gt;_row &lt;&lt; ":" &lt;&lt; it.operator-&gt;()-&gt;_col &lt;&lt; endl;//ok</span>
		
		<span class="token operator">++</span>it<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3const_186"></a>3，const迭代器类的实现</h3> 
<p>在我们遍历数据时，有时会写一个打印函数，<strong>引用传参，一般建议加const，这就出现了一个const链表</strong>：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt1<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>const_iterator it <span class="token operator">=</span> lt1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> lt1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>it<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>const迭代器不是在普通迭代器前面加const,即不是const iterator</strong>。</p> 
<pre><code class="prism language-c"><span class="token comment">//err 这样使it本身也不能++了</span>
<span class="token keyword">const</span> list<span class="token operator">&lt;</span> <span class="token keyword">int</span> <span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>const 迭代器目的:<strong>本身可以修改，指向的内容不能修改</strong>，类似const T* p。</p> 
<p>所以我们要再定义一个类，控制*和-&gt;的返回值就可以了。</p> 
<pre><code class="prism language-c">template <span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
class ListConstIterator
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> ListConstIterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Self<span class="token punctuation">;</span><span class="token comment">//名字变得简短</span>

public<span class="token operator">:</span>
	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span><span class="token comment">//定义一个节点指针</span>

	<span class="token function">ListConstIterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token comment">//前置:返回之后的值</span>
	<span class="token comment">//++it;//返回与自己一样的类型</span>
	Self<span class="token operator">&amp;</span> operator<span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Self<span class="token operator">&amp;</span> operator<span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//后置:返回之前的值</span>
	Self operator<span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Self operator<span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 所以我们要再定义一个类，使用const控制*和-&gt;的返回值就可以</span>
	<span class="token keyword">const</span> T<span class="token operator">&amp;</span> operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">const</span> T<span class="token operator">*</span> operator<span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool operator<span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> it<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">!=</span> it<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool operator<span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> it<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">==</span> it<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="4_280"></a>4，通过模板参数，把两个类型的迭代器类结合</h3> 
<p>可以发现，其实普通迭代器和const迭代器的<strong>本质区别是 * 和 -&gt;，这两个运算符的返回类型的变化</strong>。两个类冗余，<mark>所以可以通过模板，给不同的模板参数，让编译器自己实例化两个类</mark>。</p> 
<pre><code class="prism language-c">template <span class="token operator">&lt;</span>class T<span class="token punctuation">,</span>class Ref<span class="token punctuation">,</span>class Ptr<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">ListIterator</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> ListIterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Ref<span class="token punctuation">,</span> Ptr<span class="token operator">&gt;</span> Self<span class="token punctuation">;</span><span class="token comment">//名字变得简短</span>

	Node<span class="token operator">*</span> _node<span class="token punctuation">;</span><span class="token comment">//定义一个节点指针</span>

	<span class="token function">ListIterator</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token comment">//前置:返回之后的值</span>
	<span class="token comment">//++it;//返回与自己一样的类型</span>
	Self<span class="token operator">&amp;</span> operator<span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Self<span class="token operator">&amp;</span> operator<span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//后置:返回之前的值</span>
	Self operator<span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Self operator<span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		Self <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_node <span class="token operator">=</span> _node<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span>
		<span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Ref operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Ptr operator<span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>_node<span class="token operator">-&gt;</span>_data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool operator<span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> it<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">!=</span> it<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	bool operator<span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Self<span class="token operator">&amp;</span> it<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _node <span class="token operator">==</span> it<span class="token punctuation">.</span>_node<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="5_347"></a>5，迭代器类的一些问题的思考</h3> 
<p><strong>(1) 类中是否需要写析构函数</strong>？</p> 
<p>这个迭代器类不要写析构函数，因为这里的节点不是迭代器的，是链表的，不用把它释放。<strong>我们使用begin，end返回节点给迭代器，是借助迭代器修改，访问数据，所以我们不需要释放</strong>。</p> 
<p><strong>(2) 类中是否需要写拷贝构造进行深拷贝和写赋值拷贝</strong>？</p> 
<p>这里也不需要写拷贝构造进行深拷贝，因为这里要的就是浅拷贝。<strong>begin返回了第一个节点的迭代器给it，这里就是用默认生成的拷贝构造，浅拷贝给it，那这两个迭代器就指向同一个节点，所以这里用默认的拷贝构造和赋值拷贝就可以了</strong>。</p> 
<h2><a id="list__356"></a>🚀三，list 类</h2> 
<h3><a id="1list_358"></a>1，list类的结构</h3> 
<pre><code class="prism language-c">template <span class="token operator">&lt;</span>class T<span class="token operator">&gt;</span>
class list
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
public<span class="token operator">:</span>
	<span class="token comment">//物理空间不是连续的，不符合迭代器的行为，无法遍历</span>
	<span class="token comment">//typedef Node* iterator;</span>

	<span class="token comment">//规范命名</span>
	<span class="token comment">//typedef ListIterator&lt;T&gt; iterator;</span>
	<span class="token comment">//typedef ListConstIterator&lt;T&gt; const_iterator;</span>

	<span class="token keyword">typedef</span> ListIterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> iterator<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> ListIterator<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">*</span><span class="token operator">&gt;</span> const_iterator<span class="token punctuation">;</span>

	<span class="token comment">//………………</span>

private<span class="token operator">:</span>
	Node<span class="token operator">*</span> _head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="2_382"></a>2，迭代器的实现</h3> 
<p><strong>包含普通迭代器和const迭代器</strong>。</p> 
<pre><code class="prism language-c">iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//iterator it(_head-&gt;_next);</span>
	<span class="token comment">//return it;</span>
	<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>_head<span class="token operator">-&gt;</span>_next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用匿名对象</span>
<span class="token punctuation">}</span>

iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

const_iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">const_iterator</span><span class="token punctuation">(</span>_head<span class="token operator">-&gt;</span>_next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

const_iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">const_iterator</span><span class="token punctuation">(</span>_head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3insert_408"></a>3，插入数据insert</h3> 
<pre><code class="prism language-c">iterator <span class="token function">insert</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span><span class="token comment">//找到当前节点</span>
	Node<span class="token operator">*</span> newnode <span class="token operator">=</span> new <span class="token function">Node</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//申请节点</span>
	Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span><span class="token comment">//找到前一个节点</span>

	<span class="token comment">//prev newnode cur 进行链接</span>
	newnode<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
	cur<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>newnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：<strong>链表的insert没有迭代器失效问题，因为没有扩容的概念，pos位置的节点不会改变</strong>。但是STL库里insert也给了返回值，<strong>返回的是新插入位置的迭代器</strong>。</p> 
<h3><a id="4erase_428"></a>4，删除数据erase</h3> 
<pre><code class="prism language-c">iterator <span class="token function">erase</span><span class="token punctuation">(</span>iterator pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//防止删除头节点</span>

	Node<span class="token operator">*</span> cur <span class="token operator">=</span> pos<span class="token punctuation">.</span>_node<span class="token punctuation">;</span><span class="token comment">//找到当前节点</span>
	Node<span class="token operator">*</span> prev <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_prev<span class="token punctuation">;</span><span class="token comment">//找到前一个节点</span>
	Node<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span><span class="token comment">//找到后一个节点</span>

	prev<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> next<span class="token punctuation">;</span>
	next<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>

	delete cur<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：<strong>链表的erase后有迭代器失效问题，pos失效了，因为pos指向的节点被释放了</strong>。所以也要返回值，<strong>返回的是删除节点的下一个节点的迭代器</strong>。</p> 
<h3><a id="5_448"></a>5，头插，头删，尾插，尾删</h3> 
<p><strong>可以复用前面的 insert和 erase</strong> 。</p> 
<pre><code class="prism language-c"><span class="token comment">//尾插:end()的下一个位置</span>
<span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//Node* newnode = new Node(x);//申请节点并且初始化</span>
	<span class="token comment">//Node* tail = _head-&gt;_prev;</span>

	<span class="token comment">链接节点</span>
	<span class="token comment">//tail-&gt;_next = newnode;</span>
	<span class="token comment">//newnode-&gt;_prev = tail;</span>
	<span class="token comment">//_head-&gt;_prev = newnode;</span>
	<span class="token comment">//newnode-&gt;_next = _head;</span>

	<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//尾删</span>
<span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">erase</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意：前置--</span>
<span class="token punctuation">}</span>

<span class="token comment">//头插:在begin前面插入</span>
<span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//头删</span>
<span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="6_485"></a>6，常见构造函数的实现</h3> 
<p>主要包含：<strong>构造函数，拷贝构造，initializer_list构造(列表构造)</strong>。</p> 
<p>注意：<strong>由于这些都是在有哨兵位节点的前提下实现的</strong>，所以可以把申请哨兵位头节点这一步骤提取出来。</p> 
<pre><code class="prism language-c"><span class="token comment">//空初始化，申请哨兵位头节点</span>
<span class="token keyword">void</span> <span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	_head <span class="token operator">=</span> new <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	_head<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> _head<span class="token punctuation">;</span>
	_head<span class="token operator">-&gt;</span>_prev <span class="token operator">=</span> _head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//拷贝构造:直接复用尾插，前提要有哨兵位头节点</span>
<span class="token comment">//lt2(lt1)</span>
<span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">const</span> list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lt<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//注意：使用范围for时加上const和&amp;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> lt<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//initializer_list构造，前提要有哨兵位头节点</span>
<span class="token function">list</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> il<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">empty_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> il<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">push_back</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="7_528"></a>7，析构函数</h3> 
<p>析构函数的作用是：<strong>删除整个链表结构，包括哨兵位节点</strong>。</p> 
<pre><code class="prism language-c"><span class="token comment">//清空当前数据 留头节点，其余节点释放</span>
<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//返回删除节点的下一个节点的迭代器</span>
		it <span class="token operator">=</span> <span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//析构：销毁整个链表</span>
<span class="token operator">~</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	delete _head<span class="token punctuation">;</span>
	_head <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a89b1653b9519188f48eb7bf792bdb16/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">爬取链家二手房房价数据存入mongodb并进行分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75ac02370961d58fb7946136cf6be96f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;/STL】：list容器的基本使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>