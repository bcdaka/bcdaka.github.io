<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法系列篇】分治-归并 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/334b9847f4d886d9e8cb19eea03218ce/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法系列篇】分治-归并">
  <meta property="og:description" content="文章目录 前言什么是归并算法1. 排序数组1.1 题目要求1.2 做题思路1.3 Java代码实现 2. 数组中逆序对2.1 题目要求2.2 做题思路2.3 Java代码实现 3. 计算右侧小于当前元素的个数3.1 题目要求3.2 做题思路3.3 Java代码实现 4. 翻转对4.1 题目要求4.2 做题思路4.3 Java代码实现 总结 前言 上一篇算法文章，我们介绍了分治-快排的算法，今天我将为大家分享关于分治的另外一种算法——归并。
什么是归并算法 归并算法是一种常用的排序算法，它采用分治策略将待排序的数组分解为更小的子数组，然后逐步合并这些子数组以获得最终的有序数组。归并排序的主要思想是将两个有序的子数组合并成一个有序的数组。
归并算法通常包含以下步骤：
分解（Divide）：将待排序的数组递归地分解为规模更小的子数组，直到每个子数组只有一个元素或为空。
解决（Conquer）：通过递归地排序子数组，将其转化为有序的子数组。这通常是通过继续将子数组进一步分解并排序的方式实现的。
合并（Merge）：将两个有序的子数组合并成一个有序的数组。该步骤的实现方式是比较两个子数组的元素，并按照顺序合并到一个新的数组中，直到所有元素都被合并。
归并排序的时间复杂度是O(nlogn)，其中n是待排序数组的长度。它的主要优点包括：
稳定性：归并排序是一种稳定的排序算法，即相等元素的相对顺序不会被改变。
适用性：归并排序适用于各种数据结构，尤其在外部排序中，它对于大规模数据的排序效果明显。
然而，归并排序也存在一些缺点：
额外空间消耗：归并排序需要额外的空间来存储临时的子数组和合并结果，这可能对内存消耗造成一定影响。
递归调用：归并排序的实现通常使用递归调用，对于大规模数据的排序可能导致递归深度增加，从而增加了额外的函数调用开销。
总结而言，归并排序是一种高效、稳定的排序算法，通过分治策略将待排序的数组分解为更小的子数组，然后逐步合并这些子数组以获得最终的有序数组。尽管归并排序需要额外的空间和函数调用开销，但它在实践中被广泛使用，特别适用于对大规模数据进行排序。
1. 排序数组 https://leetcode.cn/problems/sort-an-array/
1.1 题目要求 给你一个整数数组 nums，请你将该数组升序排列。
示例 1：
输入：nums = [5,2,3,1] 输出：[1,2,3,5] 示例 2：
输入：nums = [5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示：
1 &lt;= nums.length &lt;= 5 * 104-5 * 104 &lt;= nums[i] &lt;= 5 * 104 class Solution { public int[] sortArray(int[] nums) { } } 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-06T09:38:27+08:00">
    <meta property="article:modified_time" content="2023-09-06T09:38:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法系列篇】分治-归并</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/c6/e1/t6FwleNB_o.gif" alt="在这里插入图片描述"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">前言</a></li><li><a href="#_6" rel="nofollow">什么是归并算法</a></li><li><a href="#1__32" rel="nofollow">1. 排序数组</a></li><li><ul><li><a href="#11__35" rel="nofollow">1.1 题目要求</a></li><li><a href="#12__61" rel="nofollow">1.2 做题思路</a></li><li><a href="#13_Java_68" rel="nofollow">1.3 Java代码实现</a></li></ul> 
  </li><li><a href="#2__107" rel="nofollow">2. 数组中逆序对</a></li><li><ul><li><a href="#21__110" rel="nofollow">2.1 题目要求</a></li><li><a href="#22__132" rel="nofollow">2.2 做题思路</a></li><li><a href="#23_Java_140" rel="nofollow">2.3 Java代码实现</a></li></ul> 
  </li><li><a href="#3__228" rel="nofollow">3. 计算右侧小于当前元素的个数</a></li><li><ul><li><a href="#31__231" rel="nofollow">3.1 题目要求</a></li><li><a href="#32__266" rel="nofollow">3.2 做题思路</a></li><li><a href="#33_Java_273" rel="nofollow">3.3 Java代码实现</a></li></ul> 
  </li><li><a href="#4__332" rel="nofollow">4. 翻转对</a></li><li><ul><li><a href="#41__335" rel="nofollow">4.1 题目要求</a></li><li><a href="#42__361" rel="nofollow">4.2 做题思路</a></li><li><a href="#43_Java_367" rel="nofollow">4.3 Java代码实现</a></li></ul> 
  </li><li><a href="#_458" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>前言</h2> 
<p>上一篇算法文章，我们介绍了分治-快排的算法，今天我将为大家分享关于分治的另外一种算法——归并。</p> 
<h2><a id="_6"></a>什么是归并算法</h2> 
<p><img src="https://images2.imgbox.com/d6/bb/ac6qm28j_o.png" alt="在这里插入图片描述"><br> 归并算法是一种常用的排序算法，它采用分治策略将待排序的数组分解为更小的子数组，然后逐步合并这些子数组以获得最终的有序数组。归并排序的主要思想是将两个有序的子数组合并成一个有序的数组。</p> 
<p>归并算法通常包含以下步骤：</p> 
<ol><li> <p>分解（Divide）：将待排序的数组递归地分解为规模更小的子数组，直到每个子数组只有一个元素或为空。</p> </li><li> <p>解决（Conquer）：通过递归地排序子数组，将其转化为有序的子数组。这通常是通过继续将子数组进一步分解并排序的方式实现的。</p> </li><li> <p>合并（Merge）：将两个有序的子数组合并成一个有序的数组。该步骤的实现方式是比较两个子数组的元素，并按照顺序合并到一个新的数组中，直到所有元素都被合并。</p> </li></ol> 
<p>归并排序的时间复杂度是O(nlogn)，其中n是待排序数组的长度。它的主要优点包括：</p> 
<ol><li> <p>稳定性：归并排序是一种稳定的排序算法，即相等元素的相对顺序不会被改变。</p> </li><li> <p>适用性：归并排序适用于各种数据结构，尤其在外部排序中，它对于大规模数据的排序效果明显。</p> </li></ol> 
<p>然而，归并排序也存在一些缺点：</p> 
<ol><li> <p>额外空间消耗：归并排序需要额外的空间来存储临时的子数组和合并结果，这可能对内存消耗造成一定影响。</p> </li><li> <p>递归调用：归并排序的实现通常使用递归调用，对于大规模数据的排序可能导致递归深度增加，从而增加了额外的函数调用开销。</p> </li></ol> 
<p>总结而言，归并排序是一种高效、稳定的排序算法，通过分治策略将待排序的数组分解为更小的子数组，然后逐步合并这些子数组以获得最终的有序数组。尽管归并排序需要额外的空间和函数调用开销，但它在实践中被广泛使用，特别适用于对大规模数据进行排序。</p> 
<h2><a id="1__32"></a>1. 排序数组</h2> 
<p><a href="https://leetcode.cn/problems/sort-an-array/" rel="nofollow">https://leetcode.cn/problems/sort-an-array/</a></p> 
<h3><a id="11__35"></a>1.1 题目要求</h3> 
<p>给你一个整数数组 nums，请你将该数组升序排列。</p> 
<p>示例 1：</p> 
<pre><code>输入：nums = [5,2,3,1]
输出：[1,2,3,5]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
</code></pre> 
<p>提示：</p> 
<ul><li>1 &lt;= nums.length &lt;= 5 * 104</li><li>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12__61"></a>1.2 做题思路</h3> 
<p>不知道大家是否做过将两个有序数组合并为一个有序数组，我们的归并算法就是通过将两个数组合并为一个有序数组来实现的。而归并的思想就是就一整个数组从中间将数组分为两个数组，然后再继续将这两个数组分别从中间分开，直到将这两部分的数组分为只有一个元素的两部分数组，然后将这两个数组通过合并两个数组的操作来进行合并，合并完成之后的数组就成为了一个有序的数组，然后继续将这两个有序的数组通过合并数组的操作继续进行合并，直到将这些数组合并为一个最大的数组。<br> <img src="https://images2.imgbox.com/c7/f9/eqG6tot5_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/01/73/kqH1YMIB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="13_Java_68"></a>1.3 Java代码实现</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//因为每一次递归都需要创建临时的数组来存储两个数组排序之后的结果，</span>
    <span class="token comment">//每次都向申请内存，速度会很慢</span>
    <span class="token comment">//所以我们直接申请一个跟nums同样大小的数组</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//当数组中只有一个元素或者区间不成立的时候，结束递归</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">//先排序mid左右两边的数组，最后在将左右两边的有序数组进行合并</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> cur1 <span class="token operator">=</span> left<span class="token punctuation">,</span>cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//处理没到达数组结尾的数组</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">//将临时排序之后数组的结果更新到我们原本的数组中</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j <span class="token operator">-</span> left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ef/21/q9Fj8ySg_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2__107"></a>2. 数组中逆序对</h2> 
<p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/" rel="nofollow">https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/</a></p> 
<h3><a id="21__110"></a>2.1 题目要求</h3> 
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p> 
<p>示例 1:</p> 
<pre><code>输入: [7,5,6,4]
输出: 5
</code></pre> 
<p>限制：</p> 
<ul><li>0 &lt;= 数组长度 &lt;= 50000</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="22__132"></a>2.2 做题思路</h3> 
<p>我们先来看看如何使用暴力解法来解决这个问题：用两层循环来遍历数组，i 从 0 开始，j 则从 i 的下一个位置开始，看 j 所指向的位置是否小于 i 所指的位置，如果是则逆序对总数加一。这样虽然简单，但是时间复杂度达到了 O(N^2)，是跑不过去的，那么我们就需要对暴力解法进行优化，问题就在于我们该如何优化呢？</p> 
<p>这样想，如果我们将数组分为两个部分，先计算左边部分的数组中的所有逆序对，然后计算右边部分数组中的所有逆序对，最后在左边数组一次选择一个数字，看右边数组中是否元素能与左边数组中的那个元素构成逆序对，这样的思路其实跟暴力解法是相同的，时间复杂度都是 O(N^2)，那么当我们分别在左边数组中和右边数组中找到了符合的逆序对的话，我们是否可以将这两部分数组进行排序呢？当进行了排序之后，再分别在左边数组中依次拿元素与右边数组中的元素进行比较，假设我们按照升序的方式进行排序，当左边部分遇到比右边数组部分大的元素的话，那么左边数组部分从这个元素开始到左边部分数组结束的位置是否都大于右边数组的该元素呢？<br> <img src="https://images2.imgbox.com/2f/f4/adTEAk8P_o.png" alt="在这里插入图片描述"><br> 如果nums[cur1] &lt; nums[cur2] 则继续让 cur1 向右移动，直到出现逆序对的情况，这样 cur1 和 cur2 指针都不用返回，就较少了很多的重复比较，使得时间复杂度提升为<br> O(N*logN)。</p> 
<h3><a id="23_Java_140"></a>2.3 Java代码实现</h3> 
<p>（1）升序方法</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">//统计逆序对的数量</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//计算左边数组中逆序对的数量</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//计算右边数组中逆序对的数量</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> cur1 <span class="token operator">=</span> left<span class="token punctuation">,</span> cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//当nums[cur1] &lt;= nums[cur2] 的时候，只需要进行合并数组的操作</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">//当nums[cur1] &gt; nums[cur2] 的时候，需要更新逆序对的数量，同时也需要合并数组</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                ret <span class="token operator">+=</span> mid <span class="token operator">-</span> cur1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j <span class="token operator">-</span> left<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2a/05/DpFHqlts_o.png" alt="在这里插入图片描述"><br> （2）降序方法<br> 我们也可以用降序排列的方式来实现归并排序，只是当使用降序的时候，需要在右边数组中统计逆序对的数量，因为当遇到 nums[cur1] &gt; nums[cur2] 的时候，如果还是统计左边数组 mid - cur1 + 1 作为逆序对的数量的话，那么当 cur2 向后移动的时候，再遇到 nums[cur1] &gt; nums[cur2] 的时候就会出现重复的情况，所以<font color="CC0000">当我们以降序的方式排序的时候需要在右边数组中统计逆序对的数量。<br> <img src="https://images2.imgbox.com/c0/30/xOymXx8D_o.png" alt="在这里插入图片描述"></font></p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">//统计逆序对的数量</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//计算左边数组中逆序对的数量</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//计算右边数组中逆序对的数量</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> cur1 <span class="token operator">=</span> left<span class="token punctuation">,</span> cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//当nums[cur1] &lt;= nums[cur2] 的时候，只需要进行合并数组的操作</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">//当nums[cur1] &gt; nums[cur2] 的时候，需要更新逆序对的数量，同时也需要合并数组</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                ret <span class="token operator">+=</span> right <span class="token operator">-</span> cur2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j <span class="token operator">-</span> left<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/5f/8a/UKk027rN_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3__228"></a>3. 计算右侧小于当前元素的个数</h2> 
<p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/description/" rel="nofollow">https://leetcode.cn/problems/count-of-smaller-numbers-after-self/description/</a></p> 
<h3><a id="31__231"></a>3.1 题目要求</h3> 
<p>给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。</p> 
<p>示例 1：</p> 
<pre><code>输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：nums = [-1]
输出：[0]
</code></pre> 
<p>示例 3：</p> 
<pre><code>输入：nums = [-1,-1]
输出：[0,0]
</code></pre> 
<p>提示：</p> 
<ul><li>1 &lt;= nums.length &lt;= 105</li><li>-104 &lt;= nums[i] &lt;= 104</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">countSmaller</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="32__266"></a>3.2 做题思路</h3> 
<p>这道题目跟上面的找逆序对的数量是类似的，逆序对是找前面的元素大于后面元素的个数，而这道题是需要找到数组中每个元素的之后的小于该元素的个数，也就是说这个题目返回的是多个数，而不是一个数。那么我们在使用分冶算法的过程中该如何记住对应数字的下标呢？因为在分冶的过程中加上排序，数组中元素的位置是不断变化的，但是这道题目按顺序返回数组中对用位置右边部分大小小于该位置元素的数量，所以这道题目如何记住原本数组对应元素的下标是很重要的。</p> 
<p>那么我们如何记住原本数组元素的对应下标呢？我们可以创建一个 index 数组，当数组进行合并排序的时候，相应的 index 数组也跟着变化，这样就能使排序后数组对应位置的 index 数组中存放的是原本数组的下标。</p> 
<p><img src="https://images2.imgbox.com/ce/0b/V5LryzKb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33_Java_273"></a>3.3 Java代码实现</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret<span class="token punctuation">;</span> <span class="token comment">//该数组中存放右侧小于当前元素的个数</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> index<span class="token punctuation">;</span> <span class="token comment">//存放对应元素的下标</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpNums<span class="token punctuation">;</span> <span class="token comment">//排序后的临时数组</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpIndex<span class="token punctuation">;</span> <span class="token comment">//排序后对应元素的原本下标</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">countSmaller</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//index 数组初始化</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> index<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        tmpNums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        tmpIndex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">mergerSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> ret<span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergerSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token function">mergerSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergerSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> cur1 <span class="token operator">=</span> left<span class="token punctuation">,</span> cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//降序</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                tmpNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span><span class="token punctuation">;</span>
                tmpIndex<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//因为前面的递归中可能出现了右侧小于当前位置的数，所以需要使用+=</span>
                ret<span class="token punctuation">[</span>index<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> right <span class="token operator">-</span> cur2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                tmpNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span><span class="token punctuation">;</span>
                tmpIndex<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmpNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span><span class="token punctuation">;</span>
            tmpIndex<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmpNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span><span class="token punctuation">;</span>
            tmpIndex<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmpNums<span class="token punctuation">[</span>j <span class="token operator">-</span> left<span class="token punctuation">]</span><span class="token punctuation">;</span>
            index<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmpIndex<span class="token punctuation">[</span>j <span class="token operator">-</span> left<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/46/d2/21GnyT4n_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4__332"></a>4. 翻转对</h2> 
<p><a href="https://leetcode.cn/problems/reverse-pairs/description/" rel="nofollow">https://leetcode.cn/problems/reverse-pairs/description/</a></p> 
<h3><a id="41__335"></a>4.1 题目要求</h3> 
<p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p> 
<p>你需要返回给定数组中的重要翻转对的数量。</p> 
<p>示例 1:</p> 
<pre><code>输入: [1,3,2,3,1]
输出: 2
</code></pre> 
<p>示例 2:</p> 
<pre><code>输入: [2,4,3,5,1]
输出: 3
</code></pre> 
<p>注意:</p> 
<ul><li>给定数组的长度不会超过50000。</li><li>输入数组中的所有数字都在32位整数的表示范围内。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="42__361"></a>4.2 做题思路</h3> 
<p>这个题目跟前面的的两个题目都是类似的，只是这里不能在我们更新翻转对的时候就进行排序，因为翻转对的判断条件是 i &lt; j 且 nums[i] &gt; 2*nums[j]，根据这个判断条件，我们不能判断出 nums[i] 和 nums[j] 哪个大，所以只能在更新完翻转对之后进行归并排序，其他的步骤基本上是类似的。<br> <img src="https://images2.imgbox.com/47/73/xLk8zpAf_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="43_Java_367"></a>4.3 Java代码实现</h3> 
<p>（1）升序</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token comment">//统计左右两部分数组中翻转对的数量</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> cur1 <span class="token operator">=</span> left<span class="token punctuation">,</span> cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//这里需要使用nums[cur1] / 2.0 而不是nums[cur2] * 2，</span>
        <span class="token comment">//因为可能会导致溢出</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2.0</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span><span class="token punctuation">)</span> cur1<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur1 <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            ret <span class="token operator">+=</span> mid <span class="token operator">-</span> cur1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            cur2<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

		<span class="token comment">//升序</span>
        cur1 <span class="token operator">=</span> left<span class="token punctuation">;</span>
        cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j <span class="token operator">-</span> left<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ab/06/DqG4tKkK_o.png" alt="在这里插入图片描述"></p> 
<p>（2）降序</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ret <span class="token operator">+=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> cur1 <span class="token operator">=</span> left<span class="token punctuation">,</span> cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//降序</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//这里cur1不动，因为cur1向后移动只会越来越小，所以让cur2向后移动</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2.0</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span><span class="token punctuation">)</span> cur2<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur2 <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
            ret <span class="token operator">+=</span> right <span class="token operator">-</span> cur2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            cur1<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        cur1 <span class="token operator">=</span> left<span class="token punctuation">;</span>
        cur2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>cur2<span class="token punctuation">]</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>cur2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>j <span class="token operator">-</span> left<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e1/e6/UpOOHZdK_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_458"></a>总结</h2> 
<p>归并排序是一种高效而稳定的排序算法，它利用了分治策略，将待排序的数组分解为更小的子数组，并逐步合并这些子数组以获得最终的有序数组。</p> 
<p>归并排序算法的核心思想是将待排序数组递归地分解为规模更小、有序的子数组，然后通过合并操作将这些子数组有序地合并成一个大的有序数组。这种分解和合并的过程直到最终合并成排序后的完整数组。</p> 
<p>归并排序算法具有以下优点：</p> 
<ol><li> <p>稳定性：归并排序是一种稳定的排序算法，即相等元素的相对顺序不会被改变。这使得它特别适用于对具有多关键字排序要求的情况。</p> </li><li> <p>高效性：归并排序的时间复杂度为O(nlogn)，其中n是待排序数组的长度。它具有较好的性能表现，并适用于大规模数据的排序。</p> </li></ol> 
<p>此外，归并排序算法还具有一定的弹性和灵活性。它可以通过优化合并操作的实现方式，减少额外空间的消耗。此外，归并排序也适用于外部排序，可以处理存储在外部存储介质中的大规模数据。</p> 
<p>尽管归并排序算法需要额外的空间和函数调用开销，但由于其稳定性和较好的时间复杂度，它在实际应用中被广泛采用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/195ab708091e4ff9f5a02adcb9eb2eae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【web知识清单】你想要的都有：网络、HTTP、会话保持、认证授权......持续更新中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7bb47c74c39e364518c99d8bf5a2eb1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">el-select数据过多的解决（纯前端）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>