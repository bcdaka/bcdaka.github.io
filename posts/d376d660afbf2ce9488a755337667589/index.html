<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之ArrayList与顺序表（上） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d376d660afbf2ce9488a755337667589/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之ArrayList与顺序表（上）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
顺序表的学习，点我
上面这篇博文是关于顺序表的基础知识，以及顺序表的实现。
目录
手动实现顺序表的源码：
分析Java 8 的 ArrayList 的源码 字段：
构造方法：
ArrayList本身的扩容机制和分配内存机制
ArrayList常见操作
ArrayList的遍历 普通for循环遍历
for-each遍历 toString方法遍历 迭代器遍历 手动实现顺序表的源码： 下面是Java版的顺序表源码：
public class MyArraylist { public int[] elem; public int usedSize;//0 //默认容量 private static final int DEFAULT_SIZE = 10; public MyArraylist() { this.elem = new int[DEFAULT_SIZE]; } /** * 打印顺序表: * 根据usedSize判断即可 */ public void display() { for (int i = 0; i &lt; this.usedSize; i&#43;&#43;) { System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-07T21:45:43+08:00">
    <meta property="article:modified_time" content="2024-06-07T21:45:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之ArrayList与顺序表（上）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></p> 
</blockquote> 
<p><a class="link-info" href="https://blog.csdn.net/2301_80854132/article/details/137356385" title="顺序表的学习，点我">顺序表的学习，点我</a></p> 
<p>上面这篇博文是关于顺序表的基础知识，以及顺序表的实现。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A" rel="nofollow">手动实现顺序表的源码：</a></p> 
<p id="%E5%88%86%E6%9E%90Java%208%20%E7%9A%84%20ArrayList%20%E7%9A%84%E6%BA%90%E7%A0%81%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%88%86%E6%9E%90Java%208%20%E7%9A%84%20ArrayList%20%E7%9A%84%E6%BA%90%E7%A0%81%C2%A0" rel="nofollow">分析Java 8 的 ArrayList 的源码 </a></p> 
<p id="%E5%AD%97%E6%AE%B5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%AD%97%E6%AE%B5%EF%BC%9A" rel="nofollow">字段：</a></p> 
<p id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">构造方法：</a></p> 
<p id="ArrayList%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#ArrayList%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6" rel="nofollow">ArrayList本身的扩容机制和分配内存机制</a></p> 
<p id="ArrayList%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#ArrayList%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C" rel="nofollow">ArrayList常见操作</a></p> 
<p id="ArrayList%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:0px;"><a href="#ArrayList%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow">ArrayList的遍历 </a></p> 
<p id="%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86" rel="nofollow">普通for循环遍历</a></p> 
<p id="for-each%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:40px;"><a href="#for-each%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow">for-each遍历 </a></p> 
<p id="toString%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:40px;"><a href="#toString%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow">toString方法遍历 </a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%C2%A0" rel="nofollow">迭代器遍历 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A" style="background-color:transparent;"><span style="color:#fe2c24;">手动实现顺序表的源码：</span></h2> 
<p>下面是Java版的顺序表源码：</p> 
<pre><code class="language-java">public class MyArraylist {
    public int[] elem;
    public int usedSize;//0
    //默认容量
    private static final int DEFAULT_SIZE = 10;

    public MyArraylist() {
        this.elem = new int[DEFAULT_SIZE];
    }

    /**
     * 打印顺序表:
     *   根据usedSize判断即可
     */
    public void display() {
        for (int i = 0; i &lt; this.usedSize; i++) {
            System.out.print(this.elem[i]+" ");
        }
        System.out.println();
    }

    // 新增元素,默认在数组最后新增
    public void add(int data) {
        // 增加元素之前得先判断数组是否已满
        if (isFull()) {
            expansion();
        }
        // 尾插数据不需要判断 pos 位置是否合法
        elem[this.usedSize++] = data;
    }

    // 扩容
    private void expansion() {
        // 原来数组的2倍扩容
        this.elem = Arrays.copyOf(this.elem, 2 * this.elem.length);
    }

    /**
     * 判断当前的顺序表是不是满的！
     * @return true:满   false代表空
     */
    public boolean isFull() {
        // 判断这个数组的有效元素个数是否等于数组的长度
        return this.usedSize == this.elem.length;
    }


    private boolean checkPosInAdd(int pos) {
        if (pos &lt; 0 || pos &gt; this.usedSize) {
            return false;
        }
        return true;//合法
    }

    // 在 pos 位置新增元素
    public void add(int pos, int data) throws PosofAddException{
        if (!checkPosInAdd(pos)) {
            throw new PosofAddException("add(int pos, int data) " +
                    "pos位置不合法");
        }
        // 判断是否为尾插
        if (pos == this.usedSize) {
            add(data);
        }else {
            // 开始移除元素（从后往前移除）
            for (int i = this.usedSize; i &gt; pos; i--) {
                this.elem[i] = this.elem[i-1];
            }
            // 开始插入数据
            this.elem[pos] = data;
            this.usedSize++;
        }
    }

    // 判定是否包含某个元素
    public boolean contains(int toFind) {
        // 先判断这个数组是否有元素
        if (isEmpty()) {
            return false;
        }
        for (int i = 0; i &lt; this.usedSize; i++) {
            if (this.elem[i] == toFind) {
                return true;
            }
        }
        return false;
    }

    // 查找某个元素对应的位置
    public int indexOf(int toFind) {
        for (int i = 0; i &lt; this.usedSize; i++) {
            if (this.elem[i] == toFind) {
                return i;
            }
        }
        return -1;
    }

    // 获取 pos 位置的元素
    public int get(int pos) throws PosofGetException{
        if (pos &lt; 0 || pos &gt; this.usedSize) {
            throw new PosofGetException("get(int pos)" +
                    "pos位置不合法");
        }
        return this.elem[pos];
    }

    private boolean isEmpty() {
        // 有效数据个数为0，就是为空
        return this.usedSize == 0;
    }

    // 给 pos 位置的元素设为【更新为】 value
    public void set(int pos, int value) throws PosofSetException{
        // 先得判断这个 pos 位置是否合法
        if (pos &lt; 0 || pos &gt;= this.usedSize) {
            throw new PosofSetException("set(int pos, int value)" +
                    "要修改的位置不合法");
        }
        this.elem[pos] = value;
    }

    /**
     * 删除第一次出现的关键字key
     * @param key
     */
    public void remove(int key) throws PosofRemoveException{
        int pos = indexOf(key); // 下标
        if (pos &lt; 0) {
            throw new PosofRemoveException("remove(int key)" +
                    "没有您要删除的数据");
        }
        for (int i = pos; i &lt; this.usedSize - 1; i++) {
            // 后一个位置往前覆盖
            this.elem[i] = this.elem[i+1];
        }
        this.usedSize--;
    }

    // 获取顺序表长度
    public int size() {
        return this.usedSize;
    }

    // 清空顺序表
    public void clear() {
        // 由于存放的是基本数据类型，直接清空即可
        this.usedSize = 0;
        // 如果存放的是引用数据类型就得通过for循环遍历把数组的内容置为null
        // 注意：如果直接把数组置为null的话，就会存在安全问题，而且源码也是遍历的方式
    }
}
</code></pre> 
<p>异常：</p> 
<p>PosofAddException：</p> 
<pre><code class="language-java">public class PosofAddException extends RuntimeException{
    public PosofAddException() {

    }
    public PosofAddException(String msg) {
        super(msg);
    }
}
</code></pre> 
<p> PosofGetException：</p> 
<pre><code class="language-java">public class PosofGetException extends RuntimeException{
    public PosofGetException() {

    }
    public PosofGetException(String msg) {
        super(msg);
    }
}</code></pre> 
<p>PosofSetException： </p> 
<pre><code class="language-java">public class PosofSetException extends RuntimeException{
    public PosofSetException() {

    }
    public PosofSetException(String msg) {
        super(msg);
    }
}
</code></pre> 
<p>PosofRemoveException： </p> 
<pre><code class="language-java">public class PosofRemoveException extends RuntimeException{
    public PosofRemoveException() {

    }
    public PosofRemoveException(String msg) {
        super(msg);
    }
}
</code></pre> 
<h2 id="%E5%88%86%E6%9E%90Java%208%20%E7%9A%84%20ArrayList%20%E7%9A%84%E6%BA%90%E7%A0%81%C2%A0"><span style="color:#fe2c24;">分析Java 8 的 ArrayList 的源码</span> </h2> 
<p>实现了咱们自己写的顺序表了之后，就该来看Java本身的源码是怎么写的以及与我们的有什么不同？（注意：由于Java 17封装性太强，不好观看源码，因此下面的源码来自Java 8。）</p> 
<h3 id="%E5%AD%97%E6%AE%B5%EF%BC%9A"><span style="color:#38d8f0;">字段：</span></h3> 
<p><img alt="" height="546" src="https://images2.imgbox.com/8c/a5/AXXfPa6R_o.png" width="1200"></p> 
<p>elementData 就是我们自己实现的 elem 数组。</p> 
<p>size 就是 usedSize ，也就是这个数组的有效元素的个数。 </p> 
<h3 id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span style="color:#38d8f0;">构造方法：</span></h3> 
<p>Java 8 实现的顺序表有三个构造方法。 </p> 
<p>带有一个 int 类型的参数的构造方法： </p> 
<p><img alt="" height="714" src="https://images2.imgbox.com/37/5f/2z1kQFmO_o.png" width="1200"></p> 
<p> 不带参数的构造方法：</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/aa/6e/x7IIMZhw_o.png" width="1200"></p> 
<p>带一个 Collection 类型的参数的构造方法：</p> 
<p>下面的是其源码： </p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/dd/68/QyW9B23q_o.png" width="1200"></p> 
<p>首先，我们得知道Collection 到底是这个啥？ </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/38/30/hr1KazRv_o.jpg"></p> 
<p>根据上面这个图可以得知：Collection 是一个接口。</p> 
<p>上面的参数先不看泛型，那就是Collection c  这个意味着只要实现了Collection 接口，就可以被当成实参传过来。而从上图的关系可知：ArrayList 继承了 AbstractLIst 这个抽象类 ，并且实现了LIst这个接口，而 LIst 这个接口拓展了 Collection 这个接口的功能。也就意味着 ArrayList 这个类实现了 Collection 这个接口。那么 ArrayList 就可以被当成参数传过来。</p> 
<p>接下来，就是了解 &lt;? extends E&gt; ，？就可以当成是被传过来的 ArrayList 中的泛型，也就是说被传过来的 ArrayList 中的泛型要是 E 或者 E的子类。例如：</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/36/b7/71CgtmBe_o.png" width="1200"></p> 
<p>了解了这些，我们就来看源码吧。这个源码的大概意思是把传入的 ArrayList 中的元素给全部拷贝到原来的 ArrayList 的后面。</p> 
<h3 id="ArrayList%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6"><span style="color:#38d8f0;">ArrayList本身的扩容机制和分配内存机制</span></h3> 
<p>既然我们在创建一个顺序表的时候，原本是空，那么当我们去增加元素的时候，扩容的机制又是如何呢？</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/83/da/VPL4kopZ_o.png" width="1200"></p> 
<p>上面是分析过程（可忽略），总之，得出了下面这个结论： </p> 
<p><span style="color:#ff9900;">当顺序表为空时，我们如果去增加元素，就会初始化一个大小10的数组。并且数组在满了之后，会按照1.5倍的扩容方式来扩容。如果用户所需大小超过预估1.5倍大小，则按照用户所需大小扩容。</span></p> 
<h2 id="ArrayList%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span style="color:#fe2c24;">ArrayList常见操作</span></h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   ArrayList常用方法 
 </caption><tbody><tr><td>boolean add(E e)</td><td>尾插e</td></tr><tr><td>void add(int index, E element)</td><td>将 e 插入到 index 位置</td></tr><tr><td>boolean addAll(Collection&lt;? extends E&gt; c)</td><td>将c 中的元素进行尾插</td></tr><tr><td>E remove(int index)</td><td>删除 index 位置元素</td></tr><tr><td>boolean remove(Object o)</td><td>删除遇到的第一个o</td></tr><tr><td>E get(int index)</td><td>获取下标index位置元素</td></tr><tr><td>E set(int index, E element)</td><td>将下标 index 位置元素改为 element</td></tr><tr><td>void clear()</td><td>清空</td></tr><tr><td>boolean contains(Object o）</td><td>判断是否在顺序表中</td></tr><tr><td>int indexOf(Object o)</td><td>返回第一个o所在下标</td></tr><tr><td>int lastlndexOf(Object o)</td><td>返回最后一个o的下标</td></tr><tr><td>List&lt;E&gt; subList(int fromlndex, int tolndex)</td><td>截取部分list</td></tr></tbody></table> 
<p>大部分方法，我们都很熟悉。因此这里只展示 addAll()方法 和 subList 方法。</p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/80/25/wCOc792a_o.png" width="1200"></p> 
<p>addAll () 方法可以实现 ArrayList 的带Collection 类型的参数的构造方法。</p> 
<p>从上面打印的结果可以看出来，ArrayList 是重写了toString 方法的。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/88/c1/N8yxGGfz_o.png" width="1200"></p> 
<p>从这里我们就可以看出来，被分割的数组应该是下面这样：</p> 
<p><img alt="" height="567" src="https://images2.imgbox.com/56/58/dwQV1NNJ_o.png" width="1200"></p> 
<h2 id="ArrayList%E7%9A%84%E9%81%8D%E5%8E%86%C2%A0"><span style="color:#fe2c24;">ArrayList的遍历 </span></h2> 
<h3 id="%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span style="color:#38d8f0;">普通for循环遍历</span></h3> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(1);
        arrayList.add(2);
        arrayList.add(3);
        for (int i = 0; i &lt; arrayList.size(); i++) {
            System.out.print(arrayList.get(i)+" ");
        }
    }
}</code></pre> 
<h3 id="for-each%E9%81%8D%E5%8E%86%C2%A0"><span style="color:#38d8f0;">for-each遍历 </span></h3> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(1);
        arrayList.add(2);
        arrayList.add(3);
        for (Integer x : arrayList) {
            System.out.print(x+" ");
        }
    }
}</code></pre> 
<h3 id="toString%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%C2%A0"><span style="color:#38d8f0;">toString方法遍历 </span></h3> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(1);
        arrayList.add(2);
        arrayList.add(3);
        System.out.println(arrayList.toString());
    }
}</code></pre> 
<h3 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%C2%A0" style="background-color:transparent;"><span style="color:#38d8f0;">迭代器遍历</span> </h3> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(1);
        arrayList.add(2);
        arrayList.add(3);
        // 调用iterator方法生成一个迭代器，用Iterator&lt;E&gt;来接收
        Iterator&lt;Integer&gt; integerIterator = arrayList.iterator();
        // 如果下一个元素有值话，就进入while循环，并且打印下一个值，最后自己往后走
        while (integerIterator.hasNext()) {
            System.out.print(integerIterator.next()+" ");
        }
    }
}
        </code></pre> 
<p>只要是实现了 Iterator 接口就可以使用迭代器的方式来遍历。就是下面这张图：</p> 
<p><img alt="" src="https://images2.imgbox.com/81/0e/lcx3Ue5d_o.jpg"></p> 
<p>好啦！本期 数据结构之ArrayList与顺序表（上）的学习就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/540f978c4e0c98fb75ad03d07578e9f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vagrant CentOS7 安装 Docker 及使用 Docker 安装 MySQL</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2cde7415f262279951519f3fc48c4df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">G5 - Pix2Pix理论与实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>