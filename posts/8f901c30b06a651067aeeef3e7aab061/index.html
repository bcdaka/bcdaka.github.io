<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>127. Go反射基本原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8f901c30b06a651067aeeef3e7aab061/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="127. Go反射基本原理">
  <meta property="og:description" content="文章目录 反射基础 - go 的 interface 是怎么存储的？iface 和 eface 的结构体定义（runtime/iface.go）：_type 是什么？itab 是什么？ 反射对象 - reflect.Type 和 reflect.Value反射三大定律Elem 方法reflect.Value 的 Elem 方法reflect.Type 的 Elem 方法 Interface 方法Kindaddressable 获取类型信息 - reflect.Type通用的 Type 方法某些类型特定的 Type 方法创建 reflect.Type 的方式 获取值信息 - reflect.Valuereflect.Value 的方法创建 reflect.Value 的方式 总结 反射是这样一种机制，它是可以让我们在程序运行时（runtime）访问、检测和修改对象本身状态或行为的一种能力。 比如，从一个变量推断出其类型信息、以及存储的数据的一些信息，又或者获取一个对象有什么方法可以调用等。 反射经常用在一些需要同时处理不同类型变量的地方，比如序列化、反序列化、ORM 等等，如标准库里面的 json.Marshal。
反射基础 - go 的 interface 是怎么存储的？ 在正式开始讲解反射之前，我们有必要了解一下 go 里的接口（interface）是怎么存储的。 在之前相关文章中我们学习过，interface{} 类型(不含有任何方法的接口）在底层实际上是eface类型，而 含有方法的接口类型在底层实际上是 iface 类型。
iface 和 eface 的结构体定义（runtime/iface.go）： // 非空接口（如：io.Reader） type iface struct { tab *itab // 方法表 与 类型信息 data unsafe.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-10T19:59:54+08:00">
    <meta property="article:modified_time" content="2024-08-10T19:59:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">127. Go反射基本原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__go__interface__4" rel="nofollow">反射基础 - go 的 interface 是怎么存储的？</a></li><li><ul><li><a href="#iface__eface_runtimeifacego_7" rel="nofollow">iface 和 eface 的结构体定义（runtime/iface.go）：</a></li><li><a href="#_type__60" rel="nofollow">_type 是什么？</a></li><li><a href="#itab__86" rel="nofollow">itab 是什么？</a></li></ul> 
  </li><li><a href="#__reflectType__reflectValue_155" rel="nofollow">反射对象 - reflect.Type 和 reflect.Value</a></li><li><ul><li><a href="#_168" rel="nofollow">反射三大定律</a></li><li><a href="#Elem__212" rel="nofollow">Elem 方法</a></li><li><ul><li><a href="#reflectValue__Elem__215" rel="nofollow">reflect.Value 的 Elem 方法</a></li><li><a href="#reflectType__Elem__240" rel="nofollow">reflect.Type 的 Elem 方法</a></li></ul> 
   </li><li><a href="#Interface__259" rel="nofollow">Interface 方法</a></li><li><a href="#Kind_264" rel="nofollow">Kind</a></li><li><a href="#addressable_358" rel="nofollow">addressable</a></li></ul> 
  </li><li><a href="#__reflectType_367" rel="nofollow">获取类型信息 - reflect.Type</a></li><li><ul><li><a href="#_Type__371" rel="nofollow">通用的 Type 方法</a></li><li><a href="#_Type__442" rel="nofollow">某些类型特定的 Type 方法</a></li><li><a href="#_reflectType__515" rel="nofollow">创建 reflect.Type 的方式</a></li></ul> 
  </li><li><a href="#__reflectValue_521" rel="nofollow">获取值信息 - reflect.Value</a></li><li><ul><li><a href="#reflectValue__527" rel="nofollow">reflect.Value 的方法</a></li><li><a href="#_reflectValue__564" rel="nofollow">创建 reflect.Value 的方式</a></li></ul> 
  </li><li><a href="#_570" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<p>反射是这样一种机制，它是可以让我们在程序运行时（<code>runtime</code>）访问、检测和修改对象本身状态或行为的一种能力。 比如，从一个变量推断出其类型信息、以及存储的数据的一些信息，又或者获取一个对象有什么方法可以调用等。 反射经常用在一些需要同时处理不同类型变量的地方，比如序列化、反序列化、<code>ORM</code> 等等，如标准库里面的 <code>json.Marshal</code>。</p> 
<h2><a id="__go__interface__4"></a>反射基础 - go 的 interface 是怎么存储的？</h2> 
<p>在正式开始讲解反射之前，我们有必要了解一下 <code>go</code> 里的接口（<code>interface</code>）是怎么存储的。 在之前相关文章中我们学习过，<strong><code>interface{}</code> 类型(不含有任何方法的接口）在底层实际上是<code>eface</code>类型，而 含有方法的接口类型在底层实际上是 <code>iface</code> 类型。</strong></p> 
<h3><a id="iface__eface_runtimeifacego_7"></a>iface 和 eface 的结构体定义（runtime/iface.go）：</h3> 
<pre><code class="prism language-go"><span class="token comment">// 非空接口（如：io.Reader）</span>
<span class="token keyword">type</span> iface <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
 tab  <span class="token operator">*</span>itab          <span class="token comment">// 方法表 与 类型信息</span>
 data unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 指向变量本身的指针</span>
<span class="token punctuation">}</span>

<span class="token comment">// 空接口（interface{}）</span>
<span class="token keyword">type</span> eface <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
 _type <span class="token operator">*</span>_type         <span class="token comment">// 接口变量的类型</span>
 data  unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 指向变量本身的指针</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>go</code> 底层的类型信息是使用 <code>_type </code>结构体来存储的。</p> 
<p>比如，我们有下面的代码：</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">type</span> Bird <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
 name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b Bird<span class="token punctuation">)</span> <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Flyable <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
 <span class="token function">Fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 bird <span class="token operator">:=</span> Bird<span class="token punctuation">{<!-- --></span>name<span class="token punctuation">:</span> <span class="token string">"b1"</span><span class="token punctuation">}</span>
 <span class="token keyword">var</span> efc <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token operator">=</span> bird <span class="token comment">// efc 是 eface</span>
 <span class="token keyword">var</span> ifc Flyable <span class="token operator">=</span> bird <span class="token comment">// ifc 是 iface</span>

 <span class="token function">println</span><span class="token punctuation">(</span>efc<span class="token punctuation">)</span> <span class="token comment">// runtime.printeface</span>
 <span class="token function">println</span><span class="token punctuation">(</span>ifc<span class="token punctuation">)</span> <span class="token comment">// runtime.printiface</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面代码中，<code>efc</code> 是 <code>eface</code> 类型的变量，对应到 <code>eface </code>结构体的话，<code>_type </code>就是<code>Bird</code>这个类型本身，而<code>data</code>就是 <code>&amp;bird</code> 这个指针：<br> <img src="https://images2.imgbox.com/cb/8a/Tx77JrQa_o.png" alt="在这里插入图片描述"></p> 
<p>类似的，<code>ifc</code> 是 <code>iface</code> 类型的变量，对应到<code>iface</code>结构体的话，<code>data</code> 也是 <code>&amp;bird</code> 这个指针：</p> 
<p><img src="https://images2.imgbox.com/1d/74/f6hGHCyw_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_type__60"></a>_type 是什么？</h3> 
<p>在<code>go</code>中，<code>_type </code>是保存了变量类型的元数据的结构体，定义如下：</p> 
<pre><code class="prism language-go"><span class="token comment">// _type 是 go 里面所有类型的一个抽象，里面包含 GC、反射、大小等需要的细节，</span>
<span class="token comment">// 它也决定了 data 如何解释和操作。</span>
<span class="token comment">// 里面包含了非常多信息：类型的大小、哈希、对齐及 kind 等信息</span>
<span class="token keyword">type</span> _type <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    size       <span class="token builtin">uintptr</span> <span class="token comment">// 数据类型共占用空间的大小</span>
    ptrdata    <span class="token builtin">uintptr</span> <span class="token comment">// 含有所有指针类型前缀大小</span>
    hash       <span class="token builtin">uint32</span>  <span class="token comment">// 类型 hash 值；避免在哈希表中计算</span>
    tflag      tflag   <span class="token comment">// 额外类型信息标志</span>
    align      <span class="token builtin">uint8</span>   <span class="token comment">// 该类型变量对齐方式</span>
    fieldAlign <span class="token builtin">uint8</span>   <span class="token comment">// 该类型结构体字段对齐方式</span>
    kind       <span class="token builtin">uint8</span>   <span class="token comment">// 类型编号</span>
    <span class="token comment">// 用于比较此类型对象的函数</span>
    equal <span class="token keyword">func</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span> <span class="token builtin">bool</span>
    <span class="token comment">// gc 相关数据</span>
    gcdata    <span class="token operator">*</span><span class="token builtin">byte</span>
    str       nameOff <span class="token comment">// 类型名字的偏移</span>
    ptrToThis typeOff
<span class="token punctuation">}</span>
</code></pre> 
<p>这个 <code>_type</code> 结构体定义大家大致看看就好了，实际上，<code>go</code> 底层的类型表示也不是上面这个结构体这么简单。</p> 
<h3><a id="itab__86"></a>itab 是什么？</h3> 
<p>我们从 <code>iface</code> 中可以看到，它包含了一个 <code>*itab</code> 类型的字段，我们看看这个 <code>itab</code> 的定义：</p> 
<pre><code class="prism language-go"><span class="token comment">// 编译器已知的 itab 布局</span>
<span class="token keyword">type</span> itab <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
 inter <span class="token operator">*</span>interfacetype <span class="token comment">// 接口类型</span>
 _type <span class="token operator">*</span>_type
 hash  <span class="token builtin">uint32</span>
 <span class="token boolean">_</span>     <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
 fun   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token builtin">uintptr</span> <span class="token comment">// 变长数组. fun[0]==0 意味着 _type 没有实现 inter 这个接口</span>
<span class="token punctuation">}</span>

<span class="token comment">// 接口类型</span>
<span class="token comment">// 对应源代码：type xx interface {}</span>
<span class="token keyword">type</span> interfacetype <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    typ     _type     <span class="token comment">// 类型信息</span>
    pkgpath name      <span class="token comment">// 包路径</span>
    mhdr    <span class="token punctuation">[</span><span class="token punctuation">]</span>imethod <span class="token comment">// 接口的方法列表</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>根据 <code>interfacetype</code> 我们可以得到关于接口所有方法的信息。同样的，通过<code>_type</code>也可以获取结构体类型的所有方法信息。</p> 
<p>从定义上，我们可以看到<code> itab</code> 跟 <code>*interfacetype</code> 和 <code>*_type</code> 有关，但实际上有什么关系，从定义上其实不太能看得出来， 但是我们可以看它是怎么被使用的，现在，假设我们有如下代码：</p> 
<pre><code class="prism language-go"><span class="token comment">// i 在底层是一个 interfacetype 类型</span>
<span class="token keyword">type</span> i <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
 <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// t 底层会用 _type 来表示</span>
<span class="token comment">// t 里面有 A、B、C、D 方法</span>
<span class="token comment">// 因为实现了 i 中的所有方法，所以 t 实现了接口 i</span>
<span class="token keyword">type</span> t <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>下图描述了上面代码对应的 <code>itab</code> 生成的过程：</p> 
<p><code>i </code>为接口类型，<code>t</code>为结构体类型，将<code>t</code>的实例对象赋值给<code>i</code>接口类型后，<code>itab</code>组成如下，其中<code>inter</code>字段包含<code>i</code>接口类型的信息，<code>_type</code>字段包含<code>t</code>结构体类型信息，<code>fun</code>字段包含<code>i</code>和<code>t</code>拥有的方法的<code>交集</code>，因为<code>t</code>赋值给<code>i</code>接口类型后，只能调用<code>i</code>接口类型拥有的方法。<br> <img src="https://images2.imgbox.com/d9/1d/dnNN3sjr_o.png" alt="在这里插入图片描述"></p> 
<p><strong>说明：</strong></p> 
<ul><li> <p><code>itab</code> 里面的 <code>inter</code> 是接口类型的指针（比如通过<code>type Reader interface{}</code>这种形式定义的接口，记录的是这个类型本身的信息），这个接口类型本身定义了一系列的方法，如图中的<code>i</code>包含了 <code>A、C </code>两个方法。</p> </li><li> <p><code>_type</code> 是实际类型的指针，记录的是这个实际类型本身的信息，比如这个类型包含哪些方法。图中的<code>i</code>实现了<code> A、B、C、D</code> 四个方法，因为实现了 <code>i </code>的所有方法，所以说<code>t</code>实现了<code>i</code>接口。</p> </li><li> <p>在底层做类型转换的时候，比如<code>t</code>转换为<code>i</code>的时候（<code>var v i = t{}</code>），会生成一个 <code>itab</code></p> 
  <ul><li>如果<code> t</code> 没有实现 <code>i </code>中的所有方法，那么生成的 <code>itab </code>中不包含任何方法。</li><li>如果<code>t</code>实现了<code>i</code>中的所有方法，那么生成的<code>itab</code>中包含了<code>i</code>中的所有方法指针，但是实际指向的方法是实际类型的方法（也就是指向的是<code>t</code>中的方法地址）</li></ul> </li><li> <p><code>mhdr</code> (<code>interfacetype</code>结构体中的一个字段）就是<code> itab</code> 中的方法表，里面的方法名就是接口的所有方法名，这个方法表中保存了实际类型<code>（t）</code>中同名方法的函数地址，通过这个地址就可以调用实际类型的方法了。</p> </li></ul> 
<p><strong>所以，我们有如下结论：</strong></p> 
<ul><li><code>itab</code> 实际上定义了 <code>interfacetype</code> 和 <code>_type</code> 之间方法的交集。作用是什么呢？就是用来判断一个结构体是否实现某个接口的。</li><li><code>itab</code> 包含了接口的所有方法，这里面的方法是实际类型的子集。</li><li><code>itab</code> 里面的方法列表包含了实际类型的方法指针（也就是实际类型的方法的地址），通过这个地址可以对实际类型进行方法的调用。</li><li><code>itab</code> 在实际类型没有实现接口的所有方法的时候，生成失败（失败的意思是，生成的 <code>itab</code> 里面的方法列表是空的，在底层实现上是用 <code>fun[0] = 0</code> 来表示）。</li></ul> 
<p>一个 <code>interface{}</code> 中实际上既包含了变量的类型信息，也包含了类型的数据。而<code>reflect.TypeOf </code>和<code> reflect.ValueOf</code>函数都会先将实参转为<code>interface{}</code>，正因为如此，我们才可以通过反射来获取到变量的类型信息，以及变量的数据信息。</p> 
<h2><a id="__reflectType__reflectValue_155"></a>反射对象 - reflect.Type 和 reflect.Value</h2> 
<p>知道了 <code>interface{}</code> 的内存结构之后，我们就可以开始讲解反射了。反射的核心是两个对象，分别是 <code>reflect.Type接口</code> 和 <code>reflect.Value结构体</code>。 它们分别代表了 <code>go</code> 语言中的类型和值。我们可以通过 <code>reflect.TypeOf </code>和<code>reflect.ValueOf</code>来获取到一个变量的类型和值。</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
t <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">"hello"</span>
t1 <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
</code></pre> 
<p>我们去看一下 <code>TypeOf </code>和 <code>ValueOf </code>的源码会发现，这两个方法都接收一个 <code>interface{} </code>类型的参数，然后返回一个<code>reflect.Type</code>和 <code>reflect.Value </code>类型的值。这也就是为什么我们可以通过<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>来获取到一个变量的类型和值的原因。</p> 
<h3><a id="_168"></a>反射三大定律</h3> 
<p>在<code>go</code>官方博客中关于反射的文章<code> laws-of-reflection</code> 中，提到了三条反射定律：</p> 
<ul><li>反射可以将 <code>interface</code> 类型变量转换成反射对象。通常使用通过<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>实现。</li><li>反射可以将反射对象还原成<code> interface</code> 对象。通常使用<code>reflect.Value.Interface()</code>实现。</li><li>如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</li><li></ul> 
<p>关于这三条定律，官方博客已经有了比较完整的阐述，感兴趣的可以去看一下官方博客的文章。这里简单阐述一下：</p> 
<p><strong>反射可以将 interface 类型变量转换成反射对象。</strong><br> 其实也就是上面的 <code>reflect.Type</code> 和 <code>reflect.Value</code>，我们可以通过 <code>reflect.TypeOf </code>和 <code>reflect.ValueOf </code>来获取到一个变量的反射类型和反射值。</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
typeOfA <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
valueOfA <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
</code></pre> 
<p><strong>反射可以将反射对象还原成 interface 对象。</strong><br> 我们可以通过 <code>reflect.Value.Interface </code>来获取到反射对象的<code>interface</code>对象，也就是传递给 <code>reflect.ValueOf </code>的那个变量本身。 不过返回值类型是 <code>interface{}</code>，所以我们需要进行类型断言。</p> 
<pre><code class="prism language-go">i <span class="token operator">:=</span> valueOfA<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>如果要修改反射对象，那么反射对象必须是可设置的（CanSet）。</strong><br> 我们可以通过 <code>reflect.Value.CanSet</code> 来判断一个反射对象是否是可设置的。如果是可设置的，我们就可以通过 <code>reflect.Value.Set</code> 来修改反射对象的值。 这其实也是非常常见的使用反射的一个场景，通过反射来修改变量的值。</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> x <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">3.4</span>
v <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"settability of v:"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">CanSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"settability of v:"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CanSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre> 
<p>那什么情况下一个反射对象是可设置的呢？前提是这个反射对象是一个指针，然后这个指针指向的是一个可设置的变量。 在我们传递一个值给<code>reflect.ValueOf</code>的时候，如果这个值只是一个普通的变量，那么<code>reflect.ValueOf</code>会返回一个不可设置的反射对象。 因为这个值实际上被拷贝了一份，我们如果通过反射修改这个值，那么实际上是修改的这个拷贝的值，而不是原来的值。 所以<code>go</code>语言在这里做了一个限制，如果我们传递进<code>reflect.ValueOf</code>的变量是一个普通的变量，那么在我们设置反射对象的值的时候，会报错。 所以在上面这个例子中，我们传递了 <code>x </code>的指针变量作为参数。这样，运行时就可以找到 <code>x</code> 本身，而不是<code>x</code>的拷贝，所以就可以修改 <code>x </code>的值了。</p> 
<p>但同时我们也注意到了，在上面这个例子中，<code>v.CanSet()</code> 返回的是 <code>false</code>，而 <code>v.Elem().CanSet() </code>返回的是<code> true</code>。 这是因为，<code>v </code>是一个指针，而<code>v.Elem()</code>是指针指向的值，对于这个指针本身，我们修改它是没有意义的，我们可以设想一下， 如果我们修改了指针变量（也就是修改了指针变量指向的地址），那会发生什么呢？那样我们的指针变量就不是指向<code>x</code>了， 而是指向了其他的变量，这样就不符合我们的预期了。所以 <code>v.CanSet() </code>返回的是<code> false</code>。</p> 
<p>而 <code>v.Elem().CanSet()</code> 返回的是 <code>true</code>。这是因为 <code>v.Elem() </code>才是 <code>x</code> 本身，通过 <code>v.Elem() </code>修改 <code>x</code> 的值是没有问题的。<br> <img src="https://images2.imgbox.com/6c/fa/imit7mwC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Elem__212"></a>Elem 方法</h3> 
<p><code>Elem</code> 方法的作用是什么呢？在回答这个问题之前，我们需要明确一点：<code>reflect.Value 和 reflect.Type 这两个反射对象都有 Elem 方法，既然是不同的对象，那么它们的作用自然是不一样的。</code></p> 
<h4><a id="reflectValue__Elem__215"></a>reflect.Value 的 Elem 方法</h4> 
<p><code>reflect.Value</code> 的 <code>Elem</code> 方法的作用是获取指针指向的值，或者获取接口的动态值。也就是说，能调用 <code>Elem</code> 方法的反射对象，必须是一个指针或者一个接口。 在使用其他类型的 <code>reflect.Value</code> 来调用 <code>Elem</code> 方法的时候，会 <code>panic</code>:</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// panic: reflect: call of reflect.Value.Elem on int Value</span>
reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 不报错</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>a
reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>对于指针很好理解，其实作用类似解引用。而对于接口，还是要回到 <code>interface</code> 的结构本身，因为接口里包含了类型和数据本身，所以 <code>Elem</code> 方法就是获取接口的数据部分（也就是 <code>iface</code> 或 <code>eface</code> 中的 <code>data</code> 字段）。</p> 
<p>指针类型：</p> 
<p><img src="https://images2.imgbox.com/13/d2/odXTT7nz_o.png" alt="在这里插入图片描述"></p> 
<p>接口类型：</p> 
<p><img src="https://images2.imgbox.com/6c/8e/E5fROn6V_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="reflectType__Elem__240"></a>reflect.Type 的 Elem 方法</h4> 
<p><code>reflect.Type</code> 的 <code>Elem</code> 方法的作用是获取<code>数组、chan、map、指针、切片</code>关联元素的类型信息，也就是说，对于<code>reflect.Type</code>来说， 能调用<code>Elem</code>方法的反射对象，必须是数组、<code>chan</code>、<code>map</code>、指针、切片中的一种，其他类型的 <code>reflect.Type</code> 调用 <code>Elem</code> 方法会 <code>panic</code>。</p> 
<p>示例：</p> 
<pre><code class="prism language-go">t1 <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 数组 [3]int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [3]int</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// int</span>
</code></pre> 
<p>需要注意的是，如果我们要获取 <code>map</code> 类型<code>key</code>的类型信息，需要使用 <code>Key</code> 方法，而不是 <code>Elem</code> 方法。</p> 
<pre><code class="prism language-go">m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
t1 <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// string</span>
</code></pre> 
<h3><a id="Interface__259"></a>Interface 方法</h3> 
<p>这也是非常常用的一个方法，<code>reflect.Value</code> 的 <code>Interface</code> 方法的作用是获取反射对象的动态值。 也就是说，如果反射对象是一个指针，那么 <code>Interface</code> 方法会返回指针指向的值。</p> 
<p>简单来说，如果 <code>var i interface{} = x</code>，那么 <code>reflect.ValueOf(x).Interface()</code> 就是<code> i</code> 本身，只不过其类型是 <code>interface{} </code>类型。</p> 
<h3><a id="Kind_264"></a>Kind</h3> 
<p>说到反射，不得不提的另外一个话题就是 <code>go</code> 的类型系统，对于开发者来说，我们可以基于基本类型来定义各种新的类型，如：</p> 
<pre><code class="prism language-go"><span class="token comment">// Kind 是 int</span>
<span class="token keyword">type</span> myIny <span class="token builtin">int</span>
<span class="token comment">// Kind 是 Struct</span>
<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
    Name <span class="token builtin">string</span>
    Age <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是不管我们定义了多少种类型，在 <code>go</code> 看来都是下面的基本类型中的一个：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> Kind <span class="token builtin">uint</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
 Invalid Kind <span class="token operator">=</span> <span class="token boolean">iota</span>
 Bool
 Int
 Int8
 Int16
 Int32
 Int64
 Uint
 Uint8
 Uint16
 Uint32
 Uint64
 Uintptr
 Float32
 Float64
 Complex64
 Complex128
 Array
 Chan
 Func
 Interface
 Map
 Pointer
 Slice
 String
 Struct
 UnsafePointer
<span class="token punctuation">)</span>
</code></pre> 
<p>也就是说，我们定义的类型在 <code>go</code> 的类型系统中都是基本类型的一种，这个基本类型就是 <code>Kind</code>。 也正因为如此，我们可以通过有限的 <code>reflect.Type</code> 的 <code>Kind</code> 来进行类型判断。 也就是说，我们在通过反射来判断变量的类型的时候，只需要枚举 <code>Kind</code> 中的类型，然后通过 <code>reflect.Type</code> 的 <code>Kind</code> 方法来判断即可。</p> 
<p><code>Type</code> 表示的是反射对象的类型（<code>Type</code> 对象是某一个 <code>Kind</code>，通过 <code>Kind()</code> 方法可以获取 <code>Type</code> 的 <code>Kind</code>，基本类型的种类），<code>Kind</code> 表示的是 <code>go</code> 底层类型系统中的类型。</p> 
<p>比如下面的例子：</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">display</span><span class="token punctuation">(</span>path <span class="token builtin">string</span><span class="token punctuation">,</span> v reflect<span class="token punctuation">.</span>Value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">switch</span> v<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Invalid<span class="token punctuation">:</span>
  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s = invalid\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
 <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Slice<span class="token punctuation">,</span> reflect<span class="token punctuation">.</span>Array<span class="token punctuation">:</span>
  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
   <span class="token function">display</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s[%d]"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Struct<span class="token punctuation">:</span>
  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
   fieldPath <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s.%s"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
   <span class="token function">display</span><span class="token punctuation">(</span>fieldPath<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Map<span class="token punctuation">:</span>
  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> v<span class="token punctuation">.</span><span class="token function">MapKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token function">display</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s[%s]"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token function">formatAny</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">MapIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Pointer<span class="token punctuation">:</span>
  <span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">IsNil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s = nil\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
   <span class="token function">display</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"(*%s)"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">case</span> reflect<span class="token punctuation">.</span>Interface<span class="token punctuation">:</span>
  <span class="token keyword">if</span> v<span class="token punctuation">.</span><span class="token function">IsNil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s = nil\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
   fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s.type = %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token function">display</span><span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token string">".value"</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">default</span><span class="token punctuation">:</span>
  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s = %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> <span class="token function">formatAny</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们在开发的时候非常常用的结构体，在<code>go</code>的类型系统中，通通都是<code>Struct</code>这个种类的。</p> 
<h3><a id="addressable_358"></a>addressable</h3> 
<p><code>go </code>反射中最后一个很重要的话题是 <code>addressable</code>。在 <code>go</code> 的反射系统中有两个关于寻址的方法：<code>CanAddr</code> 和 <code>CanSet</code>。</p> 
<p><code>CanAddr </code>方法的作用是判断反射对象是否可以寻址，也就是说，如果 <code>CanAddr </code>返回 <code>true</code>，那么我们就可以通过 <code>Addr </code>方法来获取反射对象的地址。 如果<code> CanAddr</code> 返回 <code>false</code>，那么我们就不能通过<code>Addr</code>方法来获取反射对象的地址。对于这种情况，我们就无法通过反射对象来修改变量的值。</p> 
<p>但是，<code>CanAddr</code> 是<code>true</code>并不是说<code> reflect.Value</code> 一定就能修改变量的值了。<code>reflect.Value </code>还有一个方法<code> CanSet</code>，只有 <code>CanSet </code>返回<code> true</code>，我们才能通过反射对象来修改变量的值。</p> 
<p>那么<code>CanAddr</code>背后的含义是什么呢？它意味着我们传递给 <code>reflect.ValueOf </code>的变量是不是可以寻址的。也就是说，我们的反射值对象拿到的是不是变量本身，而不是变量的副本。如果我们是通过 <code>&amp;v</code> 这种方式来创建反射对象的，那么<code> CanAddr</code> 就会返回 <code>true</code>， 反之，如果我们是通过<code> v</code> 这种方式来创建反射对象的，那么<code> CanAddr</code> 就会返回 <code>false</code>。</p> 
<h2><a id="__reflectType_367"></a>获取类型信息 - reflect.Type</h2> 
<p><code>reflect.Type </code>是一个接口，它代表了一个类型。我们可以通过 <code>reflect.TypeOf </code>来获取一个类型的<code>reflect.Type</code>对象。 <code>我们使用 reflect.Type 的目的通常是为了获取类型的信息，比如类型是什么、类型的名称、类型的字段、类型的方法等等</code>。 又或者最常见的场景：结构体中的 <code>json</code> 的 <code>tag</code>，它是没有语义的，它的作用就是为了在序列化的时候，生成我们想要的字段名。 而这个<code> tag</code> 就是需要通过反射来获取的。</p> 
<h3><a id="_Type__371"></a>通用的 Type 方法</h3> 
<p>在 <code>go</code> 的反射系统中，是使用<code>reflect.Type</code>这个接口来获取类型信息的。<code>reflect.Type </code>这个接口有很多方法，下面这些方法是所有的类型通用的方法：</p> 
<pre><code class="prism language-go"><span class="token comment">// Type 是 Go 类型的表示。</span>
<span class="token comment">//</span>
<span class="token comment">// 并非所有方法都适用于所有类型。</span>
<span class="token comment">// 在调用 kind 具体方法之前，先使用 Kind 方法找出类型的种类。因为调用一个方法如果类型不匹配会导致 panic</span>
<span class="token comment">//</span>
<span class="token comment">// Type 类型值是可以比较的，比如用 == 操作符。所以它可以用做 map 的 key</span>
<span class="token comment">// 如果两个 Type 值代表相同的类型，那么它们一定是相等的。</span>
<span class="token keyword">type</span> Type <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
 <span class="token comment">// Align 返回该类型在内存中分配时，以字节数为单位的字节数</span>
 <span class="token function">Align</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
 
 <span class="token comment">// FieldAlign 返回该类型在结构中作为字段使用时，以字节数为单位的字节数</span>
 <span class="token function">FieldAlign</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
 
 <span class="token comment">// Method 这个方法返回类型方法集中的第 i 个方法。</span>
 <span class="token comment">// 如果 i 不在[0, NumMethod()]范围内，就会 panic。</span>
 <span class="token comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span>
 <span class="token comment">// 其第一个参数是接收者，并且只能访问导出的方法。</span>
 <span class="token comment">// 对于一个接口类型，返回的 Method 的 Type 字段给出的是方法签名，没有接收者，Func字段为nil。</span>
 <span class="token comment">// 方法是按字典序顺序排列的。</span>
 <span class="token function">Method</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> Method

 <span class="token comment">// MethodByName 返回类型的方法集中具有该名称的方法和一个指示是否找到该方法的布尔值。</span>
 <span class="token comment">// 对于非接口类型 T 或 *T，返回的 Method 的 Type 和 Func 字段描述了一个函数，</span>
 <span class="token comment">// 其第一个参数是接收者。</span>
 <span class="token comment">// 对于一个接口类型，返回的 Method 的 Type 字段给出的是方法签名，没有接收者，Func字段为nil。</span>
 <span class="token function">MethodByName</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Method<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>

 <span class="token comment">// NumMethod 返回使用 Method 可以访问的方法数量。</span>
 <span class="token comment">// 对于非接口类型，它返回导出方法的数量。</span>
 <span class="token comment">// 对于接口类型，它返回导出和未导出方法的数量。</span>
 <span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

 <span class="token comment">// Name 返回定义类型在其包中的类型名称。</span>
 <span class="token comment">// 对于其他（未定义的）类型，它返回空字符串。</span>
 <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

 <span class="token comment">// PkgPath 返回一个定义类型的包的路径，也就是导入路径，导入路径是唯一标识包的类型，如 "encoding/base64"。</span>
 <span class="token comment">// 如果类型是预先声明的(string, error)或者没有定义(*T, struct{}, []int，或 A，其中 A 是一个非定义类型的别名），包的路径将是空字符串。</span>
 <span class="token function">PkgPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

 <span class="token comment">// Size 返回存储给定类型的值所需的字节数。它类似于 unsafe.Sizeof.</span>
 <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uintptr</span>

 <span class="token comment">// String 返回该类型的字符串表示。</span>
 <span class="token comment">// 字符串表示法可以使用缩短的包名。</span>
 <span class="token comment">// (例如，使用 base64 而不是 "encoding/base64")并且它并不能保证类型之间是唯一的。如果是为了测试类型标识，应该直接比较类型 Type。</span>
 <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>

 <span class="token comment">// Kind 返回该类型的具体种类。</span>
 <span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Kind

 <span class="token comment">// Implements 表示该类型是否实现了接口类型 u。</span>
 <span class="token function">Implements</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span>

 <span class="token comment">// AssignableTo 表示该类型的值是否可以分配给类型 u。</span>
 <span class="token function">AssignableTo</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span>

 <span class="token comment">// ConvertibleTo 表示该类型的值是否可转换为 u 类型。</span>
 <span class="token function">ConvertibleTo</span><span class="token punctuation">(</span>u Type<span class="token punctuation">)</span> <span class="token builtin">bool</span>

 <span class="token comment">// Comparable 表示该类型的值是否具有可比性。</span>
 <span class="token function">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="_Type__442"></a>某些类型特定的 Type 方法</h3> 
<p>下面是某些类型特定的方法，对于这些方法，如果我们使用的类型不对，则会 <code>panic</code>：</p> 
<pre><code class="prism language-go"><span class="token keyword">type</span> Type <span class="token keyword">interface</span> <span class="token punctuation">{<!-- --></span>
 <span class="token comment">// Bits 以 bits 为单位返回类型的大小。</span>
 <span class="token comment">// 如果类型的 Kind 不属于：sized 或者 unsized Int, Uint, Float, 或者 Complex，会 panic。</span>
 <span class="token function">Bits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

 <span class="token comment">// ChanDir 返回一个通道类型的方向。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Chan，会 panic。</span>
 <span class="token function">ChanDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ChanDir

 <span class="token comment">// IsVariadic 表示一个函数类型的最终输入参数是否为一个 "..." 可变参数。如果是，t.In(t.NumIn() - 1) 返回参数的隐式实际类型 []T.</span>
 <span class="token comment">// 更具体的，如果 t 代表 func(x int, y ... float64)，那么：</span>
 <span class="token comment">// t.NumIn() == 2</span>
 <span class="token comment">// t.In(0)是 "int" 的 reflect.Type 反射类型。</span>
 <span class="token comment">// t.In(1)是 "[]float64" 的 reflect.Type 反射类型。</span>
 <span class="token comment">// t.IsVariadic() == true</span>
 <span class="token comment">// 如果类型的 Kind 不是 Func，IsVariadic 会 panic</span>
 <span class="token function">IsVariadic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>

 <span class="token comment">// Elem 返回一个 type 的元素类型。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Array、Chan、Map、Ptr 或 Slice，就会 panic</span>
 <span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Type

 <span class="token comment">// Field 返回一个结构类型的第 i 个字段。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Struct，就会 panic。</span>
 <span class="token comment">// 如果 i 不在 [0, NumField()) 范围内也会 panic。</span>
 <span class="token function">Field</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> StructField

 <span class="token comment">// FieldByIndex 返回索引序列对应的嵌套字段。它相当于对每一个 index 调用 Field。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Struct，就会 panic。</span>
 <span class="token function">FieldByIndex</span><span class="token punctuation">(</span>index <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> StructField

 <span class="token comment">// FieldByName 返回给定名称的结构字段和一个表示是否找到该字段的布尔值。</span>
 <span class="token function">FieldByName</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>StructField<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>

 <span class="token comment">// FieldByNameFunc 返回一个能满足 match 函数的带有名称的 field 字段。布尔值表示是否找到。</span>
 <span class="token function">FieldByNameFunc</span><span class="token punctuation">(</span>match <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>StructField<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>

 <span class="token comment">// In 返回函数类型的第 i 个输入参数的类型。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Func 类型会 panic。</span>
 <span class="token comment">// 如果 i 不在 [0, NumIn()) 的范围内，会 panic。</span>
 <span class="token function">In</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> Type

 <span class="token comment">// Key 返回一个 map 类型的 key 类型。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Map，会 panic。</span>
 <span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Type

 <span class="token comment">// Len 返回一个数组类型的长度。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Array，会 panic。</span>
 <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

 <span class="token comment">// NumField 返回一个结构类型的字段数目。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Struct，会 panic。</span>
 <span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

 <span class="token comment">// NumIn 返回一个函数类型的输入参数数。</span>
 <span class="token comment">// 如果类型的 Kind 不是Func.NumIn()，会 panic。</span>
 <span class="token function">NumIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

 <span class="token comment">// NumOut 返回一个函数类型的输出参数数。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Func.NumOut()，会 panic。</span>
 <span class="token function">NumOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

 <span class="token comment">// Out 返回一个函数类型的第 i 个输出参数的类型。</span>
 <span class="token comment">// 如果类型的 Kind 不是 Func，会 panic。</span>
 <span class="token comment">// 如果 i 不在 [0, NumOut()) 的范围内，会 panic。</span>
 <span class="token function">Out</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> Type
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_reflectType__515"></a>创建 reflect.Type 的方式</h3> 
<p>我们可以通过下面的方式来获取变量的类型信息，即以下方法的返回类型都是<code>reflect.Type</code>：</p> 
<p><img src="https://images2.imgbox.com/79/8c/QvrLh8x0_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="__reflectValue_521"></a>获取值信息 - reflect.Value</h2> 
<p><code>reflect.Value</code> 是一个结构体，它代表了一个值。 我们使用 <code>reflect.Value </code>可以实现一些接收多种类型参数的函数，又或者可以让我们在运行时针对值的一些信息来进行修改。 常常用在接收<code>interface{}</code>类型参数的方法中，因为参数是接口类型，所以我们可以通过 <code>reflect.ValueOf </code>来获取到参数的值信息。 <code>值信息不仅包含具体的数据，还包含类型、大小、结构体字段、方法等等。</code></p> 
<p>同时，我们可以对这些获取到的反射值进行修改。这也是反射的一个重要用途。</p> 
<h3><a id="reflectValue__527"></a>reflect.Value 的方法</h3> 
<p><code>reflect.Value</code> 这个<code>Struct</code>同样有很多方法：具体可以分为以下几类：</p> 
<ul><li>设置值的方法：<code>Set*：Set、SetBool、SetBytes、SetCap、SetComplex、SetFloat、SetInt、SetLen、SetMapIndex、SetPointer、SetString、SetUint</code>。通过这类方法，我们可以修改反射值的内容，前提是这个反射值得是合适的类型。<code>CanSet</code> 返回<code>true</code>才能调用这类方法</li><li>获取值的方法：<code>Interface、InterfaceData、Bool、Bytes、Complex、Float、Int、String、Uint</code>。通过这类方法，我们可以获取反射值的内容。前提是这个反射值是合适的类型，比如我们不能通过 <code>complex</code> 反射值来调用 <code>Int </code>方法（我们可以通过<code>Kind</code>来判断类型）。</li><li><code>map</code> 类型的方法：<code>MapIndex、MapKeys、MapRange、MapSet</code>。</li><li><code>chan</code> 类型的方法：<code>Close、Recv、Send、TryRecv、TrySend</code>。</li><li><code>slice</code> 类型的方法：<code>Len、Cap、Index、Slice、Slice3</code>。</li><li><code>struct</code> 类型的方法：<code>NumField、NumMethod、Field、FieldByIndex、FieldByName、FieldByNameFunc</code>。<strong>reflect.Type也基本有这些方法。</strong></li><li>判断是否可以设置为某一类型：·CanConvert、CanComplex、CanFloat、CanInt、CanInterface、CanUint·。</li><li>方法类型的方法：<code>Method、MethodByName、Call、CallSlice</code>。</li><li>判断值是否有效：<code>IsValid</code>。</li><li>判断值是否是 <code>nil</code>：<code>IsNil</code>。</li><li>判断值是否是零值：<code>IsZero</code>。</li><li>判断值能否容纳下某一类型的值：<code>Overflow、OverflowComplex、OverflowFloat、OverflowInt、OverflowUint</code>。</li><li>反射值指针相关的方法：<code>Addr</code>（<code>CanAddr </code>为 <code>true</code> 才能调用）、<code>UnsafeAddr、Pointer、UnsafePointer</code>。</li><li>获取类型信息：<code>Type、Kind</code>。<strong>注：<code>reflect.Value</code>有<code>Type</code>方法可以获取到<code>reflect.Type</code>类型，包含结构体字段类型信息，但是该方式获取到的类型信息没有<code>reflect.StructField</code>的，比如<code>reflect.StructField</code>有<code>Tag</code>方法获取<code>tag</code>信息，<code>reflect.Type</code>则没有Tag()方法，所以在遍历结构体的字段类型和值时,尤其是需要<code>Tag</code>信息时，一般是如下模式</strong></li></ul> 
<pre><code class="prism language-go"> val <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token comment">// v是结构体</span>
 typ <span class="token operator">:=</span> val<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 等价 reflect.TypeOf(v)</span>

 <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> val<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 也可以换成typ.Numfield()</span>
     <span class="token comment">// 获取到字段对应的Value，即使再使用fieldVal.Type方法获取到字段对应的reflect.Type</span>
     <span class="token comment">//也只能拿到字段名、类型，路径等信息，不包含Tag信息,因为Tag信息是结构体特有的</span>
 	 fieldVal <span class="token operator">:=</span> val<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
 	 <span class="token comment">// 返回reflect.StructField类型，包含字段的类型信息，如字段名、Tag，类型，路径，是否匿名等</span>
     fieldType <span class="token operator">:=</span> typ<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
     <span class="token comment">//进行相应的后续处理</span>
     <span class="token comment">//如 xxxTag := fieldType.Tag.Get("xxx")</span>
 <span class="token punctuation">}</span>
</code></pre> 
<ul><li>获取指向元素的值：<code>Elem</code>。</li><li>类型转换：<code>Convert</code>。</li><li><code>Len </code>也适用于 <code>slice、array、chan、map、string </code>类型的反射值。</li></ul> 
<h3><a id="_reflectValue__564"></a>创建 reflect.Value 的方式</h3> 
<p>我们可以通过下面的方式来获取变量的值信息，即以下方法的返回类型都是<code>reflect.Value</code>：：</p> 
<p><img src="https://images2.imgbox.com/2f/af/YIcu0Xd0_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_570"></a>总结</h2> 
<ul><li><code>reflect </code>包提供了反射机制，可以在运行时获取变量的类型信息、值信息、方法信息等等。</li><li><code>go</code> 中的<code>interface{}</code>实际上包含了两个指针，一个指向类型信息，一个指向值信息。正因如此，我们可以在运行时通过<code> interface{}</code> 来获取变量的类型信息、值信息。</li><li><code>reflect.Type</code> 代表一个类型，<code>reflect.Value</code> 代表一个值。通过<code>reflect.Type</code>可以获取类型信息，通过<code> reflect.Value</code> 可以获取值信息。</li><li>反射三定律： 
  <ul><li>反射可以将<code> interface</code> 类型变量转换成反射对象。</li><li>反射可以将反射对象还原成 <code>interface </code>对象。</li><li>如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</li></ul> </li><li><code>reflect.Value</code> 和<code> reflect.Type</code> 里面都有 <code>Elem</code> 方法，但是它们的作用不一样：</li><li><code>reflect.Type</code> 的<code>Elem</code>方法返回的是元素类型，只适用于 <code>array、chan、map、pointer </code>和 <code>slice </code>类型的<code> reflect.Type</code>。</li><li><code>reflect.Value</code> 的 <code>Elem </code>方法返回的是值，只适用于接口或指针类型的 <code>reflect.Value</code>。</li><li>通过 <code>reflect.Value</code> 的<code> Interface</code> 方法可以获取到反射对象的原始变量，但是是 <code>interface{} </code>类型的。</li><li><code>Type</code> 和<code> Kind</code> 都表示类型，但是<code>Type</code>是类型的反射对象，<code>Kind </code>是 <code>go </code>类型系统中最基本的一些类型，比如<code>int、string、struct</code>等等。</li><li>如果我们想通过<code>reflect.Value</code>来修改变量的值，那么<code>reflect.Value</code>必须是可设置的（<code>CanSet</code>）。同时如果想要 <code>CanSet </code>为<code> true</code>，那么我们的变量必须是可寻址的。</li><li>我们有很多方法可以创建 <code>reflect.Type</code> 和 <code>reflect.Value</code>，我们需要根据具体的场景来选择合适的方法。</li><li><code>reflect.Type </code>和<code>reflect.Value</code>里面，都有一部分方法是通用的，也有一部分只适用于特定的类型。如果我们想要调用那些适用于特定类型的方法，那么我们必须先判断 <code>reflect.Type</code> 或 <code>reflect.Value</code> 的类型（这里说的是 <code>Kind</code>），然后再调用。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/52f6fc8bed59dedf57b3c88b173b66ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#实现代理服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cad3718c0e2759e01216e295edcfe29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java入门基础16：集合框架1（Collection集合体系、List、Set）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>