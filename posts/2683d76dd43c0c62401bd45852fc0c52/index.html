<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>探索算法系列 - 双指针 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2683d76dd43c0c62401bd45852fc0c52/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="探索算法系列 - 双指针">
  <meta property="og:description" content="目录
移动零（原题链接）
复写零（原题链接）
快乐数（原题链接）
盛最多水的容器（原题链接）
有效三角形的个数（原题链接）
查找总价格为目标值的两个商品（原题链接）
三数之和（原题链接）
四数之和（原题链接）
移动零（原题链接） 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
解题思路
定义两个指针 cur 和 dest。cur 用于遍历整个数组。dest 指向下一个非零元素应该放置的位置。初始化 dest 为 -1，这是因为我们需要在第一次找到非零元素时将其值赋给 dest 并且增加 dest 的值。 步骤说明
初始化：
cur 从0开始。dest 从-1开始（表示还没有遇到非零元素）。 遍历数组：
使用循环遍历整个数组 nums。对于数组中的每一个元素 nums[cur]，检查它是否是非零元素。 如果 nums[cur] 不为0，则执行以下操作： 将 dest 加1。交换 nums[dest] 和 nums[cur] 的值。 结束条件：
当 cur 遍历完整个数组后，循环结束。 结果：
所有的非零元素都已经被移动到了数组的前半部分，并保持了原有的顺序。所有的0元素都被移动到了数组的后半部分。 具体代码
class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { for (int cur = 0, dest = -1; cur &lt; nums.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T16:21:15+08:00">
    <meta property="article:modified_time" content="2024-07-25T16:21:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">探索算法系列 - 双指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%89" rel="nofollow">移动零（原题链接）</a></p> 
<p id="%E5%A4%8D%E5%86%99%E9%9B%B6-toc" style="margin-left:0px;"><a href="#%E5%A4%8D%E5%86%99%E9%9B%B6" rel="nofollow">复写零（原题链接）</a></p> 
<p id="%E5%BF%AB%E4%B9%90%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%BF%AB%E4%B9%90%E6%95%B0" rel="nofollow">快乐数（原题链接）</a></p> 
<p id="%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8" rel="nofollow">盛最多水的容器（原题链接）</a></p> 
<p id="%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow">有效三角形的个数（原题链接）</a></p> 
<p id="%E6%9F%A5%E6%89%BE%E6%80%BB%E4%BB%B7%E6%A0%BC%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%95%86%E5%93%81-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E6%89%BE%E6%80%BB%E4%BB%B7%E6%A0%BC%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%95%86%E5%93%81" rel="nofollow">查找总价格为目标值的两个商品（原题链接）</a></p> 
<p id="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">三数之和（原题链接）</a></p> 
<p id="%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C" rel="nofollow">四数之和（原题链接）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/8b/27/3tJoJlQM_o.png" width="762"></p> 
<h2 id="%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E5%8E%9F%E9%A2%98%E9%93%BE%E6%8E%A5%EF%BC%89">移动零<a class="link-info" href="https://leetcode.cn/problems/move-zeroes/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p> 
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/a3/25/eWdmopBe_o.png" width="890"></p> 
<blockquote> 
 <p><strong>解题思路</strong></p> 
 <ul><li>定义两个指针 <code>cur</code> 和 <code>dest</code>。</li><li><code>cur</code> 用于遍历整个数组。</li><li><code>dest</code> 指向下一个非零元素应该放置的位置。</li><li>初始化 <code>dest</code> 为 <code>-1</code>，这是因为我们需要在第一次找到非零元素时将其值赋给 <code>dest</code> 并且增加 <code>dest</code> 的值。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li> <p><strong>初始化</strong>：</p> 
   <ul><li><code>cur</code> 从0开始。</li><li><code>dest</code> 从-1开始（表示还没有遇到非零元素）。</li></ul></li><li> <p><strong>遍历数组</strong>：</p> 
   <ul><li>使用循环遍历整个数组 <code>nums</code>。</li><li>对于数组中的每一个元素 <code>nums[cur]</code>，检查它是否是非零元素。 
     <ul><li>如果 <code>nums[cur]</code> 不为0，则执行以下操作： 
       <ul><li>将 <code>dest</code> 加1。</li><li>交换 <code>nums[dest]</code> 和 <code>nums[cur]</code> 的值。</li></ul></li></ul></li></ul></li><li> <p><strong>结束条件</strong>：</p> 
   <ul><li>当 <code>cur</code> 遍历完整个数组后，循环结束。</li></ul></li><li> <p><strong>结果</strong>：</p> 
   <ul><li>所有的非零元素都已经被移动到了数组的前半部分，并保持了原有的顺序。</li><li>所有的0元素都被移动到了数组的后半部分。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>具体代码</strong></p> 
 <pre><code>class Solution 
{
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums)
    {
        for (int cur = 0, dest = -1; cur &lt; nums.size(); cur++)
        {
            if (nums[cur])
            {
                swap(nums[++dest], nums[cur]);
            }
        }
    }
};</code></pre> 
</blockquote> 
<h2 id="%E5%A4%8D%E5%86%99%E9%9B%B6">复写零<a class="link-info" href="https://leetcode.cn/problems/duplicate-zeros/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>给你一个长度固定的整数数组 <code>arr</code> ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p> 
<p>注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 <strong>就地 </strong>进行上述修改，不要从函数返回任何东西。</p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/cb/81/nLUdozkC_o.png" width="899"></p> 
<blockquote> 
 <p><strong>解题思路</strong></p> 
 <ul><li> <p><strong>初始化变量</strong></p> </li><li> <p><strong>预处理</strong>：</p> </li><li> <p><strong>复制与调整</strong></p> </li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li> <p><strong>初始化</strong>：</p> 
   <ul><li><code>cur</code> 从0开始。</li><li><code>dest</code> 从-1开始。</li><li><code>n</code> 是数组的长度。</li></ul></li><li> <p><strong>预处理</strong>：</p> 
   <ul><li>使用循环遍历整个数组 <code>arr</code>。</li><li>如果 <code>arr[cur]</code> 是0，则 <code>dest</code> 增加2；否则，<code>dest</code> 增加1。</li><li>如果 <code>dest</code> 大于等于 <code>n-1</code>，则退出循环。</li></ul></li><li> <p><strong>特殊情况处理</strong>：</p> 
   <ul><li>如果 <code>dest</code> 等于 <code>n</code>，说明最后一个位置应该是一个复制的0元素，需要将最后一个元素设置为0，并减少 <code>dest</code> 的值以确保不会超出数组长度。</li><li>减少 <code>cur</code> 的值以便在接下来的步骤中重新处理这个位置。</li></ul></li><li> <p><strong>复制与调整</strong>：</p> 
   <ul><li>从 <code>cur</code> 开始向左遍历数组。</li><li>如果 <code>arr[cur]</code> 不为0，则直接将 <code>arr[cur]</code> 复制到 <code>dest</code> 的位置。</li><li>如果 <code>arr[cur]</code> 为0，则需要复制两次0元素到 <code>dest</code> 的位置。</li><li>在每一步之后减少 <code>dest</code> 的值，并且每次循环结束后减少 <code>cur</code> 的值。</li></ul></li><li> <p><strong>结束条件</strong>：</p> 
   <ul><li>当 <code>cur</code> 小于0 时，循环结束。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>具体代码</strong></p> 
 <pre><code>class Solution
{
public:
    void duplicateZeros(vector&lt;int&gt;&amp; arr)
    {
        int cur = 0, dest = -1, n = arr.size();
        while (cur &lt; n)
        {
            if (arr[cur])
                dest++;
            else
                dest += 2;
            if (dest &gt;= n - 1)
                break;
            cur++;
        }

        if (dest == n)
        {
            arr[n - 1] = 0;
            cur--;
            dest -= 2;
        }

        while (cur &gt;= 0)
        {
            if (arr[cur])
                arr[dest--] = arr[cur--];
            else
            {
                arr[dest--] = 0;
                arr[dest--] = 0;
                cur--;
            }
        }
    }
};</code></pre> 
</blockquote> 
<h2 id="%E5%BF%AB%E4%B9%90%E6%95%B0">快乐数<a class="link-info" href="https://leetcode.cn/problems/happy-number/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p> 
<p><strong>「快乐数」</strong> 定义为：</p> 
<ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul> 
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p> 
<p><img alt="" height="390" src="https://images2.imgbox.com/84/d7/t71CfBXf_o.png" width="902"></p> 
<blockquote> 
 <p>首先我们先证明：</p> 
 <p>        对于任意正整数，通过上述过程要么最终变为 1，要么进入一个循环，而不会出现其他情况。（鸽巢原理）</p> 
 <p><strong>证明过程</strong></p> 
 <ol><li> <p><strong>有限性</strong>：</p> 
   <ul><li>假设初始数为 𝑛n，且 𝑛n 有 𝑑d 位数字。</li><li>每次迭代产生的新数的最大值是 𝑑×81d×81，这是因为每一位上的数字最大是 9，而 92=8192=81。</li><li>因此，无论初始数有多大，经过若干次迭代后，得到的数将不会超过 𝑑×81d×81。</li></ul></li><li> <p><strong>循环检测</strong>：</p> 
   <ul><li>既然每次迭代产生的数都是有限集合内的一个数，那么随着迭代次数的增加，必然会出现重复的数。</li><li>当重复出现时，就会形成一个循环，因为一旦出现了一个数，之后的迭代结果将完全由之前的数决定，形成一个闭环。</li></ul></li><li> <p><strong>唯一循环</strong>：</p> 
   <ul><li>如果一个数 𝑛n 通过上述过程变成了 1，那么它就是一个快乐数。</li><li>如果一个数进入了循环，而循环中没有 1，那么这个数就是一个不快乐数。</li><li>除了 1 之外，所有可能的循环都是有限的，因为生成的数总是有限集合内的一个数。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong> 解题思路</strong></p> 
 <ul><li><strong>定义辅助函数</strong> <code>bitSum</code>：计算一个数各位数字的平方和。</li><li><strong>使用快慢指针法</strong> <code>isHappy</code>：通过快慢指针法检测循环，判断是否为快乐数。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li><strong>初始化变量</strong> <code>slow</code> 和 <code>fast</code>： 
   <ul><li><code>slow</code> 初始化为 <code>n</code>。</li><li><code>fast</code> 初始化为 <code>bitSum(n)</code>，即对 <code>n</code> 应用一次 <code>bitSum</code> 函数的结果。</li></ul></li><li><strong>使用快慢指针法检测循环</strong>： 
   <ul><li>在 <code>slow</code> 和 <code>fast</code> 不相等的情况下，继续执行循环。</li><li>在每次循环中： 
     <ul><li>更新 <code>slow</code> 为 <code>bitSum(slow)</code>，即对 <code>slow</code> 应用一次 <code>bitSum</code> 函数。</li><li>更新 <code>fast</code> 为 <code>bitSum(bitSum(fast))</code>，即对 <code>fast</code> 应用两次 <code>bitSum</code> 函数。</li></ul></li></ul></li><li><strong>判断是否为快乐数</strong>： 
   <ul><li>如果 <code>slow</code> 和 <code>fast</code> 最终相等，并且等于 1，则 <code>n</code> 是快乐数。</li><li>如果 <code>slow</code> 和 <code>fast</code> 最终相等但不等于 1，则 <code>n</code> 不是快乐数，因为它进入了循环。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>具体代码</strong></p> 
 <pre><code>class Solution 
{
public:
    int bitSum(int n)
    {
        int sum = 0;
        while(n)
        {
            int t = n % 10;
            sum += t * t;
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) 
    {
        int slow = n,fast = bitSum(n);
        while(slow != fast)
        {
            slow = bitSum(slow);
            fast = bitSum(bitSum(fast));
        }
        return slow == 1;
    }
};</code></pre> 
</blockquote> 
<h2 id="%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8">盛最多水的容器<a class="link-info" href="https://leetcode.cn/problems/container-with-most-water/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p> 
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p> 
<p>返回容器可以储存的最大水量。</p> 
<p><strong>说明：</strong>你不能倾斜容器。</p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/33/55/ZZRywVCz_o.png" width="900"></p> 
<blockquote> 
 <p><strong>解题思路</strong></p> 
 <ul><li><strong>双指针法</strong>：使用两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的起始位置和结束位置。</li><li><strong>计算面积</strong>：每次计算由 <code>left</code> 和 <code>right</code> 指向的两条线形成的容器面积。</li><li><strong>更新最大面积</strong>：记录每次计算的最大面积。</li><li><strong>移动指针</strong>：根据高度较小的一侧来移动指针，以寻找可能更大的面积。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li><strong>初始化变量</strong> <code>left</code> 和 <code>right</code> 分别指向数组的首尾，<code>ret</code> 用于记录最大的面积。</li><li><strong>循环条件</strong>：当 <code>left</code> 小于 <code>right</code> 时，继续执行循环。</li><li><strong>计算面积</strong>： 
   <ul><li>计算当前容器的面积 <code>v</code>，面积由较短边的高度和两线间的距离决定：<code>v = min(height[left], height[right]) * (right - left)</code>。</li><li>更新 <code>ret</code> 为当前面积 <code>v</code> 和已记录的最大面积 <code>ret</code> 中较大的那个值。</li></ul></li><li><strong>移动指针</strong>： 
   <ul><li>如果 <code>height[left]</code> 小于 <code>height[right]</code>，则将 <code>left</code> 向右移动一位。</li><li>否则，将 <code>right</code> 向左移动一位。</li></ul></li><li><strong>循环结束</strong>：当 <code>left</code> 不再小于 <code>right</code> 时，循环结束。</li><li><strong>返回结果</strong> <code>ret</code>。</li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>具体代码 </strong></p> 
 <pre><code>class Solution 
{
public:
    int maxArea(vector&lt;int&gt;&amp; height) 
    {
        int left = 0, right = height.size() - 1, ret = 0;
        while(left &lt; right)
        {
            int v = min(height[left], height[right]) * (right - left);
            ret = max(ret, v);

            if(height[left] &lt; height[right])
                left++;
            else
                right--;
        }
        return ret;
    }
};</code></pre> 
</blockquote> 
<h2 id="%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0">有效三角形的个数<a class="link-info" href="https://leetcode.cn/problems/valid-triangle-number/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>给定一个包含非负整数的数组 <code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/18/71/0b0St4Ha_o.png" width="900"></p> 
<blockquote> 
 <p><strong>解题思路</strong></p> 
 <ul><li><strong>排序</strong>：首先对数组进行排序。</li><li><strong>双指针法</strong>：使用两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的起始位置和当前遍历位置的前一个位置。</li><li><strong>遍历</strong>：从数组的末尾开始遍历，每次选取一个数作为最长边。</li><li><strong>条件判断</strong>：根据构成三角形的条件，移动 <code>left</code> 和 <code>right</code> 指针来寻找所有可能的组合。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li> <p><strong>排序</strong>:</p> 
   <ul><li>使用 <code>sort</code> 函数对输入数组 <code>nums</code> 进行升序排序。</li></ul></li><li> <p><strong>初始化变量</strong>:</p> 
   <ul><li><code>ret</code> 用于记录满足条件的组合数量。</li><li><code>n</code> 是数组的长度。</li></ul></li><li> <p><strong>遍历数组</strong>:</p> 
   <ul><li>从数组的末尾开始，即从最长的边开始遍历。</li><li>使用循环变量 <code>i</code> 从 <code>n - 1</code> 开始递减到 <code>2</code>（因为至少需要三个数才能构成三角形）。</li></ul></li><li> <p><strong>双指针法</strong>:</p> 
   <ul><li>在每次循环中，使用两个指针 <code>left</code> 和 <code>right</code>，分别初始化为 0 和 <code>i - 1</code>。</li><li>使用内部循环，当 <code>left</code> 小于 <code>right</code> 时，继续执行循环。</li><li>根据构成三角形的条件（两边之和大于第三边），进行如下操作： 
     <ul><li>如果 <code>nums[left] + nums[right] &gt; nums[i]</code>，则满足条件，此时所有位于 <code>left</code> 和 <code>right</code> 之间的数都可以与 <code>nums[left]</code> 和 <code>nums[i]</code> 构成三角形，因此加上 <code>right - left</code> 的数量。</li><li>如果不满足条件，则将 <code>left</code> 向右移动一位，尝试更大的数。</li><li>如果满足条件，则将 <code>right</code> 向左移动一位，尝试较小的数。</li></ul></li></ul></li><li> <p><strong>返回结果</strong>:</p> 
   <ul><li>返回 <code>ret</code>，即满足条件的组合数量。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>具体代码 </strong></p> 
 <pre><code>class Solution 
{
public:
    int triangleNumber(vector&lt;int&gt;&amp; nums) 
    {
        sort(nums.begin(), nums.end());

        int ret = 0, n = nums.size();
        for(int i = n - 1; i &gt;= 2; i--)
        {
            int left = 0, right = i - 1;
            while(left &lt; right)
            {
                if(nums[left] + nums[right] &gt; nums[i])
                {
                    ret += right - left;
                    right--;
                }
                else
                {
                    left++;
                }
            }
        }
        return ret;
    }
};</code></pre> 
</blockquote> 
<h2 id="%E6%9F%A5%E6%89%BE%E6%80%BB%E4%BB%B7%E6%A0%BC%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%95%86%E5%93%81">查找总价格为目标值的两个商品<a class="link-info" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>购物车内的商品价格按照升序记录于数组 <code>price</code>。请在购物车中找到两个商品的价格总和刚好是 <code>target</code>。若存在多种情况，返回任一结果即可。</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/8f/13/S3SbdlFG_o.png" width="900"></p> 
<blockquote> 
 <p><strong>解题思路</strong></p> 
 <ul><li><strong>双指针法</strong>：使用两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的起始位置和结束位置。</li><li><strong>计算和</strong>：每次计算由 <code>left</code> 和 <code>right</code> 指向的两个数的和。</li><li><strong>更新指针</strong>：根据和与目标值的关系来更新指针。</li><li><strong>返回结果</strong>：如果找到了符合条件的两个数，则返回这两个数；否则，返回 <code>{ -1, -1 }</code>。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li><strong>初始化变量</strong> <code>left</code> 和 <code>right</code> 分别指向数组的首尾。</li><li><strong>循环条件</strong>：当 <code>left</code> 小于 <code>right</code> 时，继续执行循环。</li><li><strong>计算和</strong>： 
   <ul><li>计算当前和 <code>sum</code>：<code>sum = price[left] + price[right]</code>。</li></ul></li><li><strong>更新指针</strong>： 
   <ul><li>如果 <code>sum</code> 大于 <code>target</code>，则将 <code>right</code> 向左移动一位。</li><li>如果 <code>sum</code> 小于 <code>target</code>，则将 <code>left</code> 向右移动一位。</li><li>如果 <code>sum</code> 等于 <code>target</code>，则找到了符合条件的两个数，返回这两个数。</li></ul></li><li><strong>循环结束</strong>：当 <code>left</code> 不再小于 <code>right</code> 时，循环结束。</li><li><strong>返回结果</strong>：如果没有找到符合条件的两个数，则返回 <code>{ -1, -1 }</code>。</li></ol> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p><strong> 具体代码</strong></p> 
 <pre><code>class Solution 
{
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; price, int target) 
    {
        int left = 0, right = price.size() - 1;
        while(left &lt; right)
        {
            int sum = price[left] + price[right];
            if(sum &gt; target)
                right--;
            else if(sum &lt; target)
                left++;
            else
                return {price[left], price[right]};
        }
        return {-1,-1};
    }
};</code></pre> 
</blockquote> 
<h2 id="%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">三数之和<a class="link-info" href="https://leetcode.cn/problems/3sum/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p> 
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/a8/21/hLG1fdQu_o.png" width="900"></p> 
<blockquote> 
 <p><strong>解题思路</strong></p> 
 <ul><li><strong>排序</strong>：首先对数组进行排序。</li><li><strong>双指针法</strong>：使用两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的当前位置的后一个位置和数组的末尾。</li><li><strong>遍历</strong>：从数组的开头开始遍历，每次选取一个数作为第一个数。</li><li><strong>条件判断</strong>：根据和为 0 的条件，移动 <code>left</code> 和 <code>right</code> 指针来寻找所有可能的组合。</li><li><strong>去重</strong>：在遍历过程中，跳过重复的元素以避免重复的组合。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li> <p><strong>排序</strong>:</p> 
   <ul><li>使用 <code>sort</code> 函数对输入数组 <code>nums</code> 进行升序排序。</li></ul></li><li> <p><strong>初始化变量</strong>:</p> 
   <ul><li><code>ret</code> 用于记录满足条件的组合。</li><li><code>n</code> 是数组的长度。</li></ul></li><li> <p><strong>遍历数组</strong>:</p> 
   <ul><li>从数组的开头开始遍历，使用循环变量 <code>i</code>。</li><li>当 <code>nums[i]</code> 大于 0 时，提前结束遍历（因为之后的组合肯定大于 0）。</li></ul></li><li> <p><strong>双指针法</strong>:</p> 
   <ul><li>在每次循环中，使用两个指针 <code>left</code> 和 <code>right</code>，分别初始化为 <code>i + 1</code> 和 <code>n - 1</code>。</li><li>使用内部循环，当 <code>left</code> 小于 <code>right</code> 时，继续执行循环。</li><li>计算和 <code>sum</code>：<code>sum = nums[left] + nums[right]</code>。</li><li>根据和与目标值 0 的关系，进行如下操作： 
     <ul><li>如果 <code>sum</code> 大于 0，则将 <code>right</code> 向左移动一位。</li><li>如果 <code>sum</code> 小于 0，则将 <code>left</code> 向右移动一位。</li><li>如果 <code>sum</code> 等于 0，则将当前组合加入到结果中，并移动指针以寻找下一个可能的组合。</li><li>在找到有效的组合后，需要跳过重复的元素，以避免重复的组合。</li></ul></li></ul></li><li> <p><strong>返回结果</strong>:</p> 
   <ul><li>返回 <code>ret</code>，即满足条件的组合列表。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>具体代码 </strong></p> 
 <pre><code>class Solution
{
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums)
    {
        vector&lt;vector&lt;int&gt;&gt; ret;

        sort(nums.begin(), nums.end());

        int n = nums.size();
        for (int i = 0; i &lt; n; )
        {
            if (nums[i] &gt; 0)
                break;
            int left = i + 1, right = n - 1, target = -nums[i];
            while (left &lt; right)
            {
                int sum = nums[left] + nums[right];
                if (sum &gt; target)
                    right--;
                else if (sum &lt; target)
                    left++;
                else
                {
                    ret.push_back({ nums[i], nums[right], nums[left] });
                    left++, right--;
                    while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])
                        left++;
                    while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])
                        right--;
                }
            }
            i++;
            while (i &lt; n &amp;&amp; nums[i] == nums[i - 1])
                i++;
        }
        return ret;
    }
};</code></pre> 
</blockquote> 
<h2 id="%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C">四数之和<a class="link-info" href="https://leetcode.cn/problems/4sum/description/" rel="nofollow" title="（原题链接）">（原题链接）</a></h2> 
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。</p> 
<p>请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p> 
<ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul> 
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/38/a7/NHm1UcZU_o.png" width="900"></p> 
<blockquote> 
 <p> <strong>解题思路</strong></p> 
 <ul><li><strong>排序</strong>：首先对数组进行排序。</li><li><strong>双指针法</strong>：使用两个指针 <code>left</code> 和 <code>right</code>，分别指向数组的当前位置的后一个位置和数组的末尾。</li><li><strong>嵌套循环</strong>：使用两层嵌套循环，外层循环遍历数组中的两个数，内层使用双指针法寻找另外两个数，使得四数之和等于目标值。</li><li><strong>去重</strong>：在遍历过程中，跳过重复的元素以避免重复的组合。</li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>步骤说明</strong></p> 
 <ol><li> <p><strong>排序</strong>:</p> 
   <ul><li>使用 <code>sort</code> 函数对输入数组 <code>nums</code> 进行升序排序。</li></ul></li><li> <p><strong>初始化变量</strong>:</p> 
   <ul><li><code>ret</code> 用于记录满足条件的组合。</li><li><code>n</code> 是数组的长度。</li></ul></li><li> <p><strong>外层循环</strong>:</p> 
   <ul><li>从数组的开头开始遍历，使用循环变量 <code>i</code>。</li><li>内层循环遍历数组中的第二个数，使用循环变量 <code>j</code>。</li></ul></li><li> <p><strong>双指针法</strong>:</p> 
   <ul><li>在每次内外层循环中，使用两个指针 <code>left</code> 和 <code>right</code>，分别初始化为 <code>j + 1</code> 和 <code>n - 1</code>。</li><li>使用内部循环，当 <code>left</code> 小于 <code>right</code> 时，继续执行循环。</li><li>计算和 <code>sum</code>：<code>sum = nums[left] + nums[right]</code>。</li><li>根据和与目标值 <code>target</code> 的关系，进行如下操作： 
     <ul><li>如果 <code>sum</code> 小于 <code>target - nums[i] - nums[j]</code>，则将 <code>left</code> 向右移动一位。</li><li>如果 <code>sum</code> 大于 <code>target - nums[i] - nums[j]</code>，则将 <code>right</code> 向左移动一位。</li><li>如果 <code>sum</code> 等于 <code>target - nums[i] - nums[j]</code>，则将当前组合加入到结果中，并移动指针以寻找下一个可能的组合。</li><li>在找到有效的组合后，需要跳过重复的元素，以避免重复的组合。</li></ul></li></ul></li><li> <p><strong>返回结果</strong>:</p> 
   <ul><li>返回 <code>ret</code>，即满足条件的组合列表。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>具体代码 </strong></p> 
 <pre><code>class Solution 
{
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) 
    {
        vector&lt;vector&lt;int&gt;&gt; ret;

        sort(nums.begin(), nums.end());
        
        int n = nums.size();
        for(int i = 0; i &lt; n; )
        {
            for(int j = i + 1; j &lt; n; )
            {
                int  left = j + 1, right = n - 1;
                long long aim = (long long)target - nums[i] - nums[j];
                while(left &lt; right)
                {
                    int sum = nums[left] + nums[right];
                    if(sum &lt; aim)
                        left++;
                    else if(sum &gt; aim)
                        right--;
                    else
                    {
                        ret.push_back({nums[i], nums[j], nums[left], nums[right]});
                        left++, right--;
                        while (left &lt; right &amp;&amp; nums[left] == nums[left - 1])
                            left++;
                        while (left &lt; right &amp;&amp; nums[right] == nums[right + 1])
                            right--;
                    }
                }
                j++;
                while(j &lt; n &amp;&amp; nums[j] == nums[j-1])
                    j++;
            }
            i++;
            while(i &lt; n &amp;&amp; nums[i] == nums[i - 1])
                i++;
        }
        return ret;
    }
};</code></pre> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/99a34ff605a89f955b1f349e525ec427/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux中的三类读写函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a47b1f09f7f1f1d91d67c77aa0e7d37a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uni-app全局文件与常用API</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>