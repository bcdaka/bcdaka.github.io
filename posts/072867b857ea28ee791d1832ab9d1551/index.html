<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言数据在内存中的存储超详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/072867b857ea28ee791d1832ab9d1551/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言数据在内存中的存储超详解">
  <meta property="og:description" content="文章目录 1. 整数在内存中的存储2. 大小端字节序和字节序判断2. 1 什么是大小端？2. 2 为什么会有大小端？2. 3 练习 3. 浮点数在内存中的存储3. 1 一个代码3. 2 浮点数的存储3. 2. 1 浮点数存的过程3. 2. 2 浮点数取的过程3. 3 题目解析 1. 整数在内存中的存储 在操作符的博客中，我们就了解过了下面的内容：
整数的二进制表示方法有三种，即原码、反码和补码，有符号的整数，三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表 示“负”，最高位的一位是被当做符号位，剩余的都是数值位。正整数的原、反、补码都相同。
负整数的三种表示方法各不相同。原码：直接将数值按照正负数的形式翻译成二进制得到的就是原码
反码：将原码的符号位不变，其他位依次按位取反就可以得到反码
补码：反码&#43;1就得到补码。 实际上对于整形来说：数据存放在内存中的是补码。
为什么呢？
在计算机系统中，数值一律用补码来表示和存储。
原因在于，使用补码，可以将符号位和数值域统一处理。
同时，加法和减法也可以统一处理(CPU只有加法器)此外，补码与原码相互转换，其运算过程是
相同的，不需要额外的硬件电路。
关于 其运算过程是相同的 这一点：正整数不必赘述，负数的补码是原码取反&#43;1，如果要从补码得到原码的操作应该是-1再取反，但实际上由于是二进制，取反&#43;1也能得到原码，因此说补码和反码的转换是相同的。
2. 大小端字节序和字节序判断 在了解了数据整数在内存中的存储之后，我们通过调试来看一个细节：
来看这个代码：
#include&lt;stdio.h&gt; int main() { int a = 0x11223344; return 0; } 这里给int 变量a赋值了八进制的 11223344，那它在内存中是这么存储的吗？我们来看一看：
调试的时候，我们可以看到在a中的 0x11223344 这个数字是按照字节为单位，倒着存储的。这是为什么呢?
2. 1 什么是大小端？ 其实超过一个字节的数据在内存中存储的时候，就有存储顺序的问题，按照不同的存储顺序，我们分为大端字节序存储和小端字节序存储，下面是具体的概念:
大端(存储)模式:
是指数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处。
小端(存储)模式:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T19:55:12+08:00">
    <meta property="article:modified_time" content="2024-08-02T19:55:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言数据在内存中的存储超详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__4" rel="nofollow">1. 整数在内存中的存储</a></li><li><a href="#2__22" rel="nofollow">2. 大小端字节序和字节序判断</a></li><li><ul><li><a href="#2_1__36" rel="nofollow">2. 1 什么是大小端？</a></li><li><a href="#2_2__47" rel="nofollow">2. 2 为什么会有大小端？</a></li><li><a href="#2_3__54" rel="nofollow">2. 3 练习</a></li></ul> 
  </li><li><a href="#3__315" rel="nofollow">3. 浮点数在内存中的存储</a></li><li><ul><li><a href="#3_1__318" rel="nofollow">3. 1 一个代码</a></li><li><a href="#3_2__338" rel="nofollow">3. 2 浮点数的存储</a></li><li><a href="#3_2_1__360" rel="nofollow">3. 2. 1 浮点数存的过程</a></li><li><a href="#3_2_2__371" rel="nofollow">3. 2. 2 浮点数取的过程</a></li><li><a href="#3_3__389" rel="nofollow">3. 3 题目解析</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="1__4"></a>1. 整数在内存中的存储</h2> 
<p>在<a href="http://t.csdnimg.cn/eTILN" rel="nofollow">操作符的博客</a>中，我们就了解过了下面的内容：</p> 
<ol><li>整数的二进制表示方法有三种，即<strong>原码、反码和补码</strong>，有符号的整数，三种表示方法均有<strong>符号位</strong>和<strong>数值位</strong>两部分，符号位都是用0表示“正”，用1表 示“负”，<strong>最高位的一位是被当做符号位，剩余的都是数值位。</strong></li><li><strong>正整数的原、反、补码都相同。<br> 负整数的三种表示方法各不相同。</strong></li><li>原码：直接将数值按照正负数的形式翻译成二进制得到的就是原码<br> 反码：将原码的符号位不变，其他位依次按位取反就可以得到反码<br> 补码：反码+1就得到补码。</li></ol> 
<p><strong>实际上对于整形来说：数据存放在内存中的是补码。</strong><br> 为什么呢？<br> 在计算机系统中，数值一律用补码来表示和存储。<br> 原因在于，使用补码，<strong>可以将符号位和数值域统一处理</strong>。<br> 同时，加法和减法也可以统一处理(CPU只有加法器)此外，补码与原码相互转换，<strong>其运算过程是<br> 相同的</strong>，不需要额外的硬件电路。<br> 关于 <em>其运算过程是相同的</em> 这一点：正整数不必赘述，负数的补码是原码取反+1，如果要从补码得到原码的操作应该是-1再取反，但实际上由于是二进制，<strong>取反+1也能得到原码</strong>，因此说补码和反码的转换是相同的。</p> 
<h2><a id="2__22"></a>2. 大小端字节序和字节序判断</h2> 
<p>在了解了数据整数在内存中的存储之后，我们通过调试来看一个细节：<br> 来看这个代码：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x11223344</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里给<code>int</code> 变量<code>a</code>赋值了八进制的 <code>11223344</code>，那它在内存中是这么存储的吗？我们来看一看：<br> <img src="https://images2.imgbox.com/7a/a7/CUuEMYsB_o.png" alt="&amp;a"><br> 调试的时候，我们可以看到在<code>a</code>中的 <code>0x11223344</code> 这个数字是<strong>按照字节为单位，倒着存储的</strong>。这是为什么呢?</p> 
<h3><a id="2_1__36"></a>2. 1 什么是大小端？</h3> 
<p>其实超过一个字节的数据在内存中存储的时候，就有<strong>存储顺序</strong>的问题，按照不同的存储顺序，我们分为<strong>大端字节序存储</strong>和<strong>小端字节序存储</strong>，下面是具体的概念:</p> 
<p><strong>大端(存储)模式:</strong><br> 是指数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处。</p> 
<p><strong>小端(存储)模式:</strong><br> 是指数据的低位字节内容保存在内存的低地址处，而数据的高位字节内容，保存在内存的高地址处。</p> 
<p>也就是说：<strong>倒着存储的，就是小端字节序</strong>。</p> 
<h3><a id="2_2__47"></a>2. 2 为什么会有大小端？</h3> 
<p>为什么会有大小端模式之分呢?</p> 
<p>这是因为在计算机系统中，我们是<strong>以字节为单位</strong>的，每个地址单元都对应着一个字节，一个字节为<code>8bit</code> 位，但是在C语言中除了<code>8bit</code>的 <code>char</code> 之外，还有<code>16bit</code>的 <code>short</code> 型，<code>32bit</code>的 <code>long</code> 型(要看具体的编译器)，另外，对于<strong>位数大于8位的处理器</strong>，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个<strong>如何将多个字节安排的问题</strong>。因此就导致了大端存储模式和小端存储模式。</p> 
<p>例如:-个 <code>16bit</code> 的 <code>short</code>型<code>x</code>，在内存中的地址为 <code>0x0010</code> ，<code>x</code>的值为 <code>0x1122</code> ，那么<code>0x11</code> 为高字节，<code>0x22</code> 为低字节。对于大端模式，就将 <strong>0x11</strong> 放在<strong>低地址</strong>即 <strong>0x0010</strong> 中，<strong>0x22</strong> 放在<strong>高地址</strong>即 <code>0x0011</code> 中。小端模式则刚好相反。我们常用的 <code>X86</code> 结构是<strong>小端模式</strong>，而<strong>KEIL C51</strong> 则为<strong>大端模式</strong>。很多的<strong>ARM</strong>，<strong>DSP</strong>都为小端模式。有些<strong>ARM</strong>处理器还可以由硬件来选择是大端模式还是小端模式。</p> 
<h3><a id="2_3__54"></a>2. 3 练习</h3> 
<p><strong>练习一</strong><br> <strong>请简述大端字节序和小端字节序的概念，设计个小程序来判断当前机器的字节序</strong>。(10分)-<strong>百度笔试题</strong><br> 怎么来判断当前机器的字节序呢？既然是程序，那当然不能通过调试来看。<br> 我们可以想一想 int 类型和 char 类型来判断：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"小端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"大端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下面我们来分析一下这个 <code>check</code> 程序的原理：<br> 如果说机器是<strong>小端存储</strong>的，那么它在内存中就是：</p> 
<pre><code class="prism language-c"><span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>
</code></pre> 
<p>而 <code>&amp;a</code> 得到的是 <code>a</code> 的这<strong>4个字节的第一个字节的地址</strong>，也就是 <code>01</code> 这个字节，将其强制类型转换为 <code>char*</code> 再解引用，得到的就是 <code>1</code>。<br> 如果是小段字节序，得到的就是<code>0</code>。</p> 
<p>那么除了用这样的办法以外，我们还可以使用联合体这一自定义结构：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">union</span> c
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> a<span class="token punctuation">;</span>
		<span class="token keyword">char</span> b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>tmp<span class="token punctuation">;</span>
	tmp<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> tmp<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"小端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"大端"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里简要介绍一下联合体，它和结构体一样都是C语言提供的自定义类型，创建与使用都十分地相似，不同之处在于：<strong>联合体中的每一个变量都是存储在同一个地址中的</strong>。也就是说，上面这个联合体的 <code>a</code> 变量有4个字节，而另一个 变量 <code>b</code> 就是 <code>a</code> 的第一个字节，那么新的 <code>check</code> 函数和上面的 <code>check</code> 函数的原理和结果都是相同的。</p> 
<p><strong>练习二</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">signed</span> <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%d,b=%d,c=%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出结果为？</p> 
<p>首先，我们先要知道 <code>char</code> 类型是有符号还是无符号的？事实上这取决于编译器，但大多数的编译器，包括<strong>VS2022</strong> ，<code>char == signed char</code>。</p> 
<p>我们继续分析：<br> -1的<strong>补码</strong>很容易算，是</p> 
<pre><code class="prism language-c"><span class="token number">11111111111111111111111111111111</span>
</code></pre> 
<p>那么在将其赋值给不同的 <code>char</code> 类型变量时，会把内存中的第一个字节的内容，也就是</p> 
<pre><code class="prism language-c"><span class="token number">11111111</span>
</code></pre> 
<p>赋值过去，所以<code>a,b,c</code>三个变量存储的都是这个。<br> 当 <code>a</code> 在打印时，使用了<code>%d</code>占位符要发生整形提升，而且<code>a</code>是有符号的类型，发生整形提升时，高位补原来的最高位，也就是1：</p> 
<pre><code class="prism language-c"><span class="token number">11111111111111111111111111111111</span>
</code></pre> 
<p>再进行打印，就是-1。<br> b与a同理。</p> 
<p>我们再来看c，c是无符号类型，发生整形提升时，高位补0，得到的就是：</p> 
<pre><code class="prism language-c"><span class="token number">00000000000000000000000011111111</span>
</code></pre> 
<p>再进行打印，就是255。<br> 所以这个代码的运行结果是：<br> <img src="https://images2.imgbox.com/33/86/t646r1HM_o.png" alt="运行结果"><br> <strong>练习三</strong></p> 
<pre><code class="prism language-c"><span class="token comment">//代码一</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//代码二</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这两段代码的输出结果分别是什么？<br> <strong>代码一：</strong><br> -128的反码是</p> 
<pre><code class="prism language-c"><span class="token number">11111111111111111111111110000000</span>
</code></pre> 
<p>那么放入<code>a</code>的就是</p> 
<pre><code class="prism language-c"><span class="token number">10000000</span>
</code></pre> 
<p><code>%u</code>是<code>unsigned int</code> ，所以要发生整形提升。<code>a</code>是有符号的，高位补1，就是</p> 
<pre><code class="prism language-c"><span class="token number">11111111111111111111111110000000</span>
</code></pre> 
<p>那么代码一的结果就是将这个数以无符号的形式打印出来。<br> 也就是：<br> <img src="https://images2.imgbox.com/cf/b8/zepG8gR1_o.png" alt="代码一"><br> <strong>代码二：</strong><br> 128的反码和原码相同，也就是：</p> 
<pre><code class="prism language-c"><span class="token number">00000000000000000000000010000000</span>
</code></pre> 
<p>那么放入 <code>a</code> 的就是</p> 
<pre><code class="prism language-c"><span class="token number">10000000</span>
</code></pre> 
<p>再进行整形提升，就是：</p> 
<pre><code class="prism language-c"><span class="token number">11111111111111111111111110000000</span>
</code></pre> 
<p>把这个数按照 <code>%u</code> 的格式打印出来就是结果了：<br> <img src="https://images2.imgbox.com/5d/b7/Dct88oVb_o.png" alt="代码二"><br> <strong>练习四</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>提示：<code>'\0'</code>的ASCII码值为<code>0</code>。<br> 要计算出哪一个位置会得到0，我们先要算出如果<code>a[i]</code>是 0 ，等号右边应该是什么样的数：<br> <code>a[i]</code>是<code>char</code>变量，取的是<code>-1-i</code>在内存中的的最后一个字节的内容，很显然 <code>-1-i</code> 恒为负数，那么最后一个字节的内容如果是：<code>00000000</code>，那么在原码中，最后一个字节的内容应该是：<code>00000000</code>，最大的满足这个的原码是：<code>10000000000000000000000100000000</code>，也就是-256，那么此时的<code>i</code>就是255，所以<code>a</code>的长度应该是255.<br> <img src="https://images2.imgbox.com/69/ed/MOnqRyEn_o.png" alt="练习四"><br> <strong>练习五：</strong></p> 
<pre><code class="prism language-c"><span class="token comment">//代码一</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//代码二</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>代码一</strong><br> <code>i&lt;=255</code>是恒成立的，为什么？<br> <code>unsigned char</code> 类型的最大值是255，如果此时再+1，就会变成多少呢？<br> 我们通过一个代码来测试：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span>
	a<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1f/81/vS9HKYlF_o.png" alt="测试结果"><br> 可以看到，此时<code>a</code>又变成了 <code>unsigned char</code> 的最小值0。<br> 那么上面的循环就是一个死循环，会不停地打印<code>hello world</code>。<br> <img src="https://images2.imgbox.com/6e/6c/twX7n7QC_o.png" alt="执行结果"><br> <strong>代码二</strong><br> <code>unsigned int</code> 的取值范围最小为0，再-1会变成什么呢？<br> 我们还是通过一个代码来分析：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	a<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%u"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意使用 %u 占位符</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4e/a9/MIWdJR5w_o.png" alt="测试"><br> 可以看到，<code>a</code>变成了 <code>unsigned int</code> 的最大值，所以上面的循环也是一个死循环，会不停地打印 <code>i</code> 的值。<br> <img src="https://images2.imgbox.com/0b/e0/pwvZUl4W_o.png" alt="代码二"><br> <strong>练习六</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token comment">//X86环境 小端字节序</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x,%x"</span><span class="token punctuation">,</span> ptr1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>关于<code>ptr1</code>，在指针系列中我已经讲解过，这里只做简要说明，不明白可以看我的指针系列文章，&amp;a+1跳过整个数组，再强制类型转换为<code>int*</code>，<code>ptr1[-1]</code>就是取<code>ptr1</code> 的上一个数字，也就是 4，按照16进制打印，还是4.<br> 我们重点来看 <code>ptr2</code>，首先将 <code>a</code>强制类型转换为<code>int</code>，这里<code>a</code>是指数组的首元素的地址，假设是<code>0x00115511</code>，再+1得到<code>0x00115512</code>，再强制类型转换为<code>int*</code>，也就是相对原来的位置，向后走了一个字节，那么此时<code>ptr2</code>是多少？<br> 我们画图来分析：<br> <img src="https://images2.imgbox.com/f3/d8/d9u05FOh_o.png" alt="ptr2"><br> 那么此时的ptr2就是<code>0x02000000</code>。</p> 
<h2><a id="3__315"></a>3. 浮点数在内存中的存储</h2> 
<p>浮点数表示的范围:<code>float.h</code>中定义<br> 常见的浮点数:3.14159、1E10等，浮点数家族包括: <code>float、double、long double</code> 类型。</p> 
<h3><a id="3_1__318"></a>3. 1 一个代码</h3> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
	<span class="token keyword">float</span><span class="token operator">*</span> pFloat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>n<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"n的值为：%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>pFloat <span class="token operator">=</span> <span class="token number">9.0</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num的值为：%d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*pFloat的值为：%f\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pFloat<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出结果为：<br> <img src="https://images2.imgbox.com/c5/9d/FwCek7z8_o.png" alt="输出结果"><br> 上面的代码中， <code>num</code> 和 *<code>pFloat</code> 在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别<br> 这么大?</p> 
<h3><a id="3_2__338"></a>3. 2 浮点数的存储</h3> 
<p>要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法。<br> 根据国际标准IEEE(电气和电子工程协会)754，任意一个二进制浮点数V可以表示成下面的形式：<br> V = (−1) <sup>S</sup> * M ∗ 2<sup>E</sup><br> 其中：<br> (−1) <sup>S</sup> 表示符号位，当S=0，V为正数；当S=1，V为负数<br> M 表示有效数字，M是大于等于1，小于2的<br> 2<sup>E</sup> 表示指数位</p> 
<p>举例来说:<br> 十进制的5.0，写成二进制是 101.0 ，相当于 1.01x2^2。<br> 那么，按照上面V的格式，可以得出S=0，M=1.01，E=2。</p> 
<p>十进制的 -5.0，写成二进制是-101.0，相当于-1.01x2<sup>2</sup>。那么，S=1，M=1.01，E=2。</p> 
<p>IEEE 754规定:<br> <strong>对于32位的浮点数，最高的1位存储符号位S，接着的8位存储指数E，剩下的23位存储有效数字M<br> 对于64位的浮点数，最高的1位存储符号位S，接着的11位存储指数E，剩下的52位存储有效数字M</strong><br> <strong>float:</strong><br> <img src="https://images2.imgbox.com/b8/c4/Mx7pZGwA_o.png" alt="float"><br> <strong>double:</strong><br> <img src="https://images2.imgbox.com/95/c8/FZvhk5SV_o.png" alt="double"></p> 
<h3><a id="3_2_1__360"></a>3. 2. 1 浮点数存的过程</h3> 
<p>IEEE754 对<strong>有效数字M和指数E</strong>，还有一些特别规定。</p> 
<p>前面说过，<code>1 ≤ M &lt; 2</code> ，也就是说，<code>M</code>可以写成<code>1.xxxxxx</code> 的形式，其中 <code>xxxxxx</code> 表示小数部分。<br> IEEE 754 规定，在计算机内部保存<code>M</code>时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的<code>xxxxxx</code>部分。比如保存<code>1.01</code>的时候，只保存<code>01</code>，等到读取的时候，再把第一位的<code>1</code>加上去。这样做的目的，是<strong>节省1位有效数字</strong>。以32位浮点数为例，留给<code>M</code>只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</p> 
<p>至于<strong>指数E</strong>，情况就比较复杂<br> 首先，<code>E</code>为一个无符号整数(<code>unsigned int</code>)<br> 这意味着，如果E为8位，它的取借范围为0 ~ 255;如果E为11位，它的取值范围为0 ~ 2047。<br> 但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是<code>127</code>;对于11位的E，这个中间数是<code>1023</code>。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即<code>10001001</code>。</p> 
<h3><a id="3_2_2__371"></a>3. 2. 2 浮点数取的过程</h3> 
<p>指数E从内存中取出还可以再分成三种情况：</p> 
<p><strong>E不全为0或不全为1</strong><br> 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127(或1023)，得到真实值，再将有效<br> 数字M前加上第一位的1。<br> 比如:0.5 的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为<code>1.0*2^(-1)</code>，其阶码为-1+127(中间值)=126，表示为<code>01111110</code>，而尾数<code>1.0</code>去掉整数部分为0，补齐0到23位<code>00000000000000000000000</code>，则其二进制表示形式为：</p> 
<pre><code class="prism language-c"><span class="token number">0</span> <span class="token number">01111110</span> <span class="token number">00000000000000000000000</span>
</code></pre> 
<p><strong>E全为0</strong><br> 这时，浮点数的指数E等于1-127(或者1-1023)即为真实值，有效数字M不再加上第一位的1，而是还<br> 原为<code>0.xxxxxx</code>的小数。这样做是为了表示<code>±0</code>，以及接近于0的很小的数字。</p> 
<p><strong>E全为1</strong><br> 这时，如果有效数字M全为0，表示±无穷大(正负取决于符号位s)</p> 
<h3><a id="3_3__389"></a>3. 3 题目解析</h3> 
<p>先看第1环节，为什么 9 还原成浮点数，就成了 <code>0.000000</code> ？<br> 9 以整型的形式存储在内存中，得到如下二进制序列：</p> 
<pre><code class="prism language-c"><span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">1001</span>
</code></pre> 
<p>首先，将 9的二进制序列按照浮点数的形式拆分，得到第一位符号位s=0，后面8位的指数<br> E=<code>00000000</code>，最后23位的有效数字M=<code>000 0000 0000 0000 00001001</code>。<br> 由于指数E全为0，所以符合E为全0的情况。因此，浮点数V就写成:</p> 
<pre><code class="prism language-c">V<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0</span> x <span class="token number">0.00000000000000000001001</span>x2<span class="token operator">^</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">126</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">1.001</span>x2<span class="token operator">^</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">146</span><span class="token punctuation">)</span>
</code></pre> 
<p>显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是<code>0.000000</code>。</p> 
<p>再看第2环节，浮点数9.0，为什么整数打印是<code>1091567616</code><br> 首先，浮点数9.0等于二进制的1001.0，即换算成科学计数法是:<code>1.001x2^3</code><br> 所以:9.0 = (-1)<sup>0</sup>*(1.001)*2<sup>3</sup><br> 那么，第一位的符号位S=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，<br> 即<code>10000010</code><br> 所以，写成二进制形式，应该是<code>S+E+M</code>，即</p> 
<pre><code class="prism language-c"><span class="token number">0</span> <span class="token number">10000010</span> <span class="token number">001</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span>
</code></pre> 
<p>这个32位的二进制数，被当做整数来解析的时候，就是整数在内存中的补码，原码正是<br> <code>1091567616</code>。</p> 
<p><strong>谢谢你的阅读，喜欢的话来个点赞收藏评论关注吧！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/46acdc9ade65aca2be032fd498493fa3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【研发日记】Matlab/Simulink技能解锁(十二)——Stateflow中的两种状态机嵌套对比</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7ba8d96dba5321ac2bf8691285790b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">鸿蒙购物车布局完成后的点击事件（不怎么通俗易懂）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>