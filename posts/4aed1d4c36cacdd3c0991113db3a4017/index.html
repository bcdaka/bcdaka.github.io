<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【初阶数据结构】深入解析单链表:探索底层逻辑（无头单向非循环链表） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4aed1d4c36cacdd3c0991113db3a4017/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【初阶数据结构】深入解析单链表:探索底层逻辑（无头单向非循环链表）">
  <meta property="og:description" content="🔥引言
本篇将深入解析单链表:探索底层逻辑，理解底层是如何实现并了解该接口实现的优缺点，以便于我们在编写程序灵活地使用该数据结构。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C&#43;&#43;笔记专栏： C&#43;&#43;笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、链表的概念二、链表的分类四、实现无头单向非循环链表的相关接口(SLTlist.h)五、知识铺垫六、正式开始模拟实现单链表6.1 创建链表中的节点6.2 单链表的插入节点6.2.1 单链表的尾插6.2.2 单链表的头插 6.3 单链表的删除6.3.1 单链表的尾删6.3.2 单链表的头删 6.4 查找单链表中数据6.5 关于单链表的任意位置插入和删除6.5.1 单链表的pos指定前插入6.5.2 单链表的删除pos当前结点6.5.3 单链表的pos之后插入6.5.4 单链表的pos之后删除 6.6 单链表的打印 七、顺序表和链表的区别 一、链表的概念 链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
二、链表的分类 我们重点需要关注以下两个链表:
1.无头单向非循环链表
结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
2.带头双向循环链表
结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。虽然结构复杂，但是使用代码实现，以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了
链表是通过一个个结点链接起来的数据结构，多个结点链接形成下列结构(箭头是不存在，是为了方便理解)
下列图片会简化结点间的链接过程：
【注意】:
从图上可以看出，链式结构在逻辑上是连续的，但是在物理上不一定连续
现实中的节点一般都是从堆上申请出来的
从堆上申请的空间。是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续
四、实现无头单向非循环链表的相关接口(SLTlist.h) 五、知识铺垫 1.实现部分接口需要通过二级指针接受实参
原因在于我们需要可以修改实参，而是实参为一级指针时(同样是传递地址)，需要使用二级指针进行接受，否则获得临时拷贝，不会影响到实参。修改实参的情况，比如一开始为空，在插入时需将头指针存储在有效结点的的地址上，需要改变实参的值
2.单链表的初始化
这里实现链表，没有必要进行初始化，初始化对于一开始就要开辟的空间有初始化的需求，表是多个节点通过地址链接在一起，那么只需要开辟新节点的时候，初始化下就行了(有哨兵位需要初始化)
3.二级指针断言
二级指针存放的是头节点的地址，头节点的地址为空，那么还有什么意义呢?
当我们有所了解链表的结构，接下来是实现链表的相关接口，比如增删查改
六、正式开始模拟实现单链表 6.1 创建链表中的节点 在插入中需要先创建一块结点空间，再通过上一个结点通过当前结点的地址指向当前结点的位置。这是因为结点是通过地址访问的，结点里面存储着下一个节点的地址，理解为当前结点(通过下一个结点地址)指向下一个结点
SLNode* CreateNode(SLNDataType x) { SLNode* newnode = (SLNode*)malloc(sizeof(SLNode)); if (newnode==NULL) { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-17T08:42:53+08:00">
    <meta property="article:modified_time" content="2024-06-17T08:42:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【初阶数据结构】深入解析单链表:探索底层逻辑（无头单向非循环链表）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/f3/f8/8xWX3TIZ_o.gif" alt="请添加图片描述"></p> 
<p>🔥引言</p> 
<blockquote> 
 <p>本篇将深入解析单链表:探索底层逻辑，理解底层是如何实现并了解该接口实现的优缺点，以便于我们在编写程序灵活地使用该数据结构。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/1d/d2/cMYcKmtD_o.gif" alt="请添加图片描述" width="600" height="60"><br> <img src="https://images2.imgbox.com/ef/32/NYYb1oPL_o.png" alt="Alt" width="200" height="200"></p> 
<p>🌈个人主页：<a href="https://blog.csdn.net/2302_79177254?type=blog">是店小二呀</a><br> 🌈C语言笔记专栏：<a href="https://blog.csdn.net/2302_79177254/category_12498683.html?spm=1001.2014.3001.5482">C语言笔记</a><br> 🌈C++笔记专栏： <a href="https://blog.csdn.net/2302_79177254/category_12596619.html">C++笔记</a><br> 🌈初阶数据结构笔记专栏： <a href="https://blog.csdn.net/2302_79177254/category_12596619.html">初阶数据结构笔记</a></p> 
<p>🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅<br> <img src="https://images2.imgbox.com/36/50/45RRJiaP_o.gif" alt="请添加图片描述" width="600" height="60"></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#font_colorcornflowerbluefont_21" rel="nofollow"><font color="cornflowerblue">一、链表的概念</font></a></li><li><a href="#font_colorcornflowerbluefont_25" rel="nofollow"><font color="cornflowerblue">二、链表的分类</font></a></li><li><a href="#font_colorcornflowerbluefontSLTlisth_56" rel="nofollow"><font color="cornflowerblue">四、实现无头单向非循环链表的相关接口</font>(SLTlist.h)</a></li><li><a href="#font_colorcornflowerbluefont_61" rel="nofollow"><font color="cornflowerblue">五、知识铺垫</font></a></li><li><a href="#font_colorcornflowerbluefont_77" rel="nofollow"><font color="cornflowerblue">六、正式开始模拟实现单链表</font></a></li><li><ul><li><a href="#font_colorcornflowerblue61_font_79" rel="nofollow"><font color="cornflowerblue">6.1 创建链表中的节点</font></a></li><li><a href="#font_colorcornflowerblue62_font_99" rel="nofollow"><font color="cornflowerblue">6.2 单链表的插入节点</font></a></li><li><ul><li><a href="#font_colorcornflowerblue621_font_103" rel="nofollow"><font color="cornflowerblue">6.2.1 单链表的尾插</font></a></li><li><a href="#622__135" rel="nofollow">6.2.2 单链表的头插</a></li></ul> 
   </li><li><a href="#font_colorcornflowerblue63_font_160" rel="nofollow"><font color="cornflowerblue">6.3 单链表的删除</font></a></li><li><ul><li><a href="#font_colorcornflowerblue631_font_166" rel="nofollow"><font color="cornflowerblue">6.3.1 单链表的尾删</font></a></li><li><a href="#font_colorcornflowerblue632_font_198" rel="nofollow"><font color="cornflowerblue">6.3.2 单链表的头删</font></a></li></ul> 
   </li><li><a href="#font_colorcornflowerblue64_font_226" rel="nofollow"><font color="cornflowerblue">6.4 查找单链表中数据</font></a></li><li><a href="#font_colorcornflowerblue65_font_245" rel="nofollow"><font color="cornflowerblue">6.5 关于单链表的任意位置插入和删除</font></a></li><li><ul><li><a href="#font_colorcornflowerblue651_posfont_247" rel="nofollow"><font color="cornflowerblue">6.5.1 单链表的pos指定前插入</font></a></li><li><a href="#font_colorcornflowerblue652_posfont_279" rel="nofollow"><font color="cornflowerblue">6.5.2 单链表的删除pos当前结点</font></a></li><li><a href="#font_colorcornflowerblue653_posfont_314" rel="nofollow"><font color="cornflowerblue">6.5.3 单链表的pos之后插入</font></a></li><li><a href="#font_colorcornflowerblue654_posfont_339" rel="nofollow"><font color="cornflowerblue">6.5.4 单链表的pos之后删除</font></a></li></ul> 
   </li><li><a href="#font_colorcornflowerblue66_font_370" rel="nofollow"><font color="cornflowerblue">6.6 单链表的打印</font></a></li></ul> 
  </li><li><a href="#font_colorcornflowerblue__font_406" rel="nofollow"><font color="cornflowerblue">七、顺序表和链表的区别 </font></a></li></ul> 
</div> 
<p></p> 
<h2><a id="font_colorcornflowerbluefont_21"></a><font color="cornflowerblue">一、链表的概念</font></h2> 
<p>链表是一种<strong>物理存储结构上非连续、非顺序</strong>的存储结构，数据元素的逻辑顺序是通过链表中的<strong>指针链接次序实现的</strong> 。</p> 
<h2><a id="font_colorcornflowerbluefont_25"></a><font color="cornflowerblue">二、链表的分类</font></h2> 
<p><img src="https://images2.imgbox.com/9f/ba/hLLKVyBs_o.png" alt="在这里插入图片描述"></p> 
<p><strong>我们重点需要关注以下两个链表</strong>:</p> 
<p><strong><font color="cornflowerblue">1.无头单向非循环链表</font></strong></p> 
<p>结构简单，<strong>一般不会单独用来存数据</strong>。实际中更多是<strong>作为其他数据结构的子结构</strong>，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。</p> 
<p><strong><font color="cornflowerblue">2.带头双向循环链表</font></strong></p> 
<p>结构最复杂，<strong>一般用在单独存储数据</strong>。实际中使用的链表数据结构，都是带头双向循环链表。虽然结构复杂，但是使用代码实现，以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了</p> 
<p>链表是通过一个个结点链接起来的数据结构，多个结点链接形成下列结构(箭头是不存在，是为了方便理解)<br> <img src="https://images2.imgbox.com/97/96/yqKtmyyY_o.png" alt="在这里插入图片描述"></p> 
<p><strong>下列图片会简化结点间的链接过程：</strong></p> 
<p><img src="https://images2.imgbox.com/74/8d/3JHxhGQ0_o.png" alt="在这里插入图片描述"></p> 
<p>【<strong>注意</strong>】:</p> 
<ol><li> <p>从图上可以看出，链式结构在逻辑上是连续的，但是在物理上不一定连续</p> </li><li> <p>现实中的节点<strong>一般都是从堆上申请出来</strong>的</p> </li><li> <p>从堆上申请的空间。是按照一定的策略来分配的，<strong>两次申请的空间可能连续，也可能不连续</strong></p> </li></ol> 
<h2><a id="font_colorcornflowerbluefontSLTlisth_56"></a><font color="cornflowerblue">四、实现无头单向非循环链表的相关接口</font>(SLTlist.h)</h2> 
<p><img src="https://images2.imgbox.com/81/4b/Xl4lMpKk_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="font_colorcornflowerbluefont_61"></a><font color="cornflowerblue">五、知识铺垫</font></h2> 
<p><strong><font color="cornflowerblue">1.实现部分接口需要通过二级指针接受实参</font></strong></p> 
<p>原因在于我们需要可以修改实参，而是实参为一级指针时(同样是传递地址)，需要使用二级指针进行接受，否则获得临时拷贝，不会影响到实参。修改实参的情况，比如一开始为空，在插入时需将头指针存储在有效结点的的地址上，需要改变实参的值</p> 
<p><strong><font color="cornflowerblue">2.单链表的初始化</font></strong></p> 
<p>这里实现链表，没有必要进行初始化，<strong>初始化对于一开始就要开辟的空间有初始化的需求</strong>，表是多个节点通过地址链接在一起，那么只需要开辟新节点的时候，初始化下就行了(有哨兵位需要初始化)</p> 
<p><strong><font color="cornflowerblue">3.二级指针断言</font></strong></p> 
<p>二级指针存放的是头节点的地址，头节点的地址为空，那么还有什么意义呢?</p> 
<p>当我们有所了解链表的结构，接下来是实现链表的相关接口，比如增删查改</p> 
<h2><a id="font_colorcornflowerbluefont_77"></a><font color="cornflowerblue">六、正式开始模拟实现单链表</font></h2> 
<h3><a id="font_colorcornflowerblue61_font_79"></a><font color="cornflowerblue">6.1 创建链表中的节点</font></h3> 
<p>在插入中需要先创建一块结点空间，再通过上一个结点通过当前结点的地址指向当前结点的位置。<strong>这是因为结点是通过地址访问的，结点里面存储着下一个节点的地址，理解为当前结点(通过下一个结点地址)指向下一个结点</strong></p> 
<pre><code class="prism language-c">SLNode<span class="token operator">*</span> <span class="token function">CreateNode</span><span class="token punctuation">(</span>SLNDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SLNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>SLNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>newnode<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc fail!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		 <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	newnode<span class="token operator">-&gt;</span>val <span class="token operator">=</span> x<span class="token punctuation">;</span>
	<span class="token keyword">return</span> newnode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:申请到的空间交给什么类型去维护，为结点(结构体)申请空间，就需要交给结构体指针维护，同时需要注意开辟空间可能会失败，比如开辟空间多大，无法提供空间。<strong>对新结点设置了指向下一个结点为空</strong></p> 
<h3><a id="font_colorcornflowerblue62_font_99"></a><font color="cornflowerblue">6.2 单链表的插入节点</font></h3> 
<p><strong>插入分为三类</strong>:头插\尾插\任意位置插入(其中任意位置插入，在实现查找功能先放着)</p> 
<h4><a id="font_colorcornflowerblue621_font_103"></a><font color="cornflowerblue">6.2.1 单链表的尾插</font></h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPushBack</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> phead<span class="token punctuation">,</span>SLNDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">CreateNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//值已经有了,创建一个新节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>phead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//这里需要二级指针去改变了，外的头了</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>phead <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//找尾</span>
		SLNode<span class="token operator">*</span> cur <span class="token operator">=</span><span class="token operator">*</span>phead<span class="token punctuation">;</span><span class="token comment">//拷贝一份</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span><span class="token comment">//newnode已经搞下一次是空了	</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:while语句<strong>cur需要到达尾，再进行尾插的操作</strong>。同时需要考虑到特殊情况，这里我们通过if判断语句对于<code>* pphead</code>为空的情况，将<code>*pphead</code>存储在第一个结点地址。<br> <img src="https://images2.imgbox.com/ce/58/QcE3RVao_o.gif" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<p><img src="https://images2.imgbox.com/de/ba/xsESIhZ4_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="622__135"></a>6.2.2 单链表的头插</h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPushFront</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">,</span> SLNDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">CreateNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:将<code>*pphead</code>移动到新节点的位置，再 <code>* pphead</code>指向<code>cur</code>(在原来的头节点位置)。<strong>同样的需要考虑到特殊情况，这里使用if判断语句对于<code>* pphead</code>为空的情况，将<code>*pphead</code>设为存储第一个结点地址。</strong><br> <img src="https://images2.imgbox.com/5f/7b/udo61cFO_o.gif" alt="在这里插入图片描述"></p> 
<h3><a id="font_colorcornflowerblue63_font_160"></a><font color="cornflowerblue">6.3 单链表的删除</font></h3> 
<p><strong>删除分为三类</strong>：头删\尾删\任意位置删除(其中任意位置删除，在实现查找功能先放着)</p> 
<p><strong>提前说明</strong>:空链表无法进行删除数据，需要在删除操作之前进行断言检查<code>assert(*pphead)</code></p> 
<h4><a id="font_colorcornflowerblue631_font_166"></a><font color="cornflowerblue">6.3.1 单链表的尾删</font></h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPopBack</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//空的时候</span>
	<span class="token comment">//一个节点和多个节点</span>
	<span class="token comment">//这里不创建一个cur变量，当只有一个节点的时候，直接pphead</span>
	SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">//上一个节点</span>
		<span class="token punctuation">}</span>
		<span class="token function">free</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:删除需要分为两种情况存在一个节点和多个节点的处理。需要利用while循环找到删除节点的上一个节点，将上一个节点指向空，最后不要忘记<code>free(cur-&gt;next)</code>，释放当前节点空间。<br> <img src="https://images2.imgbox.com/8f/b5/o9tqhFuU_o.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传"></p> 
<h4><a id="font_colorcornflowerblue632_font_198"></a><font color="cornflowerblue">6.3.2 单链表的头删</font></h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPopFront</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">*</span>pphead <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里需要注意的是:删除需要分为两种情况存在一个节点和多个节点的处理。cur保存当头节点位置，<code>*pphead</code>移动到下一个节点的位置，再<code>free(cur)</code><br> <img src="https://images2.imgbox.com/4c/5f/VsmqFG3L_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="font_colorcornflowerblue64_font_226"></a><font color="cornflowerblue">6.4 查找单链表中数据</font></h3> 
<pre><code class="prism language-c">SLNode<span class="token operator">*</span> <span class="token function">SLTFind</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span> pphead<span class="token punctuation">,</span> SLNDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>val <span class="token operator">==</span> x<span class="token punctuation">)</span>
			<span class="token keyword">return</span> cur<span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:遍历链表，找到返回当前节点，没有找到继续向下遍历</p> 
<h3><a id="font_colorcornflowerblue65_font_245"></a><font color="cornflowerblue">6.5 关于单链表的任意位置插入和删除</font></h3> 
<h4><a id="font_colorcornflowerblue651_posfont_247"></a><font color="cornflowerblue">6.5.1 单链表的pos指定前插入</font></h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTInsert</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">,</span>SLNode <span class="token operator">*</span>pos<span class="token punctuation">,</span>SLNDataType x<span class="token punctuation">)</span><span class="token comment">//pos指定之前插入</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//没有节点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">SLTPushFront</span><span class="token punctuation">(</span>pphead<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead <span class="token operator">==</span> pos<span class="token punctuation">)</span><span class="token comment">//一个节点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">SLTPushFront</span><span class="token punctuation">(</span>pphead<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token comment">//多个节点</span>
	<span class="token punctuation">{<!-- --></span>
		SLNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">CreateNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> pos<span class="token punctuation">)</span><span class="token comment">//上面避免了pos等于cur</span>
		<span class="token punctuation">{<!-- --></span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
		newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> pos<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>:需要分为三种情况，空节点，一个节点，多个节点就行处理。空节点调用尾插或者头插都可以，一个节点(在<code>pos</code>前插入)那么可以调用头插<br> <img src="https://images2.imgbox.com/6d/60/rCq78y32_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="font_colorcornflowerblue652_posfont_279"></a><font color="cornflowerblue">6.5.2 单链表的删除pos当前结点</font></h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTEeara</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">,</span> SLNode<span class="token operator">*</span> pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//防止用户传个空指针</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> next <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">==</span>pos<span class="token punctuation">)</span>
	<span class="token operator">*</span>pphead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> pos<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pos <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>：分为两种情况，存在一个节点和多个节点的处理。<strong>如果使用三个变量，需要使用到的地址不会丢失，就不需要担心先后顺序问题</strong>。结点是一块块的独立空间，其链接方式也是较灵活的，这里跟上面方法是类似的。<br> <img src="https://images2.imgbox.com/89/38/m4hw7uNt_o.png" alt="在这里插入图片描述"></p> 
<p>如果不想在<code>pos</code>之前插入\删除，可以改动逻辑在<code>pos</code>之后进行插入、删除。</p> 
<h4><a id="font_colorcornflowerblue653_posfont_314"></a><font color="cornflowerblue">6.5.3 单链表的pos之后插入</font></h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTInsertAfter</span><span class="token punctuation">(</span>SLNode <span class="token operator">*</span><span class="token operator">*</span>pphead<span class="token punctuation">,</span>SLNode<span class="token operator">*</span> pos<span class="token punctuation">,</span> SLNDataType x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//没有节点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">SLTPushFront</span><span class="token punctuation">(</span>pphead<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>pphead <span class="token operator">==</span> pos<span class="token punctuation">)</span><span class="token comment">//一个节点</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">SLTPushBack</span><span class="token punctuation">(</span>pphead<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token comment">//多个节点</span>
	<span class="token punctuation">{<!-- --></span>
		SLNode<span class="token operator">*</span> newnode <span class="token operator">=</span> <span class="token function">CreateNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		SLNode<span class="token operator">*</span> back <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		newnode<span class="token operator">-&gt;</span>next <span class="token operator">=</span> back<span class="token punctuation">;</span>
		pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newnode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="font_colorcornflowerblue654_posfont_339"></a><font color="cornflowerblue">6.5.4 单链表的pos之后删除</font></h4> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTEearaAfter</span><span class="token punctuation">(</span>SLNode <span class="token operator">*</span><span class="token operator">*</span>pphead<span class="token punctuation">,</span>SLNode<span class="token operator">*</span> pos<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> back <span class="token operator">=</span> pos<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> pos<span class="token punctuation">)</span><span class="token comment">//只有一个结点</span>
		<span class="token function">SLTPopBack</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>back<span class="token operator">-&gt;</span>next<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">free</span><span class="token punctuation">(</span>back<span class="token punctuation">)</span><span class="token punctuation">;</span>
		back <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span>
	<span class="token punctuation">{<!-- --></span>
		pos<span class="token operator">-&gt;</span>next <span class="token operator">=</span> back<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>back<span class="token punctuation">)</span><span class="token punctuation">;</span>
		back <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的两个接口实现过程跟<code>SLTInsert</code>、<code>SLTEeara</code>实现类似的，看看代码就能理解</p> 
<p>在完成了单链表的核心接口，我们需要继续完善剩下的接口，使实现的单链表功能更加丰富起来。</p> 
<h3><a id="font_colorcornflowerblue66_font_370"></a><font color="cornflowerblue">6.6 单链表的打印</font></h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTPrint</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span><span class="token comment">//二级指针改变外的结构体指针类型</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d-&gt;"</span><span class="token punctuation">,</span> cur<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"NULL\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>：当cur==NULL时，没有进去循环，需要额外打印NULL，最后不要忘记单链表的销毁</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SLTDestroy</span><span class="token punctuation">(</span>SLNode<span class="token operator">*</span><span class="token operator">*</span> pphead<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>pphead<span class="token punctuation">)</span><span class="token punctuation">;</span>
	SLNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">*</span>pphead<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		SLNode<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//这里cur不要赋空，还需要使用的</span>
		cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
	<span class="token operator">*</span>pphead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>这里需要注意的是</strong>：链表是通过多个节点链接而成的，同时也是一块块独立空间，通过cur去访问每一个空间和释放每一块空间。其中free指针跟指针变身是没有关系的，释放的是指针所指向的那一块动态空间</p> 
<h2><a id="font_colorcornflowerblue__font_406"></a><font color="cornflowerblue">七、顺序表和链表的区别 </font></h2> 
<table><thead><tr><th>不同点</th><th>顺序表</th><th>链表</th></tr></thead><tbody><tr><td>存储空间上</td><td>物理上一定连续</td><td>逻辑上连续，但物理上不一定 连续</td></tr><tr><td>随机访问</td><td>支持O(1)</td><td>不支持：O(N)</td></tr><tr><td>任意位置插入或者删除 元素</td><td>可能需要搬移元素，效率低 O(N)</td><td>只需修改指针指向</td></tr><tr><td>插入</td><td>动态顺序表，空间不够时需要 扩容</td><td>没有容量的概念</td></tr><tr><td>应用场景</td><td>元素高效存储+频繁访问</td><td>任意位置插入和删除频繁</td></tr><tr><td>缓存利用率</td><td>高</td><td>低</td></tr></tbody></table> 
<p>不管是哪一种数据结构都有他的优点和缺点，对此在使用数据结构中应该知道它的优缺点是什么，加以合理地利用解决实际中的问题。</p> 
<hr> 
<p><img src="https://images2.imgbox.com/a0/61/68YotEWR_o.gif" alt="请添加图片描述"></p> 
<p><strong><font color="cornflowerblue">以上就是本篇文章的所有内容，在此感谢大家的观看！这里是店小二初阶数据结构笔记，希望对你在学习初阶数据结构中有所帮助！</font></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/524f166d839841fd5dc439135bef25da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【一步一步了解Java系列】：认识String类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef1ba9c978d2c182f06e82ba1ee3d6b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">打造工业操作系统开源开放体系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>