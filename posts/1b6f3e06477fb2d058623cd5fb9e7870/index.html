<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EureKa是什么? - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1b6f3e06477fb2d058623cd5fb9e7870/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="EureKa是什么?">
  <meta property="og:description" content="Eureka 是一个源于 Netflix 公司的开源项目，主要用于实现服务注册和服务发现的功能。它是构建分布式系统中的微服务架构的一个关键组件。下面是对 Eureka 的解释：
基本概念 Eureka 是基于 REST 的服务，主要用于管理微服务架构中的服务实例的注册与发现。它提供了服务注册中心，让各个微服务可以在其中注册自己的信息（比如 IP 地址、端口号、健康状况等），并能够发现其他已注册的服务实例。
核心组件 Eureka Server：作为服务注册中心，负责接收来自各个微服务实例的注册信息，并提供一个可供查询服务实例的接口。Eureka Server 通过复制多个实例来实现高可用性。
Eureka Client：集成在每个微服务应用中，用于向 Eureka Server 注册自身服务实例信息以及从 Eureka Server 获取其他服务实例的信息，从而实现服务间的调用。
关键特性 服务注册：微服务启动时，Eureka Client 会将服务实例的元数据（如主机名、IP地址、端口、健康检查URL等）注册到 Eureka Server。
服务发现：客户端可以通过 Eureka Server 获取到注册的服务实例列表，实现服务间的动态路由与负载均衡。
心跳机制：Eureka Client 定期向 Eureka Server 发送心跳（默认每30秒），以维持服务实例的活性状态。如果心跳超时未更新，Eureka Server 会将该服务实例标记为不可用。
自我保护模式：当网络分区故障发生或者大量服务实例同时下线导致 Eureka Server 收不到心跳时，它会自动进入自我保护模式，停止从注册表中移除因心跳失败而看似不健康的实例，以避免因网络瞬时故障造成服务雪崩。
客户端缓存：Eureka Client 会缓存从 Eureka Server 获取到的服务实例信息，即使与 Eureka Server 的连接中断，也能根据缓存继续进行服务调用，提高了系统的容错性。
高可用部署：生产环境中，通常会部署多个 Eureka Server 实例并形成集群，以确保服务注册中心的高可用性。
使用场景 Eureka 主要适用于微服务架构中，特别是当系统由众多独立服务构成，且这些服务需要动态发现和调用对方时。它被广泛应用于构建高可用、可伸缩的云端应用和服务平台。
集成与配置 Eureka 被 Spring Cloud 框架集成，开发者可以通过简单的注解（如 @EnableEurekaServer 和 @EnableEurekaClient）在 Spring Boot 应用中启用 Eureka Server 或 Client，简化了配置和部署过程。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-29T10:09:07+08:00">
    <meta property="article:modified_time" content="2024-05-29T10:09:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EureKa是什么?</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Eureka 是一个源于 Netflix 公司的开源项目，主要用于实现服务注册和服务发现的功能。它是构建分布式系统中的微服务架构的一个关键组件。下面是对 Eureka 的解释：</p> 
<h4><a id="_2"></a>基本概念</h4> 
<p>Eureka 是基于 REST 的服务，主要用于管理微服务架构中的服务实例的注册与发现。它提供了服务注册中心，让各个微服务可以在其中注册自己的信息（比如 IP 地址、端口号、健康状况等），并能够发现其他已注册的服务实例。</p> 
<h4><a id="_5"></a>核心组件</h4> 
<ul><li> <p><strong>Eureka Server</strong>：作为服务注册中心，负责接收来自各个微服务实例的注册信息，并提供一个可供查询服务实例的接口。Eureka Server 通过复制多个实例来实现高可用性。</p> </li><li> <p><strong>Eureka Client</strong>：集成在每个微服务应用中，用于向 Eureka Server 注册自身服务实例信息以及从 Eureka Server 获取其他服务实例的信息，从而实现服务间的调用。</p> </li></ul> 
<h4><a id="_10"></a>关键特性</h4> 
<ol><li> <p><strong>服务注册</strong>：微服务启动时，Eureka Client 会将服务实例的元数据（如主机名、IP地址、端口、健康检查URL等）注册到 Eureka Server。</p> </li><li> <p><strong>服务发现</strong>：客户端可以通过 Eureka Server 获取到注册的服务实例列表，实现服务间的动态路由与负载均衡。</p> </li><li> <p><strong>心跳机制</strong>：Eureka Client 定期向 Eureka Server 发送心跳（默认每30秒），以维持服务实例的活性状态。如果心跳超时未更新，Eureka Server 会将该服务实例标记为不可用。</p> </li><li> <p><strong>自我保护模式</strong>：当网络分区故障发生或者大量服务实例同时下线导致 Eureka Server 收不到心跳时，它会自动进入自我保护模式，停止从注册表中移除因心跳失败而看似不健康的实例，以避免因网络瞬时故障造成服务雪崩。</p> </li><li> <p><strong>客户端缓存</strong>：Eureka Client 会缓存从 Eureka Server 获取到的服务实例信息，即使与 Eureka Server 的连接中断，也能根据缓存继续进行服务调用，提高了系统的容错性。</p> </li><li> <p><strong>高可用部署</strong>：生产环境中，通常会部署多个 Eureka Server 实例并形成集群，以确保服务注册中心的高可用性。</p> </li></ol> 
<h4><a id="_23"></a>使用场景</h4> 
<p>Eureka 主要适用于微服务架构中，特别是当系统由众多独立服务构成，且这些服务需要动态发现和调用对方时。它被广泛应用于构建高可用、可伸缩的云端应用和服务平台。</p> 
<h4><a id="_26"></a>集成与配置</h4> 
<p>Eureka 被 Spring Cloud 框架集成，开发者可以通过简单的注解（如 <code>@EnableEurekaServer</code> 和 <code>@EnableEurekaClient</code>）在 Spring Boot 应用中启用 Eureka Server 或 Client，简化了配置和部署过程。</p> 
<h4><a id="_28"></a>工作原理与应用场景</h4> 
<h4><a id="1__29"></a>1. <strong>详细架构</strong></h4> 
<ul><li> <p><strong>Eureka Server集群</strong>: Eureka Server本身设计为可集群部署，以提高可用性。每个Eureka Server都是对等的，它们之间通过复制来进行数据同步，保证了服务注册信息的一致性。集群中的每个节点都是独立的，没有单点故障问题。</p> </li><li> <p><strong>多区域支持</strong>：Eureka支持多数据中心部署，可以配置不同的区域（Zone）。每个区域包含一个或多个Eureka Server实例，它们之间通过特定的复制策略（如只复制到同区域的其他Eureka Server）来减少跨区域的网络延迟和提高容灾能力。</p> </li></ul> 
<h4><a id="2__35"></a>2. <strong>高级配置</strong></h4> 
<ul><li> <p><strong>租约（Lease）管理</strong>：Eureka中的每个服务实例注册都有一个租约概念，包括租约期限（lease duration）和续租间隔（lease renewal interval）。服务实例定期发送心跳来续租，若超过一定时间未续租，则会被视为宕机并从注册表中剔除。这个机制允许Eureka快速感知服务实例的状态变化。</p> </li><li> <p><strong>自我保护模式</strong>：在面临网络分区（Network Partition）等异常情况时，Eureka Server会自动进入自我保护模式，暂停服务剔除逻辑，以避免因网络瞬时故障导致的健康服务被误判为不可用。此模式通过比较最近几分钟内注册服务的心跳失败比例来触发。</p> </li><li> <p><strong>安全配置</strong>：Eureka支持通过Spring Security等框架进行安全配置，允许对注册和发现操作进行身份验证和授权，增加安全性。</p> </li></ul> 
<h4><a id="3_API_43"></a>3. <strong>API和监控</strong></h4> 
<ul><li> <p><strong>RESTful API</strong>：Eureka提供了一套REST API，允许外部系统查询服务实例信息、注册新服务等操作，便于集成到现有系统或进行自动化运维。</p> </li><li> <p><strong>监控与指标</strong>：Eureka Server提供了丰富的监控指标，如服务实例数量、每秒心跳数等，可以通过集成Prometheus、Grafana等监控工具进行可视化监控和报警设置。</p> </li></ul> 
<h4><a id="4_Spring_Cloud_49"></a>4. <strong>与Spring Cloud的集成</strong></h4> 
<ul><li> <p><strong>服务发现</strong>：Spring Cloud Eureka客户端自动集成到Spring Boot应用中，通过<code>@EnableEurekaClient</code>注解即可开启服务发现功能。应用启动时会自动向Eureka Server注册，并在需要时从Eureka获取服务实例列表进行服务调用。</p> </li><li> <p><strong>负载均衡</strong>：Spring Cloud Ribbon或Spring Cloud LoadBalancer可以与Eureka集成，实现客户端侧的负载均衡，自动选择一个可用的服务实例进行请求转发。</p> </li><li> <p><strong>断路器与服务降级</strong>：结合Hystrix或Spring Cloud Circuit Breaker，可以在服务调用链路中添加断路器逻辑，防止服务雪崩效应，实现服务的稳定性和可靠性。</p> </li></ul> 
<h4><a id="5__57"></a>5. <strong>与其他服务发现方案对比</strong></h4> 
<p>相比于Consul、Zookeeper等其他服务发现方案，Eureka更专注于服务发现的高可用性和低延迟，牺牲了一定的数据一致性，采用最终一致性模型。Eureka的自我保护机制也是其独特之处，更适合构建容错性强的微服务架构。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/102d69e4e29716b123665428263f38e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;第二十一弹---vector深度剖析及模拟实现(上)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0de2f45c4af8b8154e57b1738d75f505/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AIGC如何改变人类生活20240529</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>