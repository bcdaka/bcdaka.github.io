<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL：查询（万字超详细版） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/194690977d8b35572b7b34bf7324a820/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MySQL：查询（万字超详细版）">
  <meta property="og:description" content="💎所属专栏： MySQL
💎1. 单表查询 💎1.1 全列查询和指定列查询 全列查询：
select * from exam; 在实际开发中不要使用 * 来进行查询，因为数据库会很大，影响效率 指定列查询：
select id,name,math from exam; 查询的结果是一个表达式，例如，在查询命令中添加一个数值，每一列都会有这个数值
select id ,name ,10 from exam; 之后，可以通过as关键字来为查询结果中的列指定别名，as和引号可以省略，但如果别名中存在空格就不能省略引号了
select id as &#39;编号&#39; ,name as &#39;姓名&#39; from exam; 列与列之间还可以进行运算：
select chinese &#43; math &#43; english as &#39;总分&#39; from exam; 还可以直接加上指定的数字
select math &#43; 10 from exam; 💎1.2 去重查询 去重查询是通过关键字 distinct 来实现的，在之前的math中，是存在一个重复的98的，我们来试验一下去重查询操作：
select distinct math from exam; 有一点需要注意的是，在查询结果中，每一列都相同才认为是重复数据，刚刚只查询的是math这一列，这次加上id试试：
可以看到，这一次重复的98并没有被去掉，因为id不同
💎1.3 排序查询 对于多字段，按照字段的前后顺序，如果第一个字段相同，按照第二个字段进行排序">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-15T23:27:38+08:00">
    <meta property="article:modified_time" content="2024-08-15T23:27:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL：查询（万字超详细版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p> </p> 
 <p class="img-center"><img alt="" height="417" src="https://images2.imgbox.com/49/a3/gUEPWtho_o.gif" width="755"></p> 
</blockquote> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>  💎所属专栏</strong>： <a href="https://blog.csdn.net/2202_76097976/category_12751130.html" title="MySQL">MySQL</a></span></p> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/bf/aa/7TTjzyls_o.gif"></p> 
<p> </p> 
<h2 style="background-color:transparent;">💎1. 单表查询</h2> 
<p class="img-center"><img alt="" height="238" src="https://images2.imgbox.com/bc/21/GFFJccTE_o.png" width="572"></p> 
<h3 style="background-color:transparent;">💎1.1 全列查询和指定列查询</h3> 
<p>全列查询：</p> 
<pre><code class="language-sql">select * from exam;</code></pre> 
<p class="img-center"><img alt="" height="365" src="https://images2.imgbox.com/ac/32/qTIBKJtI_o.png" width="1104"></p> 
<p>在实际开发中不要使用 * 来进行查询，因为数据库会很大，影响效率 </p> 
<p>指定列查询：</p> 
<pre><code class="language-sql">select id,name,math from exam;</code></pre> 
<p class="img-center"><img alt="" height="307" src="https://images2.imgbox.com/84/19/00V4zaGd_o.png" width="600"></p> 
<p>查询的结果是一个表达式，例如，在查询命令中添加一个数值，每一列都会有这个数值</p> 
<pre><code class="language-sql">select id ,name ,10 from exam;</code></pre> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/2c/2d/6ckl2Kqw_o.png" width="374"></p> 
<p></p> 
<p></p> 
<p> 之后，可以通过<strong>as关键字</strong>来为查询结果中的列指定别名，as和引号可以省略，但如果别名中存在空格就不能省略引号了</p> 
<pre><code class="language-sql">select id as '编号' ,name as '姓名' from exam;</code></pre> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/b1/27/xecQafR0_o.png" width="247"></p> 
<p></p> 
<p>列与列之间还可以进行运算：</p> 
<pre><code class="language-sql">select chinese + math + english as '总分' from exam;</code></pre> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/5e/67/XO5hh9kt_o.png" width="138"></p> 
<p> 还可以直接加上指定的数字</p> 
<pre><code class="language-sql">select math + 10 from exam;</code></pre> 
<h3 style="background-color:transparent;">💎1.2 去重查询</h3> 
<p><img alt="" height="93" src="https://images2.imgbox.com/10/cf/5o2diCoZ_o.png" width="403"></p> 
<p>去重查询是通过关键字 <strong>distinct</strong> 来实现的，在之前的math中，是存在一个重复的98的，我们来试验一下去重查询操作：</p> 
<pre><code class="language-sql">select distinct math from exam;</code></pre> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/de/c3/yDX8e5wK_o.png" width="297"></p> 
<p>有一点需要注意的是，在查询结果中，每一列都相同才认为是重复数据，刚刚只查询的是math这一列，这次加上id试试：</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/18/5d/8xLhXg40_o.png" width="254"></p> 
<p>可以看到，这一次重复的98并没有被去掉，因为id不同</p> 
<h3 style="background-color:transparent;">💎1.3 排序查询</h3> 
<p class="img-center"><img alt="" height="186" src="https://images2.imgbox.com/64/b8/Ebd5lAYk_o.png" width="787"></p> 
<p> 对于多字段，按照字段的前后顺序，如果第一个字段相同，按照第二个字段进行排序</p> 
<pre><code class="language-sql">select math from exam order by math desc ;</code></pre> 
<p> <img alt="" height="200" src="https://images2.imgbox.com/db/56/f9tP6GmT_o.png" width="145"></p> 
<p> 如果数据为 null 就认为是最小的，升序排最前面，降序排最后面</p> 
<p>还可以加上之前的表达式和别名进行排序</p> 
<pre><code class="language-sql">select id ,name, math + chinese + english as '总分' from exam order by math + chinese + english desc;</code></pre> 
<p> 前面已经定义了别名，所以后面可以直接用</p> 
<pre><code class="language-sql">select id ,name, math + chinese + english as '总分' from exam order by 总分 desc;</code></pre> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/f0/18/H6gIIVuI_o.png" width="346"></p> 
<p> 关于null的特殊情况：</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1.不论和任何值相加，结果都是null</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>2.始终被看作false</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>3.null 并不等同于 0</strong></span></p> 
</blockquote> 
<p> 所以说，如果想上面的按照总分排序，如果其中一门为Null,那么他的总分就是null</p> 
<p>最后还可以通过多个字段进行排序，排序的优先级就按照书写的顺序进行排列</p> 
<p>例如：先按数学降序排列，再按语文升序排列，再按英语顺序排列</p> 
<p></p> 
<pre><code class="language-sql">select id, name, math, chinese,english
from exam
order by math desc, chinese asc, english asc;</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="327" src="https://images2.imgbox.com/da/8f/gzmJRD84_o.png" width="1048"></p> 
<h3 style="background-color:transparent;">💎1.4 条件查询</h3> 
<p class="img-center"><img alt="" height="95" src="https://images2.imgbox.com/63/e2/xqiUmIc2_o.png" width="451"></p> 
<h4 style="background-color:transparent;"> 💎1.4.1 比较运算符</h4> 
<p> 先来看比较运算符</p> 
<p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/4f/7d/SOBnJsux_o.png" width="533"></p> 
<p><span style="color:#956fe7;"><strong>前面的大于等于这些符号和java中一样，就不多说了，而java中相等是用 "==" 表示的，mysql中是 "=" ，判断不等于的这两个写法都可以</strong></span></p> 
<p>这里有一些小细节需要注意：</p> 
<pre><code class="language-sql">-- 查询英语不及格的
select name ,english from exam where english &lt; 60;</code></pre> 
<p> 如果表中有null，不参与筛选，所以最终的结果不会包括null</p> 
<pre><code class="language-sql">-- 查询英语比语文好的
select * from exam where english &gt; chinese;</code></pre> 
<p> 在上面的比较方式中，同一行的数据是可以比较的，但是不能跨行比较</p> 
<pre><code class="language-sql">select name, english + math + chinese as total
from exam
where english + math + chinese &lt; 250
order by total desc ;</code></pre> 
<p>如果where 后面使用了表达式的话要写完整的表达式，不能写别名 </p> 
<p>原因：和SQL的执行顺序有关</p> 
<p class="img-center"><img alt="" height="207" src="https://images2.imgbox.com/d1/68/U9NsbhRP_o.png" width="755"></p> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>1.如果要在数据库中查找某些数据，首先要确定表，先执行</strong></span><span style="color:#fe2c24;"><strong>from</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>2.在查询过程中，要根据指定的查询条件把符合条件的数据过滤出来，这时执行的是</strong></span><span style="color:#fe2c24;"><strong>where</strong></span><span style="color:#956fe7;"><strong>字句</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>3.执行</strong></span><span style="color:#fe2c24;"><strong>select</strong></span><span style="color:#956fe7;"><strong>后面的指定的列，这些列最终要加到结果的展示集里</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>4.根据</strong></span><span style="color:#fe2c24;"><strong>order by</strong></span><span style="color:#956fe7;"><strong> 子句的列名和排序规则进行最后的排序</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>根据以上顺序可以推断出，在执行where语句时，还没到select里的total，所以用不了</strong></span></p> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>&lt;=&gt;</td><td>表示等于，是专门针对null判断的，例如null &lt;=&gt; null 的结果为1</td></tr></tbody></table> 
<p> null的判断是不能用 "=" 判断的</p> 
<p></p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/01/89/4WIpWL3U_o.png" width="445"></p> 
<p>接下来的 between...and...和 in (...) 都是字面意思，分别用来判断是否在一个区间和是否在括号中的列表中</p> 
<pre><code class="language-sql">select 1 in (1,2,3);
select 2 between 1 and 4;</code></pre> 
<p>而like表示模糊匹配的意思是，按照单个字符和任意个字符进行匹配，来看一个例子：</p> 
<p class="img-center"><img alt="" height="488" src="https://images2.imgbox.com/d9/df/aePMjddl_o.png" width="1200"></p> 
<p><strong> 当用 '%' 表示的是找出姓张的人，任意字符也就是张后面可以跟任意个字符，'_' 表示单个字符，也就是张后面只能跟一个字符</strong></p> 
<p>最后还有一个判断是否为null的命令</p> 
<p class="img-center"><img alt="" height="118" src="https://images2.imgbox.com/33/9d/fEzplIbj_o.png" width="600"></p> 
<h4 style="background-color:transparent;">💎1.4.2 逻辑运算符</h4> 
<p> 接下来看逻辑运算符</p> 
<table><tbody><tr><td>运算符</td><td>说明</td><td>对应Java中的逻辑运算符</td></tr><tr><td>AND</td><td>多个条件必须都为 TRUE(1)，结果才是 TRUE(1)</td><td>&amp;&amp;</td></tr><tr><td>OR</td><td>任意一个条件为 TRUE(1), 结果为 TRUE(1)</td><td>||</td></tr><tr><td>NOT</td><td>条件为 TRUE(1)，结果为 FALSE(0)</td><td>!</td></tr></tbody></table> 
<pre><code class="language-sql">-- 语文大于80或英语大于80
select name, english, chinese
from exam
where english &gt; 80
   or chinese &gt; 80;</code></pre> 
<p>  or 的话是任意一个条件为true 就符合，哪怕另一个条件为null不参与比较</p> 
<pre><code class="language-sql">-- 语文英语都大于80分
select name, english, chinese
from exam
where english &gt; 80
  and chinese &gt; 80;</code></pre> 
<p>下面来分析一下and 和 or 的优先级：</p> 
<pre><code class="language-sql">-- 比较and 和 or 的运算优先级
select name, chinese, math, english
from exam
where chinese &gt; 80
   or math &gt; 70 and english &gt; 70;

select name, chinese, math, english
from exam
where (chinese &gt; 80 or math &gt; 70)
  and english &gt; 70
</code></pre> 
<p>通过对比发现，and 和 or 和 java 中的优先级是一样的，都是and &gt; or ，不过还是建议根据需求加括号 </p> 
<p class="img-center"><img alt="" height="431" src="https://images2.imgbox.com/0d/30/PVks1h9u_o.png" width="1200"></p> 
<h3 style="background-color:transparent;"> 💎1.5 分页查询</h3> 
<p class="img-center"><img alt="" height="90" src="https://images2.imgbox.com/dc/b8/45mXWuaA_o.png" width="511"></p> 
<p>在实现已经提到过，如果直接通过select * from不加限制来查询全部的数据是不安全的，通过分页查询可以有效的控制一次查询出来的结果集中的记录条数，可以有效的减少数据库服务器的压力，也有利于用户查看，例如我们经常见到的这种就是用到了分页查询</p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/ea/10/LT3Q4JCd_o.png" width="651"></p> 
<p> 例如从第0条开始，往后读取2条数据有一下这几种写法：</p> 
<pre><code class="language-sql">-- 从第0条开始往后读取2条数据
select *
from exam
order by id
limit 2;

select *
from exam
order by id
limit 0,2;

select * from exam
order by id
limit 2 offset 0;</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/6d/bd/NgDQ15ap_o.png" width="522"></p> 
<p> 可以通过下面这个公式来计算第 s 页所需要的偏移量 n:</p> 
<p><strong>n = (s - 1) * 每页显示的记录数</strong></p> 
<p> 如果说指定的起始位置超出了整个表的范围就会返回一个空的结果集</p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/9e/76/zEVU0jsa_o.png" width="1121"></p> 
<h3 style="background-color:transparent;">💎1.6 分组查询</h3> 
<p class="img-center"><img alt="" height="82" src="https://images2.imgbox.com/c5/82/ojoatQDV_o.png" width="770"></p> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>where 和 having的区别：</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>执行时机不同：where 是分组前进行过滤，不满足where条件不进行分组，having是对分组后的结果进行过滤</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>判断条件不同：where不能对聚合函数进行判断，而having可以</strong></span></p> 
</blockquote> 
<pre><code class="language-sql">-- 根据角色进行分组，显示出角色和平均薪资,使用round四舍五入
select role, round(avg(salary), 2)
from emp
group by role;</code></pre> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/0d/62/20fcJepl_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-sql">-- 讲分组后的数据根据薪资进行升序排列
select role, round(avg(salary), 2) as 平均薪资
from emp
group by role
order by 平均薪资 ASC;</code></pre> 
<p class="img-center"><img alt="" height="177" src="https://images2.imgbox.com/5b/90/Krwe7tlX_o.png" width="457"></p> 
<p><strong>通过having 对分组后的数据进行过滤：</strong></p> 
<pre><code class="language-sql">-- 对分组后的数据进行过滤
select role, round(avg(salary), 2) as 平均薪资
from emp
group by role
having 平均薪资 &gt; 10000
   and 平均薪资 &lt; 100000;</code></pre> 
<p class="img-center"><img alt="" height="109" src="https://images2.imgbox.com/c7/a5/822fttsT_o.png" width="468"></p> 
<p>综合小练习：</p> 
<p>查询平均薪资低于10000的角色和平均薪资</p> 
<pre><code class="language-sql">-- 显示平均薪资低于10000的角色和其平均薪资
select role ,avg(salary) as 平均薪资
from emp
group by role
having 平均薪资 &lt; 10000;</code></pre> 
<p><img alt="" height="139" src="https://images2.imgbox.com/b7/b6/pRSP0x8H_o.png" width="466"></p> 
<h2 style="background-color:transparent;">💎2. 多表查询</h2> 
<p>联合查询就是联合多个表进行查询，为了消除表中字段的依赖关系，设计数据时把表进行拆分，这时就会导致一条SQL语句查找出来的数据不够完整，就可以通过联合查询把关系中的数据全部查出来，在一个数据行中显示详细信息</p> 
<blockquote> 
 <p>步骤：</p> 
 <p>1.首先确定哪几张表要参与查询</p> 
 <p>2.根据表于表之间的主外键关系，确定过滤条件</p> 
 <p>3.精简查询字段</p> 
</blockquote> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/01/5a/PJxbO6Jm_o.png" width="363"></p> 
<p>例如上面的两个表，通过联合查询获取下面的表的这种信息：</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/9e/61/9EgbKd1Z_o.png" width="502"></p> 
<h3 style="background-color:transparent;">💎2.1 内连接</h3> 
<p><img alt="" height="113" src="https://images2.imgbox.com/40/f1/hMsX2tLa_o.png" width="1076"></p> 
<p>1. 取多张表的笛卡尔集</p> 
<p>分别创建上面的class，student表，并添加数据：</p> 
<pre><code class="language-sql">create table class
(
    id   bigint primary key auto_increment,
    name varchar(20)
);

create table student
(
    id       bigint primary key auto_increment,
    name     varchar(20),
    gender   varchar(1),
    class_id bigint,
    foreign key (class_id) references class (id)
);
insert into class(id, name)
values (1, 'Java01'),
       (2, 'Java02');
       
insert into student(id, name, gender, class_id)
values (1, '张三', '男', 1),
       (2, '李四', '男', 2),
       (3, '王五', '女', 2),
       (4, '赵六', '男', 1);</code></pre> 
<p>通过下面的这个命令可以查询到两张表取笛卡尔集后的数据：</p> 
<pre><code class="language-sql">select * from student,class;</code></pre> 
<p> 但是会发现，有四条数据是不匹配的</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/c4/09/LbBLBbDS_o.png" width="1200"></p> 
<p>2.通过连接条件过滤掉无效的数据</p> 
<p>由于这两个表是存在主外键关系的，只需要判断主外键字段是否相等</p> 
<pre><code class="language-sql">-- 通过连接条件过滤掉无效的数据
select *
from student,
     class
where student.class_id = class.id;</code></pre> 
<p><img alt="" height="180" src="https://images2.imgbox.com/3a/04/tvwbfWkG_o.png" width="1200"></p> 
<p>这样，得到的就都是正确的数据了 </p> 
<p>3.通过指定列查询精简结果集</p> 
<pre><code class="language-sql">-- 指定列查询精简结果集
select student.id, student.name, class.name
from student,
     class
where student.class_id = class.id;</code></pre> 
<p> 通过指定列查询可以使结果更加精简，这也就是内连接的第一种写法</p> 
<p class="img-center"><img alt="" height="180" src="https://images2.imgbox.com/44/d0/gJ5G9aub_o.png" width="754"></p> 
<p> 还可以加入别名的方式进行简化SQL语句</p> 
<pre><code class="language-sql">-- 别名方式简化
select s.id, s.name, c.name
from student s,
     class c
where s.class_id = c.id;</code></pre> 
<p>第二种写法：</p> 
<p><span style="color:#fe2c24;"><strong>通过关键字 inner join 来实现的，from 表1 inner join 表2 意思是从表1到表2建立内连接，关注点是表1，从表1里面找表2的连接</strong></span></p> 
<pre><code class="language-sql">-- 写法2
select s.id, s.name, c.name
from student s
         inner join class c on class_id = c.id;</code></pre> 
<p>inner 也可以省略</p> 
<pre><code class="language-sql">-- inner可以省略
select s.id, s.name, c.name
from student s
         join class c on class_id = c.id;</code></pre> 
<h4 style="background-color:transparent;">💎2.1.1小练习</h4> 
<p>创建的表的部分内容如下</p> 
<p class="img-center"><img alt="" height="374" src="https://images2.imgbox.com/ca/82/YimLWkdG_o.png" width="1200"></p> 
<p style="background-color:transparent;"><strong>找出许仙的成绩：</strong></p> 
<p>首先确定要联合的表，这里联合student和score表，然后对目标表去笛卡尔集，再通过连接条件进行过滤，再精确字段</p> 
<pre><code class="language-sql">select *
from student,
     score
where student.student_id = score.student_id
  and name = '许仙';</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="191" src="https://images2.imgbox.com/cf/c6/hjmnyNtO_o.png" width="1200"></p> 
<p>此时发现显示的字段有点多，再根据要求查询指定字段</p> 
<pre><code class="language-sql">-- 指定字段
select name, score
from student,
     score
where student.student_id = score.student_id
  and name = '许仙';</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="165" src="https://images2.imgbox.com/ef/ac/zoeoUGnU_o.png" width="419"></p> 
<p style="background-color:transparent;"><strong>查询每位同学的总成绩和学生信息：</strong></p> 
<p>和前面步骤一样</p> 
<pre><code class="language-sql">select student.student_id, sum(score.score)
from student,
     score
where student.student_id = score.student_id;
</code></pre> 
<p>之后，由于求的是每个同学的总分，所以还需要按照student_id进行分组，再精简字段</p> 
<p></p> 
<pre><code class="language-sql">select student.student_id,student.name, sum(score.score)
from student,
     score
where student.student_id = score.student_id
group by student.student_id;</code></pre> 
<p><img alt="" height="289" src="https://images2.imgbox.com/e6/15/Wu35QOLK_o.png" width="866"></p> 
<p style="background-color:transparent;"><strong>查询每位同学每一门的成绩：</strong></p> 
<p>还是按照之前的步骤进行，只不过这次需要用到三张表</p> 
<pre><code class="language-sql">select student.student_id,student.name,course.name,score.score
from student,
     score,
     course
where student.student_id = score.student_id
  and score.course_id = course.course_id;</code></pre> 
<p>使用  [inner] join on 的形式：</p> 
<pre><code class="language-sql">select st.student_id, st.name, c.name, sc.score
from student st
     inner
         join score sc
              on st.student_id = sc.student_id
         join course c
              on c.course_id = sc.course_id;</code></pre> 
<h3 style="background-color:transparent;">💎2.2 外连接</h3> 
<p>外连接又分为左外连接和右外连接</p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/c8/83/QrF4Kfow_o.png" width="416"></p> 
<p>内连接和外连接的区别：</p> 
<p>内连接只会查询到两个表的交集部分，外连接可以查询左边或右边整个表 </p> 
<h4 style="background-color:transparent;">💎2.2.1右外连接</h4> 
<p class="img-center"><img alt="" height="371" src="https://images2.imgbox.com/2d/f3/1reAJWps_o.png" width="987"></p> 
<p>右链接就是以 join 右边的表为基准，显示这个表的全部数据，左边的表如果没有匹配的记录的话会以null作为补充</p> 
<pre><code class="language-sql">-- 使用右外连接
select student.student_id, student.name, class.class_id, class.name
from student
         right join class on student.class_id = class.class_id;</code></pre> 
<p><strong><span style="color:#fe2c24;">这里从 student 表到 class 表建立右外连接，没有学生的班级id也会显示出来，用null代替</span></strong></p> 
<p><strong><span style="color:#fe2c24;">右边class表中的数据都显示出来了，左边没有与之对应的行用null补充 </span></strong></p> 
<p> <img alt="" height="262" src="https://images2.imgbox.com/1d/8c/GQWNtDIM_o.png" width="867"></p> 
<h4 style="background-color:transparent;"> 💎2.2.2 左外连接</h4> 
<p>需求：查询哪位同学没有参加考试</p> 
<p>也就是在student表里有记录，在score表里没有对应的记录</p> 
<p>这时就可以使用左连接，把student表作为基准表</p> 
<pre><code class="language-sql">-- 左外连接
select student.student_id, student.name, score
from student
         left join score on student.student_id = score.student_id;</code></pre> 
<p> </p> 
<p class="img-center"><img alt="" height="205" src="https://images2.imgbox.com/72/44/qwBdIacO_o.png" width="559"></p> 
<h3 style="background-color:transparent;">💎2.3 自连接</h3> 
<p>自连接可以实现行与行之间的比较功能</p> 
<p class="img-center"><img alt="" height="67" src="https://images2.imgbox.com/19/28/7ECO1ONy_o.png" width="567"></p> 
<p>需求：找出计算机原理课程成绩大于Java的</p> 
<p>还是和之前的步骤一样，只不过这里由于是自连接，取笛卡尔集的时候需要确定别名</p> 
<pre><code class="language-sql">-- 找出计算机原理的成绩大于Java的
-- 取笛卡尔集
use test3;
select *
from score s1,
     score s2
where s1.student_id = s2.student_id;
-- 确定过滤条件
select *
from score s1,
     score s2
where s1.student_id = s2.student_id
and s1.course_id = 3 and s2.course_id = 1
and s1.score &gt; s2.score;</code></pre> 
<p>自连接查询可以是内连接，也可以是外连接，在下面这张员工表中</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>id</td><td>name</td><td>job</td><td>manager_id</td></tr><tr><td>1</td><td>张三</td><td>总裁</td><td> <p>null</p> </td></tr><tr><td>2</td><td>李四</td><td>项目经理</td><td> <p>1</p> </td></tr><tr><td>3</td><td>王五</td><td>工程师</td><td>2</td></tr></tbody></table> 
<p>来看内连接的例子：</p> 
<p>查询员工及其所属领导的名字</p> 
<pre><code class="language-sql">select a.name, b.name
from emp a,
     emp b
where a.manager_id = b.id;</code></pre> 
<p>查询所有员工及其领导的名字（如果员工没有领导也要表示出来）</p> 
<pre><code class="language-sql">select a.name, b.name
from emp a
         left join emp b on a.manager_id = b.id;</code></pre> 
<h3 style="background-color:transparent;">💎2.4 子查询</h3> 
<p>SQL语句中嵌套select语句称为嵌套查询，又叫子查询</p> 
<p class="img-center"><img alt="" height="103" src="https://images2.imgbox.com/1e/18/pi4BAe95_o.png" width="565"></p> 
<p>根据查询的结果又可以分为：标量子查询（查询结果为单个值），列子查询（查询结果为一列），行子查询（查询结果为一行），表子查询（查询结果为多行多列） </p> 
<h4 style="background-color:transparent;">💎2.4.1 单行子查询 </h4> 
<p>需求：查询与许仙一个班级的同学</p> 
<p>如果不适用子查询的话，就需要用多条SQL语句来查询</p> 
<pre><code class="language-sql">-- 查找和许仙一个班级的同学
select class_id from student where name = '许仙';
-- 得出许仙的 class_id 是 1
select name from student where class_id = 1;</code></pre> 
<p> 下面来看子查询的形式</p> 
<pre><code class="language-sql">select *
from student
where class_id = (select class_id from student where name = '许仙')
  -- 也可以对子查询的整体加上再加上过滤条件
  and name != '许仙';</code></pre> 
<p>要注意的是外层条件的列，与同层查询条件的列必须要匹配 </p> 
<h4 style="background-color:transparent;">💎2.4.2 多行子查询</h4> 
<p>需求：获取语文和英文的成绩信息</p> 
<p>如果不用子查询，还是需要两步进行，获取课程的 id 之后，再根据 id 去查找成绩信息</p> 
<pre><code class="language-sql">-- 获取课程 id
select course_id
from course
where name = '语文'
   or name = '英文';

select *
from score
where course_id = 4
   or course_id = 6;</code></pre> 
<p>由于这里查询到的是多行的信息，所以在进行子查询的时候需要使用 IN（） 来判断</p> 
<pre><code class="language-sql">select *
from score
where course_id in (select course_id
                    from course
                    where name = '语文'
                       or name = '英文');</code></pre> 
<h4 style="background-color:transparent;">💎2.4.3 多列子查询 </h4> 
<p> 需求：查询重复的分数</p> 
<p>按照同一个学生，同一门课程，同样的成绩这三个列同时去分组，然后分组之后在 having字句中用count(*)判断分组中的记录数</p> 
<pre><code class="language-sql">select student_id, course_id, score
from score
group by student_id, course_id, score;

-- 加上having过滤条件
select student_id, course_id, score,count(*)
from score
group by student_id, course_id, score having count(*) &gt; 1;</code></pre> 
<p>多列分组查询</p> 
<pre><code class="language-sql">select *
from score
where (student_id, course_id, score) in (select student_id, course_id, score
                                         from score
                                         group by student_id, course_id, score
                                         having count(*) &gt; 1);</code></pre> 
<p>外层查询中的条件字段和内层查询中的结果对比，完全符合条件才可以 </p> 
<h3 style="background-color:transparent;">💎2.5 EXISTS关键字 </h3> 
<p>语法：select * from 表名 where exists (select * from 表名)；</p> 
<p>exists 后面括号中的查询语句，如果有结果返回就执行外层查询，如果返回的是一个空结果集，就不执行外层的查询</p> 
<pre><code class="language-sql">select *
from course
where exists(select * from course where course_id = 100);</code></pre> 
<p class="img-center"><img alt="" height="216" src="https://images2.imgbox.com/94/c7/AM97rY0X_o.png" width="944"></p> 
<pre><code class="language-sql">select *
from course
where exists(select null);</code></pre> 
<p> 对于上面的SQL语句，虽然exists中返回的是 null ，但不是空结果集，所以还会执行外层查询</p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/41/29/Tgq5Ykjk_o.png" width="1035"> </p> 
<h3 style="background-color:transparent;">💎2.6 临时表查询</h3> 
<p>在 from 子句中使用子查询，就是把一个子查询当做一个临时表来使用，下面还是通过一个例子来介绍</p> 
<p>需求：查询所有比"中文系2019级3班"平均分高的成绩信息</p> 
<p>首先获取 '' 中文系2019级3班"的平均分，将其看做临时表</p> 
<pre><code class="language-sql">-- 获取平均分作为临时表
select avg(sc.score)
from score sc,
     student st,
     class c
where c.class_id = st.class_id
and st.student_id = sc.student_id
and c.name = '中文系2019级3班';</code></pre> 
<p> 接下来用表中的真实成绩和临时表比较</p> 
<pre><code class="language-sql">-- 用表中的真实成绩和临时表比较
select *from score sc,
   (select avg(sc.score) score -- 这里要起别名
from score sc,
     student st,
     class c
where c.class_id = st.class_id
and st.student_id = sc.student_id
and c.name = '中文系2019级3班') tmp
where sc.score &gt; tmp.score;</code></pre> 
<p class="img-center"><img alt="" height="151" src="https://images2.imgbox.com/f9/67/oAP9r6JU_o.png" width="1200"></p> 
<h2 style="background-color:transparent;">💎3. 合并查询 </h2> 
<p>合并查询就是合并多个查询结果到一个结果集中</p> 
<p class="img-center"><img alt="" height="121" src="https://images2.imgbox.com/e8/0b/yrlvXmzg_o.png" width="291"></p> 
<p>需求：查找score_id &lt; 3 或者 score &gt; 90的同学 </p> 
<pre><code class="language-sql">-- 查找score_id &lt; 3 或者 score &gt; 90的同学
use test3;
select *
from score
where score_id &lt; 3;
select *
from score
where score &gt; 90;

-- 两次查询结果联合起来
select *
from score
where score_id &lt; 3
union
select *
from score
where score &gt; 90;</code></pre> 
<p>在单表中用 or 更加简洁，在多表中，就没有办法用 or ，如果最终的查询结果是从多个表中获取到的，必须要用 union 来进行合并  </p> 
<p>下面来看两张表的</p> 
<pre><code class="language-sql">-- 复制表结构
create table student2 like student;
insert into student2(student_id, sn, name, mail, class_id)
values (1, 2022, '张三', null, 2),
       (2, 2023, '李四', null, 1);
select * from student;
select * from student2;

-- 两张表数据在一个数据表中显示
select * from student union
select * from student2;</code></pre> 
<p> <img alt="" height="248" src="https://images2.imgbox.com/ab/cf/h2X8DDyJ_o.png" width="1141"></p> 
<p> 需要注意的是，合并显示的两张表的列名要匹配一致</p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">union 和 union all 的区别：</span></strong></p> 
 <p><strong><span style="color:#956fe7;">union 会自动去除合并结果中的重复行</span></strong></p> 
 <p><strong><span style="color:#956fe7;">union all 则会保留所有结果集中的所有行，包括重复的行</span></strong></p> 
</blockquote> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/f1/4a/zKbMbVos_o.gif"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94469cfac8f41fe69d386973c23b61db/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">初阶数据结构排序之插入排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/deb4621d8d4a2d410313d25fce6afbf2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">新手常见错误：java.lang.NumberFormatException: For input string: “xxxx“</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>