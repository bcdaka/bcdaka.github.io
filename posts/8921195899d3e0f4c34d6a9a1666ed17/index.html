<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024年前端最新最新的Vue面试题大全含源码级回答，吊打面试官系列，前端初级面试题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8921195899d3e0f4c34d6a9a1666ed17/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="2024年前端最新最新的Vue面试题大全含源码级回答，吊打面试官系列，前端初级面试题">
  <meta property="og:description" content="Vue 面试题 1.Vue 双向绑定原理
2.描述下 vue 从初始化页面–修改数据–刷新页面 UI 的过程？
3.你是如何理解 Vue 的响应式系统的?
4.虚拟 DOM 实现原理
5.既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进行 diff 检测差异?
6.Vue 中 key 值的作用？
7.Vue 的生命周期
8.Vue 组件间通信有哪些方式?
9.watch、methods 和 computed 的区别?
10.vue 中怎么重置 data?
11.组件中写 name 选项有什么作用？
12.vue-router 有哪些钩子函数?
13.route 和 router 的区别是什么？
14.说一下 Vue 和 React 的认识，做一个简单的对比
15.Vue 的 nextTick 的原理是什么？
16.Vuex 有哪几种属性?
17.vue 首屏加载优化
18.Vue 3.0 有没有过了解？
19.vue-cli 替我们做了哪些工作？
如果你觉得对你有帮助，可以戳这里获取：【大厂前端面试题解析&#43;核心总结学习笔记&#43;真实项目实战&#43;最新讲解视频】
return vm
}
…">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-14T01:08:25+08:00">
    <meta property="article:modified_time" content="2024-05-14T01:08:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024年前端最新最新的Vue面试题大全含源码级回答，吊打面试官系列，前端初级面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Vue__2"></a>Vue 面试题</h3> 
<p>1.Vue 双向绑定原理<br> 2.描述下 vue 从初始化页面–修改数据–刷新页面 UI 的过程？<br> 3.你是如何理解 Vue 的响应式系统的?<br> 4.虚拟 DOM 实现原理<br> 5.既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进行 diff 检测差异?<br> 6.Vue 中 key 值的作用？<br> 7.Vue 的生命周期<br> 8.Vue 组件间通信有哪些方式?<br> 9.watch、methods 和 computed 的区别?<br> 10.vue 中怎么重置 data?<br> 11.组件中写 name 选项有什么作用？<br> 12.vue-router 有哪些钩子函数?<br> 13.route 和 router 的区别是什么？<br> 14.说一下 Vue 和 React 的认识，做一个简单的对比<br> 15.Vue 的 nextTick 的原理是什么？<br> 16.Vuex 有哪几种属性?<br> 17.vue 首屏加载优化<br> 18.Vue 3.0 有没有过了解？<br> 19.vue-cli 替我们做了哪些工作？<br> <img src="https://images2.imgbox.com/fc/81/vBUfOjrN_o.png" alt=""></p> 
<p><strong><a href="https://bbs.csdn.net/forums/4304bb5a486d4c3ab8389e65ecb71ac0">如果你觉得对你有帮助，可以戳这里获取：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】</a></strong></p> 
<p>return vm</p> 
<p>}</p> 
<p>…</p> 
<p>Vue.prototype.$emit = function (event: string): Component {<!-- --></p> 
<p>const vm: Component = this</p> 
<p>…</p> 
<p>let cbs = vm._events[event]</p> 
<p>// 循环调用要触发的事件的回调函数数组</p> 
<p>if (cbs) {<!-- --></p> 
<p>cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs</p> 
<p>const args = toArray(arguments, 1)</p> 
<p>const info = <code>event handler for "${event}"</code></p> 
<p>for (let i = 0, l = cbs.length; i &lt; l; i++) {<!-- --></p> 
<p>invokeWithErrorHandling(cbs[i], vm, args, vm, info)</p> 
<p>}</p> 
<p>}</p> 
<p>return vm</p> 
<p>}</p> 
<p><strong>4. attrs、listeners</strong></p> 
<ul><li> <p><code>$attrs</code>: 包含了父作用域<code>没被props声明</code>绑定的数据，组件可以通过<code>v-bind="$attrs"</code>继续传给子组件</p> </li><li> <p><code>$listernes</code>: 包含了父作用域中的<code>v-on</code>(不含 .native 修饰器的) 监听事件，可以通过<code>v-on="$listeners"</code>传入内部组件</p> </li></ul> 
<p><strong>5. provide、inject</strong></p> 
<p>父组件通过provide注入一个依赖，其所有的子孙组件可以通过inject来接收。要注意的是官网有这一段话：</p> 
<blockquote> 
 <p>提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p> 
</blockquote> 
<p>所以Vue不会对provide中的变量进行响应式处理。要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。实际上在很多高级组件中都可以看到组件会将this通过provide传递给子孙组件，包括element-ui、ant-design-vue等。</p> 
<p><strong>6. vuex 状态管理实现通信</strong></p> 
<p>vuex是专为vue设计的状态管理模式。每个组件实例都有共同的store实例，并且store.state是响应式的，改变state唯一的办法就是通过在这个store实例上commit一个mutation，方便跟踪每一个状态的变化，实现原理在下面的vuex原理里有讲。</p> 
<p><a href="" rel="nofollow"></a>8.computed、watch、method有什么区别</p> 
<hr> 
<p>computed：有缓存，有对应的watcher，watcher有个lazy为true的属性，表示只有在模板里去读取它的值后才会计算，并且这watcher在初始化的时候会赋值dirty为true，watcher只有dirty为true的时候才会重新求值，重新求值后会将dirty置为false，false会直接返回watcher的value，只有下次watcher的响应式依赖有更新的时候，会将watcher的dirty再置为false，这时候才会重新求值，这样就实现了computed的缓存。</p> 
<p>watch：watcher的对象每次更新都会执行函数。watch 更适用于数据变化时的异步操作。如果需要在某个数据变化时做一些事情，使用watch。</p> 
<p>method: 将方法在模板里使用，每次视图有更新都会重新执行函数，性能消耗较大。</p> 
<p><a href="" rel="nofollow"></a>9.生命周期</p> 
<hr> 
<p>官网对生命周期的说明：</p> 
<blockquote> 
 <p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p> 
</blockquote> 
<p>生命周期就是每个Vue实例完成初始化、运行、销毁的一系列动作的钩子。</p> 
<p>基本上可以说8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p> 
<ul><li> <p>创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。</p> </li><li> <p>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</p> </li><li> <p>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</p> </li><li> <p>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p> </li></ul> 
<p>结合源码再理解，在源码中生命周期钩子是用callHook函数调用的。看下callHook函数：</p> 
<p>function callHook (vm: Component, hook: string) {<!-- --></p> 
<p>pushTarget()</p> 
<p>const handlers = vm.$options[hook]</p> 
<p>const info = <code>${hook} hook</code></p> 
<p>if (handlers) {<!-- --></p> 
<p>for (let i = 0, j = handlers.length; i &lt; j; i++) {<!-- --></p> 
<p>invokeWithErrorHandling(handlers[i], vm, null, vm, info)</p> 
<p>}</p> 
<p>}</p> 
<p>if (vm._hasHookEvent) {<!-- --></p> 
<p>vm.$emit(‘hook:’ + hook)</p> 
<p>}</p> 
<p>popTarget()</p> 
<p>}</p> 
<p>接收一个vm组件实例的参数和hook，取组件实例的$options传入的hook属性值，有的话会循环调用这个钩子的回调函数。在调用生命钩子的回调函数之前会临时pushTarget一个null值，也就是将Dep.target置为空来禁止在执行生命钩子的时候进行依赖收集。</p> 
<p>vm.$emit(‘hook:’ + hook)则是用来给父组件监听该组件的回调事件。</p> 
<p>接下来看每个生命钩子具体调用的时机。</p> 
<h4><a id="_1_beforeCreatecreated_208"></a><a href="" rel="nofollow"></a>1. beforeCreate、created：</h4> 
<p>Vue.prototype._init = function (options?: Object) {<!-- --></p> 
<p>…</p> 
<p>initLifecycle(vm)</p> 
<p>initEvents(vm)</p> 
<p>initRender(vm)</p> 
<p>callHook(vm, ‘beforeCreate’)</p> 
<p>initInjections(vm) // resolve injections before data/props</p> 
<p>initState(vm)</p> 
<p>initProvide(vm) // resolve provide after data/props</p> 
<p>callHook(vm, ‘created’)</p> 
<p>…</p> 
<p>if (vm.$options.el) {<!-- --></p> 
<p>vm.<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         m 
        
       
         o 
        
       
         u 
        
       
         n 
        
       
         t 
        
       
         ( 
        
       
         v 
        
       
         m 
        
       
         . 
        
       
      
        mount(vm. 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">m</span><span class="mord">.</span></span></span></span></span>options.el)</p> 
<p>}</p> 
<p>}</p> 
<p>在执行beforeCreate之前调用了 <code>initLifecycle、initEvents、initRender</code>函数，所以beforeCreate是在初始化生命周期、事件、渲染函数之后的生命周期。</p> 
<p>在执行created之前调用了initInjections、initState、initProvide，这时候created初始化了data、props、watcher、provide、inject等，所以这时候就可以访问到data、props等属性。</p> 
<h4><a id="_2_beforeMountmounted_258"></a><a href="" rel="nofollow"></a>2. beforeMount、mounted</h4> 
<p><img src="https://images2.imgbox.com/99/72/MjUms4Sg_o.png" alt=""></p> 
<h4><a id="_3_beforeUpdateupdated_266"></a><a href="" rel="nofollow"></a>3. beforeUpdate、updated</h4> 
<p>这两个钩子函数是在数据更新的时候进行回调的函数。在<code>src/core/instance/lifecycle.js</code>找到beforeUpdate调用的代码：</p> 
<p>…</p> 
<p>new Watcher(vm, updateComponent, noop, {<!-- --></p> 
<p>before () {<!-- --></p> 
<p>if (vm._isMounted &amp;&amp; !vm._isDestroyed) {<!-- --></p> 
<p>callHook(vm, ‘beforeUpdate’)</p> 
<p>}</p> 
<p>}</p> 
<p>}, true /* isRenderWatcher */)</p> 
<p>…</p> 
<p>_isMounted为ture的话（DOM已经被挂载）会调用callHook(vm, ‘beforeUpdate’)方法，然后会对虚拟DOM进行重新渲染。然后在/src/core/observer/scheduler.js下的flushSchedulerQueue()函数中渲染DOM，flushSchedulerQueue会刷新watcher队列并执行，执行完所有watcher的run方法之后（run方法就是watcher进行dom diff并更新DOM的方法），再调用callHook(vm, ‘updated’)，代码如下：</p> 
<p>/**</p> 
<ul><li>Flush both queues and run the watchers.</li></ul> 
<p>*/</p> 
<p>function flushSchedulerQueue () {<!-- --></p> 
<p>…</p> 
<p>for (index = 0; index &lt; queue.length; index++) {<!-- --></p> 
<p>watcher = queue[index]</p> 
<p>if (watcher.before) {<!-- --></p> 
<p>watcher.before()</p> 
<p>}</p> 
<p>watcher.run()</p> 
<p>}</p> 
<p>…</p> 
<p>callUpdatedHooks(updatedQueue)</p> 
<p>…</p> 
<p>}</p> 
<p>function callUpdatedHooks (queue) {<!-- --></p> 
<p>let i = queue.length</p> 
<p>while (i–) {<!-- --></p> 
<p>const watcher = queue[i]</p> 
<p>const vm = watcher.vm</p> 
<p>if (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) {<!-- --></p> 
<p>callHook(vm, ‘updated’)</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<h4><a id="_4_beforeDestroydestroyed_368"></a><a href="" rel="nofollow"></a>4. beforeDestroy、destroyed</h4> 
<p>这两个钩子是vue实例销毁的钩子，定义在Vue.prototype.$destroy中：</p> 
<p>Vue.prototype.$destroy = function () {<!-- --></p> 
<p>const vm: Component = this</p> 
<p>if (vm._isBeingDestroyed) {<!-- --></p> 
<p>return</p> 
<p>}</p> 
<p>callHook(vm, ‘beforeDestroy’)</p> 
<p>vm._isBeingDestroyed = true</p> 
<p>// remove self from parent</p> 
<p>const parent = vm.$parent</p> 
<p>if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) {<!-- --></p> 
<p>remove(parent.$children, vm)</p> 
<p>}</p> 
<p>// teardown watchers</p> 
<p>if (vm._watcher) {<!-- --></p> 
<p>vm._watcher.teardown()</p> 
<p>}</p> 
<p>let i = vm._watchers.length</p> 
<p>while (i–) {<!-- --></p> 
<p>vm._watchers[i].teardown()</p> 
<p>}</p> 
<p>// remove reference from data ob</p> 
<p>// frozen object may not have observer.</p> 
<p>if (vm._data.<strong>ob</strong>) {<!-- --></p> 
<p>vm._data.<strong>ob</strong>.vmCount–</p> 
<p>}</p> 
<p>// call the last hook…</p> 
<p>vm._isDestroyed = true</p> 
<p>// invoke destroy hooks on current rendered tree</p> 
<p>vm.<strong>patch</strong>(vm._vnode, null)</p> 
<p>// fire destroyed hook</p> 
<p>callHook(vm, ‘destroyed’)</p> 
<p>// turn off all instance listeners.</p> 
<p>vm.$off()</p> 
<p>// remove <strong>vue</strong> reference</p> 
<p>if (vm.$el) {<!-- --></p> 
<p>vm.$el.<strong>vue</strong> = null</p> 
<p>}</p> 
<p>if (vm.$vnode) {<!-- --></p> 
<p>vm.$vnode.parent = null</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<p>在销毁之前执行callHook(vm, ‘beforeDestroy’)，然后销毁的时候做了几件事：</p> 
<ul><li> <p>如果有父元素，将父元素的$children中把该组件实例移除。</p> </li><li> <p>移除watchers，并在依赖订阅者中移除自己。</p> </li><li> <p>删除数据引用</p> </li></ul> 
<h4><a id="_5_activateddeactivated_480"></a><a href="" rel="nofollow"></a>5. activated、deactivated</h4> 
<p>剩下的还有<code>activated、deactivated、errorCaptured</code>三个钩子函数。</p> 
<p>activated、deactivated这两个钩子函数分别是在keep-alive 组件激活和停用之后的回调。</p> 
<p>errorCaptured捕获到当子孙组件错误时会被调用，在源码中可以经常看到try catch中catch会调用handleError函数，handleError会向组件所有的父级组件抛出异常，</p> 
<p>function handleError (err: Error, vm: any, info: string) {<!-- --></p> 
<p>pushTarget()</p> 
<p>try {<!-- --></p> 
<p>if (vm) {<!-- --></p> 
<p>let cur = vm</p> 
<p>while ((cur = cur.$parent)) {<!-- --></p> 
<p>const hooks = cur.$options.errorCaptured</p> 
<p>if (hooks) {<!-- --></p> 
<p>for (let i = 0; i &lt; hooks.length; i++) {<!-- --></p> 
<p>try {<!-- --></p> 
<p>const capture = hooks[i].call(cur, err, vm, info) === false</p> 
<p>if (capture) return</p> 
<p>} catch (e) {<!-- --></p> 
<p>globalHandleError(e, cur, ‘errorCaptured hook’)</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<p>globalHandleError(err, vm, info)</p> 
<p>} finally {<!-- --></p> 
<p>popTarget()</p> 
<p>}</p> 
<p>}</p> 
<p>分析完源码再一下官网图示，会更清楚：</p> 
<p><img src="https://images2.imgbox.com/ac/fb/xony2o9Q_o.png" alt=""></p> 
<p><a href="" rel="nofollow"></a>10.keep-aliva原理</p> 
<hr> 
<p>keep-alive是Vue.js的一个内置组件。它能够将不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。</p> 
<p>include与exclude两个属性，允许组件有条件地进行缓存，max属性确定最多缓存多少组件实例。</p> 
<p>keep-alive是一个组件，跟其他组件一样有生命周期和render函数，keep-alive包裹的分析keep-alive就是分析一个组件。</p> 
<p>源码再<code>src/core/components/keep-alive</code>，created声明了要缓存的组件对象，和存储的组件keys，keep-alive销毁的时候会用pruneCacheEntry将缓存的所有组件实例销毁，也就是调用组件实例的destroy方法。在挂载完成后监听include和exclude，动态地销毁已经不满足include的组件和满足exclude的组件实例:</p> 
<p>created () {<!-- --></p> 
<p>this.cache = Object.create(null) // 存储需要缓存的组件</p> 
<p>this.keys = [] // 存储每个需要缓存的组件的key，即对应this.cache对象中的键值</p> 
<p>},</p> 
<p>// 销毁keep-alive组件的时候，对缓存中的每个组件执行销毁</p> 
<p>destroyed () {<!-- --></p> 
<p>for (const key in this.cache) {<!-- --></p> 
<p>pruneCacheEntry(this.cache, key, this.keys)</p> 
<p>}</p> 
<p>},</p> 
<p>mounted () {<!-- --></p> 
<p>this.$watch(‘include’, val =&gt; {<!-- --></p> 
<p>pruneCache(this, name =&gt; matches(val, name))</p> 
<p>})</p> 
<p>this.$watch(‘exclude’, val =&gt; {<!-- --></p> 
<p>pruneCache(this, name =&gt; !matches(val, name))</p> 
<p>})</p> 
<p>},</p> 
<p>接下来是render函数：</p> 
<p>render () {<!-- --></p> 
<p>const slot = this.$slots.default</p> 
<p>const vnode: VNode = getFirstComponentChild(slot)</p> 
<p>// 如果vnode存在就取vnode的选项</p> 
<p>const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</p> 
<p>if (componentOptions) {<!-- --></p> 
<p>// check pattern</p> 
<p>//获取第一个有效组件的name</p> 
<p>const name: ?string = getComponentName(componentOptions)</p> 
<p>const { include, exclude } = this</p> 
<p>if (</p> 
<p>// not included</p> 
<p>(include &amp;&amp; (!name || !matches(include, name))) ||</p> 
<p>// excluded</p> 
<p>(exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</p> 
<p>) {<!-- --></p> 
<p>return vnode// 说明不用缓存，直接返回这个组件进行渲染</p> 
<p>}</p> 
<p>// 匹配到了，开始缓存操作</p> 
<p>const { cache, keys } = this // keep-alive组件的缓存组件和缓存组件对应的key</p> 
<p>// 获取第一个有效组件的key</p> 
<p>const key: ?string = vnode.key == null</p> 
<p>// same constructor may get registered as different local components</p> 
<p>// so cid alone is not enough (#3269)</p> 
<dl> 
 
   ? componentOptions.Ctor.cid + (componentOptions.tag ? 
  <code>::${componentOptions.tag}</code> : ‘’) 
  
 <dd>
   vnode.key 
 </dd> 
</dl> 
<p>if (cache[key]) {<!-- --></p> 
<p>// 这个组件的实例用缓存中的组件实例替换</p> 
<p>vnode.componentInstance = cache[key].componentInstance</p> 
<p>// make current key freshest</p> 
<p>// 更新当前key在keys中的位置</p> 
<p>remove(keys, key)</p> 
<p>keys.push(key)</p> 
<p>} else {<!-- --></p> 
<p>cache[key] = vnode</p> 
<p>keys.push(key)</p> 
<p>// prune oldest entry</p> 
<p>// 如果缓存中的组件个数超过传入的max，销毁缓存中的LRU组件</p> 
<p>// LRU: least recently used 最近最少用，缓存淘汰策略</p> 
<p>if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {<!-- --></p> 
<p>pruneCacheEntry(cache, keys[0], keys, this._vnode)</p> 
<p>}</p> 
<p>}</p> 
<p>vnode.data.keepAlive = true</p> 
<p>}</p> 
<p>// 若第一个有效的组件存在，但其componentOptions不存在，就返回这个组件进行渲染</p> 
<p>// 或若也不存在有效的第一个组件，但keep-alive组件的默认插槽存在，就返回默认插槽的第一个组件进行渲染</p> 
<p>return vnode || (slot &amp;&amp; slot[0])</p> 
<p>}</p> 
<p>代码做了详细的注释，这里再分析下render做了什么。</p> 
<p>通过this.$slots.default拿到插槽组件，也就是keep-alive包裹的组件，getFirstComponentChild获取第一个子组件，获取该组件的name（存在组件名则直接使用组件名，否则会使用tag）。接下来会将这个name通过include与exclude属性进行匹配，匹配不成功（说明不需要进行缓存）则不进行任何操作直接返回vnode<code>（vnode节点描述对象，vue通过vnode创建真实的DOM）</code>。</p> 
<p>匹配到了就开始缓存，根据key在this.cache中查找，如果存在则说明之前已经缓存过了，直接将缓存的vnode的componentInstance（组件实例）覆盖到目前的vnode上面。否则将vnode存储在cache中。并且通过remove(keys, key)，将当前的key从keys中删除再重新keys.push(key)，这样就改变了当前key在keys中的位置。这个是为了实现max的功能，并且遵循缓存淘汰策略。</p> 
<p>如果没匹配到，说明没缓存过，这时候需要进行缓存，并且判断当前缓存的个数是否超过max指定的个数，如果超过，则销毁keys里的最后一个组件，并从keys中移除，这个就是LRU（<code>Least Recently Used ：最近最少使用</code> ）缓存淘汰算法。</p> 
<p>最后返回vnode或者默认插槽的第一个组件进行DOM渲染。</p> 
<p><a href="" rel="nofollow"></a>12.虚拟dom和diff算法</p> 
<hr> 
<p>虚拟DOM是对DOM的描述，用对象属性来描述节点，本质上是JavaScript对象。它有几个意义：</p> 
<ol><li>具备跨平台的优势</li></ol> 
<p>由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器、小程序、Node、原生应用、服务端渲染等等。</p> 
<ol start="2"><li>提升渲染性能</li></ol> 
<p>频繁变动DOM会造成浏览器的回流或者重回，而通过将大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，可以减少真实DOM的操作次数，从而提高性能。</p> 
<ol start="3"><li>代码可维护性更高</li></ol> 
<p>通过虚拟 DOM 的抽象能力，可以用声明式写 UI 的方式，大大提高了我们的工作效率。</p> 
<p>在vue中template最终会转成render函数，而render函数最终是执行的createElement，生成vnode，vnode正是 vue中用来表示虚拟DOM的类，看下vnode：</p> 
<p>class VNode {<!-- --></p> 
<p>tag: string | void;</p> 
<p>data: VNodeData | void;</p> 
<p>children: ?Array;</p> 
<p>text: string | void;</p> 
<p>elm: Node | void;</p> 
<p>ns: string | void;</p> 
<p>context: Component | void; // rendered in this component’s scope</p> 
<p>key: string | number | void;</p> 
<p>componentOptions: VNodeComponentOptions | void;</p> 
<p>componentInstance: Component | void; // component instance</p> 
<p>parent: VNode | void; // component placeholder node</p> 
<p>// strictly internal</p> 
<p>raw: boolean; // contains raw HTML? (server only)</p> 
<p>isStatic: boolean; // hoisted static node</p> 
<p>isRootInsert: boolean; // necessary for enter transition check</p> 
<p>isComment: boolean; // empty comment placeholder?</p> 
<p>isCloned: boolean; // is a cloned node?</p> 
<p>isOnce: boolean; // is a v-once node?</p> 
<p>asyncFactory: Function | void; // async component factory function</p> 
<p>asyncMeta: Object | void;</p> 
<p>isAsyncPlaceholder: boolean;</p> 
<p>ssrContext: Object | void;</p> 
<p>fnContext: Component | void; // real context vm for functional nodes</p> 
<p>fnOptions: ?ComponentOptions; // for SSR caching</p> 
<p>devtoolsMeta: ?Object; // used to store functional render context for devtools</p> 
<p>fnScopeId: ?string; // functional scope id support</p> 
<p>constructor (</p> 
<p>tag?: string,</p> 
<p>data?: VNodeData,</p> 
<p>children?: ?Array,</p> 
<p>text?: string,</p> 
<p>elm?: Node,</p> 
<p>context?: Component,</p> 
<p>componentOptions?: VNodeComponentOptions,</p> 
<p>asyncFactory?: Function</p> 
<p>) {<!-- --></p> 
<p>this.tag = tag</p> 
<p>this.data = data</p> 
<p>this.children = children</p> 
<p>this.text = text</p> 
<p>this.elm = elm</p> 
<p>this.ns = undefined</p> 
<p>this.context = context</p> 
<p>this.fnContext = undefined</p> 
<p>this.fnOptions = undefined</p> 
<p>this.fnScopeId = undefined</p> 
<p>this.key = data &amp;&amp; data.key</p> 
<p>this.componentOptions = componentOptions</p> 
<p>this.componentInstance = undefined</p> 
<p>this.parent = undefined</p> 
<p>this.raw = false</p> 
<p>this.isStatic = false</p> 
<p>this.isRootInsert = true</p> 
<p>this.isComment = false</p> 
<p>this.isCloned = false</p> 
<p>this.isOnce = false</p> 
<p>this.asyncFactory = asyncFactory</p> 
<p>this.asyncMeta = undefined</p> 
<p>this.isAsyncPlaceholder = false</p> 
<p>}</p> 
<p>// DEPRECATED: alias for componentInstance for backwards compat.</p> 
<p>/* istanbul ignore next */</p> 
<p>get child (): Component | void {<!-- --></p> 
<p>return this.componentInstance</p> 
<p>}</p> 
<p>}</p> 
<p>看下其中关键的几个属性：</p> 
<ul><li> <p>tag: 当前节点的标签名</p> </li><li> <p>data: 表示节点上的class，attribute，style以及绑定的事件</p> </li><li> <p>children: 当前节点的子节点，是一个数组</p> </li><li> <p>text: 当前节点的文本</p> </li><li> <p>elm: 当前虚拟节点对应的真实dom节点</p> </li><li> <p>key: 节点的key属性，被当作节点的标志，用以优化</p> </li><li> <p>componentOptions: 组件的option选项</p> </li><li> <p>componentInstance: 当前节点对应的组件的实例</p> </li><li> <p>parent: 当前节点的父节点</p> </li><li> <p>isStatic: 是否为静态节点</p> </li></ul> 
<p>children和parent是指当前的vnode的子节点和父节点，这样一个个vnode就形成了DOM树。</p> 
<p>diff算法发生在<code>视图更新</code>的时候，也就是数据更新的时候，<code>diff算法会将新旧虚拟DOM作对比，将变化的地方转换为DOM</code>。</p> 
<p>当某个数据被修改的时候，依赖对应的watcher会通知更新，执行渲染函数会生成新的vnode，vnode再去与旧的vnode进行对比更新，这就是vue中的虚拟dom diff算法触发的流程。</p> 
<p>看下组件更新的_update方法：</p> 
<p>Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {<!-- --></p> 
<p>const vm: Component = this</p> 
<p>const prevEl = vm.$el</p> 
<p>const prevVnode = vm._vnode</p> 
<p>const restoreActiveInstance = setActiveInstance(vm)</p> 
<p>vm._vnode = vnode</p> 
<p>// Vue.prototype.<strong>patch</strong> is injected in entry points</p> 
<p>// based on the rendering backend used.</p> 
<p>if (!prevVnode) {<!-- --></p> 
<p>// initial render</p> 
<p>vm.<span class="katex--inline">KaTeX parse error: Expected group after '_' at position 9: el = vm._̲_patch__(vm.</span>el, vnode, hydrating, false /* removeOnly */)</p> 
<p>} else {<!-- --></p> 
<p>// updates</p> 
<p>vm.$el = vm.<strong>patch</strong>(prevVnode, vnode)</p> 
<p>}</p> 
<p>}</p> 
<p>…</p> 
<p>vm.$el = vm._patch（），这个就是最终渲染的DOM元素，patch就是vue中diff算法的函数，在key的作用章节有提过。patch将新旧虚拟DOM节点比较后，最终返回真实的DOM节点。</p> 
<h4><a id="_patch_1056"></a><a href="" rel="nofollow"></a>patch</h4> 
<p>看下patch代码（部分）：</p> 
<p>function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {<!-- --></p> 
<p>/<em>vnode不存在则直接调用销毁钩子</em>/</p> 
<p>if (isUndef(vnode)) {<!-- --></p> 
<p>if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</p> 
<p>return</p> 
<p>}</p> 
<p>let isInitialPatch = false</p> 
<p>const insertedVnodeQueue = []</p> 
<p>if (isUndef(oldVnode)) {<!-- --></p> 
<p>// empty mount (likely as component), create new root element</p> 
<p>isInitialPatch = true</p> 
<p>createElm(vnode, insertedVnodeQueue, parentElm, refElm)</p> 
<p>} else {<!-- --></p> 
<p>/<em>标记旧的VNode是否有nodeType</em>/</p> 
<p>/<em>Github:https://github.com/answershuto</em>/</p> 
<p>const isRealElement = isDef(oldVnode.nodeType)</p> 
<p>if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {<!-- --></p> 
<p>// patch existing root node</p> 
<p>/<em>是同一个节点的时候直接修改现有的节点</em>/</p> 
<p>patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</p> 
<p>…</p> 
<p>return vnode.elm</p> 
<p>首先是判断是否有新的vnode，没有代表是要销毁旧的vnode，调用销毁组件的钩子。</p> 
<p>然后判断是否有旧的vnode，没有代表是新增，也就是新建root节点。</p> 
<p>接下来判断旧的vnode是否是真实的元素，而不是组件，如果是组件并且用someVnode判断新旧节点是否是相同的节点（sameVnode在key的作用章节有做解析），是进行patchVnode，这时候进行真正的新老节点的diff。<code>只有相同的节点才会进行diff算法！！！</code></p> 
<h4><a id="_patchVnode_1132"></a><a href="" rel="nofollow"></a>patchVnode</h4> 
<p>function patchVnode (</p> 
<p>oldVnode,</p> 
<p>vnode,</p> 
<p>insertedVnodeQueue,</p> 
<p>ownerArray,</p> 
<p>index,</p> 
<p>removeOnly</p> 
<p>) {<!-- --></p> 
<p>// 两个vnode相同，说明不需要diff，直接返回</p> 
<p>if (oldVnode === vnode) {<!-- --></p> 
<p>return</p> 
<p>}</p> 
<p>// 如果传入了ownerArray和index，可以进行重用vnode，updateChildren里用来替换位置</p> 
<p>if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {<!-- --></p> 
<p>// clone reused vnode</p> 
<p>vnode = ownerArray[index] = cloneVNode(vnode)</p> 
<p>}</p> 
<p>const elm = vnode.elm = oldVnode.elm</p> 
<p>// 如果oldVnode的isAsyncPlaceholder属性为true时，跳过检查异步组件，return</p> 
<p>if (isTrue(oldVnode.isAsyncPlaceholder)) {<!-- --></p> 
<p>if (isDef(vnode.asyncFactory.resolved)) {<!-- --></p> 
<p>hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</p> 
<p>} else {<!-- --></p> 
<p>vnode.isAsyncPlaceholder = true</p> 
<p>}</p> 
<p>return</p> 
<p>}</p> 
<p>/*</p> 
<p>如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），</p> 
<p>并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），</p> 
<p>那么只需要替换elm以及componentInstance即可。</p> 
<p>*/</p> 
<p>if (isTrue(vnode.isStatic) &amp;&amp;</p> 
<p>isTrue(oldVnode.isStatic) &amp;&amp;</p> 
<p>vnode.key === oldVnode.key &amp;&amp;</p> 
<p>(isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</p> 
<p>) {<!-- --></p> 
<p>vnode.componentInstance = oldVnode.componentInstance</p> 
<p>return</p> 
<p>}</p> 
<p>let i</p> 
<p>const data = vnode.data</p> 
<p>if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) {<!-- --></p> 
<p>i(oldVnode, vnode)</p> 
<p>}</p> 
<p>const oldCh = oldVnode.children</p> 
<p>const ch = vnode.children</p> 
<p>if (isDef(data) &amp;&amp; isPatchable(vnode)) {<!-- --></p> 
<p>for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</p> 
<p>if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</p> 
<p>}</p> 
<p>/<em>如果这个VNode节点没有text文本时</em>/</p> 
<p>if (isUndef(vnode.text)) {<!-- --></p> 
<p>if (isDef(oldCh) &amp;&amp; isDef(ch)) {<!-- --></p> 
<p>// 两个vnode都定义了子节点，并且不相同，就对子节点进行diff</p> 
<p>if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</p> 
<p>} else if (isDef(ch)) {<!-- --></p> 
<p>// 如果只有新的vnode定义了子节点，则进行添加子节点的操作</p> 
<p>if (process.env.NODE_ENV !== ‘production’) {<!-- --></p> 
<p>checkDuplicateKeys(ch)</p> 
<p>}</p> 
<p>if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, ‘’)</p> 
<p>addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</p> 
<p>} else if (isDef(oldCh)) {<!-- --></p> 
<p>// 如果只有旧的vnode定义了子节点，则进行删除子节点的操作</p> 
<p>removeVnodes(oldCh, 0, oldCh.length - 1)</p> 
<p>} else if (isDef(oldVnode.text)) {<!-- --></p> 
<p>nodeOps.setTextContent(elm, ‘’)</p> 
<p>}</p> 
<p>} else if (oldVnode.text !== vnode.text) {<!-- --></p> 
<p>nodeOps.setTextContent(elm, vnode.text)</p> 
<p>}</p> 
<p>if (isDef(data)) {<!-- --></p> 
<p>if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</p> 
<p>}</p> 
<p>}</p> 
<p>通过代码可知，patchVnode分为多种情况，分析下子节点的diff过程 <code>(oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点)</code></p> 
<ol><li> <p>oldCh、ch都定义了调用updateChildren再进行diff</p> </li><li> <p>若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中</p> </li><li> <p>若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点</p> </li><li> <p>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点</p> </li></ol> 
<p><code>updateChildren</code>是子节点diff的函数，也是最重要的环节。</p> 
<h4><a id="_updateChildren_1324"></a><a href="" rel="nofollow"></a>updateChildren</h4> 
<p>function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {<!-- --></p> 
<p>// 声明oldCh和newCh的头尾索引和头尾的vnode，</p> 
<p>let oldStartIdx = 0</p> 
<p>let newStartIdx = 0</p> 
<p>let oldEndIdx = oldCh.length - 1</p> 
<p>let oldStartVnode = oldCh[0]</p> 
<p>let oldEndVnode = oldCh[oldEndIdx]</p> 
<p>let newEndIdx = newCh.length - 1</p> 
<p>let newStartVnode = newCh[0]</p> 
<p>let newEndVnode = newCh[newEndIdx]</p> 
<p>let oldKeyToIdx, idxInOld, vnodeToMove, refElm</p> 
<p>const canMove = !removeOnly</p> 
<p>if (process.env.NODE_ENV !== ‘production’) {<!-- --></p> 
<p>checkDuplicateKeys(newCh)</p> 
<p>}</p> 
<p>while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {<!-- --></p> 
<p>if (isUndef(oldStartVnode)) {<!-- --></p> 
<p>oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</p> 
<p>} else if (isUndef(oldEndVnode)) {<!-- --></p> 
<p>oldEndVnode = oldCh[–oldEndIdx]</p> 
<p>// 判断两边的头是不是相同节点</p> 
<p>} else if (sameVnode(oldStartVnode, newStartVnode)) {<!-- --></p> 
<p>patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</p> 
<p>oldStartVnode = oldCh[++oldStartIdx]</p> 
<p>newStartVnode = newCh[++newStartIdx]</p> 
<p>// 判断尾部是不是相同节点</p> 
<p>} else if (sameVnode(oldEndVnode, newEndVnode)) {<!-- --></p> 
<p>patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</p> 
<p>oldEndVnode = oldCh[–oldEndIdx]</p> 
<p>newEndVnode = newCh[–newEndIdx]</p> 
<p>// 判断旧节点头部是不是与新节点的尾部相同，相同则把头部往右移</p> 
<p>} else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right</p> 
<p>patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</p> 
<p>canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</p> 
<p>oldStartVnode = oldCh[++oldStartIdx]</p> 
<p>newEndVnode = newCh[–newEndIdx]</p> 
<p>// 判断旧节点尾部是不是与新节点的头部相同，相同则把头部往左移</p> 
<p>} else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left</p> 
<p>patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</p> 
<p>canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</p> 
<p>oldEndVnode = oldCh[–oldEndIdx]</p> 
<p>newStartVnode = newCh[++newStartIdx]</p> 
<p>} else {<!-- --></p> 
<p>/*</p> 
<p>生成一个key与旧VNode的key对应的哈希表</p> 
<p>*/</p> 
<p>if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</p> 
<p>idxInOld = isDef(newStartVnode.key)</p> 
<dl> 
 
   ? oldKeyToIdx[newStartVnode.key] 
  
 <dd>
   findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) 
 </dd> 
</dl> 
<p>if (isUndef(idxInOld)) { // New element</p> 
<p>createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</p> 
<p>} else {<!-- --></p> 
<p>vnodeToMove = oldCh[idxInOld]</p> 
<p>if (sameVnode(vnodeToMove, newStartVnode)) {<!-- --></p> 
<p>patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</p> 
<p>oldCh[idxInOld] = undefined</p> 
<p>canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</p> 
<p>} else {<!-- --></p> 
<p>// same key but different element. treat as new element</p> 
<p>createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</p> 
<p>}</p> 
<p>}</p> 
<p>newStartVnode = newCh[++newStartIdx]</p> 
<p>}</p> 
<p>}</p> 
<p>// oldCh或者newCh遍历完，说明剩下的节点不是新增就是删除</p> 
<p>if (oldStartIdx &gt; oldEndIdx) {<!-- --></p> 
<p>refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</p> 
<p>addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</p> 
<p>} else if (newStartIdx &gt; newEndIdx) {<!-- --></p> 
<p>removeVnodes(oldCh, oldStartIdx, oldEndIdx)</p> 
<p>}</p> 
<p>}</p> 
<p>首先给startIndex和endIndex来作为遍历的索引，在遍历的时候会先判断头尾节点是否相同，没有找到相同节点后再按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点。</p> 
<p>当oldCh 或者 newCh 遍历完后(遍历完的条件就是 oldCh 或者 newCh 的 startIndex &gt;= endIndex )，说明剩下的节点为新增或者删除，这时候停止oldCh 和 newCh 的 diff。</p> 
<p><a href="" rel="nofollow"></a>13.Vuex原理</p> 
<hr> 
<p>vuex是什么，先看下官方的原话：</p> 
<blockquote> 
 <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p> 
</blockquote> 
<p>这段话可以得出几个结论：<code>Vuex是为vue.js服务的</code>，而像redux与react是解耦的，然后vuex是状态管理模式，所有的状态以一种可预测的方式发生变化。</p> 
<p>设计思想：</p> 
<p>Vuex的设计思想，借鉴了Flux、Redux，将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新。</p> 
<p>原理可以从使用方式开始分析。</p> 
<p>Vue.use(Vuex); // 1. vue的插件机制，安装vuex</p> 
<p>let store = new Vuex.Store({ // 2.实例化store，调用install方法</p> 
<p>state,</p> 
<p>getters,</p> 
<p>modules,</p> 
<p>mutations,</p> 
<p>actions,</p> 
<p>plugins</p> 
<p>});</p> 
<p>new Vue({ // 3.注入store, 挂载vue实例</p> 
<p>store,</p> 
<p>render: h=&gt;h(app)</p> 
<p>}).$mount(‘#app’);</p> 
<p>Vue.use是vue中的插件机制，内部会调用插件的install方法，vuex的install方法：</p> 
<p>export function install (_Vue) {<!-- --></p> 
<p>if (Vue) {<!-- --></p> 
<p>if (process.env.NODE_ENV !== ‘production’) {<!-- --></p> 
<p>console.error(</p> 
<p>‘[vuex] already installed. Vue.use(Vuex) should be called only once.’</p> 
<p>)</p> 
<p>}</p> 
<p>return</p> 
<p>}</p> 
<p>/<em>保存Vue，同时用于检测是否重复安装</em>/</p> 
<p>Vue = _Vue</p> 
<p>/<em>将vuexInit混淆进Vue的beforeCreate(Vue2.0)或_init方法(Vue1.0)</em>/</p> 
<p>applyMixin(Vue)</p> 
<p>}</p> 
<p>vuex是个全局的状态管理，全局有且只能有一个store实例，所以在install的时候会判断是否已经安装过了，这个就是单例模式，确保一个类只有一个实例。在第一次install的时候会applyMixin，applyMixin是<code>/src/mixin</code>导入的方法:</p> 
<p>function (Vue) {<!-- --></p> 
<p>const version = Number(Vue.version.split(‘.’)[0])</p> 
<p>if (version &gt;= 2) {<!-- --></p> 
<p>Vue.mixin({ beforeCreate: vuexInit })</p> 
<p>} else {<!-- --></p> 
<p>// override init and inject vuex init procedure</p> 
<p>// for 1.x backwards compatibility.</p> 
<p>const _init = Vue.prototype._init</p> 
<p>Vue.prototype._init = function (options = {}) {<!-- --></p> 
<p>options.init = options.init</p> 
<dl> 
 
   ? [vuexInit].concat(options.init) 
  
 <dd>
   vuexInit 
 </dd> 
</dl> 
<p>_init.call(this, options)</p> 
<p>}</p> 
<p>}</p> 
<p>/**</p> 
<ul><li>Vuex init hook, injected into each instances init hooks list.</li></ul> 
<p>*/</p> 
<p>function vuexInit () {<!-- --></p> 
<p>const options = this.$options</p> 
<p>// store injection</p> 
<p>if (options.store) {<!-- --></p> 
<p>this.$store = typeof options.store === ‘function’</p> 
<dl> 
 
   ? options.store() 
  
 <dd>
   options.store 
 </dd> 
</dl> 
<p>} else if (options.parent &amp;&amp; options.parent.$store) {<!-- --></p> 
<p>this.<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         t 
        
       
         o 
        
       
         r 
        
       
         e 
        
       
         = 
        
       
         o 
        
       
         p 
        
       
         t 
        
       
         i 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         . 
        
       
         p 
        
       
         a 
        
       
         r 
        
       
         e 
        
       
         n 
        
       
         t 
        
       
         . 
        
       
      
        store = options.parent. 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ore</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">pt</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord">.</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">re</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">.</span></span></span></span></span>store</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<p>先是判断下vue的版本，这边分析vue2的逻辑。利用Vue.mixin混入的机制，在组件实例的beforeCreate调用vuexInit方法，首先判断options是否有store，没有代表是root节点，这时候要进行store初始化，没有的话就取父组件的$store赋值，这样就实现了全局共用唯一的store实例。</p> 
<p>store实现的源码在<code>src/store.js</code>，其中最核心的是响应式的实现，通过resetStoreVM(this, state)调用，看下这个方法：</p> 
<p>function resetStoreVM (store, state, hot) {<!-- --></p> 
<p>const oldVm = store._vm</p> 
<p>// bind store public getters</p> 
<p>store.getters = {}</p> 
<p>// reset local getters cache</p> 
<p>store._makeLocalGettersCache = Object.create(null)</p> 
<p>const wrappedGetters = store._wrappedGetters</p> 
<p>const computed = {}</p> 
<p>forEachValue(wrappedGetters, (fn, key) =&gt; {<!-- --></p> 
<p>// use computed to leverage its lazy-caching mechanism</p> 
<p>// direct inline function use will lead to closure preserving oldVm.</p> 
<p>// using partial to return function with only arguments preserved in closure environment.</p> 
<p>computed[key] = partial(fn, store)</p> 
<p>Object.defineProperty(store.getters, key, {<!-- --></p> 
<p>get: () =&gt; store._vm[key],</p> 
<p>enumerable: true // for local getters</p> 
<p>})</p> 
<p>})</p> 
<p>// use a Vue instance to store the state tree</p> 
<p>// suppress warnings just in case the user has added</p> 
<p>// some funky global mixins</p> 
<p>const silent = Vue.config.silent</p> 
<p>Vue.config.silent = true</p> 
<p>store._vm = new Vue({<!-- --></p> 
<p>data: {<!-- --></p> 
<p>$$state: state</p> 
<p>},</p> 
<p>computed</p> 
<p>})</p> 
<p>Vue.config.silent = silent</p> 
<p>// enable strict mode for new vm</p> 
<p>if (store.strict) {<!-- --></p> 
<p>enableStrictMode(store)</p> 
<p>}</p> 
<p>if (oldVm) {<!-- --></p> 
<p>if (hot) {<!-- --></p> 
<p>// dispatch changes in all subscribed watchers</p> 
<p>// to force getter re-evaluation for hot reloading.</p> 
<p>store._withCommit(() =&gt; {<!-- --></p> 
<p>oldVm._data.$$state = null</p> 
<p>})</p> 
<p>}</p> 
<p>Vue.nextTick(() =&gt; oldVm.$destroy())</p> 
<p>}</p> 
<p>}</p> 
<p>resetStoreVM首先会遍历wrappedGetters，使用Object.defineProperty方法对store.getters的每一个getter定义get方法，这样访问this.$store.getter.test就等同于访问store._vm.test。</p> 
<p>state是通过new一个Vue对象来实现数据的“响应式化”，运用Vue的data属性来实现数据与视图的同步更新，computed实现getters的计算属性。最终访问store.state也就是访问store._vm.state。</p> 
<p><a href="" rel="nofollow"></a>最后</p> 
<p>=============================================================</p> 
<p>在面试前花了三个月时间刷了很多大厂面试题，最近做了一个整理并分类，主要内容包括html，css，JavaScript，ES6，计算机网络，浏览器，工程化，模块化，Node.js，框架，数据结构，性能优化，项目等等。</p> 
<p>包含了腾讯、字节跳动、小米、阿里、滴滴、美团、58、拼多多、360、新浪、搜狐等一线互联网公司面试被问到的题目，涵盖了初中级前端技术点。</p> 
<p>无偿分享给大家，算是一个感恩回馈吧，详细内容可以在文末自行获取哈！</p> 
<h4><a id="_1821"></a>总结</h4> 
<p>秋招即将开始，校招的朋友普遍是缺少项目经历的，所以<strong>底层逻辑，基础知识要掌握好！</strong></p> 
<p>而一般的社招，更是神仙打架。特别强调，项目经历不可忽视；几乎简历上提到的项目都会被刨根问底，所以项目应用的技术要熟练，底层原理必须清楚。</p> 
<p>这里给大家提供一份汇集各大厂面试高频核心考点前端学习资料。涵盖 <strong>HTML，CSS，JavaScript，HTTP，TCP协议，浏览器，Vue框架，算法</strong>等高频考点<strong>238道（含答案）</strong>！</p> 
<p><strong><a href="https://bbs.csdn.net/forums/4304bb5a486d4c3ab8389e65ecb71ac0">开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】</a></strong></p> 
<p>资料截图 ：</p> 
<p><img src="https://images2.imgbox.com/e9/ca/9EV0h835_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/e7/73/W8M6JPqh_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/9c/2a/FTNYIztY_o.png" alt=""></p> 
<p><strong>高级前端工程师必备资料包</strong></p> 
<p><img src="https://images2.imgbox.com/cd/7b/xKTZify9_o.png" alt=""></p> 
<p>const silent = Vue.config.silent</p> 
<p>Vue.config.silent = true</p> 
<p>store._vm = new Vue({<!-- --></p> 
<p>data: {<!-- --></p> 
<p>$$state: state</p> 
<p>},</p> 
<p>computed</p> 
<p>})</p> 
<p>Vue.config.silent = silent</p> 
<p>// enable strict mode for new vm</p> 
<p>if (store.strict) {<!-- --></p> 
<p>enableStrictMode(store)</p> 
<p>}</p> 
<p>if (oldVm) {<!-- --></p> 
<p>if (hot) {<!-- --></p> 
<p>// dispatch changes in all subscribed watchers</p> 
<p>// to force getter re-evaluation for hot reloading.</p> 
<p>store._withCommit(() =&gt; {<!-- --></p> 
<p>oldVm._data.$$state = null</p> 
<p>})</p> 
<p>}</p> 
<p>Vue.nextTick(() =&gt; oldVm.$destroy())</p> 
<p>}</p> 
<p>}</p> 
<p>resetStoreVM首先会遍历wrappedGetters，使用Object.defineProperty方法对store.getters的每一个getter定义get方法，这样访问this.$store.getter.test就等同于访问store._vm.test。</p> 
<p>state是通过new一个Vue对象来实现数据的“响应式化”，运用Vue的data属性来实现数据与视图的同步更新，computed实现getters的计算属性。最终访问store.state也就是访问store._vm.state。</p> 
<p><a href="" rel="nofollow"></a>最后</p> 
<p>=============================================================</p> 
<p>在面试前花了三个月时间刷了很多大厂面试题，最近做了一个整理并分类，主要内容包括html，css，JavaScript，ES6，计算机网络，浏览器，工程化，模块化，Node.js，框架，数据结构，性能优化，项目等等。</p> 
<p>包含了腾讯、字节跳动、小米、阿里、滴滴、美团、58、拼多多、360、新浪、搜狐等一线互联网公司面试被问到的题目，涵盖了初中级前端技术点。</p> 
<p>无偿分享给大家，算是一个感恩回馈吧，详细内容可以在文末自行获取哈！</p> 
<h4><a id="_1932"></a>总结</h4> 
<p>秋招即将开始，校招的朋友普遍是缺少项目经历的，所以<strong>底层逻辑，基础知识要掌握好！</strong></p> 
<p>而一般的社招，更是神仙打架。特别强调，项目经历不可忽视；几乎简历上提到的项目都会被刨根问底，所以项目应用的技术要熟练，底层原理必须清楚。</p> 
<p>这里给大家提供一份汇集各大厂面试高频核心考点前端学习资料。涵盖 <strong>HTML，CSS，JavaScript，HTTP，TCP协议，浏览器，Vue框架，算法</strong>等高频考点<strong>238道（含答案）</strong>！</p> 
<p><strong><a href="https://bbs.csdn.net/forums/4304bb5a486d4c3ab8389e65ecb71ac0">开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】</a></strong></p> 
<p>资料截图 ：</p> 
<p><img src="https://images2.imgbox.com/b5/5d/oxDxZeTr_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/93/49/7Oq3rYDC_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/12/6f/bZ9Em4kF_o.png" alt=""></p> 
<p><strong>高级前端工程师必备资料包</strong></p> 
<p><img src="https://images2.imgbox.com/0a/e9/lU8T4esN_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61315850e3d4bdd57d8e6a9a5214ea8c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年大数据最新使用logstash迁移ES数据并解决限流等问题，不了解这些多线程的基础知识很难学懂大数据开发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77fcaa1110b1048b84568fb9273e601e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI智能体｜我把Kimi接入了个人微信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>