<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文搞懂前端渲染技术：什么是SSR、SSG、CSR？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/024dab311a1674c6f51f30711e31ab29/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="一文搞懂前端渲染技术：什么是SSR、SSG、CSR？">
  <meta property="og:description" content="在前端开发的世界里，我们经常遇到SSR（服务器端渲染）、SSG（静态站点生成）和CSR（客户端渲染）这三种渲染技术。它们各自有着独特的优缺点，适用于不同的场景和需求。下面，我们将详细介绍这三种技术，并通过代码示例来加深理解。
一、CSR（客户端渲染） 介绍：
CSR（Client-Side Rendering）是前端开发中最常见的渲染方式。在这种模式下，服务器主要负责提供静态的HTML文件（可能包含一些基本的HTML结构和JavaScript脚本），而真正的页面渲染工作则完全由客户端的浏览器来完成。这意味着页面内容是在用户的浏览器上动态生成的。
优点：
响应速度快：一旦HTML文件加载完成，浏览器就可以开始渲染页面，而不需要等待服务器返回完整的渲染结果。动态性强：由于页面渲染在客户端进行，因此可以方便地实现各种动态交互效果。前端部署简单：只需要一个静态服务即可部署前端代码，降低了部署成本。 缺点：
首屏加载时间长：由于需要加载整个JavaScript包，可能导致首屏加载时间较长，特别是对于复杂的单页应用（SPA）。不利于SEO：搜索引擎爬虫可能无法很好地解析由JavaScript动态生成的页面内容，导致SEO效果较差。白屏时间：在JavaScript代码加载和执行期间，用户可能会看到空白的页面，即所谓的“白屏时间”。 示例（使用React）：
// 假设有一个React组件 import React from &#39;react&#39;; function MyComponent() { const [message, setMessage] = React.useState(&#39;Hello, CSR!&#39;); const handleClick = () =&gt; { setMessage(&#39;Clicked!&#39;); }; return ( &lt;div&gt; &lt;p&gt;{message}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt; &lt;/div&gt; ); } // 在HTML文件中引入React和组件的JavaScript文件 // 浏览器加载并执行这些JavaScript，从而渲染页面 二、SSR（服务器端渲染） 介绍：
SSR（Server-Side Rendering）是一种在服务器端完成页面渲染的技术。在这种模式下，服务器接收到客户端的请求后，会先根据请求数据和模板文件生成完整的HTML页面，然后将这个页面直接发送给客户端。这样，用户可以直接看到完成的内容，无需等待JavaScript加载和执行。
优点：
首屏加载速度快：由于服务器已经生成了完整的HTML页面，因此客户端可以直接显示这个页面，无需等待JavaScript加载和执行。SEO友好：搜索引擎爬虫可以很好地解析由服务器生成的HTML页面内容，有利于SEO优化。适合复杂页面：对于包含大量数据、需要复杂计算的页面，SSR可以更好地处理并减少客户端的负载。 缺点：
服务器压力大：对于每个请求，服务器都需要重新渲染页面，这可能导致服务器压力过大。开发限制：SSR要求开发者在编写Vue组件时，需要考虑到服务器端和客户端环境的差异，不能过度依赖客户端环境。调试困难：SSR的调试过程相对复杂，需要同时考虑到服务器端和客户端的日志和错误信息。 示例（使用React的服务器端渲染）：
// 服务器端代码（Node.js） const React = require(&#39;react&#39;); const ReactDOMServer = require(&#39;react-dom/server&#39;); const MyComponent = require(&#39;.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-15T10:39:10+08:00">
    <meta property="article:modified_time" content="2024-05-15T10:39:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文搞懂前端渲染技术：什么是SSR、SSG、CSR？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在前端开发的世界里，我们经常遇到SSR（服务器端渲染）、SSG（静态站点生成）和CSR（客户端渲染）这三种渲染技术。它们各自有着独特的优缺点，适用于不同的场景和需求。下面，我们将详细介绍这三种技术，并通过代码示例来加深理解。</p> 
<h4 id="item-1">一、CSR（客户端渲染）</h4> 
<p><strong>介绍：</strong></p> 
<p>CSR（Client-Side Rendering）是前端开发中最常见的渲染方式。在这种模式下，服务器主要负责提供静态的HTML文件（可能包含一些基本的HTML结构和JavaScript脚本），而真正的页面渲染工作则完全由客户端的浏览器来完成。这意味着页面内容是在用户的浏览器上动态生成的。</p> 
<p><strong>优点：</strong></p> 
<ol><li><strong>响应速度快</strong>：一旦HTML文件加载完成，浏览器就可以开始渲染页面，而不需要等待服务器返回完整的渲染结果。</li><li><strong>动态性强</strong>：由于页面渲染在客户端进行，因此可以方便地实现各种动态交互效果。</li><li><strong>前端部署简单</strong>：只需要一个静态服务即可部署前端代码，降低了部署成本。</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li><strong>首屏加载时间长</strong>：由于需要加载整个JavaScript包，可能导致首屏加载时间较长，特别是对于复杂的单页应用（SPA）。</li><li><strong>不利于SEO</strong>：搜索引擎爬虫可能无法很好地解析由JavaScript动态生成的页面内容，导致SEO效果较差。</li><li><strong>白屏时间</strong>：在JavaScript代码加载和执行期间，用户可能会看到空白的页面，即所谓的“白屏时间”。</li></ol> 
<p><strong>示例（使用React）：</strong></p> 
<pre>// 假设有一个React组件
import React from 'react';

function MyComponent() {
  const [message, setMessage] = React.useState('Hello, CSR!');

  const handleClick = () =&gt; {
    setMessage('Clicked!');
  };

  return (
    &lt;div&gt;
      &lt;p&gt;{message}&lt;/p&gt;
      &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
  );
}

// 在HTML文件中引入React和组件的JavaScript文件
// 浏览器加载并执行这些JavaScript，从而渲染页面</pre> 
<h4 id="item-2">二、SSR（服务器端渲染）</h4> 
<p><strong>介绍：</strong></p> 
<p>SSR（Server-Side Rendering）是一种在服务器端完成页面渲染的技术。在这种模式下，服务器接收到客户端的请求后，会先根据请求数据和模板文件生成完整的HTML页面，然后将这个页面直接发送给客户端。这样，用户可以直接看到完成的内容，无需等待JavaScript加载和执行。</p> 
<p><strong>优点：</strong></p> 
<ol><li><strong>首屏加载速度快</strong>：由于服务器已经生成了完整的HTML页面，因此客户端可以直接显示这个页面，无需等待JavaScript加载和执行。</li><li><strong>SEO友好</strong>：搜索引擎爬虫可以很好地解析由服务器生成的HTML页面内容，有利于SEO优化。</li><li><strong>适合复杂页面</strong>：对于包含大量数据、需要复杂计算的页面，SSR可以更好地处理并减少客户端的负载。</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li><strong>服务器压力大</strong>：对于每个请求，服务器都需要重新渲染页面，这可能导致服务器压力过大。</li><li><strong>开发限制</strong>：SSR要求开发者在编写Vue组件时，需要考虑到服务器端和客户端环境的差异，不能过度依赖客户端环境。</li><li><strong>调试困难</strong>：SSR的调试过程相对复杂，需要同时考虑到服务器端和客户端的日志和错误信息。</li></ol> 
<p><strong>示例（使用React的服务器端渲染）：</strong></p> 
<pre>// 服务器端代码（Node.js）
const React = require('react');
const ReactDOMServer = require('react-dom/server');
const MyComponent = require('./MyComponent').default; // 假设MyComponent是上面定义的React组件

// 渲染组件为HTML字符串
const html = ReactDOMServer.renderToString(&lt;MyComponent /&gt;);

// 将HTML字符串发送给客户端
// ...（这里省略了HTTP服务器和响应发送的代码）</pre> 
<h4 id="item-3">三、SSG（静态站点生成）</h4> 
<p><strong>介绍：</strong></p> 
<p>SSG（Static Site Generation）是一种在构建时生成静态HTML页面的技术。在这种模式下，开发者会编写一些模板文件和数据文件，然后使用构建工具（如Hugo、Gatsby等）将这些文件转换为静态的HTML页面。这些页面可以直接部署到服务器上，而不需要服务器进行实时渲染。</p> 
<p><strong>优点：</strong></p> 
<ol><li><strong>性能卓越</strong>：由于页面是静态的，因此无需等待服务器渲染，直接由浏览器加载显示，具有出色的性能。</li><li><strong>安全性高</strong>：由于服务器只提供静态文件，因此降低了遭受攻击的风险。</li><li><strong>适合内容型网站</strong>：对于内容更新不频繁的内容型网站（如博客、文档网站等），SSG是一个很好的选择。</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li><strong>动态性受限</strong>：由于页面是静态的，因此难以实现复杂的动态交互效果。</li><li><strong>构建时间长</strong>：对于大型站点，构建时间可能会比较长。</li><li><strong>不适合频繁更新</strong>：对于需要频繁更新数据的网站，SSG可能不太适合，因为每次更新都需要重新构建并部署整个网站。</li></ol> 
<p><strong>示例（使用Nunjucks模板引擎）：</strong><br><strong>模板文件（<code>index.njk</code>）：</strong></p> 
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My Static Site&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;{<!-- -->{ message }}&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre> 
<p><strong>构建脚本（Node.js）：</strong></p> 
<pre>const nunjucks = require('nunjucks');
const fs = require('fs');

// 配置Nunjucks模板引擎
nunjucks.configure('views', { autoescape: true });

// 渲染模板
const res = nunjucks.render('index.njk', { message: 'Hello, SSG!' });

// 将渲染结果写入HTML文件
fs.writeFileSync('dist/index.html', res);

// 现在你可以将生成的`dist/index.html`部署到服务器上</pre> 
<h4 id="item-4">总结</h4> 
<p>CSR、SSR和SSG各有优缺点，适用于不同的场景和需求。在选择使用哪种技术时，需要根据项目的具体需求来权衡利弊。</p> 
<p>例如，对于需要丰富交互效果和实时数据的场景，可以选择CSR；对于需要优化首屏加载速度和SEO效果的场景，可以选择SSR；而对于内容更新不频繁、对性能要求高的场景，可以选择SSG。同时，也可以结合使用多种技术来实现更好的用户体验和性能优化。</p> 
<p>前端的世界总是在不断变化，作为开发者，我们需要保持好奇心和学习热情，不断探索新的技术，只有这样，我们才能在这个快速发展的时代中立于不败之地。低代码也是一个值得我们深入探索的领域，让我们拭目以待，它将给前端世界带来怎样的变革。</p> 
<p>介绍一款程序员都应该知道的软件<a href="https://link.zhihu.com/?target=https%3A//www.jnpfsoft.com/%3Fzhihuxl" rel="nofollow" title="JNPF快速开发平台">JNPF快速开发平台</a>，很多人都尝试用过它，它是功能的集大成者，任何信息化系统都可以基于它开发出来。</p> 
<p>JNPF可以实现应用从创建、配置、开发、测试到发布、运维、升级等完整生命周期的管理。减少了传统应用程序的代码编写量，通过图形化、可视化的界面，以拖放组件的方式，即可快速生成应用程序的产品，大幅降低了开发企业管理类软件的难度。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d047252d26feed93f07b38459f63ec01/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AI语音基础】ASR基本知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f285c9896752128f2c794183bb4f8418/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">finallyshell激活-支持所有版本（老版 &#43; 最新版） &#43; 所有平台（mac &#43; windows）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>