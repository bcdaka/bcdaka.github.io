<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>.Net接入AzureOpenAI、OpenAI、通义千问、智谱AI、讯飞星火、文心一言大语言模型。 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a4d5035fcf0246dd0848e57e0b6db74e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content=".Net接入AzureOpenAI、OpenAI、通义千问、智谱AI、讯飞星火、文心一言大语言模型。">
  <meta property="og:description" content="前言 现在在网上搜索.NET接入大模型的帖子很少，有些官方案例只提供java和python的SDK，所以有了这篇.Net的接入大模型文章，目前仅实现对话模型的调用。
这里仅举例通义千问，其他模型实现可以参考Gi他Hub 对您有帮助的话帮忙点个star
个人博客：FaceMan’ Blog 。
Github：FaceMan’ GitHub 。
实现方式 创建IModelExtensionsChatCompletionService对话服务，规范对话服务应实现的接口。
public interface IModelExtensionsChatCompletionService { /// &lt;summary&gt; /// 对话 /// &lt;/summary&gt; /// &lt;param name=&#34;chatHistory&#34;&gt;对话历史&lt;/param&gt; /// &lt;param name=&#34;settings&#34;&gt;参数配置&lt;/param&gt; /// &lt;param name=&#34;kernel&#34;&gt;SK的kernel&lt;/param&gt; /// &lt;param name=&#34;cancellationToken&#34;&gt;是否取消&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;ChatMessageContent&gt; GetChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default); /// &lt;summary&gt; /// 流式对话 /// &lt;/summary&gt; /// &lt;param name=&#34;chatHistory&#34;&gt;对话历史&lt;/param&gt; /// &lt;param name=&#34;settings&#34;&gt;参数配置&lt;/param&gt; /// &lt;param name=&#34;kernel&#34;&gt;SK的kernel&lt;/param&gt; /// &lt;param name=&#34;cancellationToken&#34;&gt;是否取消&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; IAsyncEnumerable&lt;string&gt; GetStreamingChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default); } 创建ModelClient类做数据解析">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-21T21:44:44+08:00">
    <meta property="article:modified_time" content="2024-01-21T21:44:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">.Net接入AzureOpenAI、OpenAI、通义千问、智谱AI、讯飞星火、文心一言大语言模型。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>前言</h2> 
<p>现在在网上搜索.NET接入大模型的帖子很少，有些官方案例只提供java和python的SDK，所以有了这篇.Net的接入大模型文章，目前仅实现对话模型的调用。<br> 这里仅举例通义千问，其他模型实现可以参考Gi他Hub 对您有帮助的话帮忙点个star<br> 个人博客：<a href="https://blog.faceman.cn/" rel="nofollow">FaceMan’ Blog</a> 。<br> Github：<a href="https://github.com/faceman0814">FaceMan’ GitHub</a> 。</p> 
<h2><a id="_6"></a>实现方式</h2> 
<ol><li> <p>创建IModelExtensionsChatCompletionService对话服务，规范对话服务应实现的接口。</p> <pre><code>public interface IModelExtensionsChatCompletionService
{
	 /// &lt;summary&gt;
	 /// 对话
	 /// &lt;/summary&gt;
	 /// &lt;param name="chatHistory"&gt;对话历史&lt;/param&gt;
	 /// &lt;param name="settings"&gt;参数配置&lt;/param&gt;
	 /// &lt;param name="kernel"&gt;SK的kernel&lt;/param&gt;
	 /// &lt;param name="cancellationToken"&gt;是否取消&lt;/param&gt;
	 /// &lt;returns&gt;&lt;/returns&gt;
	 Task&lt;ChatMessageContent&gt; GetChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default);

	 /// &lt;summary&gt;
	 /// 流式对话
	 /// &lt;/summary&gt;
	 /// &lt;param name="chatHistory"&gt;对话历史&lt;/param&gt;
	 /// &lt;param name="settings"&gt;参数配置&lt;/param&gt;
	 /// &lt;param name="kernel"&gt;SK的kernel&lt;/param&gt;
	 /// &lt;param name="cancellationToken"&gt;是否取消&lt;/param&gt;
	 /// &lt;returns&gt;&lt;/returns&gt;
	 IAsyncEnumerable&lt;string&gt; GetStreamingChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default);
 }
</code></pre> </li><li> <p>创建ModelClient类做数据解析</p> <pre><code>public class ModelClient : IDisposable
{
    internal readonly HttpClient HttpClient = null!;

    public ModelClient(string apiKey, ModelType modelType, HttpClient? httpClient = null)
    {
        HttpClient = httpClient ?? new HttpClient();
        switch (modelType)
        {
            case ModelType.ZhiPu:
                int expirationInSeconds = 3600; // 设置过期时间为1小时
                apiKey = GenerateJwtToken(apiKey, expirationInSeconds);
                HttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", apiKey);
                break;
            case ModelType.QianWen:
                HttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", apiKey);
                break;
            case ModelType.XunFei:
                break;

        }
        QianWen = new QianWenClient(this);
        ZhiPu = new ZhiPuClient(this);
        XunFei = new XunFeiClient(this);
        WenXin = new WenXinClient(this);
    }

    public QianWenClient QianWen { get; set; }
    public ZhiPuClient ZhiPu { get; set; }
    public XunFeiClient XunFei { get; set; }
    public WenXinClient WenXin { get; set; }
    /// &lt;summary&gt;
    /// 处理基础HTTP客户端。
    /// &lt;/summary&gt;
    public void Dispose() =&gt; HttpClient.Dispose();

    /// &lt;summary&gt;
    /// 数据流转换器
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    /// &lt;param name="response"&gt;响应体&lt;/param&gt;
    /// &lt;param name="cancellationToken"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="Exception"&gt;&lt;/exception&gt;
    internal static async Task&lt;T&gt; ReadResponse&lt;T&gt;(HttpResponseMessage response, CancellationToken cancellationToken)
    {
        if (!response.IsSuccessStatusCode)
        {
            throw new Exception(await response.Content.ReadAsStringAsync());
        }
        try
        {
            var debug = await response.Content.ReadAsStringAsync();
            return (await response.Content.ReadFromJsonAsync&lt;T&gt;(options: null, cancellationToken))!;
        }
        catch (Exception e) when (e is NotSupportedException or System.Text.Json.JsonException)
        {
            throw new Exception($"未能将以下json转换为: {typeof(T).Name}: {await response.Content.ReadAsStringAsync()}", e);
        }
    }
    /// &lt;summary&gt;
    /// 讯飞星火 数据流转换器
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    /// &lt;param name="receivedMessage"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static XunFeiResponseWrapper ReadResponse&lt;T&gt;(string receivedMessage)
    {
        XunFeiResponseWrapper response = JsonConvert.DeserializeObject&lt;XunFeiResponseWrapper&gt;(receivedMessage);
        return response;
    }

    /// &lt;summary&gt;
    /// 智谱生成JWT令牌
    /// &lt;/summary&gt;
    /// &lt;param name="apiKey"&gt;&lt;/param&gt;
    /// &lt;param name="expSeconds"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;exception cref="ArgumentException"&gt;&lt;/exception&gt;
    internal string GenerateJwtToken(string apiKey, int expSeconds)
    {
        // 分割API Key以获取ID和Secret
        var parts = apiKey.Split('.');
        if (parts.Length != 2)
        {
            throw new ArgumentException("Invalid API key format.");
        }

        var id = parts[0];
        var secret = parts[1];

        // 创建Header信息
        var header = new JwtHeader(new SigningCredentials(
            new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)), SecurityAlgorithms.HmacSha256))
            {
                {"sign_type", "SIGN"}
            };

        // 创建Payload信息
        long currentMillis = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        var payload = new JwtPayload
        {
            {"api_key", id},
            {"exp", currentMillis + expSeconds * 1000},
            {"timestamp", currentMillis}
        };

        // 生成JWT Token
        var token = new JwtSecurityToken(header, payload);

        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
</code></pre> </li><li> <p>定义ModelType区分不同模型供应商</p> <pre><code>public enum ModelType
{
	[Description("通义千问")]
	[EnumName("通义千问")]
	QianWen = 1,

	[Description("智谱AI")]
	[EnumName("智谱AI")]
	ZhiPu,

	[Description("科大讯飞")]
	[EnumName("科大讯飞")]
	XunFei,

	[Description("文心一言")]
	[EnumName("文心一言")]
	WenXin,
}
</code></pre> </li><li> <p>以通义千问为例，创建QianWenChatCompletionService类继承IModelExtensionsChatCompletionService</p> <pre><code>public class QianWenChatCompletionService : IModelExtensionsChatCompletionService
{
	private readonly string _apiKey;
	private readonly string _model;
	public QianWenChatCompletionService(string key, string model)
	{
		_apiKey = key;
		_model = model;
	}
	/// &lt;summary&gt;
	/// 对话
	/// &lt;/summary&gt;
	/// &lt;param name="chatHistory"&gt;&lt;/param&gt;
	/// &lt;param name="settings"&gt;&lt;/param&gt;
	/// &lt;param name="kernel"&gt;&lt;/param&gt;
	/// &lt;param name="cancellationToken"&gt;&lt;/param&gt;
	/// &lt;returns&gt;&lt;/returns&gt;
	public async Task&lt;ChatMessageContent&gt; GetChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default)
	{
		var histroyList = new List&lt;ChatMessage&gt;();
		ChatParameters chatParameters = null;
		foreach (var item in chatHistory)
		{
			var history = new ChatMessage()
			{
				Role = item.Role.Label,
				Content = item.Content,
			};
			histroyList.Add(history);
		}
		if (settings != null)
		{
			chatParameters = new ChatParameters()
			{
				TopP = settings != null ? (float)settings.TopP : default,
				MaxTokens = settings != null ? settings.MaxTokens : default,
				Temperature = settings != null ? (float)settings.Temperature : default,
				Seed = settings.Seed != null ? (ulong)settings.Seed : default,
				Stop = settings != null ? settings.StopSequences : default,
				//RepetitionPenalty = (float)settings.FrequencyPenalty,
				//TopK = (int)settings.PresencePenalty
			};
		}
		ModelClient client = new(_apiKey, ModelType.QianWen);
		QianWenResponseWrapper result = await client.QianWen.GetChatMessageContentsAsync(_model, histroyList, chatParameters, cancellationToken);
		var message = new ChatMessageContent(AuthorRole.Assistant, result.Output.Text);
		return message;
	}

	/// &lt;summary&gt;
	/// 流式对话
	/// &lt;/summary&gt;
	/// &lt;param name="chatHistory"&gt;&lt;/param&gt;
	/// &lt;param name="settings"&gt;&lt;/param&gt;
	/// &lt;param name="kernel"&gt;&lt;/param&gt;
	/// &lt;param name="cancellationToken"&gt;&lt;/param&gt;
	/// &lt;returns&gt;&lt;/returns&gt;
	public async IAsyncEnumerable&lt;string&gt; GetStreamingChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default)
	{
		var histroyList = new List&lt;ChatMessage&gt;();
		ChatParameters chatParameters = null;
		foreach (var item in chatHistory)
		{
			var history = new ChatMessage()
			{
				Role = item.Role.Label,
				Content = item.Content,
			};
			histroyList.Add(history);
		}
		if (settings != null)
		{
			chatParameters = new ChatParameters()
			{
				TopP = settings != null ? (float)settings.TopP : default,
				MaxTokens = settings != null ? settings.MaxTokens : default,
				Temperature = settings != null ? (float)settings.Temperature : default,
				Seed = settings.Seed != null ? (ulong)settings.Seed : default,
				Stop = settings != null ? settings.StopSequences : default,
			};
		}
		ModelClient client = new(_apiKey, ModelType.QianWen);

		await foreach (string item in client.QianWen.GetStreamingChatMessageContentsAsync(_model, histroyList, chatParameters, cancellationToken))
		{
			yield return item;
		}
	}
}
</code></pre> <p>其中，OpenAIPromptExecutionSettings 和 ChatHistory 来自于SK框架，ChatParameters属于自定义的参数类，因为每家模型供应商都不一样。</p> </li><li> <p>ChatParameters的代码</p> <pre><code>public record ChatParameters
{
	/// &lt;summary&gt;
	/// 结果的格式-“text”为旧文本版本，“message”为OpenAI兼容消息。
	/// ＜para＞对于语言模型，此字段必须是中的“text”，而不是VL模型中使用的字段&lt;/para&gt;
	/// &lt;/summary&gt;
	[JsonPropertyName("result_format")]
	public string? ResultFormat { get; set; }

	/// &lt;summary&gt;
	/// 随机数生成器的种子，用于控制模型生成的随机性。
	/// 使用相同的种子允许模型输出的再现性。
	/// &lt;para&gt;此字段为可选字段。默认值为1234。&lt;/para&gt;
	/// &lt;/summary&gt;
	[JsonPropertyName("seed")]
	public ulong? Seed { get; set; }

	/// &lt;summary&gt;
	/// 限制要生成的令牌数量。限制设置了最大值，但不能保证
	/// 确切地说，将生成那么多令牌。此字段是可选的。
	/// &lt;para&gt;qwen turbo和qwen max longcontext的最大值和默认值为1500。&lt;/para&gt;
	/// &lt;para&gt;qwen max、qwen-max-1201和qwen plus的最大值和默认值为2048。&lt;/para&gt;
	/// &lt;/summary&gt;
	[JsonPropertyName("max_tokens")]
	public int? MaxTokens { get; set; }

	/// &lt;summary&gt;
	/// 细胞核取样的概率阈值。以0.8的值为例，
	/// 仅保留累积概率总和大于或等于0.8的令牌。
	/// &lt;para&gt;取值范围为（0,1.0）。取值越大，随机性越高&lt;/para&gt;
	/// &lt;para&gt;值越小，随机性越低。此字段是可选的.&lt;/para&gt;
	/// &lt;para&gt;默认值为0.8。请注意，该值不应大于或等于1.&lt;/para&gt;
	/// &lt;/summary&gt;
	[JsonPropertyName("top_p")]
	public float? TopP { get; set; }

	/// &lt;summary&gt;
	/// 要采样的候选集的大小。例如，当设置为50时，只有前50个令牌
	/// 将考虑进行采样。此字段是可选的。较大的值会增加随机性；
	/// 较小的值会增加确定性。注意：如果top_ k为null或大于100，
	/// 没有使用topk策略，只有topp是有效的。默认值为null。
	/// &lt;/summary&gt;
	[JsonPropertyName("top_k")]
	public int? TopK { get; set; }

	/// &lt;summary&gt;
	/// 为减少模型生成中的冗余而应用重复的惩罚。
	/// 值为1.0表示没有惩罚。此字段是可选的。
	/// &lt;para&gt;默认值为1.1。&lt;/para&gt;
	/// &lt;/summary&gt;
	[JsonPropertyName("repetition_penalty")]
	public float? RepetitionPenalty { get; set; }

	/// &lt;summary&gt;
	/// 控制文本生成的随机性和多样性程度。
	/// 高温度值会降低概率分布的峰值、
	/// 允许选择更多低概率词，从而产生更多样化的输出。
	/// &lt;para&gt;
	/// 低温度值会增加峰度，使高概率词更有可能被选中、
	/// 从而使输出结果更加确定。此字段为可选项。
	/// 数值范围为 [0, 2)。系统默认值为 1.0。
	/// &lt;/para&gt;
	/// &lt;/summary&gt;
	[JsonPropertyName("temperature")]
	public float? Temperature { get; set; }

	/// &lt;summary&gt;
	/// 指定生成后应停止模型进一步输出的内容。
	/// &lt;para&gt;这可以是一个字符串或字符串列表、一个标记 ID 列表或一个标记 ID 列表。
	/// &lt;para&gt;例如，如果将 stop 设置为 "hello"，则在生成 "hello "之前停止生成；&lt;/para
	/// &lt;para&gt;如果设置为[37763, 367]，则在生成相当于 "Observation "的标记 ID 之前停止生成。
	/// &lt;para&gt;
	/// 注意，此字段为可选字段，列表模式不支持字符串和标记 ID 混合使用；&lt;/para&gt; &lt;para&gt;
	/// /// 注意，此字段为可选字段，列表模式不支持字符串和令牌 ID 混合使用。
	/// &lt;/para&gt;
	/// &lt;/summary&gt;
	[JsonPropertyName("stop")]
	public object? Stop { get; set; }

	///&lt;summary&gt;
	///控制在生成过程中是否考虑搜索结果。
	///＜para＞注意：启用搜索并不保证会使用搜索结果&lt;/para&gt;
	///&lt;para&gt;
	///如果启用了搜索，则模型会将搜索结果视为提示的一部分以潜在地生成包括结果的文本。
	///&lt;/para&gt;
	///＜para＞此字段为可选字段，默认为false&lt;/段落&gt;
	///&lt;/summary&gt;
	[JsonPropertyName("enable_search")]
	public bool? EnableSearch { get; set; }

	/// &lt;summary&gt;
	///控制是否启用增量输出模式。
	///&lt;para&gt;
	///默认值为false，这意味着后续输出将包含已完成的段。
	///当设置为true时，将激活增量输出模式，并且后续输出将不包含
	///之前的片段。完整的输出将需要由用户逐步构建。
	///&lt;/para&gt;
	///此字段是可选的，仅适用于流输出模式。
	/// &lt;/summary&gt;
	[JsonPropertyName("incremental_output")]
	public bool? IncrementalOutput { get; set; }

	/// &lt;summary&gt;
	/// 使用同步调用时，此参数应当设置为 fasle 或者省略。表示模型生成完所有内容后一次性返回所有内容。
	/// 如果设置为 true，模型将通过标准 Event Stream ，逐块返回模型生成内容。Event Stream 结束时会返回一条data: [DONE] 消息。
	/// &lt;/summary&gt;
	[JsonPropertyName("stream")]
	public bool Stream { get; set; }

	/// &lt;summary&gt;
	/// 智谱： do_sample 为 true 时启用采样策略，do_sample 为 false 时采样策略 temperature、top_p 将不生效
	/// &lt;/summary&gt;
	[JsonPropertyName("do_sample")]
	public bool DoSample { get; set; }

	/// &lt;summary&gt;
	/// 文心
	/// 通过对已生成的token增加惩罚，减少重复生成的现象。
	/// 说明：（1）值越大表示惩罚越大。
	/// （2）默认1.0，取值范围：[1.0, 2.0]。
	/// &lt;/summary&gt;
	[JsonPropertyName("penalty_score")]
	public float? PenaltyScore { get; set; }

	/// &lt;summary&gt;
	/// 文心
	/// 模型人设，主要用于人设设定。
	/// 例如，你是xxx公司制作的AI助手，
	/// 说明：（1）长度限制1024个字符
	/// （2）如果使用functions参数，不支持设定人设system
	/// &lt;/summary&gt;
	[JsonPropertyName("system")]
	public string System { get; set; }

	/// &lt;summary&gt;
	/// 文心
	/// 强制关闭实时搜索功能，默认false，表示不关闭
	/// &lt;/summary&gt;
	[JsonPropertyName("disable_search")]
	public bool DisableSearch { get; set; }

	/// &lt;summary&gt;
	/// 文心
	/// 是否开启上角标返回
	/// &lt;/summary&gt;
	[JsonPropertyName("enable_citation")]
	public bool EnableCitation { get; set; }

	/// &lt;summary&gt;
	/// 文心
	/// 鉴权参数
	/// &lt;/summary&gt;
	public string Token { get; set; }
}
</code></pre> </li><li> <p>创建QianWenClienthttp请求类</p> <pre><code> public class QianWenClient
 {
	 /// &lt;summary&gt;
	 /// 基础请求地址
	 /// &lt;/summary&gt;
	 private readonly string baseUrl = "https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation";
	 internal QianWenClient(ModelClient parent)
	 {
		 Parent = parent;
	 }
	 internal ModelClient Parent { get; }

	 public async Task&lt;QianWenResponseWrapper&gt; GetChatMessageContentsAsync(string model, IReadOnlyList&lt;ChatMessage&gt; messages, ChatParameters? parameters = null, CancellationToken cancellationToken = default)
	 {
		 HttpRequestMessage httpRequest = new(HttpMethod.Post, baseUrl)
		 {
			 Content = JsonContent.Create(QianWenRequestWrapper.Create(model, new
			 {
				 messages,
			 }, parameters), options: new JsonSerializerOptions
			 {
				 DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
			 }),
		 };
		 HttpResponseMessage resp = await Parent.HttpClient.SendAsync(httpRequest, cancellationToken);
		 return await ModelClient.ReadResponse&lt;QianWenResponseWrapper&gt;(resp, cancellationToken);
	 }

	 public async IAsyncEnumerable&lt;string&gt; GetStreamingChatMessageContentsAsync(string model,
	 IReadOnlyList&lt;ChatMessage&gt; messages,
	 ChatParameters? parameters = null,
	 [EnumeratorCancellation] CancellationToken cancellationToken = default)
	 {
		 HttpRequestMessage httpRequest = new(HttpMethod.Post, baseUrl)
		 {
			 Content = JsonContent.Create(QianWenRequestWrapper.Create(model, new
			 {
				 messages,
			 }, parameters), options: new JsonSerializerOptions
			 {
				 DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
			 }),
		 };
		 httpRequest.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("text/event-stream"));
		 httpRequest.Headers.TryAddWithoutValidation("X-DashScope-SSE", "enable");

		 using HttpResponseMessage resp = await Parent.HttpClient.SendAsync(httpRequest, HttpCompletionOption.ResponseHeadersRead, cancellationToken);
		 if (!resp.IsSuccessStatusCode)
		 {
			 throw new Exception(await resp.Content.ReadAsStringAsync());
		 }

		 string lastText = string.Empty; // 记录上一次返回的数据
		 using StreamReader reader = new(await resp.Content.ReadAsStreamAsync(), Encoding.UTF8);
		 while (!reader.EndOfStream)
		 {
			 if (cancellationToken.IsCancellationRequested) throw new TaskCanceledException();

			 string? line = await reader.ReadLineAsync();
			 if (line != null &amp;&amp; line.StartsWith("data:"))
			 {
				 string data = line["data:".Length..];
				 if (data.StartsWith("{\"code\":"))
				 {
					 throw new Exception(data);
				 }
				 var result = JsonSerializer.Deserialize&lt;QianWenResponseWrapper&gt;(data)!;
				 // 获取新增加的部分数据并返回
				 int commonPrefixLength = 0;
				 while (commonPrefixLength &lt; lastText.Length &amp;&amp; commonPrefixLength &lt; result.Output.Text.Length &amp;&amp; lastText[commonPrefixLength] == data[commonPrefixLength])
				 {
					 commonPrefixLength++;
				 }
				 // 获取新增加的文本部分并返回
				 string newText = result.Output.Text;
				 string addedText = newText.Substring(lastText.Length);

				 lastText = newText;

				 yield return addedText;
			 }
		 }
	 }
 }
</code></pre> </li><li> <p>创建QianWenResponseWrapper基本响应类</p> </li></ol> 
<pre><code>/// &lt;summary&gt;
/// 用于映像请求异步任务的通用基本响应类。
/// &lt;/summary&gt;
public record QianWenResponseWrapper
{
    /// &lt;summary&gt;
    /// The identifier corresponds to each individual request.
    /// &lt;/summary&gt;
    [JsonPropertyName("request_id")]
    public string RequestId { get; init; }

    /// &lt;summary&gt;
    /// The processed task status response associated with the respective request.
    /// &lt;/summary&gt;
    [JsonPropertyName("output")]
    public QianWenChatOutput Output { get; init; }

    /// &lt;summary&gt;
    /// Usage of the request.
    /// &lt;/summary&gt;
    [JsonPropertyName("usage")]
    public QianWenChatTokenUsage? Usage { get; init; }
}
/// &lt;summary&gt;
/// 聊天请求的令牌使用情况。
/// &lt;/summary&gt;
public record QianWenChatTokenUsage
{
    /// &lt;summary&gt;
    /// 输出消息的令牌计数。
    /// &lt;/summary&gt;
    [JsonPropertyName("output_tokens")]
    public int OutputTokens { get; init; }

    /// &lt;summary&gt;
    /// 输入消息的令牌计数。
    /// &lt;/summary&gt;
    [JsonPropertyName("input_tokens")]
    public int InputTokens { get; init; }
}
/// &lt;summary&gt;
/// 聊天请求的输出。
/// &lt;/summary&gt;
public record QianWenChatOutput
{
    /// &lt;summary&gt;
    /// 模型的输出内容。
    /// &lt;/summary&gt;
    [JsonPropertyName("text")]
    public string Text { get; init; }

    /// &lt;summary&gt;
    /// 有3种情况：
    /// &lt;list type="bullet"&gt;
    /// &lt;item&gt;&lt;c&gt;null&lt;/c&gt;正在生成&lt;/item&gt;
    /// &lt;item&gt;&lt;c&gt;stop&lt;/c&gt; 停止了&lt;/item&gt;
    /// &lt;item&gt;&lt;c&gt;length&lt;/c&gt; 文本太长&lt;/item&gt;
    /// &lt;/list&gt;
    /// &lt;/summary&gt;
    [JsonPropertyName("finish_reason")]
    public string FinishReason { get; init; }
}
</code></pre> 
<ol start="8"><li>创建QianWenRequestWrapper请求包装器</li></ol> 
<pre><code>/// &lt;summary&gt;
/// 请求包装器
/// &lt;/summary&gt;
public record QianWenRequestWrapper
{
	public static QianWenRequestWrapper&lt;TInput, TParameters&gt; Create&lt;TInput, TParameters&gt;(string model, TInput input, TParameters? parameters = default) =&gt; new()
	{
			Model = model ?? throw new ArgumentNullException(nameof(model)),
			Input = input ?? throw new ArgumentNullException(nameof(input)),
			Parameters = parameters,
	};

	public static QianWenRequestWrapper&lt;TInput, object&gt; Create&lt;TInput&gt;(string model, TInput inputPrompt) =&gt; new()
	{
			Model = model ?? throw new ArgumentNullException(nameof(model)),
			Input = inputPrompt ?? throw new ArgumentNullException(nameof(inputPrompt)),
	};
}
public record QianWenRequestWrapper&lt;TInput, TParameters&gt; : QianWenRequestWrapper
{
		[JsonPropertyName("model")]
		public string Model { get; set; }

		[JsonPropertyName("input")]
		public TInput Input { get; init; }

		[JsonPropertyName("parameters")]
		public TParameters? Parameters { get; init; }
}
</code></pre> 
<ol start="9"><li>调用</li></ol> 
<pre><code>QianWenChatCompletionService chatgpt = new("你的key", "模型名称：例如qwen-turbo");
ChatHistory historys = new ChatHistory();
historys.AddSystemMessage("你是一个c#编程高手，你将用代码回答我关于.net编程的技术问题，下面是我的第一个问题：");
historys.AddUserMessage("用c#写一个冒泡排序");
// 流式调用
await foreach (string item in chatgpt.GetStreamingChatMessageContentsAsync(historys))
{
    Console.Write(item);
}
//普通调用
var result = await chatgpt.GetChatMessageContentsAsync(historys);
Console.WriteLine(result);
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df28a7ee92582700ebc90394a0e91947/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HiveSQL常用函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8da9f4c48d40be216e04a5c15db35077/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GitHub Copilot 与 OpenAI ChatGPT 的区别及应用领域比较</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>