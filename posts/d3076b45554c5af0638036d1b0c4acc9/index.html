<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>身份认证与口令攻击 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d3076b45554c5af0638036d1b0c4acc9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="身份认证与口令攻击">
  <meta property="og:description" content="身份认证与口令攻击 身份认证身份认证的五种方式口令认证静态口令动态口令(一次性口令)动态口令分类 密码学认证一次性口令认证S/KEY协议改进的S/KEY协议 其于共享密钥的认证 口令行为规律和口令猜测口令规律口令猜测 口令破解操作系统口令破解Windows密码存储机制Windows密码破解方法 Unix/Linux系统口令文件Unix的口令文件Unix口令破解程序CrackJohn the RipperXITSlurpie 密码哈希值破解网络应用口令破解远程口令攻击跨域拓展攻击 口令防御 身份认证 系统安全性常常依赖于对终端用户身份的正确识别与检查。最基本的安全问题：对计算机系统的访问必须根据访问者的身份施加一定的限制。身份认证有两方面的内容：识别和验证。 识别：要明确访问者身份，即必须对系统中的每个合法用户都有识别能力 要保证识别的有效性，必须保证任意两个不同的用户都不能具有相同的识别符 验证：在访问者声称自己的身份后(向系统输入它的识别符)，系统还必须对它所声称的身份进行验证，以防假冒。 个人身份验证方法的四种类型： 所知：验证他知道什么，如密码、口令所有：验证他拥有什么，如身份证、护照、信用卡、智能门卡所在：验证他的位置，如IP、办公室地址用户特征：验证他的生物特征（如指纹、虹膜、DNA等）、行为特征（如击键、笔迹） 身份认证的五种方式 口令认证信物认证地址认证用户特征认证密码学认证 口令的“魔咒”：可记忆、抗猜测 “可记忆”要求口令尽量短、有规律、不复杂“抗猜测”要求口令尽量长、无规律、越复杂越好 没有一种认证方案可实现“文本”口令方案的所有优点。 口令认证 口令认证的不可替代性：口令认证仍将是最主要的认证方式 成本低廉可用性可再生性口令是中硬件token否低生物特征否高 静态口令 用户在注册阶段生成用户名和初始口令，系统在其用户文件或数据库中保存用户的信息。当用户登录认证时，将自己的用户名和口令上传给服务器，服务器通过查询其保存的用户信息来验证用户上传的认证信息是否和保存的用户信息相匹配。如果匹配则认为用户是合法用户，否则拒绝服务，并将认证结果回传给客户端。用户定期改变口令，保证安全性。静态口令因实现简单、使用方便，得到广泛的应用。 动态口令(一次性口令) 基本原理：在用户登录过程中，基于用户口令加入不确定因子，对用户口令和不确定因子进行单向散列函数变换，将结果作为认证数据提交给认证服务器。认证服务器接收到用户的认证数据后，把用户的认证数据和自己用同样的散列算法计算出的数值进行比对，从而实现对用户身份的认证。 动态口令分类 动态口令按生成原理可分为非同步和同步两种认证技术。非同步认证技术生成的动态口令主要是依据挑战－响应原理来实现。 挑战—响应机制
同步认证技术包括与时间有关的时钟同步认证技术和与时间无关的事件同步认证技术。 图形口令：图形密码是一种基于知识的认证机制，它利用人类对视觉信息的记忆与共享的秘密或组成的图像或草图，以提高密码的可记忆性，同时保留传统密码的安全性。 密码学认证 常用的密码学认证协议有一次性口令认证、基于共享密钥的认证、基于公钥证书的认证、零知识证明和标识认证等。 一次性口令认证 一次性口令（One-Time Password, OTP）：一般使用双运算因子来实现 固定因子：即用户的口令或口令散列值动态因子：每次不一样的因子，如时间，事件序列，挑战/应答 挑战—响应机制
S/KEY协议 一次性口令认证协议S/KEY
S/KEY中，服务器产生挑战（challenge）信息。挑战信息由迭代值（Iteration Count, IC）和种子（seed）组成。迭代值，指定散列计算的迭代次数，为1~100之间的数，每执行一次挑战/响应过程，IC减1（当IC为1时，则必须
重新进行初始化）。种子由两个字母和5个数字组成。例如，挑战信息“05 xa13783”表示迭代值为05，种子为“xa13783”。客户端收到挑战后，要将秘密口令与种子“xa13783”拼接后，做5次散列运算。 S/KEY中支持三种散列函数，即MD4, MD5和SHA。OTP服务器将散列函数的固定输出折叠成64位（OTP的长度）。64位OTP可以被转换为一个由6个英文单词组成的短语，每个单词由1~4个字母组成，被编码成11位，6个单词共66位，其中最后2位（ 11 × 6 − 64 = 2 11\times 6 - 64 = 2 11×6−64=2）用于存储校验和。 安全性分析 用户的秘密口令没有在网络上传输，传输的只是一次性口令，并且一次性口令即使在传输过程中被窃取，也不能再次使用。客户端和服务器存储的是用户秘密口令的散列值，即使客户端和服务器被攻陷导致口令散列值被窃取，也需破解口令散列才能获得明文口令。用户登录一定次数后，客户和服务器必须重新初始化口令序列为了防止重放攻击，系统认证服务器具有唯一性，不适合分布式认证单向认证（即服务器对客户端进行认证），不能保证认证服务器的真实性S/KEY使用的种子和迭代值采用明文传输，攻击者可以利用小数攻击来获取一系列口令冒充合法用户。 改进的S/KEY协议 核心思想：不在网络中传输一次性口令散列值。使用用户的口令散列对挑战进行散列，并将计算结果发送给服务器。服务器收到后，同样使用服务器保存的用户口令散列对挑战进行散列计算，并与客户端发来的应答进行比较，如果相同则认证通过，否则拒绝。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T20:02:53+08:00">
    <meta property="article:modified_time" content="2024-05-31T20:02:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">身份认证与口令攻击</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>身份认证与口令攻击</h4> 
 <ul><li><a href="#_1" rel="nofollow">身份认证</a></li><li><ul><li><a href="#_15" rel="nofollow">身份认证的五种方式</a></li><li><a href="#_27" rel="nofollow">口令认证</a></li><li><ul><li><a href="#_35" rel="nofollow">静态口令</a></li><li><a href="#_39" rel="nofollow">动态口令(一次性口令)</a></li><li><a href="#_42" rel="nofollow">动态口令分类</a></li></ul> 
   </li><li><a href="#_50" rel="nofollow">密码学认证</a></li><li><ul><li><a href="#_52" rel="nofollow">一次性口令认证</a></li><li><a href="#SKEY_59" rel="nofollow">S/KEY协议</a></li><li><a href="#SKEY_75" rel="nofollow">改进的S/KEY协议</a></li></ul> 
   </li><li><a href="#_85" rel="nofollow">其于共享密钥的认证</a></li></ul> 
  </li><li><a href="#_91" rel="nofollow">口令行为规律和口令猜测</a></li><li><ul><li><a href="#_92" rel="nofollow">口令规律</a></li><li><a href="#_97" rel="nofollow">口令猜测</a></li></ul> 
  </li><li><a href="#_109" rel="nofollow">口令破解</a></li><li><ul><li><a href="#_110" rel="nofollow">操作系统口令破解</a></li><li><ul><li><a href="#Windows_111" rel="nofollow">Windows密码存储机制</a></li><li><a href="#Windows_120" rel="nofollow">Windows密码破解方法</a></li></ul> 
   </li><li><a href="#UnixLinux_129" rel="nofollow">Unix/Linux系统口令文件</a></li><li><a href="#Unix_139" rel="nofollow">Unix的口令文件</a></li><li><a href="#Unix_156" rel="nofollow">Unix口令破解程序</a></li><li><ul><li><a href="#Crack_157" rel="nofollow">Crack</a></li><li><a href="#John_the_Ripper_160" rel="nofollow">John the Ripper</a></li><li><a href="#XIT_167" rel="nofollow">XIT</a></li><li><a href="#Slurpie_169" rel="nofollow">Slurpie</a></li></ul> 
   </li><li><a href="#_171" rel="nofollow">密码哈希值破解</a></li><li><a href="#_174" rel="nofollow">网络应用口令破解</a></li><li><a href="#_179" rel="nofollow">远程口令攻击</a></li><li><a href="#_188" rel="nofollow">跨域拓展攻击</a></li></ul> 
  </li><li><a href="#_223" rel="nofollow">口令防御</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>身份认证</h2> 
<ul><li>系统安全性常常依赖于对终端用户身份的正确识别与检查。</li><li>最基本的安全问题：对计算机系统的访问必须根据访问者的身份施加一定的限制。</li><li>身份认证有两方面的内容：<strong>识别和验证</strong>。 
  <ul><li>识别：要明确访问者身份，即必须对系统中的每个合法用户都有识别能力</li></ul> 
  <blockquote> 
   <ul><li>要保证识别的有效性，必须保证任意两个不同的用户都不能具有相同的识别符</li></ul> 
  </blockquote> 
  <ul><li>验证：在访问者声称自己的身份后(向系统输入它的识别符)，系统还必须对它所声称的身份进行验证，以防假冒。</li></ul> </li></ul> 
<hr> 
<ul><li><strong>个人身份验证方法的四种类型</strong>： 
  <ul><li>所知：验证他知道什么，如密码、口令</li><li>所有：验证他拥有什么，如身份证、护照、信用卡、智能门卡</li><li>所在：验证他的位置，如IP、办公室地址</li><li>用户特征：验证他的生物特征（如指纹、虹膜、DNA等）、行为特征（如击键、笔迹）</li></ul> </li></ul> 
<hr> 
<h3><a id="_15"></a>身份认证的五种方式</h3> 
<ol><li>口令认证</li><li>信物认证</li><li>地址认证</li><li>用户特征认证</li><li>密码学认证</li></ol> 
<hr> 
<ul><li>口令的“魔咒”：可记忆、抗猜测 
  <ul><li>“可记忆”要求口令尽量短、有规律、不复杂</li><li>“抗猜测”要求口令尽量长、无规律、越复杂越好</li></ul> </li><li><strong>没有一种认证方案可实现“文本”口令方案的所有优点。</strong></li></ul> 
<h3><a id="_27"></a>口令认证</h3> 
<ul><li>口令认证的不可替代性：口令认证仍将是最主要的认证方式</li></ul> 
<table><thead><tr><th>成本低廉</th><th>可用性</th><th>可再生性</th></tr></thead><tbody><tr><td>口令</td><td>是</td><td>中</td></tr><tr><td>硬件token</td><td>否</td><td>低</td></tr><tr><td>生物特征</td><td>否</td><td>高</td></tr></tbody></table> 
<h4><a id="_35"></a>静态口令</h4> 
<ul><li>用户在注册阶段生成用户名和初始口令，系统在其用户文件或数据库中保存用户的信息。</li><li>当用户登录认证时，将自己的用户名和口令上传给服务器，服务器通过查询其保存的用户信息来验证用户上传的认证信息是否和保存的用户信息相匹配。如果匹配则认为用户是合法用户，否则拒绝服务，并将认证结果回传给客户端。</li><li>用户定期改变口令，保证安全性。静态口令因实现简单、使用方便，得到广泛的应用。</li></ul> 
<h4><a id="_39"></a>动态口令(一次性口令)</h4> 
<ul><li>基本原理：在用户登录过程中，基于用户口令加入不确定因子，对用户口令和不确定因子进行单向散列函数变换，将结果作为认证数据提交给认证服务器。认证服务器接收到用户的认证数据后，把用户的认证数据和自己用同样的散列算法计算出的数值进行比对，从而实现对用户身份的认证。</li></ul> 
<hr> 
<h4><a id="_42"></a>动态口令分类</h4> 
<ul><li>动态口令按生成原理可分为<strong>非同步和同步两种认证技术</strong>。</li><li>非同步认证技术生成的动态口令主要是依据<strong>挑战－响应原理</strong>来实现。 
  <ul><li><strong>挑战—响应机制</strong><br> <img src="https://images2.imgbox.com/95/cb/sS6ERlse_o.png" alt="在这里插入图片描述"></li></ul> </li><li>同步认证技术包括与时间有关的<strong>时钟同步认证</strong>技术和与时间无关的<strong>事件同步认证</strong>技术。</li></ul> 
<hr> 
<ul><li>图形口令：图形密码是一种基于知识的认证机制，它利用人类对视觉信息的记忆与共享的秘密或组成的图像或草图，以提高密码的可记忆性，同时保留传统密码的安全性。</li></ul> 
<h3><a id="_50"></a>密码学认证</h3> 
<ul><li>常用的密码学认证协议有<strong>一次性口令认证、基于共享密钥的认证、基于公钥证书的认证、零知识证明和标识认证</strong>等。</li></ul> 
<h4><a id="_52"></a>一次性口令认证</h4> 
<ul><li>一次性口令（One-Time Password, OTP）：一般使用双运算因子来实现 
  <ul><li>固定因子：即用户的口令或口令散列值</li><li>动态因子：每次不一样的因子，如时间，事件序列，<strong>挑战/应答</strong></li></ul> </li></ul> 
<blockquote> 
 <ul><li><strong>挑战—响应机制</strong><br> <img src="https://images2.imgbox.com/d8/f4/KO9jFd6U_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<hr> 
<h4><a id="SKEY_59"></a>S/KEY协议</h4> 
<ul><li>一次性口令认证协议S/KEY<br> <img src="https://images2.imgbox.com/69/1d/rMvSOWeb_o.png" alt="在这里插入图片描述"></li><li>S/KEY中，服务器产生挑战（challenge）信息。挑战信息由迭代值（Iteration Count, IC）和种子（seed）组成。</li><li>迭代值，指定散列计算的迭代次数，为1~100之间的数，每执行一次挑战/响应过程，IC减1（当IC为1时，则必须<br> 重新进行初始化）。种子由两个字母和5个数字组成。例如，挑战信息“05 xa13783”表示迭代值为05，种子为“xa13783”。客户端收到挑战后，要将秘密口令与种子“xa13783”拼接后，做5次散列运算。</li></ul> 
<hr> 
<ul><li>S/KEY中支持三种散列函数，即<strong>MD4, MD5和SHA</strong>。OTP服务器将散列函数的固定输出折叠成64位（OTP的长度）。64位OTP可以被转换为一个由6个英文单词组成的短语，每个单词由1~4个字母组成，被编码成11位，6个单词共66位，其中最后2位（<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          11 
         
        
          × 
         
        
          6 
         
        
          − 
         
        
          64 
         
        
          = 
         
        
          2 
         
        
       
         11\times 6 - 64 = 2 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">11</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">64</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span></span></span></span></span>）用于存储校验和。</li></ul> 
<hr> 
<ul><li>安全性分析</li></ul> 
<ol><li>用户的秘密口令没有在网络上传输，传输的只是一次性口令，并且一次性口令即使在传输过程中被窃取，也不能再次使用。</li><li>客户端和服务器存储的是用户秘密口令的散列值，即使客户端和服务器被攻陷导致口令散列值被窃取，也需破解口令散列才能获得明文口令。</li><li>用户登录一定次数后，客户和服务器必须重新初始化口令序列</li><li>为了防止重放攻击，系统认证服务器具有唯一性，不适合分布式认证</li><li>单向认证（即服务器对客户端进行认证），不能保证认证服务器的真实性</li><li>S/KEY使用的种子和迭代值采用明文传输，攻击者可以利用小数攻击来获取一系列口令冒充合法用户。</li></ol> 
<h4><a id="SKEY_75"></a>改进的S/KEY协议</h4> 
<ul><li>核心思想：<strong>不在网络中传输一次性口令散列值</strong>。使用用户的口令散列对挑战进行散列，并将计算结果发送给服务器。服务器收到后，同样使用服务器保存的用户口令散列对挑战进行散列计算，并与客户端发来的应答进行比较，如果相同则认证通过，否则拒绝。<br> <img src="https://images2.imgbox.com/cc/bf/OWqZ37CA_o.png" alt="在这里插入图片描述"></li><li>安全性分析</li></ul> 
<ol><li>用户很容易求出正确的一次性口令，采用一次性口令的匹配通过服务器的身份认证</li><li>攻击者即使截获一次性口令，也不能破解出用户口令散列</li><li>攻击者不能预测下一次一次性口令，也不能重放成功。</li><li>能够避免监听和重放，但不能防范拦截和修改数据包、会话劫持等攻击</li><li>没有完整性保护机制，无法防范内部攻击</li><li>不能对服务器的身份进行认证</li></ol> 
<h3><a id="_85"></a>其于共享密钥的认证</h3> 
<ul><li>Needham-Schroeder双向鉴别协议<br> <img src="https://images2.imgbox.com/fe/09/lmNffytn_o.png" alt="在这里插入图片描述"></li><li>问题：执行完上述三个步骤后，A和B已得到了由KDC分配的一次性会话密钥，可用于后续的保密通信，为什么还要增加后面两个步骤？</li><li>为了进一步保护通信的完整性和认证性。<strong>第四个步骤是为确保A和B能够相互认证对方的身份</strong>。在这个步骤中，B向A发送一个随机数N2，并用会话密钥Ks对N2进行加密。通过将加密后的N2发送给A，B证明了自己拥有会话密钥Ks，并且A能够验证B的身份。**第五个步骤是为了确保通信的完整性。**在这个步骤中，A使用会话密钥Ks对N2进行加密，并将结果发送给B。B解密接收到的信息，并验证解密后的结果与之前发送的N2是否匹配，从而确认通信的完整性。</li></ul> 
<hr> 
<h2><a id="_91"></a>口令行为规律和口令猜测</h2> 
<h3><a id="_92"></a>口令规律</h3> 
<ul><li>3类脆弱口令行为：<strong>口令构造的偏好性选择、口令重用、基于个人信息构造口令</strong> 
  <ul><li>口令构造的偏好性选择：国民口令，中文国民口令多为纯数字，而英文国民口令多含有字母例如：5201314、woaini1314、iloveyou；口令字符构成</li><li>口令重用：在不同网站重复使用同一个密码，同时在密码中嵌入个人相关信息，如姓名和生日。用户的口令重用是不安全的，所以应当避免。只有跨不同安全级（或重要程度）的账户重用口令，才应努力避免的</li><li>基于个人信息构造口令：用户在构造时喜欢使用姓名、生日、身份证号。</li></ul> </li></ul> 
<h3><a id="_97"></a>口令猜测</h3> 
<ul><li>根据口令破解过程中是否需要连网，<strong>口令猜测算法分为在线破解（Online Guessing）和离线破解（Offline Guessing)。</strong></li><li>根据攻击过程中是否利用用户个人信息，口令猜测算法可以分为<strong>漫步攻击（TrawlingAttacking）和定向攻击（Targeted Attacking）</strong></li></ul> 
<hr> 
<ul><li>漫步攻击：不关心攻击对象的信息，而只关注在允许的猜测次数内，猜测出更多的口令。</li><li>主流的2种漫步攻击算法：基于PCFG的算法和Markov算法。</li><li>算法的核心假设是：<strong>用户构造口令从前向后依次进行</strong>。因此，算法对整个口令进行训练，通过从左到右的字符之间的联系来计算口令的概率。</li></ul> 
<hr> 
<ul><li>定向攻击：尽可能以最快速度猜测出所给定目标（如网站）的口令。因此，攻击者会利用与攻击对象相关的个人信息（人口学相关信息），增强猜测的针对性。用户在其他网站或系统中泄露的口令也可以被攻击者利用来进行定向攻击。</li><li>基于Markov链的定向攻击猜测算法的基本思想是：人群中有多少比例使用某种个人信息，那么攻击对象也有同样可能使用该个人信息。将个人信息分为6大类：用户名A、邮箱前缀E、姓名N、生日B、手机号P和身份证G。</li><li>定向攻击：基于概率上下文无关文法（PCFG）的定向攻击猜测算法Personal-PCFG。基本思想与PCFG攻击模型完全相同：<strong>将口令按字符类型按长度进行切分</strong>。同Targeted-Markov算法一样，<strong>将个人信息也分为6大类</strong>。</li></ul> 
<hr> 
<h2><a id="_109"></a>口令破解</h2> 
<h3><a id="_110"></a>操作系统口令破解</h3> 
<h4><a id="Windows_111"></a>Windows密码存储机制</h4> 
<ul><li>Windows密码：安全策略</li><li>Windows中的**本地安全授权子系统（LSASS，Local Security Authority Subsystem Service）<strong>负责有关安全方面的功能。该子系统将用户登录过程中输入的用户名和密码信息发送给</strong>安全帐号管理器（SAM，Security Account Manage）**决定登录尝试是否合法。</li><li>SAM中的SAM数据库（SAM文件）记录每一个用户帐号的密码记录。SAM文件中每个用户帐号有两条密码记录：LM密码表示和NT哈希表示。</li><li>SAM数据库在磁盘上保存在<code>%systemroot%system32\config\</code>目录下的sam文件中，登陆Windows系统后SAM是<br> 被锁死的，如果选择打开SAM文件会显示被另一个程序使用，无法打开，即使打开也显示空白。<br> <img src="https://images2.imgbox.com/60/fb/mVUDACTz_o.png" alt="在这里插入图片描述"></li><li>SAM文件中每个用户帐号有两条密码记录：LM密码表示和NT哈希表示。<strong>Windows 7以后，默认不包含LM密码表示</strong><img src="https://images2.imgbox.com/78/0f/Prsgz2pl_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="Windows_120"></a>Windows密码破解方法</h4> 
<ol><li>提取SAM文件进行破解：用DOS启动盘启动计算机，把SAM文件拷贝出来，用软件进行分析破解，得到系统口令。</li><li>用备份的SAM文件替换当前SAM文件：攻击者用DOS启动盘启动后，还可以用<code>%SystemRoot%\repair\asm</code>覆盖<code>%SystemRoot%\system32\config\sam</code>，这样系统管理员Administrator的密码就恢复成安装操作系统时的密码，而大部分人在安装操作系统时都将初始密码设置为空或者很简单。</li><li>使用口令修改软件：在不登陆系统的情况下修改系统密码，如Passware Kit Enterprise这款软件可以自动把administrator密码修改为12345。</li><li>系统口令破解软件： 
  <ul><li>Cain：集合多种攻击工具的软件。</li><li>PWDUMP4：主要用于获取本地或远端Windows系统的SAM文件，配合LC5等破解软件使用</li><li>John the Ripper：是Unix/Linux平台上最好的密码破解软件之一。</li></ul> </li></ol> 
<h3><a id="UnixLinux_129"></a>Unix/Linux系统口令文件</h3> 
<ul><li>Unix/Linux系统使用<code>/etc/passwd</code>文件创建和管理账户。 
  <ul><li>文件存储信息的结构</li></ul> <pre><code class="prism language-bash">alice:<span class="token variable">$1</span><span class="token variable">$sumys0Ch</span><span class="token variable">$ao01LX5MF6U</span>:502:502:alice
<span class="token operator">|</span>账号<span class="token operator">|</span>--------密码-----------<span class="token operator">|</span><span class="token environment constant">UID</span><span class="token operator">|</span>默认<span class="token environment constant">UID</span><span class="token operator">|</span>登录目录
</code></pre> </li><li>系统中任何用户和进程都可以读取/etc/passwd文件，安全性不高。</li><li>现在的系统把账户信息和口令密文分开存放，<code>/etc/passwd</code>文件用于保存账户信息，加密后过的密码保存在<code>/etc/shadow</code>或<code>/etc/secure</code>影子口令文件中，只有root用户能够读取。</li></ul> 
<hr> 
<h3><a id="Unix_139"></a>Unix的口令文件</h3> 
<ul><li>UNIX系统用户的口令，本来是经过加密后保存在一个文本文件passwd中的，一般存放在/etc目录下，后来由于安全的需要，把passwd文件中与用户口令相关的域提取出来，组织成文件shadow，并规定只有超级用户才能读取。这种分离工作也称为shadow变换。因此，在破解口令时，需要做UnShadow变换，将/etc/passwd与/etc/shadow合并起来。在此基础上才开始进行口令的破解。</li><li><code>/etc/shadow</code>文件包含用户的加密后口令相关的信息。每个用户一条记录。格式如下：</li></ul> 
<pre><code class="prism language-bash">username:passwd:lastchg:min:max:warn:inactive:expire:flag
</code></pre> 
<table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>username</td><td>登录名</td></tr><tr><td>passwd</td><td>经过加密后的口令</td></tr><tr><td>lastchg</td><td>上次更改口令距今的天数</td></tr><tr><td>min</td><td>两次修改口令之间最少经过的天数</td></tr><tr><td>max</td><td>口令的有效期限</td></tr><tr><td>warn</td><td>口令失效前的警告天数</td></tr><tr><td>inactive</td><td>禁止登录前用户仍然有效的天数</td></tr><tr><td>expire</td><td>禁止登录的天数</td></tr><tr><td>flag</td><td>未使用</td></tr></tbody></table> 
<h3><a id="Unix_156"></a>Unix口令破解程序</h3> 
<h4><a id="Crack_157"></a>Crack</h4> 
<ul><li>Crack：旨在快速定位UNIX口令弱点的口令破解程序，使用标准的猜测技术确定口令。通过生成口令进行加密去匹配原口令密码，或直接从网上截获明文口令。</li><li>Crack 程序中包含了几个很大的字典库，进行解破时它会按照一定的规则将字词进行组合，然后对之进行加密，再与要解破的加密口令匹配。所以运行Crack通常要占用大量的CPU，并要运行相当长的时间才结束</li></ul> 
<h4><a id="John_the_Ripper_160"></a>John the Ripper</h4> 
<ul><li>John The Ripper这个软件是由著名的黑客组织UCF编写的，它支持UNIX、DOS、Windows。</li><li>John The Ripper有四种破解模式： 
  <ul><li>“字典文件”破解模式（Worldlist Mode）</li><li>“简单”破解模式（Single Crack）</li><li>“增强”破解模式（Incremental Mode）</li><li>“外挂模块”破解模式（External Mode）</li></ul> </li></ul> 
<h4><a id="XIT_167"></a>XIT</h4> 
<ul><li>XIT是一个执行词典攻击的UNIX口令破解程序。XIT的功能有限，因为它只能运行词典攻击，但程序很小、运行很快。</li></ul> 
<h4><a id="Slurpie_169"></a>Slurpie</h4> 
<ul><li>Slurpie能执行词典攻击和定制的强行攻击，要规定所需要使用的字符数目和字符类型。</li></ul> 
<h3><a id="_171"></a>密码哈希值破解</h3> 
<ul><li><a href="http://www.cmd5.com/" rel="nofollow">http://www.cmd5.com/</a>：一个MD5和SHA1散列值在线破解的网站，拥有全世界最大的数据库，完全收录1-6位大小写字母+数字+特殊字符、7位小写字母+数字、8位小写字母和8-11位数字，部分收录了8位小写字母+数字，网站平均破解成功率高达95%。</li><li><a href="http://md5crack.adintr.com" rel="nofollow">MD5Crack</a>是一个离线的MD5密码暴力破解软件，具有破解速度快，支持批量破解，保存进度和多线程的特点。</li></ul> 
<h3><a id="_174"></a>网络应用口令破解</h3> 
<ul><li>通过登录攻击来猜测口令，即通过网络运行一个工具周期性地尝试登录目标系统。</li><li>推荐工具： 
  <ul><li>Brutus：免费软件（www.hoobie.net/brutus），运行于Windows平台，支持的协议有基本HTTP认证、带HTML表单的HTTP认证、POP3、FTP、SMB及Telnet</li><li>Hydra：免费软件（http://thc.org/thc-hydra），运行于Linux/Unix平台。</li></ul> </li></ul> 
<h3><a id="_179"></a>远程口令攻击</h3> 
<ul><li>远程口令攻击主要是指网络服务口令攻击，是一种远程在线攻击。破解效率很低，而且容易被记录。</li><li>特点：可以远程进行穷举字典的方式来猜解口令；破解效率很低，而且容易被记录。</li><li>攻击过程大致如下： 
  <ol><li>建立与目标网络服务的网络连接。</li><li>选取一个用户列表文件和一个字典文件。</li><li>在用户列表文件和一个字典文件中，选取一组用户和口令，按照网络服务协议规定，将用户名和口令发给目标网络服务端口。</li><li>检测远程服务返回信息，确定口令尝试是否成功。</li><li>循环2到4步，直到口令破解成功为止</li></ol> </li></ul> 
<h3><a id="_188"></a>跨域拓展攻击</h3> 
<ul><li>脱库（Database Breach）：指攻击者通过某种方式获取并下载整个数据库或其中的敏感数据。这通常涉及通过漏洞、恶意软件或其他非授权手段入侵数据库服务器，并提取其中的数据。</li></ul> 
<p><strong>常见方式</strong>：</p> 
<ol><li><strong>SQL注入</strong>：攻击者利用输入验证缺陷，通过SQL注入攻击获取数据库访问权限。</li><li><strong>未授权访问</strong>：通过弱密码、默认账号或未修补的漏洞，攻击者能够直接访问数据库。</li><li><strong>内部威胁</strong>：公司内部人员利用其权限，非法下载和复制敏感数据。</li></ol> 
<p><strong>风险</strong>：</p> 
<ul><li>数据泄露：敏感信息（如用户密码、财务数据、个人信息）被暴露。</li><li>财务损失：被盗数据可能被用于欺诈或勒索。</li><li>声誉损害：数据泄露事件可能严重影响公司的声誉和客户信任。</li></ul> 
<hr> 
<ul><li>洗库（Data Cleaning or Scrubbing）：指对已经获取的数据库进行处理和清洗，以便去除不需要的数据、重复的数据或错误的数据。对于攻击者而言，洗库是为了提取有用的、可利用的数据。</li></ul> 
<p><strong>常见方式</strong>：</p> 
<ol><li><strong>数据清洗</strong>：使用脚本或工具排除重复数据、无效数据以及错误数据，确保数据的质量。</li><li><strong>数据规范化</strong>：对数据进行格式统一和标准化处理，使其更容易被利用。</li></ol> 
<p><strong>风险</strong>：</p> 
<ul><li>攻击者可以更有效地利用清洗后的数据进行进一步攻击，如撞库攻击或社会工程学攻击。</li></ul> 
<hr> 
<ul><li>撞库（Credential Stuffing）：一种利用已泄露的用户名和密码组合，尝试登录其他网站或服务的攻击手段。攻击者假设用户在多个网站上使用相同的用户名和密码。</li></ul> 
<p><strong>常见方式</strong>：</p> 
<ol><li><strong>自动化脚本</strong>：使用自动化脚本或工具，批量尝试登录目标网站。</li><li><strong>已泄露凭证</strong>：利用在之前数据泄露事件中获得的用户名和密码组合进行尝试。</li></ol> 
<p><strong>风险</strong>：</p> 
<ul><li>未授权访问：攻击者可能获得对其他服务的未授权访问，进一步窃取或滥用信息。</li><li>账户劫持：合法用户账户被攻击者控制，可能导致资金或数据的损失。</li><li>大规模攻击：通过撞库攻击，攻击者能迅速尝试大量账号组合，造成广泛影响。</li></ul> 
<p><img src="https://images2.imgbox.com/d5/e5/yRua9UTU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_223"></a>口令防御</h2> 
<ol><li>强壮的密码策略</li></ol> 
<ul><li>推荐使用密码短语设置长密码。例如“Lee, Ithink I’ll buy another copy of Counter Hack”要比密码“#dx92!$X”难破解得多！</li><li>密码要符合复杂性要求： 
  <ul><li>指定密码最短长度：至少为9个字符</li><li>禁止使用字典词汇，应该包含非字母字符</li><li>少用个信信息</li></ul> </li></ul> 
<hr> 
<ol start="2"><li>用户意识</li></ol> 
<ul><li>不要在不同系统上使用同一口令</li><li>不要选取显而易见的信息作口令</li><li>尽量不要在同一台机器上分配多个用户权限，一旦某个用户具有登录权限，那么他就可能获取该计算机的SAM信息并分析出所有用户的密码。</li></ul> 
<hr> 
<ol start="3"><li>密码过滤软件：为确保用户没有选择弱密码，使用密码过滤工具来规范用户使用强壮的密码。</li></ol> 
<hr> 
<ol start="4"><li>保护密码文件：在支持密码shadow的系统中，确保激活密码shadow。（密码shadow用来在/etc/shadow文件中存储密码表示，仅可以让root读取）</li></ol> 
<hr> 
<ol start="5"><li>分组分类：将重要的账户进行重点保护，那些不怎么重要的账号就可以用简单的密码设置，同类账户可以密码重用。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3cd564ac9e890ce0fbe79706b520ceaa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">7B2 PRO主题5.4.2 免授权开心版源码 | WordPress主题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/677eaf35452b586f6d178f74ec85740a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法（十一）贪婪算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>