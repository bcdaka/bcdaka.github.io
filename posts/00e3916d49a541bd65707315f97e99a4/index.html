<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>链表基础知识详解（非常详细简单易懂） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/00e3916d49a541bd65707315f97e99a4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="链表基础知识详解（非常详细简单易懂）">
  <meta property="og:description" content="概述： 链表作为 C 语言中一种基础的数据结构，在平时写程序的时候用的并不多，但在操作系统里面使用的非常多。不管是RTOS还是Linux等使用非常广泛，所以必须要搞懂链表，链表分为单向链表和双向链表，单向链表很少用，使用最多的还是双向链表。单向链表懂了双向链表自然就会了。
文章目录
一、链表的概念
链表的构成：
链表的操作:
双向链表
链表与数组的对比
二、链表的创建
三、链表的遍历
四、链表的释放
五、链表节点的查找
六、链表节点的删除
七、链表中插入一个节点
八、链表排序
九、双向链表的创建和遍历
十、双向链表插入节点
一、链表的概念 定义：
链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序，实现的一种线性存储结构。
特点：
链表由一系列节点（链表中每一个元素称为节点）组成，节点在运行时动态生成 （malloc），每个节点包括两个部分：
一个是存储数据元素的数据域
另一个是存储下一个节点地址的指针域
图1 单向链表
链表的构成： 链表由一个个节点构成，每个节点一般采用结构体的形式组织，例如：
typedef struct student｛ int num； char name[20]； struct student *next； }STU; 链表节点分为两个域
数据域：存放各种实际的数据，如：num、score等
指针域：存放下一节点的首地址，如：next等.
图2 节点内嵌在一个数据结构中
链表的操作: 链表最大的作用是通过节点把离散的数据链接在一起，组成一个表，这大概就是链表 的字面解释了吧。 链表常规的操作就是节点的插入和删除，为了顺利的插入，通常一条链 表我们会人为地规定一个根节点，这个根节点称为生产者。通常根节点还会有一个节点计 数器，用于统计整条链表的节点个数，具体见图3中的 root_node。
图3带根节点的链表
双向链表 双向链表与单向链表的区别就是节点中有两个节点指针，分别指向前后两个节点，其 它完全一样。有关双向链表的文字描述参考单向链表小节即可，有关双向链表的示意图具体见图4
图4双向链表
链表与数组的对比 在很多公司的嵌入式面试中，通常会问到链表和数组的区别。在 C 语言中，链表与数 组确实很像，两者的示意图具体见图5，这里以双向链表为例。
图5 链表与数组的对比
链表是通过节点把离散的数据链接成一个表，通过对节点的插入和删除操作从而实现 对数据的存取。而数组是通过开辟一段连续的内存来存储数据，这是数组和链表最大的区 别。数组的每个成员对应链表的节点，成员和节点的数据类型可以是标准的 C 类型或者是 用户自定义的结构体。数组有起始地址和结束地址，而链表是一个圈，没有头和尾之分， 但是为了方便节点的插入和删除操作会人为的规定一个根节点。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-08T17:35:26+08:00">
    <meta property="article:modified_time" content="2023-08-08T17:35:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">链表基础知识详解（非常详细简单易懂）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>概述：</h2> 
<p>      链表作为 C 语言中一种基础的数据结构，在平时写程序的时候用的并不多，但在操作系统里面使用的非常多。不管是RTOS还是Linux等使用非常广泛，所以必须要搞懂链表，链表分为单向链表和双向链表，单向链表很少用，使用最多的还是双向链表。单向链表懂了双向链表自然就会了。</p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、链表的概念</a></p> 
<p id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A" rel="nofollow"> 链表的构成：</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%3A-toc" style="margin-left:40px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%3A" rel="nofollow">链表的操作:</a></p> 
<p id="%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" rel="nofollow"> 双向链表</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">链表与数组的对比</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">二、链表的创建</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow"> 三、链表的遍历</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8A%E6%94%BE-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8A%E6%94%BE" rel="nofollow">四、链表的释放</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow"> 五、链表节点的查找</a></p> 
<p id="%E5%85%AD%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">六、链表节点的删除</a></p> 
<p id="%E4%B8%83%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9" rel="nofollow">七、链表中插入一个节点</a></p> 
<p id="%E5%85%AB%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F" rel="nofollow">八、链表排序</a></p> 
<p id="%E4%B9%9D%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86" rel="nofollow">九、双向链表的创建和遍历</a></p> 
<p id="%C2%A0%E5%8D%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%8D%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9" rel="nofollow"> 十、双向链表插入节点</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5">一、链表的概念</h2> 
<p>定义：</p> 
<p>      链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序，实现的一种线性存储结构。</p> 
<p>特点：</p> 
<p>      链表由一系列节点（链表中每一个元素称为节点）组成，节点在运行时动态生成 （malloc），每个节点包括两个部分：</p> 
<p>     一个是存储数据元素的<strong>数据域</strong></p> 
<p>     另一个是存储下一个节点地址的<strong>指针域</strong></p> 
<p><img alt="" height="154" src="https://images2.imgbox.com/ce/22/ScuRC6TE_o.png" width="841"></p> 
<p style="text-align:center;">图1 单向链表</p> 
<p style="text-align:center;"></p> 
<h3 id="%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90%EF%BC%9A"> <strong>链表的构成：</strong></h3> 
<p>      链表由一个个节点构成，每个节点一般采用结构体的形式组织，例如：</p> 
<pre><code>typedef struct student｛
 int num；
 char name[20]；
 struct student *next；
 }STU;</code></pre> 
<p>      链表节点分为两个域</p> 
<p>      数据域：存放各种实际的数据，如：num、score等</p> 
<p>      指针域：存放下一节点的首地址，如：next等.</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/46/96/8QrZxzN1_o.png" width="1200"></p> 
<p style="text-align:center;">图2 节点内嵌在一个数据结构中</p> 
<h3 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%3A"><strong>链表的操作:</strong></h3> 
<p>      链表最大的作用是通过节点把离散的数据链接在一起，组成一个表，这大概就是链表 的字面解释了吧。 链表常规的操作就是节点的插入和删除，为了顺利的插入，通常一条链 表我们会人为地规定一个根节点，这个根节点称为生产者。通常根节点还会有一个节点计 数器，用于统计整条链表的节点个数，具体见图3中的 root_node。</p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/8c/58/ujXk1l2h_o.png" width="1200"></p> 
<p style="text-align:center;">图3带根节点的链表</p> 
<h3 id="%C2%A0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"> <strong>双向链表</strong></h3> 
<p>      双向链表与单向链表的区别就是节点中有两个节点指针，分别指向前后两个节点，其 它完全一样。有关双向链表的文字描述参考单向链表小节即可，有关双向链表的示意图具体见图4</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/84/84/ePqG43cU_o.png" width="1200"></p> 
<p style="text-align:center;">图4双向链表</p> 
<h3 id="%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94"><strong>链表与数组的对比</strong></h3> 
<p>      在很多公司的嵌入式面试中，通常会问到链表和数组的区别。在 C 语言中，链表与数 组确实很像，两者的示意图具体见图5，这里以双向链表为例。</p> 
<p style="text-align:center;"><img alt="" height="373" src="https://images2.imgbox.com/9f/21/3FGdICoT_o.png" width="1200">图5 链表与数组的对比</p> 
<p>      链表是通过节点把离散的数据链接成一个表，通过对节点的插入和删除操作从而实现 对数据的存取。而数组是通过开辟一段连续的内存来存储数据，这是数组和链表最大的区 别。数组的每个成员对应链表的节点，成员和节点的数据类型可以是标准的 C 类型或者是 用户自定义的结构体。数组有起始地址和结束地址，而链表是一个圈，没有头和尾之分， 但是为了方便节点的插入和删除操作会人为的规定一个根节点。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA">二、链表的创建</h2> 
<p>第一步：创建一个节点</p> 
<p><img alt="" height="48" src="https://images2.imgbox.com/c5/d1/4LYb395e_o.png" width="199"></p> 
<p> 第二步：创建第二个节点，将其放在第一个节点的后面（第一的节点的指针域保存第二个节点的地址）</p> 
<p><img alt="" height="42" src="https://images2.imgbox.com/81/76/U9v2oDlr_o.png" width="358"></p> 
<p>第三步：再次创建节点，找到原本链表中的最后一个节点，接着讲最后一个节点的指针域保存新节点的地址，以此内推。</p> 
<p><img alt="" height="42" src="https://images2.imgbox.com/0e/3d/6RjqXqG8_o.png" width="549"></p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//定义结点结构体
typedef struct student
{
    //数据域
    int num;		//学号
    int score;      //分数
    char name[20];  //姓名
    //指针域
    struct student *next;
}STU;

void link_creat_head(STU **p_head,STU *p_new)
{
    STU *p_mov = *p_head;
    if(*p_head == NULL)	//当第一次加入链表为空时，head执行p_new
    {
        *p_head = p_new;
        p_new-&gt;next=NULL;
    }
    else //第二次及以后加入链表
    {
        while(p_mov-&gt;next!=NULL)
        {
            p_mov=p_mov-&gt;next;	//找到原有链表的最后一个节点
        }

        p_mov-&gt;next = p_new;	//将新申请的节点加入链表
        p_new-&gt;next = NULL;
    }
}

int main()
{
    STU *head = NULL,*p_new = NULL;
    int num,i;
    printf("请输入链表初始个数:\n");
    scanf("%d",&amp;num);
    for(i = 0; i &lt; num;i++)
    {
        p_new = (STU*)malloc(sizeof(STU));//申请一个新节点
        printf("请输入学号、分数、名字:\n"); //给新节点赋值
        scanf("%d %d %s",&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name);

        link_creat_head(&amp;head,p_new);	//将新节点加入链表
    }
}
</code></pre> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"> 三、链表的遍历</h2> 
<p>第一步：输出第一个节点的数据域，输出完毕后，让指针保存后一个节点的地址</p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/bf/b3/TNV4G8tD_o.png" width="574"></p> 
<p> 第二步：输出移动地址对应的节点的数据域，输出完毕后，指针继续后移 </p> 
<p> <img alt="" height="188" src="https://images2.imgbox.com/a0/bc/CZONpZzt_o.png" width="1136"></p> 
<p> 第三步：以此类推，直到节点的指针域为NULL</p> 
<pre><code>//链表的遍历
void link_print(STU *head)
{
    STU *p_mov;
    //定义新的指针保存链表的首地址，防止使用head改变原本链表
    p_mov = head;
    //当指针保存最后一个结点的指针域为NULL时，循环结束
    while(p_mov!=NULL)
    {
        //先打印当前指针保存结点的指针域
        printf("num=%d score=%d name:%s\n",p_mov-&gt;num,\
               p_mov-&gt;score,p_mov-&gt;name);

        //指针后移，保存下一个结点的地址
        p_mov = p_mov-&gt;next;
    }
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8A%E6%94%BE">四、链表的释放</h2> 
<p>重新定义一个指针q，保存p指向节点的地址，然后p后移保存下一个节点的地址，然后释放q对应的节点，以此类推，直到p为NULL为止</p> 
<p><img alt="" height="100" src="https://images2.imgbox.com/45/24/59TQSnyh_o.png" width="490"><img alt="" height="104" src="https://images2.imgbox.com/c6/9c/5KDjnfNN_o.png" width="492"></p> 
<pre><code> //链表的释放
 void link_free(STU **p_head)
 {
   //定义一个指针变量保存头结点的地址
   STU *pb=*p_head;

  while(*p_head!=NULL)
  {
   //先保存p_head指向的结点的地址
   pb=*p_head;
   //p_head保存下一个结点地址
   *p_head=(*p_head)‐&gt;next;
   //释放结点并防止野指针
   free(pb);
   pb = NULL;
  }
 }</code></pre> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E6%9F%A5%E6%89%BE"> 五、链表节点的查找</h2> 
<p>      先对比第一个结点的数据域是否是想要的数据，如果是就直接返回，如果不是则继续查找下 一个结点，如果到达最后一个结点的时候都没有匹配的数据，说明要查找数据不存在</p> 
<p></p> 
<pre><code>
//链表的查找
//按照学号查找
STU * link_search_num(STU *head,int num)
{
    STU *p_mov;
    //定义的指针变量保存第一个结点的地址
    p_mov=head;
    //当没有到达最后一个结点的指针域时循环继续
    while(p_mov!=NULL)
    {
        //如果找到是当前结点的数据，则返回当前结点的地址
        if(p_mov-&gt;num == num)//找到了
        {
            return p_mov;
        }
        //如果没有找到，则继续对比下一个结点的指针域
        p_mov=p_mov-&gt;next;
    }

    //当循环结束的时候还没有找到，说明要查找的数据不存在，返回NULL进行标识
    return NULL;//没有找到
}

//按照姓名查找
STU * link_search_name(STU *head,char *name)
{
    STU *p_mov;
    p_mov=head;
    while(p_mov!=NULL)
    {
        if(strcmp(p_mov-&gt;name,name)==0)//找到了
        {
            return p_mov;
        }
        p_mov=p_mov-&gt;next;
    }
    return NULL;//没有找到
}</code></pre> 
<h2 id="%E5%85%AD%E3%80%81%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4">六、链表节点的删除</h2> 
<p>      如果链表为空，不需要删除 如果删除的是第一个结点，则需要将保存链表首地址的指针保存第一个结点的下一个结点的 地址 如果删除的是中间结点，则找到中间结点的前一个结点，让前一个结点的指针域保存这个结 点的后一个结点的地址即可</p> 
<pre><code>//链表结点的删除
void link_delete_num(STU **p_head,int num)
{
    STU *pb,*pf;
    pb=pf=*p_head;
    if(*p_head == NULL)//链表为空，不用删
    {
        printf("链表为空，没有您要删的节点");\
        return ;
    }
    while(pb-&gt;num != num &amp;&amp; pb-&gt;next !=NULL)//循环找，要删除的节点
    {
        pf=pb;
        pb=pb-&gt;next;
    }
    if(pb-&gt;num == num)//找到了一个节点的num和num相同
    {
        if(pb == *p_head)//要删除的节点是头节点
        {
            //让保存头结点的指针保存后一个结点的地址
            *p_head = pb-&gt;next;
        }
        else
        {
            //前一个结点的指针域保存要删除的后一个结点的地址
            pf-&gt;next = pb-&gt;next;
        }

        //释放空间
        free(pb);
        pb = NULL;
    }
    else//没有找到
    {
        printf("没有您要删除的节点\n");
    }
}</code></pre> 
<h2 id="%E4%B8%83%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9">七、链表中插入一个节点</h2> 
<p>链表中插入一个结点，按照原本链表的顺序插入，找到合适的位置</p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/dd/23/YiLve30P_o.png" width="463"></p> 
<p> 情况（按照从小到大）：</p> 
<p>      如果链表没有结点，则新插入的就是第一个结点。</p> 
<p>      如果新插入的结点的数值最小，则作为头结点。</p> 
<p>      如果新插入的结点的数值在中间位置，则找到前一个，然后插入到他们中间。</p> 
<p>      如果新插入的结点的数值最大，则插入到最后。</p> 
<pre><code>//链表的插入：按照学号的顺序插入
void link_insert_num(STU **p_head,STU *p_new)
{
    STU *pb,*pf;
    pb=pf=*p_head;
    if(*p_head ==NULL)// 链表为空链表
    {
        *p_head = p_new;
        p_new-&gt;next=NULL;
        return ;
    }
    while((p_new-&gt;num &gt;= pb-&gt;num)  &amp;&amp; (pb-&gt;next !=NULL) )
    {
        pf=pb;
        pb=pb-&gt;next;
    }

    if(p_new-&gt;num &lt; pb-&gt;num)//找到一个节点的num比新来的节点num大，插在pb的前面
    {
        if(pb== *p_head)//找到的节点是头节点，插在最前面
        {
            p_new-&gt;next= *p_head;
            *p_head =p_new;
        }
        else
        {
            pf-&gt;next=p_new;
            p_new-&gt;next = pb;
        }
    }
    else//没有找到pb的num比p_new-&gt;num大的节点，插在最后
    {
        pb-&gt;next =p_new;
        p_new-&gt;next =NULL;
    }
}</code></pre> 
<h2 id="%E5%85%AB%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F">八、链表排序</h2> 
<p>      如果链表为空，不需要排序。</p> 
<p>      如果链表只有一个结点，不需要排序。</p> 
<p>      先将第一个结点与后面所有的结点依次对比数据域，只要有比第一个结点数据域小的，则交 换位置。</p> 
<p>       交换之后，拿新的第一个结点的数据域与下一个结点再次对比，如果比他小，再次交换，依 次类推。</p> 
<p>      第一个结点确定完毕之后，接下来再将第二个结点与后面所有的结点对比，直到最后一个结 点也对比完毕为止。</p> 
<pre><code>//链表的排序
void link_order(STU *head)
{
    STU *pb,*pf,temp;
    pf=head;

    if(head==NULL)
    {
        printf("链表为空,不用排序\n");
        return ;
    }

    if(head-&gt;next ==NULL)
    {
        printf("只有一个节点，不用排序\n");
        return ;
    }

    while(pf-&gt;next !=NULL)//以pf指向的节点为基准节点，
    {
        pb=pf-&gt;next;//pb从基准元素的下个元素开始
        while(pb!=NULL)
        {
            if(pf-&gt;num &gt; pb-&gt;num)
            {
                temp=*pb;
                *pb=*pf;
                *pf=temp;

                temp.next=pb-&gt;next;
                pb-&gt;next=pf-&gt;next;
                pf-&gt;next=temp.next;
            }
            pb=pb-&gt;next;
        }
        pf=pf-&gt;next;
    }
}</code></pre> 
<h2 id="%E4%B9%9D%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86">九、双向链表的创建和遍历</h2> 
<p>第一步：创建一个节点作为头节点，将两个指针域都保存NULL</p> 
<p><img alt="" height="82" src="https://images2.imgbox.com/9f/28/msB0L7PI_o.png" width="251"></p> 
<p>第二步：先找到链表中的最后一个节点，然后让最后一个节点的指针域保存新插入节点的地址，新插入节点的两个指针域，一个保存上一个节点的地址，一个保存NULL</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//定义结点结构体
typedef struct student
{
    //数据域
    int num;		//学号
    int score;      //分数
    char name[20];  //姓名

    //指针域
    struct student *front;  //保存上一个结点的地址
    struct student *next;   //保存下一个结点的地址
}STU;

void double_link_creat_head(STU **p_head,STU *p_new)
{
    STU *p_mov=*p_head;
    if(*p_head==NULL)				//当第一次加入链表为空时，head执行p_new
    {
        *p_head = p_new;
        p_new-&gt;front = NULL;
        p_new-&gt;next = NULL;
    }
    else	//第二次及以后加入链表
    {
        while(p_mov-&gt;next!=NULL)
        {
            p_mov=p_mov-&gt;next;	//找到原有链表的最后一个节点
        }
        p_mov-&gt;next = p_new;		//将新申请的节点加入链表
        p_new-&gt;front = p_mov;
        p_new-&gt;next = NULL;
    }
}


void double_link_print(STU *head)
{
    STU *pb;
    pb=head;
    while(pb-&gt;next!=NULL)
    {
        printf("num=%d score=%d name:%s\n",pb-&gt;num,pb-&gt;score,pb-&gt;name);
        pb=pb-&gt;next;
    }
    printf("num=%d score=%d name:%s\n",pb-&gt;num,pb-&gt;score,pb-&gt;name);

    printf("***********************\n");

    while(pb!=NULL)
    {
        printf("num=%d score=%d name:%s\n",pb-&gt;num,pb-&gt;score,pb-&gt;name);
        pb=pb-&gt;front;
    }
}

int main()
{
    STU *head=NULL,*p_new=NULL;
    int num,i;
    printf("请输入链表初始个数:\n");
    scanf("%d",&amp;num);
    for(i=0;i&lt;num;i++)
    {
        p_new=(STU*)malloc(sizeof(STU));//申请一个新节点
        printf("请输入学号、分数、名字:\n");	//给新节点赋值
        scanf("%d %d %s",&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name);
        double_link_creat_head(&amp;head,p_new);	//将新节点加入链表
    }

    double_link_print(head);
}
</code></pre> 
<h2 id="%C2%A0%E5%8D%81%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"> 十、双向链表插入节点</h2> 
<p>按照顺序插入结点</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/72/1a/6WNViTOE_o.png" width="400"></p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//定义结点结构体
typedef struct student
{
    //数据域
    int num;		//学号
    int score;      //分数
    char name[20];  //姓名

    //指针域
    struct student *front;  //保存上一个结点的地址
    struct student *next;   //保存下一个结点的地址
}STU;

void double_link_creat_head(STU **p_head,STU *p_new)
{
    STU *p_mov=*p_head;
    if(*p_head==NULL)				//当第一次加入链表为空时，head执行p_new
    {
        *p_head = p_new;
        p_new-&gt;front = NULL;
        p_new-&gt;next = NULL;
    }
    else	//第二次及以后加入链表
    {
        while(p_mov-&gt;next!=NULL)
        {
            p_mov=p_mov-&gt;next;	//找到原有链表的最后一个节点
        }
        p_mov-&gt;next = p_new;		//将新申请的节点加入链表
        p_new-&gt;front = p_mov;
        p_new-&gt;next = NULL;
    }
}


void double_link_print(STU *head)
{
    STU *pb;
    pb=head;
    while(pb-&gt;next!=NULL)
    {
        printf("num=%d score=%d name:%s\n",pb-&gt;num,pb-&gt;score,pb-&gt;name);
        pb=pb-&gt;next;
    }
    printf("num=%d score=%d name:%s\n",pb-&gt;num,pb-&gt;score,pb-&gt;name);

    printf("***********************\n");

    while(pb!=NULL)
    {
        printf("num=%d score=%d name:%s\n",pb-&gt;num,pb-&gt;score,pb-&gt;name);
        pb=pb-&gt;front;
    }
}

//双向链表的删除
void double_link_delete_num(STU **p_head,int num)
{
    STU *pb,*pf;
    pb=*p_head;
    if(*p_head==NULL)//链表为空，不需要删除
    {
        printf("链表为空，没有您要删除的节点\n");
        return ;
    }
    while((pb-&gt;num != num) &amp;&amp; (pb-&gt;next != NULL) )
    {
        pb=pb-&gt;next;
    }
    if(pb-&gt;num == num)//找到了一个节点的num和num相同，删除pb指向的节点
    {
        if(pb == *p_head)//找到的节点是头节点
        {
            if((*p_head)-&gt;next==NULL)//只有一个节点的情况
            {
                *p_head=pb-&gt;next;
            }
            else//有多个节点的情况
            {
                *p_head = pb-&gt;next;//main函数中的head指向下个节点
                (*p_head)-&gt;front=NULL;
            }
        }
        else//要删的节点是其他节点
        {
            if(pb-&gt;next!=NULL)//删除中间节点
            {
                pf=pb-&gt;front;//让pf指向找到的节点的前一个节点
                pf-&gt;next=pb-&gt;next; //前一个结点的next保存后一个结点的地址
                (pb-&gt;next)-&gt;front=pf; //后一个结点的front保存前一个结点的地址
            }
            else//删除尾节点
            {
                pf=pb-&gt;front;
                pf-&gt;next=NULL;
            }
        }

        free(pb);//释放找到的节点

    }
    else//没找到
    {
        printf("没有您要删除的节点\n");
    }
}

int main()
{
    STU *head=NULL,*p_new=NULL;
    int num,i;
    printf("请输入链表初始个数:\n");
    scanf("%d",&amp;num);
    for(i=0;i&lt;num;i++)
    {
        p_new=(STU*)malloc(sizeof(STU));//申请一个新节点
        printf("请输入学号、分数、名字:\n");	//给新节点赋值
        scanf("%d %d %s",&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name);
        double_link_creat_head(&amp;head,p_new);	//将新节点加入链表
    }

    double_link_print(head);

    printf("请输入您要删除的节点的num\n");
    scanf("%d",&amp;num);
    double_link_delete_num(&amp;head,num);
    double_link_print(head);

}
</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6562332d2973fee16ff7a0c83a87dc29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue使用printJs实现前端打印,以及打印分页实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5e59ef2245289ad25d31c4f87a24fe95/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">windows安装stable-diffusion-webui教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>