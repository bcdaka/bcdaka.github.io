<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java-数据结构-链表-LinkedList（二）|ू･ω･` ) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/27b8506e6f3e731e069ff892c1e6dcc8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java-数据结构-链表-LinkedList（二）|ू･ω･` )">
  <meta property="og:description" content="文本目录：
☛一、LinkedList（无头双向非循环链表的结构）：
☛ 二、LinkedList的模拟实现：
❄️1、操作方法：
▶（1）、display()方法：
▶（2）、size()方法：
▶（3）、contains(int key)方法：
▶（4）、addFirst(int data)方法：
▶（5）、addLast(int data)方法：
▶（6）、addIndex(int index,int data)方法：
▶（7）、remove(int data)方法：
▶（8）、removeAllKey(int data)方法：
❄️2、 总代码：
☛三、Java自带的LinkedList：
❄️1、LinkedList的使用：
♠（1）、LinkedList的构造方法：
♠（2）、LinkedList的常用操作：
▷1、indexOf(Object o)方法：
▷2、lastIndexOf(Object o)方法：
▷3、subList(int fromIndex, int toIndex)方法：
♠（3）、LinkedList的遍历： ▷1、使用sout直接遍历：
▷ 2、使用for-each直接遍历：
▷ 4、使用迭代器逆序遍历：
☛ 四、ArrayList和LinkedList的区别：
☛ 总结： 一、LinkedList（无头双向非循环链表的结构）： 对于我们的无头双向链表的结构呢，因为是双向的所以呢，我们每个节点要有两个存储地址的地方，一个存储数据的地方，这样呢，每一个节点都可以访问它的前一个节点和后一个节点了。
我们来看看它的结构是什么样的并且看看其对于结构代码的实现：
这个呢，就是双向无头非循环链表的节点的结构，其是由这以一个节点构成的。
我们来看看是怎样构成的：
我们结构看完了，我们来看看我们怎样使用代码来实现这个节点，我们来看：
二、LinkedList的模拟实现： ❄️1、操作方法： 我们在双向无头非循环链表中要实现的方法，和我们在单向无头非循环链表中的我们自己实现的方法是差不多的方法，所以我们也可以去实现IList接口，来重写方法，以便于管理。
▶（1）、display()方法： 打印双向无头非循环链表。
我们的display() 方法，还是非常简单的，我们只需要遍历一遍链表就可以了，都用不到prev这个地址，和我们在单行无头非循环链表中的代码是差不多的。我们来看：
▶（2）、size()方法： 返回链表的长度。
这个也和我们之前写单向无头非循环链表的方法是差不多的，我们直接看代码：
▶（3）、contains(int key)方法： 查找链表中是否有key这个数据的节点。
那么这个嘛，你懂得~
▶（4）、addFirst(int data)方法： 头插方法。
对于这个链表的头插方法呢和我们之前的不同，对于我们头插呢，要先把newNode的next放head，之后再把head的prev放newNode，之后我们要把head往前移动，但是呢在执行之前呢，我们要先注意的是，当我们的链表为空的时候呢，我们要把 newNode=head=last，我们来看看我们的思路图：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-03T20:34:41+08:00">
    <meta property="article:modified_time" content="2024-09-03T20:34:41+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java-数据结构-链表-LinkedList（二）|ू･ω･` )</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>文本目录</strong>：</p> 
<p id="%E2%98%9B%E4%B8%80%E3%80%81LinkedList%EF%BC%88%E6%97%A0%E5%A4%B4%E5%8F%8C%E5%90%91%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%89%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E2%98%9B%E4%B8%80%E3%80%81LinkedList%EF%BC%88%E6%97%A0%E5%A4%B4%E5%8F%8C%E5%90%91%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%89%EF%BC%9A" rel="nofollow">☛一、LinkedList（无头双向非循环链表的结构）：</a></p> 
<p id="%E2%98%9B%C2%A0%E4%BA%8C%E3%80%81LinkedList%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E2%98%9B%C2%A0%E4%BA%8C%E3%80%81LinkedList%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">☛ 二、LinkedList的模拟实现：</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%E2%9D%84%EF%B8%8F1%E3%80%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%E2%9D%84%EF%B8%8F1%E3%80%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">     ❄️1、操作方法：</a></p> 
<p id="%C2%A0%20%C2%A0%20%E2%96%B6%EF%BC%881%EF%BC%89%E3%80%81display()%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%E2%96%B6%EF%BC%881%EF%BC%89%E3%80%81display%28%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">    ▶（1）、display()方法：</a></p> 
<p id="%C2%A0%20%C2%A0%20%E2%96%B6%EF%BC%882%EF%BC%89%E3%80%81size()%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%E2%96%B6%EF%BC%882%EF%BC%89%E3%80%81size%28%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">    ▶（2）、size()方法：</a></p> 
<p id="%C2%A0%20%E2%96%B6%EF%BC%883%EF%BC%89%E3%80%81contains(int%20key)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%E2%96%B6%EF%BC%883%EF%BC%89%E3%80%81contains%28int%20key%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">  ▶（3）、contains(int key)方法：</a></p> 
<p id="%C2%A0%20%C2%A0%E2%96%B6%EF%BC%884%EF%BC%89%E3%80%81addFirst(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%E2%96%B6%EF%BC%884%EF%BC%89%E3%80%81addFirst%28int%20data%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">   ▶（4）、addFirst(int data)方法：</a></p> 
<p id="%E2%96%B6%EF%BC%885%EF%BC%89%E3%80%81addLast(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E2%96%B6%EF%BC%885%EF%BC%89%E3%80%81addLast%28int%20data%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">▶（5）、addLast(int data)方法：</a></p> 
<p id="%E2%96%B6%EF%BC%886%EF%BC%89%E3%80%81addIndex(int%20index%2Cint%20data)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E2%96%B6%EF%BC%886%EF%BC%89%E3%80%81addIndex%28int%20index%2Cint%20data%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">▶（6）、addIndex(int index,int data)方法：</a></p> 
<p id="%E2%96%B6%EF%BC%887%EF%BC%89%E3%80%81remove(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E2%96%B6%EF%BC%887%EF%BC%89%E3%80%81remove%28int%20data%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">▶（7）、remove(int data)方法：</a></p> 
<p id="%C2%A0%E2%96%B6%EF%BC%888%EF%BC%89%E3%80%81removeAllKey(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%96%B6%EF%BC%888%EF%BC%89%E3%80%81removeAllKey%28int%20data%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow"> ▶（8）、removeAllKey(int data)方法：</a></p> 
<p id="%E2%9D%84%EF%B8%8F2%E3%80%81%20%E6%80%BB%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%9D%84%EF%B8%8F2%E3%80%81%20%E6%80%BB%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">❄️2、 总代码：</a></p> 
<p id="%E2%98%9B%E4%B8%89%E3%80%81Java%E8%87%AA%E5%B8%A6%E7%9A%84LinkedList%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E2%98%9B%E4%B8%89%E3%80%81Java%E8%87%AA%E5%B8%A6%E7%9A%84LinkedList%EF%BC%9A" rel="nofollow">☛三、Java自带的LinkedList：</a></p> 
<p id="%E2%9D%84%EF%B8%8F1%E3%80%81LinkedList%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E2%9D%84%EF%B8%8F1%E3%80%81LinkedList%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A" rel="nofollow">❄️1、LinkedList的使用：</a></p> 
<p id="%C2%A0%20%C2%A0%20%E2%99%A0%EF%BC%881%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%E2%99%A0%EF%BC%881%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">    ♠（1）、LinkedList的构造方法：</a></p> 
<p id="%E2%99%A0%EF%BC%882%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E2%99%A0%EF%BC%882%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">♠（2）、LinkedList的常用操作：</a></p> 
<p id="%E2%96%B71%E3%80%81indexOf(Object%20o)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E2%96%B71%E3%80%81indexOf%28Object%20o%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">▷1、indexOf(Object o)方法：</a></p> 
<p id="%E2%96%B72%E3%80%81lastIndexOf(Object%20o)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E2%96%B72%E3%80%81lastIndexOf%28Object%20o%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">▷2、lastIndexOf(Object o)方法：</a></p> 
<p id="%E2%96%B73%E3%80%81subList(int%20fromIndex%2C%20int%20toIndex)%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E2%96%B73%E3%80%81subList%28int%20fromIndex%2C%20int%20toIndex%29%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">▷3、subList(int fromIndex, int toIndex)方法：</a></p> 
<p id="%E2%99%A0%EF%BC%883%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%99%A0%EF%BC%883%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A%C2%A0" rel="nofollow">♠（3）、LinkedList的遍历： </a></p> 
<p id="%C2%A0%E2%96%B71%E3%80%81%E4%BD%BF%E7%94%A8sout%E7%9B%B4%E6%8E%A5%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%C2%A0%E2%96%B71%E3%80%81%E4%BD%BF%E7%94%A8sout%E7%9B%B4%E6%8E%A5%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow"> ▷1、使用sout直接遍历：</a></p> 
<p id="%C2%A0%C2%A0%E2%96%B7%C2%A02%E3%80%81%E4%BD%BF%E7%94%A8for-each%E7%9B%B4%E6%8E%A5%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%C2%A0%C2%A0%E2%96%B7%C2%A02%E3%80%81%E4%BD%BF%E7%94%A8for-each%E7%9B%B4%E6%8E%A5%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">  ▷ 2、使用for-each直接遍历：</a></p> 
<p id="%C2%A0%C2%A0%E2%96%B7%204%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%C2%A0%C2%A0%E2%96%B7%204%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">  ▷ 4、使用迭代器逆序遍历：</a></p> 
<p id="%E2%98%9B%C2%A0%E5%9B%9B%E3%80%81ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E2%98%9B%C2%A0%E5%9B%9B%E3%80%81ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A" rel="nofollow">☛ 四、ArrayList和LinkedList的区别：</a></p> 
<p id="%E2%98%9B%C2%A0%E6%80%BB%E7%BB%93%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#%E2%98%9B%C2%A0%E6%80%BB%E7%BB%93%EF%BC%9A%C2%A0" rel="nofollow">☛ 总结： </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E2%98%9B%E4%B8%80%E3%80%81LinkedList%EF%BC%88%E6%97%A0%E5%A4%B4%E5%8F%8C%E5%90%91%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%89%EF%BC%9A" style="background-color:transparent;"><img alt="" height="82" src="https://images2.imgbox.com/f2/dc/mVQMi3Dc_o.gif" width="82"><em>一、LinkedList（无头双向非循环链表的结构）：</em></h2> 
<p>     <span style="color:#0d0016;"><strong>对于我们的</strong></span><span style="color:#956fe7;"><strong>无头双向链表的结构</strong></span><span style="color:#0d0016;"><strong>呢，因为是双向的所以呢，我们每个节点要有两个存储地址的地方，一个存储数据的地方，这样呢，每一个节点都可以访问它的前一个节点和后一个节点了。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>      我们来看看它的结构是什么样的并且看看其对于结构代码的实现：</strong></span><img alt="" height="448" src="https://images2.imgbox.com/01/93/HLmfwu6W_o.png" width="424"></p> 
<p>  <span style="color:#0d0016;"><strong>这个呢，就是</strong></span><span style="color:#fe2c24;"><strong>双向无头非循环链表的节点的结构</strong></span><span style="color:#0d0016;"><strong>，其是由这以一个节点构成的。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>我们来看看是怎样构成的：</strong></span><img alt="" height="610" src="https://images2.imgbox.com/ae/1a/zCqF0xn7_o.png" width="1200"></p> 
<p><span style="color:#0d0016;"><strong>我们结构看完了，我们来看看我们怎样使用代码来实现这个节点，我们来看：</strong></span></p> 
<p><img alt="" height="945" src="https://images2.imgbox.com/81/c7/K4nQ0mV4_o.png" width="1200"></p> 
<hr> 
<h2 id="%E2%98%9B%C2%A0%E4%BA%8C%E3%80%81LinkedList%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%EF%BC%9A" style="background-color:transparent;"><img alt="" height="82" src="https://images2.imgbox.com/44/1e/fA4K2ADt_o.gif" width="82"><em>二、LinkedList的模拟实现：</em></h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%E2%9D%84%EF%B8%8F1%E3%80%81%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%EF%BC%9A" style="background-color:transparent;">     ❄️1、操作方法：</h3> 
<p>     <span style="color:#0d0016;"><strong> 我们在双向无头非循环链表中要实现的方法，和我们在单向无头非循环链表中的我们自己实现的方法是差不多的方法，所以我们也可以去实现IList接口，来重写方法，以便于管理。</strong></span></p> 
<h4 id="%C2%A0%20%C2%A0%20%E2%96%B6%EF%BC%881%EF%BC%89%E3%80%81display()%E6%96%B9%E6%B3%95%EF%BC%9A"><span style="color:#956fe7;"><strong> </strong></span><span style="color:#4da8ee;"><strong>   ▶</strong></span><span style="color:#956fe7;"><strong>（1）、display()方法：</strong></span></h4> 
<p><span style="color:#956fe7;"><strong>              </strong></span><span style="color:#511b78;"><strong>   打印双向无头非循环链表。</strong></span></p> 
<p>     <span style="color:#0d0016;"><strong> 我们的display() 方法，还是非常简单的，我们</strong></span><span style="color:#956fe7;"><strong>只需要遍历一遍链表就可以了</strong></span><span style="color:#0d0016;"><strong>，都用不到prev这个地址，</strong></span><span style="color:#956fe7;"><strong>和我们在单行无头非循环链表中的代码是差不多的</strong></span><span style="color:#0d0016;"><strong>。我们来看：</strong></span><img alt="" height="642" src="https://images2.imgbox.com/5e/24/98Sl8wfo_o.png" width="1035"></p> 
<hr> 
<h4 id="%C2%A0%20%C2%A0%20%E2%96%B6%EF%BC%882%EF%BC%89%E3%80%81size()%E6%96%B9%E6%B3%95%EF%BC%9A">    <span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（2）、size()方法：</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>                  </strong></span><span style="color:#511b78;"><strong>    返回链表的长度。</strong></span></p> 
<p><span style="color:#511b78;"><strong>这个也和我们之前写单向无头非循环链表的方法是差不多的，我们直接看代码：</strong></span></p> 
<p><img alt="" height="658" src="https://images2.imgbox.com/9f/76/9daCA7XC_o.png" width="798"></p> 
<hr> 
<h4 id="%C2%A0%20%E2%96%B6%EF%BC%883%EF%BC%89%E3%80%81contains(int%20key)%E6%96%B9%E6%B3%95%EF%BC%9A">  <span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（3）、contains(int key)方法：</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>                  </strong></span><span style="color:#511b78;"><strong>    查找链表中是否有key这个数据的节点。</strong></span></p> 
<p><span style="color:#511b78;"><strong>那么这个嘛，你懂得~</strong></span><img alt="" height="639" src="https://images2.imgbox.com/84/ed/2QPHWQSu_o.png" width="817"></p> 
<hr> 
<p></p> 
<h4 id="%C2%A0%20%C2%A0%E2%96%B6%EF%BC%884%EF%BC%89%E3%80%81addFirst(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A">   <span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（4）、addFirst(int data)方法：</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>                  </strong></span><span style="color:#511b78;"><strong>    头插方法。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>       对于这个链表的头插方法呢和我们之前的不同，对于我们头插呢，</strong></span><span style="color:#fe2c24;"><strong>要先把newNode的next放head，之后再把head的prev放newNode，之后我们要把head往前移动</strong></span><span style="color:#0d0016;"><strong>，但是呢在执行之前呢，我们要先注意的是，</strong></span><span style="color:#fe2c24;"><strong>当我们的链表为空的时候呢，我们要把 newNode=head=last，</strong></span><span style="color:#0d0016;"><strong>我们来看看我们的思路图：</strong></span><img alt="" height="1200" src="https://images2.imgbox.com/ab/02/NTtrosI9_o.png" width="1200"></p> 
<p>  <span style="color:#0d0016;"><strong>我们来看看代码是如何实现的： </strong></span><img alt="" height="685" src="https://images2.imgbox.com/ff/3a/21gvtsns_o.png" width="922"></p> 
<hr> 
<h4 id="%E2%96%B6%EF%BC%885%EF%BC%89%E3%80%81addLast(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A"><span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（5）、addLast(int data)方法：</strong></span></h4> 
<p><span style="color:#956fe7;"><strong>                  尾插方法。</strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>这个尾插方法的操作呢和我们上面的头插是类似的操作，我们也是先判断链表是否为空，</strong></span><span style="color:#956fe7;"><strong>如果为空要执行 head=last=newNode 操作</strong></span><span style="color:#0d0016;"><strong>，</strong></span><span style="color:#ff9900;"><strong>当我们不为空的时候呢，要把 newNode 的地址存放到 last 的 next 里面，newNode 的 prev 里面要存放 last 的地址，最后再把 last 往后移</strong></span><span style="color:#0d0016;"><strong>。还是老样子，我们先来看看思路图：</strong></span><img alt="" height="1200" src="https://images2.imgbox.com/fe/e9/bNuUZmsI_o.png" width="1200"></p> 
<p>  <span style="color:#4da8ee;"><strong>OK，我们在理解这个尾插的操作之后呢，我们来看看代码是如何实现的：</strong></span><img alt="" height="669" src="https://images2.imgbox.com/b8/06/uae0porA_o.png" width="984"></p> 
<hr> 
<h4 id="%E2%96%B6%EF%BC%886%EF%BC%89%E3%80%81addIndex(int%20index%2Cint%20data)%E6%96%B9%E6%B3%95%EF%BC%9A" style="background-color:transparent;"><span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（6）、addIndex(int index,int data)方法：</strong></span></h4> 
<p><span style="color:#956fe7;"><strong>                        在index这个位置插入data这个数据的节点。</strong></span></p> 
<p>      <span style="color:#0d0016;"><strong>对于这个方法呢，在</strong></span><span style="color:#4da8ee;"><strong>双向链表中和在单向链表中是不一样的</strong></span><span style="color:#0d0016;"><strong>，我们在</strong></span><span style="color:#1c7331;"><strong>单向链表中我们要找到添加位置节点的前一个节点</strong></span><span style="color:#0d0016;"><strong>，</strong></span><span style="color:#956fe7;"><strong>但是呢对于双向链表我们可以直接找要添加的位置的节点就可以了</strong></span><span style="color:#0d0016;"><strong>。但是在执行这个操作之前呢，</strong></span><span style="color:#ff9900;"><strong>我们要先判断index是否是有效的，并且在index=0，index =链表的长度 的时候分别进行头插和尾插操作就可以了</strong></span><span style="color:#0d0016;"><strong>。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>      我们还是老样子，先来看思路图：</strong></span><img alt="" height="586" src="https://images2.imgbox.com/ee/5a/yRG8t8aA_o.png" width="686"></p> 
<p> <span style="color:#0d0016;"><strong> 我们来看看代码是怎样实现的：</strong></span></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/48/03/WRq1YQ3R_o.png" width="1200"></p> 
<hr> 
<h4 id="%E2%96%B6%EF%BC%887%EF%BC%89%E3%80%81remove(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A" style="background-color:transparent;"><span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（7）、remove(int data)方法：</strong></span></h4> 
<p><span style="color:#956fe7;"><strong>                       删除</strong></span><span style="color:#fe2c24;"><strong>第一次</strong></span><span style="color:#956fe7;"><strong>出现data的这个数据的节点。</strong></span></p> 
<p>      <span style="color:#0d0016;"><strong> 对于这个remove方法和上面那个方法是相似的，</strong></span><span style="color:#956fe7;"><strong>我们同样不需要找删除节点的前一个节点，我们同样只需要找要删除的那个节点就可以了</strong></span><span style="color:#0d0016;"><strong>。但是这个方法还是很麻烦的，我们在删除的过程中呢，要考虑很多的地方。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>       我们先来看看在中间的时候删除操作是怎样执行的：</strong></span><img alt="" height="1200" src="https://images2.imgbox.com/34/7d/Hr5SS0Mj_o.png" width="1200"></p> 
<p><span style="color:#0d0016;"><strong>接下来我们来<img alt="" height="48" src="https://images2.imgbox.com/4f/19/aA4Qq2xt_o.png" width="48">我们需要 注意的地方：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>      </strong></span><span style="color:#ff9900;"><strong>   1、删除的地方是 head 这个位置的时候</strong></span><span style="color:#0d0016;"><strong>：</strong></span><img alt="" height="1200" src="https://images2.imgbox.com/70/48/aPekDCwV_o.png" width="1200"></p> 
<p>     <span style="color:#ff9900;"><strong> 2 、删除的地方是 last 这个位置的时候</strong></span><span style="color:#0d0016;"><strong>： </strong></span><img alt="" height="1200" src="https://images2.imgbox.com/d8/70/SCZgyiZa_o.png" width="1200"></p> 
<p><span style="color:#0d0016;"><strong>  OK，我们也分析了这么多了，我们来看看代码是如何实现这个操作的吧：</strong></span><img alt="" height="1200" src="https://images2.imgbox.com/53/22/bGR45kqw_o.png" width="1200"></p> 
<hr> 
<h4 id="%C2%A0%E2%96%B6%EF%BC%888%EF%BC%89%E3%80%81removeAllKey(int%20data)%E6%96%B9%E6%B3%95%EF%BC%9A"> <span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（8）、removeAllKey(int data)方法：</strong></span></h4> 
<p><span style="color:#956fe7;"><strong>                       删除出现data的这个数据的</strong></span><span style="color:#fe2c24;"><strong>所有</strong></span><span style="color:#956fe7;"><strong>节点。</strong></span></p> 
<p>    <span style="color:#0d0016;"><strong>   这个操作呢，当我们理解了上面的删除操作之后呢，对于这个操作就非常的简单了，</strong></span><span style="color:#956fe7;"><strong>这个是删除所有出现data这个数据的节点，所以我们要遍历一遍链表才能结束</strong></span><span style="color:#0d0016;"><strong>，所以和上面的代码十分的相似，就是你没有 return 这行代码而已，这里我们直接看代码：</strong></span><img alt="" height="680" src="https://images2.imgbox.com/12/b7/VwMZXZcZ_o.png" width="686"></p> 
<hr> 
<p>  <span style="color:#4da8ee;"><strong>▶</strong></span><span style="color:#956fe7;"><strong>（9）、clear()方法：</strong></span></p> 
<p><span style="color:#956fe7;"><strong>                         清除链表。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>        </strong></span><span style="color:#0d0016;"><strong>这个清除链表的代码呢和我们在写单向链表的时候是十分相似的。我们只需要在其基础上把prev也同样置为null就可以了，我们还是直接来看代码的实现：</strong></span><img alt="" height="567" src="https://images2.imgbox.com/6d/ed/9mg8ly94_o.png" width="768"></p> 
<hr> 
<h3 id="%E2%9D%84%EF%B8%8F2%E3%80%81%20%E6%80%BB%E4%BB%A3%E7%A0%81%EF%BC%9A" style="background-color:transparent;">❄️2、 总代码：</h3> 
<p>    <span style="color:#0d0016;"><strong>   我们所有的代码都分析完事了，当然这些操作方法不是我们 Java 里 LinkedList 的所有方法，只是经常使用的操作，下面我们把这些代码结合起来看看：</strong></span></p> 
<pre><code class="language-java">public class MyLinkedList implements IList{

    //我们对于双向无头非非循环链表的节点呢，我们也是使用内部类来构成的
    static class ListNode {
        public int val;
        public ListNode prev;//默认为null
        public ListNode next;//默认为null

        public ListNode(int val) {
            this.val = val;
        }
    }
    public ListNode head;
    public ListNode last;

    @Override
    public void addFirst(int data) {
        ListNode newNode = new ListNode(data);

        if (this.head == null) {
            this.head = this.last = newNode;
        }else {
            newNode.next = this.head;
            this.head.prev = newNode;
            this.head = newNode;
        }
    }

    @Override
    public void addLast(int data) {
        ListNode newNode = new ListNode(data);

        if (this.head == null) {
            this.head = this.last = newNode;
        }else {
            this.last.next = newNode;
            newNode.prev = this.last;
            this.last = this.last.next;
        }
    }

    private void indexException2(int index) throws IndexException{
        if (index &lt; 0 || index &gt; size()) {
            throw new IndexException("index错误");
        }
    }

    private ListNode findKeyNode(int index) {
        ListNode cur = this.head;
        while(index != 0) {
            cur = cur.next;
            index--;
        }
        return cur;
    }
    @Override
    public void addIndex(int index, int data) {
        try{
            indexException2(index);

            if (index == 0) {
                addFirst(data);
                return;
            }
            if (index == size()) {
                addLast(data);
                return;
            }

            //处理中间
            ListNode cur = findKeyNode(index);
            ListNode newNode = new ListNode(data);
            //处理next
            newNode.next = cur;
            cur.prev.next = newNode;
            //处理prev
            newNode.prev = cur.prev;
            cur.prev = newNode;
        }catch (IndexException e) {
            System.out.println("index输入错误");
            e.printStackTrace();
        }
    }

    @Override
    public boolean contains(int key) {
        ListNode cur = this.head;
        while(cur != null) {
            if (cur.val == key) {
                return true;
            }
            cur = cur.next;
        }
        return false;
    }

    @Override
    public void remove(int key) {
        ListNode cur = this.head;
        while(cur != null) {
            if (cur.val == key) {
                //开始删除
                if (cur == this.head) {
                    this.head = this.head.next;
                    if (this.head != null) {
                        this.head.prev = null;
                    }
                }else {
                    cur.prev.next = cur.next;
                    if (cur == this.last) {
                        this.last = this.last.prev;
                    }else {
                        cur.next.prev = cur.prev;
                    }
                }
                return;
            }
            cur = cur.next;
        }
    }

    @Override
    public void removeAllKey(int key) {
        ListNode cur = this.head;
        while(cur != null) {
            if (cur.val == key) {
                //开始删除
                if (cur == this.head) {
                    this.head = this.head.next;
                    if (this.head != null) {
                        this.head.prev = null;
                    }
                }else {
                    cur.prev.next = cur.next;
                    if (cur == this.last) {
                        this.last = this.last.prev;
                    }else {
                        cur.next.prev = cur.prev;
                    }
                }
            }
            cur = cur.next;
        }
    }

    @Override
    public int size() {
        ListNode cur = this.head;
        int log = 0;
        while(cur != null) {
            log++;
            cur = cur.next;
        }
        return log;
    }

    @Override
    public void display() {
        ListNode cur = this.head;
        while(cur != null) {
            System.out.print(cur.val + "-&gt;");
            cur = cur.next;
        }
        System.out.println("");
    }

    @Override
    public void clear() {
        ListNode cur = this.head;
        while(cur != null) {
            ListNode curNext = cur.next;
            cur.prev = null;
            cur.next = null;
            cur = curNext;
        }
        this.head = this.last = null;
    }
}
</code></pre> 
<hr> 
<h2 id="%E2%98%9B%E4%B8%89%E3%80%81Java%E8%87%AA%E5%B8%A6%E7%9A%84LinkedList%EF%BC%9A" style="background-color:transparent;"><img alt="" height="82" src="https://images2.imgbox.com/6e/fe/wvCOYtHF_o.gif" width="82"><em>三、Java自带的LinkedList：</em></h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>对于这个 LinkedList 方面的知识我们也可以去到Java官网去查看：</strong></span></p> 
 <p><a class="link-info" href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" rel="nofollow" title="      在Java的LinkedList的官方文档">      在Java的LinkedList的官方文档</a></p> 
</blockquote> 
<p>     <span style="color:#0d0016;"><strong>   我们在 Java 每次使用双向链表的时候，不需要每次都去把我们这个自实现的代码重写一遍。在 Java 中呢，Java官方已经在底层里面添加了链表，而且这个链表的底层使用的就是双向无头非循环的链表来实现的。 </strong></span></p> 
<p>     <strong><span style="color:#0d0016;">对于Java自带的链表这里呢有一些注意：</span></strong></p> 
<p><strong><span style="color:#956fe7;">▷1、LinkedList实现了List这个接口</span></strong></p> 
<p><strong><span style="color:#956fe7;">▷2、LinkedList的底层使用双向链表</span></strong></p> 
<p><strong><span style="color:#956fe7;">▷3、LinkedList不支持随机访问，因为没有实现RandoimAccess接口</span></strong></p> 
<p><strong><span style="color:#956fe7;">▷4、LinkedList的任意位置的插入和删除的效率比较高，时间复杂度是O(1)</span></strong></p> 
<p><span style="color:#956fe7;"><strong>▷5、LinkedList适合用于任意位置的插入和删除</strong></span></p> 
<p> </p> 
<hr> 
<h3 id="%E2%9D%84%EF%B8%8F1%E3%80%81LinkedList%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A" style="background-color:transparent;">❄️1、LinkedList的使用：</h3> 
<h4 id="%C2%A0%20%C2%A0%20%E2%99%A0%EF%BC%881%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A">    <span style="color:#956fe7;"><strong>♠（1）、LinkedList的构造方法：</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>    我们的 LinkedList 的构造方法有</strong></span><span style="color:#956fe7;"><strong>两种构造方法</strong></span><span style="color:#0d0016;"><strong>：</strong></span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>1、无参构造：</strong></span></p> 
 <p><img alt="" height="193" src="https://images2.imgbox.com/fb/2e/iIPFXW3z_o.png" width="1087"></p> 
</blockquote> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">2、 LinkedList(Collection &lt;? extends E&gt; c) 构造方法：</span></strong></p> 
 <p><span style="color:#fe2c24;"><strong>      这个里面放的是实现Collection这个接口的对象，并且呢是 E 或者是 E 的子类。</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>我们来看看怎么使用：</strong></span><img alt="" height="877" src="https://images2.imgbox.com/ca/a7/Vz2W3Rbt_o.png" width="1200"></p> 
 <p><img alt="" height="162" src="https://images2.imgbox.com/42/54/m6j96953_o.png" width="463"></p> 
 <p> <span style="color:#fe2c24;"><strong>这个就是在传入的参数之上进行操作的。</strong></span></p> 
</blockquote> 
<hr> 
<h4 id="%E2%99%A0%EF%BC%882%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%EF%BC%9A" style="background-color:transparent;"><span style="color:#956fe7;"><strong>♠</strong>（2）、LinkedList的常用操作：</span></h4> 
<p>    <span style="color:#0d0016;"><strong> 我们在自实现 LinkedList 的时候呢，我们大多数的操作都实现了，在Java自带的LinkedList 里面都有这个对应的操作，但是呢没有display() 这个方法。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    但是呢，在Java 自带得LinkedList 里面呢，我们也有没有自实现的，我们来看看常用的操作是怎样进行的：</strong></span></p> 
<h5 id="%E2%96%B71%E3%80%81indexOf(Object%20o)%E6%96%B9%E6%B3%95%EF%BC%9A"><span style="color:#1a439c;"><strong>▷1、indexOf(Object o)方法：</strong></span></h5> 
<p><span style="color:#0d0016;"><strong>          返回第一个出现o的的位置下标。</strong></span></p> 
<h5 id="%E2%96%B72%E3%80%81lastIndexOf(Object%20o)%E6%96%B9%E6%B3%95%EF%BC%9A" style="background-color:transparent;"><span style="color:#1a439c;"><strong>▷2、lastIndexOf(Object o)方法：</strong></span></h5> 
<p><span style="color:#0d0016;"><strong>           返回最后一个o出现的位置下标。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>我们来看看它们的使用案例：</strong></span><img alt="" height="1000" src="https://images2.imgbox.com/48/91/aZYyBDjZ_o.png" width="1200"></p> 
<hr> 
<h5 id="%E2%96%B73%E3%80%81subList(int%20fromIndex%2C%20int%20toIndex)%E6%96%B9%E6%B3%95%EF%BC%9A"><span style="color:#1a439c;"><strong>▷3、subList(int fromIndex, int toIndex)方法：</strong></span></h5> 
<p><span style="color:#0d0016;"><strong>         </strong></span> <span style="color:#956fe7;"><strong>返回fromIndex下标到 toIndex下标的链表。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>我们来看看使用例子：</strong></span><img alt="" height="1039" src="https://images2.imgbox.com/54/63/mJTNEpxI_o.png" width="1200"></p> 
<hr> 
<h4 id="%E2%99%A0%EF%BC%883%EF%BC%89%E3%80%81LinkedList%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A%C2%A0" style="background-color:transparent;"><span style="color:#956fe7;"><strong>♠</strong>（3）、LinkedList的遍历： </span></h4> 
<h5 id="%C2%A0%E2%96%B71%E3%80%81%E4%BD%BF%E7%94%A8sout%E7%9B%B4%E6%8E%A5%E9%81%8D%E5%8E%86%EF%BC%9A"><span style="color:#956fe7;"> </span><span style="color:#1a439c;"><strong>▷</strong></span><span style="color:#956fe7;">1、使用sout直接遍历：</span></h5> 
<p><img alt="" height="838" src="https://images2.imgbox.com/3a/66/OexezVRJ_o.png" width="1200"></p> 
<hr> 
<h5 id="%C2%A0%C2%A0%E2%96%B7%C2%A02%E3%80%81%E4%BD%BF%E7%94%A8for-each%E7%9B%B4%E6%8E%A5%E9%81%8D%E5%8E%86%EF%BC%9A"> <span style="color:#956fe7;"> </span><span style="color:#1a439c;"><strong>▷ </strong></span><span style="color:#956fe7;"><strong>2</strong>、使用for-each直接遍历：</span></h5> 
<p><img alt="" height="1192" src="https://images2.imgbox.com/2d/ce/RGCdrjjR_o.png" width="1200"></p> 
<hr> 
<p> <span style="color:#956fe7;"> </span><span style="color:#1a439c;"><strong>▷ </strong></span><span style="color:#956fe7;"><strong>3</strong>、使用迭代器正序遍历：</span></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/00/d8/jMg6kKhY_o.png" width="1200"></p> 
<hr> 
<h5 id="%C2%A0%C2%A0%E2%96%B7%204%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"> <span style="color:#956fe7;"> </span><span style="color:#1a439c;"><strong>▷ 4</strong></span><span style="color:#956fe7;">、使用迭代器逆序遍历：</span></h5> 
<p><img alt="" height="1146" src="https://images2.imgbox.com/9c/5c/FvkZZiLW_o.png" width="1200"></p> 
<hr> 
<h2 id="%E2%98%9B%C2%A0%E5%9B%9B%E3%80%81ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A" style="background-color:transparent;"><img alt="" height="82" src="https://images2.imgbox.com/0e/70/I7dmQd4c_o.gif" width="82"> <em>四、ArrayList和LinkedList的区别：</em></h2> 
<p><span style="color:#0d0016;"><strong>          这个呢我们直接看表格，比较直观，我们来看：</strong></span><img alt="" height="722" src="https://images2.imgbox.com/53/33/kK4h2anl_o.png" width="1200"></p> 
<hr> 
<h2 id="%E2%98%9B%C2%A0%E6%80%BB%E7%BB%93%EF%BC%9A%C2%A0" style="background-color:transparent;"><img alt="" height="63" src="https://images2.imgbox.com/93/3b/oxDBGihX_o.jpg" width="63"><em> 总结： </em></h2> 
<p>       <span style="color:#0d0016;"><strong>OK了，关于我们的链表的相关知识就到这里就结束了，我们下次来看看有关于链表方面的练习题，让我们期待下次的见面吧，拜拜喽~~~</strong></span><img alt="" height="627" src="https://images2.imgbox.com/72/29/F4f7oNPG_o.png" width="556"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3eda51d07cc0df9bfb1e9b24dabb3f33/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring AOP（下）原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/22207c17952294f7f3f01fd533f3ada3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">哈希 详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>