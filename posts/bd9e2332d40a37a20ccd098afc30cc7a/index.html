<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——单链表OJ题（下） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bd9e2332d40a37a20ccd098afc30cc7a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——单链表OJ题（下）">
  <meta property="og:description" content="目录
一、链表的回文结构
思路一：数组法
（1）注意
（2）解题
思路二：反转链表法
（1） 注意
（2）解题
二、相交链表
（1）思路：快慢指针
（2）注意
（3）解题
三、环形链表1
（1）思路：快慢指针
（2）解释
（3）注意
（4）解题
①快指针走两步
② 快指针走三步
四、环形链表2
（1）思路：快慢指针
（2）解释
（3）注意
（4）解题
五、随机链表的复制
（1）思路
（2）解题
六、写在最后 一、链表的回文结构 思路一：数组法 将链表中结点的数据存储在数组中，创建两个指针分别从左右两边遍历并比较，如果左右对称则说明是回文结构。
（1）注意 ①为什么要创建数组存储数据？因为链表的结点不是连续的，不能进行逆向访问；
②从左右两端进行遍历时，需满足left&lt;right的条件；
③该方法只适用于链表长度小于等于900的条件下，因为数组的长度最大为900。
（2）解题 typedef struct ListNode ListNode; bool chkPalindrome(ListNode* A) { //创建数组存储数据 int arr[900] = {0}; //数据的个数为i int i = 0; ListNode* pcur = A; //遍历链表，将数据存储在数组中 while(pcur) { arr[i&#43;&#43;] = pcur-&gt;val; pcur = pcur-&gt;next; } int left = 0; int right = i - 1; while(left &lt; right) { //若有不相等，说明不是回文结构 if(arr[left] !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T19:28:17+08:00">
    <meta property="article:modified_time" content="2024-07-25T19:28:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——单链表OJ题（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84" rel="nofollow">一、链表的回文结构</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E6%95%B0%E7%BB%84%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E6%95%B0%E7%BB%84%E6%B3%95" rel="nofollow">思路一：数组法</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%B3%A8%E6%84%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E6%B3%A8%E6%84%8F" rel="nofollow">（1）注意</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%A7%A3%E9%A2%98-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E8%A7%A3%E9%A2%98" rel="nofollow">（2）解题</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%B3%95" rel="nofollow">思路二：反转链表法</a></p> 
<p id="%EF%BC%881%EF%BC%89%20%E6%B3%A8%E6%84%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%20%E6%B3%A8%E6%84%8F" rel="nofollow">（1） 注意</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%A7%A3%E9%A2%98-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E8%A7%A3%E9%A2%98" rel="nofollow">（2）解题</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8" rel="nofollow">二、相交链表</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88" rel="nofollow">（1）思路：快慢指针</a></p> 
<p id="%EF%BC%882%EF%BC%89%E6%B3%A8%E6%84%8F-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E6%B3%A8%E6%84%8F" rel="nofollow">（2）注意</a></p> 
<p id="%EF%BC%883%EF%BC%89%E8%A7%A3%E9%A2%98-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E8%A7%A3%E9%A2%98" rel="nofollow">（3）解题</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81" rel="nofollow"> 三、环形链表1</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88" rel="nofollow">（1）思路：快慢指针</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E8%A7%A3%E9%87%8A" rel="nofollow">（2）解释</a></p> 
<p id="%EF%BC%883%EF%BC%89%E6%B3%A8%E6%84%8F-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E6%B3%A8%E6%84%8F" rel="nofollow">（3）注意</a></p> 
<p id="%EF%BC%884%EF%BC%89%E8%A7%A3%E9%A2%98-toc" style="margin-left:40px;"><a href="#%EF%BC%884%EF%BC%89%E8%A7%A3%E9%A2%98" rel="nofollow">（4）解题</a></p> 
<p id="%E2%91%A0%E5%BF%AB%E6%8C%87%E9%92%88%E8%B5%B0%E4%B8%A4%E6%AD%A5-toc" style="margin-left:120px;"><a href="#%E2%91%A0%E5%BF%AB%E6%8C%87%E9%92%88%E8%B5%B0%E4%B8%A4%E6%AD%A5" rel="nofollow">①快指针走两步</a></p> 
<p id="%E2%91%A1%C2%A0%E5%BF%AB%E6%8C%87%E9%92%88%E8%B5%B0%E4%B8%89%E6%AD%A5-toc" style="margin-left:120px;"><a href="#%E2%91%A1%C2%A0%E5%BF%AB%E6%8C%87%E9%92%88%E8%B5%B0%E4%B8%89%E6%AD%A5" rel="nofollow">② 快指针走三步</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82" rel="nofollow">四、环形链表2</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88" rel="nofollow">（1）思路：快慢指针</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%A7%A3%E9%87%8A-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E8%A7%A3%E9%87%8A" rel="nofollow">（2）解释</a></p> 
<p id="%EF%BC%883%EF%BC%89%E6%B3%A8%E6%84%8F-toc" style="margin-left:40px;"><a href="#%EF%BC%883%EF%BC%89%E6%B3%A8%E6%84%8F" rel="nofollow">（3）注意</a></p> 
<p id="%EF%BC%884%EF%BC%89%E8%A7%A3%E9%A2%98-toc" style="margin-left:40px;"><a href="#%EF%BC%884%EF%BC%89%E8%A7%A3%E9%A2%98" rel="nofollow">（4）解题</a></p> 
<p id="%E4%BA%94%E3%80%81%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6" rel="nofollow">五、随机链表的复制</a></p> 
<p id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF" rel="nofollow">（1）思路</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%A7%A3%E9%A2%98-toc" style="margin-left:40px;"><a href="#%EF%BC%882%EF%BC%89%E8%A7%A3%E9%A2%98" rel="nofollow">（2）解题</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E%C2%A0" rel="nofollow">六、写在最后 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84" style="background-color:transparent;">一、链表的回文结构</h2> 
<p><img alt="" height="251" src="https://images2.imgbox.com/1b/09/7XZZzadL_o.png" width="958"></p> 
<h3 id="%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E6%95%B0%E7%BB%84%E6%B3%95">思路一：数组法</h3> 
<p>将链表中结点的数据存储在数组中，创建两个指针分别从左右两边遍历并比较，如果左右对称则说明是回文结构。</p> 
<h4 id="%EF%BC%881%EF%BC%89%E6%B3%A8%E6%84%8F">（1）注意</h4> 
<p>①为什么要创建数组存储数据？因为链表的结点不是连续的，不能进行逆向访问；</p> 
<p>②从左右两端进行遍历时，需满足left&lt;right的条件；</p> 
<p>③该方法只适用于链表长度小于等于900的条件下，因为数组的长度最大为900。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E8%A7%A3%E9%A2%98">（2）解题</h4> 
<pre><code class="language-cpp">typedef struct ListNode ListNode;
bool chkPalindrome(ListNode* A) 
    {
        //创建数组存储数据
        int arr[900] = {0};
        //数据的个数为i
        int i = 0;
        ListNode* pcur = A;
        //遍历链表，将数据存储在数组中
        while(pcur)
        {
            arr[i++] = pcur-&gt;val;
            pcur = pcur-&gt;next;
        }
        int left = 0;
        int right = i - 1;
        while(left &lt; right)
        {
            //若有不相等，说明不是回文结构
            if(arr[left] != arr[right])
            {
                return false;
            }
            left++;
            right--;
        }
        //跳出循环，说明left和right指向的数据一直相等，即回文结构
        return true;
        
    }</code></pre> 
<h3 id="%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E6%B3%95">思路二：反转链表法</h3> 
<p>使用快慢指针法找到原链表的中间结点，将中间结点之后的链表进行反转，最后将原链表的前半段与新链表存储的数据进行比较。</p> 
<h4 id="%EF%BC%881%EF%BC%89%20%E6%B3%A8%E6%84%8F">（1） 注意</h4> 
<p>①寻找中间结点和反转链表在上节已练习，可将它们封装成两个函数；</p> 
<p>②由于原链表的长度大于新链表（反转后的），因此循环结束的判定条件是p2==NULL。</p> 
<h4>（2）解题</h4> 
<pre><code class="language-cpp">class PalindromeList {
    //寻找中间结点的函数
    ListNode* midNode(ListNode* head)
    {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast &amp;&amp; fast-&gt;next)
        {
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
        }
        return slow;
    }
    //将链表进行反转的函数
    ListNode* reverse(ListNode* head)
    {
        ListNode* n1, * n2 , *n3;
        n1 = NULL;
        n2 = head;
        n3 = head-&gt;next;
        while(n2)
        {
            n2-&gt;next = n1;
            n1 = n2;
            n2 = n3;
            if(n3)
            {
                n3 = n3-&gt;next;
            }
        }
        return n1;
    }
public:
    bool chkPalindrome(ListNode* A) 
    {
        //原链表的中间结点
        ListNode* mid = midNode(A);
        //将中间结点之后的链表进行反转
        ListNode* p2 = reverse(mid);
        ListNode* p1 = A;
        //遍历两个链表的值，比较是否相等
        while(p2)
        {
            //存在不相等的，说明不是回文结构
            if(p1-&gt;val != p2-&gt;val)
            {
                return false;
            }
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        }
        //跳出循环，说明left和right指向的数据都相等，即为回文结构
        return true;
    }
};</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8" style="background-color:transparent;">二、相交链表</h2> 
<p><img alt="" height="404" src="https://images2.imgbox.com/97/de/NxryDXBA_o.png" width="1184"></p> 
<h3 id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88">（1）思路：快慢指针</h3> 
<p>首先找到两个链表长度的差值k，创建两个指针指向头结点，快指针先走k步，接着快慢指针一起走，若快慢指针指向同一个结点，则说明该结点为相交结点。</p> 
<h3 id="%EF%BC%882%EF%BC%89%E6%B3%A8%E6%84%8F">（2）注意</h3> 
<p>①计算差值时无法确定两个长度谁大谁小，可使用abs()绝对值函数；</p> 
<p>②通过比较两个长度的大小来确定快指针指向哪个链表的头结点；</p> 
<p>③判断快慢指针指向的结点是否相同，而非结点指向的数据！！</p> 
<h3 id="%EF%BC%883%EF%BC%89%E8%A7%A3%E9%A2%98">（3）解题</h3> 
<pre><code class="language-cpp">typedef struct ListNode ListNode;
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) 
{
    //计算两个链表的长度
    int len1 = 0;
    int len2 = 0;
    ListNode* pcur = headA;
    while(pcur)
    {
        pcur = pcur-&gt;next;
        len1++;
    }
    pcur = headB;
    while(pcur)
    {
        pcur = pcur-&gt;next;
        len2++;
    }
    //两个链表长度的差值k
    int k = abs(len1 - len2);
    //快指针指向长链表的头结点
    ListNode* fast = headA;
    ListNode* slow = headB;
    if(len1 &lt; len2)
    {
        fast = headB;
        slow = headA;
    }
    //快指针先走k步
    while(k--)
    {
        fast = fast-&gt;next;
    }
    //比较两个指针指向的结点是否相同
    while(fast &amp;&amp; slow)
    {
        if(fast == slow)
        {
            return fast;
        }
        fast = fast-&gt;next;
        slow = slow-&gt;next;
    }
    return NULL;
}</code></pre> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A81" style="background-color:transparent;"> 三、环形链表1</h2> 
<p><img alt="" height="718" src="https://images2.imgbox.com/35/a4/bCB3fjRP_o.png" width="1188"></p> 
<h3 style="background-color:transparent;">（1）思路：快慢指针</h3> 
<p>创建快慢指针并指向头结点，快指针一次经过两个结点，慢指针一次经过一个结点，若最终快指针与慢指针相遇，则说明该链表是环形链表。</p> 
<h3 id="%EF%BC%882%EF%BC%89%E8%A7%A3%E9%87%8A" style="background-color:transparent;">（2）解释</h3> 
<p>①为什么在起点相同的情况下，快指针走两步，慢指针走一步，两者可以相遇，会不会遇不上？</p> 
<p>假设此时fast进入环，slow走完入环前的距离准备入环，此时它们之间的距离为N。在接下来的追逐中，它们每追击（变换位置）一次，两者之间的距离缩小一步，直至相遇。（参考下图理解）</p> 
<p> <img alt="" height="1094" src="https://images2.imgbox.com/df/35/EYh5usT2_o.jpg" width="1200"></p> 
<p>②如果慢指针一次走一步，快指针一次走3、4、5...n步，快慢指针还能再相遇吗？</p> 
<p>可以！以快指针一次走3步为例：</p> 
<p><img alt="" height="1101" src="https://images2.imgbox.com/a2/68/DBqy8Q65_o.jpg" width="1200"></p> 
<p>slow入环后，slow和fast在环内进行追逐，假设两者之间的距离为N，那么在之后的过程中，每追逐一次两者之间的距离就缩小两步。</p> 
<p>若N为偶数，最终距离可缩小为0，即相遇；若N为奇数，假设环的长度为C，会出现套圈情况（即slow走在fast前面），此时两者之间的长度为C-1。</p> 
<p>此时需要讨论C-1是奇数还是偶数，若C-1为偶数，则可以相遇。若C-1为奇数，两者还会错过，继续套圈，那么fast和slow还会再相遇吗？</p> 
<p>假设slow走完入环前的距离L，刚准备入环；fast在环里走了x圈，且此时fast和slow之间的距离为N，那么两者走过的长度分别为：slow : L     fast : L + xC + (C - N)。又因为fast的速度是slow的3倍，因此3L =  L + xC + (C - N)，化简得：2L = (x + 1)C - N</p> 
<p>上述条件中：N为奇数，C为偶数。因为：偶数= 偶数-偶数，偶数=奇数-奇数。那么（x+1）C为奇数时，会相遇。因此，如果慢指针一次走一步，快指针一次走3步，快慢指针还能再相遇。</p> 
<p>同理可得其它步数的情况下也可相遇。</p> 
<h3 id="%EF%BC%883%EF%BC%89%E6%B3%A8%E6%84%8F">（3）注意</h3> 
<p>①循环结束的判定条件是fast &amp;&amp; fast-&gt;next：若fast为空则说明不是环形链表；</p> 
<p>②不能写成fast-&gt;next &amp;&amp; fast，要先判断fast，因为如果fast为空，就不能取next；</p> 
<p>③虽然证明了快指针不论走多少步都可以满足在带环链表中相遇，但是在编写代码的时候会有额外的步骤引入，涉及到快慢指针的算法题中通常习惯使用慢指针走一步、快指针走两步的方式。</p> 
<h3 id="%EF%BC%884%EF%BC%89%E8%A7%A3%E9%A2%98">（4）解题</h3> 
<h5 id="%E2%91%A0%E5%BF%AB%E6%8C%87%E9%92%88%E8%B5%B0%E4%B8%A4%E6%AD%A5">①快指针走两步</h5> 
<pre><code class="language-cpp">typedef struct ListNode ListNode;
bool hasCycle(struct ListNode *head) 
{
    ListNode* fast = head;
    ListNode* slow = head;
    while(fast &amp;&amp; fast-&gt;next)
    {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
        if(fast == slow)
        {
            return true;
        }
    }
    return false;
}</code></pre> 
<h5 id="%E2%91%A1%C2%A0%E5%BF%AB%E6%8C%87%E9%92%88%E8%B5%B0%E4%B8%89%E6%AD%A5">② 快指针走三步</h5> 
<pre><code class="language-cpp">typedef struct ListNode ListNode;
bool hasCycle(struct ListNode *head) 
{
    ListNode* fast = head;
    ListNode* slow = head;
    while(fast &amp;&amp; fast-&gt;next)
    {
        slow = slow-&gt;next;
        //快指针一次走三步
        int n = 3;
        while(n--)
        {
            if(fast-&gt;next)
            {
                fast = fast-&gt;next;
            }
            else 
            {
                return false;
            }
        }
        if(fast == slow)
        {
            return true;
        }
    }
    return false;
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82">四、环形链表2</h2> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="background-color:transparent;"><img alt="" height="721" src="https://images2.imgbox.com/31/f7/iXdNIQyd_o.png" width="1200"></h2> 
<h3 style="background-color:transparent;">（1）思路：快慢指针</h3> 
<p>创建两个指针，一个从链表的头结点开始遍历链表，另一个从快慢指针的（判断是否为环形链表的）相遇点开始绕环运行，两个指针都是一次走一步，最终会在入口点的位置相遇。</p> 
<h3 style="background-color:transparent;">（2）解释</h3> 
<p>①为什么相遇点和头结点到入环结点的距离是相等的？</p> 
<p>假设环的长度为R，入环之前的距离为L，入环节点到相遇点的距离为X，那么相遇点到入环结点之间的距离为R-X。</p> 
<p><img alt="" height="1114" src="https://images2.imgbox.com/6f/ac/BpbQOMQY_o.jpg" width="1200"></p> 
<p>在判环时（此时在相遇点），快慢指针走的路程为：slow : L+X     fast :L+nR+X（其中n≥1）。</p> 
<p>由于判环时，快指针一次走两步，慢指针一次走一步，则快指针的路程时慢指针的两倍。且慢指针入环之后，快指针一定会在一圈之内追上慢指针（因为慢指针入环之后，两者之间的距离最大为环的长度，而每追击一次，两者之间的距离缩短一步，因此在一圈之内，快指针一定能追上慢指针）。</p> 
<p>那么：2*（L+X）= L+nR+X，化简为：L = nR - X，即L = (n -1)R+(R-X)。在极端情况下：假设n=1，则：L=R-X，即头结点到和相遇点到入环结点之间的距离相等。</p> 
<h3>（3）注意</h3> 
<p>①fast &amp;&amp; fast-&gt;next位置的注意事项同上。</p> 
<h3>（4）解题</h3> 
<pre><code class="language-cpp">typedef struct ListNode ListNode;
struct ListNode *detectCycle(struct ListNode *head) 
{
    ListNode *fast = head;
    ListNode *slow = head;
    while(fast &amp;&amp; fast-&gt;next)
    {
        //fast一次走两步，slow一次走一步
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
        if(fast == slow)
        {
            ListNode* pcur = head;
            //判断两者何时相遇
            while(pcur != slow)
            {
            pcur = pcur-&gt;next;
            slow = slow-&gt;next;
            }
            return slow;
        }
    }
    //链表不带环
    return NULL;
}</code></pre> 
<h2 id="%E4%BA%94%E3%80%81%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">五、随机链表的复制</h2> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0"><img alt="" height="953" src="https://images2.imgbox.com/cb/6a/BcYwW49k_o.png" width="1200"> </h2> 
<h3 id="%EF%BC%881%EF%BC%89%E6%80%9D%E8%B7%AF">（1）思路</h3> 
<p>在原链表的基础上继续复制链表，置random指针（copy-&gt;random = pcur-&gt;random-&gt;next），最后将复制链表和原链表断开，得到复制链表。</p> 
<h3>（2）解题</h3> 
<pre><code class="language-cpp">typedef struct Node Node;
Node* buyNode(int x) {
    Node* newnode = (Node*)malloc(sizeof(Node));
    newnode-&gt;val = x;
    newnode-&gt;next = newnode-&gt;random = NULL;
    return newnode;
}
void AddNode(Node* phead) {
    Node* pcur = phead;
    while (pcur) 
    {
        // 存储pcur的下一个结点
        Node* Next = pcur-&gt;next;
        // 创建新结点，尾插到pcur
        Node* newnode = buyNode(pcur-&gt;val);
        pcur-&gt;next = newnode;
        newnode-&gt;next = Next;
        pcur = Next;
    }
}
struct Node* copyRandomList(struct Node* head) {
    if(head == NULL)
    {
        return NULL;
    }
    // 1.在原链表上复制结点
    AddNode(head);
    // 2.置random
    Node* pcur = head;
    while (pcur) 
    {
        Node* copy = pcur-&gt;next;
        if (pcur-&gt;random != NULL) 
        {
            copy-&gt;random = pcur-&gt;random-&gt;next;
        }
        pcur = copy-&gt;next;
    }
    // 3.断开链表
    pcur = head;
    Node *newHead, *newTail;
    newHead = newTail = pcur-&gt;next;
    while (pcur-&gt;next-&gt;next) 
    {
        pcur = pcur-&gt;next-&gt;next;
        newTail-&gt;next = pcur-&gt;next;
        newTail = newTail-&gt;next;
    }
    return newHead;
}</code></pre> 
<h2 id="%E5%85%AD%E3%80%81%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E%C2%A0">六、写在最后 </h2> 
<p> 链表既然包括单链表，就还有其他种类啦~</p> 
<p>敬请期待“双向链表”~</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/811dc30571ad5fb5e0afc9bf4d385f50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第三周DAY04---git</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/151fca34f5a8d68d789885a87f5dedd3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java多线线程-----等待唤醒机制(wait notify)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>