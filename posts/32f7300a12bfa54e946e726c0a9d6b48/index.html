<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>损失函数——交叉熵损失（Cross-entropy loss） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/32f7300a12bfa54e946e726c0a9d6b48/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="损失函数——交叉熵损失（Cross-entropy loss）">
  <meta property="og:description" content="交叉熵损失（Cross-entropy loss）是深度学习中常用的一种损失函数，通常用于分类问题。它衡量了模型预测结果与实际结果之间的差距，是优化模型参数的关键指标之一。以下是交叉熵损失的详细介绍。
假设我们有一个分类问题，需要将输入数据x分为C个不同的类别。对于每个输入数据x，我们定义一个C维的向量y^​，其中y^​i​表示x属于第i个类别的概率。我们的目标是使得y^​尽可能接近真实的标签y的概率分布。
假设真实标签y是一个C维的向量，其中只有一个元素为1，其余元素为0，表示x属于第k个类别。那么，我们可以使用交叉熵损失来衡量模型预测结果和真实标签之间的差距。交叉熵损失的公式如下： 其中，xi​表示真实标签的第i个元素，y​i​表示模型预测x属于第i个类别的概率。
交叉熵损失的本质是衡量两个概率分布之间的距离。其中一个概率分布是真实标签y的分布，另一个是模型预测的概率分布y^​。对于每个类别i，yi​表示真实标签x属于第i个类别的概率，y^​i​表示模型预测x属于第i个类别的概率。当两个概率分布越接近时，交叉熵损失越小，表示模型预测结果越准确。
交叉熵损失是一种凸函数，通常使用梯度下降等优化算法来最小化它。在深度学习中，交叉熵损失是常见的分类损失函数之一，广泛应用于图像分类、语音识别等任务中。
在PyTorch中，交叉熵损失可以使用torch.nn.CrossEntropyLoss实现。该函数将输入数据视为模型输出的概率分布，将目标标签视为类别索引，并计算这些概率与实际标签之间的交叉熵损失。
以下是一个示例代码片段，说明如何使用torch.nn.CrossEntropyLoss计算交叉熵损失：
import torch # 创建模型输出和目标标签 output = torch.randn(10, 5) # 10个样本，5个类别 target = torch.tensor([1, 0, 4, 2, 3, 1, 0, 4, 2, 3]) # 目标类别索引 # 创建交叉熵损失函数 criterion = torch.nn.CrossEntropyLoss() # 计算损失 loss = criterion(output, target) print(loss) 在训练中，你可以使用torch.nn.CrossEntropyLoss作为损失函数来优化模型。假设你已经有一个PyTorch模型和训练数据集，以下是一个简单的训练循环示例，它使用交叉熵损失函数来训练模型：
import torch import torch.nn as nn import torch.optim as optim # 定义模型 class MyModel(nn.Module): def __init__(self): super(MyModel, self).__init__() self.fc1 = nn.Linear(10, 5) self.fc2 = nn.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-16T12:41:44+08:00">
    <meta property="article:modified_time" content="2023-03-16T12:41:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">损失函数——交叉熵损失（Cross-entropy loss）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>交叉熵损失（Cross-entropy loss）</strong>是深度学习中常用的一种损失函数，通常用于分类问题。它衡量了模型预测结果与实际结果之间的差距，是优化模型参数的关键指标之一。以下是交叉熵损失的详细介绍。</p> 
<p>假设我们有一个分类问题，需要将输入数据x分为C个不同的类别。对于每个输入数据x，我们定义一个C维的向量y^​，其中y^​i​表示x属于第i个类别的概率。我们的目标是使得y^​尽可能接近真实的标签y的概率分布。</p> 
<p>假设真实标签y是一个C维的向量，其中只有一个元素为1，其余元素为0，表示x属于第k个类别。那么，我们可以使用交叉熵损失来衡量模型预测结果和真实标签之间的差距。交叉熵损失的公式如下： </p> 
<p>                                                         <img alt="L\left ( x,y \right ) = -\sum _{i=1}^{C}x_{_{i}} log y_{i}" class="mathcode" src="https://images2.imgbox.com/3d/56/kz0bAnCj_o.png"></p> 
<p>其中，xi​表示真实标签的第i个元素，y​i​表示模型预测x属于第i个类别的概率。</p> 
<p>交叉熵损失的本质是衡量两个概率分布之间的距离。其中一个概率分布是真实标签y的分布，另一个是模型预测的概率分布y^​。对于每个类别i，yi​表示真实标签x属于第i个类别的概率，y^​i​表示模型预测x属于第i个类别的概率。当两个概率分布越接近时，交叉熵损失越小，表示模型预测结果越准确。</p> 
<p>交叉熵损失是一种凸函数，通常使用梯度下降等优化算法来最小化它。在深度学习中，交叉熵损失是常见的分类损失函数之一，广泛应用于图像分类、语音识别等任务中。</p> 
<p>在PyTorch中，交叉熵损失可以使用<code>torch.nn.CrossEntropyLoss</code>实现。该函数将输入数据视为模型输出的概率分布，将目标标签视为类别索引，并计算这些概率与实际标签之间的交叉熵损失。</p> 
<p>以下是一个示例代码片段，说明如何使用<code>torch.nn.CrossEntropyLoss</code>计算交叉熵损失：</p> 
<pre><code class="language-python">import torch

# 创建模型输出和目标标签
output = torch.randn(10, 5)  # 10个样本，5个类别
target = torch.tensor([1, 0, 4, 2, 3, 1, 0, 4, 2, 3])  # 目标类别索引

# 创建交叉熵损失函数
criterion = torch.nn.CrossEntropyLoss()

# 计算损失
loss = criterion(output, target)

print(loss)</code></pre> 
<p>在训练中，你可以使用<code>torch.nn.CrossEntropyLoss</code>作为损失函数来优化模型。假设你已经有一个PyTorch模型和训练数据集，以下是一个简单的训练循环示例，它使用交叉熵损失函数来训练模型：</p> 
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as optim

# 定义模型
class MyModel(nn.Module):
    def __init__(self):
        super(MyModel, self).__init__()
        self.fc1 = nn.Linear(10, 5)
        self.fc2 = nn.Linear(5, 2)
    
    def forward(self, x):
        x = self.fc1(x)
        x = nn.functional.relu(x)
        x = self.fc2(x)
        return x

model = MyModel()

# 定义损失函数和优化器
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.1)

# 训练循环
for epoch in range(num_epochs):
    for batch_idx, (data, target) in enumerate(train_loader):
        optimizer.zero_grad()
        output = model(data)
        loss = criterion(output, target)
        loss.backward()
        optimizer.step()
        
        if batch_idx % log_interval == 0:
            print('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(
                epoch, batch_idx * len(data), len(train_loader.dataset),
                100. * batch_idx / len(train_loader), loss.item()))</code></pre> 
<p>在这个例子中，<code>MyModel</code>是一个简单的两层全连接神经网络。训练循环通过从数据集中加载数据批次，使用<code>optimizer.zero_grad()</code>清空梯度，计算模型输出和损失，使用<code>loss.backward()</code>计算梯度并使用<code>optimizer.step()</code>更新模型参数。每个epoch结束时，模型将在测试集上进行评估，以检查其在新数据上的泛化能力。</p> 
<p>在这个训练循环中，我们使用<code>nn.CrossEntropyLoss()</code>作为损失函数，并传递模型输出和目标标签作为参数。<code>loss.backward()</code>计算梯度并将梯度传播回模型中的参数，从而使优化器能够更新这些参数以最小化损失。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12300118f2546f8086cfc3a1c4acfb27/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Stable Diffusion 原理介绍与源码分析（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a4bed7a8774817b6be22daa994a90f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手把手教你完成一个Python与OpenCV人脸识别项目（对图片、视频、摄像头人脸的检测）超详细保姆级记录！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>