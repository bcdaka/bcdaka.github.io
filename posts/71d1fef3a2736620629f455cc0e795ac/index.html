<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python——Django 框架 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/71d1fef3a2736620629f455cc0e795ac/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="python——Django 框架">
  <meta property="og:description" content="Django 框架 1、 简介 Django 是用python语言写的开源web开发框架，并遵循MVC设计。
Django的主要目的是简便、快速的开发数据库驱动的网站。它强调代码复用，多个组件可以很方便的以&#34;插件&#34;形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(DoNotRepeatYourself)原则。
2、特点 1） 重量级框架 对比Flask框架，Django原生提供了众多的功能组件，让开发更简便快速。
提供项目工程管理的自动化脚本工具
数据库ORM支持（对象关系映射，英语：Object Relational Mapping）
模板
表单
Admin管理站点
文件管理
认证权限
session机制
缓存 2）MVT模式 有一种程序设计模式叫MVC，其核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容。
MVC的全拼为Model-View-Controller，最早由TrygveReenskaug在1978年提出，是施乐帕罗奥多研究中心(Xerox PARC)在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。随着标准输入输出设备的出现，开发人员只需要将精力集中在业务逻辑的分析与实现上。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。现在虽然不再使用原来的分工方式，但是这种分工的思想被沿用下来，广泛应用于软件工程中，是一种典型并且应用广泛的软件架构模式。后来，MVC的思想被应用在了Ｗeb开发方面，被称为Ｗeb MVC框架。
Django的MVT
3、搭建虚拟环境 Django框架（入门超细笔记 创建项目步骤 ）_django创建项目-CSDN博客
3.1、在cmd中输入命令 pip install virtualenv
3.2、创建虚拟环境 3.2.1、新建文件夹 DjangoSpace 3.2.2、执行命令 virtualenv venv(虚拟环境目录名称可以任意) 3.2.3 、在虚拟环境中安装Django框架 进入到DjangoSpace\venv\Scripts目录下执行：pip install Django
安装成功后
4、创建Django项目 cmd中创建Django 4.1、首先将路径切换到要创建Django项目的路径下 4.2、执行创建工程的命令 django-admin startproject （项目名称）
例如：创建一个学生管理系统
django-admin startproject studentsystem
4.3、工程目录说明
查看创建的工程目录，结构如下： 与项目同名的目录，此处为studentsystem。
settings.py 是项目的整体配置文件。
urls.py是项目的URL配置文件。
wsgi.py是项目与WSGI兼容的Web服务器入口。
manage.py是项目管理文件，通过它管理项目
4.4、 运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-27T20:49:17+08:00">
    <meta property="article:modified_time" content="2023-11-27T20:49:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python——Django 框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><img alt="" height="129" src="https://images2.imgbox.com/2a/f2/xWFEuPrb_o.png" width="256"></h3> 
<h2>Django 框架</h2> 
<h3 id="1-简介">1、 简介</h3> 
<p>Django 是用python语言写的开源web开发框架，并遵循MVC设计。</p> 
<p>Django的<strong>主要目的是简便、快速的开发数据库驱动的网站。</strong>它强调代码复用，多个组件可以很方便的以"插件"形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(DoNotRepeatYourself)原则。</p> 
<h3 id="2-特点">2、特点</h3> 
<h3 id="1）-重量级框架">1） 重量级框架</h3> 
<p>对比Flask框架，Django原生提供了众多的功能组件，让开发更简便快速。</p> 
<blockquote> 
 <ul><li> <p>提供项目工程管理的自动化脚本工具</p> </li><li> <p>数据库ORM支持（对象关系映射，英语：Object Relational Mapping）</p> </li><li> <p>模板</p> </li><li> <p>表单</p> </li><li> <p>Admin管理站点</p> </li><li> <p>文件管理</p> </li><li> <p>认证权限</p> </li><li> <p>session机制</p> </li><li>缓存</li></ul> 
</blockquote> 
<h3 id="2）mvt模式">2）MVT模式</h3> 
<p>有一种程序设计模式叫<strong>MVC</strong>，其核心思想是<strong>分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容</strong>。</p> 
<blockquote> 
 <p>MVC的全拼为<strong>Model-View-Controller</strong>，最早由TrygveReenskaug在1978年提出，是施乐帕罗奥多研究中心(Xerox PARC)在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。随着标准输入输出设备的出现，开发人员只需要将精力集中在业务逻辑的分析与实现上。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。现在虽然不再使用原来的分工方式，但是这种分工的思想被沿用下来，广泛应用于软件工程中，是一种典型并且应用广泛的软件架构模式。后来，MVC的思想被应用在了Ｗeb开发方面，被称为Ｗeb MVC框架。</p> 
</blockquote> 
<p id="mvc模式说明"><strong>Django的MVT</strong><img alt="" height="584" src="https://images2.imgbox.com/bf/61/feVTCVE5_o.png" width="933"></p> 
<h3 id="为什么要搭建虚拟环境">3、搭建虚拟环境</h3> 
<p><a href="https://blog.csdn.net/qq_62870237/article/details/122989102?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169937032516800215054301%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169937032516800215054301&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-122989102-null-null.142%5Ev96%5Epc_search_result_base8&amp;utm_term=django%E6%A1%86%E6%9E%B6&amp;spm=1018.2226.3001.4187" title="Django框架（入门超细笔记 创建项目步骤 ）_django创建项目-CSDN博客">Django框架（入门超细笔记 创建项目步骤 ）_django创建项目-CSDN博客</a></p> 
<h4><strong>3.1、在cmd中输入命令</strong></h4> 
<blockquote> 
 <p>pip install virtualenv</p> 
</blockquote> 
<h4>3.2、创建虚拟环境</h4> 
<h5>3.2.1、新建文件夹 DjangoSpace</h5> 
<p><img alt="" height="420" src="https://images2.imgbox.com/32/4d/DHGOeX7F_o.png" width="739"></p> 
<h5>3.2.2、执行命令 virtualenv venv(虚拟环境目录名称可以任意)</h5> 
<p><img alt="" height="153" src="https://images2.imgbox.com/6b/8b/baQqPm94_o.png" width="735"></p> 
<p><img alt="" height="141" src="https://images2.imgbox.com/d1/ca/rqx2D06i_o.png" width="972"></p> 
<h5>3.2.3 、在虚拟环境中安装Django框架</h5> 
<p>进入到DjangoSpace\venv\Scripts目录下执行：<strong><code>pip install Django</code></strong></p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/c7/71/whXewoFq_o.png" width="707"></p> 
<p>安装成功后<img alt="" height="608" src="https://images2.imgbox.com/1b/45/iZEhzFFi_o.png" width="796"></p> 
<h3><strong>4、创建Django项目</strong></h3> 
<h3>cmd中创建Django</h3> 
<h3><a name="t6"></a>4.1、首先将路径切换到要创建Django项目的路径下</h3> 
<p><img alt="" height="184" src="https://images2.imgbox.com/89/cf/MhZ4Y7AZ_o.png" width="417"></p> 
<h3><strong>4.2、执行创建工程的命令</strong></h3> 
<blockquote> 
 <p><code><strong>django-admin startproject</strong> </code><code>（项目名称）</code></p> 
</blockquote> 
<blockquote> 
 <p>例如：创建一个学生管理系统</p> 
 <p><strong>django-admin startproject studentsystem</strong></p> 
</blockquote> 
<p> <img alt="" height="364" src="https://images2.imgbox.com/38/a5/Ka0C8BqE_o.png" width="677"></p> 
<h3>4.3、工程目录说明<br> 查看创建的工程目录，结构如下：</h3> 
<p><img alt="" height="205" src="https://images2.imgbox.com/d3/db/GwVlhcSQ_o.png" width="663"></p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/d4/96/t8qRqbnH_o.png" width="613"></p> 
<blockquote> 
 <p>与项目同名的目录，此处为studentsystem。</p> 
 <p>settings.py 是项目的整体配置文件。</p> 
 <p>urls.py是项目的URL配置文件。</p> 
 <p>wsgi.py是项目与WSGI兼容的Web服务器入口。</p> 
 <p>manage.py是项目管理文件，通过它管理项目</p> 
</blockquote> 
<h3>4.4、 运行开发服务器</h3> 
<p>在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。</p> 
<blockquote> 
 <p>先设置用户：</p> 
 <p><strong>python manage.py migrate </strong></p> 
 <p><img alt="" height="317" src="https://images2.imgbox.com/23/3e/qtRruuJ0_o.png" width="550"></p> 
 <p>运行服务器命令：</p> 
 <p>python manage.py runserver ip:端口<br> 或：<strong>python manage.py runserver</strong></p> 
 <p><img alt="" height="279" src="https://images2.imgbox.com/75/e8/yif5zAwx_o.png" width="814"><br> 注意：如果电脑有酷狗音乐一定要关掉，它有可能会占8000这个端口</p> 
</blockquote> 
<p><img alt="" height="560" src="https://images2.imgbox.com/65/7a/XAi0LXkC_o.png" width="1150"></p> 
<p><strong>django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启</strong></p> 
<p><strong>按ctrl+c停止服务器</strong></p> 
<p></p> 
<h3><strong>5、创建子应用</strong></h3> 
<p>在Web应用中，通常有一些业务功能模块是在不同的项目中都可以复用的，故在开发中通常将工程项目拆分为不同的子功能模块，各功能模块间可以保持相对的独立，在其他工程项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。</p> 
<p><strong>Django的视图编写是放在子应用中的。</strong></p> 
<h3><strong>(1)、创建APP</strong></h3> 
<p>在Django中，创建子应用模块的仍然可以通过命令来操作，即</p> 
<blockquote> 
 <p>python manage.py startapp 子应用名称</p> 
</blockquote> 
<p>manage.py为上述创建工程时自动生成的管理文件。</p> 
<p>例如，在刚才创建的studentsystem工程中，想要创建一个用户student子应用模块，可执行：</p> 
<blockquote> 
 <p><strong>python manage.py startapp student</strong></p> 
 <p><img alt="" height="450" src="https://images2.imgbox.com/e7/62/Sjrk4x5d_o.png" width="932"></p> 
</blockquote> 
<h3><strong>(2)、子应用目录说明</strong></h3> 
<p><strong>查看此时的工程目录，结构如下：</strong></p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/86/ba/6Bq1equL_o.png" width="487"></p> 
<blockquote> 
 <p>admin.py    文件跟网站的后台管理站点配置相关。</p> 
 <p>apps.py      文件用于配置当前子应用的相关信息。</p> 
 <p>migrations  目录用于存放数据库迁移历史文件。</p> 
 <p>models.py  文件用户保存数据库模型类。</p> 
 <p>tests.py      文件用于开发测试用例，编写单元测试。</p> 
 <p>views.py     文件用于编写Web应用视图函数。</p> 
</blockquote> 
<p><img alt="" height="257" src="https://images2.imgbox.com/61/10/fcWF4c9w_o.png" width="1039"></p> 
<p></p> 
<p>创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。</p> 
<p>在工程配置文件settings.py中，<strong>INSTALLED_APPS</strong>项保存了工程中已经注册安装的子应用，初始工程中的INSTALLED_APPS如下：</p> 
<p><img alt="" height="686" src="https://images2.imgbox.com/e7/35/fkwZsysh_o.png" width="964"></p> 
<p><strong>注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。</strong></p> 
<p>例如，将刚创建的book子应用添加到工程中，可在INSTALLED_APPS列表中添加<strong>'book.apps.BookConfig'</strong>。</p> 
<p><img alt="" height="325" src="https://images2.imgbox.com/11/ad/9tcG5ivx_o.png" width="559"></p> 
<p></p> 
<h2><strong>pycharm创建我们的Django项目</strong></h2> 
<p><img alt="" height="406" src="https://images2.imgbox.com/38/73/OkTuJb1W_o.png" width="663"></p> 
<p>用pycharm打开</p> 
<p><img alt="" height="810" src="https://images2.imgbox.com/55/ae/yik1sPUI_o.png" width="1200"></p> 
<p><strong>创建好后</strong></p> 
<p><img alt="" height="581" src="https://images2.imgbox.com/dd/b3/mzIO1ITI_o.png" width="967"> 创建项目之前首先要安装Django和pymysql</p> 
<blockquote> 
 <p>pip install Django</p> 
 <p>pip install pymysql</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="模型">模型</h2> 
<blockquote> 
 <ul><li>当前项目的开发, 都是数据驱动的。</li><li> <p>以下为书籍信息管理的数据关系：书籍和人物是 ：一对多关系</p> </li></ul> 
 <p><img alt="" height="151" src="https://images2.imgbox.com/28/b8/jcsaMdTX_o.png" width="407"></p> 
 <ul><li> <p>要先分析出项目中所需要的数据, 然后设计数据库表.</p> </li></ul> 
</blockquote> 
<p><strong>书籍信息表</strong></p> 
<table><thead><tr><th>字段名</th><th>字段类型</th><th>字段说明</th></tr></thead><tbody><tr><td>id</td><td>AutoField</td><td>主键</td></tr><tr><td>name</td><td>CharField</td><td>书名</td></tr></tbody></table> 
<table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>西游记</td></tr><tr><td>2</td><td>三国演义</td></tr></tbody></table> 
<p><strong>人物信息表</strong></p> 
<table><thead><tr><th>字段名</th><th>字段类型</th><th>字段说明</th></tr></thead><tbody><tr><td>id</td><td>AutoField</td><td>主键</td></tr><tr><td>name</td><td>CharField</td><td>人名</td></tr><tr><td>gender</td><td>BooleanField</td><td>性别</td></tr><tr><td>book</td><td>ForeignKey</td><td>外键</td></tr></tbody></table> 
<table><thead><tr><th>id</th><th>name</th><th>gender</th><th>book</th></tr></thead><tbody><tr><td>1</td><td>孙悟空</td><td>False</td><td>1</td></tr><tr><td>2</td><td>白骨精</td><td>True</td><td>1</td></tr><tr><td>3</td><td>曹操</td><td>False</td><td>2</td></tr><tr><td>4</td><td>貂蝉</td><td>True</td><td>2</td></tr></tbody></table> 
<p id="使用django进行数据库开发的提示-："><strong>使用Django进行数据库开发的提示 </strong></p> 
<blockquote> 
 <ul><li><code>MVT</code>设计模式中的<code>Model</code>, 专门负责和数据库交互.对应<code>(models.py)</code></li><li>由于<code>Model</code>中内嵌了<code>ORM框架</code>, 所以不需要直接面向数据库编程.</li><li>而是定义模型类, 通过<code>模型类和对象</code>完成数据库表的<code>增删改查</code>.</li><li><strong><code>ORM框架</code>就是把数据库表的行与相应的对象建立关联, 互相转换.使得数据库的操作面向对象.</strong><img alt="" height="388" src="https://images2.imgbox.com/52/9c/JMJOx0nH_o.png" width="665"></li></ul> 
</blockquote> 
<h3 id="使用django进行数据库开发的步骤-：">使用Django进行数据库开发的步骤 </h3> 
<blockquote> 
 <ol><li> <p>定义模型类</p> </li><li>模型迁移</li><li>操作数据库</li></ol> 
</blockquote> 
<h3 id="1-定义模型类">1. 定义模型类</h3> 
<ul><li>根据书籍表结构设计模型类: 
  <blockquote> 
   <ul><li>模型类：BookInfo</li><li>书籍名称字段：name</li></ul> 
  </blockquote> </li><li>根据人物表结构设计模型类： 
  <blockquote> 
   <ul><li>模型类：PeopleInfo</li><li>人物姓名字段：name</li><li>人物性别字段：gender</li><li>外键约束：book 
     <ul><li>外键要指定所属的模型类 <code>book = models.ForeignKey(BookInfo)</code></li></ul></li></ul> 
  </blockquote> </li><li>说明 : 
  <blockquote> 
   <ul><li>书籍-人物的关系为一对多. 一本书中可以有多个英雄.</li><li>不需要定义主键字段, 在生成表时会自动添加, 并且值为自增长.</li></ul> 
  </blockquote> </li><li> <p>根据数据库表的设计</p> 
  <blockquote> 
   <ul><li>在<code>models.py</code>中定义模型类,继承自<code>models.Model</code></li></ul> 
   <pre><code class="language-python">from django.db import models

# Create your models here.

'''
1.定义模型类
2.模型迁移
    2.1 先生成迁移文件(不会在数据库中生成表,只会创建一个数据表和模型的对应关系)
        python manage.py makemigrations
    2.2 再迁移(会在数据库中生成表)
3.操作数据库

在哪里定义模型
模型继承自谁就可以
ORM对应的关系
    表--&gt;类
    字段--&gt;属性
'''

# 准备书籍列表信息的模型类
class BookInfo(models.Model):
    # 创建字段，字段类型...
    # 1、主键  当前会自动生成
    # 2、属性
    name = models.CharField(max_length=10)

# 准备人物列表信息的模型类
class PeopleInfo(models.Model):
    # 姓名
    name = models.CharField(max_length=10)
    # 性别
    gender = models.BooleanField()
    # 外键约束：人物属于哪本书
    book = models.ForeignKey(BookInfo,on_delete=models.CASCADE)</code></pre> 
   <p></p> 
  </blockquote> </li></ul> 
<h3 id="2-模型迁移-（建表）">2. 模型迁移 （建表）</h3> 
<blockquote> 
 <ul><li> <p>迁移由两步完成 </p> </li></ul> 
 <p>                生成迁移文件：根据模型类生成创建表的语句</p> 
 <p><strong>                        python manage.py makemigrations</strong></p> 
 <p>                执行迁移：根据第一步生成的语句在数据库中创建表</p> 
 <ul><li> <p>迁移前</p> </li></ul> 
 <p><img alt="" height="389" src="https://images2.imgbox.com/13/b3/hR4aueCG_o.png" width="290"></p> 
 <ul><li> <p>迁移后</p> </li></ul> 
 <p><img alt="" height="403" src="https://images2.imgbox.com/01/3f/cMPcjqwx_o.png" width="719"></p> 
 <p><img alt="" height="731" src="https://images2.imgbox.com/e0/ed/sLgLMG7D_o.png" width="1200"></p> 
</blockquote> 
<blockquote> 
 <p><strong>提示：默认采用</strong><code>sqlite3</code><strong>数据库来存储数据</strong></p> 
</blockquote> 
<p>注意事项</p> 
<p><img alt="" height="544" src="https://images2.imgbox.com/1f/d7/IzTkcIkP_o.png" width="1088"> 解决办法</p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/90/2d/u6hmWtvX_o.png" width="833"></p> 
<p> 注意事项</p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/5d/c0/zo09aCbq_o.png" width="834"></p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/02/25/SlhuoAth_o.png" width="923"></p> 
<p> 看不到数据库表解决办法</p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/d1/82/BtdjgO6x_o.png" width="666"></p> 
<p><strong>运行</strong></p> 
<p><img alt="" height="952" src="https://images2.imgbox.com/2c/45/fv1u4q2R_o.png" width="1200"></p> 
<h2><img alt="" height="567" src="https://images2.imgbox.com/58/43/p8uSywS8_o.png" width="984"></h2> 
<p><strong>中文显示（改后刷新页面）</strong></p> 
<p><img alt="" height="694" src="https://images2.imgbox.com/0f/8a/nVKbdr4V_o.png" width="1044"></p> 
<h2><img alt="" height="572" src="https://images2.imgbox.com/5c/9e/AylfyciJ_o.png" width="961"></h2> 
<h4></h4> 
<h4></h4> 
<h2 id="站点管理">站点管理</h2> 
<ul><li><strong>站点</strong>: 分为<code>内容发布</code>和<code>公共访问</code>两部分</li><li><strong>内容发布</strong>的部分由网站的管理员负责查看、添加、修改、删除数据</li><li><code>Django</code>能够根据定义的模型类自动地生成管理模块</li><li>使用<code>Django</code>的管理模块, 需要按照如下步骤操作 : 
  <blockquote> 
   <ul><li>1.管理界面本地化</li><li>2.创建管理员</li><li>3.注册模型类</li><li>4.发布内容到数据库</li></ul> 
  </blockquote> </li></ul> 
<h3 id="1管理界面本地化">1.管理界面本地化</h3> 
<blockquote> 
 <ul><li>本地化是将显示的语言、时间等使用本地的习惯，这里的本地化就是进行中国化.</li><li>中国大陆地区使用<code>简体中文</code>, 时区使用<code>亚洲/上海时区</code>, 注意这里不使用北京时区.</li><li> <p>本地化前<img alt="" height="239" src="https://images2.imgbox.com/e5/3d/E6zkqw6D_o.png" width="699"></p> </li><li> <p>本地化后<img alt="" height="262" src="https://images2.imgbox.com/cf/dc/MVNiLYFf_o.png" width="692"></p> </li></ul> 
</blockquote> 
<h3 id="2创建管理员">2.创建管理员</h3> 
<ul><li> <p>创建管理员的命令 </p> </li></ul> 
<blockquote> 
 <p><strong>python manage.py createsuperuser</strong></p> 
</blockquote> 
<ul><li> <p>按提示输入用户名、邮箱、密码<img alt="" height="216" src="https://images2.imgbox.com/10/49/aApnQaRD_o.png" width="1005"></p> </li></ul> 
<p>注意：要用超级管理员  admin  Zw23456..！</p> 
<ul><li> <p>重置密码</p> </li></ul> 
<blockquote> 
 <p><strong>python manager.py changepassword 用户名</strong></p> 
</blockquote> 
<p><img alt="" height="628" src="https://images2.imgbox.com/9b/f4/eGgi1pEm_o.png" width="1128"></p> 
<ul><li> <p>登陆站点  <strong><code>http://127.0.0.1:8000/admin</code></strong></p> 
  <ul><li> <p>需要服务器是启动状态<img alt="" height="513" src="https://images2.imgbox.com/26/fa/MKPYdy5y_o.png" width="939"></p> </li></ul></li><li> <p>登陆站点成功</p> 
  <ul><li> <p>站点界面中没有书籍和人物管理入口,因为没有注册模型类<img alt="" height="326" src="https://images2.imgbox.com/81/13/Xi0pTFm5_o.png" width="1041"></p> </li></ul></li></ul> 
<h3 id="3注册模型类">3.注册模型类</h3> 
<ul><li> <p>在<code>应用</code>的<code>admin.py</code>文件中注册模型类</p> 
  <ul><li> <p>需要导入模型模块  <code>from book.models import BookInfo,PeopleInfo</code><img alt="" height="461" src="https://images2.imgbox.com/9a/6d/JX0sNaDp_o.png" width="877"></p> </li></ul></li><li> <p>注册模型后<img alt="" height="508" src="https://images2.imgbox.com/78/70/Gn1FtfQV_o.png" width="992"></p> </li></ul> 
<blockquote> 
 <p><strong>注册模型成功后, 就可以在站点管理界面方便快速的管理数据.</strong></p> 
</blockquote> 
<h3 id="4发布内容到数据库">4.发布内容到数据库</h3> 
<h3><img alt="" height="557" src="https://images2.imgbox.com/b4/e6/hRtQVk7t_o.png" width="1002"><img alt="" height="449" src="https://images2.imgbox.com/8e/a1/wJPTg0DF_o.png" width="1200"></h3> 
<ul><li>发布内容后，优化模型类展示</li></ul> 
<p><img alt="" height="431" src="https://images2.imgbox.com/28/7f/zLFQb24m_o.png" width="836"></p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/78/f0/zNEIQftf_o.png" width="851"></p> 
<p></p> 
<p></p> 
<h2 id="视图和url">视图和URL</h2> 
<blockquote> 
 <ul><li>站点管理页面做好了, 接下来就要做<code>公共访问</code>的页面了.</li><li>对于<code>Django</code>的设计框架<code>MVT</code>. 
   <ul><li>用户在URL中请求的是视图.</li><li>视图接收请求后进行处理.</li><li>并将处理的结果返回给请求者.</li></ul></li><li>使用视图时需要进行两步操作 
   <ul><li>1.定义视图</li><li>2.配置URLconf</li></ul></li></ul> 
</blockquote> 
<h3 id="1-定义视图">1. 定义视图</h3> 
<blockquote> 
 <ul><li>视图就是一个<code>Python</code>函数，被定义在<code>应用</code>的<code>views.py</code>中.</li><li>视图的第一个参数是<code>HttpRequest</code>类型的对象<code>reqeust</code>，包含了所有<code>请求信息</code>.</li><li>视图必须返回<code>HttpResponse对象</code>，包含返回给请求者的<code>响应信息</code>.</li><li> <p>需要导入<code>HttpResponse</code>模块 :<code>from django.http import HttpResponse</code></p> </li><li> <p>定义视图函数 : 响应字符串<code>OK!</code>给客户端<img alt="" height="568" src="https://images2.imgbox.com/1c/72/ZCLWFnTP_o.png" width="1049"></p> </li></ul> 
</blockquote> 
<blockquote> 
 <p><strong>思考 : 如何才能让请求找到视图?</strong></p> 
</blockquote> 
<h3 id="2-配置urlconf">2. 配置URLconf</h3> 
<blockquote> 
 <ul><li> <p><span style="color:#0d0016;">查找视图的过程 :</span></p> 
   <ul><li><span style="color:#0d0016;">1.请求者在浏览器地址栏中输入URL, 请求到网站.</span></li><li><span style="color:#0d0016;">2.网站获取URL信息.</span></li><li><span style="color:#0d0016;">3.然后与编写好的URLconf逐条匹配.</span></li><li><span style="color:#0d0016;">4.如果匹配成功则调用对应的视图.</span></li><li> <p><span style="color:#0d0016;">5.如果所有的URLconf都没有匹配成功.则返回404错误.<img alt="" height="296" src="https://images2.imgbox.com/51/be/Lx3CF2fK_o.png" width="1107"></span></p> </li></ul></li><li> <p><span style="color:#0d0016;"><code>URLconf</code>入口</span><img alt="" height="603" src="https://images2.imgbox.com/5d/8c/Arj4nl2Y_o.png" width="990"></p> </li><li> <p><span style="color:#0d0016;">需要两步完成<code>URLconf</code>配置</span></p> 
   <ul><li><span style="color:#0d0016;">1.在<code>项目</code>中定义<code>URLconf</code></span></li><li><span style="color:#0d0016;">2.在<code>应用</code>中定义<code>URLconf</code></span></li></ul></li><li> <p><span style="color:#0d0016;">在<code>项目</code>中定义<code>URLconf</code></span><img alt="" height="894" src="https://images2.imgbox.com/98/34/CeZayPel_o.png" width="1200"></p> </li></ul> 
 <pre><code class="language-python">"""bookmanager URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include


'''
1、urlpatterns 是固定写法，值是列表
2、浏览器中输入的路径会和urlpatterns 中的每一项顺序进行匹配
    如果匹配成功，则直接引导到相应的模块
    如果匹配不成功，则直接返回404
3、urlpatterns中的元素是 url
    url 的第一个参数是：正则
            r 转义
            ^ 严格的开始
            $ 严格的结尾
4、浏览器中输入的路由 中 哪些部分参与正则匹配
    http://ip:port/path/?key=value
    http://ip:port/ 和 get post 参数不参与正则匹配
5、如果和当前的某一项匹配成功，则引导到子应用中继续匹配
    如果匹配成功，则停止匹配返回相应的视图
    如果匹配不成功，则继承和后边的工程中的url的每一项继续匹配，直到匹配每一项
6、
'''

urlpatterns = [
    # http://127.0.0.1:8000/admin/
    # http://127.0.0.1:8000
    # admin/？a=100
    # admin/
    path('admin/', admin.site.urls),

    # 添加一项
    path('',include('book.urls'))
]






</code></pre> 
 <ul><li> <p><span style="color:#0d0016;">在<code>应用</code>中定义<code>URLconf</code></span></p> 
   <ul><li> <p><span style="color:#0d0016;">提示：一条<code>URLconf</code>包括URL规则、视图两部分</span></p> 
     <ul><li><span style="color:#0d0016;">URL规则使用正则表达式定义.</span></li><li> <p><span style="color:#0d0016;">视图就是在<code>views.py</code>中定义的视图函数</span><img alt="" height="672" src="https://images2.imgbox.com/83/30/HPMXI8Fm_o.png" width="804"></p> <pre><code class="language-python">from django.urls import path
from book.views import index

urlpatterns = [
    # index/
    # url的第一个参数是：正则
    # url的第二个参数是：视图函数名
    path('index/',index),
]</code></pre> </li><li> <p><span style="color:#0d0016;">url匹配过程</span><img alt="" height="375" src="https://images2.imgbox.com/d1/bd/op7RI6J8_o.png" width="1154"></p> </li></ul></li></ul></li></ul> 
</blockquote> 
<h3 id="3-测试：请求访问">3. 测试：请求访问</h3> 
<ul><li> <p><code>http://127.0.0.1:8000/index</code></p> </li></ul> 
<p><img alt="" height="217" src="https://images2.imgbox.com/89/5c/0MgsFpbD_o.png" width="849"></p> 
<h3>4. 总结</h3> 
<p>视图处理过程如下图：<img alt="" height="402" src="https://images2.imgbox.com/01/8c/cN9QlwPJ_o.png" width="869"></p> 
<blockquote> 
 <p>使用视图时需要进行两步操作，两步操作不分先后</p> 
 <ol><li>配置<code>URLconf</code></li><li>在<code>应用/views.py</code>中定义视图</li></ol> 
</blockquote> 
<p><img alt="" height="472" src="https://images2.imgbox.com/e5/93/7DQBp0J7_o.png" width="756"></p> 
<h4></h4> 
<h4></h4> 
<h2 id="模板">模板</h2> 
<blockquote> 
 <p>思考 : 网站如何向客户端返回一个漂亮的页面呢？</p> 
</blockquote> 
<blockquote> 
 <ul><li> <p>提示 :</p> 
   <ul><li>漂亮的页面需要<code>html</code>、<code>css</code>、<code>js</code>.</li><li>可以把这一堆字段串全都写到视图中, 作为<code>HttpResponse()</code>的参数,响应给客户端.</li></ul></li><li> <p>问题 :</p> 
   <ul><li>视图部分代码臃肿, 耦合度高.</li><li>这样定义的字符串是不会出任何效果和错误的.</li><li>效果无法及时查看.有错也不容易及时发现.</li></ul></li><li> <p>设想 :</p> 
   <ul><li>是否可以有一个专门定义前端页面的地方, 效果可以及时展示,错误可以及时发现,并且可以降低模块间耦合度!</li></ul></li><li> <p>解决问题 :<strong>模板</strong></p> 
   <ul><li><code>MVT</code>设计模式中的<code>T</code>,<code>Template</code></li></ul></li><li> <p><strong>在</strong><code>Django</code><strong>中, 将前端的内容定义在模板中, 然后再把模板交给视图调用, 各种漂亮、炫酷的效果就出现了.</strong></p> </li></ul> 
</blockquote> 
<h3 id="模板使用步骤">模板使用步骤</h3> 
<blockquote> 
 <ul><li>1.创建模板</li><li>2.设置模板查找路径</li><li>3.模板接收视图传入的数据</li><li>4.模板处理数据</li></ul> 
</blockquote> 
<h4 id="1创建模板">1.创建模板</h4> 
<blockquote> 
 <ul><li>在<code>应用</code>同级目录下创建模板文件夹<code>templates</code>. 文件夹名称固定写法.</li><li>在<code>templates</code>文件夹下, 创建<code>应用</code>同名文件夹. 例, <code>Book</code></li><li> <p>在<code>应用</code>同名文件夹下创建<code>网页模板</code>文件. 例 :<code>index.html</code></p> </li></ul> 
 <p><img alt="" height="392" src="https://images2.imgbox.com/7a/6b/L5bBuOYf_o.png" width="893"></p> 
</blockquote> 
<h4 id="2设置模板查找路径">2.设置模板查找路径</h4> 
<p><img alt="" height="646" src="https://images2.imgbox.com/8a/ef/AtaMOIy0_o.png" width="1158"></p> 
<h4 id="3模板接收视图传入的数据">3.模板接收视图传入的数据</h4> 
<ul><li> 
  <blockquote> 
   <p>视图模板加载</p> 
  </blockquote> </li></ul> 
<h4><img alt="" height="516" src="https://images2.imgbox.com/f2/b1/cienjs3r_o.png" width="927"></h4> 
<h4 id="4模板处理数据">4.模板处理数据</h4> 
<p><img alt="" height="588" src="https://images2.imgbox.com/84/c6/Zilk8Aby_o.png" width="1044"></p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/a7/0f/glr1to0a_o.png" width="828"></p> 
<h4 id="5-查看模板处理数据成果">5. 查看模板处理数据成果<img alt="" height="294" src="https://images2.imgbox.com/72/ba/Llk8RtR7_o.png" width="733"></h4> 
<p><img alt="" height="280" src="https://images2.imgbox.com/df/f1/YrE4Zg9l_o.png" width="717"></p> 
<p> 总结</p> 
<p><img alt="" height="351" src="https://images2.imgbox.com/af/a1/eh7rZqYw_o.png" width="831"></p> 
<p></p> 
<h2 id="展示书籍列表">展示书籍列表</h2> 
<h3 id="需求">需求</h3> 
<p><img alt="" height="226" src="https://images2.imgbox.com/04/9d/YdRAI7sP_o.png" width="583"></p> 
<h4 id="实现步骤">实现步骤</h4> 
<blockquote> 
 <ul><li>1.创建视图</li><li>2.创建模板</li><li>3.配置URLconf</li></ul> 
</blockquote> 
<h4 id="1创建视图">1.创建视图</h4> 
<blockquote> 
 <ul><li>查询数据库数据</li><li>构造上下文</li><li> <p>传递上下文到模板</p> </li></ul> 
</blockquote> 
<pre><code class="language-python">from django.shortcuts import render
from django.http import HttpRequest,HttpResponse
from book.models import BookInfo
# Create your views here.

def index(request):

    # 实现业务逻辑
    # 1、先把所有书籍查询出来
    # ORM 实现
    books = BookInfo.objects.all()
    # books = [BookInfo(),]
    # 2、组织数据

    context = {
        'books':books
    }
    # 3、将组织好的数据传递给模板
    return render(request,'index.html',context)</code></pre> 
<h4 id="2创建模板">2.创建模板</h4> 
<ul><li>读取上下文数据</li><li>构造网页html文档 : 书籍信息以列表样式展示</li></ul> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;a href="#"&gt;书籍列表&lt;/a&gt;
&lt;ul&gt;
    {% for book in books %}
        &lt;li&gt;{<!-- -->{ book.name }}&lt;/li&gt;
    {% endfor %}

&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h4 id="3配置urlconf">3.配置URLconf</h4> 
<ul><li> <p>进入<code>应用</code>中的<code>urls.py</code>文件</p> </li></ul> 
<pre><code class="language-python">from django.urls import path
from book.views import index
urlpatterns = [
    path('index/',index),
]</code></pre> 
<h4></h4> 
<h2 id="配置、静态文件与路由">配置和静态文件</h2> 
<h3 id="配置文件">settings 配置文件</h3> 
<h4 id="1-basedir">1. BASE_DIR</h4> 
<pre><code class="language-python">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
</code></pre> 
<p>当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。<img alt="" height="629" src="https://images2.imgbox.com/c8/b2/Gm04s2xP_o.png" width="860"></p> 
<h4 id="2-debug">2. DEBUG</h4> 
<p>调试模式，创建工程后初始值为<strong>True</strong>，即默认工作在调试模式下。</p> 
<p>作用：</p> 
<ul><li> <p>修改代码文件，程序自动重启</p> </li><li> <p>Django程序出现异常时，向前端显示详细的错误追踪信息，例如</p> </li></ul> 
<p><img alt="" height="468" src="https://images2.imgbox.com/c3/cb/J3EkTym2_o.png" width="1200"></p> 
<ul><li> <p>而非调试模式下，仅返回Server Error (500)</p> </li></ul> 
<p><strong>注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG=False和ALLOW_HOSTS。</strong></p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/9a/3e/mBSIM5Vj_o.png" width="904"></p> 
<h4 id="3-本地语言与时区">3、静态文件</h4> 
<p>项目中的CSS、图片、js都是静态文件。一般会将静态文件放到一个单独的目录中，以方便管理。在html页面中调用时，也需要指定静态文件的路径，Django中提供了一种解析的方式配置静态文件路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在项目中是通用的，所以推荐放在项目的根目录下，方便管理。</p> 
<p>为了提供静态文件，需要配置两个参数：</p> 
<blockquote> 
 <ul><li><strong>STATICFILES_DIRS</strong>存放查找静态文件的目录</li><li><strong>STATIC_URL</strong>访问静态文件的URL前缀</li></ul> 
</blockquote> 
<p id="示例"><strong>示例</strong></p> 
<p>1） 在项目根目录下创建static目录来保存静态文件。</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/78/94/0HJGJeCW_o.png" width="599"></p> 
<p>2） 在bookmanager/settings.py中修改静态文件的两个参数为</p> 
<pre><code class="language-python">STATIC_URL = '/static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
</code></pre> 
<p>3）此时在static添加的任何静态文件都可以使用网址<strong>/static/文件在static中的路径</strong>来访问了。</p> 
<p><img alt="" height="686" src="https://images2.imgbox.com/5d/1a/G2x4nwIU_o.png" width="1200"></p> 
<p>例如，我们向static目录中添加一个index.html文件，在浏览器中就可以使用127.0.0.1:8000/static/index.html来访问。</p> 
<p>或者我们在static目录中添加了一个子目录和文件book/detail.html，在浏览器中就可以使用127.0.0.1:8000/static/book/detail.html来访问。</p> 
<p></p> 
<h4 id="app应用配置">4、App应用配置</h4> 
<p><img alt="" height="833" src="https://images2.imgbox.com/a0/36/SHvzQxmX_o.png" width="1186"></p> 
<p>在每个应用目录中都包含了apps.py文件，用于保存该应用的相关信息。</p> 
<p>在创建应用时，Django会向apps.py文件中写入一个该应用的配置类，如</p> 
<pre><code>from django.apps import AppConfig


class BookConfig(AppConfig):
    name = 'book'
</code></pre> 
<p>我们将此类添加到工程settings.py中的INSTALLED_APPS列表中，表明注册安装具备此配置属性的应用。</p> 
<ul><li> <p><strong>AppConfig.name</strong>属性表示这个配置类是加载到哪个应用的，每个配置类必须包含此属性，默认自动生成。</p> </li><li> <p><strong>AppConfig.verbose_name</strong>属性用于设置该应用的直观可读的名字，此名字在Django提供的Admin管理站点中会显示，如</p> <pre><code class="language-python">from django.apps import AppConfig

class UsersConfig(AppConfig):
    name = 'book'
    verbose_name = '后台相关'</code></pre> </li></ul> 
<p> <img alt="" height="611" src="https://images2.imgbox.com/6c/cc/sEQFggcs_o.png" width="851"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/a2/2a/gfOts33p_o.png" width="923"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/55/f7/AK8h2MTd_o.png" width="1119"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="django介绍">模型</h2> 
<p id="1-创建虚拟环境">重点</p> 
<ul><li><strong>模型配置</strong></li><li> <p><strong>数据的增删改</strong></p> 
  <ul><li> <p>增:<code>book = BookInfo() book.save()</code> 和 <code>BookInfo.objects.create()</code></p> </li><li> <p>删:<code>book.delete()</code> 和<code>BookInfo.objects.get().delete()</code></p> </li><li> <p>改:<code>book.name='xxx' book.save()</code> 和 <code>BookInfo.objects.get().update(name=xxx)</code></p> </li></ul></li><li> <p><strong>数据的查询</strong></p> 
  <ul><li> <p>基础查询</p> </li><li> <p>F对象和Q对象</p> </li><li> <p>关联查询</p> </li><li> <p>查询集QuerySet</p> </li></ul></li></ul> 
<p><img alt="" height="549" src="https://images2.imgbox.com/a4/87/vSR1ZP3I_o.png" width="1108"></p> 
<h3 id="项目准备">一、项目准备</h3> 
<h4>1.创建项目</h4> 
<blockquote> 
 <p><strong>django-admin startproject bookmanager01</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>先设置用户：  python manage.py migrate </strong></p> 
</blockquote> 
<h4>2.创建应用</h4> 
<blockquote> 
 <p><strong>python manage.py startapp book</strong></p> 
</blockquote> 
<h4>3. 运行开发服务器</h4> 
<blockquote> 
 <p></p> 
 <p><strong>运行服务器命令：  python manage.py runserver ip:端口  </strong></p> 
 <p><strong>                        或：python manage.py runserver</strong></p> 
</blockquote> 
<h4>4.安装应用</h4> 
<pre><code>INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    #添加子应用
    'book.apps.BookConfig'
]
</code></pre> 
<h4><img alt="" height="716" src="https://images2.imgbox.com/5b/4e/KKWpVhb1_o.png" width="1050"></h4> 
<h4>5.本地化</h4> 
<pre><code class="language-python">#设置中文
LANGUAGE_CODE = 'zh-Hans'
#亚洲上海时区
TIME_ZONE = 'Asia/Shanghai'
</code></pre> 
<p><img alt="" height="621" src="https://images2.imgbox.com/08/32/NsJhfgqo_o.png" width="1074"></p> 
<h4>6.创建管理员</h4> 
<blockquote> 
 <p><strong>创建管理员命令：python manage.py createsuperuser</strong></p> 
</blockquote> 
<h4><img alt="" height="154" src="https://images2.imgbox.com/a3/41/tD4ThEyQ_o.png" width="731"></h4> 
<h4>7.模板路径</h4> 
<p>在应用同级目录下,创建<code>templates</code>模板文件夹</p> 
<pre><code class="language-python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR/'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
</code></pre> 
<h4><img alt="" height="666" src="https://images2.imgbox.com/7c/8c/5ZkKMZAd_o.png" width="1200"></h4> 
<h4>8.项目中匹配urls</h4> 
<p>正则 : 路径只要不是<code>admin/</code>就算匹配成功。并包含到应用中的<code>urls.py</code></p> 
<pre><code class="language-python">from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),

    path('',include('book.urls'))
]
</code></pre> 
<h4><img alt="" height="785" src="https://images2.imgbox.com/79/a2/kvjx6aZv_o.png" width="1200"></h4> 
<h4>9.准备视图</h4> 
<pre><code class="language-python"># 定义视图：提供书籍列表信息
def bookList(request):

    return HttpResponse('OK!')
</code></pre> 
<h4><img alt="" height="396" src="https://images2.imgbox.com/88/3c/Fu5dDyfm_o.png" width="1199"></h4> 
<h4> 10.应用中匹配<code>urls.py</code></h4> 
<blockquote> 
 <p>应用中创建 <code>urls.py</code></p> 
 <p>正则 : 路径中包含<code>booklist/</code>，就调用视图中对应的<code>bookList</code>函数</p> 
</blockquote> 
<pre><code class="language-python">from django.urls import path
from book.views import bookList
urlpatterns = [
    path('booklist/',bookList),
]</code></pre> 
<h4><img alt="" height="438" src="https://images2.imgbox.com/69/21/RswW8V3A_o.png" width="990"></h4> 
<h4>11.开启服务器, 测试项目</h4> 
<blockquote> 
 <p>进入项目文件中, 开启项目对应的服务器<br><strong> python manage.py runserver</strong></p> 
 <p></p> 
 <p>浏览器中输入网址 http://127.0.0.1:8000/booklist/</p> 
</blockquote> 
<p> <img alt="" height="209" src="https://images2.imgbox.com/61/c8/FIaafWgY_o.png" width="640"></p> 
<h4></h4> 
<h3 id="配置">二、配置数据库</h3> 
<p>在settings.py中保存了数据库的连接配置信息，Django默认初始配置使用<strong>sqlite</strong>数据库。</p> 
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
</code></pre> 
<h4>1、使用<strong>MySQL</strong>数据库首先需要安装驱动程序</h4> 
<blockquote> 
 <p>pip install PyMySQL</p> 
</blockquote> 
<p>在Django的工程同名子目录的__init__.py文件中添加如下语句</p> 
<pre><code class="language-python">import pymysql

pymysql.install_as_MySQLdb()
</code></pre> 
<p><img alt="" height="559" src="https://images2.imgbox.com/88/94/wUlNJ44q_o.png" width="791"></p> 
<p>作用是让Django的ORM能以mysqldb的方式来调用PyMySQL。</p> 
<ol><li> <p>修改<strong>DATABASES</strong>配置信息</p> </li></ol> 
<pre><code class="language-python"># sqlite 主要是一个嵌入式的关系型数据库
# 主要用在移动端
# sqlite 属于小型的关系型数据库
# 中型数据库 mysql（甲骨文）  sqlserver（微软）
# 大型数据 oracle   DB2
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '127.0.0.1',     # 数据库主机
        'PORT': '3306',          # 数据库端口
        'USER': 'root',          # 数据库用户名
        'PASSWORD': '123456',    # 数据库用户密码
        'NAME': 'book',          # 数据库名字
    }
}
</code></pre> 
<p><img alt="" height="674" src="https://images2.imgbox.com/71/0d/qPeq3oM5_o.png" width="1129"></p> 
<ol><li> <p>在MySQL中创建数据库</p> </li></ol> 
<blockquote> 
 <p>create database book charset=utf8;</p> 
</blockquote> 
<p></p> 
<h3 id="定义模型类">三、定义模型类</h3> 
<ul><li>模型类被定义在"应用/models.py"文件中。</li><li>模型类必须继承自Model类，位于包django.db.models中。</li></ul> 
<h4 id="1-定义">1 定义</h4> 
<p>在models.py 文件中定义模型类。</p> 
<pre><code class="language-python">from django.db import models

# Create your models here.
'''
    1、ORM
        表 --》 类
        字段 --》 属性
        
    2、模型类需要继承models.Model
    
    3、模型类会自动为我们添加（生成）一个主键
    
    4、属性名 = 属性类型（选项）
        属性名：不要使用关键，不要使用连续的下划线
        属性类型：和mysql的类型相似
        选项：charfiled 必须设置 max_length
            varchar(m)
            null  是否为空
            unique 唯一
            default 设置默认值
            verbose_name 主要是 admin 后台显示
    
    书籍表：
        id,name,pub_date,readcount,commentcount,is_delete
        
'''
# 准备书籍列表信息的模型类
class BookInfo(models.Model):
    # 属性名 = 属性类型（选项）
    name = models.CharField(10,unique=True,verbose_name='名字')
    # 发布日期
    pub_date = models.DateField(null=True)
    # 阅读量
    readcount = models.IntegerField(default=0)
    # 评论量
    commentcount = models.IntegerField(default=0)
    # 是否逻辑删除
    is_delete = models.BooleanField(default=False)

    class Meta:
        # 改表名
        db_table = 'bookinfo'
        # 修改后台admin的显示信息的配置
        verbose_name = 'admin'


    def __str__(self):
        return self.name


# 准备人物列表信息的模型类
class PeopleInfo(models.Model):
    # 有序字典
    GENDER_CHOICES = (
        (0, 'male'),
        (1, 'female')
    )
    name = models.CharField(max_length=20, verbose_name='名称')
    gender = models.SmallIntegerField(choices=GENDER_CHOICES, default=0, verbose_name='性别')
    description = models.CharField(max_length=200, null=True, verbose_name='描述信息')
    # on_delete 联级
    book = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name='图书')  # 外键
    is_delete = models.BooleanField(default=False, verbose_name='逻辑删除')

    class Meta:
        db_table = 'peopleinfo'
        verbose_name = '人物信息'

    def __str__(self):
        return self.name</code></pre> 
<h5><strong>1） 数据库表名</strong></h5> 
<p>模型类如果未指明表名，Django默认以<strong>小写app应用名_小写模型类名</strong>为数据库表名。</p> 
<p>可通过<strong>db_table</strong>指明数据库表名。</p> 
<h5><strong>2） 关于主键</strong></h5> 
<p>django会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后django不会再创建自动增长的主键列。</p> 
<p>默认创建的主键列属性为id，可以使用pk代替，pk全拼为primary key。</p> 
<h5><strong>3） 属性命名限制</strong></h5> 
<ul><li>不能是python的保留关键字。</li><li>不允许使用连续的下划线，这是由django的查询方式决定的。</li><li> <p>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：</p> </li></ul> 
<blockquote> 
 <p><strong>属性 = models.字段类型(选项)</strong></p> 
</blockquote> 
<h5><strong>4）字段类型</strong></h5> 
<table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>AutoField</td><td>自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性</td></tr><tr><td>BooleanField</td><td>布尔字段，值为True或False</td></tr><tr><td>NullBooleanField</td><td>支持Null、True、False三种值</td></tr><tr><td>CharField</td><td>字符串，参数max_length表示最大字符个数</td></tr><tr><td>TextField</td><td>大文本字段，一般超过4000个字符时使用</td></tr><tr><td>IntegerField</td><td>整数</td></tr><tr><td>DecimalField</td><td>十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数</td></tr><tr><td>FloatField</td><td>浮点数</td></tr><tr><td>DateField</td><td>日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于"最后一次修改"的时间戳，它总是使用当前日期，默认为False； 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为False; 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误</td></tr><tr><td>TimeField</td><td>时间，参数同DateField</td></tr><tr><td>DateTimeField</td><td>日期时间，参数同DateField</td></tr><tr><td>FileField</td><td>上传文件字段</td></tr><tr><td>ImageField</td><td>继承于FileField，对上传的内容进行校验，确保是有效的图片</td></tr></tbody></table> 
<h5><strong>5） 选项</strong></h5> 
<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>null</td><td>如果为True，表示允许为空，默认值是False</td></tr><tr><td>blank</td><td>如果为True，则该字段允许为空白，默认值是False</td></tr><tr><td>db_column</td><td>字段的名称，如果未指定，则使用属性的名称</td></tr><tr><td>db_index</td><td>若值为True, 则在表中会为此字段创建索引，默认值是False</td></tr><tr><td>default</td><td>默认</td></tr><tr><td>primary_key</td><td>若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用</td></tr><tr><td>unique</td><td>如果为True, 这个字段在表中必须有唯一值，默认值是False</td></tr></tbody></table> 
<p><strong>null是数据库范畴的概念，blank是表单验证范畴的</strong></p> 
<h5><strong>6） 外键</strong></h5> 
<p>在设置外键时，需要通过<strong>on_delete</strong>选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量：</p> 
<ul><li> <p><strong>CASCADE</strong>级联，删除主表数据时连通一起删除外键表中数据</p> </li><li> <p><strong>PROTECT</strong>保护，通过抛出<strong>ProtectedError</strong>异常，来阻止删除主表中被外键应用的数据</p> </li><li> <p><strong>SET_NULL</strong>设置为NULL，仅在该字段null=True允许为null时可用</p> </li><li> <p><strong>SET_DEFAULT</strong>设置为默认值，仅在该字段设置了默认值时可用</p> </li><li> <p><strong>SET()</strong>设置为特定值或者调用特定方法</p> </li><li> <p><strong>DO_NOTHING</strong>不做任何操作，如果数据库前置指明级联性，此选项会抛出<strong>IntegrityError</strong>异常</p> </li></ul> 
<h4 id="2-迁移">2 迁移</h4> 
<p>将模型类同步到数据库中。</p> 
<h5><strong>1）生成迁移文件</strong></h5> 
<blockquote> 
 <p><strong>python manage.py makemigrations</strong></p> 
</blockquote> 
<h5><strong>2）同步到数据库中</strong></h5> 
<blockquote> 
 <p><strong>python manage.py migrate</strong></p> 
</blockquote> 
<h4 id="3-添加测试数据">3 添加测试数据</h4> 
<pre><code class="language-sql">insert into bookinfo(name, pub_date, readcount,commentcount, is_delete) values
('射雕英雄传', '1980-5-1', 12, 34, 0),
('天龙八部', '1986-7-24', 36, 40, 0),
('笑傲江湖', '1995-12-24', 20, 80, 0),
('雪山飞狐', '1987-11-11', 58, 24, 0);
</code></pre> 
<pre><code class="language-sql">insert into peopleinfo(name, gender, book_id, description, is_delete)  values
    ('郭靖', 1, 1, '降龙十八掌', 0),
    ('黄蓉', 0, 1, '打狗棍法', 0),
    ('黄药师', 1, 1, '弹指神通', 0),
    ('欧阳锋', 1, 1, '蛤蟆功', 0),
    ('梅超风', 0, 1, '九阴白骨爪', 0),
    ('乔峰', 1, 2, '降龙十八掌', 0),
    ('段誉', 1, 2, '六脉神剑', 0),
    ('虚竹', 1, 2, '天山六阳掌', 0),
    ('王语嫣', 0, 2, '神仙姐姐', 0),
    ('令狐冲', 1, 3, '独孤九剑', 0),
    ('任盈盈', 0, 3, '弹琴', 0),
    ('岳不群', 1, 3, '华山剑法', 0),
    ('东方不败', 0, 3, '葵花宝典', 0),
    ('胡斐', 1, 4, '胡家刀法', 0),
    ('苗若兰', 0, 4, '黄衣', 0),
    ('程灵素', 0, 4, '医术', 0),
    ('袁紫衣', 0, 4, '六合拳', 0);</code></pre> 
<h3> 四、shell工具和查看MySQL数据库日志</h3> 
<h4 id="1-shell工具">1、shell工具</h4> 
<p>Django的manage工具提供了<strong>shell</strong>命令，帮助我们配置好当前工程的运行环境（如连接好数据库等），以便可以直接在终端中执行测试python语句。</p> 
<p>通过如下命令进入shell</p> 
<blockquote> 
 <p><strong>python manage.py shell</strong></p> 
</blockquote> 
<p>导入两个模型类，以便后续使用</p> 
<blockquote> 
 <p><strong>from book.models import BookInfo,PeopleInfo</strong></p> 
 <p></p> 
 <p><strong>BookInfo.objects.all()</strong></p> 
</blockquote> 
<h3><img alt="" height="243" src="https://images2.imgbox.com/4c/1f/rucAI8Fy_o.png" width="1101"></h3> 
<h4 id="2-查看mysql数据库日志">2 查看MySQL数据库日志</h4> 
<p>查看mysql数据库日志可以查看对数据库的操作记录。 mysql日志文件默认没有产生，需要做如下配置：</p> 
<blockquote> 
 <p><strong>vi /etc/mysql/mysql.conf.d/mysqld.cnf</strong></p> 
</blockquote> 
<p>把68，69行前面的#去除，然后保存并使用如下命令重启mysql服务。</p> 
<blockquote> 
 <p><strong>service mysql restart</strong></p> 
</blockquote> 
<p>使用如下命令打开mysql日志文件。</p> 
<blockquote> 
 <p><strong>tail -f /var/log/mysql/mysql.log </strong>    # 可以实时查看数据库的日志内容</p> 
 <p></p> 
 <p># 如提示需要sudo权限，执行<br> # sudo tail -f /var/log/mysql/mysql.log</p> 
</blockquote> 
<h4></h4> 
<h4></h4> 
<h3>五、数据库操作-增、删、改</h3> 
<h4 id="1-增加">1 增加</h4> 
<p>增加数据有两种方法。</p> 
<h5><strong>1）save（方法一）</strong></h5> 
<p>通过创建模型类对象，执行对象的save()方法保存到数据库中。</p> 
<pre><code class="language-python">from book.models import BookInfo
# 方式一
# 会把新生成的对象返回给我们
book = BookInfo(
    name = 'python',
    pub_date = '2010-1-1'
)

# 需要手动待用saver方法
book.save()</code></pre> 
<p><img alt="" height="890" src="https://images2.imgbox.com/60/56/jZs8lFoG_o.png" width="1200"></p> 
<h5><strong>2）create（方法二）</strong></h5> 
<p>通过模型类.objects.create()保存。</p> 
<pre><code class="language-python"># 方式二 直接入库
# objects 模型的管理类
# 我们对模型的 增删改查 都用它
BookInfo.objects.create(
    name = 'java',
    pub_date = '2023-1-1'
)</code></pre> 
<h4><img alt="" height="903" src="https://images2.imgbox.com/88/90/Hg1XnKaa_o.png" width="1200"></h4> 
<h4 id="3-修改">2 修改</h4> 
<p>修改更新有两种方法</p> 
<h5><strong>1）save（方法一）</strong></h5> 
<p><strong>修改模型类对象的属性，然后执行save()方法</strong></p> 
<pre><code class="language-python">from book.models import BookInfo
# 1、先查询数据
book = BookInfo.objects.get(id = 1)
# 2、修改实例属性
book.readcount = 20
# 3、调用save方法
book.save()</code></pre> 
<h5><img alt="" height="800" src="https://images2.imgbox.com/ea/5e/isgSitUw_o.png" width="1200"></h5> 
<h5><strong>2）update（方法二）</strong></h5> 
<p><strong>使用模型类.objects.filter().update()</strong>，会返回受影响的行数</p> 
<pre><code class="language-python"># 方法二 直接更新
# filter 过滤
BookInfo.objects.filter(id = 2).update(
    readcount = 200,
    commentcount = 300
)
</code></pre> 
<p><img alt="" height="814" src="https://images2.imgbox.com/46/f7/QdxIRHN0_o.png" width="1200"></p> 
<h4 id="4-删除">3 删除</h4> 
<p>删除有两种方法</p> 
<h5><strong>1）模型类对象delete</strong></h5> 
<pre><code class="language-python"># 方法一
# 先查出数据
book = BookInfo.objects.get(name='python')
# 调用删除方法
book.delete()</code></pre> 
<h5><strong>2）模型类.objects.filter().delete()</strong></h5> 
<pre><code class="language-python">BookInfo.objects.filter(name='java').delete()</code></pre> 
<p><img alt="" height="870" src="https://images2.imgbox.com/5b/77/3fgnKfib_o.png" width="1200"></p> 
<h3>六、数据库操作-查询 </h3> 
<h4 id="基础条件查询">基础条件查询</h4> 
<h4 id="21-基本查询">1 基本查询</h4> 
<blockquote> 
 <p><strong>get   </strong>查询单一结果，如果不存在会抛出<strong>模型类.DoesNotExist</strong>异常。</p> 
 <p><strong>all    </strong>查询多个结果。</p> 
 <p><strong>count    </strong>查询结果数量。</p> 
</blockquote> 
<pre><code class="language-python"># get    得到某一个数据
# all    获取所有的
# count  个数

from book.models import BookInfo

# get返回一个对象
book = BookInfo.objects.get(id=1)
# 查询不存在的数据会抛出异常  # 完美写法
try:
    book = BookInfo.objects.get(id=2)
except BookInfo.DoesNotExist:
    pass


# all 返回所有结果是列表
BookInfo.objects.all()


# count
BookInfo.objects.all().count()
BookInfo.objects.count()</code></pre> 
<h4><img alt="" height="856" src="https://images2.imgbox.com/fc/66/lLjG6iTH_o.png" width="945"></h4> 
<p><img alt="" height="519" src="https://images2.imgbox.com/fc/3e/1qHLg5Qd_o.png" width="1181"> <img alt="" height="509" src="https://images2.imgbox.com/9e/58/4kRPSMoD_o.png" width="968"></p> 
<p></p> 
<h4 id="22-过滤查询">2 过滤查询</h4> 
<p>实现SQL中的where功能，包括</p> 
<blockquote> 
 <p><strong>filter        </strong>过滤出多个结果</p> 
 <p><strong>exclude   </strong>排除掉符合条件剩下的结果</p> 
 <p><strong>get         </strong>过滤单一结果</p> 
</blockquote> 
<p>对于过滤条件的使用，上述三个方法相同，故仅以<strong>filter</strong>进行讲解。</p> 
<p>过滤条件的表达语法如下：</p> 
<blockquote> 
 <pre><strong># 语法形式：  filter(属性名称__比较运算符 = 值)
# 属性名称和比较运算符间使用两个下划线，所以属性名不能包括多个下划线</strong>
</pre> 
</blockquote> 
<h5><strong>1）相等</strong></h5> 
<p><strong>exact：表示判等。</strong></p> 
<p>例：查询编号为1的图书。</p> 
<pre><code class="language-python">BookInfo.objects.get(id__exact = 1)    # exact 精确的 就是等于
BookInfo.objects.get(id= 1)

BookInfo.objects.filter(id=1)
BookInfo.objects.filter(id__exact = 1)</code></pre> 
<p><img alt="" height="790" src="https://images2.imgbox.com/c5/59/utZLOZ2b_o.png" width="990"></p> 
<h5><strong>2）模糊查询</strong></h5> 
<p><strong>contains：是否包含。</strong></p> 
<blockquote> 
 <p>说明：如果要包含%无需转义，直接写即可。</p> 
</blockquote> 
<p>例：查询书名包含'湖'的图书。</p> 
<pre><code class="language-python"># 查询书名包含'湖'的图书
# contains 包含
BookInfo.objects.filter(name__contains='湖')</code></pre> 
<p><img alt="" height="365" src="https://images2.imgbox.com/e5/12/BMxssYwI_o.png" width="899"></p> 
<p><strong>startswith、endswith：以指定值开头或结尾。</strong></p> 
<p>例：查询书名以'部'结尾的图书</p> 
<pre><code class="language-python"># 查询书名以'部'结尾的图书
BookInfo.objects.filter(name__endswith='部')</code></pre> 
<p><img alt="" height="381" src="https://images2.imgbox.com/75/ce/CuohzgLC_o.png" width="981"></p> 
<blockquote> 
 <p>以上运算符都区分大小写，在这些运算符前加上i表示不区分大小写，如iexact、icontains、istartswith、iendswith</p> 
</blockquote> 
<h5><strong>3） 空查询</strong></h5> 
<p><strong>isnull：是否为null。</strong></p> 
<p>例：查询书名为空的图书。</p> 
<pre><code class="language-python"># 查询书名为空的图书
BookInfo.objects.filter(name__isnull=True)</code></pre> 
<h5><img alt="" height="233" src="https://images2.imgbox.com/2d/76/s0lRhheQ_o.png" width="919"></h5> 
<h5><strong>4） 范围查询</strong></h5> 
<p><strong>in：是否包含在范围内。</strong></p> 
<p>例：查询编号为1或3或5的图书</p> 
<pre><code class="language-python"># 查询编号为1或3或5的图书
BookInfo.objects.filter(id__in=[1,3,5])</code></pre> 
<p><img alt="" height="334" src="https://images2.imgbox.com/6e/45/KfoL6Sgs_o.png" width="868"></p> 
<h5><strong>5）比较查询</strong></h5> 
<blockquote> 
 <p><strong>gt    </strong>大于 (greater then)</p> 
 <p><strong>gte  </strong>大于等于 (greater then equal)</p> 
 <p><strong>lt     </strong>小于 (less then)</p> 
 <p><strong>lte   </strong>小于等于 (less then equal)</p> 
</blockquote> 
<p>例：查询编号大于3的图书</p> 
<pre><code class="language-python">BookInfo.objects.filter(id__gt=3)
</code></pre> 
<p><img alt="" height="276" src="https://images2.imgbox.com/9e/4e/riOZAVJj_o.png" width="790"></p> 
<p><strong>不等于的运算符，使用exclude()过滤器。</strong></p> 
<p>例：查询编号不等于3的图书</p> 
<pre><code class="language-python"># 查询编号不等于3的图书
BookInfo.objects.exclude(id=3)</code></pre> 
<p><img alt="" height="243" src="https://images2.imgbox.com/93/b7/G0XwZWeD_o.png" width="870"></p> 
<h5><strong>6）日期查询</strong></h5> 
<p><strong>year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。</strong></p> 
<p>例：查询1980年发表的图书。</p> 
<pre><code class="language-python"># 查询1980年发表的图书
BookInfo.objects.filter(pub_date__year=1980)</code></pre> 
<p><img alt="" height="284" src="https://images2.imgbox.com/68/a3/Ziipbud6_o.png" width="839"></p> 
<p>例：查询1990年1月1日后发表的图书。</p> 
<pre><code class="language-python"># 查询1990年1月1日后发表的图书
BookInfo.objects.filter(pub_date__gt='1990-1-1')</code></pre> 
<p><img alt="" height="261" src="https://images2.imgbox.com/b1/4e/So1lAZrW_o.png" width="876"> 注意事项</p> 
<p><img alt="" height="761" src="https://images2.imgbox.com/9e/ac/nyDXg9sb_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p></p> 
<h4 id="f和q对象">3、F和Q对象</h4> 
<h5 id="f对象">F对象</h5> 
<p>之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？</p> 
<p>答：使用F对象，被定义在django.db.models中。</p> 
<blockquote> 
 <p><strong>语法：    F(属性名)</strong></p> 
</blockquote> 
<p>例：查询阅读量大于等于评论量的图书。</p> 
<pre><code class="language-python"># 查询阅读量大于等于评论量的图书
from django.db.models import F
BookInfo.objects.filter(readcount__gt=F('commentcount'))</code></pre> 
<p><img alt="" height="335" src="https://images2.imgbox.com/0a/40/gyoRnqHl_o.png" width="1030"></p> 
<p>可以在F对象上使用算数运算。</p> 
<p>例：查询阅读量大于2倍评论量的图书。</p> 
<pre><code class="language-python"># 查询阅读量大于2倍评论量的图书
BookInfo.objects.filter(readcount__gt=F('commentcount')*2)</code></pre> 
<p><img alt="" height="279" src="https://images2.imgbox.com/42/73/PASVUfnf_o.png" width="1069"></p> 
<h5 id="q对象">Q对象</h5> 
<p><strong>多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。</strong></p> 
<p>例：查询阅读量大于20，并且编号小于3的图书。</p> 
<pre><code class="language-python"># 查询阅读量大于20，并且编号小于3的图书。
BookInfo.objects.filter(readcount__gt=20,id__lt=3)

BookInfo.objects.filter(readcount__gt=20).filter(id__lt=3)</code></pre> 
<p><img alt="" height="414" src="https://images2.imgbox.com/9d/6c/GG6lr4gB_o.png" width="1105"></p> 
<p><strong>如果需要实现逻辑或or的查询，需要使用Q()对象结合|运算符</strong>，<strong>Q对象被义在django.db.models中。</strong></p> 
<blockquote> 
 <p><strong>语法：    Q(属性名__运算符=值)</strong></p> 
</blockquote> 
<p>例：查询阅读量大于20的图书，改写为Q对象如下。</p> 
<pre><code class="language-python"># 查询阅读量大于20的图书，改写为Q对象如下。
from django.db.models import Q

BookInfo.objects.filter(Q(readcount__gt=20))</code></pre> 
<p><img alt="" height="400" src="https://images2.imgbox.com/48/79/1F0XYhvi_o.png" width="1140"></p> 
<p>Q对象可以使用&amp;、|连接，&amp;表示逻辑与，|表示逻辑或。</p> 
<p>例：查询阅读量大于20，或编号小于3的图书，只能使用Q对象实现</p> 
<pre><code class="language-python"># 查询阅读量大于20，或编号小于3的图书，只能使用Q对象实现
BookInfo.objects.filter(Q(readcount__gt=20)|Q(id__lt=3))</code></pre> 
<p><img alt="" height="284" src="https://images2.imgbox.com/dd/e3/jk78DILh_o.png" width="1131"></p> 
<p>Q对象前可以使用~操作符，表示非not。</p> 
<p>例：查询编号不等于3的图书。</p> 
<pre><code class="language-python"># 查询编号不等于3的图书。
BookInfo.objects.filter(~Q(id=3))</code></pre> 
<p><img alt="" height="250" src="https://images2.imgbox.com/0e/78/1rwtNiul_o.png" width="1144"></p> 
<p></p> 
<h4 id="聚合函数">4、聚合函数和排序函数</h4> 
<h5 id="23--排序">1. 聚合函数</h5> 
<p>使用aggregate()过滤器调用聚合函数。聚合函数包括：<strong>Avg</strong>平均，<strong>Count</strong>数量，<strong>Max</strong>最大，<strong>Min</strong>最小，<strong>Sum</strong>求和，被定义在django.db.models中。</p> 
<p>例：查询图书的总阅读量。</p> 
<pre><code class="language-python">from django.db.models import Sum
# 查询图书的总阅读量。
BookInfo.objects.aggregate(Sum('readcount'))</code></pre> 
<p><img alt="" height="328" src="https://images2.imgbox.com/c7/19/8UUVmJhe_o.png" width="975"></p> 
<p>注意aggregate的返回值是一个字典类型，格式如下：</p> 
<blockquote> 
 <p><strong>  {'属性名__聚合类小写':值}</strong></p> 
 <p></p> 
 <p>  如:{'readcount__sum': 298}</p> 
</blockquote> 
<p>使用count时一般不使用aggregate()过滤器。</p> 
<p>例：查询图书总数。</p> 
<pre><code class="language-python"># 查询图书总数。
BookInfo.objects.count()
</code></pre> 
<p><img alt="" height="305" src="https://images2.imgbox.com/62/34/TzIuSCKK_o.png" width="1005"></p> 
<p>注意count函数的返回值是一个数字。</p> 
<h5>2. 排序</h5> 
<p>使用<strong>order_by</strong>对结果进行排序</p> 
<pre><code class="language-python"># 默认升序
BookInfo.objects.all().order_by('readcount')

# 降序
BookInfo.objects.all().order_by('-readcount')</code></pre> 
<p><img alt="" height="520" src="https://images2.imgbox.com/12/9a/HfHdT5PI_o.png" width="1118"></p> 
<h4>5、关联查询</h4> 
<blockquote> 
 <p>查询书籍为1的所有人物信息<br> 查询人物为1的书籍信息</p> 
</blockquote> 
<p>由一到多的访问语法：</p> 
<blockquote> 
 <p>一对一的模型类对象.多对一的模型类名小写_set</p> 
</blockquote> 
<p>例：</p> 
<pre><code class="language-python"># 查询书籍为1的所有人物信息  ==》 通过书籍 查询人物

# 查询书籍
book = BookInfo.objects.get(id=1)

# 根据书籍关联人物信息
book.peopleinfo_set.all()</code></pre> 
<p><img alt="" height="399" src="https://images2.imgbox.com/80/17/cF6ImpXH_o.png" width="1200"></p> 
<p>由多到一的访问语法:</p> 
<blockquote> 
 <p>多对应的模型类对象.多对应的模型类中的关系类属性名</p> 
</blockquote> 
<p>例：</p> 
<pre><code class="language-python"># 查询人物为1的书籍信息   ==》 根据书籍查询人物
from book.models import PeopleInfo
# 1、查询人物
person = PeopleInfo.objects.get(id=1)
# 2、根据人物关联查询数据
person.book

person.book.name
person.book.readcount
person</code></pre> 
<p><img alt="" height="366" src="https://images2.imgbox.com/53/b6/cWuUwy0r_o.png" width="974"></p> 
<p>访问一对一的模型类关联对象的id语法:</p> 
<blockquote> 
 <p>多对一的模型类对象.关联类属性_id</p> 
</blockquote> 
<p>例：</p> 
<pre><code class="language-python">person = PeopleInfo.objects.get(id=1)
person.book_id
</code></pre> 
<p><img alt="" height="259" src="https://images2.imgbox.com/b2/11/8WO3nXBx_o.png" width="889"></p> 
<h5><img alt="" height="378" src="https://images2.imgbox.com/8a/34/6flz8Pnh_o.png" width="779"></h5> 
<h5></h5> 
<h5 id="关联过滤查询">关联过滤查询</h5> 
<p><strong>由多模型类条件查询一模型类数据</strong>:</p> 
<p>语法如下：</p> 
<blockquote> 
 <p><strong>关联模型类名小写__属性名__条件运算符=值</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>注意：如果没有"__运算符"部分，表示等于。</strong></p> 
</blockquote> 
<p>例：</p> 
<p>查询图书，要求图书人物为"郭靖"</p> 
<pre><code class="language-python">book = BookInfo.objects.filter(peopleinfo__name='郭靖')
book
</code></pre> 
<p><img alt="" height="358" src="https://images2.imgbox.com/05/fb/k9mgDbRe_o.png" width="1029"></p> 
<p>查询图书，要求图书中人物的描述包含"八"</p> 
<pre><code class="language-python">book = BookInfo.objects.filter(peopleinfo__description__contains='八')
book</code></pre> 
<p><img alt="" height="460" src="https://images2.imgbox.com/06/22/ylSjKvkc_o.png" width="1166"></p> 
<p><strong>由一模型类条件查询多模型类数据</strong>:</p> 
<p>语法如下：</p> 
<blockquote> 
 <p><strong>一模型类关联属性名__一模型类属性名__条件运算符=值</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>注意：如果没有"__运算符"部分，表示等于。</strong></p> 
</blockquote> 
<p>例：</p> 
<p>查询书名为“天龙八部”的所有人物。</p> 
<pre><code class="language-python"># 查询书名为“天龙八部”的所有人物。
people = PeopleInfo.objects.filter(book__name='天龙八部')
people
</code></pre> 
<p><img alt="" height="303" src="https://images2.imgbox.com/7e/b3/RYJMrZ6d_o.png" width="1069"></p> 
<p>查询图书阅读量大于30的所有人物</p> 
<pre><code class="language-python"># 查询图书阅读量大于30的所有人物
people = PeopleInfo.objects.filter(book__readcount__gt=30)
people</code></pre> 
<p><img alt="" height="320" src="https://images2.imgbox.com/b3/d1/t5ehVLtf_o.png" width="1200"></p> 
<h4></h4> 
<h4>6、查询集QuerySet</h4> 
<h5 id="1-概念">1 概念</h5> 
<p>Django的ORM中存在查询集的概念。</p> 
<p>查询集，也称查询结果集、QuerySet，表示从数据库中获取的对象集合。</p> 
<p>当调用如下过滤器方法时，Django会返回查询集（而不是简单的列表）：</p> 
<blockquote> 
 <p>all()                  返回所有数据。</p> 
 <p>filter()               返回满足条件的数据。</p> 
 <p>exclude()         返回满足条件之外的数据。</p> 
 <p>order_by()        对结果进行排序。</p> 
</blockquote> 
<p>对查询集可以再次调用过滤器进行过滤，如</p> 
<pre><code class="language-python">books = BookInfo.objects.filter(readcount__gt=30).order_by('pub_date')
books</code></pre> 
<p><img alt="" height="349" src="https://images2.imgbox.com/ed/fb/CJ5v4ktZ_o.png" width="967"></p> 
<p>也就意味着查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果。</p> 
<p><strong>从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。</strong></p> 
<p><strong>判断某一个查询集中是否有数据</strong>：</p> 
<blockquote> 
 <p>exists()：判断查询集中是否有数据，如果有则返回True，没有则返回False。</p> 
</blockquote> 
<h5 id="2-两大特性">2 两大特性</h5> 
<p id="1）惰性执行"><strong>1）惰性执行</strong></p> 
<p>创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用</p> 
<p>例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集books</p> 
<pre><code class="language-python">books = BookInfo.objects.all()
</code></pre> 
<p>继续执行遍历迭代操作后，才真正的进行了数据库的查询</p> 
<pre><code class="language-python">for book in books:
    print(book.name)
</code></pre> 
<p><img alt="" height="309" src="https://images2.imgbox.com/50/f5/mDbyODE2_o.png" width="520"></p> 
<p id="2）缓存"><strong>2）缓存</strong></p> 
<p>使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。</p> 
<p><strong>情况一</strong>：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。</p> 
<pre><code class="language-python">from book.models import BookInfo

[book.id for book in BookInfo.objects.all()]

[book.id for book in BookInfo.objects.all()]

# 上面写发没有使用缓存</code></pre> 
<p><img alt="" height="75" src="https://images2.imgbox.com/9e/f7/bcgjWfwe_o.png" width="958"></p> 
<p><strong>情况二</strong>：经过存储后，可以重用查询集，第二次使用缓存中的数据。</p> 
<pre><code class="language-python"># 优化后的代码

books=BookInfo.objects.all()

[book.id for book in books]

[book.id for book in books]</code></pre> 
<h5><img alt="" height="54" src="https://images2.imgbox.com/1c/83/xYxoeuDF_o.png" width="956"></h5> 
<h5 id="3-限制查询集">3 限制查询集</h5> 
<p>可以对查询集进行取下标或切片操作，等同于sql中的limit和offset子句。</p> 
<blockquote> 
 <p>注意：不支持负数索引。</p> 
</blockquote> 
<p><strong>对查询集进行切片后返回一个新的查询集，不会立即执行查询。</strong></p> 
<p>如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发IndexError异常，[0:1].get()如果没有数据引发DoesNotExist异常。</p> 
<p>示例：获取第1、2项，运行查看。</p> 
<pre><code class="language-python"># 获取前两条数据
books = BookInfo.objects.all()[0:2]
books = BookInfo.objects.all()[:2]      # 和上面写发一样
books</code></pre> 
<p><img alt="" height="119" src="https://images2.imgbox.com/32/75/b6y5H6TS_o.png" width="639"></p> 
<h5 id="4分页">4 分页</h5> 
<div> 
 <pre><code class="language-python">#查询数据
books = BookInfo.objects.all()
#导入分页类
from django.core.paginator import Paginator
#创建分页实例
paginator=Paginator(books,2)
#获取指定页码的数据
page_skus = paginator.page(1)
#获取分页数据
total_page=paginator.num_pages</code></pre> 
</div> 
<p></p> 
<h2>视图</h2> 
<p id="1-创建虚拟环境"><strong>重点</strong></p> 
<ul><li><strong>HttpRequest</strong> 
  <ul><li>位置参数和关键字参数</li><li>查询字符串</li><li>请求体:表单数据,JSON数据</li><li>请求头</li></ul></li><li> <p><strong>HttpResponse</strong></p> 
  <ul><li> <p>HttpResponse</p> </li><li> <p>JsonResponse</p> </li><li> <p>redirect</p> </li></ul></li><li> <p><strong>类视图</strong></p> 
  <ul><li> <p>类视图的定义和使用</p> </li><li> <p>类视图装饰器(难点)</p> </li></ul></li></ul> 
<p></p> 
<h2 id="视图介绍和项目准备">一、视图介绍和项目准备</h2> 
<p> <img alt="" height="549" src="https://images2.imgbox.com/38/29/iIsv9sdZ_o.png" width="1108"> </p> 
<h5 id="视图介绍">视图介绍</h5> 
<blockquote> 
 <ul><li>视图就是<code>应用</code>中<code>views.py</code>文件中的函数</li><li>视图的第一个参数必须为<code>HttpRequest对象</code>，还可能包含下参数如 
   <ul><li>通过正则表达式组获取的位置参数</li><li>通过正则表达式组获得的关键字参数</li></ul></li><li>视图必须返回一个<code>HttpResponse对象</code>或<code>子对象</code>作为响应 
   <ul><li>子对象： <code>JsonResponse</code> <code>HttpResponseRedirect</code></li></ul></li><li>视图负责接受Web请求<code>HttpRequest</code>，进行逻辑处理，返回Web响应<code>HttpResponse</code>给请求者 
   <ul><li>响应内容可以是<code>HTML内容</code>，<code>404错误</code>，<code>重定向</code>，<code>json数据</code>...</li></ul></li><li> <p>视图处理过程如下图：</p> </li></ul> 
 <p> <img alt="" height="402" src="https://images2.imgbox.com/ff/b6/ehsrE81Q_o.png" width="869"> </p> 
</blockquote> 
<blockquote> 
 <p>使用视图时需要进行两步操作，两步操作不分先后</p> 
 <ol><li>配置<code>URLconf</code></li><li>在<code>应用/views.py</code>中定义视图</li></ol> 
</blockquote> 
<h5>项目准备</h5> 
<ul><li> <p>创建项目+创建应用+安装应用+配置模板路径+本地化+mysql数据库+URLconf+视图</p> </li><li> <p>安装应用</p> </li></ul> 
<pre><code class="language-python">INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'book.apps.BookConfig'
]</code></pre> 
<ul><li> <p>mysql数据库使用之前的book</p> <pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '127.0.0.1', # 数据库主机
        'PORT': 3306, # 数据库端口
        'USER': 'root', # 数据库用户名
        'PASSWORD': 'mysql', # 数据库用户密码
        'NAME': 'book' # 数据库名字
    }
}
</code></pre> </li></ul> 
<p> <img alt="" height="380" src="https://images2.imgbox.com/60/9e/AnMYJsq4_o.png" width="729"> </p> 
<ul><li> <p>URLconf</p> 
  <ul><li> <p><code>settings.py</code>中：指定url配置</p> <pre><code class="language-python">ROOT_URLCONF = 'bookmanager01.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]</code></pre> </li><li> <p>项目中<code>urls.py</code>：只要不是<code>admin/</code>就匹配成功，包含到应用中的<code>urls.py</code></p> <pre><code class="language-python">from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),

    path('',include('book.urls'))
]</code></pre> </li></ul></li><li> <p>应用中<code>urls.py</code>：匹配<code>testproject/</code>成功就调用<code>views</code>中的<code>testproject</code>函数，测试项目逻辑</p> <pre><code class="language-python">  from django.conf.urls import url
  import views

  urlpatterns = [
      # 匹配`testproject/`成功就调用`views`中的`testproject`函数
      url(r'^testproject/$', views.testproject),
  ]

from django.urls import path
from book.views import bookList

urlpatterns = [
    path('booklist/',bookList),
]</code></pre> </li><li> <p>视图：测试项目逻辑</p> <pre><code class="language-python">from django.http import HttpResponse

  # 测试项目逻辑
  def testproject(request):
      return HttpResponse('测试项目逻辑')

from django.shortcuts import render
from book.models import BookInfo

def bookList(request):
    # 1、到数据库中查询数据
    books = BookInfo.objects.all()
    # 2、组织数据
    context = {
        'books':books
    }
    # 3、传递给模板
    return render(request,'booklist.html',context=context)
</code></pre> </li><li> <p>在models.py 文件中定义模型类</p> </li></ul> 
<pre><code class="language-python">from django.db import models

# Create your models here.
# 准备书籍列表信息的模型类
class BookInfo(models.Model):
    # 创建字段，字段类型...
    name = models.CharField(max_length=20, verbose_name='名称')
    pub_date = models.DateField(verbose_name='发布日期',null=True)
    readcount = models.IntegerField(default=0, verbose_name='阅读量')
    commentcount = models.IntegerField(default=0, verbose_name='评论量')
    is_delete = models.BooleanField(default=False, verbose_name='逻辑删除')

    class Meta:
        db_table = 'bookinfo'  # 指明数据库表名
        verbose_name = '图书'  # 在admin站点中显示的名称

    def __str__(self):
        """定义每个数据对象的显示信息"""
        return self.name

# 准备人物列表信息的模型类
class PeopleInfo(models.Model):
    GENDER_CHOICES = (
        (0, 'male'),
        (1, 'female')
    )
    name = models.CharField(max_length=20, verbose_name='名称')
    gender = models.SmallIntegerField(choices=GENDER_CHOICES, default=0, verbose_name='性别')
    description = models.CharField(max_length=200, null=True, verbose_name='描述信息')
    book = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name='图书')  # 外键
    is_delete = models.BooleanField(default=False, verbose_name='逻辑删除')

    class Meta:
        db_table = 'peopleinfo'
        verbose_name = '人物信息'

    def __str__(self):
        return self.name
</code></pre> 
<p>1<strong>）生成迁移文件</strong></p> 
<blockquote> 
 <p><strong>python manage.py makemigrations</strong></p> 
</blockquote> 
<p><strong>2）同步到数据库中</strong></p> 
<blockquote> 
 <p><strong>python manage.py migrate</strong></p> 
</blockquote> 
<p>3<strong>）添加测试数据</strong></p> 
<pre><code class="language-sql">insert into bookinfo(name, pub_date, readcount,commentcount, is_delete) values
('射雕英雄传', '1980-5-1', 12, 34, 0),
('天龙八部', '1986-7-24', 36, 40, 0),
('笑傲江湖', '1995-12-24', 20, 80, 0),
('雪山飞狐', '1987-11-11', 58, 24, 0);
</code></pre> 
<pre><code class="language-sql">insert into peopleinfo(name, gender, book_id, description, is_delete)  values
    ('郭靖', 1, 1, '降龙十八掌', 0),
    ('黄蓉', 0, 1, '打狗棍法', 0),
    ('黄药师', 1, 1, '弹指神通', 0),
    ('欧阳锋', 1, 1, '蛤蟆功', 0),
    ('梅超风', 0, 1, '九阴白骨爪', 0),
    ('乔峰', 1, 2, '降龙十八掌', 0),
    ('段誉', 1, 2, '六脉神剑', 0),
    ('虚竹', 1, 2, '天山六阳掌', 0),
    ('王语嫣', 0, 2, '神仙姐姐', 0),
    ('令狐冲', 1, 3, '独孤九剑', 0),
    ('任盈盈', 0, 3, '弹琴', 0),
    ('岳不群', 1, 3, '华山剑法', 0),
    ('东方不败', 0, 3, '葵花宝典', 0),
    ('胡斐', 1, 4, '胡家刀法', 0),
    ('苗若兰', 0, 4, '黄衣', 0),
    ('程灵素', 0, 4, '医术', 0),
    ('袁紫衣', 0, 4, '六合拳', 0);</code></pre> 
<p></p> 
<h4></h4> 
<h4></h4> 
<h4></h4> 
<p> 注意：改变IP地址方式</p> 
<pre><code class="language-python"># ALLOWED_HOSTS  允许以那个主机的形式访问后端
# 默认是 127.0.0.1
# ALLOWED_HOSTS = [192.168.127.128]  
ALLOWED_HOSTS = []</code></pre> 
<h2 id="urlconf">二、URLconf</h2> 
<p>浏览者 通过在浏览器的地址栏中输入网址请求网站</p> 
<p>对于Dja ngo开发的网站，由哪一个视图进行处理请求，是由url匹配找到的</p> 
<h4 id="配置urlconf">配置URLconf</h4> 
<ul><li> <p><strong>1.<code>settings.py</code>中</strong></p> 
  <ul><li> <p>指定url配置</p> </li></ul></li></ul> 
<blockquote> 
 <p><strong>ROOT_URLCONF = '项目.urls'</strong></p> 
 <p><img alt="" height="257" src="https://images2.imgbox.com/d8/21/vrupL8KZ_o.png" width="629">  </p> 
</blockquote> 
<ul><li> <p><strong>2.项目中<code>urls.py</code></strong></p> 
  <ul><li> <p>匹配成功后，包含到应用的<code>urls.py</code></p> </li></ul></li></ul> 
<blockquote> 
 <p><strong><code>url(正则, include('应用.urls'))</code></strong></p> 
 <p><img alt="" height="234" src="https://images2.imgbox.com/c6/b8/kjK6pwJh_o.png" width="486"></p> 
</blockquote> 
<ul><li> <p><strong>3.应用中<code>urls.py</code></strong></p> 
  <ul><li> <p>匹配成功后，调用<code>views.py</code>对应的函数</p> </li></ul></li></ul> 
<blockquote> 
 <p><strong>url(正则, views.函数名)</strong></p> 
 <p> <img alt="" height="156" src="https://images2.imgbox.com/bc/a7/7SSq4rai_o.png" width="485"> </p> 
</blockquote> 
<ul><li> <p><strong>4.提示</strong></p> </li></ul> 
<blockquote> 
 <p>  1. 正则部分推荐使用 r，表示字符串不转义，这样在正则表达式中使用 \ 只写一个就可以</p> 
 <p></p> 
 <p>2. 不能在开始加反斜杠，推荐在结束加反斜杠<br>       正确：path/<br>       正确：path<br>       错误：/path<br>       错误：/path/</p> 
 <p></p> 
 <p>3. 请求的url被看做是一个普通的python字符串，进行匹配时不包括域名、get或post参数<br>      3.1 如请求地址如：http://127.0.0.1:8000/18/?a=10<br>      3.2 去掉域名和参数部分后，只剩下如下部分与正则匹配 18/</p> 
</blockquote> 
<p><strong>说明：</strong></p> 
<p>虽然路由结尾带/能带来上述好处，但是却违背了HTTP中URL表示资源位置路径的设计理念。</p> 
<p>是否结尾带/以所属公司定义风格为准。</p> 
<p></p> 
<h2>三、路由命名与reverse反解析（逆向）</h2> 
<h3 id="31-路由命名">1 路由命名</h3> 
<p>在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。</p> 
<p>1) 在使用include函数定义路由时，可以使用namespace参数定义路由的命名空间，如</p> 
<pre><code class="language-python">url(r'^',include('book.urls',namespace='book'))
</code></pre> 
<p>命名空间表示，凡是book.urls中定义的路由，均属于namespace指明的book名下。</p> 
<p><strong>命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。</strong></p> 
<p>2) 在定义普通路由时，可以使用name参数指明路由的名字，如</p> 
<pre><code class="language-python">urlpatterns = [
    url(r'^$',index),
    # 匹配书籍列表信息的URL,调用对应的bookList视图
    url(r'^booklist/$',bookList,name='index'),
    url(r'^testproject/$',views.testproject,name='test'),
]
</code></pre> 
<h3 id="32-reverse反解析">2 reverse反解析（通过名字找到路由）</h3> 
<p>使用reverse函数，可以根据路由名称，返回具体的路径，如：</p> 
<pre><code class="language-python">from django.core.urlresolvers import reverse
#或者
from django.urls import reverse

def testproject(request):

    return HttpResponse("OK")

# 定义视图：提供书籍列表信息
def bookList(request):

    url = reverse('book:test')
    print(url)
    return HttpResponse('index')
</code></pre> 
<blockquote> 
 <ul><li>对于未指明namespace的，reverse(路由name)</li><li>对于指明namespace的，reverse(命名空间namespace:路由name)</li></ul> 
 <p> <img alt="" height="217" src="https://images2.imgbox.com/c7/08/5x7avTNN_o.png" width="682"> </p> 
 <p> <img alt="" height="94" src="https://images2.imgbox.com/b4/2a/yQHbTBSk_o.png" width="811"> </p> 
</blockquote> 
<p></p> 
<h2 id="httprequest对象">四、HttpRequest对象</h2> 
<p>利用HTTP协议向服务器传参有几种途径？</p> 
<blockquote> 
 <ul><li>提取URL的特定部分，如/weather/beijing/2018，可以在服务器端的路由中用正则表达式截取；</li><li>查询字符串（query string)，形如key1=value1&amp;key2=value2；</li><li>请求体（body）中发送的数据，比如表单数据、json、xml；</li><li>在http报文的头（header）中。</li></ul> 
</blockquote> 
<h3 id="1-url路径参数">1 URL路径参数</h3> 
<blockquote> 
 <ul><li>如果想从URL中获取值，需要在正则表达式中使用<code>分组</code>，</li><li>获取值分为两种方式 
   <ul><li>位置参数 
     <ul><li>参数的位置不能错</li></ul></li><li>关键字参数 
     <ul><li>参数的位置可以变，跟关键字保持一致即可</li></ul></li></ul></li><li>注意：两种参数的方式不要混合使用，在一个正则表达式中只能使用一种参数方式</li><li>分别使用以上两种获取URL值的方式提取出<code>18 188</code> 
   <ul><li><code>http://127.0.0.1:8000/18/188/</code></li></ul></li></ul> 
</blockquote> 
<p><img alt="" height="779" src="https://images2.imgbox.com/6a/3f/u8wv6PNz_o.png" width="1200"></p> 
<p id="位置参数"><strong>位置参数(推荐使用)</strong></p> 
<blockquote> 
 <ul><li> <p>应用中<code>urls.py</code></p> <pre><code class="language-python">urlpatterns = [
    path('booklist/',bookList),

    url(r'^(\d+)/(\d+)/$',detail),

]</code></pre> </li><li> <p>视图中函数: 参数的位置不能错<img alt="" height="937" src="https://images2.imgbox.com/b4/98/dFwcyOsW_o.png" width="1200"></p> <pre><code class="language-python">def detail(request,value1,value2):

    context = {'v1': value1, 'v2': value2}
    print(value1,value2)

    return HttpResponse("deft")</code></pre> </li></ul> 
</blockquote> 
<p>​​​​​<strong>关键字参数</strong></p> 
<blockquote> 
 <ul><li> <p>应用中<code>urls.py</code></p> 
   <ul><li>其中<code>?P&lt;value1&gt;</code>部分表示为这个参数定义的名称为<code>value1</code></li><li> <p>可以是其它名称，起名要做到见名知意</p> </li></ul></li></ul> 
 <pre><code class="language-python">urlpatterns = [
    path('booklist/',bookList),

    # 位置参数
    # url(r'^(\d+)/(\d+)/$',detail),
    # 关键字参数
    url(r'^(?P&lt;value1&gt;\d+)/(?P&lt;value2&gt;\d+)/$',detail),</code></pre> 
 <ul><li> <p>视图中函数: 参数的位置可以变，跟关键字保持一致即可</p> </li></ul> 
 <pre><code class="language-python">def detail(request,value2,value1):

    context = {'v1': value1, 'v2': value2}
    print(context)

    return HttpResponse("deft")</code></pre> 
 <p><img alt="" height="742" src="https://images2.imgbox.com/0e/14/TvDnjJHX_o.png" width="1200"></p> 
</blockquote> 
<h3>2 Django中的QueryDict对象</h3> 
<p>HttpRequest对象的属性GET、POST都是QueryDict类型的对象</p> 
<p>与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况</p> 
<blockquote> 
 <ul><li> <p>方法get()：根据键获取值</p> <p>如果一个键同时拥有多个值将获取最后一个值</p> <p>如果键不存在则返回None值，可以设置默认值进行后续处理</p> <pre><code>get('键',默认值)
</code></pre> </li><li> <p>方法getlist()：根据键获取值，值以列表返回，可以获取指定键的所有值</p> <p>如果键不存在则返回空列表[]，可以设置默认值进行后续处理</p> <pre><code>getlist('键',默认值)
</code></pre> </li></ul> 
</blockquote> 
<p><img alt="" height="957" src="https://images2.imgbox.com/87/86/n3urp5ra_o.png" width="1200"></p> 
<h3>3. 查询字符串Query String</h3> 
<p>获取请求路径中的查询字符串参数（形如?k1=v1&amp;k2=v2），可以通过request.GET属性获取，返回QueryDict对象。</p> 
<pre><code class="language-python"># http://127.0.0.1:8000/4/100/?aaa=1111&amp;bbb=2222&amp;aaa=333

def detail(request,value2,value1):

    context = {'v1': value1, 'v2': value2}
    print(context)

    query_params = request.GET
    print(query_params)
    # &lt;QueryDict: {'aaa': ['1111'], 'bbb': ['2222']}&gt;

    aaa = query_params['aaa']
    bbb = query_params['bbb']
    print(aaa,bbb)

    alist = query_params.getlist('aaa')
    print(alist)

    return HttpResponse("deft")
</code></pre> 
<p><strong>重要：查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。</strong></p> 
<p><strong>注意：QueryDict  已普通的字典形式来获取 一键多值的时候 只能获取最后的一个</strong></p> 
<p><img alt="" height="1011" src="https://images2.imgbox.com/77/08/RSX9uZD6_o.png" width="1200"></p> 
<h3 id="4-请求体">4 请求体</h3> 
<p>请求体数据格式不固定，可以是表单类型字符串，可以是JSON字符串，可以是XML字符串，应区别对待。</p> 
<p>可以发送请求体数据的请求方式有 <strong>POST</strong>、<strong>PUT</strong>、<strong>PATCH</strong>、<strong>DELETE</strong>。</p> 
<p><img alt="" height="307" src="https://images2.imgbox.com/03/27/8gbHkAMx_o.png" width="1200"></p> 
<p><strong>Django默认开启了CSRF防护</strong>，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件，如：</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/27/58/DzxPYVhc_o.png" width="922"></p> 
<h4 id="41-表单类型-form-data">4.1 表单类型 Form Data</h4> 
<p>前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。</p> 
<pre><code class="language-python">def detail(request,value2,value1):

    
    data = request.POST
    print(data)

    alist = data.getlist('aaa')
    print(alist)

    return HttpResponse("deft")</code></pre> 
<p><img alt="" height="527" src="https://images2.imgbox.com/a4/8b/JkyopmDb_o.png" width="1200"> <img alt="" height="779" src="https://images2.imgbox.com/8f/03/2KXbbmB1_o.png" width="1200"></p> 
<h4 id="42-非表单类型-nonform-data">4.2 非表单类型 Non-Form Data</h4> 
<p>非表单类型的请求体数据，Django无法自动解析，可以通过<strong>request.body</strong>属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。<strong>request.body返回bytes类型。</strong></p> 
<p>例如要获取请求体中的如下JSON数据</p> 
<pre><code class="language-python">{"a": 1, "b": 2}
</code></pre> 
<p>可以进行如下方法操作：</p> 
<pre><code class="language-python">import json

def detail(request):

    json_str = request.body            # 元组
    print(json_str)
    json_str2 = json_str.decode()      # 转换 json形式的 字符串
    print(json_str2)
    req_data = json.loads(json_str2)   # 转换成字典
    print(req_data)
    print(req_data['aaa'])
    print(req_data['bbb'])

    return HttpResponse('OK')
</code></pre> 
<p></p> 
<h3 id="5-请求头">5 请求头</h3> 
<p>可以通过<strong>request.META</strong>属性获取请求头headers中的数据，<strong>request.META为字典类型</strong>。</p> 
<p>常见的请求头如：</p> 
<blockquote> 
 <ul><li><code>CONTENT_LENGTH</code>– The length of the request body (as a string).</li><li><code>CONTENT_TYPE</code>– The MIME type of the request body.</li><li><code>HTTP_ACCEPT</code>– Acceptable content types for the response.</li><li><code>HTTP_ACCEPT_ENCODING</code>– Acceptable encodings for the response.</li><li><code>HTTP_ACCEPT_LANGUAGE</code>– Acceptable languages for the response.</li><li><code>HTTP_HOST</code>– The HTTP Host header sent by the client.</li><li><code>HTTP_REFERER</code>– The referring page, if any.</li><li><code>HTTP_USER_AGENT</code>– The client’s user-agent string.</li><li><code>QUERY_STRING</code>– The query string, as a single (unparsed) string.</li><li><code>REMOTE_ADDR</code>– The IP address of the client.</li><li><code>REMOTE_HOST</code>– The hostname of the client.</li><li><code>REMOTE_USER</code>– The user authenticated by the Web server, if any.</li><li><code>REQUEST_METHOD</code>– A string such as<code>"GET"</code>or<code>"POST"</code>.</li><li><code>SERVER_NAME</code>– The hostname of the server.</li><li><code>SERVER_PORT</code>– The port of the server (as a string).</li></ul> 
</blockquote> 
<p>具体使用如:</p> 
<pre><code class="language-python">def get_headers(request):
    print(request.META['CONTENT_TYPE'])
    return HttpResponse('OK')
</code></pre> 
<h3 id="6-其他常用httprequest对象属性">6 其他常用HttpRequest对象属性</h3> 
<blockquote> 
 <ul><li><strong>method</strong>：一个字符串，表示请求使用的HTTP方法，常用值包括：'GET'、'POST'。</li><li><strong>user：请求的用户对象。</strong></li><li><strong>path：</strong>一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。</li><li> <p><strong>encoding</strong>：一个字符串，表示提交的数据的编码方式。</p> 
   <ul><li>如果为None则表示使用浏览器的默认设置，一般为utf-8。</li><li>这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。</li></ul></li><li> <p>FILES：一个类似于字典的对象，包含所有的上传文件。</p> </li></ul> 
</blockquote> 
<p><img alt="" height="567" src="https://images2.imgbox.com/b1/26/hVAurUGq_o.png" width="772"></p> 
<h2>五、HttpResponse对象</h2> 
<p>视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。</p> 
<h3 id="1-httpresponse">1 HttpResponse</h3> 
<p>可以使用<strong>django.http.HttpResponse</strong>来构造响应对象。</p> 
<pre><code class="language-python">HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)
</code></pre> 
<p>也可通过HttpResponse对象属性来设置响应体、响应体数据类型、状态码：</p> 
<blockquote> 
 <ul><li>content：表示返回的内容。</li><li>status_code：返回的HTTP响应状态码。</li></ul> 
</blockquote> 
<p>响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置：</p> 
<pre><code class="language-python">response = HttpResponse()
response['itcast'] = 'Python'  # 自定义响应头Itcast, 值为Python

return response
</code></pre> 
<p> <img alt="" height="837" src="https://images2.imgbox.com/d7/df/PlBBCkIM_o.png" width="1200"></p> 
<p>示例：</p> 
<pre><code class="language-python">from django.http import HttpResponse

def response(request):
    
    # return HttpResponse('hello python', status=400)
    # 或者
    data = {"hello python"}
    response = HttpResponse(content=data)
    response.status_code = 400
    return response
</code></pre> 
<p><img alt="" height="730" src="https://images2.imgbox.com/2e/0d/RZ0xD665_o.png" width="1200"></p> 
<h3 id="2-httpresponse子类">2 HttpResponse子类</h3> 
<p>Django提供了一系列HttpResponse的子类，可以快速设置状态码</p> 
<blockquote> 
 <ul><li>HttpResponseRedirect 301</li><li>HttpResponsePermanentRedirect 302</li><li>HttpResponseNotModified 304</li><li>HttpResponseBadRequest 400</li><li>HttpResponseNotFound 404</li><li>HttpResponseForbidden 403</li><li>HttpResponseNotAllowed 405</li><li>HttpResponseGone 410</li><li>HttpResponseServerError 500</li></ul> 
</blockquote> 
<h3 id="3-jsonresponse">3 JsonResponse</h3> 
<p>若要返回json数据，可以使用JsonResponse来构造响应对象，作用：</p> 
<blockquote> 
 <ul><li>帮助我们将数据转换为json字符串</li><li>设置响应头<strong>Content-Type</strong>为<strong>application/json</strong></li></ul> 
</blockquote> 
<pre><code class="language-python">from django.http import JsonResponse

def response(request):
    return JsonResponse({'city': 'beijing', 'subject': 'python'})
</code></pre> 
<p><img alt="" height="585" src="https://images2.imgbox.com/cf/7e/t84u43RJ_o.png" width="1200"></p> 
<h3 id="4-redirect重定向">4 redirect重定向</h3> 
<pre><code class="language-python">from django.shortcuts import redirect

def response(request):
    return redirect('/booklist')
    # return redirect('http://www.baidu.com')</code></pre> 
<p><img alt="" height="754" src="https://images2.imgbox.com/8a/fc/F719hR8b_o.png" width="1200"></p> 
<h4></h4> 
<h2 id="状态保持">六、状态保持</h2> 
<blockquote> 
 <ul><li>浏览器请求服务器是无状态的。</li><li><strong>无状态</strong>：指一次用户请求时，浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。</li><li><strong>无状态原因</strong>：浏览器与服务器是使用Socket套接字进行通信的，服务器将请求结果返回给浏览器之后，会关闭当前的Socket连接，而且服务器也会在处理页面完毕之后销毁页面对象。</li><li>有时需要保持下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等</li><li>实现状态保持主要有两种方式： 
   <ul><li>在客户端存储信息使用<code>Cookie</code></li><li>在服务器端存储信息使用<code>Session</code></li></ul></li></ul> 
</blockquote> 
<p></p> 
<h3 id="cookie">1、Cookie (保存在客户端的数据)</h3> 
<p>Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。</p> 
<p>Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</p> 
<h3 id="cookie的特点">Cookie的特点</h3> 
<ul><li>Cookie以键值对的格式进行信息的存储。</li><li>Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。</li><li>当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。</li></ul> 
<h4><img alt="" height="279" src="https://images2.imgbox.com/51/70/peJMNbCa_o.png" width="1147"></h4> 
<h4 id="1-设置cookie">1）设置Cookie</h4> 
<p>可以通过<strong>HttpResponse</strong>对象中的<strong>set_cookie</strong>方法来设置cookie。</p> 
<pre><code class="language-python">HttpResponse.set_cookie(cookie名, value=cookie值, max_age=cookie有效期)
</code></pre> 
<ul><li><strong>max_age</strong>单位为秒，默认为<strong>None</strong> 。如果是临时cookie，可将max_age设置为None。</li></ul> 
<p>示例：</p> 
<pre><code class="language-python">def cookie(request):
    response = HttpResponse('ok')
    response.set_cookie('hello', 'python1')                  # 临时cookie
    response.set_cookie('hello', 'python2', max_age=3600)    # 有效期一小时
    return response

def set_cookie(request):
    # 1、先假设没有cookie信息
    cook = request.COOKIES
    print(cook)

    # 2、获取用户名
    username = request.GET.get('username')

    # 3、向服务器设置cookie信息
    response = HttpResponse('set_cookie')
    response.set_cookie('username',username)

    # 4、返回响应
    return response</code></pre> 
<p><img alt="" height="966" src="https://images2.imgbox.com/97/bf/QyyXOWIp_o.png" width="1200"> <img alt="" height="307" src="https://images2.imgbox.com/15/a6/vKkIXnro_o.png" width="1151"></p> 
<h4 id="2-读取cookie">2）读取Cookie</h4> 
<p>可以通过<strong>HttpResponse</strong>对象的<strong>COOKIES</strong>属性来读取本次请求携带的cookie值。<strong>request.COOKIES为字典类型</strong>。</p> 
<pre><code class="language-python">def cookie(request):
    cookie1 = request.COOKIES.get('username')
    print(cookie1)
    return HttpResponse('OK')
</code></pre> 
<h4><img alt="" height="992" src="https://images2.imgbox.com/1a/a9/ofV4Jz54_o.png" width="1200"></h4> 
<h4>3）删除Cookie</h4> 
<p>可以通过<strong>HttpResponse</strong>对象中的delete_cookie方法来删除。</p> 
<pre><code class="language-python">response.delete_cookie('username')</code></pre> 
<p><img alt="" height="904" src="https://images2.imgbox.com/f1/83/TjcBh46a_o.png" width="1200"></p> 
<p></p> 
<p>注意：</p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/45/c7/U8zKuIvL_o.png" width="1200"></p> 
<h2><img alt="" height="384" src="https://images2.imgbox.com/5b/80/CWSM4bMq_o.png" width="1200"></h2> 
<p><img alt="" height="360" src="https://images2.imgbox.com/d0/8e/nfosXfGP_o.png" width="1200"><img alt="" height="506" src="https://images2.imgbox.com/12/b4/CwUS2fyb_o.png" width="1200"></p> 
<p> <img alt="" height="240" src="https://images2.imgbox.com/79/54/HWCU87Ck_o.png" width="1019"></p> 
<p></p> 
<h2 id="session">2、Session（保存在服务器的数据）</h2> 
<p>Session 依赖于cookie，如果浏览器禁用了cookie，则session不能实现 </p> 
<blockquote> 
 <pre><strong>0.概念
1.流程
        第一次请求:
                ① 我们第一次请求的时候可以携带一些信息(用户名/密码) cookie中没有任何信息
                ② 当我们的服务器接收到这个请求之后,进行用户名和密码的验证,验证没有问题可以设置session信息
                ③ 在设置session信息的同时(session信息保存在服务器端).服务器会在响应头中设置一个 sessionid 的cookie信息(由服务器自己设置的,不是我们设置的)
                ④ 客户端(浏览器)在接收到响应之后,会将cookie信息保存起来(保存sessionid的信息)
        第二次及其之后的请求:
                ⑤ 第二次及其之后的请求都会携带 session id信息
                ⑥ 当服务器接收到这个请求之后,会获取到sessionid信息,然后进行验证,验证成功,则可以获取 session信息(session信息保存在服务器端)

2.效果
3.从原理(http)角度
        第一次请求:
                ① 第一次请求,在请求头中没有携带任何cookie信息
                ② 我们在设置session的时候,session会做2件事.
                        #第一件：　将数据保存在数据库中
                        #第二件：　设置一个cookie信息，这个cookie信息是以　sessionid为key  value为 xxxxx
                        cookie肯定会以响应的形式在相应头中出现
        第二次及其之后的:
                ③ 都会携带 cookie信息,特别是 sessionid</strong>
</pre> 
</blockquote> 
<h3 id="1-启用session" style="background-color:transparent;">1 启用Session</h3> 
<p><strong>Django项目默认启用Session。</strong></p> 
<p>可以在settings.py文件中查看，如图所示</p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/29/43/nFK1u8u2_o.png" width="940"></p> 
<p>如需禁用session，将上图中的session中间件注释掉即可。</p> 
<h3 id="2-存储方式" style="background-color:transparent;">2 存储方式</h3> 
<p>在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。</p> 
<h4 id="21-数据库">2.1 数据库</h4> 
<p>存储在数据库中，如下设置可以写，也可以不写，<strong>这是默认存储方式</strong>。</p> 
<pre><code class="language-python">SESSION_ENGINE='django.contrib.sessions.backends.db'
</code></pre> 
<p><img alt="" height="479" src="https://images2.imgbox.com/13/d2/OPft5So9_o.png" width="1197"></p> 
<p>如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/05/b7/PVKOvMQA_o.png" width="600"></p> 
<p>数据库中的表如图所示</p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/11/99/HFTMk9P8_o.png" width="662"></p> 
<p>表结构如下</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/7b/3a/Km04b7ry_o.png" width="932"></p> 
<p>由表结构可知，操作Session包括三个数据：键，值，过期时间。</p> 
<h4 id="22-本地缓存">2.2 本地缓存</h4> 
<p>存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。</p> 
<pre><code class="language-python">SESSION_ENGINE='django.contrib.sessions.backends.cache'
</code></pre> 
<h4 id="23-混合存储">2.3 混合存储</h4> 
<p>优先从本机内存中存取，如果没有则从数据库中存取。</p> 
<pre><code class="language-python">SESSION_ENGINE='django.contrib.sessions.backends.cached_db'
</code></pre> 
<h4 id="24-redis" style="background-color:transparent;">2.4 Redis</h4> 
<p>在redis中保存session，需要引入第三方扩展，我们可以使用<strong>django-redis</strong>来解决。</p> 
<p>1） 安装扩展</p> 
<pre><code class="language-python">pip install django-redis
</code></pre> 
<p>2）配置</p> 
<p>在settings.py文件中做如下设置</p> 
<pre><code class="language-python">CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'default'
</code></pre> 
<p id="注意"><strong>注意</strong></p> 
<p>如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下：<img alt="" height="404" src="https://images2.imgbox.com/4a/ab/WjMOxsk0_o.png" width="1200"></p> 
<p>解决方法：修改redis的配置文件，添加特定ip地址。</p> 
<p>打开redis的配置文件</p> 
<pre><code class="language-python">vim /etc/redis/redis.conf
</code></pre> 
<p>在如下配置项进行修改（如要添加10.211.55.5地址）</p> 
<p>重新启动redis服务</p> 
<pre><code class="language-python">service redis-server restart
</code></pre> 
<h3 id="3-session操作" style="background-color:transparent;">3 Session操作</h3> 
<p>通过HttpRequest对象的session属性进行会话的读写操作。</p> 
<p>1） 以键值对的格式写session。</p> 
<pre><code class="language-python">request.session['键']=值
</code></pre> 
<p>2）根据键读取值。</p> 
<pre><code class="language-python">request.session.get('键',默认值)
</code></pre> 
<p>3）清除所有session，在存储中删除值部分。</p> 
<pre><code class="language-python">request.session.clear()
</code></pre> 
<p>4）清除session数据，在存储中删除session的整条数据。</p> 
<pre><code class="language-python">request.session.flush()
</code></pre> 
<p>5）删除session中的指定键及值，在存储中只删除某个键及对应的值。</p> 
<pre><code>del request.session['键']
</code></pre> 
<p>6）设置session的有效期</p> 
<pre><code>request.session.set_expiry(value)
</code></pre> 
<ul><li>如果value是一个整数，session将在value秒没有活动后过期。</li><li>如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。</li><li>如果value为None，那么session有效期将采用系统默认值， <strong>默认为两周</strong>，可以通过在settings.py中设置<strong>SESSION_COOKIE_AGE</strong>来设置全局默认值。</li></ul> 
<pre><code class="language-python">def set_session(request):
    """
     第一次请求:
            ① 我们第一次请求的时候可以携带一些信息(用户名/密码) cookie中没有任何信息
            ② 当我们的服务器接收到这个请求之后,进行用户名和密码的验证,验证没有问题可以设置session
                信息
            ③ 在设置session信息的同时(session信息保存在服务器端).服务器会在响应头中设置一个 sessionid 的cookie信息
            ④ 客户端(浏览器)在接收到响应之后,会将cookie信息保存起来(保存 sessionid的信息)
    """
    # 1.cookie中没有任何信息
    print(request.COOKIES)

    #2.对用户名和密码进行验证
    # 假设认为 用户名和密码正确
    user_id=6666

    #3.设置session信息
    # request.session  理解为字典
    # 设置session的时候其实 session做了2件事
    #第一件：　将数据保存在数据库中
    #第二件：　设置一个　ｃｏｏｋｉｅ信息，这个ｃｏｏｋｉｅ信息是以　sessionid为key
    request.session['user_id']=user_id

    #4. 返回响应
    return HttpResponse('set_session')

def get_session(request):
    """
        第二次及其之后的请求:
            ⑤ 第二次及其之后的请求都会携带 session id信息
            ⑥ 当服务器接收到这个请求之后,会获取到sessionid信息,然后进行验证,
                验证成功,则可以获取 session信息(session信息保存在服务器端)
    """
    #1. 请求都会携带 session id信息
    print(request.COOKIES)

    #2. 会获取到sessionid信息,然后进行验证,
    # 验证成功,可以获取 session信息(

    # request.session 字典
    user_id=request.session['user_id']
    user_id=request.session.get('user_id')

    #3.返回响应
    return HttpResponse('get_session')</code></pre> 
<h2><img alt="" height="970" src="https://images2.imgbox.com/d8/69/J5xJAXWk_o.png" width="1200"></h2> 
<h2><img alt="" height="850" src="https://images2.imgbox.com/01/29/tKhfLRlv_o.png" width="1200"></h2> 
<p><img alt="" height="551" src="https://images2.imgbox.com/ae/40/N7XJ6k2d_o.png" width="1200"></p> 
<p> <strong>第二次请求：</strong><img alt="" height="942" src="https://images2.imgbox.com/55/fa/wokq1mPU_o.png" width="1200"></p> 
<blockquote> 
 <pre>问题1: 我换了浏览器,还能获取到 session信息吗?  不可以

问题2: 我不换浏览器,删除session id ,则获取不到session数据

问题3: 再去执行 set_sesison 的时候 会重新生成session id</pre> 
</blockquote> 
<h4></h4> 
<h2 style="background-color:transparent;">七、类视图与中间件 </h2> 
<h3>1、类视图</h3> 
<p>思考：一个视图，是否可以处理两种逻辑？比如get和post请求逻辑。</p> 
<p id="如何在一个视图中处理get和post请求"><strong>如何在一个视图中处理get和post请求</strong><img alt="" height="487" src="https://images2.imgbox.com/3e/f0/eCDSFf4Y_o.png" width="849"></p> 
<p id="注册视图处理get和post请求"><strong>注册视图处理get和post请求</strong></p> 
<p>以函数的方式定义的视图称为<strong>函数视图</strong>，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。</p> 
<pre><code class="language-python">"""
登陆页面
    GET 请求是获取 登陆的页面
    POST 请求是 验证登陆 (用户名和密码是否正确)
"""

# GET 请求是获取 登陆的页面
def show_login(request):
    return render(request)

#POST 请求是 验证登陆 (用户名和密码是否正确)
def veri_login(request):
    return redirect('首页')

# 我想由2个视图 变为 1个视图
def login(request):
    #我们需要区分业务逻辑
    if request.method == 'GET':
        # GET 请求是获取 登陆的页面
        return render(request)

    else:
        # POST 请求是 验证登陆 (用户名和密码是否正确)
        return redirect('首页')</code></pre> 
<p></p> 
<p id="类视图使用"><strong>类视图使用</strong></p> 
<p>在Django中也可以使用类来定义一个视图，称为<strong>类视图</strong>。</p> 
<p>使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义</p> 
<pre><code class="language-python">"""
面向对象
    类视图 是采用的面向对象的思路
    1.定义类试图
        ① 继承自 View  (from django.views import View)
        ② 不同的请求方式 有不同的业务逻辑
            类试图的方法 就直接采用 http的请求方式的名字 作为我们的函数名.例如: get ,post,put,delete
        ③  类试图的方法的第二个参数 必须是请求实例对象
            类试图的方法 必须有返回值 返回值是HttpResopnse及其子类
    2.类试图的url引导
"""

from django.views import View
class BookView(View):

    def get(self,request):
        return HttpResponse('get')

    def post(self,request):
        return HttpResponse('post')

    def put(self,request):
        return HttpResponse('put')
    
    def oooo(self,request):
        return HttpResponse('oooo')</code></pre> 
<p>类视图的好处：</p> 
<blockquote> 
 <ul><li><strong>代码可读性好</strong></li><li><strong>类视图相对于函数视图有更高的复用性</strong> ， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可</li></ul> 
</blockquote> 
<p>定义类视图需要继承自Django提供的父类<strong>View</strong>，可使用<strong><code>from django.views.generic import View</code></strong>或者<strong><code>from django.views.generic.base import View</code></strong>导入，定义方式如上所示。</p> 
<p><strong>配置路由时，使用类视图的<code>as_view()</code>方法来添加</strong>。</p> 
<pre><code class="language-python">urlpatterns = [
    # 视图函数：注册
    # url(r'^register/$', views.register, name='register'),
    # 类视图：注册
    url(r'^register/$', views.RegisterView.as_view(), name='register'),
]


from django.urls import path
from django.conf.urls import url
from book.views import bookList,detail,set_cookie,set_session,get_session,BookView

urlpatterns = [
    path('booklist/',bookList),

    # 位置参数
    # url(r'^(\d+)/(\d+)/$',detail),
    # 关键字参数
    url(r'^(?P&lt;value1&gt;\d+)/(?P&lt;value2&gt;\d+)/$',detail),

    path('set_cookie/',set_cookie),

    path('set_session/',set_session),

    path('get_session/',get_session),

    path('bookview/',BookView.as_view())

]</code></pre> 
<p></p> 
<p><strong>类视图的多继承重写dispatch</strong></p> 
<p>使用面向对象多继承的特性。</p> 
<p>先找LoginRequiredMixin，后找View</p> 
<pre><code class="language-python">"""
个人中心页面      --  必须登陆才能显示
GET 方式 展示 个人中心
POST 实现个人中心信息的修改
定义类视图
"""
from django.contrib.auth.mixins import LoginRequiredMixin

class CenterView(LoginRequiredMixin,View):

    def get(self,request):

        return HttpResponse('个人中心展示')

    def post(self,request):

        return HttpResponse('个人中心修改')</code></pre> 
<p></p> 
<p></p> 
<h3 id="中间件">2、中间件</h3> 
<p>Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。</p> 
<p>我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。</p> 
<h4 id="1-中间件的定义方法">1）中间件的定义方法</h4> 
<p>定义一个中间件工厂函数，然后返回一个可以被调用的中间件。</p> 
<p>中间件工厂函数需要接收一个可以调用的get_response对象。</p> 
<p>返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-comment"># 每次请求和响应的时候都会用到</span>

<span class="hljs-keyword">def</span> <span class="function_ hljs-title">simple_middleware</span>(<span class="hljs-params">get_response</span>):
    <span class="hljs-comment"># 此处编写的代码仅在Django第一次配置和初始化的时候执行一次。</span>

    <span class="hljs-keyword">def</span> <span class="function_ hljs-title">middleware</span>(<span class="hljs-params">request</span>):
        <span class="hljs-comment"># 此处编写的代码会在每个请求处理视图前被调用。</span>

        response = get_response(request)

        <span class="hljs-comment"># 此处编写的代码会在每个请求处理视图之后被调用。</span>

        <span class="hljs-keyword">return</span> response

    <span class="hljs-keyword">return</span> middleware
</code></pre> 
</div> 
<p>例如，<strong>在book应用中新建一个middleware.py文件</strong>，</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="function_ hljs-title">my_middleware</span>(<span class="hljs-params">get_response</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'init 被调用'</span>)
    <span class="hljs-keyword">def</span> <span class="function_ hljs-title">middleware</span>(<span class="hljs-params">request</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'before request 被调用'</span>)
        response = get_response(request)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'after response 被调用'</span>)
        <span class="hljs-keyword">return</span> response
    <span class="hljs-keyword">return</span> middleware
</code></pre> 
</div> 
<p></p> 
<p><strong>定义好中间件后，需要在settings.py 文件中添加注册中间件</strong></p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-comment"># 中间件</span>
MIDDLEWARE = [
    <span class="hljs-string">'django.middleware.security.SecurityMiddleware'</span>,
    <span class="hljs-string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,
    <span class="hljs-string">'django.middleware.common.CommonMiddleware'</span>,
    <span class="hljs-comment"># 'django.middleware.csrf.CsrfViewMiddleware',</span>
    <span class="hljs-string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,
    <span class="hljs-string">'django.contrib.messages.middleware.MessageMiddleware'</span>,
    <span class="hljs-string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,
    <span class="hljs-string">'book.middleware.my_middleware'</span>,  <span class="hljs-comment"># 添加中间件</span>
]
</code></pre> 
</div> 
<p>定义一个视图进行测试</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="function_ hljs-title">middleware</span>(<span class="hljs-params">request</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'view 视图被调用'</span>)
    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">'OK'</span>)
</code></pre> 
</div> 
<p>执行结果</p> 
<p><img alt="" height="734" src="https://images2.imgbox.com/36/47/ZXrAFz6f_o.png" width="1010"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p><strong>注意：Django运行在调试模式下，中间件init部分有可能被调用两次。</strong></p> 
<h4 id="2-多个中间件的执行顺序">2）多个中间件的执行顺序</h4> 
<ul><li>在请求视图被处理<strong>前</strong>，中间件<strong>由上至下</strong>依次执行</li><li>在请求视图被处理<strong>后</strong>，中间件<strong>由下至上</strong>依次执行</li></ul> 
<p>示例：</p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/f3/5a/TfQisqsu_o.png" width="942"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p>定义两个中间件</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="function_ hljs-title">my_middleware</span>(<span class="hljs-params">get_response</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'init 被调用'</span>)
    <span class="hljs-keyword">def</span> <span class="function_ hljs-title">middleware</span>(<span class="hljs-params">request</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'before request 被调用'</span>)
        response = get_response(request)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'after response 被调用'</span>)
        <span class="hljs-keyword">return</span> response
    <span class="hljs-keyword">return</span> middleware

<span class="hljs-keyword">def</span> <span class="function_ hljs-title">my_middleware2</span>(<span class="hljs-params">get_response</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'init2 被调用'</span>)
    <span class="hljs-keyword">def</span> <span class="function_ hljs-title">middleware</span>(<span class="hljs-params">request</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'before request 2 被调用'</span>)
        response = get_response(request)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'after response 2 被调用'</span>)
        <span class="hljs-keyword">return</span> response
    <span class="hljs-keyword">return</span> middleware
</code></pre> 
</div> 
<p>注册添加两个中间件</p> 
<div> 
 <pre><code class="hljs language-python">MIDDLEWARE = [
    <span class="hljs-string">'django.middleware.security.SecurityMiddleware'</span>,
    <span class="hljs-string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,
    <span class="hljs-string">'django.middleware.common.CommonMiddleware'</span>,
    <span class="hljs-comment"># 'django.middleware.csrf.CsrfViewMiddleware',</span>
    <span class="hljs-string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,
    <span class="hljs-string">'django.contrib.messages.middleware.MessageMiddleware'</span>,
    <span class="hljs-string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,
    <span class="hljs-string">'users.middleware.my_middleware'</span>,  <span class="hljs-comment"># 添加</span>
    <span class="hljs-string">'users.middleware.my_middleware2'</span>,  <span class="hljs-comment"># 添加</span>
]
</code></pre> 
</div> 
<p>执行结果</p> 
<p><img alt="" height="861" src="https://images2.imgbox.com/eb/d7/kMe2fTeE_o.png" width="1200"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p></p> 
<h2 style="background-color:transparent;">模板</h2> 
<p id="1-创建虚拟环境"><strong>重点</strong></p> 
<ul><li><strong>自带模板</strong> 
  <ul><li>基本使用</li><li>流程控制</li><li>过滤器</li><li>继承</li></ul></li><li> <p><strong>Jinja2模板</strong></p> 
  <ul><li>配置</li></ul></li><li> <p><strong>CSRF</strong></p> 
  <ul><li> <p>原理</p> </li><li> <p>如何防范</p> </li></ul></li></ul> 
<p> </p> 
<h2 id="django使用自带模板" style="background-color:transparent;">一、Django使用自带模板</h2> 
<h3 id="1-配置">1 配置</h3> 
<p>在工程中创建模板目录templates。</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/63/f4/fdhdCrRw_o.png" width="1127"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p>在settings.py配置文件中修改<strong>TEMPLATES</strong>配置项的DIRS值：</p> 
<div> 
 <pre><code class="hljs language-python">TEMPLATES = [
    {
        <span class="hljs-string">'BACKEND'</span>: <span class="hljs-string">'django.template.backends.django.DjangoTemplates'</span>,
        <span class="hljs-string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="hljs-string">'templates'</span>)],  <span class="hljs-comment"># 此处修改</span>
        <span class="hljs-string">'APP_DIRS'</span>: <span class="hljs-literal">True</span>,
        <span class="hljs-string">'OPTIONS'</span>: {
            <span class="hljs-string">'context_processors'</span>: [
                <span class="hljs-string">'django.template.context_processors.debug'</span>,
                <span class="hljs-string">'django.template.context_processors.request'</span>,
                <span class="hljs-string">'django.contrib.auth.context_processors.auth'</span>,
                <span class="hljs-string">'django.contrib.messages.context_processors.messages'</span>,
            ],
        },
    },
]
</code></pre> 
</div> 
<h3 id="2-定义模板" style="background-color:transparent;">2 定义模板</h3> 
<p>在templates目录中新建一个模板文件，如index.html</p> 
<div> 
 <pre><code class="hljs language-XML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
{<!-- -->{ city }}
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre> 
</div> 
<h3 id="3-模板渲染">3 模板渲染</h3> 
<p>调用模板分为两步骤：</p> 
<blockquote> 
 <ol><li> <p>找到模板 loader.get_template(模板文件在模板目录中的相对路径) -&gt; 返回模板对象</p> </li><li> <p>渲染模板 模板对象.render(context=None, request=None) -&gt; 返回渲染后的html文本字符串 context 为模板变量字典，默认值为None request 为请求对象，默认值为None</p> </li></ol> 
</blockquote> 
<p>例如，定义一个视图</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse
<span class="hljs-keyword">from</span> django.template <span class="hljs-keyword">import</span> loader


<span class="hljs-keyword">def</span> <span class="function_ hljs-title">bookList</span>(<span class="hljs-params">request</span>):
    <span class="hljs-comment"># 1.获取模板</span>
    template = loader.get_template(<span class="hljs-string">'booklist.html'</span>)
    <span class="hljs-comment"># 到数据库中查询数据</span>
    books = BookInfo.objects.<span class="hljs-built_in">all</span>()
    <span class="hljs-comment"># 2、组织数据</span>
    context = {
        <span class="hljs-string">'books'</span>:books
        }
    <span class="hljs-comment"># 3.渲染模板</span>
    <span class="hljs-keyword">return</span> HttpResponse(template.render(context))</code></pre> 
</div> 
<p><strong>Django提供了一个函数render可以简写上述代码。</strong></p> 
<p>render(request对象, 模板文件路径, 模板数据字典)</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render

<span class="hljs-comment"># 写法二</span>
<span class="hljs-keyword">def</span> <span class="function_ hljs-title">bookList</span>(<span class="hljs-params">request</span>):
    <span class="hljs-comment"># 1、到数据库中查询数据</span>
    books = BookInfo.objects.<span class="hljs-built_in">all</span>()
    <span class="hljs-comment"># 2、组织数据</span>
    context = {
        <span class="hljs-string">'books'</span>:books
    }
    <span class="hljs-comment"># 3、传递给模板</span>
    <span class="hljs-keyword">return</span> render(request,<span class="hljs-string">'booklist.html'</span>,context=context)

</code></pre> 
</div> 
<h3 id="4-模板语法">4 模板语法</h3> 
<h4 id="41-模板变量" style="background-color:transparent;">4.1 模板变量</h4> 
<p>变量名必须由字母、数字、下划线（不能以下划线开头）和点组成。</p> 
<p>语法如下： {<!-- -->{变量}}</p> 
<p>模板变量可以使python的内建类型，也可以是对象。</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="function_ hljs-title">bookList</span>(<span class="hljs-params">request</span>):
    
    context = {
        <span class="hljs-string">'city'</span>: <span class="hljs-string">'北京'</span>,
        <span class="hljs-string">'adict'</span>: {
            <span class="hljs-string">'name'</span>: <span class="hljs-string">'西游记'</span>,
            <span class="hljs-string">'author'</span>: <span class="hljs-string">'吴承恩'</span>
        },
        <span class="hljs-string">'alist'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
    }

    <span class="hljs-keyword">return</span> render(request,<span class="hljs-string">'booklist.html'</span>,context=context)

</code></pre> 
</div> 
<div> 
 <pre><code class="hljs language-XML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{<!-- -->{ city }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{<!-- -->{ adict }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{<!-- -->{ adict.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{<!-- -->{ alist }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{<!-- -->{ alist.0 }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre> 
</div> 
<h4 id="42-模板语句">4.2 模板语句</h4> 
<p><strong>1）for循环：</strong></p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/e9/d2/Du8jdftJ_o.png" width="1097"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p><strong>2）if条件：</strong></p> 
<blockquote> 
 <p></p> 
 <pre>&lt;hr&gt;
{% if age &gt; 10 %}
    大于10
{% else %}
    等于10
{% endif %}
&lt;hr&gt;</pre> 
</blockquote> 
<p> </p> 
<h4 id="过滤器" style="background-color:transparent;">过滤器<img alt="" height="660" src="https://images2.imgbox.com/12/c3/ajWuan7b_o.png" width="1156"><span title="点击并拖拽以改变尺寸">​</span></h4> 
<p>语法如下:</p> 
<blockquote> 
 <ul><li>使用管道符号|来应用过滤器，用于进行计算、转换操作，可以使用在变量、标签中。</li><li>如果过滤器需要参数，则使用冒号:传递参数。</li><li> 
   <div> 
    <pre><code class="hljs">变量|过滤器:参数
</code></pre> 
   </div> </li></ul> 
</blockquote> 
<p>列举几个如下：<img alt="" height="695" src="https://images2.imgbox.com/53/7a/Sn0d56W2_o.png" width="1200"><span title="点击并拖拽以改变尺寸">​</span></p> 
<blockquote> 
 <ul><li> <p><strong>safe</strong>，禁用转义，告诉模板这个变量是安全的，可以解释执行</p> </li><li> <p><strong>length</strong>，长度，返回字符串包含字符的个数，或列表、元组、字典的元素个数。</p> </li><li> <p><strong>default</strong>，默认值，如果变量不存在时则返回默认值。</p> </li><li> 
   <div> 
    <pre><code class="hljs">data|default:'默认值'
</code></pre> 
   </div> </li><li> <p><strong>date</strong>，日期，用于对日期类型的值进行字符串格式化，常用的格式化字符如下：</p> 
   <ul><li>Y表示年，格式为4位，y表示两位的年。</li><li>m表示月，格式为01,02,12等。</li><li>d表示日, 格式为01,02等。</li><li>j表示日，格式为1,2等。</li><li>H表示时，24进制，h表示12进制的时。</li><li>i表示分，为0-59。</li><li>s表示秒，为0-59。</li><li> 
     <div> 
      <pre><code class="hljs language-python">value|date:<span class="hljs-string">"Y年m月j日  H时i分s秒"</span></code></pre> 
     </div> </li></ul></li></ul> 
</blockquote> 
<h4></h4> 
<h4 id="模板继承" style="background-color:transparent;">模板继承</h4> 
<p><img alt="" height="844" src="https://images2.imgbox.com/9e/7e/MDJ8vChG_o.png" width="1106"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p><img alt="" height="629" src="https://images2.imgbox.com/db/1d/cKpUqHWF_o.png" width="1197"><span title="点击并拖拽以改变尺寸">​</span></p> 
<h2 id="django中使用jinja2模板">二、Django使用jinja2模板</h2> 
<h4 id="jinja2介绍">jinja2介绍</h4> 
<blockquote> 
 <p>Jinja2：是 Python 下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于 Django 的模板引擎，并扩展了其语法和一系列强大的功能，尤其是Flask框架内置的模板语言</p> 
</blockquote> 
<p>由于django默认模板引擎功能不齐全,速度慢，所以我们也可以在Django中使用jinja2, jinja2宣称比django默认模板引擎快10-20倍。</p> 
<p>Django主流的第三方APP基本上也都同时支持Django默认模板及jinja2，所以要用jinja2也不会有多少障碍。</p> 
<h4 id="1安装jinja2模块">安装jinja2模块</h4> 
<div> 
 <pre><code class="hljs language-XML">pip install jinja2
</code></pre> 
</div> 
<h4 id="2django配置jinja2">Django配置jinja2</h4> 
<ol><li>在项目文件中创建 jinja2_env.py 文件</li></ol> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">from</span> jinja2 <span class="hljs-keyword">import</span> Environment

<span class="hljs-keyword">def</span> <span class="function_ hljs-title">environment</span>(<span class="hljs-params">**options</span>):
    env = Environment(**options)

    <span class="hljs-keyword">return</span> env
</code></pre> 
</div> 
<p>2.在settings.py文件</p> 
<div> 
 <pre><code class="hljs language-python">TEMPLATES = [
    {
        <span class="hljs-string">'BACKEND'</span>: <span class="hljs-string">'django.template.backends.jinja2.Jinja2'</span>,<span class="hljs-comment">#修改1</span>
        <span class="hljs-string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="hljs-string">'templates'</span>)],
        <span class="hljs-string">'APP_DIRS'</span>:<span class="hljs-literal">True</span>,
        <span class="hljs-string">'OPTIONS'</span>:{
            <span class="hljs-string">'environment'</span>: <span class="hljs-string">'jinja2_env.environment'</span>,<span class="hljs-comment"># 修改2</span>
            <span class="hljs-string">'context_processors'</span>:[
                <span class="hljs-string">'django.template.context_processors.debug'</span>,
                <span class="hljs-string">'django.template.context_processors.request'</span>,
                <span class="hljs-string">'django.contrib.auth.context_processors.auth'</span>,
                <span class="hljs-string">'django.contrib.messages.context_processors.messages'</span>,
            ],
        },
    },
]
</code></pre> 
</div> 
<h4 id="3jinja2模板的使用绝大多数和django自带模板一样">jinja2模板的使用绝大多数和Django自带模板一样</h4> 
<p><img alt="" height="607" src="https://images2.imgbox.com/b1/fc/7YxZpqCc_o.png" width="1200"><span title="点击并拖拽以改变尺寸">​</span></p> 
<h4></h4> 
<h4 id="4jinja2自定义过滤器" style="background-color:transparent;">jinja2自定义过滤器</h4> 
<p id="在jinja2envpy文件中自定义过滤器">在jinja2_env.py文件中自定义过滤器</p> 
<div> 
 <pre><code class="hljs language-python"><span class="hljs-keyword">from</span> jinja2 <span class="hljs-keyword">import</span> Environment

<span class="hljs-keyword">def</span> <span class="function_ hljs-title">environment</span>(<span class="hljs-params">**options</span>):
    env = Environment(**options)

    <span class="hljs-comment"># 2.将自定义的过滤器添加到 环境中</span>
    env.filters[<span class="hljs-string">'do_listreverse'</span>] = do_listreverse

    <span class="hljs-keyword">return</span> env

<span class="hljs-comment"># 1.自定义过滤器</span>
<span class="hljs-keyword">def</span> <span class="function_ hljs-title">do_listreverse</span>(<span class="hljs-params">li</span>):
    <span class="hljs-keyword">if</span> li == <span class="hljs-string">"B"</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"哈哈"</span></code></pre> 
</div> 
<p> </p> 
<h2 id="csrf" style="background-color:transparent;">三、CSRF攻击</h2> 
<blockquote> 
 <ul><li><code>CSRF </code>拼为 <code>Cross Site Request Forgery</code>，译为 跨站请求伪造。</li><li><code>CSRF</code>指攻击者盗用了你的身份，以你的名义发送恶意请求。 
   <ul><li>包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......</li></ul></li><li>造成的问题：个人隐私泄露以及财产安全。</li></ul> 
</blockquote> 
<h4 id="csrf攻击示意图">CSRF攻击示意图</h4> 
<ul><li>客户端访问服务器时没有同服务器做安全验证</li></ul> 
<h4 id="防止-csrf-攻击">防止 CSRF 攻击</h4> 
<h6 id="步骤">步骤</h6> 
<ol><li>在客户端向后端请求界面数据的时候，后端会往响应中的 cookie 中设置 csrf_token 的值</li><li>在 Form 表单中添加一个隐藏的的字段，值也是 csrf_token</li><li>在用户点击提交的时候，会带上这两个值向后台发起请求</li><li>后端接受到请求，以会以下几件事件： 
  <ul><li>从 cookie中取出 csrf_token</li><li>从 表单数据中取出来隐藏的 csrf_token 的值</li><li>进行对比</li></ul></li><li>如果比较之后两值一样，那么代表是正常的请求，如果没取到或者比较不一样，代表不是正常的请求，不执行下一步操作</li></ol> 
<h4 id="代码演示">代码演示</h4> 
<h6 id="未进行-csrf-校验的-weba">未进行 csrf 校验的 WebA</h6> 
<ul><li>后端代码实现</li></ul> 
<div> 
 <pre><code class="hljs">#定义路由
from django.conf.urls  import url
from pay import views
urlpatterns = [
    url(r'^$',views.LoginView.as_view(),name='index'),   #登录路由 
    url(r'^transfer/$',views.TransferView.as_view(),name='transfer'), #转账路由
]

#定义视图
class LoginView(View):

    def post(self,request):

        # 取到表单中提交上来的参数
        username = request.POST.get("username")
        password = request.POST.get("password")

        if not all([username, password]):
            print('参数错误')
        else:
            print(username, password)
            if username == 'laowang' and password == '1234':
                # 状态保持，设置用户名到cookie中表示登录成功
                response = redirect(reverse('transfer'))
                response.set_cookie('username', username)
                return response
            else:
                print('密码错误')
        return render(request,'login.html')
    def get(self,request):
        return render(request,'login.html')

class TransferView(View):


    def post(self,request):
        # 从cookie中取到用户名
        username = request.COOKIES.get('username', None)
        # 如果没有取到，代表没有登录
        if not username:
            return redirect(reverse('index'))


        to_account = request.POST.get("to_account")
        money = request.POST.get("money")

        print('假装执行转操作，将当前登录用户的钱转账到指定账户')
        return HttpResponse('转账 %s 元到 %s 成功' % (money, to_account))

    def get(self, request):
        # 渲染转换页面
        response = render(request, 'transfer.html')

        return response
</code></pre> 
</div> 
<ul><li>前端登录页面代码</li></ul> 
<div> 
 <pre><code class="hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;登录&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;我是网站A，登录页面&lt;/h1&gt;

&lt;form method="post"&gt;
    &lt;label&gt;用户名：&lt;/label&gt;&lt;input type="text" name="username" placeholder="请输入用户名"&gt;&lt;br/&gt;
    &lt;label&gt;密码：&lt;/label&gt;&lt;input type="password" name="password" placeholder="请输入密码"&gt;&lt;br/&gt;
    &lt;input type="submit" value="登录"&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<ul><li>前端转账页面代码</li></ul> 
<div> 
 <pre><code class="hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;转账&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;我是网站A，转账页面&lt;/h1&gt;

&lt;form method="post"&gt;
    &lt;label&gt;账户：&lt;/label&gt;&lt;input type="text" name="to_account" placeholder="请输入要转账的账户"&gt;&lt;br/&gt;
    &lt;label&gt;金额：&lt;/label&gt;&lt;input type="number" name="money" placeholder="请输入转账金额"&gt;&lt;br/&gt;
    &lt;input type="submit" value="转账"&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<blockquote> 
 <p>运行测试，如果在未登录的情况下，不能直接进入转账页面，测试转账是成功的</p> 
</blockquote> 
<h6 id="攻击网站b的代码">攻击网站B的代码</h6> 
<ul><li>后端代码实现</li></ul> 
<div> 
 <pre><code class="hljs">#定义路由
from django.conf.urls import url
from ads import views

urlpatterns = [
    url(r'^$',views.AdsView.as_view()),
]

#定义视图
class AdsView(View):

    def get(self,request):

        return render(request,'index.html')
</code></pre> 
</div> 
<ul><li>前端代码实现</li></ul> 
<div> 
 <pre><code class="hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;我是网站B&lt;/h1&gt;

&lt;form method="post" action="http://127.0.0.1:9000/transfer/"&gt;
    &lt;input type="hidden" name="to_account" value="黑客"&gt;
    &lt;input type="hidden" name="money" value="190000" hidden&gt;
    &lt;input type="submit" value="点击领取优惠券"&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<blockquote> 
 <p>运行测试，在用户登录网站A的情况下，点击网站B的按钮，可以实现伪造访问</p> 
</blockquote> 
<h4 id="在网站a中实现-csrftoken-校验的流程">在网站A中实现 csrf_token 校验的流程</h4> 
<ul><li>导入生成 csrf_token 的函数</li></ul> 
<div> 
 <pre><code class="hljs"> from django.middleware.csrf import get_token
 csrf_token = get_token(request)
</code></pre> 
</div> 
<ul><li> <p>在渲染转账页面的，做以下几件事情：</p> 
  <ol><li>生成 csrf_token 的值</li><li>在返回转账页面的响应里面设置 csrf_token 到 cookie 中</li><li>将 csrf_token 保存到表单的隐藏字段中</li></ol> 
  <div> 
   <pre><code class="hljs"> def get(self, request):
        # 生成csrf_token
        from django.middleware.csrf import get_token
        csrf_token = get_token(request)

        # 渲染转换页面，传入 csrf_token 到模板中
        response = render(request, 'transfer.html',context={'csrf_token':csrf_token})

        # 设置csrf_token到cookie中，用于提交校验
        response.set_cookie('csrf_token', csrf_token)

        return response
</code></pre> 
  </div> </li><li> <p>在转账模板表单中添加 csrf_token 隐藏字段</p> </li></ul> 
<div> 
 <pre><code class="hljs">&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;转账&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;我是网站A，转账页面&lt;/h1&gt;

&lt;form method="post"&gt;
    &lt;input type="hidden" name="csrftoken" value="{<!-- -->{ csrf_token }}"&gt;
    &lt;label&gt;账户：&lt;/label&gt;&lt;input type="text" name="to_account" placeholder="请输入对方账户"&gt;&lt;br/&gt;
    &lt;label&gt;金额：&lt;/label&gt;&lt;input type="number" name="money" placeholder="请输入转账金额"&gt;&lt;br/&gt;
    &lt;input type="submit" value="转账"&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<p>运行测试，进入到转账页面之后，查看 cookie 和 html 源代码</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7b/dd/KE71LaRA_o.png" width="1200"></p> 
<ul><li>在执行转账逻辑之前进行 csrf_token 的校验</li></ul> 
<div> 
 <pre><code class="hljs"> # 取出表单中的 csrf_token
 form_csrf_token = request.POST.get("csrftoken")
 # 取出 cookie 中的 csrf_token
 cookie_csrf_token = request.COOKIES.get('csrf_token')
 # 进行对比
 if cookie_csrf_token != form_csrf_token:
     return HttpResponse('token校验失败，可能是非法操作')
</code></pre> 
</div> 
<p>运行测试，用户直接在网站 A 操作没有问题，再去网站B进行操作，发现转账不成功，因为网站 B 获取不到表单中的 csrf_token 的隐藏字段，而且浏览器有<strong>同源策略</strong>，网站B是获取不到网站A的 cookie 的，所以就解决了<strong>跨站请求伪造</strong>的问题</p> 
<h3 id="在-flask-项目中解决-csrf-攻击">在 Django项目中解决 CSRF 攻击</h3> 
<p>Django默认是开启CSRF的<img alt="" height="222" src="https://images2.imgbox.com/84/4c/AtYbe4ba_o.png" width="760"></p> 
<p>模板中设置 CSRF 令牌</p> 
<div> 
 <pre><code class="hljs">{% csrf_token %}
或者
&lt;input type="hidden" value="{<!-- -->{ csrf_token }}"&gt;</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b66d955a64ca9e06570b895af43087fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Git的原理与使用(一):Git的基本操作(包含:版本回退)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07b2df7c390d967137111dd18c76145c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java - Stream Filter 多条件筛选过滤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>