<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java设计模式（七）适配器模式（Adapter Pattern） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/51e27044d48383479e79fe9e76334c42/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="java设计模式（七）适配器模式（Adapter Pattern）">
  <meta property="og:description" content="1、模式介绍： 适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换成客户希望的另外一个接口。适配器模式通常用于需要复用现有的类，但是接口与客户端的要求不完全匹配的情况。它包括两种形式：类适配器模式和对象适配器模式。
2、应用场景： 系统需要使用现有的类，而这些类的接口不符合需求。
不想修改现有的接口，而又需要复用该接口的情况。
多个类似功能的接口需要统一。
3、优点： 增加了类的透明性和复用性：将具体的实现封装在适配器中，对客户端来说是透明的，同时提高了被适配类的复用性。
灵活性好：通过适配器，可以在不改变原有代码的基础上增加新的适配器类，符合开闭原则。
4、缺点： 过多使用适配器，会让系统非常零乱。
增加系统的复杂性：因为增加了额外的适配器，可能会增加系统的理解难度
5、代码实现： /** * 适配接口 * * @author FM_南风 * @date 2024/6/27 13:53 */ public interface MediaPlayer { void play(String mediaType, String fileName); } /** * 被适配者 * * @author FM_南风 * @date 2024/6/27 13:54 */ public class AudioPlayer implements MediaPlayer{ @Override public void play(String mediaType, String fileName) { if (mediaType.equalsIgnoreCase(&#34;mp3&#34;)) { System.out.println(&#34;播放MP3文件: &#34; &#43; fileName); } else { System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-27T14:09:51+08:00">
    <meta property="article:modified_time" content="2024-06-27T14:09:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java设计模式（七）适配器模式（Adapter Pattern）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、模式介绍：</h3> 
<p>        适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类的接口转换成客户希望的另外一个接口。适配器模式通常用于需要复用现有的类，但是接口与客户端的要求不完全匹配的情况。它包括两种形式：类适配器模式和对象适配器模式。</p> 
<h3>2、应用场景：</h3> 
<p>         系统需要使用现有的类，而这些类的接口不符合需求。<br>         不想修改现有的接口，而又需要复用该接口的情况。<br>         多个类似功能的接口需要统一。</p> 
<h3>3、优点：</h3> 
<p><strong>        增加了类的透明性和复用性</strong>：将具体的实现封装在适配器中，对客户端来说是透明的，同时提高了被适配类的复用性。<br><strong>        灵活性好</strong>：通过适配器，可以在不改变原有代码的基础上增加新的适配器类，符合开闭原则。</p> 
<h3>4、缺点：</h3> 
<p><strong>        过多使用适配器，会让系统非常零乱。<br>         增加系统的复杂性</strong>：因为增加了额外的适配器，可能会增加系统的理解难度</p> 
<h3>5、代码实现：</h3> 
<pre><code class="language-java">/**
 * 适配接口
 *
 * @author FM_南风
 * @date 2024/6/27 13:53
 */
public interface MediaPlayer {
    void play(String mediaType, String fileName);
}

/**
 * 被适配者
 *
 * @author FM_南风
 * @date 2024/6/27 13:54
 */
public class AudioPlayer implements MediaPlayer{
    @Override
    public void play(String mediaType, String fileName) {
        if (mediaType.equalsIgnoreCase("mp3")) {
            System.out.println("播放MP3文件: " + fileName);
        } else {
            System.out.println("使用" + mediaType + "媒体播放");
        }
    }
}

/**
 * 新适配接口
 *
 * @author FM_南风
 * @date 2024/6/27 13:55
 */
public interface AdvancedMediaPlayer {
    void playVlc(String fileName);
    void playMp4(String fileName);
}

/**
 * Mp4播放器实现新的接口
 *
 * @author FM_南风
 * @date 2024/6/27 13:56
 */
public class Mp4Player implements AdvancedMediaPlayer{
    @Override
    public void playVlc(String fileName) {

    }

    @Override
    public void playMp4(String fileName) {
        System.out.println("播放MP4文件: " + fileName);
    }
}

/**
 * Vlc播放器实现新的接口
 *
 * @author FM_南风
 * @date 2024/6/27 13:56
 */
public class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("播放Vlc文件: " + fileName);
    }

    @Override
    public void playMp4(String fileName) {

    }
}

/**
 * 适配器类，实现目标接口并持有被适配者的引用
 *
 * @author FM_南风
 * @date 2024/6/27 13:57
 */
public class MediaAdapter implements MediaPlayer{

    AdvancedMediaPlayer advancedMusicPlayer;

    public MediaAdapter(String mediaType) {
        if (mediaType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer = new VlcPlayer();
        } else if (mediaType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer = new Mp4Player();
        }
    }

    @Override
    public void play(String mediaType, String fileName) {
        if (mediaType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer.playVlc(fileName);
        } else if (mediaType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}


/**
 * 应用
 *
 * @author FM_南风
 * @date 2024/6/27 13:58
 */
public class AdapterClient {

    public static void main(String[] args) {
        MediaPlayer audioPlayer = new AudioPlayer();

        audioPlayer.play("mp3", "音乐.mp3");
        audioPlayer.play("mp4", "视频.mp4");
        audioPlayer.play("vlc", "视频.vlc");
        audioPlayer.play("avi", "视频.avi"); // Unsupported media type
    }
}
</code></pre> 
<h3>6、结果展示：<br><img alt="" height="654" src="https://images2.imgbox.com/db/22/QTu27p3F_o.png" width="1200"></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd8d3e76bf8f8efc48db65dc22d79e11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何将 iPhone Mirroring (镜像) 到 Mac 电脑 - iOS 18 新功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02bfaece03d198fed064e2dc9fee3827/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络课程实训：局域网方案设计与实现（基于ensp）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>