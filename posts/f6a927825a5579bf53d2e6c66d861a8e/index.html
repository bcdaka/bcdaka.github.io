<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【一步一步了解Java系列】：对这个系列的总结以及对缺漏内部类知识的补充 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f6a927825a5579bf53d2e6c66d861a8e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【一步一步了解Java系列】：对这个系列的总结以及对缺漏内部类知识的补充">
  <meta property="og:description" content="看到这句话的时候证明：此刻你我都在努力
加油陌生人
br /&gt;个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
一路来的文章 第一篇文章： 记得这个系列是我今年4月29日开始写的，写的是我初始Java的总结，第一篇便是写了Java基本类型与C语言的区别，至于为什么我一开始就跟C语言对标呢？原因有两个：
我那时刚学完C语言，对C语言记忆尤为深刻。我初始Java的基本数据类型时我就发现Java有C语言没有的基本类型如：byte，而且char在Java中占2个字节。 不知不觉已经过去了两个月了，这个系列也差不多结束了，之后会是Java实现的数据结构的系列了，在之后就是更高级的Java系列。现在这个系列差一个图书馆系统的博客没有写，不过应该也快写了。
第二篇文章： 这篇文章没想到就是我这个系列里面阅读量最高的一篇，这是万万没想到的。这篇是对基本数据类型的转换得总结。关于什么int转换成double什么什么得，还有Java中得float的类型还得必须加上一个F或f等等。主要就是自动类型转换，强制类型转换，类型提升，以及字符串得转换成int，double等。
第三篇文章： 这篇文章还是不知不觉与C语言进行了对比，讲的是各式各样的得运算符，像简单的算术运算符，赋值和&#43;&#43;，逻辑运算符，位运算符，移位运算符等，
记得那时讲解取模时第一次遇到了异常，这可是与C语言大不相同的一个知识点，那时不懂还没学到异常，就简单说是报错哈哈哈。还有就是Java中的double是支持取模运算的，也是和C语言的一个不同呢。
第四、五篇文章 第四篇的阅读量就比较凄惨了，里面的内容也比较简单，简单的逻辑结构，记得逻辑结构我在C语言得文章里是没有写过得，那时就觉得太简单了，但到Java想想还是写一下吧，然后就有了这第四篇文章。里面讲了简单得顺序结构，选择结构，循环结构以及switch语句等等，都是非常简单的结构了。
最深刻的还是，Java中不能用数字代表真假，if里的括号只能用true来表示真，false代表假，这也是和C语言的一个不同吧。
然后第五篇：
也算是回到正常的播放量了吧，这篇主要也是和C语言进行对比，因为这是真的和C语言的不同了，在C语言中函数就是Java中的方法，叫法完全不一样了，但性质差不多，只不过Java面向对象的语言，多了一些限定修饰符。
这篇文章主要讲了方法的意义和形参实参，方法的递归，然后就是新概念方法重载，其实到后面还有一个方法·重写，但是那时没有学到类与对象，所以就没在这篇文章里讲。
第六篇文章： 这篇文章是第一次接触引用这个概念，引用是个新概念，Java中没有指针的学习，但是有引用。
数组就是一个引用类型，记得那时我以为能直接用System.out.println直接打印出来呢，没想到的是直接打印出来的是一个地址，哈哈哈。
还有在Java中数组中让我真正跟感觉到Java的简便，只需点length就可以得到数组的长度，换到C语言就是还得使用sizeof慢慢求呢。这里还学到了现成包Arrays，使用其toString就可以将数组转含为字符串就可以直接printf直接将里面的数组给打印出来了。
第七、八篇文章 第七篇文章就是真正与C语言不同的部分了，这时我学到了类与对象，说实话那时类给我的感觉就是一个C语言的结构体，他们的用法也是用“.”操作符来进行的。这篇文章主要讲述了类和对象的关系，类经过实例化后就是一个对象。然后就是一系列的有关类的知识如：构造方法，this关键字。
那时知识初始类与对象，对对象的概念还不是很清楚，但在后面的学习中对对象的理解也是会越来越深的。
然后到第八篇文章的话：
既然学的是类的话，那肯定就要讲到继承了，就有了父类和子类了，这时就要牵扯到super关键字了。然后还有代码块的初始化顺序，现在印象还是很深刻呢。父类静态代码块----&gt;子类的静态代码块----&gt;父类的实例代码块----&gt;父类的构造方法----&gt;子类的实例代码块----&gt;子类的构造方法。
第九篇文章 第九篇文章写的是关于多态，但是这时是没有讲接口和抽象类的，所以之讲了子类的多态，这时我们就讲到函数重写了，重写之后是向上转型和向下转型。
第十、十一篇文章 然后在第十篇终于迎来了，抽象类和接口得学习，不得不说抽象类和接口真的很像，两个都是为了简便代码而存在的，这篇里详细讲解了抽象类与接口的相关知识，包括抽象类不能被final，private修饰，以及不能被new直接实例化，然后就是接口，感觉与抽象类最大的不同就是它不能有构造方法，且它里面的数据和方法都是默认有一些限定修饰符修饰的。
然后这是最后一篇异常类，然后异常类就只需要知道都是Exception类的子类或者是RuntimeException的子类都是异常类，我们还可以通过继承异常类类自定义异常类，然后就是里面的相关关键字try-catch之类的。finally，总之异常类啊还是挺简单的。
补充内部类内容 静态内部类 public class Test { static class Test1{ String name; int a=10; public void setA(int a) { this.a = a; System.out.println(a); } } } class Test2{ public static void main(String[] args) { Test.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-01T15:39:30+08:00">
    <meta property="article:modified_time" content="2024-07-01T15:39:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【一步一步了解Java系列】：对这个系列的总结以及对缺漏内部类知识的补充</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>看到这句话的时候证明：此刻你我都在努力</strong><br> <strong>加油陌生人</strong><br> <img src="https://images2.imgbox.com/ea/54/NECp10zS_o.png" alt="微信图片编辑_20240229212205.png"><br> br /&gt;<strong>个人主页：</strong><a href="https://blog.csdn.net/2302_81249757?type=lately"><strong>Gu Gu Study</strong></a><strong><br><strong>专栏：</strong><a href="https://blog.csdn.net/2302_81249757/category_12656486.html?spm=1001.2014.3001.5482"><strong>一步一步了解Java</strong></a><br><br> 喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹</strong><br> <br><strong>喜欢的话可以点个赞谢谢了。</strong><br> <strong>作者：小闭</strong></p> 
<hr> 
<h2><a id="_11"></a>一路来的文章</h2> 
<h4><a id="imagepnghttpsimgblogcsdnimgcnimg_convert4085675750595c873cdd97ef32a483d8png_12"></a>第一篇文章：<img src="https://images2.imgbox.com/f0/e1/CpAuD1gg_o.png" alt="image.png"></h4> 
<p>记得这个系列是我今年<strong>4月29日</strong>开始写的，写的是我初始Java的总结，第一篇便是写了Java基本类型与C语言的区别，至于为什么我一开始就跟C语言对标呢？原因有两个：</p> 
<ol><li>我那时刚学完C语言，对C语言记忆尤为深刻。</li><li>我初始Java的基本数据类型时我就发现<strong>Java有C语言没有的基本类型如：byte，而且char在Java中占2个字节。</strong><img src="https://images2.imgbox.com/d9/20/OW56KlJG_o.png" alt="image.png"></li></ol> 
<p>不知不觉已经过去了两个月了，这个系列也差不多结束了，之后会是J<strong>ava实现的数据结构的系列</strong>了，在之后就是<strong>更高级的Java系列</strong>。现在这个系列差一个图书馆系统的博客没有写，不过应该也快写了。</p> 
<hr> 
<h4><a id="_22"></a>第二篇文章：</h4> 
<h4><a id="imagepnghttpsimgblogcsdnimgcnimg_convert54dc597872e2250b192ed0ecd522985cpng_23"></a><img src="https://images2.imgbox.com/90/7c/xQK4BADt_o.png" alt="image.png"></h4> 
<p>这篇文章没想到就是我这个系列里面阅读量最高的一篇，这是万万没想到的。这篇是对基本数据类型的转换得总结。关于什么int转换成double什么什么得，还有Java中得float的类型还得必须加上一个F或f等等。主要就是自动类型转换，强制类型转换，类型提升，以及字符串得转换成int，double等。<img src="https://images2.imgbox.com/41/1f/dAy7aRD3_o.png" alt="image.png"></p> 
<hr> 
<h4><a id="_28"></a>第三篇文章：</h4> 
<p><img src="https://images2.imgbox.com/64/09/5x6rf29A_o.png" alt="image.png"><br> 这篇文章还是不知不觉与C语言进行了对比，讲的是各式各样的得运算符，像简单的算术运算符，赋值和++，逻辑运算符，位运算符，移位运算符等，<img src="https://images2.imgbox.com/86/de/TAEWyCRy_o.png" alt="image.png"><br> 记得那时讲解取模时第一次遇到了异常，这可是与C语言大不相同的一个知识点，那时不懂还没学到异常，就简单说是报错哈哈哈。还有就是Java中的double是支持取模运算的，也是和C语言的一个不同呢。<img src="https://images2.imgbox.com/7f/e5/nDZzwBiJ_o.png" alt="image.png"></p> 
<hr> 
<h4><a id="_35"></a>第四、五篇文章</h4> 
<p><img src="https://images2.imgbox.com/15/1f/hVzsbffA_o.png" alt="image.png"><br> 第四篇的阅读量就比较凄惨了，里面的内容也比较简单，简单的逻辑结构，记得逻辑结构我在C语言得文章里是没有写过得，那时就觉得太简单了，但到Java想想还是写一下吧，然后就有了这第四篇文章。里面讲了简单得顺序结构，选择结构，循环结构以及switch语句等等，都是非常简单的结构了。<img src="https://images2.imgbox.com/8f/71/eHggohN7_o.png" alt="image.png"><br> 最深刻的还是，Java中不能用数字代表真假，if里的括号只能用true来表示真，false代表假，这也是和C语言的一个不同吧。<br> 然后第五篇：<img src="https://images2.imgbox.com/03/07/oRqbFphO_o.png" alt="image.png"><br> 也算是回到正常的播放量了吧，这篇主要也是和C语言进行对比，因为这是真的和C语言的不同了，在C语言中函数就是Java中的方法，叫法完全不一样了，但性质差不多，只不过Java面向对象的语言，多了一些限定修饰符。<br> 这篇文章主要讲了方法的意义和形参实参，方法的递归，然后就是新概念方法重载，其实到后面还有一个方法·重写，但是那时没有学到类与对象，所以就没在这篇文章里讲。<img src="https://images2.imgbox.com/5e/9b/R0IDro17_o.png" alt="image.png"></p> 
<hr> 
<h4><a id="_45"></a>第六篇文章：</h4> 
<p><img src="https://images2.imgbox.com/32/1b/wAXtm4Sv_o.png" alt="image.png"><br> 这篇文章是第一次接触<strong>引用</strong>这个概念，引用是个新概念，Java中没有指针的学习，但是有引用。<br> 数组就是一个引用类型，记得那时我以为能直接用System.out.println直接打印出来呢，没想到的是直接打印出来的是一个地址，哈哈哈。<img src="https://images2.imgbox.com/1d/6c/KG7ArNBW_o.png" alt="image.png"><br> 还有在Java中数组中让我真正跟感觉到Java的简便，只需点length就可以得到数组的长度，换到C语言就是还得使用sizeof慢慢求呢。这里还学到了现成包Arrays，使用其toString就可以将数组转含为字符串就可以直接printf直接将里面的数组给打印出来了。</p> 
<hr> 
<h4><a id="_53"></a>第七、八篇文章</h4> 
<p><img src="https://images2.imgbox.com/9b/48/uOKQHqDZ_o.png" alt="image.png"><br> 第七篇文章就是真正与C语言不同的部分了，这时我学到了类与对象，说实话那时类给我的感觉就是一个C语言的结构体，他们的用法也是用“.”操作符来进行的。这篇文章主要讲述了类和对象的关系，类经过实例化后就是一个对象。然后就是一系列的有关类的知识如：构造方法，this关键字。<img src="https://images2.imgbox.com/c4/77/2YC0WaLY_o.png" alt="image.png"><br> 那时知识初始类与对象，对对象的概念还不是很清楚，但在后面的学习中对对象的理解也是会越来越深的。<br> <strong>然后到第八篇文章的话：</strong><br> <img src="https://images2.imgbox.com/9e/22/SzP8G3HX_o.png" alt="image.png"><br> 既然学的是类的话，那肯定就要讲到继承了，就有了父类和子类了，这时就要牵扯到super关键字了。然后还有代码块的初始化顺序，现在印象还是很深刻呢。<strong>父类静态代码块----&gt;子类的静态代码块----&gt;父类的实例代码块----&gt;父类的构造方法----&gt;子类的实例代码块----&gt;子类的构造方法。</strong></p> 
<hr> 
<h4><a id="_63"></a>第九篇文章</h4> 
<h4><a id="imagepnghttpsimgblogcsdnimgcnimg_convertc9882a58851708892bf67a40f613f973png_66"></a><img src="https://images2.imgbox.com/a8/17/XWUEz908_o.png" alt="image.png"></h4> 
<p>第九篇文章写的是关于多态，但是这时是没有讲接口和抽象类的，所以之讲了子类的多态，这时我们就讲到函数重写了，重写之后是向上转型和向下转型。</p> 
<h4><a id="imagepnghttpsimgblogcsdnimgcnimg_convert47917c684f3087154366cd5d9c955784png_68"></a><img src="https://images2.imgbox.com/c8/c9/vLM0VBKI_o.png" alt="image.png"></h4> 
<h4><a id="_69"></a>第十、十一篇文章</h4> 
<p><img src="https://images2.imgbox.com/2d/6f/ewA1JOQk_o.png" alt="image.png"><br> 然后在第十篇终于迎来了，抽象类和接口得学习，不得不说抽象类和接口真的很像，两个都是为了简便代码而存在的，这篇里详细讲解了抽象类与接口的相关知识，包括抽象类不能被final，private修饰，以及不能被new直接实例化，然后就是接口，感觉与抽象类最大的不同就是它不能有构造方法，且它里面的数据和方法都是默认有一些限定修饰符修饰的。<br> <img src="https://images2.imgbox.com/43/49/bcdSbHXO_o.png" alt="image.png"><br> 然后这是最后一篇异常类，然后异常类就只需要知道都是Exception类的子类或者是RuntimeException的子类都是异常类，我们还可以通过继承异常类类自定义异常类，然后就是里面的相关关键字try-catch之类的。finally，总之异常类啊还是挺简单的。</p> 
<hr> 
<h4><a id="_77"></a>补充内部类内容</h4> 
<h6><a id="_79"></a>静态内部类</h6> 
<pre><code>public class Test {

    static class Test1{
        String name;
        int a=10;

        public void setA(int a) {
            this.a = a;
            System.out.println(a);
        }
    }




}

class Test2{
    public static void main(String[] args) {
        Test.Test1 t=new Test.Test1();
        t.setA(100);

    }
}
</code></pre> 
<p>静态内部类就是在一个类中在定义一个静态类，因为加了static所以他就是属于这个Test类，所以它的初始化就是可以直接用如上 Test.Test1 t=new Test.Test1();直接用Test.来直接实例化，然后这个t对象就是一个内部类的对象了，其就跟普通的类实例化的对象没啥区别了。然后就是静态内部类都是无法使用外部类的实例成员和实例方法的。但可以直接使用静态方法或静态成员</p> 
<hr> 
<h6><a id="_110"></a>实例内部类</h6> 
<pre><code>public class Test {

    class Test1{
        String name;
        int a=10;

        public void setA(int a) {
            this.a = a;
            System.out.println(a);
        }
    }




}


class Test2{
    public static void main(String[] args) {
        Test test=new Test();
        Test.Test1 t=test.new Test1();

    }
}
</code></pre> 
<p>实例内部类里面则就是跟静态内部类的区别就是其实例化的方式不一样，实例内部类是需要先实例化一个外部类，才能实例化实例内部类。</p> 
<hr> 
<h6><a id="_142"></a>局部内部类</h6> 
<pre><code>public class Test {
    static String name1="hjhad";


    public void func1(){

        class Test1{

            int a=10;
            public void func2(){
                System.out.println("haha");
            }


        }
        
        Test1 t=new Test1();
        t.func2();

    }
</code></pre> 
<p>局部内部类，既然是局部，其实例化也是只能在定义的方法里面进行实例化。</p> 
<hr> 
<h6><a id="_169"></a>匿名内部类</h6> 
<p>匿名内部类通常用于实现接口或继承抽象类，不需要命名。</p> 
<pre><code>复制
public class Main {
    public static void main(String[] args) {
        // 使用匿名内部类实现接口
        MyInterface myObject = new MyInterface() {
            @Override
            public void doSomething() {
                System.out.println("Doing something...");
            }
        };
        myObject.doSomething();

        // 使用匿名内部类继承抽象类
        AbstractClass myAbstractObject = new AbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Implementing abstract method...");
            }
        };
        myAbstractObject.abstractMethod();
    }
}

interface MyInterface {
    void doSomething();
}

abstract class AbstractClass {
    abstract void abstractMethod();
}
</code></pre> 
<h5><a id="_204"></a>总结</h5> 
<ol><li><strong>成员内部类</strong>（Member Inner Class）： 
  <ul><li>成员内部类是定义在另一个类中的类。</li><li>它可以访问外部类的成员变量和方法，包括私有的。</li><li>它是一个静态成员，因此不能直接访问外部类的非静态成员。</li></ul> </li><li><strong>局部内部类</strong>（Local Inner Class）： 
  <ul><li>局部内部类是在方法内部定义的类。</li><li>它的作用域仅限于定义它的块内。</li><li>它不能访问外部类的成员变量，但可以访问外部类的静态成员变量和方法。</li></ul> </li><li><strong>匿名内部类</strong>（Anonymous Inner Class）： 
  <ul><li>匿名内部类是没有名称的内部类。</li><li>通常用于实现接口或继承抽象类，且只需要一次使用。</li><li>它不能有构造器，但可以访问外部类的成员变量和方法，包括私有的。</li></ul> </li><li><strong>静态嵌套类</strong>（Static Nested Class）： 
  <ul><li>静态嵌套类是静态成员内部类的一种。</li><li>它可以独立于外部类的实例存在，因此不需要外部类的实例就可以创建静态嵌套类的实例。</li><li>它不能访问外部类的非静态成员，但可以访问外部类的静态成员。</li></ul> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d79af4f8cf9ef8356a76b7e7674765a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Spring】Spring Security 核心类介绍及Spring Security 的验证机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/862b1d63c11953bb7ca2b1989ba0e354/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IT启航：高考后的IT学习之旅与未来规划</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>