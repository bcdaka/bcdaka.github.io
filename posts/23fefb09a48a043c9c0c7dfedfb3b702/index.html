<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux badblocks命令教程：如何检测和处理Linux磁盘的坏块(附案例详解和注意事项) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/23fefb09a48a043c9c0c7dfedfb3b702/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Linux badblocks命令教程：如何检测和处理Linux磁盘的坏块(附案例详解和注意事项)">
  <meta property="og:description" content="Linux badblocks命令介绍 badblocks是一个在Linux中用于搜索设备上坏块的命令。它通常用于搜索磁盘分区上的坏块。默认情况下，它以非破坏性只读模式运行。
Linux badblocks命令适用的Linux版本 badblocks命令在大多数Linux发行版中都可以使用，包括Debian、Ubuntu、Alpine、Arch Linux、Kali Linux、RedHat/CentOS、Fedora、Raspbian等。如果在某些Linux发行版中无法使用，通常可以通过包管理器（如apt、yum、dnf或pacman等）来安装。例如，在Debian或Ubuntu上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo apt-get install e2fsprogs 在RedHat/CentOS 7上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo yum install e2fsprogs 在RedHat/CentOS 8或Fedora上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo dnf install e2fsprogs 在Arch Linux上，可以使用以下命令来安装：
[linux@bashcommandnotfound.cn ~]$ sudo pacman -S e2fsprogs Linux badblocks命令的基本语法 badblocks命令的基本语法如下：
badblocks [-b block_size] [-i input_file] [-o output_file] [-svwnf] [-c blocks_at_once] [-d delay_factor_between_reads] [-e max_bad_blocks] [-p num_passes] [-t test_pattern [-t test_pattern [...]]] device [last_block [first_block]] 其中，device是对应设备的特殊文件（例如/dev/hdc1）。
Linux badblocks命令的常用选项或参数说明 以下是badblocks命令的一些常用选项：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-18T00:00:00+08:00">
    <meta property="article:modified_time" content="2024-05-18T00:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux badblocks命令教程：如何检测和处理Linux磁盘的坏块(附案例详解和注意事项)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Linux_badblocks_0"></a>Linux badblocks命令介绍</h3> 
<p><code>badblocks</code>是一个在Linux中用于搜索设备上坏块的命令。它通常用于搜索磁盘分区上的坏块。默认情况下，它以非破坏性只读模式运行。</p> 
<h3><a id="Linux_badblocksLinux_3"></a>Linux badblocks命令适用的Linux版本</h3> 
<p><code>badblocks</code>命令在大多数Linux发行版中都可以使用，包括Debian、Ubuntu、Alpine、Arch Linux、Kali Linux、RedHat/CentOS、Fedora、Raspbian等。如果在某些Linux发行版中无法使用，通常可以通过包管理器（如apt、yum、dnf或pacman等）来安装。例如，在Debian或Ubuntu上，可以使用以下命令来安装：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> e2fsprogs
</code></pre> 
<p>在RedHat/CentOS 7上，可以使用以下命令来安装：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> yum <span class="token function">install</span> e2fsprogs
</code></pre> 
<p>在RedHat/CentOS 8或Fedora上，可以使用以下命令来安装：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> dnf <span class="token function">install</span> e2fsprogs
</code></pre> 
<p>在Arch Linux上，可以使用以下命令来安装：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> pacman <span class="token parameter variable">-S</span> e2fsprogs
</code></pre> 
<h3><a id="Linux_badblocks_21"></a>Linux badblocks命令的基本语法</h3> 
<p><code>badblocks</code>命令的基本语法如下：</p> 
<pre><code class="prism language-bash">badblocks <span class="token punctuation">[</span>-b block_size<span class="token punctuation">]</span> <span class="token punctuation">[</span>-i input_file<span class="token punctuation">]</span> <span class="token punctuation">[</span>-o output_file<span class="token punctuation">]</span> <span class="token punctuation">[</span>-svwnf<span class="token punctuation">]</span> <span class="token punctuation">[</span>-c blocks_at_once<span class="token punctuation">]</span> <span class="token punctuation">[</span>-d delay_factor_between_reads<span class="token punctuation">]</span> <span class="token punctuation">[</span>-e max_bad_blocks<span class="token punctuation">]</span> <span class="token punctuation">[</span>-p num_passes<span class="token punctuation">]</span> <span class="token punctuation">[</span>-t test_pattern <span class="token punctuation">[</span>-t test_pattern <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> device <span class="token punctuation">[</span>last_block <span class="token punctuation">[</span>first_block<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>其中，<code>device</code>是对应设备的特殊文件（例如<code>/dev/hdc1</code>）。</p> 
<h3><a id="Linux_badblocks_28"></a>Linux badblocks命令的常用选项或参数说明</h3> 
<p>以下是<code>badblocks</code>命令的一些常用选项：</p> 
<table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-b block_size</code></td><td align="left">指定以字节为单位的块大小（默认为1024字节）</td></tr><tr><td align="left"><code>-c blocks_at_once</code></td><td align="left">指定一次测试的块数（默认为64块）</td></tr><tr><td align="left"><code>-d delay_factor_between_reads</code></td><td align="left">如果在读取操作中没有遇到错误，将在读取之间延迟</td></tr><tr><td align="left"><code>-e max_bad_blocks</code></td><td align="left">指定在中止测试之前的最大坏块数</td></tr><tr><td align="left"><code>-i input_file</code></td><td align="left">提供一个输入文件，该文件包含设备中已知的坏块列表</td></tr><tr><td align="left"><code>-o output_file</code></td><td align="left">将坏块列表写入文件，而不是标准输出</td></tr><tr><td align="left"><code>-p num_passes</code></td><td align="left">指定要执行的传递次数</td></tr><tr><td align="left"><code>-s</code></td><td align="left">显示测试的当前进度，显示已扫描的块的百分比</td></tr><tr><td align="left"><code>-v</code></td><td align="left">详细模式</td></tr><tr><td align="left"><code>-w</code></td><td align="left">在设备上执行读写测试</td></tr><tr><td align="left"><code>-n</code></td><td align="left">在设备上执行非破坏性的读写测试</td></tr><tr><td align="left"><code>-f</code></td><td align="left">强制在设备上执行测试，即使设备已挂载</td></tr></tbody></table> 
<h3><a id="Linux_badblocks_46"></a>Linux badblocks命令实例详解</h3> 
<p>以下是一些<code>badblocks</code>命令的使用实例：</p> 
<h4><a id="1badblocks_49"></a>实例1：使用badblocks命令扫描设备</h4> 
<p>在这个例子中，我们将使用<code>badblocks</code>命令扫描设备<code>/dev/sda1</code>：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks /dev/sda1
</code></pre> 
<p>这将扫描<code>/dev/sda1</code>设备上的坏块，并将找到的任何坏块打印到标准输出。</p> 
<h4><a id="2badblocks_56"></a>实例2：使用badblocks命令以详细模式扫描设备</h4> 
<p>在这个例子中，我们将使用<code>-v</code>选项以详细模式运行<code>badblocks</code>命令：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks <span class="token parameter variable">-v</span> /dev/sda1
</code></pre> 
<p>这将以详细模式扫描<code>/dev/sda1</code>设备上的坏块。详细模式将打印正在进行的操作的详细信息。</p> 
<h4><a id="3badblocks_63"></a>实例3：使用badblocks命令并将结果写入文件</h4> 
<p>在这个例子中，我们将使用<code>-o</code>选项将<code>badblocks</code>命令的结果写入文件：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks <span class="token parameter variable">-o</span> badblocks.txt /dev/sda1
</code></pre> 
<p>这将扫描<code>/dev/sda1</code>设备上的坏块，并将找到的坏块写入<code>badblocks.txt</code>文件。</p> 
<h4><a id="4badblocks_70"></a>实例4：使用badblocks命令以只读模式扫描设备</h4> 
<p>在这个例子中，我们将使用<code>-n</code>选项以只读模式运行<code>badblocks</code>命令：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks <span class="token parameter variable">-n</span> /dev/sda1
</code></pre> 
<p>这将以只读模式扫描<code>/dev/sda1</code>设备上的坏块。只读模式将不会改变设备上的数据。</p> 
<h4><a id="5badblocks_77"></a>实例5：使用badblocks命令并显示进度</h4> 
<p>在这个例子中，我们将使用<code>-s</code>选项显示<code>badblocks</code>命令的进度：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks <span class="token parameter variable">-s</span> /dev/sda1
</code></pre> 
<p>这将扫描<code>/dev/sda1</code>设备上的坏块，并显示已扫描的块的百分比。</p> 
<h4><a id="6badblocks_84"></a>实例6：使用badblocks命令并指定块大小</h4> 
<p>在这个例子中，我们将使用<code>-b</code>选项指定块大小：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks <span class="token parameter variable">-b</span> <span class="token number">2048</span> /dev/sda1
</code></pre> 
<p>这将以2048字节为单位的块大小扫描<code>/dev/sda1</code>设备上的坏块。</p> 
<h4><a id="7badblocks_91"></a>实例7：使用badblocks命令并指定一次测试的块数</h4> 
<p>在这个例子中，我们将使用<code>-c</code>选项指定一次测试的块数：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks <span class="token parameter variable">-c</span> <span class="token number">128</span> /dev/sda1
</code></pre> 
<p>这将一次测试128个块扫描<code>/dev/sda1</code>设备上的坏块。</p> 
<h4><a id="8badblocks_98"></a>实例8：使用badblocks命令并指定在中止测试之前的最大坏块数</h4> 
<p>在这个例子中，我们将使用<code>-e</code>选项指定在中止测试之前的最大坏块数：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>linux@bashcommandnotfound.cn ~<span class="token punctuation">]</span>$ <span class="token function">sudo</span> badblocks <span class="token parameter variable">-e</span> <span class="token number">10</span> /dev/sda1
</code></pre> 
<p>这将扫描<code>/dev/sda1</code>设备上的坏块，如果找到的坏块数达到10个，将中止测试。</p> 
<h3><a id="Linux_badblocks_105"></a>Linux badblocks命令的注意事项</h3> 
<ul><li><code>badblocks</code>命令默认情况下以非破坏性只读模式运行。</li><li>如果要在设备上执行读写测试，可以使用<code>-w</code>选项，但请注意，这将擦除设备上的数据。</li><li>如果设备已挂载，<code>badblocks</code>命令通常不会在设备上执行读写测试或非破坏性读写测试。可以使用<code>-f</code>选项强制执行测试，但这可能会导致系统崩溃和/或损坏文件系统。</li><li>如果出现<code>bash: badblocks: command not found</code>错误，可能是因为<code>e2fsprogs</code>包没有安装。可以按照上面的指示安装此包。</li></ul> 
<h3><a id="Linux_badblocks_111"></a>Linux badblocks相关命令</h3> 
<p>以下是一些与<code>badblocks</code>命令相关的命令：</p> 
<ul><li><a href="https://bashcommandnotfound.cn/article/linux-fsck-command" rel="nofollow">fsck命令：用于检查和修复文件系统</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-e2fsck-command" rel="nofollow">e2fsck命令：用于检查ext2/ext3/ext4文件系统</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-mkfs-command" rel="nofollow">mkfs命令：用于创建文件系统</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-dd-command" rel="nofollow">dd命令：用于复制和转换文件</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-fdisk-command" rel="nofollow">fdisk命令：用于操作磁盘分区表</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-parted-command" rel="nofollow">parted命令：用于磁盘分区和管理</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-df-command" rel="nofollow">df命令：用于显示磁盘空间使用情况</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-du-command" rel="nofollow">du命令：用于估计和显示文件和目录的磁盘使用情况</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-smartctl-command" rel="nofollow">smartctl命令：用于控制和监视存储系统</a></li><li><a href="https://bashcommandnotfound.cn/article/linux-hdparm-command" rel="nofollow">hdparm命令：用于获取和设置SATA/IDE设备参数</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/30043689f10aa90fad8737d232f20a63/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter 中的 DropdownButton 小部件：全面指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c376507464cdc4aaac63eeb31badfa4c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AIGC行业现在适合进入吗</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>