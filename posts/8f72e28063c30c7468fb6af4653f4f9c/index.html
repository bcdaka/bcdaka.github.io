<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Tomcat - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8f72e28063c30c7468fb6af4653f4f9c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Tomcat">
  <meta property="og:description" content="Tomcat 1.JVM是啥2.Tomcattomcat启动慢解决方案 3.tomcat目录结构介绍binconfliblogswebappsworktempRELEASE-NOTESRUNNING.txt 4.tomcat主配置文件5.tomcat部署java项目示例：zrlog6.配置tomcat basic认证7.Nginx&#43;Tomcat集群架构8.tomcat&#43;nfs实现文件共享安装配置nfs服务端客户端配置nfs 9.nginx做静态资源缓存缓存服务器配置参数介绍缓存结果验证 10.Nginx&#43;Tomcat实现Https11.使用maven编译java程序maven安装配置编译java程序配置tomcat站点 12.使用redisson实现session共享方法一：ip_hash 做会话保持方法二：使用redisson实现session共享redis部署配置redisson1.添加会话管理器2.将下载好的jar包放到指定目录重启tomcat 13.使用JConsole 监控jvm在被监控的tomcat服务器上开启监控接口使用JConsole 监控环境变量配置启动jconsole.exe 14.Tomcat性能优化15.JVM内存分代年轻代年轻代垃圾回收算法（复制算法）老年代老年代垃圾回收算法 （标记清除算法）永久代垃圾回收何时进行系统崩溃前的一些现象：dump文件Tomcat内存调整(JVM内存调整)年轻代和老年代设置多大才合理调优方法 1.JVM是啥 JVM是Java Virtual Machine（Java虚拟机）的缩写
是运行Java程序的抽象计算机，是Java语言的运行环境，Java虚拟机本质是就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。实现“一次编译，多次运行”。
jvm java虚拟机
jre java运行环境
jdk java开发工具包
jdk包含jre，jre包含jvm虚拟机
常用的是jdk8
jdk下载地址：https://www.oracle.com/java/technologies/downloads/?er=221886#java8
其他版本jdk下载地址：https://www.oracle.com/java/technologies/downloads/archive/
2.Tomcat Tomcat和 Nginx 类似，也是一个Web服务器。
tomcat是一个java编写的web服务器，需要java运行环境，运行java。
Nginx默认仅支持处理静态资源，而Tomcat则支持Java开发的 jsp 动态资源和静态资源。
Nginx适合做前端负载均衡，而Tomcat适合做后端应用服务处理。
通常情况下会将 Nginx&#43;tomcat 结合使用，由Nginx处理静态资源，Tomcat处理动态资源。
tomcat下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/
将下载好的jdk包传到服务器上
安装jdk
rpm -ivh jdk-8u411-linux-x64.rpm
安装启动tomcat
mkdir app -p tar xf apache-tomcat-9.0.90.tar.gz -C /app /app/apache-tomcat-9.0.90/bin/startup.sh 安装方法二：
#适合debian和ubuntu等其他linux发行版 tar xf jdk-8u60-linux-x64.tar.gz -C /app/ ln -s /app/jdk1.8.0_60 /app/jdk sed -i.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T18:19:05+08:00">
    <meta property="article:modified_time" content="2024-07-23T18:19:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Tomcat</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Tomcat</h4> 
 <ul><li><ul><li><ul><li><ul><li><a href="#1JVM_2" rel="nofollow">1.JVM是啥</a></li><li><a href="#2Tomcat_28" rel="nofollow">2.Tomcat</a></li><li><ul><li><a href="#tomcat_76" rel="nofollow">tomcat启动慢解决方案</a></li></ul> 
     </li><li><a href="#3tomcat_99" rel="nofollow">3.tomcat目录结构介绍</a></li><li><ul><li><a href="#bin_102" rel="nofollow">bin</a></li><li><a href="#conf_117" rel="nofollow">conf</a></li><li><a href="#lib_125" rel="nofollow">lib</a></li><li><a href="#logs_131" rel="nofollow">logs</a></li><li><a href="#webapps_142" rel="nofollow">webapps</a></li><li><a href="#work_150" rel="nofollow">work</a></li><li><a href="#temp_154" rel="nofollow">temp</a></li><li><a href="#RELEASENOTES_158" rel="nofollow">RELEASE-NOTES</a></li><li><a href="#RUNNINGtxt_163" rel="nofollow">RUNNING.txt</a></li></ul> 
     </li><li><a href="#4tomcat_168" rel="nofollow">4.tomcat主配置文件</a></li><li><a href="#5tomcatjavazrlog_217" rel="nofollow">5.tomcat部署java项目示例：zrlog</a></li><li><a href="#6tomcat_basic_260" rel="nofollow">6.配置tomcat basic认证</a></li><li><a href="#7NginxTomcat_348" rel="nofollow">7.Nginx+Tomcat集群架构</a></li><li><a href="#8tomcatnfs_428" rel="nofollow">8.tomcat+nfs实现文件共享</a></li><li><ul><li><a href="#nfs_436" rel="nofollow">安装配置nfs服务端</a></li><li><a href="#nfs_457" rel="nofollow">客户端配置nfs</a></li></ul> 
     </li><li><a href="#9nginx_491" rel="nofollow">9.nginx做静态资源缓存</a></li><li><ul><li><a href="#_495" rel="nofollow">缓存服务器配置</a></li><li><a href="#_543" rel="nofollow">参数介绍</a></li><li><a href="#_568" rel="nofollow">缓存结果验证</a></li></ul> 
     </li><li><a href="#10NginxTomcatHttps_585" rel="nofollow">10.Nginx+Tomcat实现Https</a></li><li><a href="#11mavenjava_675" rel="nofollow">11.使用maven编译java程序</a></li><li><ul><li><a href="#maven_678" rel="nofollow">maven安装配置</a></li><li><a href="#java_719" rel="nofollow">编译java程序</a></li><li><a href="#tomcat_739" rel="nofollow">配置tomcat站点</a></li></ul> 
     </li><li><a href="#12redissonsession_773" rel="nofollow">12.使用redisson实现session共享</a></li><li><ul><li><a href="#ip_hash__782" rel="nofollow">方法一：ip_hash 做会话保持</a></li><li><a href="#redissonsession_797" rel="nofollow">方法二：使用redisson实现session共享</a></li><li><ul><li><a href="#redis_799" rel="nofollow">redis部署</a></li><li><a href="#redisson_821" rel="nofollow">配置redisson</a></li><li><a href="#1_842" rel="nofollow">1.添加会话管理器</a></li><li><a href="#2jar_894" rel="nofollow">2.将下载好的jar包放到指定目录</a></li><li><a href="#tomcat_901" rel="nofollow">重启tomcat</a></li></ul> 
     </li></ul> 
     </li><li><a href="#13JConsole_jvm_928" rel="nofollow">13.使用JConsole 监控jvm</a></li><li><ul><li><a href="#tomcat_929" rel="nofollow">在被监控的tomcat服务器上开启监控接口</a></li><li><a href="#JConsole__955" rel="nofollow">使用JConsole 监控</a></li><li><a href="#_981" rel="nofollow">环境变量配置</a></li><li><a href="#jconsoleexe_1022" rel="nofollow">启动jconsole.exe</a></li></ul> 
     </li><li><a href="#14Tomcat_1049" rel="nofollow">14.Tomcat性能优化</a></li><li><a href="#15JVM_1082" rel="nofollow">15.JVM内存分代</a></li><li><ul><li><a href="#_1111" rel="nofollow">年轻代</a></li><li><a href="#_1131" rel="nofollow">年轻代垃圾回收算法（复制算法）</a></li><li><a href="#_1143" rel="nofollow">老年代</a></li><li><a href="#__1151" rel="nofollow">老年代垃圾回收算法 （标记清除算法）</a></li><li><a href="#_1165" rel="nofollow">永久代</a></li><li><a href="#_1177" rel="nofollow">垃圾回收何时进行</a></li><li><a href="#_1193" rel="nofollow">系统崩溃前的一些现象：</a></li><li><a href="#dump_1201" rel="nofollow">dump文件</a></li><li><a href="#TomcatJVM_1209" rel="nofollow">Tomcat内存调整(JVM内存调整)</a></li><li><a href="#_1254" rel="nofollow">年轻代和老年代设置多大才合理</a></li><li><a href="#_1265" rel="nofollow">调优方法</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h5><a id="1JVM_2"></a>1.JVM是啥</h5> 
<p>JVM是Java Virtual Machine（Java虚拟机）的缩写</p> 
<p>是运行Java程序的抽象计算机，是Java语言的运行环境，Java虚拟机本质是就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。实现“一次编译，多次运行”。</p> 
<p>jvm java虚拟机<br> jre java运行环境<br> jdk java开发工具包<br> jdk包含jre，jre包含jvm虚拟机</p> 
<hr> 
<p>常用的是jdk8</p> 
<p>jdk下载地址：<a href="https://www.oracle.com/java/technologies/downloads/?er=221886#java8" rel="nofollow">https://www.oracle.com/java/technologies/downloads/?er=221886#java8</a><br> <img src="https://images2.imgbox.com/5d/cc/daSXSwY7_o.png" alt="在这里插入图片描述"></p> 
<p>其他版本jdk下载地址：<a href="https://www.oracle.com/java/technologies/downloads/archive/" rel="nofollow">https://www.oracle.com/java/technologies/downloads/archive/</a></p> 
<hr> 
<h5><a id="2Tomcat_28"></a>2.Tomcat</h5> 
<p>Tomcat和 Nginx 类似，也是一个Web服务器。<br> tomcat是一个java编写的web服务器，需要java运行环境，运行java。</p> 
<p>Nginx默认仅支持处理静态资源，而Tomcat则支持Java开发的 jsp 动态资源和静态资源。<br> Nginx适合做前端负载均衡，而Tomcat适合做后端应用服务处理。<br> 通常情况下会将 Nginx+tomcat 结合使用，由Nginx处理静态资源，Tomcat处理动态资源。</p> 
<hr> 
<p>tomcat下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/" rel="nofollow">https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/</a></p> 
<p>将下载好的jdk包传到服务器上</p> 
<p>安装jdk<br> <code>rpm -ivh jdk-8u411-linux-x64.rpm</code></p> 
<p><img src="https://images2.imgbox.com/63/c1/f7oRtIfw_o.png" alt="在这里插入图片描述"></p> 
<p>安装启动tomcat</p> 
<pre><code>mkdir app -p
tar xf apache-tomcat-9.0.90.tar.gz -C /app
/app/apache-tomcat-9.0.90/bin/startup.sh 
</code></pre> 
<p><img src="https://images2.imgbox.com/72/a8/p7snklnK_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>安装方法二：</p> 
<pre><code>#适合debian和ubuntu等其他linux发行版
tar xf jdk-8u60-linux-x64.tar.gz -C /app/
ln -s /app/jdk1.8.0_60 /app/jdk
sed -i.ori '$a export JAVA_HOME=/app/jdk\nexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH\nexport CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar' /etc/profile
source /etc/profile
mkdir /app/
tar xf apache-tomcat-8.0.27.tar.gz -C /app
/app/apache-tomcat-8.0.27/bin/startup.sh 
</code></pre> 
<hr> 
<h6><a id="tomcat_76"></a>tomcat启动慢解决方案</h6> 
<p>可以在<code>/apache-tomcat-9.0.90/logs/catalina.out</code>中看到启动用时</p> 
<p><img src="https://images2.imgbox.com/11/0b/LFjxm17G_o.png" alt="在这里插入图片描述"></p> 
<p>优化方法：<br> <code>vim /usr/java/jdk1.8.0_102/jre/lib/security/java.security</code></p> 
<pre><code>将：securerandom.source=file:/dev/random
改为：securerandom.source=file:/dev/urandom
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/6d/ypqytLp5_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>启动后可以看到java常占用的端口<br> <img src="https://images2.imgbox.com/37/f8/xZjjmt9X_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="3tomcat_99"></a>3.tomcat目录结构介绍</h5> 
<p><img src="https://images2.imgbox.com/a8/aa/ObyTFPPz_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="bin_102"></a>bin</h6> 
<p>主要包含启动、关闭tomcat脚本和脚本依赖文件 非常重要</p> 
<p><img src="https://images2.imgbox.com/d5/b7/Ou1SlUEC_o.png" alt="在这里插入图片描述"></p> 
<p>以启动脚本为例<br> 执行脚本时，会先找到脚本本身的目录，然后去执行catalina.sh脚本，然后让tomcat在后台启动。<br> <img src="https://images2.imgbox.com/a2/c6/o15ExNsp_o.png" alt="在这里插入图片描述"></p> 
<p>在需要时，也可以让tomcat在前台启动<br> 先停掉tomcat，再执行<code>./catalina.sh run </code>让它前台启动</p> 
<p><img src="https://images2.imgbox.com/a5/bc/z21ZD57E_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="conf_117"></a>conf</h6> 
<p>tomcat配置文件目录,重要</p> 
<p>tomcat的主配置文件server.xml<br> <img src="https://images2.imgbox.com/db/81/yc1kU3qo_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="lib_125"></a>lib</h6> 
<p>tomcat运行需要加载的jar包,重要</p> 
<p>jar包相当于扩展模块，tomcat在运行过程中，会运行不同的组件，不同的组件对应的就是不同的jar包。想实现某些功能，就将对应的jar包放到lib目录下。<br> <img src="https://images2.imgbox.com/00/89/B7gpSkG1_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="logs_131"></a>logs</h6> 
<p>在运行过程中产生的日志文件，重要<br> catalina.out中主要记录一些报错输出等内容<br> access访问日志中主要记录访问日志</p> 
<p><img src="https://images2.imgbox.com/60/06/AxGZS0o3_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="webapps_142"></a>webapps</h6> 
<p>站点目录，重要<br> 访问tomcat时，默认访问的是ROOT目录下的内容<br> 要访问其他的目录在url中加入/对应的目录名称即可</p> 
<p><img src="https://images2.imgbox.com/b4/d4/KbBF55l5_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="work_150"></a>work</h6> 
<p>tomcat运行时产生的缓存文件</p> 
<hr> 
<h6><a id="temp_154"></a>temp</h6> 
<p>temp 存放临时文件</p> 
<hr> 
<h6><a id="RELEASENOTES_158"></a>RELEASE-NOTES</h6> 
<p>版本特性，不重要</p> 
<hr> 
<h6><a id="RUNNINGtxt_163"></a>RUNNING.txt</h6> 
<p>帮助文件，不重要</p> 
<hr> 
<h5><a id="4tomcat_168"></a>4.tomcat主配置文件</h5> 
<p>主配置文件：<br> /app/apache-tomcat-8.x.xx/conf/server.xml</p> 
<p>用户访问tomcat，会先访问到proxy模块，监听的8080端口。<br> proxy会将请求抛向server内部，<br> 请求抛给谁处理，就会找对应的连接器，<br> 例如是http请求，就会抛给http连接器，</p> 
<p><img src="https://images2.imgbox.com/9c/d7/Mg80Rp3e_o.png" alt="在这里插入图片描述"><br> 一个tomcat实例一个server<br> 一个server中包含多个连接器（Connector），Connector的主要功能是接受、响应用户请求。<br> service的作用是：将connector关联至engine(catalina引擎)，引擎下，对应的就是站点<br> 一个host就是一个站点，类似于nginx的多站点<br> context类似于nginx中location的概念</p> 
<hr> 
<p>打开server.xml文件，可以看到8005端口可以用来远程关闭tomcat服务<br> <img src="https://images2.imgbox.com/22/f9/8HZqOcIn_o.png" alt="在这里插入图片描述"></p> 
<p>server和service之间就是通过这些connector连接器连接的</p> 
<p><img src="https://images2.imgbox.com/2f/4d/5cDya9Uj_o.png" alt="在这里插入图片描述"></p> 
<p>tomcat核心的引擎是catalina<br> 引擎下，对应的就是站点，一个Host就对应一个站点，类似于nginx的多站点<br> nginx支持多域名多站点，同样tomcat （host）也支持多域名多站点</p> 
<p><img src="https://images2.imgbox.com/13/48/ZmQ7rfhV_o.png" alt="在这里插入图片描述"></p> 
<p>默认配置的站点是localhost站点，站点目录是webapps,<br> <img src="https://images2.imgbox.com/54/e1/0QZ3kPr8_o.png" alt="在这里插入图片描述"></p> 
<p>访问日志格式：</p> 
<pre><code>className="org.apache.catalina.valves.AccessLogValve" 日志的方法
directory="logs" 日志所在目录
prefix="localhost_access_log" 日志前缀
suffix=".txt" 日志后缀
中间加上时间戳
</code></pre> 
<p><img src="https://images2.imgbox.com/35/65/Rlt5hSCQ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="5tomcatjavazrlog_217"></a>5.tomcat部署java项目示例：zrlog</h5> 
<p>修改主配置文件server.xml，添加一个站点，就是添加一个Host</p> 
<p>例：</p> 
<pre><code>www.tct.com 为站点名 记得做域名解析
/html 为站点目录
将下载好的项目war包放到站点目录/html下会自动解压，自动部署。
</code></pre> 
<p><img src="https://images2.imgbox.com/6c/bc/WsgLW1NM_o.png" alt="在这里插入图片描述"></p> 
<p>修改后，需要重启服务才会生效<br> <img src="https://images2.imgbox.com/7e/ea/oQNmwWez_o.png" alt="在这里插入图片描述"></p> 
<p>创建站点目录后，将war包放入站点目录，会自动解压自动部署<br> <img src="https://images2.imgbox.com/ab/29/g1asNLDv_o.png" alt="在这里插入图片描述"></p> 
<p>过一会访问<br> <img src="https://images2.imgbox.com/ba/47/4F2vup6q_o.png" alt="在这里插入图片描述"></p> 
<p><strong>配置数据库</strong></p> 
<pre><code>yum install mariadb-server -y
systemctl start mariadb.service
systemctl enable mariadb.service
</code></pre> 
<p><img src="https://images2.imgbox.com/e3/1b/lFD2r65T_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0e/51/OKPSbsU0_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/04/99/FufRWRK1_o.png" alt="在这里插入图片描述"></p> 
<p>站点部署成功</p> 
<p><img src="https://images2.imgbox.com/9a/bf/tZRVWKyo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c8/e7/q1Elc3IF_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="6tomcat_basic_260"></a>6.配置tomcat basic认证</h5> 
<p>有了basic认证使网站多了一层安全保障</p> 
<p>nginx同样也有basic认证，参考<a href="https://blog.csdn.net/Wangjiachenga/article/details/126122803">nginx常用功能模块</a> 中 <strong>nginx通过账户登陆实现访问控制</strong></p> 
<hr> 
<p>测试basic认证时</p> 
<p><img src="https://images2.imgbox.com/c0/31/FmY9fLOI_o.png" alt="在这里插入图片描述"></p> 
<p>点击这三个按钮后提示403</p> 
<p><img src="https://images2.imgbox.com/a7/c1/KzQcm6z0_o.png" alt="在这里插入图片描述"></p> 
<p>解决方法：</p> 
<p>将以下两个文件中的这两行注释掉</p> 
<pre><code>/app/apache-tomcat-9.0.90/webapps/manager/META-INF/context.xml
/app/apache-tomcat-9.0.90/webapps/host-manager/META-INF/context.xml
</code></pre> 
<p><img src="https://images2.imgbox.com/11/54/SZEk1kcK_o.png" alt="在这里插入图片描述"></p> 
<p>然后在<br> <code>/app/apache-tomcat-9.0.90/conf/tomcat-users.xml</code></p> 
<p>加入</p> 
<pre><code>&lt;role rolename="manager-gui"/&gt; #声明角色
&lt;role rolename="admin-gui"/&gt;
&lt;user username="tomcat" password="s3cret" roles="admin-gui,manager-gui"/&gt;  #一个用户可以是多个角色
</code></pre> 
<p><img src="https://images2.imgbox.com/6c/d1/PtJGFskY_o.png" alt="在这里插入图片描述"></p> 
<p>配置过后需要重启tomcat</p> 
<pre><code>/app/apache-tomcat-9.0.90/bin/shutdown.sh
/app/apache-tomcat-9.0.90/bin/startup.sh
</code></pre> 
<p>重启后再试即可认证<br> <img src="https://images2.imgbox.com/f1/15/wEnAD5Ow_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/11/c3/tyY7U8be_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>如果是在部署的项目上开启basic认证时，需要在配置的站点目录下找到<br> ROOT/WEB-INF/web.xml<br> 例如站点目录是/html，就编辑/html/ROOT/WEB-INF/web.xml文件</p> 
<p>在文件倒数第二行加上basic认证</p> 
<pre><code> &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;test&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/做basic认证的URL，当访问这个URL时才做basic认证&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        
        &lt;auth-constraint&gt;
            &lt;role-name&gt;角色名&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt; 
    &lt;login-config&gt;
        &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
        &lt;realm-name&gt;Default&lt;/realm-name&gt;
    &lt;/login-config&gt;

</code></pre> 
<p>配置过后重启tomcat</p> 
<pre><code>/app/apache-tomcat-9.0.90/bin/shutdown.sh
/app/apache-tomcat-9.0.90/bin/startup.sh
</code></pre> 
<hr> 
<h5><a id="7NginxTomcat_348"></a>7.Nginx+Tomcat集群架构</h5> 
<p>大概架构<br> <img src="https://images2.imgbox.com/21/52/1jRK6GBd_o.png" alt="在这里插入图片描述"></p> 
<p>在之前的基础上，部署一台配置相同的web服务器，jdk+tomcat+zrlog</p> 
<p>再部署一台nginx负载均衡服务器，配置文件如下</p> 
<p>cat proxy_java.conf</p> 
<pre><code>
upstream tomcat {    #定义资源池
 	server 192.168.xx.1:8080;  #tomcat01
 	server 192.168.xx.2:8080;  #tomcat02
 }

server {
 	listen 80;
 	server_name www.tct.com;
 	location / {
 		proxy_pass http://tomcat;  #调⽤upstream资源池定义的名称
		proxy_set_header Host $host;    #修改请求头中的Host为实际请求的主机名
		proxy_set_header X-Real-IP $remote_addr;  #传递客户端的真实IP地址
 		include proxy_params;
 	}
 }


</code></pre> 
<p><code>proxy_set_header Host $host; </code><br> 修改由Nginx传递给代理后端的请求头,修改请求头中的Host，<br> 不然会保留原始的Host，返回的页面是tomcat默认页面，<br> 并非实际请求页面，$host的值就是请求的主机名。</p> 
<p><code>proxy_set_header X-Real-IP $remote_addr;</code><br> 传递客户端的真实IP地址，当 Nginx做负载均衡时，后端服务器看到的客户端 IP 是负载均衡的 IP，而不是真实用户的 IP。</p> 
<p>同时需要将两台tomcat服务器的日志格式修改</p> 
<p><code>vim /app/apache-tomcat-8.0.27/conf/server.xml</code></p> 
<pre><code>pattern="%{X-Real-IP}i %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; 
</code></pre> 
<p>参数含义：</p> 
<pre><code>  %i 表示请求头
  %l 表示‘-’
  %u 远程用户身份验证,应该就是前面的basic认证
  %t 日期时间
  &amp;quot 表示空格
  %r 第一行的请求（主要包含请求方法和请求的URI）
  %s 响应的HTTP状态码
  %b 发送的字节数
</code></pre> 
<p><img src="https://images2.imgbox.com/4a/c3/xJaRZlRK_o.png" alt="在这里插入图片描述"></p> 
<p>修改后重启tomcat</p> 
<pre><code>/app/apache-tomcat-8.0.27/bin/shutdown.sh
/app/apache-tomcat-8.0.27/bin/startup.sh
</code></pre> 
<p>然后后端看到的IP就是真实的客户端IP了。</p> 
<p><img src="https://images2.imgbox.com/1f/eb/JFWTAEuQ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="8tomcatnfs_428"></a>8.tomcat+nfs实现文件共享</h5> 
<p>大概架构<br> 为了方便我就直接在数据库服务器上部署NFS服务了</p> 
<p><img src="https://images2.imgbox.com/94/e6/qDsDuD0L_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="nfs_436"></a>安装配置nfs服务端</h6> 
<p>1.安装<br> <code>yum install nfs-utils -y</code></p> 
<p>2.配置<br> <code>vim /etc/exports</code></p> 
<pre><code>/data 192.168.51.1/24(rw,sync,no_root_squash,no_all_squash)
</code></pre> 
<p>3.根据配置进行初始化操作<br> <code>mkdir -p /Data</code></p> 
<p>4.启动</p> 
<pre><code>systemctl start nfs
#systemctl enable nfs
</code></pre> 
<h6><a id="nfs_457"></a>客户端配置nfs</h6> 
<p>在两台tomcat服务器上都要执行以下操作</p> 
<p>安装nfs<br> <code> yum install nfs-utils -y</code></p> 
<p>查看某主机提供的nfs服务<br> <code>showmount -e 192.168.xx.xxx</code></p> 
<p>因为zrlog的图片存放路径在 /站点目录/zrlog/attached下，所以创建对应目录<br> <code>mkdir /html/zrlog/attached</code></p> 
<p>挂载<br> 将192.168.xx.xxx:/Data 挂载到本地的/html/zrlog/attached目录<br> <code>mount -t nfs 192.168.xx.xxx:/Data /html/zrlog/attached</code></p> 
<p>df -h 查看是否挂载上<br> <img src="https://images2.imgbox.com/f8/b7/zhH8Letj_o.png" alt="在这里插入图片描述"></p> 
<p>如果遇到客户端权限不足的情况参考：<br> <a href="https://blog.csdn.net/Wangjiachenga/article/details/125882632">NFS客户端权限不足</a></p> 
<p>接下来在任意一台服务器上传图片，另外一台服务器同样可以读到该图片</p> 
<p><img src="https://images2.imgbox.com/46/a4/OPvXrUwA_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="9nginx_491"></a>9.nginx做静态资源缓存</h5> 
<h6><a id="_495"></a>缓存服务器配置</h6> 
<p>nginx配置文件如下</p> 
<p>vim /etc/nginx/conf.d/proxy.conf</p> 
<pre><code>
proxy_cache_path /opt/nginx/cache levels=1:2 keys_zone=one:10m;
upstream tomcat {
	server 192.168.xx.xx1:8080;
 	server 192.168.xx.xx2:8080;
}

server {
 	listen 80;
 	server_name www.tct.com;
 	
	location / {
 		proxy_pass http://tomcat;
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
 		include proxy_params;
 	}
 	
	location ~ .*\.(gif|jpg|png|css|js|woff|flv|ico|swf)(.*) {
                proxy_cache one;
                proxy_cache_key $uri;
                proxy_cache_valid 200 302 1h;
                proxy_cache_valid 301 1d;
                proxy_cache_valid any 1m;
                expires 30d;
                add_header     Nginx-Cache   "$upstream_cache_status";
                proxy_pass http://tomcat;
				proxy_set_header Host $host;
				proxy_set_header X-Real-IP $remote_addr;
 			 	include proxy_params;
 }
}

</code></pre> 
<p><code>/opt/nginx/cache</code> 目录需要提前创建，并且授权给nginx，<br> <code>chown -R nginx:nginx /opt/nginx/cache</code><br> 因为nginx需要往该目录中写缓存</p> 
<h6><a id="_543"></a>参数介绍</h6> 
<p><code>/opt/nginx/cache</code> 指定缓存目录</p> 
<p><code>levels=1:2 </code>表示缓存目录的层级 ，1:2表示生成的目录是两级目录</p> 
<p><code>keys_zone=one:10m</code> key是索引，每个缓存都会生成唯一的标识符来索引，下次请求缓存的时候，会先去索引key，有请求资源的话直接返回缓存，没有的话生成新的缓存。one是给key区域的起的名。 10m指的是索引的大小。</p> 
<p><code>gif|jpg|png|css|js|woff|flv|ico|swf</code> 指定格式</p> 
<p><code>proxy_cache one;</code> 缓存到哪个区域，对应前面创建的one</p> 
<p><code>proxy_cache_key $uri;</code> 指定uri作为key的索引</p> 
<p><code> proxy_cache_valid 200 302 1h;</code> 200 302状态码的缓存一小时</p> 
<p><code>proxy_cache_valid 301 1d;</code> 301状态码的缓存一天</p> 
<p><code>proxy_cache_valid any 1m;</code> 其他状态码的缓存一分钟</p> 
<p><code> expires 30d;</code> 过期时间为30天</p> 
<p><code>add_header Nginx-Cache "$upstream_cache_status";</code> 判断是否命中缓存 ，在http 的响应头中添加一个缓存的命中状态。HIT表示命中缓存，MISS表示没有命中缓存。</p> 
<hr> 
<h6><a id="_568"></a>缓存结果验证</h6> 
<p>查看缓存目录，可以看到缓存目录层级是按照我们指定的两层进行缓存的</p> 
<p><img src="https://images2.imgbox.com/fe/e5/4hoYbjn5_o.png" alt="在这里插入图片描述"></p> 
<p>查看响应头，可以看到 png图片资源、js文件 都命中了缓存</p> 
<p><img src="https://images2.imgbox.com/5e/4a/vxZDtWJv_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/00/d6/J4UuPg3w_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="10NginxTomcatHttps_585"></a>10.Nginx+Tomcat实现Https</h5> 
<p><img src="https://images2.imgbox.com/e0/1e/J5mnIon0_o.png" alt="在这里插入图片描述"></p> 
<p>其实就是给nginx配一个证书</p> 
<p>nginx配置如下：</p> 
<pre><code>proxy_cache_path /opt/nginx/cache levels=1:2 keys_zone=one:10m;
upstream tomcat {
	server 192.168.xx.xx1:8080;
 	server 192.168.xx.xx2:8080;
}

server {  #主要是证书配置这一部分，其他的和之前的变化不大
 		listen 443 ssl;
   		server_name closeai.xyz;
    	ssl_certificate /opt/closeai.xyz_nginx/closeai.xyz.pem;
    	ssl_certificate_key /opt/closeai.xyz_nginx/closeai.xyz.key;
    	ssl_session_timeout 5m;
   		ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    	ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;

	location / {
 		proxy_pass http://tomcat;
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
 		include proxy_params;
 	}

	location ~ .*\.(gif|jpg|png|css|js|woff|flv|ico|swf)(.*) {
                proxy_cache one;
                proxy_cache_key $uri;
                proxy_cache_valid 200 302 1h;
                proxy_cache_valid 301 1d;
                proxy_cache_valid any 1m;
                expires 30d;
                add_header     Nginx-Cache   "$upstream_cache_status";
		proxy_pass http://tomcat;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                include proxy_params;
 }
}

server {    #做个协议层面的跳转，请求http时，自动跳转到https
        listen 80;
        server_name closeai.xyz;
        return 302 https://$server_name$request_uri;       #$server_name：请求的域名，$request_uri：用户请求的URI

}
</code></pre> 
<p>修改完配置记得重载一下nginx服务</p> 
<pre><code>nginx -t
systemctl reload nginx
</code></pre> 
<hr> 
<p>两台tomcat的配置文件中的站点也要记得修改成同样的域名</p> 
<p><code>vim /app/apache-tomcat-8.0.27/conf/server.xml</code></p> 
<p><img src="https://images2.imgbox.com/d2/ff/tqeciBwl_o.png" alt="在这里插入图片描述"></p> 
<p>修改完记得重启tomcat</p> 
<pre><code>/app/apache-tomcat-8.0.27/bin/shutdown.sh
/app/apache-tomcat-8.0.27/bin/startup.sh
</code></pre> 
<hr> 
<p><strong>结果验证</strong><br> 通过https的方式访问站点，可以成功打开<br> 因为我用的证书是有效的，如果是自己生成的证书，浏览器会报证书无效的错，但原理都一样，花钱买个域名，再把有效的证书换上就可以了。</p> 
<p><img src="https://images2.imgbox.com/da/5c/FJzasNex_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="11mavenjava_675"></a>11.使用maven编译java程序</h5> 
<h6><a id="maven_678"></a>maven安装配置</h6> 
<p>下载maven<br> <code>wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz</code></p> 
<p>解压maven<br> <code>tar xf apache-maven-3.8.8-bin.tar.gz -C /usr/local/</code></p> 
<p>创建软链接<br> <code>ln -s /usr/local/apache-maven-3.8.8 /usr/local/maven</code></p> 
<p>配置maven环境变量</p> 
<pre><code>vim /etc/profile

#文件结尾添加两行
export M2_HOME=/usr/local/maven
export PATH=${M2_HOME}/bin:$PATH
</code></pre> 
<p><code>source /etc/profile</code></p> 
<p>验证maven<br> <code>mvn -v</code></p> 
<p>配置maven仓库<br> <code>vim /usr/local/maven/conf/settings.xml</code><br> <img src="https://images2.imgbox.com/d9/fd/aQtqNDqK_o.png" alt="在这里插入图片描述"></p> 
<pre><code>	&lt;mirror&gt;
     &lt;id&gt;nexus-aliyun&lt;/id&gt;
     &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
     &lt;name&gt;Nexus aliyun&lt;/name&gt;
     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
    &lt;/mirror&gt;

</code></pre> 
<hr> 
<h6><a id="java_719"></a>编译java程序</h6> 
<p>下载好测试用的包：https://github.com/efsavage/hello-world-war</p> 
<p>解压后进入项目目录</p> 
<pre><code>unzip hello-world-war-master.zip

cd hello-world-war-master
</code></pre> 
<p>编译<br> <code>mvn clean package</code></p> 
<p>编译后war包在target目录下</p> 
<p><img src="https://images2.imgbox.com/c1/c4/FcjkTvsV_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="tomcat_739"></a>配置tomcat站点</h6> 
<p><code>vim /app/apache-tomcat-8.0.27/conf/server.xml</code><br> 再添加一个Host<br> <img src="https://images2.imgbox.com/cb/0c/tOKN0hDX_o.png" alt="在这里插入图片描述"></p> 
<p>记得创建站点目录，再将之前的war包放到站点目录下名为ROOT.war<br> tomcat会自动解压</p> 
<pre><code>mkdir /hello
mv /opt/hello-world-war-master/target/hello-world-war-1.0.0.war /hello/ROOT.war
</code></pre> 
<p><img src="https://images2.imgbox.com/ef/0c/DDjC9qqT_o.png" alt="在这里插入图片描述"></p> 
<p>记得做域名解析</p> 
<p>记得重启tomcat</p> 
<pre><code>/app/apache-tomcat-8.0.27/bin/shutdown.sh
/app/apache-tomcat-8.0.27/bin/startup.sh
</code></pre> 
<p>然后访问站点即可</p> 
<p><img src="https://images2.imgbox.com/21/02/KO7JmKue_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="12redissonsession_773"></a>12.使用redisson实现session共享</h5> 
<p>存在的问题：将相同业务的后端节点加入负载均衡后，在客户端进行登录操作的时候，会发现不管在哪个节点都无法正常登陆，原因是session没有共享。</p> 
<p>解决方案：做会话保持<br> 1.粘性session： ip_hash 始终定向⾄某⼀个后端web节点。<br> 2.session共享： 将session通过存储到指定⼀个位置，⽽不是存储⾄本地，后端所有节点都通过这个位置进行验证 （ redis ）</p> 
<hr> 
<h6><a id="ip_hash__782"></a>方法一：ip_hash 做会话保持</h6> 
<p>在负载均衡的配置文件的地址池中加入ip_hash<br> 解决了无法登陆的问题，但是只能访问固定的一个web节点，无法轮询</p> 
<pre><code>upstream web {
	ip_hash;    #做会话保持
	server 192.168.xx.xx1:8080;
	server 192.168.xx.xx2:8080;

}
</code></pre> 
<hr> 
<h6><a id="redissonsession_797"></a>方法二：使用redisson实现session共享</h6> 
<h6><a id="redis_799"></a>redis部署</h6> 
<p><code>yum install redis -y</code></p> 
<p>启动redis</p> 
<pre><code>systemctl start redis
systemctl enable redis
</code></pre> 
<p>修改redis配置文件<br> <code>vim /etc/redis.conf</code><br> 添加redis服务器的IP地址</p> 
<p><img src="https://images2.imgbox.com/2a/b2/ZZPdIiaQ_o.png" alt="在这里插入图片描述"></p> 
<p>重启redis<br> <code>systemctl restart redis</code></p> 
<hr> 
<h6><a id="redisson_821"></a>配置redisson</h6> 
<p>在每台tomcat服务器上都执行以下操作</p> 
<p>redisson项目地址<br> <a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p> 
<p>基于 Redis 的 Tomcat 会话管理器<br> <a href="https://github.com/redisson/redisson/tree/master/redisson-tomcat">https://github.com/redisson/redisson/tree/master/redisson-tomcat</a></p> 
<p>官方使用教程：<br> <img src="https://images2.imgbox.com/61/7e/PNJJGTWa_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/4c/55/oLv9qmKZ_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="1_842"></a>1.添加会话管理器</h6> 
<p><code>vim /app/apache-tomcat-8.0.27/conf/context.xml</code></p> 
<p>添加以下内容</p> 
<pre><code>&lt;Manager className="org.redisson.tomcat.RedissonSessionManager"
  configPath="${catalina.base}/conf/redisson.conf" 
  readMode="REDIS" updateMode="DEFAULT" broadcastSessionEvents="false"
  keyPrefix=""/&gt;
</code></pre> 
<p><img src="https://images2.imgbox.com/61/a7/mNC0xuTa_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>然后将redisson.conf文件放到上面配置的目录下<br> /app/apache-tomcat-8.0.27/conf/目录下</p> 
<p>这个配置文件是用来连接redis的</p> 
<p>redisson.conf文件内容如下</p> 
<pre><code>{
   "singleServerConfig":{
      "idleConnectionTimeout":10000,
      "connectTimeout":10000,
      "timeout":3000,
      "retryAttempts":3,
      "retryInterval":1500,
      "password":null,
      "subscriptionsPerConnection":5,
      "clientName":null,
      "address": "redis://你的redis地址:6379",  #这里记得改成你部署的redis的地址
      "subscriptionConnectionMinimumIdleSize":1,
      "subscriptionConnectionPoolSize":50,
      "connectionMinimumIdleSize":32,
      "connectionPoolSize":64,
      "database":0,
      "dnsMonitoringInterval":5000
   },
   "threads":0,
   "nettyThreads":0,
   "codec":{
      "class":"org.redisson.codec.JsonJacksonCodec"
   },
   "transportMode":"NIO"
}
</code></pre> 
<hr> 
<h6><a id="2jar_894"></a>2.将下载好的jar包放到指定目录</h6> 
<p>将下载好的jar包放到官方指定的tomcat根目录下的lib目录中<br> /app/apache-tomcat-8.0.27/lib/</p> 
<p><img src="https://images2.imgbox.com/12/64/8ryswUXJ_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="tomcat_901"></a>重启tomcat</h6> 
<pre><code>/app/apache-tomcat-8.0.27/bin/shutdown.sh
/app/apache-tomcat-8.0.27/bin/startup.sh
</code></pre> 
<hr> 
<p>每台tomcat服务器都配置完毕后，session已经共享，再去登陆就可以成功登陆了</p> 
<p>可以查看到在redis中存的session</p> 
<pre><code>redis-cli

KEYS *
</code></pre> 
<hr> 
<h5><a id="13JConsole_jvm_928"></a>13.使用JConsole 监控jvm</h5> 
<h6><a id="tomcat_929"></a>在被监控的tomcat服务器上开启监控接口</h6> 
<p><code>vim /app/apache-tomcat-8.0.27/bin/catalina.sh</code></p> 
<p><img src="https://images2.imgbox.com/ae/58/ql3LyybZ_o.png" alt="在这里插入图片描述"></p> 
<pre><code>CATALINA_OPTS="$CATALINA_OPTS
-Dcom.sun.management.jmxremote
-Djava.rmi.server.hostname=192.168.xx.xxx
-Dcom.sun.management.jmxremote.port=12345
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false"
</code></pre> 
<p>重启tomcat</p> 
<pre><code>/app/apache-tomcat-8.0.27/bin/shutdown.sh
/app/apache-tomcat-8.0.27/bin/startup.sh 
</code></pre> 
<p>验证<br> <img src="https://images2.imgbox.com/3c/87/JsJ6grAz_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="JConsole__955"></a>使用JConsole 监控</h6> 
<p>在一台Windows机器上安装jdk</p> 
<p>jdk下载地址：<br> <a href="https://www.oracle.com/cn/java/technologies/downloads/#java11-windows" rel="nofollow">https://www.oracle.com/cn/java/technologies/downloads/#java11-windows</a></p> 
<p><img src="https://images2.imgbox.com/11/01/bOw2gttp_o.png" alt="在这里插入图片描述"></p> 
<p>安装jdk<br> <img src="https://images2.imgbox.com/29/43/7zz6LF2R_o.png" alt="在这里插入图片描述"></p> 
<p>按照他默认的安装路径即可<br> <img src="https://images2.imgbox.com/78/d3/1cEvMYd8_o.png" alt="在这里插入图片描述"></p> 
<p>点关闭<br> <img src="https://images2.imgbox.com/24/bc/dWZy6RHA_o.png" alt="在这里插入图片描述"></p> 
<p>在刚才的安装路径下可以看到jdk-11<br> <img src="https://images2.imgbox.com/11/e3/SZK4opmD_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="_981"></a>环境变量配置</h6> 
<p>右键此电脑，属性<br> <img src="https://images2.imgbox.com/5a/1f/nEEGIjYm_o.png" alt="在这里插入图片描述"></p> 
<p>高级系统设置<br> <img src="https://images2.imgbox.com/5d/52/i7oHJYkx_o.png" alt="在这里插入图片描述"></p> 
<p>点击环境变量</p> 
<p><img src="https://images2.imgbox.com/8d/7d/b1CoiIgW_o.png" alt="在这里插入图片描述"></p> 
<p>浏览目录找到刚才的安装路径，然后点确定</p> 
<p><img src="https://images2.imgbox.com/5b/e9/aKAn7GSV_o.png" alt="在这里插入图片描述"></p> 
<p>找到Path编辑，点击新建输入<code>%Java_Home%\bin</code> ，然后确定<br> <img src="https://images2.imgbox.com/71/f3/XzCoFFaB_o.png" alt="在这里插入图片描述"></p> 
<p>然后都点确定关闭页面</p> 
<p><img src="https://images2.imgbox.com/e0/e1/MImnPxZz_o.png" alt="在这里插入图片描述"></p> 
<p>同时按下 win + R 输入 cmd 回车</p> 
<p><img src="https://images2.imgbox.com/0c/60/pJ7fXOCN_o.png" alt="在这里插入图片描述"></p> 
<p>输入java -version 查看版本<br> <img src="https://images2.imgbox.com/44/d5/XfSBZxaU_o.png" alt="在这里插入图片描述"></p> 
<p>输入javac 会输出以下信息<br> <img src="https://images2.imgbox.com/2b/6a/Web2Hs7H_o.png" alt="在这里插入图片描述"></p> 
<p>jdk配置完成</p> 
<hr> 
<h6><a id="jconsoleexe_1022"></a>启动jconsole.exe</h6> 
<p>在<code>C:\Program Files\Java\jdk-11\bin</code>下找到jconsole.exe</p> 
<p><img src="https://images2.imgbox.com/11/24/3HnWWYTq_o.png" alt="在这里插入图片描述"></p> 
<p>因为我要监控的是远程的tomcat服务器，<br> 所以在远程进程下输入远程服务器的IP地址:JMX自定义的端口，然后点连接</p> 
<p><img src="https://images2.imgbox.com/99/fd/tZfiF5AM_o.jpg" alt="在这里插入图片描述"></p> 
<p>然后点 不安全的连接 （前面没开SSL连接）<br> <img src="https://images2.imgbox.com/7e/04/rPyCpwQC_o.jpg" alt="在这里插入图片描述"></p> 
<p>稍等一会，就可以看到监控页面了</p> 
<p><img src="https://images2.imgbox.com/7c/b1/3SZIqrEp_o.jpg" alt="在这里插入图片描述"></p> 
<p>可以切换查看不同的信息</p> 
<p><img src="https://images2.imgbox.com/25/e1/DjJKutMa_o.jpg" alt="在这里插入图片描述"></p> 
<hr> 
<h5><a id="14Tomcat_1049"></a>14.Tomcat性能优化</h5> 
<p>‌Tomcat的性能优化可以通过多个方面进行，<br> 主要包括:内存优化、并发优化、‌数据库连接池优化、线程优化、缓存优化等。</p> 
<pre><code>内存优化：通过调整JVM启动参数如-Xms和-Xmx来设置JVM的初始堆大小和最大堆大小。
例如，可以设置JAVA_OPTS='-Xms1024m -Xmx2048m'来确保JVM有足够的内存资源。‌

并发优化：调整Tomcat的连接器配置文件server.xml中的参数，
如minProcessors、maxProcessors、acceptCount和maxThreads，
以优化并发处理能力。例如，增加acceptCount的值可以扩大连接请求队列，避免连接请求被拒绝。‌

数据库连接池优化：选择合适的数据库连接池
（如Apache Commons DBCP、Tomcat JDBC Pool、HikariCP等），
并合理配置连接池参数，如连接数、最大等待时间、最大空闲连接数等，
以提高数据库连接的利用率和性能。‌

线程优化：根据服务器的CPU核数和负载情况调整maxThreads参数，
以及考虑使用非阻塞模式的连接协议（如NIO或APR）来提高处理能力。‌

缓存和压缩优化：开启gzip压缩来减小网络传输大小，同时考虑使用缓存来减少对后端Tomcat的访问。
例如，可以在Tomcat中配置压缩相关的参数，如compression="on"和设置压缩的最小内容长度等。‌

Tomcat的性能优化是一个多方面的过程，
需要综合考虑内存、并发、数据库连接池、线程以及缓存和压缩等多个方面的设置和调整。

</code></pre> 
<hr> 
<h5><a id="15JVM_1082"></a>15.JVM内存分代</h5> 
<p>内存主要包括<code>堆内存</code>与<code>非堆内存</code></p> 
<p><img src="https://images2.imgbox.com/6f/3d/GjFEzzJe_o.jpg" alt="在这里插入图片描述"></p> 
<p>JVM将内存划分为三大部分：</p> 
<pre><code>年轻代Young Generation
老年代Old Generation
永久代Permanent Generation
</code></pre> 
<p><code>年轻代</code>和<code>老年代</code>属于<code>堆内存</code>，<br> 堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配<br> 年轻代和老年代将根据默认的比例（1：4）分配堆内存</p> 
<p><code>永久代</code>不属于堆内存，虚拟机直接分配，<br> 但可以通过(-XX:PermSize -XX:MaxPermSize)等参数调整其大小。</p> 
<hr> 
<p>年轻代：用来存放JVM刚分配的Java对象<br> 老年代：年轻代中经过垃圾回收没有被回收掉的对象将被Copy到年老代<br> 永久代：永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。</p> 
<hr> 
<h6><a id="_1111"></a>年轻代</h6> 
<p>年轻代用来存放JVM刚分配的Java对象。<br> 由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。</p> 
<p>年轻代又分为 ：<code>Eden</code>、<code>SurvivorFrom</code>、<code>SurvivorTo</code>三个区。</p> 
<p>Eden区：存放JVM刚分配的Java对象<br> （如果新对象占用内存很大，则直接分配到老年代）,<br> 当Eden区内存不够的时候就会触发MinorGC(局部的GC)，对年轻代区进行一次垃圾回收。</p> 
<p>SurvivorFrom（s0）：保留了一次MinorGC过程中的幸存者。</p> 
<p>SurvivorTo（s1）：上一次GC的幸存者，作为这一次GC的被扫描者。</p> 
<p>两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如对象的年龄，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。</p> 
<hr> 
<h6><a id="_1131"></a>年轻代垃圾回收算法（复制算法）</h6> 
<p>首先把Eden和SurvivorFrom区域中存活的对象复制到SurvivorTo区域<br> 同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）<br> （如果有对象的年龄已经达到了老年的标准，一般是15，则复制到老年代区）<br> 然后，清空Eden和SurvivorFrom中的对象；<br> 最后把SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。</p> 
<p><img src="https://images2.imgbox.com/d8/0d/rOVuvTIk_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h6><a id="_1143"></a>老年代</h6> 
<p>老年代的对象比较稳定，所以不会频繁执行GC。<br> 老年代在进行GC前一般年轻代都先进行了一次GC，使得年轻代的对象晋升入老年代，<br> 导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次GC进行垃圾回收腾出空间。</p> 
<hr> 
<h6><a id="__1151"></a>老年代垃圾回收算法 （标记清除算法）</h6> 
<p>首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。</p> 
<p>老年代的GC的耗时比较长，因为要扫描再回收。<br> GC会产生内存碎片，为了减少内存损耗，一般需要进行合并或者标记出来方便下次直接分配。</p> 
<p>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p> 
<hr> 
<h6><a id="_1165"></a>永久代</h6> 
<p>主要存放Class和Meta（元数据）的信息。<br> Class在被加载的时候放入永久区域。<br> 它和其他区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。</p> 
<p>在Java8中，永久代已经被移除，被“元数据区”（元空间）的区域所取代。</p> 
<p>元空间与永久代之间区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p> 
<hr> 
<h6><a id="_1177"></a>垃圾回收何时进行</h6> 
<p>当年轻代内存满时，会引发一次普通的局部GC，该GC仅回收年轻代。<br> 需要强调的是，年轻代满是指Eden代满，Survivor满不会引发GC。</p> 
<p>当老年代满时会引发全局GC（Full GC）将会同时回收年轻代、老年代。</p> 
<p>当永久代满时也会引发全局GC（Full GC），会导致Class、Method元信息的卸载。</p> 
<p>GC垃圾回收: 回收次数越少越好,回收时间越短越好</p> 
<hr> 
<h6><a id="_1193"></a>系统崩溃前的一些现象：</h6> 
<p>每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，<br> FullGC的时间也有之前的0.5s延长到4、5s。<br> FullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC，<br> 老年代的内存越来越大并且每次FullGC后老年代没有内存被释放。<br> 之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。</p> 
<h6><a id="dump_1201"></a>dump文件</h6> 
<p>通过JMX的MBean生成当前的Heap(堆栈）信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。然后选用Eclipse专门的静态内存分析工具：Mat分析该文件。</p> 
<hr> 
<h6><a id="TomcatJVM_1209"></a>Tomcat内存调整(JVM内存调整)</h6> 
<p>Tomcat内存优化主要是对 tomcat 启动参数优化，我们可以在 tomcat 的启动脚本 catalina.sh 中设置 JAVA_OPTS参数。<br> 例：</p> 
<pre><code>JAVA_OPTS="$JAVA_OPTS -server -Xms512m -Xmx512m -Xss256k  
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/heapdump 
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/tmp/heap_trace.txt 
-XX:NewSize=128m -XX:MaxNewSize=128m"
</code></pre> 
<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td></tr><tr><td>-Xmx</td><td>最大堆大小</td></tr><tr><td>-Xss</td><td>线程栈的大小,这个选项对性能的影响比较大,建议使用256K的大小。</td></tr><tr><td>-XX:NewRatio</td><td>年轻代和老年代的堆内存比例</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>控制JVM 在 OutOfMemoryError 时打印堆的信息</td></tr><tr><td>-XX:HeapDumpPath</td><td>指定堆信息文件的存储路径</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细的GC收集日志的信息</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>打印CG发生的时间戳</td></tr><tr><td>-Xloggc</td><td>设置GC打印的日志名称</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小</td></tr><tr><td>-XX:MaxNewSize</td><td>设置年轻代大小,通常会把-XX:newSize -XX:MaxNewSize设置为同样大小</td></tr><tr><td>-XX:SurvivorRatio</td><td>年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</td></tr><tr><td>-XX:MaxPermSize</td><td>设置永久代大小</td></tr><tr><td>-XX:PermSize</td><td>设置永久代大小</td></tr><tr><td>-XX:+UseParalledlOldGC</td><td>垃圾回收时，设置并行年老代收集器回收,在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC ，默认为Serial收集</td></tr><tr><td>-XX:+UseSerialGC</td><td>垃圾回收时，设置串行收集器回收</td></tr><tr><td>-XX:+UseParallelGC</td><td>垃圾回收时，设置并行收集器回收</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>垃圾回收时，设置并发收集器回收</td></tr></tbody></table> 
<hr> 
<h6><a id="_1254"></a>年轻代和老年代设置多大才合理</h6> 
<p>更大的年轻代必然导致更小的老年代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的老年代会导致更频繁的Full GC，更小的年轻代必然导致更大老年代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的老年代会减少Full GC的频率。</p> 
<p>如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：<br> （A）本着Full GC尽量少的原则，让老年代尽量缓存常用对象，JVM的默认比例1：2也是这个道理。<br> （B）通过观察应用一段时间，看其他在峰值时老年代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：4。但应该给老年代至少预留1/3的增长空间</p> 
<hr> 
<h6><a id="_1265"></a>调优方法</h6> 
<p>在调优之前，我们需要记住下面的原则：</p> 
<pre><code>1、多数的Java应用不需要在服务器上进行GC优化；
2、多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
3、在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
4、减少创建对象的数量；
5、减少使用全局变量和大对象；
6、GC优化是到最后不得已才采用的手段；
7、在实际使用中，分析GC情况优化代码比优化GC参数要多得多；
</code></pre> 
<p>GC优化的目的有两个:</p> 
<pre><code>1、将转移到老年代的对象数量降低到最小；
2、减少full GC的执行时间；
</code></pre> 
<p>为了达到上面的目的，一般地，你需要做的事情有：</p> 
<pre><code>1、减少使用全局变量和大对象；
2、调整年轻代的大小到最合适；
3、设置老年代的大小为最合适；
4、选择合适的GC收集器；
</code></pre> 
<p>GC调优是建立在GC监控和调优上的，进行监控和调优的一般步骤为：</p> 
<pre><code>1、监控GC的状态
使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；

2、分析结果，判断是否需要优化
如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；

注：如果满足下面的指标，则一般不需要进行GC：
Minor GC执行时间不到50ms；
Minor GC执行不频繁，约10秒一次；
Full GC执行时间不到1s；
Full GC执行频率不算频繁，不低于10分钟1次；

3、调整GC类型和内存分配
如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；

4、不断的分析和调整
通过不断的试验和试错，分析并找到最合适的参数

5、全面应用参数
如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。

</code></pre> 
<p>参考：<a href="https://oldqiang.com/archives/435.html" rel="nofollow">https://oldqiang.com/archives/435.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/55f5b86856d473fb895713586dee0915/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 集合框架：HashMap 的介绍、使用、原理与源码解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/569ff50cbb3200361464581bae9a7d87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 集合框架：TreeMap 的介绍、使用、原理与源码解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>