<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f796c1af4a1deabefb7a3a30653110/" rel="bookmark">
			数据结构--栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除 操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out） 的原则。 压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。 出栈：栈的删除操作叫做出栈。出数据也在栈顶。 二、栈的实现 栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上 插入数据的代价比较小 // 下面是定长的静态栈的结构，实际中一般不实用，所以我们主要实现下面的支持动态增长的栈 typedef int STDataType; #define N 10 typedef struct Stack { STDataType _a[N]; int _top; // 栈顶 }Stack; // 支持动态增长的栈 typedef int STDataType; typedef struct Stack { STDataType* _a; int _top; // 栈顶 int _capacity; // 容量 }Stack; 三、实现栈的函数 （1）.初始化栈 void StackInit(Stack* ps); 代码执行过程：
1. 首先使用断言（ assert ）确保传入的指针 ps 非空。如果 ps 为空指针，程序会终止并输出错误信息。
2. 尝试为栈分配一块初始大小为 4 个 STDataType 类型元素的内存空间。如果分配失败，打印“ malloc fail ”并退出程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68f796c1af4a1deabefb7a3a30653110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fb91f9203488301b6958a2c2487b77/" rel="bookmark">
			项目进度一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.双token验证登陆/注册 1.在前端中，得到响应记录acessToken和 refreshToken ,并记录在 localStorage中，当登录之后的请求都要携带着accessToken,如果accessToken过期，就再验证一下refreshToken，如果也过期就需要重新登录，并移除本地的token，如果没过期，就在后端生成一对新的Token，返回前端并储存到localStorage中，就自动续期成功了。
如果令牌过期，发送refreshToken请求，刷新token
二. 后端响应数据，渲染到前端上 在这里根据前端组件的id 找到前端组件，然后进行赋值。
三.个人信息界面 目前先画了这些
感觉画界面就是花太多时间了
在个人中心的导航栏可以直接copy blog博客主页的导航栏，修改一下细节，但是js
代码也是很难写
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/088de920181c2790ced8f53e0b96ae08/" rel="bookmark">
			MyBatis 源码解析：动态 SQL 生成的基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 MyBatis 提供了灵活的动态 SQL 功能，使得开发者可以根据业务需求在运行时生成不同的 SQL 语句。动态 SQL 是 MyBatis 最具特色的功能之一，它允许我们通过条件拼接来生成复杂的查询语句。本文将通过自定义实现一个简化的动态 SQL 生成器，解析其工作原理，并结合 MyBatis 的源码进行深入讲解。
前言 传统的 SQL 查询往往需要开发者根据不同的业务逻辑手动拼接 SQL 语句，而这种方式不仅容易出错，也不够灵活。MyBatis 通过动态 SQL 标签（如 &lt;if&gt;、&lt;choose&gt;、&lt;foreach&gt; 等）提供了更灵活的查询方式，允许我们在运行时根据不同条件生成 SQL 语句。本文将通过自定义实现一个简化的动态 SQL 生成器，深入解析其工作原理，并结合 MyBatis 的源码进行详细分析。
自定义实现：动态 SQL 生成器 目标与功能 我们将实现一个简化版的动态 SQL 生成器，支持以下核心功能：
条件判断：根据输入条件动态拼接 SQL 语句。组合条件：支持 AND 和 OR 等逻辑条件的组合。参数绑定：支持 SQL 语句中的参数占位符并绑定实际参数。动态拼接：通过链式调用轻松构建复杂 SQL 语句。 实现过程 为了实现一个灵活的动态 SQL 生成器，我们将从以下几个步骤开始：
SQL 语句构建：使用 StringBuilder 构建 SQL 语句片段，并根据不同条件判断是否拼接。参数绑定：通过占位符 ? 来处理 SQL 语句中的参数，并动态绑定参数。条件判断和组合：实现 if 和 where 条件的判断，确保生成的 SQL 语句语法正确。返回生成的 SQL 语句和参数：提供方法返回生成的 SQL 语句和绑定参数列表，供数据库执行使用。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/088de920181c2790ced8f53e0b96ae08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7a1f29e96c7ce57f20fcfc72339ac9/" rel="bookmark">
			如何选择SDR无线图传方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在开源软件定义无线电（SDR）领域，有几个项目提供了无线图传的解决方案。以下是一些开源SDR无线图传方案：
1. **OpenHD**：这是一个远程高清数字图像传输的开源解决方案，它使用SDR技术来实现高清视频的无线传输。OpenHD项目提供了一个完整的工具链，包括发射器和接收器的硬件设计以及相应的软件。
2. **USRP（Universal Software Radio Peripheral）**：由Ettus Research开发的USRP是一个灵活的SDR硬件平台，它可以用于无线图传应用。USRP支持广泛的频率范围和高数据传输率，适合研究和开发高级无线通信系统。
3. **GNU Radio**：这是一个开源的软件信号处理框架，可以用来开发各种无线通信系统，包括无线图传。GNU Radio提供了丰富的信号处理模块和算法，可以与USRP等硬件配合使用，实现定制化的无线图传解决方案。
4. **Osmosdr**：这是另一个开源的SDR库，它提供了对多种SDR硬件的支持，包括一些可以用于无线图传的设备。Osmosdr可以与GNU Radio等软件一起使用，以实现无线图传功能。
5. **SDR#（SDR Sharp）**：这是一个开源的SDR软件套件，它支持多种SDR硬件，并提供了一个用户友好的界面。SDR#可以用来开发和测试无线图传系统，尽管它更多地被用于业余无线电和信号接收。
6. **DJI SDR图传**：虽然DJI是一家商业公司，但它最近发布了基于SDR技术的DJI SDR图传产品。这款产品采用了SDR和Wi-Fi双制式图传技术，提供了高稳定性和穿透性的图传体验，适合专业影像创作者和高端应用场景。
在选择SDR无线图传方案时，需要考虑你的具体需求，包括传输距离、视频质量、系统复杂性以及预算。开源方案通常提供了高度的定制性，但可能需要更多的技术知识和开发工作。商业产品如DJI SDR图传则提供了即插即用的解决方案，但可能成本较高。
COFDM高清数字无线图传开发套件 https://www.eefocus.com/circuit/1161695.html 基于树莓派及OpenCV的无线图传系统设计 自制树莓派图传_mob64ca141a683a的技术博客_51CTO博客 无线图传mjpg-streamer精简版（开源）_开源图传-CSDN博客
https://github.com/BestAnHongjun/PicSocket 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca083b36b37332cba00015c9cd872f8/" rel="bookmark">
			JWT（JSON Web Token）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JWT JWT全称JSON Web Token（JSON Web令牌）
通过JSON形式作为Web应用令牌，用于在各方之间将信息作为JSON对象传输，在数据传输中完成数据加密，签名等相关处理。
作用：
授权：用户登录后，后续的请求将包括JWT令牌。从而允许用户访问该令牌允许的路由，服务和资源。开销较小，并且可以跨域使用。信息交换：在各方之间安全地传输信息。JWT可进行签名（如使用公钥/私钥对)，因此可确保发件人。由于签名是使用标头和有效负载计算的，因此还可验证内容是否被篡改。 认证流程：
前端通过Web表单将用户名和密码发送到后端接口（一般是POST请求）后端核对用户名和密码成功后，将用户id等其他信息作为JWT Pauload（负载），将其与头部分别进行Base64编码拼接签名，形成一个Token。后端将JWT字符串作为登录成功后的结果返回前端，前端将其保存在本地缓存，或者session缓存上，退出登录时删除缓存。前端每次请求时将JWT放入HTTP中Header后端检查是否存在，（验证JWT的有效性，检查签名是否存在，检查Token是否过期，验证Token的接收方式是否是自己）验证通过后可以进行操作，否则返回错误信息。 优点：
轻量简介：可以放在URL，POST参数或者请求头中，数据量小，传输速度快。自包含：包含了用户需要的信息，减少数据库的查询。以JSON形式保存在客户端中，任何web形式都支持。 结构：一个字符串，三部分组成，中间用. 隔开
标头有效负载签名 Header（标头）：有令牌的类型和使用的签名算法。
Payload（负载） ：有效负载，包含声明；声明是有关实体（通常是用户）和其他数据的声明，不放用户敏感的信息因为使用Base64编码（可逆的）
Signature （签名）：将编码后的标头和负载，加上我们提供的密钥，使用header中的签名算法进行签名（保证JWT没有被篡改）
们提供的密钥，使用header中的签名算法进行签名（保证JWT没有被篡改）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97fa82a1ea41b6fcabf8dfddadf65232/" rel="bookmark">
			【论文精读】 | 用于时间序列预测的通道对齐坚固的混合Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0、摘要1、介绍2、相关工作2.1 用于时间序列预测的Transformers2.2 用于时间序列预测的 RNN、MLP 和 CNN 模型 3、模型结构3.1 令牌化3.2 CARD 注意力胜过token3.3 CARD 注意力胜过渠道3.4 token 混合模块 4、基于信号衰减的损失函数5、实验5.1 长期预测5.2 基于重建的异常侦探5.3 基于信号衰减的增强效果Loss函数5.4 输入序列长度的影响5.5 TOKEN 混合大小的影响5.6 我们的实验 6、总结和未来工作 CARD: CHANNEL ALIGNED ROBUST BLEND TRANS
FORMER FOR TIME SERIES FORECASTING
标题： 卡片：用于时间序列预测的通道对齐坚固的混合Transformer
实验室环境：RTX 4090
文章链接：https://arxiv.org/abs/2305.12095
0、摘要 最近的研究表明，Transformer 模型在时间序列预测方面具有强大的功能。导致 transformer 成功的关键因素之一是用于提高训练鲁棒性的通道无关 （CI） 策略。然而，对 CI 中不同渠道之间相关性的无知会限制模型的预测能力。在这项工作中，我们设计了一个特殊的 Transformer，即 Channel Aligned Robust Blend Transformer（简称 CARD），它解决了 CI 型 Transformer 在时间序列预测中的关键缺点。首先，CARD 引入了一种通道对齐的注意力结构，使其能够捕获信号之间的时间相关性和多个变量随时间推移的动态依赖性。其次，为了有效地利用多尺度知识，我们设计了一个 token blend 模块来生成不同分辨率的 token。第三，我们引入了一个用于时间序列预测的稳健损失函数，以缓解潜在的过拟合问题。这个新的损失函数对基于预测不确定性在有限范围内进行预测的重要性进行了加权。我们对多个长期和短期预测数据集的评估表明，CARD 的性能明显优于最先进的时间序列预测方法。 1、介绍 时间序列预测已成为云计算、空气质量预测、能源管理和交通流量估计等各个领域的关键任务 。深度学习模型的快速发展导致了时间序列预测技术的重大进步，尤其是在多变量时间序列预测方面。在为时间序列预测开发的各种深度学习模型中，基于 RNN、CNN、MLP、transformer 和 LLM 的模型由于能够捕获复杂的长期时间依赖关系而表现出出色的性能 。对于多变量时间序列预测，模型有望通过利用不同预测变量之间的依赖关系，即所谓的通道相关 （CD） 方法，从而产生更好的性能。然而，最近的多项工作表明，一般来说，通道无关 （CI） 预测模型（即所有时间序列变量都是独立预测的）优于 CD 模型。 分析表明，CI 预测模型更稳健，而 CD 模型具有更高的建模能力。鉴于时间序列预测通常涉及高噪声水平，采用 CD 设计的典型基于 transformer 的预测模型可能会遇到过拟合噪声的问题，从而导致性能受限。这些实证研究和分析提出了一个重要问题，即如何构建一个有效的转换器来利用跨通道信息进行时间序列预测。 通道相关 （CD）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97fa82a1ea41b6fcabf8dfddadf65232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bc9101a13d697ac3656470f76ff4f7/" rel="bookmark">
			【即时通讯】轮询方式实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术栈 LayUI、jQuery实现前端效果。django4.2、django-ninja实现后端接口。
代码仓 - 后端
代码仓 - 前端 实现功能 首次访问页面并发送消息时需要设置昵称发送内容为空时要提示用户不能发送空消息前端定时获取消息，然后展示在页面上。 效果展示 首次发送需要设置昵称
发送消息与消息展示
提示用户不能发送空消息
后端接口 发送消息 DB = [] @router.post("/poll/send/message") def send_message_api(request: WSGIRequest, message: MessageSchema) -&gt; JsonResponse: """ 轮询通讯接收消息接口 :param request: WSGIRequest :param message: MessageSchema :return: JsonResponse """ message_info = message.dict() DB.append(message_info) return JsonResponse({"ok": True}) 获取消息 @router.get("/poll/get/messages") def get_messages_api(request: WSGIRequest, startIndex: int) -&gt; JsonResponse: """ 轮询通讯获取消息接口 :param request: WSGIRequest :param startIndex: int 上次获取聊天记录的最后位置 """ context = { "data": DB[startIndex:], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75bc9101a13d697ac3656470f76ff4f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396dcf83a004bc96587388a8fc76d38c/" rel="bookmark">
			java基础概念22-抽象类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、抽象类的引入 1-1、封装 问题：javabean越来越多。重复的内容越多——继承
1-2、继承 二、抽象类、抽象方法 一个方法抽取到父类中，不确定方法体——抽象方法
定义了抽象方法的类——抽象类。
在Java中，抽象类是一种特殊的类，它不能被实例化（即不能直接创建对象）。 2-1、定义抽象类 需要使用abstract关键字来声明一个类。
一个抽象类可以包含抽象方法和非抽象方法。抽象方法是没有方法体的方法，它也必须用abstract关键字来声明，且必须在子类中实现（除非子类也是抽象类）。
abstract class Animal { // 抽象方法 abstract void eat(); // 非抽象方法 void sleep() { System.out.println("Animal is sleeping"); } } 抽象方法必须以分号;结束。
【注意】：
抽象类可以有构造方法！ 作用：当创建子类对象时，给属性赋值。（给所有子类共有的属性赋值）
2-2、小结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cca99ef11575f804c0f08ee87b0aeaf/" rel="bookmark">
			Java 21的Preferences API的笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java Core LibrariesPreferences API
多用户环境下，应用程序保存配置参数的一种API，目前支持用户和系统两类配置。
在现有的项目中，目前没有使用过本API。Comparing the Preferences API to Other Mechanisms
通常，应用的开发者还可以使用Properties API或者JNDI API。Usage NotesObtain Preferences Objects for an Enclosing ClassObtain Preferences Objects for a Static MethodAtomic Updates
对多个参数的读、写操作，不支持事务。
对于需要保存的参数，可以合并为一个对象，作为一个参数的值来保存。Determine Backing Store Status
检查后端存储是否可用。Design FAQ 参考资料 Package java.util.prefsClass Preferences用 Preferences API 存储对象用Preferences API 存储对象 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315c15138656ef80f7cdbd04db4b8f74/" rel="bookmark">
			Vision Transformer(ViT)模型原理及PyTorch逐行实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vision Transformer(ViT)模型原理及PyTorch逐行实现 一、TRM模型结构 1.Encoder Position Embedding 注入位置信息Multi-head Self-attention 对各个位置的embedding融合（空间融合）LayerNorm &amp; ResidualFeedforward Neural Network 对每个位置上单独仿射变换（通道融合） Linear1(large)Linear2(d_model) LayerNorm &amp; Residual 2.Decoder Position EmbeddingCasual Multi-head Self-attentionLayerNorm &amp; ResidualMemory-base Multi-head Cross-attentionLayerNorm &amp; ResidualFeedforward Neural Network Linear1(large)Linear2(d_model) LayerNorm &amp; Residual 二、TRM使用类型 Encoder only 【 ViT 所使用的】 BERT、分类任务、非流式任务 Decoder only GPT系列、语言建模、自回归生成任务、流式任务 Encoder-Decoder 机器翻译、语音识别 三、TRM特点 无先验假设（例如：局部关联性、有序建模性）核心计算在于自注意力机制，平方复杂度数据量的要求与归纳偏置【人类通过归纳法得到的经验，把这些经验带入到模型中，很多事物的共性】的引入成反比 四、Vision Transformer(ViT) DNN perspective 图像的信息量主要还是聚集在一块区域上 image2patch 将图片切分成很多个块patch2embedding 将每个块转换为向量 CNN perspective 从卷积的角度得到向量 2D convolution over image 二维卷积flatten the output feature map 把输出的卷积图拉直 class token embedding 占位符position embedding interpolation when inference Transformer Encoder 只使用的Encoderclassification head 最后分类 五、ViT论文讲解 ​ 首先将一副图片分为很多个块，每个块的大小都是不会变化的，图片即使大一点，只是序列更长一点。先左到右，再上到下，把图片拉直成一个序列的形状。把每个块中的像素点进行归一化，范围变为0到1之间，再把块里面的所有值通过一个线性变换映射到模型的维度，得到patchembedding，得到以后，我们为了做分类任务，还需要在序列的开头加上一个可训练的embedding，这个是随机初始化的。这样就构造出了一个n+1长度的序列，然后我们再加入position embedding，加上后的这个序列的表征就可以送入到TRM的encoder当中，最后取出结果中的我们加入的可训练的embedding位置上的值（输出状态），经过一个MLP，得到各个类别的概率分布，再通过一个交叉熵函数算出分类的loss，这样就完成了一个ViT模型的搭建。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315c15138656ef80f7cdbd04db4b8f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb213328e7b66a1830193a2a462818de/" rel="bookmark">
			ue5 AI追角色后失去目标解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建接口
再到黑板中创建两个布尔变量
之后到AIcontroler中写下以下代码
再新建一个追寻到玩家最后位置的任务
最后在行为树中添加该任务，我这的逻辑是AI巡逻后发现玩家追逐玩家，如果此时AI看不到玩家了，也就是失去视野了，就执行追赶玩家到最后位置的任务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f866a498389efcfe2303059b954f0768/" rel="bookmark">
			分享一个基于微信小程序的医院挂号就诊一体化平台uniapp医院辅助挂号应用小程序设计（源码、调试、LW、开题、PPT)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💕💕作者：计算机源码社
💕💕个人简介：本人 八年开发经验，擅长Java、Python、PHP、.NET、Node.js、Android、微信小程序、爬虫、大数据、机器学习等，大家有这一块的问题可以一起交流！
💕💕学习资料、程序开发、技术解答、文档报告
💕💕如需要源码，可以扫取文章下方二维码联系咨询
💕💕Java项目
💕💕微信小程序项目
💕💕Android项目
💕💕Python项目
💕💕PHP项目
💕💕ASP.NET项目
💕💕Node.js项目
💕💕选题推荐
文章目录 1、研究背景2、研究目的和意义3、系统研究内容4、系统页面设计5、参考文献6、核心代码 1、研究背景 当前，随着医疗资源的紧张和就诊需求的增加，医院的传统挂号和就诊流程效率低下，患者需要长时间排队等待，特别是在三甲医院等大型医疗机构中，挂号难、就诊流程复杂等问题愈加突出。加之信息化技术的快速发展，许多医院逐步引入了线上服务平台来优化流程。然而，现有的系统功能分散，用户体验不佳。因此，基于微信小程序开发的医院挂号就诊一体化平台旨在解决这些问题，提升医院的服务效率。
2、研究目的和意义 该平台的开发目的是为患者提供从挂号、缴费到就诊的一站式服务，简化就诊流程，减少等待时间，提升就医体验。通过微信小程序，患者可以方便地进行线上挂号、查询医生信息、预约就诊、缴纳费用等操作。同时，平台通过数据整合，实现医院内部系统的无缝对接，提高医院管理效率，减轻医生和患者双方的压力，推动智慧医疗服务的进一步普及。
开发微信小程序医院挂号就诊一体化平台具有重要的现实意义和长远的社会价值。=它能够有效缓解医院内的排队压力，减少患者的等待时间，提升整体医疗服务效率。平台的开发为医院提供了一个便捷、高效的患者管理和信息流通途径，推动医院信息化建设，促进智慧医院的落地实施。该平台的广泛应用将为医疗资源的合理分配提供数据支持，有助于优化医疗服务流程，推动医疗行业的可持续发展。
3、系统研究内容 系统的研究内容包括以下几个方面：
用户需求分析与功能设计：通过调研患者和医院工作人员的实际需求，明确系统功能模块的设计思路。重点研究用户对挂号、预约、缴费、查询就诊记录等服务的需求，设计符合患者习惯的操作流程。同时，分析不同科室、医生排班及患者群体的特点，制定灵活的挂号策略和就诊提醒机制，确保系统能有效提升患者就医体验和医院管理效率。
系统架构与技术方案研究：基于微信小程序的特点，研究如何利用微信的开放接口实现与医院现有信息系统（HIS、PACS、LIS等）的无缝对接，确保挂号、缴费、就诊等功能流畅运作。系统架构设计需重点考虑数据传输的安全性与稳定性，确保用户信息和医疗数据在传输过程中的隐私保护。此外，研究如何通过小程序提升操作响应速度，优化用户体验。
核心模块实现与安全策略研究：研究系统的核心功能模块实现，包括挂号预约、医生排班、费用支付、就诊记录查询等模块的开发方案。同时，深入研究系统的数据加密、身份验证、支付安全等关键技术，确保用户数据安全和系统的稳定运行。在开发过程中，还需研究如何通过后台监控、预警等机制来及时发现并解决系统故障，保障用户的使用体验。
4、系统页面设计 如需要源码，可以扫取文章下方二维码联系咨询
5、参考文献 [1]陈炳旭,张鹏祥,张芝轩,等.“互联网+”口腔护理管理小程序的设计与应用[J].智能城市,2024,10(07):33-35.DOI:10.19301/j.cnki.zncs.2024.07.011.
[2]朱明,赖彬江,洪欣.面向住院陪护的电子陪护证的设计与实现[J].福建电脑,2024,40(07):68-75.DOI:10.16707/j.cnki.fjpc.2024.07.013.
[3]孟秋云.基于微信小程序的门诊预约功能设计与实现[J].电脑知识与技术,2024,20(18):50-52.DOI:10.14004/j.cnki.ckt.2024.0870.
[4]戚力天,宛楠,刘影.医院辅助挂号系统的应用小程序设计[J].福建电脑,2024,40(06):99-102.DOI:10.16707/j.cnki.fjpc.2024.06.019.
[5]贺靖轩.基于模式识别的冠心病和帕金森病症诊断方法研究[D].北方工业大学,2024. DOI:10.26926/d.cnki.gbfgu.2024.000097.
[6]陈琦棋,田思庆,陈鑫媛,等.一个基于微信小程序的陪诊服务平台设计与开发[J].科技传播,2024,16(10):125-128.DOI:10.16607/j.cnki.1674-6708.2024.10.017.
[7]罗莹,杜亚洲.基于微信小程序的学生实习管理系统设计[J].电子技术,2024,53(05):62-63.
[8]王梓春,刘宗旺,谢嘉伟,等.基于微信小程序的口腔医疗系统的设计与实现[J].电脑知识与技术,2024,20(14):52-55.DOI:10.14004/j.cnki.ckt.2024.0744.
[9]黄慈义.基于微信小程序的病案复印系统设计与实现[J].电脑知识与技术,2024,20(12):53-55.DOI:10.14004/j.cnki.ckt.2024.0633.
[10]王相喜,周晓波,倪甜弟.基于微信小程序的预约挂号系统的设计与实现[J].现代计算机,2024,30(08):116-120.
[11]魏潘晨.基于微服务器架构的慢阻肺数字化管理系统设计与实现[D].安徽师范大学,2024. DOI:10.26920/d.cnki.gansu.2024.000114.
[12]单月忠,严峰.移动端智慧化二级氧气箱小程序的开发及应用[J].医疗装备,2024,37(06):33-35+39.
[13]刘汉奕,黄俊闻,黄映欣,等.基于微信小程序云开发的牙齿健康检测系统的探索与设计[J].电子制作,2024,32(06):56+64-69.DOI:10.16589/j.cnki.cn11-3571/tn.2024.06.021.
[14]秦芹,靳晓剑,敬良原,等.基于云平台的无人医药配送系统软件设计[J].无线互联科技,2024,21(05):55-57.
[15]吴伟.融合导诊与导航功能的微信小程序在医疗机构中的应用研究[J].智能物联技术,2024,56(01):145-148.
[16]陈永秀.基于微信小程序医疗应急物资调配系统的设计与实现[J].科技资讯,2023,21(24):17-20.DOI:10.16661/j.cnki.1672-3791.2311-5042-8914.
[17]马传志,王蕊.基于ASP.NET后台的陪诊小程序开发与实现[J].电脑编程技巧与维护,2023,(12):52-54+100.DOI:10.16184/j.cnki.comprg.2023.12.016.
[18]褚水莲,冯琳,景行,等.戒烟微信小程序的开发及适用性评价[C]//中国控制吸烟协会.第二十四届全国控烟与健康学术研讨会论文摘要汇编.首都医科大学附属北京朝阳医院-北京市呼吸疾病研究所,烟草依赖治疗研究室;首都医科大学附属北京朝阳医院-北京市呼吸疾病研究所,呼吸与危重症医学科;,2023:1. DOI:10.26914/c.cnkihy.2023.119014.
[19]李麟豪,宛楠,高星明,等.医院自助机使用辅助系统的设计与研究[J].福建电脑,2023,39(12):75-79.DOI:10.16707/j.cnki.fjpc.2023.12.016.
[20]覃飞龙.基于互联网医院微信小程序的云探视设计与实现[J].现代信息科技,2023,7(23):42-45+51.DOI:10.19850/j.cnki.2096-4706.2023.23.009.
6、核心代码 /** * 门诊病历 * 后端接口 * @author * @email */ @RestController @RequestMapping("/menzhenbingli") public class MenzhenbingliController { @Autowired private MenzhenbingliService menzhenbingliService; /** * 后台列表 */ @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f866a498389efcfe2303059b954f0768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17d432b325027ccc15b59459fc7cf59/" rel="bookmark">
			请解释Java Web应用中的前后端分离是什么？它有哪些好处？什么是Java Web中的Servlet过滤器？它有什么作用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请解释Java Web应用中的前后端分离是什么？它有哪些好处？
Java Web应用中的前后端分离 在Java Web应用中，前后端分离是一种开发模式，它将传统Web开发中紧密耦合的前端（用户界面）和后端（服务器端逻辑）代码进行分离，使得它们能够独立开发、测试、部署和维护。在这种模式下，前端通常通过HTTP请求与后端进行数据交换，后端则负责业务逻辑处理、数据库交互以及向前端提供RESTful API或GraphQL等接口。
前后端分离的好处 提升开发效率： 并行开发：前端和后端可以同时进行开发，不需要等待对方完成才能进行下一步工作，从而大大缩短了项目周期。专业分工：前端开发者可以专注于用户界面和用户体验，而后端开发者则专注于服务器端的业务逻辑和数据处理，提高了开发效率和质量。降低耦合度： 前后端通过明确的接口进行交互，降低了代码之间的耦合度，使得修改和维护变得更加容易。当需要更换前端技术栈或后端框架时，只需调整接口协议，而不需要大规模修改对方代码。增强系统的可扩展性： 由于前端和后端是分离的，因此可以独立地对它们进行扩展或优化，而不会影响到对方。例如，当需要支持更多的用户或处理更多的并发请求时，可以单独对后端进行扩展，而无需改动前端代码。提升用户体验： 前端可以更加灵活地处理用户交互和展示逻辑，使用最新的前端技术栈和框架来优化用户体验。同时，由于前端可以缓存数据和逻辑，减少了对后端的依赖和请求次数，提高了应用的响应速度和流畅性。便于团队协作： 前后端分离使得团队成员可以更加专注于自己的领域，减少了跨领域沟通的成本和误解。同时，也使得项目管理和任务分配变得更加清晰和高效。易于测试和维护： 前后端分离使得测试可以分别进行，前端测试主要关注用户界面和交互逻辑，而后端测试则关注业务逻辑和数据正确性。在维护阶段，也可以分别对前端和后端进行修复和优化，提高了维护的效率和质量。 总之，前后端分离是现代Web开发中的一种重要趋势，它带来了诸多好处，包括提升开发效率、降低耦合度、增强系统的可扩展性、提升用户体验、便于团队协作以及易于测试和维护等。在Java Web应用中采用前后端分离的开发模式，可以使得项目更加高效、灵活和可扩展。
什么是Java Web中的Servlet过滤器？它有什么作用？
在Java Web开发中，Servlet过滤器（Servlet Filter）是一种可以复用于多个Servlet或JSP页面的Java组件，它能够对发送到Servlet或JSP的请求以及从Servlet或JSP发出的响应进行拦截和处理。过滤器可以修改请求头、请求数据、响应头、响应数据等，甚至可以在请求到达目标资源之前或响应发送给客户端之前中断请求-响应链。
Servlet过滤器的作用： 请求预处理：在请求到达Servlet或JSP之前，过滤器可以对请求进行预处理。例如，它可以检查请求是否包含必要的HTTP头信息，或者对请求参数进行解码、解密等。
响应后处理：在Servlet或JSP生成响应后，但在响应发送给客户端之前，过滤器可以对响应进行后处理。例如，它可以添加额外的HTTP头信息，修改响应内容，或者对响应进行压缩以减少传输数据量。
日志记录：过滤器可以用来记录请求和响应的详细信息，这对于监控Web应用的性能和调试问题非常有用。
身份验证和授权：过滤器可以检查用户是否已登录，以及用户是否有权限访问特定的资源。如果请求未通过身份验证或授权，过滤器可以重定向用户到登录页面或显示错误消息。
字符编码统一：过滤器可以确保所有请求和响应都使用统一的字符编码，从而避免乱码问题。
敏感信息处理：过滤器可以检查请求或响应中是否包含敏感信息，并对其进行适当的处理，如加密或删除。
请求和响应的封装：过滤器可以封装请求和响应对象，为它们提供额外的功能或属性，使得在Servlet或JSP中处理请求和响应变得更加方便。
实现Servlet过滤器： 要实现一个Servlet过滤器，你需要创建一个实现了javax.servlet.Filter接口的类。这个接口包含三个方法：init(FilterConfig filterConfig)、doFilter(ServletRequest request, ServletResponse response, FilterChain chain)和destroy()。其中，doFilter方法是过滤器的核心，它定义了过滤器对请求和响应的处理逻辑。
在doFilter方法中，你可以通过调用chain.doFilter(request, response)将请求传递给下一个过滤器（如果有的话）或目标资源（如Servlet或JSP）。在调用chain.doFilter之前或之后，你可以对请求和响应进行预处理或后处理。
部署Servlet过滤器： 要在Web应用中部署Servlet过滤器，你需要在web.xml文件中声明它，并指定它应该拦截哪些请求。从Servlet 3.0开始，你也可以使用注解（如@WebFilter）来声明过滤器，这样可以省去修改web.xml的麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c390366bc30639a68ac31b37e92524/" rel="bookmark">
			常见的排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 常见的10大排序，这里先详细的介绍前7种排序；
稳定性：
定义：如果两个元素具有相同的关键字，那么在排序后他们的相对顺序不变；
排序前有标记的5在前面，排序后依旧在前面即稳定，如果位置互换了就不稳定；
直接插入排序 - 原理：将未排序的数据插入到已排序部分的合适位置。通常从第二个元素开始，将其与前面已排好序的元素进行比较，找到合适位置插入。
- 使用场景：对于接近有序的数组效率较高。
- 与其他算法的联系：希尔排序是对插入排序的优化。插入排序在处理部分有序数据时具有一定优势，其思想在一些高级算法处理小规模数据时也会被借鉴，比如快速排序在处理小规模数据时可能会切换为插入排序。
代码：
public void Insertint(int[] array){ for (int i = 1; i &lt; array.length; i++) { int j=i-1; int tem=array[i]; for ( ; j &gt;=0; j--) { if(array[j]&gt;tem){ array[j+1]=array[j]; }else { array[j+1]=tem; break; } array[j]=tem; } } } 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：稳定
希尔排序 - 原理：对插入排序的一种优化，通过设置不同的步长序列，逐步对数据进行分组和局部排序，最终实现整体数据的有序。
- 使用场景：中等规模数据的排序。
- 与其他算法的联系：源于插入排序，通过改进插入排序的方式提高效率。在处理某些数据时，性能可能介于简单排序算法和高级排序算法之间。
代码：
public void shell(int[] array){ int gap=array.length/2; while (gap&gt;0){ shellsert(array,gap); gap=gap/2; } } private void shellsert(int[] array, int gap) { for (int i = gap; i &lt; array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c390366bc30639a68ac31b37e92524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d9df13adce55a853a35ef6db972b723/" rel="bookmark">
			炮弹【USACO】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景 时/空限制：1s / 64MB
题目描述 贝茜已经精通了变成炮弹并沿着长度为 N 的数轴弹跳的艺术，数轴上的位置从左到右编号为 1,2,…,N 。
她从某个整数位置 S 开始，以 1 的起始能量向右弹跳。
如果贝茜的能量为 k ，则她将弹跳至距当前位置向前距离 k 处进行下一次弹跳。
从 1 到 N 的每个整数位置上均有炮击目标或跳板。
每个炮击目标和跳板都有一个在 0 到 N 范围内的整数值。
一个数值为 v 的跳板会使贝茜的能量增加 v 并反转她的方向。
一个数值为 v 的炮击目标会当着陆时能量不小于 v 时被击破。
着陆在炮击目标上不会改变贝茜的能量和方向。
被击破的炮击目标将保持击破状态，贝茜依然可以该炮击目标上弹跳，同样不会改变能量和方向。
如果贝茜弹跳无限长的时间直到她离开数轴，她会击破多少个炮击目标？
如果贝茜开始时位于一个她可以击破的炮击目标，她会立刻将其击破。
类似地，如果贝茜开始时位于一个跳板，跳板的效果将在她第一次跳跃之前生效。
输入格式 输入的第一行包含 N 和 S ，其中 N 为数轴的长度，S 为贝茜的起始位置。
以下 N 行描述了每一个位置。其中第 i 行包含整数 qi 和 vi ，如果位置 i 上有一个跳板则 qi=0 ，位置 i 上有一个炮击目标则 qi=1 ，vi 是位置 i 上的跳板或炮击目标的数值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d9df13adce55a853a35ef6db972b723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58902b722fa096a22d9a3fe8f2f339a9/" rel="bookmark">
			面对养老困局我心安若素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“2025年，我们需要注意什么？是复杂的国际环境么？明年对于我国70岁以上的老年人来说这可不是主要关心的问题。反而有这两件事情需要他们来关注，如果70岁老人不提前做好准备，可能会有非常严重的后果......”这是昨天发表在网络空间的《70岁的老人要做好准备，从明年开始，老人或将面临两大现实问题》一文的《前言》。
网络图片：相依为命的老人
真有点儿危言耸听，但并非完全是危言耸听。而且这么一绕，也就绕出许多唠嗑来了。
毫无疑问，随着生育率的下降和人均寿命的延长（今年老龄人平均年龄为78.6岁），我国正面临人口老龄化的问题。老年人口比重不断增加，给养老、医疗、社会保障等带来日益加重的压力。预计到2030年，65岁及以上人口的占比将攀升至25%，也就是说，5年后每4个中国人中就会有一个人步入老年阶段。更令人忧虑的是到了2050年，这个比率可能会大幅增长至全国人口的三分之一，而这种人口构成的剧变又必将对社会经济成长构成史无前例的挑战。
但“人口老龄化”也非中国人的专利，因为它是全球许多国家所共同面对的难题。
比如美国，65岁及以上人群的比例达到17%，即使其财力雄厚，也难扛住冲击。
比如日本，65岁及以上人群已经超过全国人口的30%，应是当前面临全球最严峻的老龄化挑战的国家。
网络图片：老龄化世界之最的日本
相比之下，尽管我国人口老龄化进程的开始时间较晚，但却以惊人的速度发展，表明我国在应对人口老龄化考验时，必将遭遇更加复杂\艰巨的挑战。
4个月过后本笔者满79岁，有幸稍微超越了今年我国老龄人的平均年龄，纵然明晨永远醒不过来，也算个准长寿老人，不是短命鬼。然而，鄙人不会因此而幸灾乐祸。因为必定会有一些同胞没能有我这般幸运，他们迟早将会面临老无所依的窘境，令我黯然神伤！而且还不仅是老龄化，同时也将伴随着青少年人口的大幅下降而出现的诸多社会困境。
如果说，老无所依的灾难真的到来，就一定会是全社会都无法承受之重。因为老年人失去了未来养老的保障，而年轻人也必将陷入对未来老年生活的无尽焦虑——这才是现在三世同堂的我们，所应着重关切的重大问题，即我们到底应该如何应对人口老龄化危机？
清华大学教授宁向东曾经讲过：“国人老无所依，是一场即将到来的可怕危机。”他说这句话的前提是，人一旦进入迟暮之年，身体状况和精气神都将不复以往，在急需要他人照顾的时候，许多老人将得不到很好的照顾，甚至是根本得不到照顾。
笔者认为，宁向东讲的“国人老无所依，是一场即将到来的可怕危机”，而我漓这个危机也仅一步之遥。因为我现在所寄居养老之地，颤颤巍巍走路的白发老人，举目可见，而且时不时听说某大爷或某大婆“走了”，那种兔死狐悲的凄凉情绪就免不了要袭上心头，发出轻微的颤栗。人之常情啊！
​网络图片：要有尊严地“走”
大家都知道，我国人口老龄化的发展速度，可能将会超过我国社会发展及其所能承受的耐力。我们眼睁睁看着劳动力红利时代正在快速衰退，而在不远的、未知的将来，却又一定会彻底的成为过去时，曾经年轻的劳动力已变成老人之后，定会明白当初的人口红利有多么旺盛，将来的养老困局就有定会有多么严峻。
世间万物万事，有右便有左，有上也便有下，一切事物都是这样成正比的存在着，也同样是成正比的消亡着，无一幸免。明白了这个道理，本老龄笔者面对正在靠近的“老无所依”，已然是心安若素、不惊不乍，力求不当子孙的累赘，也力求留下一个“活着有尊严、死也有尊严”的人生结局。古书上不是常见有“20年后又是一条好汉”之说吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe20c23c2b8f934febbd6c95d18ace1/" rel="bookmark">
			以项目方式推动数字化规划落地，以产品思维运营IT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在企业数字化转型的过程中，我们可以借鉴华为的“以项目方式推动数字化规划落地和以产品思维运营IT”这两个重要的策略。值得读者借鉴~
以项目方式推动数字化规划落地是一种高效、有组织的实施策略，它能够确保数字化转型过程中的各项任务得到有序执行和监控。以产品思维运营IT是指将IT系统视为产品，采用产品化的方式进行规划、开发、运营和优化。
一、以项目方式推动数字化规划落地 1. 战略规划与项目分解
顶层设计与蓝图规划：华为在数字化转型之初，就进行了详细的顶层设计和战略规划，明确了转型的愿景、目标、路径和关键领域。这确保了数字化转型的方向清晰，避免了盲目行动和资源浪费。
项目化运作：基于战略规划，华为将数字化转型分解为一系列具体的项目。每个项目都有明确的目标、范围、时间表、预算和资源分配。这种项目化运作的方式，使得数字化转型工作更加有序、可控和高效。
2. “七横八纵”项目管理框架
纵向管理：华为的“七横八纵”项目管理框架在纵向上展示了变革项目实施的各个阶段，包括项目启动、规划、执行、监控和收尾等。每个阶段都有明确的任务和里程碑，确保项目按计划推进。
横向管理：在横向上，该框架展示了贯穿变革始终的关键要素，如项目团队、利益相关者、风险、变更等。通过对这些关键要素的有效管理和控制，华为能够确保项目在实施过程中能够全面覆盖各个环节，减少遗漏和偏差。
3. 价值为纲的项目生命周期管理
TAM模型：华为设计了TAM（变革价值度量）模型，从结果、能力及管理体系三个方面指导项目进行价值管理。该模型帮助项目团队在项目全生命周期内持续关注并衡量项目的价值贡献，确保项目成果能够真正满足业务需求并带来实际价值。
4. 内部交付契约价值承诺书（Value Book）
价值清晰化：华为以内部交付契约价值承诺书为抓手，对变革项目进行全生命周期管理。价值承诺书用业务的语言清晰地写明了数字化的价值主张、预期成果和衡量标准。这有助于项目团队在项目启动之初就明确目标、达成共识，并在项目实施过程中持续跟踪和评估价值实现情况。
二、以产品思维运营IT 1. IT系统的重新定位
从工具到平台：在数字化转型下，华为将IT系统重新定位为业务开展的“作业平台”而非仅仅是固化流程的工具。这意味着IT系统需要更加贴近业务需求、提升用户体验和响应速度。
2. 业务与IT一体化融合运作
一体化产品团队：华为推动业务部门和IT部门的深度融合，打造一体化产品团队。团队成员既懂业务又懂IT，能够共同设计和交付满足业务需求的IT产品和解决方案。这种一体化融合运作的方式有助于打破部门壁垒、促进跨部门协作和提升整体效能。
3. 产品思维管理IT
全生命周期管理：华为引入产品思维来管理IT系统，强调全生命周期管理的重要性。从需求分析、设计开发、测试验证到部署上线和持续优化，每个环节都需要紧密围绕业务需求进行。同时，通过敏捷迭代和持续创新的方式，确保IT系统能够始终满足业务需求的变化。
4. 松耦合的服务架构
灵活编排与独立交付：华为将IT系统拆分为一个个松耦合的服务组件，使得服务可以独立交付并基于业务场景进行灵活编排。这种服务架构极大地提升了交付效率和灵活性，使得IT系统能够更快地响应业务需求的变化并支持业务的快速发展。
图：华为服务化V模型
三、结合应用 在华为数字化转型的实践中，以项目方式推动数字化建设和以产品思维运营IT这两个策略是紧密结合、相互促进的。具体来说：
项目方式确保有序推进：通过项目化运作的方式，华为能够确保数字化转型工作有序、可控和高效推进。每个项目都有明确的目标、范围、时间表和预算等资源分配，有助于减少浪费和偏差并确保转型成果符合预期。
产品思维提升IT效能：以产品思维来管理IT系统，使得IT系统更加贴近业务需求、提升用户体验和响应速度。通过业务与IT一体化融合运作、全生命周期管理和松耦合服务架构等方式，华为不断提升IT系统的效能和灵活性以支持业务的快速发展和变革需求。
综上所述，华为在数字化转型过程中通过结合以项目方式推动数字化规划落地和以产品思维运营IT这两个策略实现了转型工作的有序推进和IT系统的持续优化及效能的显著提升。这对于其他正在或准备进行数字化转型的企业来说具有重要的借鉴意义。
往期回顾&gt;&gt;
企业4A架构：数字化转型的底层方法论（附TOGAF资料下载）
华为：数据入湖，企业数据的逻辑汇聚（附数据湖建设方案下载）
PPT分享：数据治理的方法论、设计思路与方案（干货）
浅谈数字化转型方法论
110页PPT:xx业务流程优化（BPR）方法论
PPT分享：某集团主数据治理项目方案与主数据治理方法论
华为数字化转型方法论：六步法，附华为数字化转型案例合集PPT下载：
麦肯锡结构化战略思维方法论，助力需求管理
PPT分享：埃森哲的IT与战略规划方法论
100页PPT:工业互联网平台赋能制造业数字化转型方法论
华为数字化转型方法论：六步法
48页PPT：华为流程管理和持续优化方法论
IBM企业流程框架方法论-附PPT下载
德勤卓越业务流程管理方法论及案例
52页PPT数据架构-数字化转型数据架构规划设计（方法论与案例）
从Gartner冰山模型解读数字化转型的背后逻辑
数字化转型解决时代难题：鲍莫尔成本病（106页PPT:华为数字化转型案例合集）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8278276371180e7fbe897bf092b5b1/" rel="bookmark">
			C&#43;&#43;复习day05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和对象 1. 面向对象和面向过程的区别是什么？（开放性问题） 1. **抽象级别**： - **面向对象**：以对象（数据和方法的集合）为中心，强调的是数据和行为的封装。 - **面向过程**：以过程（函数或子程序）为中心，强调的是步骤和顺序。 2. **数据和方法的关系**： - **面向对象**：数据和处理数据的方法封装在对象中，对象可以包含数据和操作数据的方法。 - **面向过程**：数据和处理数据的方法是分离的，通常数据结构和处理这些数据的函数是分开的。 3. **模块化**： - **面向对象**：通过类和对象来实现模块化，类定义了对象的蓝图。 - **面向过程**：通过函数和过程来实现模块化，函数是独立的代码块。 4. **代码重用**： - **面向对象**：通过继承和多态性，可以更容易地重用代码。 - **面向过程**：代码重用通常通过函数库来实现，但可能不如面向对象那样灵活。 5. **维护和扩展**： - **面向对象**：由于封装和模块化，通常更容易维护和扩展。 - **面向过程**：随着系统的增长，维护和扩展可能会变得更加困难。 6. **设计复杂性**： - **面向对象**：设计可能更复杂，因为需要考虑类之间的关系和继承结构。 - **面向过程**：设计可能更直接，因为关注点在于函数的调用和执行。 7. **语言支持**： - **面向对象**：许多现代编程语言（如Java、C++、Python、Ruby）天然支持面向对象编程。 - **面向过程**：几乎所有编程语言都支持过程化编程，但一些语言（如C）在支持面向对象特性方面可能不如其他语言。 8. **性能**： - **面向对象**：可能会有额外的开销，因为需要处理对象的创建和方法调用。 - **面向过程**：通常在性能上更高效，因为直接调用函数通常比创建对象和调用方法更快。 2.类大小的计算 这里同样是和结构体的内存对齐做法相同，需要注意的是空类的大小是1（主要是为了在地址空间中占位，表示存在这个类）
3.class和struct的区别 struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装；struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如： struct A{ int iNum; // 默认访问控制权限是 public } class B{ int iNum; // 默认访问控制权限是 private } 在继承关系中，struct 默认是公有继承，而 class 是私有继承；class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如： template&lt;typename T, typename Y&gt; // 可以把typename 换成 class int Func(const T&amp; t, const Y&amp; y) { //TODO } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b8278276371180e7fbe897bf092b5b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9219b93aaddef16f12d166b87f2e4de/" rel="bookmark">
			力扣 739. 每日温度【经典单调栈题目】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 题目 理解题意：
1.1. 给一个温度集合， 要返回一个对应长度的结果集合， 这个结果集合里面的元素 i 是 当前 i 位置的元素的下一个更高温度的元素的位置和当前 i 位置的距离之差， 若是当前元素不存在下一个更高温度的元素， 则这个位置用0代替； 2. 思路 本题用单调栈来求解；单调栈就适用于来求当前元素左边或者右边第一个比当前元素大或者小的元素；【单调栈：让栈中的元素保持单调递增或者递减】简单的说， 单调栈的作用就是存放遍历过的元素！
3.1. 可以将单调栈看成一种缓存机制， 只存《以后》要用到的元素！
3.2 简单说：我们在遍历的时候遍历到当前的元素， 我们并不清楚之前都遍历过哪些元素了， 那么不知道之前遍历过哪些元素， 那就不知道这个元素有没有可能比之前的某个元素大？这个元素有没有可能是之前某一个元素右边第一个比前面某个元素大的元素呢？所以需要一个数据结构来记录我们之前遍历过的元素！
3.3 本题单调栈的作用就是：记录遍历过的元素然后和当前遍历到的元素做一个对比， 看是不是《所谓下一个更大！！！》思考一下，有三种情况：【这一题栈存放的是下标而不是元素， 所以要做个映射， 要这样表示：T[i] 与 T[st.top()]；】【T[i] 是当前遍历到的元素， T[st.top] 栈顶下标对应的温度】
4.1. 当前遍历的元素 &gt; 栈口（top）元素;
4.2. 当前遍历的元素 = 栈口（top）元素;
4.3. 当前遍历的元素 &lt; 栈口（top）元素;做个模拟：【可以自己试一下】【:index】， 以T:[73, 74, 75, 71, 69, 69, 72, 76, 73] 为例子；【单调栈：记录我们之前遍历过的元素！】 先将 73【0】 入栈， 接着遍历下一个元素， 74【1】， 而74【1】 &gt; 73【0】， 则更新result 数组， result[st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9219b93aaddef16f12d166b87f2e4de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8c683047c6116b6101ec4460b9f0a6/" rel="bookmark">
			华为23年笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息传输
题目描述 在给定的 m x n (1 &lt;= m, n &lt;= 1000) 网格地图 grid 中，分布着一些信号塔，用于区域间通信。
每个单元格可以有以下三种状态： 值 0 代表空地，无法传递信号； 值 1 代表信号塔 A，在收到消息后，信号塔 A 可以在 1ms 后将信号发送给上下左右四个方向的信号塔；
值 2 代表信号塔 B，在收到消息后，信号塔 B 可以在 2ms 后将信号发送给上下左右四个方向的信号塔。
给定一个坐标 (j, k)，输入保证坐标 (j, k) 位置一定有信号塔。在坐标 (j, k) 位置的信号塔触发一个信号。 要求返回网格地图中所有信号塔收到信号的最短时间，单位为 ms。如果有信号塔无法收到信号，则返回 -1。
输入描述 第一行：网格的列数 n。 第二行：网格的行数 m。 第三行：触发信号的信号塔坐标 (j, k)。 接下来的 m 行：每行包含 n 个整数，表示该行网格中每个位置的信号塔安装信息（通过空格间隔每个状态值）。
输出描述 输出返回 网格地图中所有信号塔收到信号的最小时间，单位为ms。如果不可能，返回-1。
输入示例 3 3 1 0 0 1 2 1 2 1 0 1 2 输出示例 4 思路:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8c683047c6116b6101ec4460b9f0a6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>