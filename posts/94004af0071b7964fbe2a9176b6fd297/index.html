<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【QT】Qt 窗口 (QMainWindow) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/94004af0071b7964fbe2a9176b6fd297/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【QT】Qt 窗口 (QMainWindow)">
  <meta property="og:description" content="Qt 窗口 一、菜单栏1. 创建菜单栏并添加菜单2. 创建菜单项3. 综合示例 二、工具栏1. 创建工具栏2. 设置停靠位置3. 设置浮动属性4. 综合示例 三、状态栏1. 状态栏的创建2. 在状态栏中显示实时消息3. 在状态栏中显示永久消息 四、浮动窗口1. 浮动窗口的创建2. 设置停靠的位置 五、对话框1. 对话框介绍2. 对话框分类3. Qt 内置对话框 Qt 窗口是通过 QMainWindow类 来实现的。
QMainWindow 是一个为用户提供主窗口程序的类，继承自 QWidget 类，并且提供了一个预定义的布局。QMainWindow 包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个浮动窗口（铆接部件）(dock widgets)、⼀个状态栏(status bar) 和⼀个 中心部件(central widget)，它是许多应用程序的基础，如文本编辑器，图片编辑器等。如下图为 QMainwindow 中 各组件所处的位置：
一、菜单栏 Qt 中的菜单栏是通过 QMenuBar 这个类来实现的。⼀个主窗口最多只有⼀个菜单栏。位于主窗口顶部、主窗⼝标题栏下面。
菜单栏中包含菜单. 菜单中包含菜单项.
1. 创建菜单栏并添加菜单 菜单栏的创建可以借助于 QMainWindow类 提供的 menuBar() 函数来实现。创建菜单，并通过 QMenu 提供的 addMenu() 函数 来添加菜单。
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); // 创建菜单栏 // QMenuBar* menubar = menuBar(); QMenuBar* menubar = new QMenuBar(this); this-&gt;setMenuBar(menubar); // 添加菜单 QMenu* menu1 = new QMenu(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T14:17:51+08:00">
    <meta property="article:modified_time" content="2024-07-15T14:17:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【QT】Qt 窗口 (QMainWindow)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Qt 窗口</h4> 
 <ul><li><a href="#_14" rel="nofollow">一、菜单栏</a></li><li><ul><li><a href="#1__27" rel="nofollow">1. 创建菜单栏并添加菜单</a></li><li><a href="#2__53" rel="nofollow">2. 创建菜单项</a></li><li><a href="#3__84" rel="nofollow">3. 综合示例</a></li></ul> 
  </li><li><a href="#_191" rel="nofollow">二、工具栏</a></li><li><ul><li><a href="#1__201" rel="nofollow">1. 创建工具栏</a></li><li><a href="#2__214" rel="nofollow">2. 设置停靠位置</a></li><li><a href="#3__263" rel="nofollow">3. 设置浮动属性</a></li><li><a href="#4__283" rel="nofollow">4. 综合示例</a></li></ul> 
  </li><li><a href="#_321" rel="nofollow">三、状态栏</a></li><li><ul><li><a href="#1__333" rel="nofollow">1. 状态栏的创建</a></li><li><a href="#2__345" rel="nofollow">2. 在状态栏中显示实时消息</a></li><li><a href="#3__354" rel="nofollow">3. 在状态栏中显示永久消息</a></li></ul> 
  </li><li><a href="#_379" rel="nofollow">四、浮动窗口</a></li><li><ul><li><a href="#1__385" rel="nofollow">1. 浮动窗口的创建</a></li><li><a href="#2__407" rel="nofollow">2. 设置停靠的位置</a></li></ul> 
  </li><li><a href="#_427" rel="nofollow">五、对话框</a></li><li><ul><li><a href="#1__430" rel="nofollow">1. 对话框介绍</a></li><li><a href="#2__436" rel="nofollow">2. 对话框分类</a></li><li><a href="#3_Qt__542" rel="nofollow">3. Qt 内置对话框</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>Qt 窗口是通过 QMainWindow类 来实现的。</p> 
<p>QMainWindow 是一个为用户提供主窗口程序的类，继承自 QWidget 类，并且提供了一个预定义的布局。QMainWindow 包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个浮动窗口（铆接部件）(dock widgets)、⼀个状态栏(status bar) 和⼀个 中心部件(central widget)，它是许多应用程序的基础，如文本编辑器，图片编辑器等。如下图为 QMainwindow 中 各组件所处的位置：</p> 
<p><img src="https://images2.imgbox.com/99/0c/Hg3mnW0D_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_14"></a>一、菜单栏</h2> 
<p>Qt 中的菜单栏是通过 QMenuBar 这个类来实现的。⼀个主窗口最多只有⼀个菜单栏。位于主窗口顶部、主窗⼝标题栏下面。</p> 
<p>菜单栏中包含菜单. 菜单中包含菜单项.</p> 
<p><img src="https://images2.imgbox.com/48/42/4rwsDxve_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__27"></a>1. 创建菜单栏并添加菜单</h3> 
<p>菜单栏的创建可以借助于 QMainWindow类 提供的 menuBar() 函数来实现。创建菜单，并通过 QMenu 提供的 addMenu() 函数 来添加菜单。</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    ui-&gt;setupUi(this);
			
			    // 创建菜单栏
			    // QMenuBar* menubar = menuBar();
			    QMenuBar* menubar = new QMenuBar(this);
			    this-&gt;setMenuBar(menubar);
			
			    // 添加菜单
			    QMenu* menu1 = new QMenu("文件");
			    QMenu* menu2 = new QMenu("保存");
			    QMenu* menu3 = new QMenu("编辑");
			    menubar-&gt;addMenu(menu1);
			    menubar-&gt;addMenu(menu2);
			    menubar-&gt;addMenu(menu3);
			}
</code></pre> 
<h3><a id="2__53"></a>2. 创建菜单项</h3> 
<p>在 Qt 中，并没有专⻔的菜单项类，可以通过 QAction 类，抽象出公共的动作。如在菜单中添加菜单项.</p> 
<p>QAction 可以给菜单栏使⽤, 也可以给⼯具栏使⽤.</p> 
<p>修改 mainwindow.cpp ：</p> 
<pre><code>		    // 添加菜单项
		    QAction* action1 = new QAction("save");
		    QAction* action2 = new QAction("quit");
		    QAction* action3 = new QAction("open");
		    menu1-&gt;addAction(action1);
		    menu1-&gt;addAction(action2);
		    menu1-&gt;addAction(action3);
</code></pre> 
<p>在菜单项之间可以添加分割线。分割线如下图所⽰，添加分割线是通过 QMenu 类 提供的 addSeparator() 函数来实现：</p> 
<pre><code>		    menu1-&gt;addAction(action1);
		    menu1-&gt;addSeparator();
		    menu1-&gt;addAction(action2);
		    menu1-&gt;addSeparator();
		    menu1-&gt;addAction(action3);
</code></pre> 
<h3><a id="3__84"></a>3. 综合示例</h3> 
<p>在窗⼝上创建⼀个菜单栏，在菜单栏中添加⼀些菜单，在某⼀个菜单中添加⼀些菜单项。</p> 
<p>（1）在 “mainwindow.cpp” ⽂件中创建菜单和中央控件</p> 
<ul><li> <p>创建⼀个菜单栏, ⼀个菜单.</p> </li><li> <p>两个菜单项: 保存, 加载</p> </li><li> <p>创建⼀个 QTextEdit 作为窗⼝的中央控件.</p> <pre><code>  		MainWindow::MainWindow(QWidget *parent)
  		    : QMainWindow(parent)
  		    , ui(new Ui::MainWindow)
  		{
  		    ui-&gt;setupUi(this);
  		
  		    // 设置标题
  		    this-&gt;setWindowTitle("记事本");
  		
  		    // 创建菜单栏
  		    QMenuBar* menubar = new QMenuBar(this);
  		    this-&gt;setMenuBar(menubar);
  		
  		    // 创建菜单
  		    QMenu* menu = new QMenu("文件");
  		    menubar-&gt;addMenu(menu);
  		
  		    // 创建菜单项
  		    QAction* action1 = new QAction("保存");
  		    QAction* action2 = new QAction("加载");
  		    menu-&gt;addAction(action1);
  		    menu-&gt;addAction(action2);
  		
  		    // 创建中央控件，添加 edit 为成员变量，方便后面使用
  		    edit = new QTextEdit(this);
  		    this-&gt;setCentralWidget(edit);
  		    edit-&gt;setPlaceholderText("此处编写文本内容");
  		}
</code></pre> </li></ul> 
<p>（2）给 action 添加⼀些动作</p> 
<pre><code>			// 连接信号槽, 点击 action 时触发⼀定的效果.
		    connect(action1, &amp;QAction::triggered, this, &amp;MainWindow::save);
		    connect(action2, &amp;QAction::triggered, this, &amp;MainWindow::load);
</code></pre> 
<p>实现这两个槽函数：</p> 
<ul><li>使⽤ QFileDialog 来实现选择⽂件的效果.</li></ul> 
<p>getSaveFileName ⽤于保存⽂件的场景. 此时的对话框可以输⼊⽂件名.<br> getOpenFileName ⽤于打开⽂件的场景. 此时的对话框可以获取到⿏标选择的⽂件名.</p> 
<ul><li> <p>搭配 C++ 标准库的⽂件操作实现⽂件读写.</p> <pre><code>  		void MainWindow::save()
  		{
  		    // 弹出对话框，选择写入文件的路径
  		    QFileDialog* dialog = new QFileDialog(this);
  		    QString fileName = dialog-&gt;getSaveFileName(this, "保存文件", "D:/QtProject");
  		
  		    // 写入文件
  		    std::ofstream file(fileName.toStdString().c_str());
  		    if(!file.is_open()){
  		        qDebug() &lt;&lt; "文件保存失败";
  		        return;
  		    }
  		    const QString&amp; text = edit-&gt;toPlainText();
  		    file &lt;&lt; text.toStdString();
  		    file.close();
  		}
  		
  		void MainWindow::load()
  		{
  		    QFileDialog* dialog = new QFileDialog(this);
  		    QString fileName = dialog-&gt;getOpenFileName(this, "加载文件", "D:/QtProject");
  		
  		    // 读取文件
  		    std::ifstream file(fileName.toStdString().c_str());
  		    if(!file.is_open()){
  		        qDebug() &lt;&lt; "文件加载失败";
  		        return;
  		    }
  		    std::string content;
  		    std::string line;
  		    while(std::getline(file, line)){
  		        content += line;
  		        content += "\n";
  		    }
  		    file.close();
  		
  		    // 显示到界面上
  		    QString text = QString::fromStdString(content);
  		    edit-&gt;setPlainText(text);
  		}
</code></pre> </li></ul> 
<h2><a id="_191"></a>二、工具栏</h2> 
<p>⼯具栏是应⽤程序中集成各种功能实现快捷键使⽤的⼀个区域。可以有多个，也可以没有，它并不是应⽤程序中必须存在的组件。它是⼀个可移动的组件，它的元素可以是各种窗⼝组件，它的元素通常以图标按钮的⽅式存在。如下图为⼯具栏的⽰意图：</p> 
<p><img src="https://images2.imgbox.com/db/c1/2LtEjnuh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__201"></a>1. 创建工具栏</h3> 
<p>调⽤ QMainWindow类 的 addToolBar() 函数来创建⼯具栏，每增加⼀个⼯具栏都需要调⽤⼀次该函数。</p> 
<p>如添加两个工具栏：</p> 
<pre><code>			QToolBar* toolbar1 = new QToolBar(this);
		    QToolBar* toolbar2 = new QToolBar(this);
		    this-&gt;addToolBar(toolbar1);
		    this-&gt;addToolBar(toolbar2);
</code></pre> 
<h3><a id="2__214"></a>2. 设置停靠位置</h3> 
<p>⼯具栏停靠位置的设置有两种⽅式。⼀种是在创建⼯具栏的同时指定停靠的位置，另⼀种是通过 QToolBar类提供的 setAllowedAreas()函数 来设置。</p> 
<p>⽅式⼀：创建⼯具栏的同时指定其停靠的位置。</p> 
<p>在创建⼯具栏的同时，也可以设置⼯具栏的位置，其默认位置是在窗⼝的最上⾯；如上述代码，默认在最上⾯显⽰。⼯具栏允许停靠的区域由 QToolBar类 提供的 allowAreas()函数 决定，其中可以设置的位置包括：</p> 
<ul><li>Qt::LeftToolBarArea 停靠在左侧</li><li>Qt::RightToolBarArea 停靠在右侧</li><li>Qt::TopToolBarArea 停靠在顶部</li><li>Qt::BottomToolBarArea 停靠在底部</li><li>Qt::AllToolBarAreas 以上四个位置都可停靠</li></ul> 
<p>示例：</p> 
<pre><code>			QToolBar* toolbar1 = new QToolBar(this);
		    QToolBar* toolbar2 = new QToolBar(this);
		    this-&gt;addToolBar(Qt::LeftToolBarArea, toolbar1);
		    this-&gt;addToolBar(Qt::RightToolBarArea, toolbar2);
</code></pre> 
<p>⽅式⼆：使⽤ QToolBar类 提供的 setAllowedAreas()函数 设置停靠位置。如下⽰例：</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    ui-&gt;setupUi(this);
			    QToolBar* toolbar1 = new QToolBar(this);
			    QToolBar* toolbar2 = new QToolBar(this);
			//    this-&gt;addToolBar(Qt::LeftToolBarArea, toolbar1);
			//    this-&gt;addToolBar(Qt::RightToolBarArea, toolbar2);
			    this-&gt;addToolBar(toolbar1);
			    this-&gt;addToolBar(toolbar2);
			    // 只允许在左侧停靠
			    toolbar1-&gt;setAllowedAreas(Qt::LeftToolBarArea);
			    // 只允许在右侧停靠
			    toolbar2-&gt;setAllowedAreas(Qt::RightToolBarArea);
			}
</code></pre> 
<h3><a id="3__263"></a>3. 设置浮动属性</h3> 
<p>⼯具栏的浮动属性可以通过 QToolBar 类 提供的 setFloatable() 函数 来设置。setFloatable() 函数原型为：</p> 
<pre><code>			void setFloatable (bool floatable)
			参数：
			true：浮动
			false：不浮动
</code></pre> 
<p>示例：</p> 
<pre><code>		    toolbar1-&gt;setFloatable(true);
		    toolbar2-&gt;setFloatable(false);
</code></pre> 
<h3><a id="4__283"></a>4. 综合示例</h3> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    ui-&gt;setupUi(this);
			    resize(800, 600);
			
			    QToolBar* toolBar = new QToolBar(this);
			    // 设置工具栏的位置，默认是在窗口的上面，此处设置在左侧
			    addToolBar(Qt::LeftToolBarArea, toolBar);
			
			    // 设置工具栏的停靠位置，设置工具栏只允许在左右停靠
			    toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);
			
			    // 设置工具栏的浮动属性
			    toolBar-&gt;setFloatable(false);
			
			    // 设置工具栏的移动(总开关)
			    toolBar-&gt;setMovable(false);
			
			    // 设置工具栏内容
			    QAction* openAction = new QAction("open", this);
			    QAction* newAction = new QAction("new", this);
			
			    toolBar-&gt;addAction(openAction);
			    toolBar-&gt;addSeparator();
			    toolBar-&gt;addAction(newAction);
			
			    // 工具栏中也可以添加控件
			    QPushButton* button = new QPushButton("保存", this);
			    toolBar-&gt;addSeparator();
			    toolBar-&gt;addWidget(button);
			}
</code></pre> 
<h2><a id="_321"></a>三、状态栏</h2> 
<p>状态栏是应⽤程序中输出简要信息的区域。⼀般位于主窗⼝的最底部，⼀个窗⼝中最多只能有⼀个状态栏。在 Qt 中，状态栏是通过 QStatusBar类 来实现的。 在状态栏中可以显⽰的消息类型有：</p> 
<ul><li>实时消息：如当前程序状态</li><li>永久消息：如程序版本号，机构名称</li><li>进度消息：如进度条提⽰，百分百提⽰</li></ul> 
<h3><a id="1__333"></a>1. 状态栏的创建</h3> 
<p>状态栏的创建是通过 QMainWindow 类 提供的 statusBar() 函数来创建；⽰例如下：</p> 
<pre><code>			// 创建状态栏
		    QStatusBar* status = statusBar();
		    // 将状态栏置于窗口中
		    setStatusBar(status);
</code></pre> 
<h3><a id="2__345"></a>2. 在状态栏中显示实时消息</h3> 
<p>在状态栏中显⽰实时消息是通过 showMessage() 函数来实现，⽰例如下：</p> 
<pre><code>			status-&gt;showMessage("Hello, world", 2000);
</code></pre> 
<h3><a id="3__354"></a>3. 在状态栏中显示永久消息</h3> 
<p>在状态栏中可以显⽰永久消息，此处的永久消息是通过 标签 来显示的；⽰例如下：</p> 
<pre><code>		    // 创建状态栏
		    QStatusBar* status = statusBar();
		    // 将状态栏置于窗口中
		    setStatusBar(status);
		
		    // 创建标签
		    QLabel* label = new QLabel("提示消息", this);
		    // 将标签放入状态栏中
		    status-&gt;addWidget(label);
</code></pre> 
<p>调整显⽰消息的位置，将创建的标签放入到状态栏的右侧</p> 
<pre><code>		    // 将创建的标签放入到状态栏的右侧
		    QLabel* label2 = new QLabel("右侧提示消息", this);
		    status-&gt;addPermanentWidget(label2);
</code></pre> 
<h2><a id="_379"></a>四、浮动窗口</h2> 
<p>在 Qt 中，浮动窗⼝也称之为铆接部件。浮动窗⼝是通过 QDockWidget类 来实现浮动的功能。浮动窗口⼀般是位于核心部件的周围，可以有多个。</p> 
<h3><a id="1__385"></a>1. 浮动窗口的创建</h3> 
<p>浮动窗⼝的创建是通过 QDockWidget类 提供的构造⽅法 QDockWidget()函数 动态创建的；示例如下：</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    ui-&gt;setupUi(this);
			
			    // 浮动窗口
			    QDockWidget* dockWidget = new QDockWidget("浮动窗口", this);
			
			    // 将浮动窗口置于当前窗口中
			    addDockWidget(Qt::BottomDockWidgetArea, dockWidget);
			}
</code></pre> 
<h3><a id="2__407"></a>2. 设置停靠的位置</h3> 
<p>浮动窗⼝是位于中⼼部件的周围。可以通过 QDockWidget类 中提供 setAllowedAreas() 函数设置其允许停靠的位置。其中可以设置允许停靠的位置有：</p> 
<ul><li>Qt::LeftDockWidgetArea 停靠在左侧</li><li>Qt::RightDockWidgetArea 停靠在右侧</li><li>Qt::TopDockWidgetArea 停靠在顶部</li><li>Qt::BottomDockWidgetArea 停靠在底部</li><li>Qt::AllDockWidgetAreas 以上四个位置都可停靠</li></ul> 
<p>示例如下：设置浮动窗口只允许上下停靠</p> 
<p><img src="https://images2.imgbox.com/36/64/cYjwJ1rf_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_427"></a>五、对话框</h2> 
<h3><a id="1__430"></a>1. 对话框介绍</h3> 
<p>对话框是 GUI 程序中不可或缺的组成部分。⼀些不适合在主窗⼝实现的功能组件可以设置在对话框中。对话框通常是⼀个顶层窗⼝，出现在程序最上层，⽤于实现短期任务或者简洁的⽤⼾交互。Qt常用的内置对话框有：QFiledialog（⽂件对话框）、QColorDialog（颜⾊对话框）、QFontDialog（字体对话框）、QInputDialog （输⼊对话框）和 QMessageBox（消息框） 。</p> 
<h3><a id="2__436"></a>2. 对话框分类</h3> 
<p>对话框分为 模态对话框 和 ⾮模态对话框。</p> 
<ol><li><strong>模态对话框</strong></li></ol> 
<p>模态对话框指的是：显⽰后⽆法与⽗窗⼝进⾏交互，是⼀种阻塞式的对话框。使⽤ QDialog::exec() 函数调⽤。</p> 
<p>模态对话框适⽤于必须依赖用户选择的场合，⽐如消息显⽰，⽂件选择，打印设置等。</p> 
<p>示例：</p> 
<p>（1）新建 Qt 项⽬，在 ui ⽂件中的菜单栏中设置两个菜单：“⽂件” 和 “编辑”，在 菜单 “⽂件” 下新建菜单项：“创建” 并将菜单项 “新建” 置于⼯具栏中 ； 如下图⽰：</p> 
<p><img src="https://images2.imgbox.com/f5/1f/yfN8WCk8_o.png" alt="在这里插入图片描述"></p> 
<p>（2）在 mainwindow.cpp ⽂件中实现：当点击 “新建” 时，弹出⼀个模态对话框；</p> 
<p>说明：在菜单项中，点击菜单项时就会触发 triggered() 信号。</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    ui-&gt;setupUi(this);
			
			    // 当点击新建时，弹出一个模态对话框，在菜单项中，当点击之后就会触发 triggered 信号
			    connect(ui-&gt;action, &amp;QAction::triggered, [=](){
			        QDialog dlg(this);
			        dlg.resize(200, 100);
			        dlg.exec();
			    });
			}
</code></pre> 
<ol start="2"><li><strong>非模态对话框</strong></li></ol> 
<p>⾮模态对话框显⽰后独⽴存在，可以同时与⽗窗⼝进⾏交互，是⼀种⾮阻塞式对话框，使用 QDialog::show()函数调用。</p> 
<p>⾮模态对话框⼀般在堆上创建，这是因为如果创建在栈上时，弹出的⾮模态对话框就会⼀闪⽽过。同时还需要设置 Qt:WA_DeleteOnClose 属性，⽬的是：当创建多个⾮模态对话框时（如打开了多个非模态窗⼝），为了避免内存泄漏要设置此属性。</p> 
<p>⾮模态对话框适⽤于特殊功能设置的场合，⽐如查找操作，属性设置等。</p> 
<p>示例：</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    ui-&gt;setupUi(this);
			
			    // 非模态对话框
			    connect(ui-&gt;action, &amp;QAction::triggered, [=](){
			        // 为了防止一闪而过，创建在堆区
			        QDialog* dlg = new QDialog(this);
			
			        dlg-&gt;resize(200, 100);
			        // 当 dlg 无限创建时(即一直不断地打开关闭窗口)，设置下面这个属性就可以在关闭非模态对话框时释放这个对象
			        dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);
			        dlg-&gt;show();
			    });
			}
</code></pre> 
<ol start="3"><li><strong>混合属性对话框</strong></li></ol> 
<p>混合属性对话框同时具有模态对话框和⾮模态对话框的属性，对话框的⽣成和销毁具有⾮模态对话框属性，功能上具有模态对话框的属性。</p> 
<p>使⽤ QDialog::setModal() 函数 可以创建混合特性的对话框。通常，创建对话框时需要指定对话框的⽗组件。</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    ui-&gt;setupUi(this);
			
			    // 混合属性对话框
			    connect(ui-&gt;action, &amp;QAction::triggered, [=](){
			        QDialog* dialog = new QDialog(this);
			        dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);
			
			        dialog-&gt;setModal(true);
			        dialog-&gt;resize(200, 100);
			        dialog-&gt;show();
			    });
			}
</code></pre> 
<h3><a id="3_Qt__542"></a>3. Qt 内置对话框</h3> 
<p>Qt 提供了多种可复⽤的对话框类型，即 Qt 标准对话框。Qt 标准对话框全部继承于 QDialog类。常用标准对话框如下：</p> 
<p><img src="https://images2.imgbox.com/f3/0c/4gFruZQB_o.png" alt="在这里插入图片描述"></p> 
<ol><li><strong>消息对话框 QMessageBox</strong></li></ol> 
<p>消息对话框是应⽤程序中最常⽤的界⾯元素。消息对话框主要⽤于为⽤⼾提⽰重要信息，强制用户进行选择操作。</p> 
<p>QMessageBox类中定义了静态成员函数，可以直接调⽤创建不同⻛格的消息对话框，其中包括：</p> 
<p><img src="https://images2.imgbox.com/c0/88/Qn7jiuL5_o.png" alt="在这里插入图片描述"></p> 
<p>其对应的函数原型如下：</p> 
<p><img src="https://images2.imgbox.com/a7/ef/pR1uNV2Z_o.png" alt="在这里插入图片描述"></p> 
<p><strong>代码示例1</strong>：问题提⽰消息对话框</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			    , ui(new Ui::MainWindow)
			{
			    resize(800, 600);
			    QPushButton* btn = new QPushButton("消息对话框", this);
			    QMessageBox* msg = new QMessageBox(this);
			
			    msg-&gt;setWindowTitle("Warning Message"); // 设置消息对话框标题
			    msg-&gt;setText("Error Message!");         // 设置消息对话框内容
			    msg-&gt;setIcon(QMessageBox::Question);    // 设置消息对话框类型
			    msg-&gt;setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel); // 在消息对话框上设置按钮
			
			    connect(btn, &amp;QPushButton::clicked, [=](){
			        msg-&gt;show();
			    });
			}
</code></pre> 
<p><img src="https://images2.imgbox.com/de/df/HNUAc0a5_o.png" alt="在这里插入图片描述"></p> 
<p>其中可以设置的按钮的类型如下：</p> 
<p><img src="https://images2.imgbox.com/51/f4/c4Cu6YM8_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li><strong>颜色对话框 QColorDialog</strong></li></ol> 
<p>颜⾊对话框的功能是允许⽤⼾选择颜⾊。继承⾃ QDialog 类。</p> 
<p>常⽤⽅法介绍：</p> 
<pre><code>		QColorDialog (QWidget *parent = nullptr) //创建对象的同时设置⽗对象
		QColorDialog(const QColor &amp;initial, QWidget *parent = nullptr) //创建对象的同时通过 QColor 对象设置默认颜⾊和⽗对象
		void setCurrentColor(const QColor &amp;color) //设置当前颜⾊对话框
		QColor currentColor() const //获取当前颜⾊对话框

		QColor getColor(const QColor &amp;initial = Qt::white \
		QWidget *parent = nullptr \
		const QString&amp; title = QString() \
		QColorDialog::ColorDialogOptions options = ColorDialogOptions()) //打开颜色选择对话框，并返回⼀个QColor对象
		// initial：设置默认颜⾊
		// parent：设置⽗对象
		// title：设置对话框标题
		// options：设置选项

		 void open(QObject *receiver, const char *member) //打开颜⾊对话框
</code></pre> 
<p><strong>示例代码1：</strong></p> 
<pre><code>				#include "mainwindow.h"
				#include &lt;QPushButton&gt;
				#include &lt;QColorDialog&gt;
				#include &lt;QDebug&gt;
				
				MainWindow::MainWindow(QWidget *parent)
				    : QMainWindow(parent)
				{
				    resize(800, 600);
				    QPushButton* btn = new QPushButton("颜色对话框", this);
				
				    // 创建颜色对话框
				    QColorDialog* cdlg = new QColorDialog(this);
				
				    connect(btn, &amp;QPushButton::clicked, [=](){
				        // 打开颜色对话框, 并设置默认颜色为红色
				        QColor color = cdlg-&gt;getColor(QColor(255, 0, 0));
				        qDebug() &lt;&lt; "r = " &lt;&lt; color.red();
				        qDebug() &lt;&lt; "g = " &lt;&lt; color.green();
				        qDebug() &lt;&lt; "b = " &lt;&lt; color.blue();
				    });
				}
</code></pre> 
<p>效果如下：</p> 
<p><img src="https://images2.imgbox.com/f5/8f/vQuqyL2Z_o.png" alt="在这里插入图片描述"></p> 
<p><strong>代码示例2</strong>：</p> 
<p>将上面代码的 connect 函数改一下即可：</p> 
<pre><code>			connect(btn, &amp;QPushButton::clicked, [=](){
			        // 设置颜色对话框中的颜色
			        cdlg-&gt;setCurrentColor(QColor(200, 100, 190));
			        cdlg-&gt;open();
			    });
</code></pre> 
<p>效果如下：</p> 
<p><img src="https://images2.imgbox.com/36/63/S9ID4KIS_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li><strong>文件对话框 QFileDialog</strong></li></ol> 
<p>⽂件对话框⽤于应⽤程序中需要打开⼀个外部⽂件或需要将当前内容存储到指定的外部⽂件。常用方法介绍：</p> 
<p>1、打开⽂件（⼀次只能打开⼀个⽂件）</p> 
<pre><code>		QString getOpenFileName(QWidget *parent = nullptr, \
		const QString &amp;caption = QString(), \
		const QString &amp;dir = QString(), \
		const QString &amp;filter = QString(), \
		QString *selectedFilter = nullptr, \
		QFileDialog::Options options = Options())
</code></pre> 
<p>2、打开多个⽂件（⼀次可以打开多个⽂件）</p> 
<pre><code>		QStringList getOpenFileNames(QWidget *parent = nullptr, \
		const QString &amp;caption = QString(),\
		const QString &amp;dir = QString(), \
		const QString &amp;filter = QString(), \
		QString *selectedFilter = nullptr,\
		QFileDialog::Options options = Options())
</code></pre> 
<p>3、 保存文件</p> 
<pre><code>		QString getSaveFileName(QWidget *parent = nullptr, \
		const QString &amp;caption = QString(), \
		const QString &amp;dir = QString(), \
		const QString &amp;filter = QString(), \
		QString *selectedFilter = nullptr, \
		QFileDialog::Options options = Options())
</code></pre> 
<p>参数说明：<br> 参数1：parent 父对象<br> 参数2：caption 对话框标题<br> 参数3：dir 默认打开的路径<br> 参数4：filter ⽂件过滤器</p> 
<p><strong>示例代码1：</strong></p> 
<pre><code>			#include "mainwindow.h"
			#include &lt;QPushButton&gt;
			#include &lt;QFileDialog&gt;
			#include &lt;QDebug&gt;
			
			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			{
			    resize(800, 600);
			    QPushButton* btn = new QPushButton("文件", this);
			    QFileDialog* fdlg = new QFileDialog(this);
			
			    connect(btn, &amp;QPushButton::clicked, [=](){
			       QString str = fdlg-&gt;getOpenFileName(this,            // 父对象 
			                                           "文件",          // 文件对话框标题
			                                           "D:\\桌面\\jpg", // 打开的路径
			                                           "*.jpg");        // 只保留 .jpg 格式文件
			       qDebug() &lt;&lt; str;
			    });
			}
</code></pre> 
<p>效果如下：</p> 
<p><img src="https://images2.imgbox.com/a7/21/1YVwio3Z_o.png" alt="在这里插入图片描述"></p> 
<p><strong>示例代码2，保存文件：</strong></p> 
<p>只需要改 connect 中的内容：</p> 
<pre><code>		QString str = fdlg-&gt;getSaveFileName(this, "文件", "D:\\桌面\\jpg", "*.jpg"); 
</code></pre> 
<ol start="4"><li><strong>字体对话框 QFontDialog</strong></li></ol> 
<p>Qt 中提供了预定义的字体对话框类 <strong>QFontDialog</strong>，⽤于提供选择字体的对话框部件。</p> 
<p><strong>示例代码：</strong></p> 
<pre><code>			#include "mainwindow.h"
			#include &lt;QPushButton&gt;
			#include &lt;QFontDialog&gt;
			#include &lt;QDebug&gt;
			
			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			{
			    resize(800, 600);
			    QPushButton* btn = new QPushButton("字体", this);
			
			    connect(btn, &amp;QPushButton::clicked, [=](){
			        // 使用 QFontDialog 类的静态方法 getFont 打开字体对话框并设置默认格式
			        bool flag;
			        QFont font = QFontDialog::getFont(&amp;flag, QFont("黑体", 36));
			
			        // 将 char* 转换为 QString 的方法：.toUtf8().data()
			        qDebug() &lt;&lt; "字体: " &lt;&lt; font.family().toUtf8().data();
			
			        // 获取字号
			        qDebug() &lt;&lt; "字号: " &lt;&lt; font.pointSize();
			
			        // 判断字体是否加粗
			        qDebug() &lt;&lt; "是否加粗: " &lt;&lt; font.bold();
			
			        // 判断字体是否倾斜
			        qDebug() &lt;&lt; "是否倾斜: " &lt;&lt; font.italic();
			    });
			}
</code></pre> 
<p><img src="https://images2.imgbox.com/ab/9a/vbubJSgg_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li><strong>输入对话框 QInputDialog</strong></li></ol> 
<p>Qt 中提供了预定义的输⼊对话框类：<strong>QInputDialog</strong>，⽤于进⾏临时数据输⼊的场合。</p> 
<p>常⽤⽅法介绍：</p> 
<p>1、双精度浮点型输⼊数据对话框</p> 
<pre><code>		double getDouble (QWidget *parent, \
		const QString &amp;title, \
		const QString &amp;label, \
		double value = 0, \
		double min = -2147483647, \
		double max = 2147483647, \
		int decimals = 1, \
		bool *ok = nullptr, \
		Qt::WindowFlags flags = Qt::WindowFlags())；
</code></pre> 
<p>2、整型输⼊数据对话框</p> 
<pre><code>		int getInt (QWidget *parent, \
		const QString &amp;title, \
		const QString &amp;label, \
		int value = 0, \
		int min = -2147483647, \
		int max = 2147483647, \
		int step = 1, \
		bool *ok = nullptr, \
		Qt::WindowFlags flags = Qt::WindowFlags());
</code></pre> 
<p>3、选择条目型输⼊数据框</p> 
<pre><code>		QString getItem (QWidget *parent, \
		const QString &amp;title, \
		const QString &amp;label, \
		const QStringList &amp;items, \
		int current = 0, \
		bool editable = true, \
		bool *ok = nullptr,
		Qt::WindowFlags flags = Qt::WindowFlags(), \
		Qt::InputMethodHints inputMethodHints = Qt::ImhNone) ；
</code></pre> 
<p>参数说明：<br> parent：父对象<br> title：对话框标题<br> label：对话框标签<br> items：可供选择的条目</p> 
<p><strong>代码示例1：</strong> 浮点型数据输⼊对话框</p> 
<pre><code>			#include "mainwindow.h"
			#include &lt;QPushButton&gt;
			#include &lt;QInputDialog&gt;
			#include &lt;QDebug&gt;
			
			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			{
			    resize(800, 600);
			    QPushButton* btn = new QPushButton("输入框", this);
			
			    QInputDialog* idlg = new QInputDialog(this);
			
			    connect(btn, &amp;QPushButton::clicked, [=](){
			        double d = idlg-&gt;getDouble(this, "输入框", "浮点型");
			        qDebug() &lt;&lt; "d = " &lt;&lt; d;
			    });
			}
</code></pre> 
<p><img src="https://images2.imgbox.com/21/fe/1wXvl7d0_o.png" alt="在这里插入图片描述"></p> 
<p><strong>代码示例2：</strong> 整型数据输⼊对话框</p> 
<pre><code>			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			{
			    resize(800, 600);
			    QPushButton* btn = new QPushButton("输入框", this);
			
			    QInputDialog* idlg = new QInputDialog(this);
			
			    connect(btn, &amp;QPushButton::clicked, [=](){
			        int i = idlg-&gt;getInt(this, "输入框", "浮点型");
			        qDebug() &lt;&lt; "i = " &lt;&lt; i;
			    });
			}
</code></pre> 
<p><strong>代码示例3</strong>：打开选择条⽬对话框</p> 
<pre><code>			#include "mainwindow.h"
			#include &lt;QPushButton&gt;
			#include &lt;QInputDialog&gt;
			#include &lt;QDebug&gt;
			
			MainWindow::MainWindow(QWidget *parent)
			    : QMainWindow(parent)
			{
			    resize(800, 600);
			    QPushButton* btn = new QPushButton("输入框", this);
			    QInputDialog* idlg = new QInputDialog(this);
			
			    connect(btn, &amp;QPushButton::clicked, [=](){
			        QStringList items;
			        items &lt;&lt; tr("Spring") &lt;&lt; tr("Summer") &lt;&lt; tr("Fall") &lt;&lt; tr("Winter");
			
			        QString item = idlg-&gt;getItem(this, "输入框", "Item", items);
			
			        qDebug() &lt;&lt; "item: " &lt;&lt; item.toUtf8().data();
			    });
			}
</code></pre> 
<p>效果如下：</p> 
<p><img src="https://images2.imgbox.com/3f/0f/IqLB8paQ_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a99a4dce59434ff17f4eafc0b2c970a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Elasticsearch】Elasticsearch的分片和副本机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6223b49bfedc437d5dae64fba85fc6ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3自定义全局less scss函数混入mixins混合样式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>