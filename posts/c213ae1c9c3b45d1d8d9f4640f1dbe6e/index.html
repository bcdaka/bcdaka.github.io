<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【SpringCloud】Eureka基于Ribbon负载均衡的调用链路流程分析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c213ae1c9c3b45d1d8d9f4640f1dbe6e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【SpringCloud】Eureka基于Ribbon负载均衡的调用链路流程分析">
  <meta property="og:description" content="文章目录 前言1.调用形式2.LoadBalancerInterceptor3.负载均衡流程分析3.1 调用流程图3.2 intercept（）方法3.3 execute（）方法3.4 getServer()方法3.4 子类的chooseServer（）方法3.5 getLoadBalancerStats().getAvailableZones().size() &lt;= 13.6 父类的chooseServer()方法3.7 IRule接口下的实例3.8 最终的choose()方法—return server3.9 choose()方法内部分析 4. 彩蛋 前言 微服务间相互调用的基础上，服务间的调用更多是以调用某多实例服务下的某个实例的形式。而这就需要用到负载均衡技术。对于开发者而言，只要通过@LoadBalance注解就开启了负载均衡。如此简单的操作底层究竟是什么样的，我想你也很想知道。
1.调用形式 在《SpringCloud集成Eureka并实现负载均衡》的基础之上，我们可以进行一个小小的实验，debug运行程序，通过postman发起一个请求，A服务会去远程调用B服务，debug发现发送的url为：http://user-service/user/1，毫无疑问的是，这就是A调用B的途径
同样地，拿到这个url我们去postman里发送请求：
发现请求无法发送出去，路径出了问题。观察路径中的参数user-service发现他是B服务的服务名称，那为什么在A服务里向B服务发送“服务名称-接口路径-参数”形式的请求就能够正常响应？
结合集成负载均衡的过程，这一定是Ribbon在发挥作用
2.LoadBalancerInterceptor 负载均衡的前提不是传递一个具体的url，肯定是Ribbon做了某种解析，通过服务名称得到了服务下的实例列表，从而拉取Eureka-Server中的服务注册表来将请求映射到指定的某个实例上。
结合曾经前后端分离的web开发经验，后端经常会在拦截器中拦截前端发来的请求来对请求做一些操作，比如校验、拼接、鉴权…调用方发送请求和接收方收到的请求并不一致，这其中会不会也是有一个类似于拦截器的东西拦截了请求，并且转换了请求呢？
答案是必然的，那是谁——LoadBalancerInterceptor
可以看到的是，他实现了ClientHttpRequestInterceptor接口，具体用法细节直接去看接口中声明的方法
直观的看出接口中声明了一个intercept()方法并且接受了HttpRequest参数来拦截了客户端的http请求，并且修改的请求体！这么一看URL更改的谜底就在此处揭晓了，那么方法底层具体是怎么实现的呢：
3.负载均衡流程分析 3.1 调用流程图 Debug源码之前先来看一下源码中的调用链路总体流程图（手图）：
概括来看则是：拦截请求—读取服务—拉取服务列表—选择规则—返回服务实例
3.2 intercept（）方法 下面我们开始Debug:
1.当发送请求使得服务间发生调用关系，调用请求会先传递到拦截器中的intercept方法，可以看到的是目前还和发送是保持一致
2.继续向下执行，开始解析请求，拿到了请求中的URI——通过getHost()方法拿到了主机地址（服务的名称）
3.3 execute（）方法 3.Ribbon开始做负载均衡处理
4.两次步入之后进入到execute（）方法内部，发现传递进来的服务名称作为服务Id进入到了getLoadBalance（）方法，并且得到了一个ILoadbalance接口对象，而在该对象中封装了很多的信息：
这里记住服务实例id的值：host.docker.internal:8084，这就是Eureka客户端接收到的实例信息
3.4 getServer()方法 5.接口对象作为参数传递到了getServer()方法,得到了一个server对象进入到方法内部。发现与此同时传递了一个Object类型的对象用于指定服务器的规则或条件，不过到目前为止，这个参数一直都是null作为传递，即loadBalancer.chooseServer（）方法采用的是‘default’的方式进行选择
3.4 子类的chooseServer（）方法 6.再次步入到chooseServer（）方法，发现是在一个名为BaseLoadBalancer类（这个类是负载均衡器的具体实现后面会具体分析）下重写的父类方法
此时：可以判断的是getLoadBalancerStats().getAvailableZones().size() &lt;= 1为TRUE
3.5 getLoadBalancerStats().getAvailableZones().size() &lt;= 1 对于表达式：getLoadBalancerStats().getAvailableZones().size() &lt;= 1进行分析
发现在BaseLoadBalancer类中通过继承抽象类AbstractLoadBalancer并重写getLoadBalancerStats()抽象方法，获取到了一个loadbalancer统计信息集合LoadBalancerStats
而封装在LoadBalancerStats中的信息里有一个ConcurrentHashMap类型的集合属性，即
volatile Map&lt;String, List&lt;? extends Server&gt;&gt; upServerListZoneMap = new ConcurrentHashMap&lt;String, List&lt;?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-14T22:03:04+08:00">
    <meta property="article:modified_time" content="2024-04-14T22:03:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【SpringCloud】Eureka基于Ribbon负载均衡的调用链路流程分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#1_3" rel="nofollow">1.调用形式</a></li><li><a href="#2LoadBalancerInterceptor_10" rel="nofollow">2.LoadBalancerInterceptor</a></li><li><a href="#3_17" rel="nofollow">3.负载均衡流程分析</a></li><li><ul><li><a href="#31__18" rel="nofollow">3.1 调用流程图</a></li><li><a href="#32_intercept_22" rel="nofollow">3.2 intercept（）方法</a></li><li><a href="#33_execute_28" rel="nofollow">3.3 execute（）方法</a></li><li><a href="#34_getServer_34" rel="nofollow">3.4 getServer()方法</a></li><li><a href="#34_chooseServer_37" rel="nofollow">3.4 子类的chooseServer（）方法</a></li><li><a href="#35_getLoadBalancerStatsgetAvailableZonessize__1_41" rel="nofollow">3.5 getLoadBalancerStats().getAvailableZones().size() &lt;= 1</a></li><li><a href="#36_chooseServer_55" rel="nofollow">3.6 父类的chooseServer()方法</a></li><li><a href="#37_IRule_58" rel="nofollow">3.7 IRule接口下的实例</a></li><li><a href="#38_choosereturn_server_72" rel="nofollow">3.8 最终的choose()方法—return server</a></li><li><a href="#39_choose_76" rel="nofollow">3.9 choose()方法内部分析</a></li></ul> 
   </li><li><a href="#4__85" rel="nofollow">4. 彩蛋</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>前言</h3> 
<p>微服务间相互调用的基础上，服务间的调用更多是以调用某多实例服务下的某个实例的形式。而这就需要用到负载均衡技术。对于开发者而言，只要通过@LoadBalance注解就开启了负载均衡。如此简单的操作底层究竟是什么样的，我想你也很想知道。</p> 
<h3><a id="1_3"></a>1.调用形式</h3> 
<p>在《<a href="https://blog.csdn.net/weixin_57535055/article/details/134391818?spm=1001.2014.3001.5501">SpringCloud集成Eureka并实现负载均衡</a>》的基础之上，我们可以进行一个小小的实验，debug运行程序，通过postman发起一个请求，A服务会去远程调用B服务，debug发现发送的url为：http://user-service/user/1，毫无疑问的是，这就是A调用B的途径<br> <img src="https://images2.imgbox.com/dc/6f/jLljbp1f_o.png" alt="在这里插入图片描述"><br> 同样地，拿到这个url我们去postman里发送请求：<br> <img src="https://images2.imgbox.com/7a/ff/t5TzYVFi_o.png" alt="在这里插入图片描述"><br> 发现请求无法发送出去，路径出了问题。观察路径中的参数user-service发现他是B服务的服务名称，那为什么在A服务里向B服务发送“服务名称-接口路径-参数”形式的请求就能够正常响应？<br> 结合集成负载均衡的过程，这一定是Ribbon在发挥作用</p> 
<h3><a id="2LoadBalancerInterceptor_10"></a>2.LoadBalancerInterceptor</h3> 
<p>负载均衡的前提不是传递一个具体的url，肯定是Ribbon做了某种解析，通过服务名称得到了服务下的实例列表，从而拉取Eureka-Server中的服务注册表来将请求映射到指定的某个实例上。<br> 结合曾经前后端分离的web开发经验，后端经常会在拦截器中拦截前端发来的请求来对请求做一些操作，比如校验、拼接、鉴权…调用方发送请求和接收方收到的请求并不一致，这其中会不会也是有一个类似于拦截器的东西拦截了请求，并且转换了请求呢？<br> <strong>答案是必然的，那是谁——LoadBalancerInterceptor</strong><br> <img src="https://images2.imgbox.com/3a/13/BoD7aFbu_o.png" alt="在这里插入图片描述"><br> 可以看到的是，他实现了ClientHttpRequestInterceptor接口，具体用法细节直接去看接口中声明的方法<br> 直观的看出接口中声明了一个intercept()方法并且接受了HttpRequest参数来拦截了客户端的http请求，并且修改的请求体！这么一看URL更改的谜底就在此处揭晓了，那么方法底层具体是怎么实现的呢：</p> 
<h3><a id="3_17"></a>3.负载均衡流程分析</h3> 
<h4><a id="31__18"></a>3.1 调用流程图</h4> 
<p>Debug源码之前先来看一下源码中的调用链路总体流程图（手图）：<br> <img src="https://images2.imgbox.com/33/d7/Hfz2Gart_o.png" alt="在这里插入图片描述"><br> 概括来看则是：拦截请求—读取服务—拉取服务列表—选择规则—返回服务实例</p> 
<h4><a id="32_intercept_22"></a>3.2 intercept（）方法</h4> 
<p>下面我们开始Debug:<br> 1.当发送请求使得服务间发生调用关系，调用请求会先传递到<strong>拦截器中的intercept方法</strong>，可以看到的是目前还和发送是保持一致<br> <img src="https://images2.imgbox.com/64/a8/44Ibi5UJ_o.png" alt="在这里插入图片描述"><br> 2.继续向下执行，开始解析请求，拿到了请求中的URI——通过getHost()方法拿到了主机地址（服务的名称）<br> <img src="https://images2.imgbox.com/30/ec/fmSD1DvD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33_execute_28"></a>3.3 execute（）方法</h4> 
<p>3.Ribbon开始做负载均衡处理<br> <img src="https://images2.imgbox.com/1f/de/Vz9Slr8V_o.png" alt="在这里插入图片描述"><br> 4.两次步入之后进入到execute（）方法内部，发现传递进来的服务名称作为服务Id进入到了getLoadBalance（）方法，并且得到了一个<strong>ILoadbalance接口对象</strong>，而在该对象中封装了很多的信息：<br> <img src="https://images2.imgbox.com/81/a0/pAgk1OLx_o.png" alt="在这里插入图片描述"><br> 这里记住服务实例id的值：<strong>host.docker.internal:8084</strong>，这就是Eureka客户端接收到的实例信息</p> 
<h4><a id="34_getServer_34"></a>3.4 getServer()方法</h4> 
<p>5.接口对象作为参数传递到了getServer()方法,得到了一个server对象进入到方法内部。发现与此同时传递了一个Object类型的对象用于指定服务器的规则或条件，不过到目前为止，这个参数一直都是null作为传递，即loadBalancer.chooseServer（）方法采用的是‘default’的方式进行选择<br> <img src="https://images2.imgbox.com/7d/6e/SPm8DTBZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="34_chooseServer_37"></a>3.4 子类的chooseServer（）方法</h4> 
<p>6.再次步入到chooseServer（）方法，发现是在一个名为BaseLoadBalancer类（这个类是负载均衡器的具体实现后面会具体分析）下重写的父类方法<br> 此时：可以判断的是getLoadBalancerStats().getAvailableZones().size() &lt;= 1为TRUE<br> <img src="https://images2.imgbox.com/09/79/0bsR8ukq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="35_getLoadBalancerStatsgetAvailableZonessize__1_41"></a>3.5 getLoadBalancerStats().getAvailableZones().size() &lt;= 1</h4> 
<p>对于表达式：getLoadBalancerStats().getAvailableZones().size() &lt;= 1进行分析<br> 发现在BaseLoadBalancer类中通过继承抽象类AbstractLoadBalancer并重写getLoadBalancerStats()抽象方法，获取到了一个<strong>loadbalancer统计信息集合LoadBalancerStats</strong><br> <img src="https://images2.imgbox.com/68/4c/s8uvUz4j_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ff/7e/w1QsZDoi_o.png" alt="在这里插入图片描述"><br> 而封装在LoadBalancerStats中的信息里有一个ConcurrentHashMap类型的集合属性，即</p> 
<pre><code class="prism language-java"><span class="token keyword">volatile</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Server</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> upServerListZoneMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Server</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>用于<strong>存储可用的服务列表</strong>，这个集合中的每个条目都代表一个区域，键是区域名称，值是该区域下可用服务器的列表。<br> <img src="https://images2.imgbox.com/92/1e/9uyrrLVM_o.png" alt="在这里插入图片描述"><br> 后续的.getAvailableZones()方法则是获取这一属性值中所有的键，也就是可用的服务区域，并作为Set集合返回来进行判断<br> <img src="https://images2.imgbox.com/71/cf/Tr1y2AhB_o.png" alt="在这里插入图片描述"><br> 很显然，这里进一步论证getLoadBalancerStats().getAvailableZones().size() &lt;= 1是为true的，后续就会去调用父类的chooseServer()方法</p> 
<h4><a id="36_chooseServer_55"></a>3.6 父类的chooseServer()方法</h4> 
<p>7.步入到父类的chooseServer()方法中，发现最后返回了一个Server类型的对象，这肯定就是具体的服务实例信息了。<br> <img src="https://images2.imgbox.com/1d/9a/dho90spQ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="37_IRule_58"></a>3.7 IRule接口下的实例</h4> 
<p>去追踪rule变量，发现是一个IRule接口的实例，即为负载均衡提供规则的接口<br> <img src="https://images2.imgbox.com/03/97/7lhwKaee_o.png" alt="在这里插入图片描述"><br> 并且此接口下有大量的规则实现，而<strong>默认的规则方式则为轮询调度</strong>：<br> <img src="https://images2.imgbox.com/fb/86/gdkQSb4E_o.png" alt="在这里插入图片描述"><br> 可是看到上图在debug时，rule变量右侧灰色显示的是<code>rule：RandomRule@12045</code>这是因为我通过配置IRule类型的Bean指定了负载均衡的规则：</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>只要把他注释掉，程序就会继续去采用默认的规则即<strong>RoundRobinRule</strong></p> 
<h4><a id="38_choosereturn_server_72"></a>3.8 最终的choose()方法—return server</h4> 
<p>8.了解了IRule接口的rule实例，再去看他最终调用的choose()方法。同样地步入进去，由于是默认规则，则按照流程进入到了RoundRobinRule规则实现中的choose方法（其实IRule接口下的每一个规则实现类都有choose方法）<br> <img src="https://images2.imgbox.com/7c/29/nqobqRpA_o.png" alt="在这里插入图片描述"><br> 实现了<code>ILoadBalancer</code>接口的负载均衡器对象作为参数传递到了方法中，与此同时key为default。开始为随机选择预热。</p> 
<h4><a id="39_choose_76"></a>3.9 choose()方法内部分析</h4> 
<p>9.进入到while循环中，不断选择服务器，直到找到一个可用的服务器。随后会<strong>判断线程是否中断</strong>，如果中断了，则直接返回null。<br> <img src="https://images2.imgbox.com/d5/c4/cx3UpW1t_o.png" alt="在这里插入图片描述"><br> 这样的情况出现频率还是很高，由此可见，这个小设计会减少很多不必要计算，提升了程序运行的效率。<br> 而后这是分别获取两个服务列表<img src="https://images2.imgbox.com/f0/e3/OXf457OT_o.png" alt="在这里插入图片描述"><br> 从列表中选择一个<br> <img src="https://images2.imgbox.com/f4/ee/SZQJGLbk_o.png" alt="在这里插入图片描述"><br> 兜底操作，对选择的做判断<img src="https://images2.imgbox.com/6a/1c/95JQ7Nn7_o.png" alt="在这里插入图片描述"><br> 最后成功返回Server实例给chooseServer（）方法，服务发起者发送http：//user-service/user请求通过Ribbon最后轮询到了localhost:8084服务实例上</p> 
<h3><a id="4__85"></a>4. 彩蛋</h3> 
<p>现在有很多公司都在用Nacos替换Eureka，因为感知服务列表的变化不够敏感，感知下线服务太过迟钝，就像下面这种情况：<br> <img src="https://images2.imgbox.com/ba/b7/RnpXgePL_o.png" alt="在这里插入图片描述"><br> <strong>服务实例已经下线，时间大约过了一分钟，却还是把下线的服务加载到了可用服务列表里（upList）,其实这并不怪Ribbon，都是Eureka的错</strong><br> 针对这种情况我们留个彩蛋,下次再来talk about~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cee4c6d587580182ebc350e6910ff177/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Spring Boot】深入解密Spring Boot日志：最佳实践与策略解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a2689d89daa548bc110790d838a21df2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spark-机器学习（1）什么是机器学习与MLlib算法库的认识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>