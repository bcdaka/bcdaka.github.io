<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>南京邮电大学算法与设计实验四：回溯法（最全最新，与题目要求一致） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/68b6036e2b3287676bf6a64eb27355a1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="南京邮电大学算法与设计实验四：回溯法（最全最新，与题目要求一致）">
  <meta property="og:description" content="要求用回溯法求解8-皇后问题，使放置在8*8棋盘上的8个皇后彼此不受攻击，即：任何两个皇后都不在同一行、同一列或同一斜线上。请输出8皇后问题的所有可行解。 用回溯法编写一个递归程序解决如下装载问题：有n个集装箱要装上2艘载重分别为c1和c2的轮船，其中集装箱i的重量为wi（1≤ i ≤ n），且Σ𝑤𝑖≤𝑐1_&#43;_𝑐2_𝑛𝑖=_1_。问是否有一个合理的装载方案可以将这n个集装箱装上这2艘轮船？如果有，请给出装载方案。 提示：参考子集和数问题的求解方法。 举例：当n=3，c1=c2=50，且w=[10,40,40]时，可以将集装箱1和2装到第一艘轮船上，集装箱3装到第二艘轮船上；如果w=[20,40,40]时，无法将这3个集装箱都装上轮船。 实验内容： Transliteration Yāoqiú yòng huísù fǎ qiújiě 8-huánghòu wèntí, shǐ fàngzhì zài 8*8 qípán shàng de 8 gè huánghòu bǐcǐ bù shòu gōngjí, jí: Rènhé liǎng gè huánghòu dōu bùzài tóngyī xíng, tóngyī liè huò tóngyī xié xiàn shàng. Qǐng shūchū 8 huánghòu wèntí de suǒyǒu kěxíng jiě. Yòng huísù fǎ biānxiě yīgè dìguī chéngxù jiějué rúxià zhuāngzǎi wèntí: Yǒu n gè jízhuāngxiāng yào zhuāng shàng 2 sōu zàizhòng fēnbié wèi c1 hé c2 de lúnchuán, qízhōng jízhuāngxiāng i de zhòngliàng wèi wi(1≤ i ≤ n), qiě S𝑤𝑖≤𝑐1_&#43;_𝑐2_𝑛𝑖=_1_.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-20T14:51:03+08:00">
    <meta property="article:modified_time" content="2023-05-20T14:51:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">南京邮电大学算法与设计实验四：回溯法（最全最新，与题目要求一致）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="polyglot__panel"> 
 <div class="polyglot__inner"> 
  <div class="polyglot__section"> 
   <div class="polyglot__translation">
     要求用回溯法求解8-皇后问题，使放置在8*8棋盘上的8个皇后彼此不受攻击，即：任何两个皇后都不在同一行、同一列或同一斜线上。请输出8皇后问题的所有可行解。 
    <br> 用回溯法编写一个递归程序解决如下装载问题：有n个集装箱要装上2艘载重分别为c1和c2的轮船，其中集装箱i的重量为wi（1≤ i ≤ n），且Σ𝑤𝑖≤𝑐1_+_𝑐2_𝑛𝑖=_1_。问是否有一个合理的装载方案可以将这n个集装箱装上这2艘轮船？如果有，请给出装载方案。 
    <br> 提示：参考子集和数问题的求解方法。 
    <br> 举例：当n=3，c1=c2=50，且w=[10,40,40]时，可以将集装箱1和2装到第一艘轮船上，集装箱3装到第二艘轮船上；如果w=[20,40,40]时，无法将这3个集装箱都装上轮船。 
    <br> 实验内容： 
   </div> 
  </div> 
  <div class="polyglot__section"> 
   <div class="polyglot__section--title">
     Transliteration 
   </div> 
   <div class="polyglot__section--content">
     Yāoqiú yòng huísù fǎ qiújiě 8-huánghòu wèntí, shǐ fàngzhì zài 8*8 qípán shàng de 8 gè huánghòu bǐcǐ bù shòu gōngjí, jí: Rènhé liǎng gè huánghòu dōu bùzài tóngyī xíng, tóngyī liè huò tóngyī xié xiàn shàng. Qǐng shūchū 8 huánghòu wèntí de suǒyǒu kěxíng jiě. 
    <br> Yòng huísù fǎ biānxiě yīgè dìguī chéngxù jiějué rúxià zhuāngzǎi wèntí: Yǒu n gè jízhuāngxiāng yào zhuāng shàng 2 sōu zàizhòng fēnbié wèi c1 hé c2 de lúnchuán, qízhōng jízhuāngxiāng i de zhòngliàng wèi wi(1≤ i ≤ n), qiě S𝑤𝑖≤𝑐1_+_𝑐2_𝑛𝑖=_1_. Wèn shìfǒu yǒu yīgè hélǐ de zhuāngzǎi fāng'àn kěyǐ jiāng zhè n gè jízhuāngxiāng zhuāng shàng zhè 2 sōu lúnchuán? Rúguǒ yǒu, qǐng gěi chū zhuāngzǎi fāng'àn. 
    <br> Tíshì: Cānkǎo zǐ jí hé shù wèntí de qiújiě fāngfǎ. 
    <br> Jǔlì: Dāng n=3,c1=c2=50, qiě w=[10,40,40] shí, kěyǐ jiāng jízhuāngxiāng 1 hé 2 zhuāng dào dì yī sōu lúnchuán shàng, jízhuāngxiāng 3 zhuāng dào dì èr sōu lúnchuán shàng; rúguǒ w=[20,40,40] shí, wúfǎ jiāng zhè 3 gè jízhuāngxiāng dōu zhuāng shàng lúnchuán. 
    <br> Shíyàn nèiróng: 
   </div> 
  </div> 
 </div> 
</div> 
<p style="margin-left:0;"><span style="color:#000000;"><strong>实验原理：</strong></span></p> 
<ol><li><span style="color:#000000;">要求用回溯法求解<strong>8-</strong>皇后问题，使放置在8*8棋盘上的8个皇后彼此不受攻击，即：任何两个皇后都不在同一行、同一列或同一斜线上。请输出8皇后问题的所有可行解。</span></li><li><span style="color:#000000;">用回溯法编写一个递归程序解决如下装载问题：有n个集装箱要装上2艘载重分别为c1和c2的轮船，其中集装箱i的重量为wi（1≤ i ≤ n），且Σ𝑤𝑖≤𝑐1_+_𝑐2_𝑛𝑖=_1_。问是否有一个合理的装载方案可以将这n个集装箱装上这2艘轮船？如果有，请给出装载方案。</span></li><li><span style="color:#000000;">提示：参考子集和数问题的求解方法。</span></li><li style="text-align:justify;">举例：当n=3，c1=c2=50，且w=[10,40,40]时，可以将集装箱1和2装到第一艘轮船上，集装箱3装到第二艘轮船上；如果w=[20,40,40]时，无法将这3个集装箱都装上轮船。 <p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><strong><span style="color:#000000;">实验内容：</span></strong></span></p> <h3 style="margin-left:0;"><span style="color:#000000;"><strong> 1</strong><strong>、</strong><strong>8</strong><strong>皇后问题</strong></span></h3> <p style="margin-left:0;text-align:left;"><span style="color:#000000;">通过求解n-皇后问题，体会回溯法深度优先遍历状态空间树，并利用约束函数进行剪枝的算法思想。 代码实现：</span></p> </li><li style="text-align:justify;"> <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

bool Place(int k,int i,int *x){ //判定两个皇后是否在同一列或在同一斜线上
    for(int j=0;j&lt;k;j++)
        if ((x[j]==i)||(abs(x[j]-i)==abs(j-k))) return false;
    return true;
}
void NQueens(int k,int n,int *x){ //递归函数（求解n皇后问题）
    for (int i=0;i&lt;n;i++){
        if(Place(k,i,x)){
            x[k]=i;
            if (k==n-1){
                for (i=0;i&lt;n;i++) cout&lt;&lt;x[i]&lt;&lt;" ";
                cout&lt;&lt;endl;
            }
            else{
                NQueens(k+1,n,x);
            }
        }
    }
}

void NQueens(int n,int *x){
    NQueens(0,n,x);
}

int main()
{
    int x[8];
    for (int i=0;i&lt;8;i++) x[i]=-1;
    NQueens(8,x);
    return 0;
}
</code></pre> <p>实验结果：</p> </li><li style="text-align:justify;"> <p><img alt="" height="666" src="https://images2.imgbox.com/3e/5f/fEaMZAx7_o.png" width="436"><img alt="" height="666" src="https://images2.imgbox.com/69/e0/9TUF3hNq_o.png" width="436"></p> <h4> <span style="color:#000000;"><strong>思考题</strong><strong>1</strong><strong>：请编程实现从</strong><strong>n-</strong><strong>皇后问题的所有</strong><strong>92</strong><strong>种可行解中筛选出</strong><strong>12</strong><strong>种独立解，而其余的解都可以由这些独立解利用对称性或旋转而得到。</strong></span></h4> <p> </p> <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt; // 新增头文件用于调用 memcpy 函数
using namespace std;

bool Place(int k,int i,int *x){ //判定两个皇后是否在同一列或在同一斜线上
    for(int j=0;j&lt;k;j++)
        if ((x[j]==i)||(abs(x[j]-i)==abs(j-k)))
            return false;
    return true;
}

bool IsEquivalent(int n, int *x, int *y) { // 判断两个解是否等价
    for (int i =0; i &lt; n; i++) {
        if (x[i] ==  n - y[i] - 1)
            return false; // 检查是否为旋转等价 false代表不相等
    }

    for (int i = 0; i &lt; n; i++) { // 检查是否为对称等价
        if (x[i] == y[n - 1 - i]) return false;
    }
    return true;
}

void NQueens(int k,int n, int *x, int solutions[100][8], int &amp;num){ //递归函数（求解n皇后问题）
    int i,j,h;
    for (i=0;i&lt;n;i++){
        if(Place(k,i,x)){
            x[k]=i;
            if (k==n-1){
                bool is_independent=true;
                for(j=0; j&lt;num; j++){// 判断是否与已有解等价
                    if(IsEquivalent(n, x, solutions[j])){
                        is_independent = false;
                        break;
                    }
                }

                if(is_independent) {
                    for (h = 0; h &lt; n; h++){
                        solutions[num][h] = x[h];
                    }
                    num++;
                }
            }
            else{
                NQueens(k+1,n,x,solutions,num);
            }
        }
    }
}

void NQueens(int n,int *x,int solutions[100][8], int &amp;num){
    NQueens(0,n,x,solutions,num);
}

int main()
{

    int x[8];
    for (int i=0;i&lt;8;i++)
        x[i]=-1;
    int solutions[100][8];
    int num_solutions = 0;
    NQueens(0,8,x,solutions,num_solutions);
    //NQueens(8,x, solutions,num_solutions);

    cout &lt;&lt; "共找到 " &lt;&lt; num_solutions &lt;&lt; " 种独立解：" &lt;&lt; endl;
    for (int i = 0; i &lt; num_solutions; i++) {
        cout &lt;&lt; "解 " &lt;&lt; i + 1 &lt;&lt; ": ";
        for (int j = 0; j &lt; 8; j++) {
            cout &lt;&lt; solutions[i][j] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre> <p style="margin-left:0;text-align:left;"><span style="color:#000000;"><strong>实验结果：</strong></span></p> </li><li style="text-align:justify;"> <p style="margin-left:0;text-align:left;"><img alt="" height="452" src="https://images2.imgbox.com/d9/c4/fQUgEDJ3_o.png" width="584"></p> <h4><span style="color:#000000;"><strong>思考题</strong><strong>2: </strong><strong>若</strong><strong>n-</strong><strong>皇后问题要求在求得第一个可行解之后算法即终止，请编程实现。</strong></span> </h4> </li></ol> 
<p style="text-align:justify;">代码：</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

bool Place(int k,int i,int *x){ //判定两个皇后是否在同一列或在同一斜线上
    for(int j=0;j&lt;k;j++)
        if ((x[j]==i)||(abs(x[j]-i)==abs(j-k)))
            return false;
    return true;
}
bool NQueens(int k,int n,int *x){ //递归函数（求解n皇后问题）
    for (int i=0;i&lt;n;i++){
        if(Place(k,i,x)){
            x[k]=i;
            if (k==n-1){
                for (i=0;i&lt;n;i++) cout&lt;&lt;x[i]&lt;&lt;" ";
                cout&lt;&lt;endl;
                return true;
            }
            if(NQueens(k+1,n,x))
                return true;
            }
        }
    return false;
    }

void NQueens(int n,int *x){
    NQueens(0,n,x);
}

int main()
{
    int x[8];
    for (int i=0;i&lt;8;i++)
        x[i]=-1;
    NQueens(8,x);
    return 0;
}
</code></pre> 
<p>运行结果： </p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/0a/e4/oBeSMa4X_o.png" width="524"></p> 
<p> </p> 
<h3 style="margin-left:0;text-align:justify;"><span style="color:#000000;"><strong><span style="color:#000000;">2</span></strong><strong><span style="color:#000000;">、装载问题</span></strong></span></h3> 
<p style="margin-left:0;"><span style="color:#000000;">算法实现主体部分已给出，请补充完整，并使用下面三个测试案例调试通过。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">第一艘船载重<strong>60</strong>，第二艘船载重<strong>40</strong>，<strong>5</strong>个集装箱重量分别为：</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（<strong>1</strong>）<strong>22 35 24 19 4 </strong></span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（<strong>2</strong>）<strong>22 35 24 15 4</strong></span></p> 
<p style="margin-left:0;text-align:left;"><span style="color:#000000;">（<strong>3</strong>）<strong>22 35 24 15 3</strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#000000;"><span style="color:#000000;">代码实现：运行结果：</span></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt; // 新增头文件用于调用 memcpy 函数
using namespace std;

class Loading {
private:
    int n, //集装箱数
    *x, //当前解
    *bestx; //当前第一艘船的最优解
    int c1, //第一艘轮船的核定载重量
    c2, //第二艘轮船的核定载重量
    *w, //集装箱重量数组
    total, //所有集装箱重量之和
    cw, //当前第一艘船的载重量
    bestw, //当前第一艘船的最优载重量
    r; //剩余集装箱总重量
public:
    Loading() //构造函数
    {
        n = 5;
        x = new int[n+1];
        bestx = new int[n+1];
        w = new int[n+1];
        c1 = 60;
        c2 = 40;
        w[1] = 22;
        w[2] = 35;
        w[3] = 24;
        w[4] = 19;
        w[5] = 4;
        total = w[1]+w[2]+w[3]+w[4]+w[5];
        r = total;
        bestw = 0;
    }
        ~Loading() //析构函数
        {
            delete[] x;
            delete[] bestx;
            delete[] w;
        }
            void Backtrack(int i); //找到最接近第一艘轮船载重c1的最佳装载方案，
//最优载重值bestw，最优解数组bestx。
            void Show();//输出整个装载方案
};


void Loading::Backtrack(int i)
{ //搜索第i层结点
    if (i&gt;n)
    {//到达叶节点
        if (cw&gt;bestw)
        {
            for (int j=1;j&lt;=n;j++) bestx[j]=x[j];
            bestw=cw;
        }
        return;
    }
//搜索子树
    r-=w[i];
    if (cw+w[i]&lt;=c1) //x[i]=1时的可行解约束条件
    {//搜索左子树
        x[i]=1;
        cw+=w[i];
        Backtrack(i+1);
        cw-=w[i];
    }
    if (cw+r&gt;bestw) //x[i]=0时增加的约束函数，剪去不含最优解的分枝
    {//搜索右子树
        x[i]=0;
        Backtrack(i+1);
    }
    r+=w[i];
}

void Loading::Show()
{
    cout &lt;&lt; "装载方案：" &lt;&lt; endl;
    cout &lt;&lt; "第一艘船：";
    for (int i = 1; i &lt;= n; i++)
    {
        if (bestx[i] == 1)
        {
            cout &lt;&lt; w[i] &lt;&lt; " ";
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; "第二艘船：";
    for (int i = 1; i &lt;= n; i++)
    {
        if (bestx[i] == 0)
        {
            cout &lt;&lt; w[i] &lt;&lt; " ";
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; "第一艘船最优载重量：" &lt;&lt; bestw &lt;&lt; endl;
}

int main()
{
    Loading ld;
    ld.Backtrack(1);
    ld.Show();
    system("pause");
    return 0;
}
</code></pre> 
<div id="webTrans2305247271"> 
 <div class="wordTrans2305247271" id="wordTrans2305247271"> 
  <div class="wordTransIcon2305247271"></div> 
 </div> 
</div> 
<p> 运行结果：</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/2a/48/f0D2yeo5_o.png" width="562"></p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/13/77/cJoD9iKH_o.png" width="562"> </p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/4b/e0/KV1iIgxz_o.png" width="562"> </p> 
<h4 style="margin-left:0;text-align:justify;"><span style="color:#000000;"><strong>思考题</strong><strong>3</strong><strong>：求上面回溯法求解装载问题的计算时间复杂度？有什么方法可以继续改进算法的时间复杂度？</strong></span></h4> 
<p style="margin-left:0;"><span style="color:#000000;">由于bestx可能被更新O(2^n)次，因此该算法的时间复杂度是O(n2^n)。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">改进策略可以有下面两种，均可将算法的时间复杂度降为O(2^n)：</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（1） 首先运行只计算最优值的算法，计算出最优装载量W，所耗时间O(2^n)。然后再将算法Trace中的bestw置为W后运行，这样在首次到达的叶节点处（即首次i&gt;n时）终止算法，返回的bestx即为最优解。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（2） 另一种策略是在算法中动态的更新bestx。在第i层的当前结点处，当前最优解由x[j]，1≤j&lt;i和best[j]，i≤j≤n所组成。每当算法回溯一层时，将x[i]存入bestx[i]。</span></p> 
<h4><span style="color:#000000;"><strong>思考题</strong><strong>4</strong><strong>：请用非递归的迭代回溯方式，重新实现装载问题的求解。</strong></span></h4> 
<p><span style="color:#000000;"><strong>代码：</strong></span></p> 
<h4> </h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;

class Loading {
private:
    int n; // 集装箱数
    int *x; // 当前解
    int *bestx; // 当前第一艘船的最优解
    int c1; // 第一艘轮船的核定载重量
    int c2; // 第二艘轮船的核定载重量
    int *w; // 集装箱重量数组
    int total; // 所有集装箱重量之和
    int cw; // 当前第一艘船的载重量
    int bestw; // 当前第一艘船的最优载重量
    int r; // 剩余集装箱总重量

public:
    Loading() // 构造函数
    {
        n = 5;
        x = new int[n + 1];
        bestx = new int[n + 1];
        w = new int[n + 1];
        c1 = 60;
        c2 = 40;
        w[1] = 22;
        w[2] = 35;
        w[3] = 24;
        w[4] = 19;
        w[5] = 4;
        total = w[1] + w[2] + w[3] + w[4] + w[5];
        r = total;
        bestw = 0;
    }

    ~Loading() // 析构函数
    {
        delete[] x;
        delete[] bestx;
        delete[] w;
    }

    void Backtrack(); // 找到最接近第一艘轮船载重c1的最佳装载方案，最优载重值bestw，最优解数组bestx。
    void Show(); // 输出整个装载方案
};

void Loading::Backtrack()
{
    int i = 1;
    while (i &gt; 0)
    {
        if (i &gt; n)
        {
            // 找到更优的装载方案
            if (cw &gt; bestw)
            {
                memcpy(bestx, x, (n + 1) * sizeof(int));
                bestw = cw;
            }
            
            // 回溯到上一个箱子位置
            i--;
            while (i &gt; 0 &amp;&amp; x[i] == 0)
            {
                cw -= w[i];
                r += w[i];
                i--;
            }
            
            // 如果仍有箱子可选，则放置到第二艘船上
            if (i &gt; 0)
            {
                x[i] = 0;
                cw -= w[i];
                r += w[i];
            }
        }
        else
        {
            // 尝试将箱子放置到第一艘船上
            if (cw + w[i] &lt;= c1)
            {
                x[i] = 1;
                cw += w[i];
                r -= w[i];
                i++;
            }
            else
            {
                // 将箱子放置到第二艘船上
                x[i] = 0;
                r -= w[i];
                i++;
            }
        }
    }
}

void Loading::Show()
{
    cout &lt;&lt; "装载方案：" &lt;&lt; endl;
    cout &lt;&lt; "第一艘船：";
    for (int i = 1; i &lt;= n; i++)
    {
        if (bestx[i] == 1)
        {
            cout &lt;&lt; w[i] &lt;&lt; " ";
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; "第二艘船：";
    for (int i = 1; i &lt;= n; i++)
    {
        if (bestx[i] == 0)
        {
            cout &lt;&lt; w[i] &lt;&lt; " ";
        }
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; "第一艘船最优载重量：" &lt;&lt; bestw &lt;&lt; endl;
}

int main()
{
    Loading ld;
    ld.Backtrack();
    ld.Show();
    return 0;
}
</code></pre> 
<p>运行结果</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/94/91/7itMeN4C_o.png" width="562"></p> 
<p> 码字不易，都看到这了，欢迎打赏！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ef8fce7832076240866c7ef5ab9b3245/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Midjourney的一些“咒语”【自用-1】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f4be5f3674885a0eec1b858694e1b435/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">200&#43;的AI写作工具你值得拥有</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>