<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试题———Spring篇① - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4d592f5adbf0004e9b6e56f9570ff116/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java面试题———Spring篇①">
  <meta property="og:description" content="目录
一，谈谈你对SpringIOC的理解
二，Spring中有哪些依赖注入方式
三，你用过哪些Spring注解
四，SpringBean的作用域有几种
五，Spring中的bean线程安全吗
六，谈谈你对SpringAOP的理解
七，AOP的代理有几种方式
一，谈谈你对SpringIOC的理解 IOC，也叫控制反转，是Spring用来解耦的一种设计思想，它的做法就是将对象的控制权由程序员手中反转到Spring手中。具体来说呢就是，在没有IOC之前，对象都是程序员在类中主动去创建，需要哪个创建哪个；有了IOC之后，对象会交给Spring容器创建和管理，如果哪个对象中需要其它对象属性，Spring也会自动完成依赖注入。
总之一句话，IOC可以将对象的创建和对象之间依赖关系的维护交给Spring自动完成。
二，Spring中有哪些依赖注入方式 依赖注入指的是Spring给对象中属性进行赋值的过程，主要包括两种方式：
构造器依赖注入：构造器注入是指容器调用一个类的构造器创建对象时，直接传入给属性赋值
Setter方法注入：Setter方法注入是指容器在创建对象完成后，通过调用属性的Setter 方法，可以属性赋值
三，你用过哪些Spring注解 我们常用的Spring注解主要分类下面几大类：
1、创建对象：@Component、@Controller、@Service、@Repository
它们都可以标注在自己开发的类上，Spring会使用注解标注的类创建出对象，然后放入容器
2、依赖注入：@Autowired
标注在属性或者属性对应的set方法上，Spring会根据被标注属性的类型自动对属性进行赋值
3、依赖注入：@Qualifier和@Autowired
一块使用，在同一类型的bean有多个的情况下Spring会根据name进行选择注入
4、配置类：@Configuration、@Bean
主要标注在配置类中，用于声明配置类和向Spring容器中放入一些配置有关的对象
5、当然还有一些平时用的不是特别多的
比如：声明注解扫描的@ComponentScan，声明Bean的作用域的@Scope，用于切面编程的@Around，@Pointcut等等
四，SpringBean的作用域有几种 在Spring中作用域是用来对象的存活范围的，它支持5种作用域
第一种是单例，配置为单例的对象会跟随Spring容器创建而创建，跟随Spring容器销毁而销毁，在Spring容器中无论获取多少次单例对象，得到的都是同一个，这也是Spring中的对象的默认作用域
第二种是多例，配置为多例的对象在每次获取的时候才会创建，而且每次获取到的都不一样
还有三种分别是request、session和application，目前已经基本不再使用
其实，在我们平时的开发过程中，对象基本上都是配为单例的，这样可以有效的节省资源，只有单例对象存在线程安全问题时，才考虑调整为多例。
五，Spring中的bean线程安全吗 Spring中的Bean主要分为单例和多例
多例对象每次获取都会创建新实例，也就是说线程之间不存在Bean共享问题，也就不存在线程安全问题
单例对象是所有线程共享一个实例，因此就可能会存在线程安全问题。但是单例对象又分为无状态和有状态。
无状态Bean是指只对对象的成员变量进行查询操作，不会修改成员变量的值，因此不存在线程安全问题
有状态Bean需要对Bean中的成员变量进行数据更新操作，因此就可能存在线程安全问题
所以，最终我们得出结论，在Spring中，只有有状态的单例Bean才会存在线程安全问题
处理有状态单例Bean的线程安全问题有以下两种方法：
将Bean的作用域由单例改为多例
将需要的可变成员变量保存在ThreadLocal中， ThreadLocal本身就具备线程隔离的特性，这就相当于为每个线程提供了一个独立的变量副本，每个线程只需要操作自己的线程副本变量，从而解决线程安全问题。
六，谈谈你对SpringAOP的理解 AOP，又叫面向切面编程，核心思想是将那些与业务无关，却为业务模块所共同调用的逻辑（例如事务处理、日志管理）封装起来，然后再动态插入到业务中的功能
使用AOP可以减少系统的重复代码，降低模块间的耦合度，并有利于扩展和维护，Spring AOP是基于动态代理的，它底层同时支持JDK和CGLIB的代理方式，并且会根据被代理类是否有接口自动选择最合适的代理方式我们在开发中用到AOP的主要使用场景有：事务管理、日志、性能监视、安全检查
七，AOP的代理有几种方式 AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式和CGLIB动态代理模式
JDK动态代理模式只能对有接口的类进行代理，而且效率较高
CGLIB可以对任意的类进行动态代理，但是效率上不如JDK
因此在进行代理时，如果被代理类有接口，就用JDK；如果没有接口，就用CGLIB
使用Spring的AOP，底层会自动按照这个规则进行选择，开发者也无需关心">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T09:32:43+08:00">
    <meta property="article:modified_time" content="2024-08-13T09:32:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试题———Spring篇①</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SpringIOC%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E4%B8%80%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SpringIOC%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">一，谈谈你对SpringIOC的理解</a></p> 
<p id="%E4%BA%8C%EF%BC%8CSpring%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%EF%BC%8CSpring%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F" rel="nofollow">二，Spring中有哪些依赖注入方式</a></p> 
<p id="%E4%B8%89%EF%BC%8C%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BSpring%E6%B3%A8%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E4%B8%89%EF%BC%8C%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BSpring%E6%B3%A8%E8%A7%A3" rel="nofollow">三，你用过哪些Spring注解</a></p> 
<p id="%E5%9B%9B%EF%BC%8CSpringBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%EF%BC%8CSpringBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D" rel="nofollow">四，SpringBean的作用域有几种</a></p> 
<p id="%E4%BA%94%EF%BC%8CSpring%E4%B8%AD%E7%9A%84bean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97-toc" style="margin-left:40px;"><a href="#%E4%BA%94%EF%BC%8CSpring%E4%B8%AD%E7%9A%84bean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97" rel="nofollow">五，Spring中的bean线程安全吗</a></p> 
<p id="%E5%85%AD%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SpringAOP%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E5%85%AD%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SpringAOP%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">六，谈谈你对SpringAOP的理解</a></p> 
<p id="%E4%B8%83%EF%BC%8CAOP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%83%EF%BC%8CAOP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">七，AOP的代理有几种方式</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SpringIOC%E7%9A%84%E7%90%86%E8%A7%A3">一，谈谈你对SpringIOC的理解</h3> 
<blockquote> 
 <p>IOC，也叫控制反转，是Spring用来解耦的一种设计思想，它的做法就是将对象的控制权由程序员手中反转到Spring手中。具体来说呢就是，在没有IOC之前，对象都是程序员在类中主动去创建，需要哪个创建哪个；有了IOC之后，对象会交给Spring容器创建和管理，如果哪个对象中需要其它对象属性，Spring也会自动完成依赖注入。</p> 
 <p>总之一句话，IOC可以将对象的创建和对象之间依赖关系的维护交给Spring自动完成。</p> 
</blockquote> 
<h3 id="%E4%BA%8C%EF%BC%8CSpring%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F">二，Spring中有哪些依赖注入方式</h3> 
<blockquote> 
 <p>依赖注入指的是Spring给对象中属性进行赋值的过程，主要包括两种方式：</p> 
 <ol><li> <p><strong>构造器依赖注入：</strong>构造器注入是指容器调用一个类的构造器创建对象时，直接传入给属性赋值</p> </li><li> <p><strong>Setter方法注入：</strong>Setter方法注入是指容器在创建对象完成后，通过调用属性的Setter 方法，可以属性赋值</p> </li></ol> 
</blockquote> 
<h3 id="%E4%B8%89%EF%BC%8C%E4%BD%A0%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BSpring%E6%B3%A8%E8%A7%A3">三，你用过哪些Spring注解</h3> 
<blockquote> 
 <p>我们常用的Spring注解主要分类下面几大类：</p> 
 <p><strong>1、创建对象：</strong>@Component、@Controller、@Service、@Repository</p> 
 <p>它们都可以标注在自己开发的类上，Spring会使用注解标注的类创建出对象，然后放入容器</p> 
 <p><strong>2、依赖注入：</strong>@Autowired</p> 
 <p>标注在属性或者属性对应的set方法上，Spring会根据被标注属性的类型自动对属性进行赋值</p> 
 <p><strong>3、依赖注入：</strong>@Qualifier和@Autowired</p> 
 <p>一块使用，在同一类型的bean有多个的情况下Spring会根据name进行选择注入</p> 
 <p><strong>4、配置类：</strong>@Configuration、@Bean</p> 
 <p>主要标注在配置类中，用于声明配置类和向Spring容器中放入一些配置有关的对象</p> 
 <p>5、当然还有一些平时用的不是特别多的</p> 
 <p>比如：声明注解扫描的@ComponentScan，声明Bean的作用域的@Scope，用于切面编程的@Around，@Pointcut等等</p> 
</blockquote> 
<h3 id="%E5%9B%9B%EF%BC%8CSpringBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%87%A0%E7%A7%8D">四，SpringBean的作用域有几种</h3> 
<blockquote> 
 <p>在Spring中作用域是用来对象的存活范围的，它支持5种作用域</p> 
 <ul><li> <p>第一种是<strong>单例</strong>，配置为单例的对象会跟随Spring容器创建而创建，跟随Spring容器销毁而销毁，在Spring容器中无论获取多少次单例对象，得到的都是同一个，这也是Spring中的对象的默认作用域</p> </li><li> <p>第二种是<strong>多例</strong>，配置为多例的对象在每次获取的时候才会创建，而且每次获取到的都不一样</p> </li><li> <p>还有三种分别是<strong>request、session和application</strong>，目前已经基本不再使用</p> </li></ul> 
 <p>其实，在我们平时的开发过程中，对象基本上都是配为单例的，这样可以有效的节省资源，只有单例对象存在线程安全问题时，才考虑调整为多例。</p> 
</blockquote> 
<h3 id="%E4%BA%94%EF%BC%8CSpring%E4%B8%AD%E7%9A%84bean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97">五，Spring中的bean线程安全吗</h3> 
<blockquote> 
 <p>Spring中的Bean主要分为<strong>单例和多例</strong></p> 
 <ol><li> <p>多例对象每次获取都会创建新实例，也就是说线程之间不存在Bean共享问题，也就不存在线程安全问题</p> </li><li> <p>单例对象是所有线程共享一个实例，因此就可能会存在线程安全问题。但是单例对象又分为无状态和有状态。</p> 
   <ul><li> <p>无状态Bean是指只对对象的成员变量进行查询操作，不会修改成员变量的值，因此不存在线程安全问题</p> </li><li> <p>有状态Bean需要对Bean中的成员变量进行数据更新操作，因此就可能存在线程安全问题</p> </li></ul></li></ol> 
 <p>所以，最终我们得出结论，在Spring中，只有有状态的单例Bean才会存在线程安全问题</p> 
 <p>处理有状态单例Bean的线程安全问题有以下两种方法：</p> 
 <ol><li> <p>将Bean的作用域由单例改为多例</p> </li><li> <p>将需要的可变成员变量保存在ThreadLocal中， ThreadLocal本身就具备线程隔离的特性，这就相当于为每个线程提供了一个独立的变量副本，每个线程只需要操作自己的线程副本变量，从而解决线程安全问题。</p> </li></ol> 
</blockquote> 
<h3 id="%E5%85%AD%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SpringAOP%E7%9A%84%E7%90%86%E8%A7%A3">六，谈谈你对SpringAOP的理解</h3> 
<blockquote> 
 <p>AOP，又叫<strong>面向切面编程</strong>，核心思想是将那些与业务无关，却为业务模块所共同调用的逻辑（例如事务处理、日志管理）封装起来，然后再动态插入到业务中的功能</p> 
 <p>        使用AOP可以减少系统的重复代码，降低模块间的耦合度，并有利于扩展和维护，Spring AOP是基于动态代理的，它底层同时支持JDK和CGLIB的代理方式，并且会根据被代理类是否有接口自动选择最合适的代理方式我们在开发中用到AOP的主要使用场景有：<strong>事务管理、日志、性能监视、安全检查</strong></p> 
</blockquote> 
<h3 id="%E4%B8%83%EF%BC%8CAOP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">七，AOP的代理有几种方式</h3> 
<blockquote> 
 <p>AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式和CGLIB动态代理模式</p> 
 <ol><li> <p>JDK动态代理模式只能对有接口的类进行代理，而且效率较高</p> </li><li> <p>CGLIB可以对任意的类进行动态代理，但是效率上不如JDK</p> </li></ol> 
 <p>因此在进行代理时，如果被代理类有接口，就用JDK；如果没有接口，就用CGLIB</p> 
 <p>使用Spring的AOP，底层会自动按照这个规则进行选择，开发者也无需关心</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b8338c8554702207a4c4700a6dfba1a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Uniapp之微信小程序计算器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/917c8f7605c6bbf61c18d7ca3181a21e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里云智能大数据演进</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>