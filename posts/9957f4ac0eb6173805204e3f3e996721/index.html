<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python酷库之旅-第三方库Pandas(003) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9957f4ac0eb6173805204e3f3e996721/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python酷库之旅-第三方库Pandas(003)">
  <meta property="og:description" content="目录
一、用法精讲
4、pandas.read_csv函数
4-1、语法
4-2、参数
4-3、功能
4-4、返回值
4-5、说明
4-6、用法
4-6-1、创建csv文件
4-6-2、代码示例 4-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 4、pandas.read_csv函数 4-1、语法 # 4、pandas.read_csv函数 pandas.read_csv(filepath_or_buffer, *, sep=_NoDefault.no_default, delimiter=None, header=&#39;infer&#39;, names=_NoDefault.no_default, index_col=None, usecols=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=_NoDefault.no_default, skip_blank_lines=True, parse_dates=None, infer_datetime_format=_NoDefault.no_default, keep_date_col=_NoDefault.no_default, date_parser=_NoDefault.no_default, date_format=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression=&#39;infer&#39;, thousands=None, decimal=&#39;.&#39;, lineterminator=None, quotechar=&#39;&#34;&#39;, quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors=&#39;strict&#39;, dialect=None, on_bad_lines=&#39;error&#39;, delim_whitespace=_NoDefault.no_default, low_memory=True, memory_map=False, float_precision=None, storage_options=None, dtype_backend=_NoDefault.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-05T12:47:12+08:00">
    <meta property="article:modified_time" content="2024-07-05T12:47:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python酷库之旅-第三方库Pandas(003)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#1a439c;">目录</span></strong></p> 
<p id="%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2-toc" style="margin-left:80px;"><strong><a href="#%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2" rel="nofollow"><span style="color:#1a439c;">一、用法精讲</span></a></strong></p> 
<p id="1%E3%80%81pandas.read_pickle%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81pandas.read_pickle%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">4、pandas.read_csv函数</span></a></strong></p> 
<p id="3-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#3-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">4-1、语法</span></a></strong></p> 
<p id="3-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:160px;"><strong><a href="#3-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">4-2、参数</span></a></strong></p> 
<p id="3-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:160px;"><strong><a href="#3-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">4-3、功能</span></a></strong></p> 
<p id="3-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:160px;"><strong><a href="#3-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">4-4、返回值</span></a></strong></p> 
<p id="3-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:160px;"><strong><a href="#3-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">4-5、说明</span></a></strong></p> 
<p id="3-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:160px;"><strong><a href="#3-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">4-6、用法</span></a></strong></p> 
<p id="3-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-toc" style="margin-left:200px;"><strong><a href="#3-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">4-6-1、创建csv文件</span></a></strong></p> 
<p id="4-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%C2%A0-toc" style="margin-left:200px;"><strong><a href="#4-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%C2%A0" rel="nofollow"><span style="color:#1a439c;">4-6-2、代码示例 </span></a></strong></p> 
<p id="3-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA-toc" style="margin-left:200px;"><strong><a href="#3-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA" rel="nofollow"><span style="color:#1a439c;">4-6-3、结果输出</span></a></strong></p> 
<p id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-toc" style="margin-left:80px;"><strong><a href="#%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" rel="nofollow"><span style="color:#1a439c;">二、推荐阅读</span></a></strong></p> 
<p id="1%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#1%E3%80%81" rel="nofollow"><span style="color:#1a439c;">1、Python筑基之旅</span></a></strong></p> 
<p id="2%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#2%E3%80%81" rel="nofollow"><span style="color:#1a439c;">2、Python函数之旅</span></a></strong></p> 
<p id="3%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#3%E3%80%81" rel="nofollow"><span style="color:#1a439c;">3、Python算法之旅</span></a></strong></p> 
<p id="4%E3%80%81-toc" style="margin-left:120px;"><strong><a href="#4%E3%80%81" rel="nofollow"><span style="color:#1a439c;">4、Python魔法之旅</span></a></strong></p> 
<p id="5%E3%80%81%C2%A0-toc" style="margin-left:120px;"><strong><a href="#5%E3%80%81%C2%A0" rel="nofollow"><span style="color:#1a439c;">5、博客个人主页</span></a></strong></p> 
<div> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/7f/ZYYzjFhL_o.gif"></p> 
</div> 
<div> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/b6/70/aYu8RUoT_o.png"></p> 
</div> 
<div> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/f1/04/vMzm7eCz_o.gif"></p> 
</div> 
<h4 id="%E4%B8%80%E3%80%81%E7%94%A8%E6%B3%95%E7%B2%BE%E8%AE%B2">一、用法精讲</h4> 
<h5 id="1%E3%80%81pandas.read_pickle%E5%87%BD%E6%95%B0">4、<span style="color:#fe2c24;">pandas.read_csv</span>函数</h5> 
<h6 id="3-1%E3%80%81%E8%AF%AD%E6%B3%95">4-1、语法</h6> 
<div> 
 <pre><code class="language-python"># 4、pandas.read_csv函数
pandas.read_csv(filepath_or_buffer, *, sep=_NoDefault.no_default, delimiter=None, header='infer', names=_NoDefault.no_default, index_col=None, usecols=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=_NoDefault.no_default, skip_blank_lines=True, parse_dates=None, infer_datetime_format=_NoDefault.no_default, keep_date_col=_NoDefault.no_default, date_parser=_NoDefault.no_default, date_format=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal='.', lineterminator=None, quotechar='"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors='strict', dialect=None, on_bad_lines='error', delim_whitespace=_NoDefault.no_default, low_memory=True, memory_map=False, float_precision=None, storage_options=None, dtype_backend=_NoDefault.no_default)
Read a comma-separated values (csv) file into DataFrame.

Also supports optionally iterating or breaking of the file into chunks.

Additional help can be found in the online docs for IO Tools.

Parameters:
filepath_or_bufferstr, path object or file-like object
Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.csv.

If you want to pass in a path object, pandas accepts any os.PathLike.

By file-like object, we refer to objects with a read() method, such as a file handle (e.g. via builtin open function) or StringIO.

sepstr, default ‘,’
Character or regex pattern to treat as the delimiter. If sep=None, the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator from only the first valid row of the file by Python’s builtin sniffer tool, csv.Sniffer. In addition, separators longer than 1 character and different from '\s+' will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: '\r\t'.

delimiterstr, optional
Alias for sep.

headerint, Sequence of int, ‘infer’ or None, default ‘infer’
Row number(s) containing column labels and marking the start of the data (zero-indexed). Default behavior is to infer the column names: if no names are passed the behavior is identical to header=0 and column names are inferred from the first line of the file, if column names are passed explicitly to names then the behavior is identical to header=None. Explicitly pass header=0 to be able to replace existing names. The header can be a list of integers that specify row locations for a MultiIndex on the columns e.g. [0, 1, 3]. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if skip_blank_lines=True, so header=0 denotes the first line of data rather than the first line of the file.

namesSequence of Hashable, optional
Sequence of column labels to apply. If the file contains a header row, then you should explicitly pass header=0 to override the column names. Duplicates in this list are not allowed.

index_colHashable, Sequence of Hashable or False, optional
Column(s) to use as row label(s), denoted either by column labels or column indices. If a sequence of labels or indices is given, MultiIndex will be formed for the row labels.

Note: index_col=False can be used to force pandas to not use the first column as the index, e.g., when you have a malformed file with delimiters at the end of each line.

usecolsSequence of Hashable or Callable, optional
Subset of columns to select, denoted either by column labels or column indices. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in names or inferred from the document header row(s). If names are given, the document header row(s) are not taken into account. For example, a valid list-like usecols parameter would be [0, 1, 2] or ['foo', 'bar', 'baz']. Element order is ignored, so usecols=[0, 1] is the same as [1, 0]. To instantiate a DataFrame from data with element order preserved use pd.read_csv(data, usecols=['foo', 'bar'])[['foo', 'bar']] for columns in ['foo', 'bar'] order or pd.read_csv(data, usecols=['foo', 'bar'])[['bar', 'foo']] for ['bar', 'foo'] order.

If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True. An example of a valid callable argument would be lambda x: x.upper() in ['AAA', 'BBB', 'DDD']. Using this parameter results in much faster parsing time and lower memory usage.

dtypedtype or dict of {Hashabledtype}, optional
Data type(s) to apply to either the whole dataset or individual columns. E.g., {'a': np.float64, 'b': np.int32, 'c': 'Int64'} Use str or object together with suitable na_values settings to preserve and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion.

New in version 1.5.0: Support for defaultdict was added. Specify a defaultdict as input where the default determines the dtype of the columns which are not explicitly listed.

engine{‘c’, ‘python’, ‘pyarrow’}, optional
Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine.

New in version 1.4.0: The ‘pyarrow’ engine was added as an experimental engine, and some features are unsupported, or may not work correctly, with this engine.

convertersdict of {HashableCallable}, optional
Functions for converting values in specified columns. Keys can either be column labels or column indices.

true_valueslist, optional
Values to consider as True in addition to case-insensitive variants of ‘True’.

false_valueslist, optional
Values to consider as False in addition to case-insensitive variants of ‘False’.

skipinitialspacebool, default False
Skip spaces after delimiter.

skiprowsint, list of int or Callable, optional
Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file.

If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be lambda x: x in [0, 2].

skipfooterint, default 0
Number of lines at bottom of file to skip (Unsupported with engine='c').

nrowsint, optional
Number of rows of file to read. Useful for reading pieces of large files.

na_valuesHashable, Iterable of Hashable or dict of {HashableIterable}, optional
Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. By default the following values are interpreted as NaN: “ “, “#N/A”, “#N/A N/A”, “#NA”, “-1.#IND”, “-1.#QNAN”, “-NaN”, “-nan”, “1.#IND”, “1.#QNAN”, “&lt;NA&gt;”, “N/A”, “NA”, “NULL”, “NaN”, “None”, “n/a”, “nan”, “null “.

keep_default_nabool, default True
Whether or not to include the default NaN values when parsing the data. Depending on whether na_values is passed in, the behavior is as follows:

If keep_default_na is True, and na_values are specified, na_values is appended to the default NaN values used for parsing.

If keep_default_na is True, and na_values are not specified, only the default NaN values are used for parsing.

If keep_default_na is False, and na_values are specified, only the NaN values specified na_values are used for parsing.

If keep_default_na is False, and na_values are not specified, no strings will be parsed as NaN.

Note that if na_filter is passed in as False, the keep_default_na and na_values parameters will be ignored.

na_filterbool, default True
Detect missing value markers (empty strings and the value of na_values). In data without any NA values, passing na_filter=False can improve the performance of reading a large file.

verbosebool, default False
Indicate number of NA values placed in non-numeric columns.

Deprecated since version 2.2.0.

skip_blank_linesbool, default True
If True, skip over blank lines rather than interpreting as NaN values.

parse_datesbool, list of Hashable, list of lists or dict of {Hashablelist}, default False
The behavior is as follows:

bool. If True -&gt; try parsing the index. Note: Automatically set to True if date_format or date_parser arguments have been passed.

list of int or names. e.g. If [1, 2, 3] -&gt; try parsing columns 1, 2, 3 each as a separate date column.

list of list. e.g. If [[1, 3]] -&gt; combine columns 1 and 3 and parse as a single date column. Values are joined with a space before parsing.

dict, e.g. {'foo' : [1, 3]} -&gt; parse columns 1, 3 as date and call result ‘foo’. Values are joined with a space before parsing.

If a column or index cannot be represented as an array of datetime, say because of an unparsable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use to_datetime() after read_csv().

Note: A fast-path exists for iso8601-formatted dates.

infer_datetime_formatbool, default False
If True and parse_dates is enabled, pandas will attempt to infer the format of the datetime strings in the columns, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by 5-10x.

Deprecated since version 2.0.0: A strict version of this argument is now the default, passing it has no effect.

keep_date_colbool, default False
If True and parse_dates specifies combining multiple columns then keep the original columns.

date_parserCallable, optional
Function to use for converting a sequence of string columns to an array of datetime instances. The default uses dateutil.parser.parser to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments.

Deprecated since version 2.0.0: Use date_format instead, or read in as object and then apply to_datetime() as-needed.

date_formatstr or dict of column -&gt; format, optional
Format to use for parsing dates when used in conjunction with parse_dates. The strftime to parse time, e.g. "%d/%m/%Y". See strftime documentation for more information on choices, though note that "%f" will parse all the way up to nanoseconds. You can also pass:

“ISO8601”, to parse any ISO8601
time string (not necessarily in exactly the same format);

“mixed”, to infer the format for each element individually. This is risky,
and you should probably use it along with dayfirst.

New in version 2.0.0.

dayfirstbool, default False
DD/MM format dates, international and European format.

cache_datesbool, default True
If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.

iteratorbool, default False
Return TextFileReader object for iteration or getting chunks with get_chunk().

chunksizeint, optional
Number of lines to read from the file per chunk. Passing a value will cause the function to return a TextFileReader object for iteration. See the IO Tools docs for more information on iterator and chunksize.

compressionstr or dict, default ‘infer’
For on-the-fly decompression of on-disk data. If ‘infer’ and ‘filepath_or_buffer’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). If using ‘zip’ or ‘tar’, the ZIP file must contain only one data file to be read in. Set to None for no decompression. Can also be a dict with key 'method' set to one of {'zip', 'gzip', 'bz2', 'zstd', 'xz', 'tar'} and other key-value pairs are forwarded to zipfile.ZipFile, gzip.GzipFile, bz2.BZ2File, zstandard.ZstdDecompressor, lzma.LZMAFile or tarfile.TarFile, respectively. As an example, the following could be passed for Zstandard decompression using a custom compression dictionary: compression={'method': 'zstd', 'dict_data': my_compression_dict}.

New in version 1.5.0: Added support for .tar files.

Changed in version 1.4.0: Zstandard support.

thousandsstr (length 1), optional
Character acting as the thousands separator in numerical values.

decimalstr (length 1), default ‘.’
Character to recognize as decimal point (e.g., use ‘,’ for European data).

lineterminatorstr (length 1), optional
Character used to denote a line break. Only valid with C parser.

quotecharstr (length 1), optional
Character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored.

quoting{0 or csv.QUOTE_MINIMAL, 1 or csv.QUOTE_ALL, 2 or csv.QUOTE_NONNUMERIC, 3 or csv.QUOTE_NONE}, default csv.QUOTE_MINIMAL
Control field quoting behavior per csv.QUOTE_* constants. Default is csv.QUOTE_MINIMAL (i.e., 0) which implies that only fields containing special characters are quoted (e.g., characters defined in quotechar, delimiter, or lineterminator.

doublequotebool, default True
When quotechar is specified and quoting is not QUOTE_NONE, indicate whether or not to interpret two consecutive quotechar elements INSIDE a field as a single quotechar element.

escapecharstr (length 1), optional
Character used to escape other characters.

commentstr (length 1), optional
Character indicating that the remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as skip_blank_lines=True), fully commented lines are ignored by the parameter header but not by skiprows. For example, if comment='#', parsing #empty\na,b,c\n1,2,3 with header=0 will result in 'a,b,c' being treated as the header.

encodingstr, optional, default ‘utf-8’
Encoding to use for UTF when reading/writing (ex. 'utf-8'). List of Python standard encodings .

encoding_errorsstr, optional, default ‘strict’
How encoding errors are treated. List of possible values .

New in version 1.3.0.

dialectstr or csv.Dialect, optional
If provided, this parameter will override values (default or not) for the following parameters: delimiter, doublequote, escapechar, skipinitialspace, quotechar, and quoting. If it is necessary to override values, a ParserWarning will be issued. See csv.Dialect documentation for more details.

on_bad_lines{‘error’, ‘warn’, ‘skip’} or Callable, default ‘error’
Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :

'error', raise an Exception when a bad line is encountered.

'warn', raise a warning when a bad line is encountered and skip that line.

'skip', skip bad lines without raising or warning when they are encountered.

New in version 1.3.0.

New in version 1.4.0:

Callable, function with signature (bad_line: list[str]) -&gt; list[str] | None that will process a single bad line. bad_line is a list of strings split by the sep. If the function returns None, the bad line will be ignored. If the function returns a new list of strings with more elements than expected, a ParserWarning will be emitted while dropping extra elements. Only supported when engine='python'

Changed in version 2.2.0:

Callable, function with signature as described in pyarrow documentation when engine='pyarrow'

delim_whitespacebool, default False
Specifies whether or not whitespace (e.g. ' ' or '\t') will be used as the sep delimiter. Equivalent to setting sep='\s+'. If this option is set to True, nothing should be passed in for the delimiter parameter.

Deprecated since version 2.2.0: Use sep="\s+" instead.

low_memorybool, default True
Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set False, or specify the type with the dtype parameter. Note that the entire file is read into a single DataFrame regardless, use the chunksize or iterator parameter to return the data in chunks. (Only valid with C parser).

memory_mapbool, default False
If a filepath is provided for filepath_or_buffer, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.

float_precision{‘high’, ‘legacy’, ‘round_trip’}, optional
Specifies which converter the C engine should use for floating-point values. The options are None or 'high' for the ordinary converter, 'legacy' for the original lower precision pandas converter, and 'round_trip' for the round-trip converter.

storage_optionsdict, optional
Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to urllib.request.Request as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to fsspec.open. Please see fsspec and urllib for more details, and for more examples on storage options refer here.

dtype_backend{‘numpy_nullable’, ‘pyarrow’}, default ‘numpy_nullable’
Back-end data type applied to the resultant DataFrame (still experimental). Behaviour is as follows:

"numpy_nullable": returns nullable-dtype-backed DataFrame (default).

"pyarrow": returns pyarrow-backed nullable ArrowDtype DataFrame.

New in version 2.0.

Returns:
DataFrame or TextFileReader
A comma-separated values (csv) file is returned as two-dimensional data structure with labeled axes.</code></pre> 
</div> 
<h6 id="3-2%E3%80%81%E5%8F%82%E6%95%B0">4-2、参数</h6> 
<p><span style="color:#fe2c24;"><strong>4-2-1、filepath_or_buffer</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>文件的路径对象或任何对象具有read()方法(如文件句柄或类似文件的对象)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-2、sep/delimiter</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字段分隔符。如果未指定，则尝试自动检测。使用sep而不是delimiter，其中delimiter的默认值为None。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-3、header</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为‘infer’)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定哪行(从0开始计数)作为列名，如果文件中没有列标题，则默认为 'infer'。如果为整数或整数列表，则假定这些行是列名。如果为 'infer'，则尝试自动检测列名。如果传递了None，则不会将任何行视为列名。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-4、names</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于结果的列名的列表，如果文件不包含列标题行，则需要提供此参数。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-5、index_col</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用作行索引的列编号或列名，可以是整数、列名字符串或列名的列表。如果为None(默认)，则使用从0开始的整数索引。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-6、usecols</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>返回一个子集的列。默认情况下，解析所有列。如果为整数列表，则返回这些位置的列；如果为字符串列表，则返回这些名称的列。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-7、dtype</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>数据或列的数据类型。可以是单个类型或类型字典。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-8、engine</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于文件解析的解析引擎：{'c', 'python'}，其中，'c'引擎更快，但'python'引擎是更灵活的。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-9、converters</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>列的转换器字典。键可以是列名或列的索引(从0开始)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-10、true_values/false_values</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于将字符串值转换为布尔值的序列。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-11、skipinitialspace</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为False)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>跳过字段值的初始空格。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-12、skiprows</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>需要跳过的行号列表(从0开始)，或跳过文件开头的行数。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-13、skipfooter</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为0)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>从文件末尾跳过的行数(不支持迭代或分块读取)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-14、nrows</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>需要读取的行数(从文件开始算起)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-15、na_values</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>附加识别为NA/missing的字符串列表。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-16、keep_default_na</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果指定了na_values参数，并且keep_default_na为False，则默认NA值将被忽略。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-17、na_filter</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>检测缺失值标记(空字符串和na_values)。对于大型数据集，设置为False可以提高读取性能。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-18、verbose</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span> 如果发生错误，则打印更多信息。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-19、skip_blank_lines</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果为True，则跳过空行；否则将其视为NaN。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-20、parse_dates</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为False)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>尝试将数据解析为日期。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-21、infer_datetime_format</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果为True，并且parse_dates也被启用，pandas将尝试推断日期/时间的格式。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-22、keep_date_col</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果连接多列来解析日期，则保留原始列。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-23、date_parser</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于解析日期的函数。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-24、date_format</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>字符串或字符串列表，用于指定日期/时间的格式。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-25、dayfirst</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为False)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>当解析日期时，是否将日放在月之前。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-26、cache_dates</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果为True，则使用缓存的日期解析器。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-27、iterator</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为False)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果为True，则返回TextFileReader对象，用于增量迭代。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-28、chunksize</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定读取文件的块大小(对于迭代)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-29、compression</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'infer')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于读取文件的压缩类型，如'gzip', 'bz2', 'zip', 'xz' 或 'infer'(如果文件扩展名已知)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-30、thousands</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>千位分隔符。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-31、decimal</strong></span><span style="color:#956fe7;"><strong>(可选，默认值'.')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>小数点字符。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-32、lineterminator</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>行尾字符串(仅对C引擎有效)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-33、quotechar</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于标识字段中引用的字符(仅对C引擎有效)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-34、quoting</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为0)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>控制引号的处理方式的参数(仅对C引擎有效)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-35、doublequote</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>当字段和引号字符都被引用时，指示是否应解释两个引号字符为一个(仅对C引擎有效)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-36、escapechar</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>当在字段中需要包含引号字符时，用于转义该引号字符的字符(仅对C引擎有效)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-37、comment</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>标识注释字符的开始，行中该字符之后的部分将被忽略。如果为None(默认值)，则不忽略任何行。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-38、encoding</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于解码文件的编码。如果为None(默认值)，则尝试使用Python的locale.getpreferredencoding(False)来获取系统默认的编码。如果文件包含非ASCII字符，并且没有指定编码，这可能会导致解码错误。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-39、encoding_errors</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为strict)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定如何处理编码错误。有效选项包括'strict'、'ignore'、'replace'、'surrogatepass'等，'strict'(默认值)将引发异常，'ignore'将忽略错误，'replace'将使用<code>?</code>替换错误字符，'surrogatepass'将允许通过代理对(surrogate pairs)表示UTF-16字符，这可能在某些情况下导致不可预见的错误。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-40、dialect</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果指定，则解析器将尝试使用提供的方言参数集，这通常用于更复杂的CSV文件，其中需要更详细的控制(如Excel CSV文件)。pandas本身并不直接支持复杂的方言定义，但这个参数可以与其他支持方言的库(如csv模块)一起使用，但这在pandas.read_table()中并不常见。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-41、on_bad_lines</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为'error')</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定在读取过程中遇到“坏行”(即格式不正确的行)时的行为，有效选项包括'error'(默认值，抛出异常)、'warn'(发出警告并跳过该行)、'skip'(仅跳过该行)。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-42、delim_whitespace</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果为<code>True</code>，则使用任何空白字符(如空格、制表符等)作为字段分隔符。注意，这与仅指定<code>sep='\s+'</code>不同，因为<code>sep='\s+'</code>将使用正则表达式来匹配一个或多个空白字符作为分隔符，而delim_whitespace=True则允许任何空白字符作为分隔符，并且不会将连续的空白字符视为单个分隔符。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-43、low_memory</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为True)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果为True(默认值)，则尝试以较低内存的方式读取文件，特别是通过分块读取数据，这可能对于处理大文件很有用，但可能会牺牲一些性能。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-44、memory_map</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为False)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>如果为True，则使用内存映射文件来读取数据，这可以提高读取大文件的性能，但可能会增加内存使用量。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-45、float_precision</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定写入输出文件时浮点数的精度(小数点后的位数)，这主要用于写入操作，而不是read_table()方法的直接参数，但在这里提及以供参考。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-46、storage_options</strong></span><span style="color:#956fe7;"><strong>(可选，默认值为None)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>用于存储后端(如HDFS、S3等)的额外选项，这是一个字典，可以包含与存储后端相关的配置选项。</p> 
<p><span style="color:#fe2c24;"><strong>4-2-47、dtype_backend</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>指定用于处理数据类型的后端，这通常不需要用户直接设置，因为pandas会根据文件内容和提供的其他参数自动选择适当的后端。</p> 
<h6 id="3-3%E3%80%81%E5%8A%9F%E8%83%BD">4-3、功能</h6> 
<p>        用于读取CSV(逗号分隔值)文件并将其转换为DataFrame对象。</p> 
<h6 id="3-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">4-4、返回值</h6> 
<p>        返回一个pandas.DataFrame对象，该对象包含了从指定文件路径或文件对象中读取的数据。</p> 
<h6 id="3-5%E3%80%81%E8%AF%B4%E6%98%8E">4-5、说明</h6> 
<p>        无</p> 
<h6 id="3-6%E3%80%81%E7%94%A8%E6%B3%95">4-6、用法</h6> 
<h6 id="3-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B">4-6-1、创建csv文件</h6> 
<div> 
 <pre><code class="language-python"># 4、创建csv文件的两种方式
# 4-1、用csv库
import csv
# 要写入CSV的数据
rows = [
    ["Name", "Age", "City"],
    ["Myelsa", 42, "New York"],
    ["Bryce", 6, "Los Angeles"],
    ["Jimmy", 35, "Chicago"]
]
# 打开文件以写入，如果文件不存在则创建
with open('example.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    # 写入所有行
    writer.writerows(rows)
print("CSV文件已使用csv创建！")

# 4-2、用Pandas库
import pandas as pd
# 要写入CSV的数据
data = {
    'Name': ['Myelsa', 'Bryce', 'Jimmy'],
    'Age': [42, 6, 15],
    'City': ['New York', 'Los Angeles', 'Chicago']
}
# 创建DataFrame
df = pd.DataFrame(data)
# 将DataFrame写入CSV文件
df.to_csv('example.csv', index=False)  # index=False表示不将行索引写入文件
print("CSV文件已使用pandas创建！")
</code></pre> 
</div> 
<h6 id="4-6-2%E3%80%81%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%C2%A0">4-6-2、代码示例 </h6> 
<pre><code class="language-python"># 4-3、基本读取
import pandas as pd
# 读取CSV文件
df = pd.read_csv('example.csv')
# 显示前几行数据
print(df.head())

# 4-4、指定分隔符
import pandas as pd
df = pd.read_csv('example.csv', sep=';')
print(df.head())

# 4-5、跳过行和指定列
import pandas as pd
# 跳过前两行，并只读取第一列和第三列
df = pd.read_csv('example.csv', skiprows=2, usecols=[0, 2])
print(df.head())

# 4-6、 指定列名
import pandas as pd
# 假设文件没有列头，我们手动指定列名
df = pd.read_csv('example.csv', header=None, names=['Name_1', 'Age_1', 'City_1'])
print(df.head())</code></pre> 
<h6 id="3-6-2%E3%80%81%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA">4-6-3、结果输出</h6> 
<div> 
 <pre><code class="language-python"># 4-3、基本读取
#      Name  Age         City
# 0  Myelsa   42     New York
# 1   Bryce    6  Los Angeles
# 2   Jimmy   15      Chicago

# 4-4、指定分隔符
#          Name,Age,City
# 0   Myelsa,42,New York
# 1  Bryce,6,Los Angeles
# 2     Jimmy,15,Chicago

# 4-5、跳过行和指定列
#    Bryce Los Angeles
# 0  Jimmy     Chicago

# 4-6、 指定列名
#    Name_1 Age_1       City_1
# 0    Name   Age         City
# 1  Myelsa    42     New York
# 2   Bryce     6  Los Angeles
# 3   Jimmy    15      Chicago
</code></pre> 
</div> 
<h4 id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">二、推荐阅读</h4> 
<h5 id="1%E3%80%81">1、<a href="https://myelsa1024.blog.csdn.net/article/details/139241094?spm=1001.2014.3001.5502" rel="nofollow" title="Python筑基之旅">Python筑基之旅</a></h5> 
<h5 id="2%E3%80%81">2、<a href="https://myelsa1024.blog.csdn.net/article/details/138916144?spm=1001.2014.3001.5502" rel="nofollow" title="Python函数之旅">Python函数之旅</a></h5> 
<h5 id="3%E3%80%81">3、<a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Python算法之旅">Python算法之旅</a></h5> 
<h5 id="4%E3%80%81">4、<a href="https://myelsa1024.blog.csdn.net/article/details/139555733" rel="nofollow" title="Python魔法之旅">Python魔法之旅</a></h5> 
<h5 id="5%E3%80%81%C2%A0">5、<a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="博客个人主页">博客个人主页</a></h5>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7265d54f03968533e7d4f0739e9408ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot | 大新闻项目后端（redis优化登录）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/16e366153146d3f8daef3d7bc40bae81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">0/1背包问题总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>