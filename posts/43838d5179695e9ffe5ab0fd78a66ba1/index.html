<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言：扫雷游戏实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/43838d5179695e9ffe5ab0fd78a66ba1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言：扫雷游戏实现">
  <meta property="og:description" content="一、扫雷游戏的分析和设计 扫雷游戏想必大家都玩过吧，初级的玩法是在一个9*9的棋盘上找到没有雷的格子，而今天我们就要做的就是9*9扫雷游戏的实现。
1、游戏功能和规则 使用控制台实现经典的扫雷游戏游戏可以通过菜单实现继续玩或者退出游戏扫雷的棋盘是9*9的格⼦默认随机布置10个雷（可随意）可以排查雷 如果位置不是雷，就显示周围有几个雷
如果位置是雷，就炸死游戏结束
把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束
2、游戏实现思路 首先，创建一个主函数用于判断是否进行游戏，并设计一个菜单。创建用于存放雷的棋盘，并进行棋盘的初始化。设计棋盘的打印。放入雷，并实现有雷棋盘的打印。输入坐标进行排查，并返回排查结果。进行循环直到排查成功或被炸死。 在布置雷的过程中我们将雷设置为&#39;1&#39;,不是雷设置为&#39;0&#39;; 二、代码实现 在实现代码前，我们可以用多文件的方式，对我们的函数进行声明和定义，这样可以简化和简洁直观的设计和表达代码。
game.h:我们可以在game.h文件中包含我们所有需要用到的头文件，常量的定义和函数的声明，其他文件只需要声明game.h 即可。game.c:写入游戏所需要的功能函数。test.c:代码的整合 1、主函数的实现 在主函数中我们先创建一个input值，用于输入我们的选择，根据 do while 循环判断我们是否进行游戏，并且每次循环都打印菜单，在接着使用switch语句根据玩家输入进行判断，如果输入为1就开始游戏执行game(),如果为0，游戏结束并跳出循环，如果输入错误就继续进行循环直到主动退出。
int main() { int input = 0; srand((unsigned int)time(NULL)); do { menu(); printf(&#34;请输入选项：&#34;); scanf(&#34;%d&#34;, &amp;input); switch (input) { case 1: printf(&#34;开始游戏\n&#34;); game(); break; case 0: printf(&#34;游戏结束\n&#34;); break; default: printf(&#34;选择错误，请重新选择：\n&#34;); break; } } while (input); return 0; } 2、菜单的实现 不需要返回所以用void
void menu() { printf(&#34;****************\n&#34;); printf(&#34;**** 1.play ****\n&#34;); printf(&#34;**** 0.exit ****\n&#34;); printf(&#34;****************\n&#34;); } 3、游戏函数的实现 1、棋盘的设计 在排雷的过程中如果我们选择的位置不是雷就会看它周围的8个坐标中是否有雷，如果有雷就会显示雷的个数。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T20:44:40+08:00">
    <meta property="article:modified_time" content="2024-07-25T20:44:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言：扫雷游戏实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、扫雷游戏的分析和设计</h2> 
<p>扫雷游戏想必大家都玩过吧，初级的玩法是在一个9*9的棋盘上找到没有雷的格子，而今天我们就要做的就是9*9扫雷游戏的实现。</p> 
<h3>1、游戏功能和规则</h3> 
<blockquote> 
 <ul><li>使用控制台实现经典的扫雷游戏</li><li>游戏可以通过菜单实现继续玩或者退出游戏</li><li>扫雷的棋盘是9*9的格⼦</li><li>默认随机布置10个雷（可随意）</li><li>可以排查雷</li></ul> 
 <p>如果位置不是雷，就显示周围有几个雷</p> 
 <p>如果位置是雷，就炸死游戏结束</p> 
 <p>把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束</p> 
</blockquote> 
<p><img alt="" height="300" src="https://images2.imgbox.com/69/18/i9W6FNY0_o.png" width="271"></p> 
<h3>2、游戏实现思路</h3> 
<blockquote> 
 <ol><li>首先，创建一个主函数用于判断是否进行游戏，并设计一个菜单。</li><li>创建用于存放雷的棋盘，并进行棋盘的初始化。</li><li>设计棋盘的打印。</li><li>放入雷，并实现有雷棋盘的打印。</li><li>输入坐标进行排查，并返回排查结果。</li><li>进行循环直到排查成功或被炸死。</li></ol> 
</blockquote> 
<p>在布置雷的过程中我们将雷设置为'1',不是雷设置为'0'; </p> 
<h2>二、代码实现</h2> 
<p>在实现代码前，我们可以用多文件的方式，对我们的函数进行声明和定义，这样可以简化和简洁直观的设计和表达代码。</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/3d/e0/pGFcNYTd_o.png" width="202"></p> 
<ul><li>game.h:我们可以在game.h文件中包含我们所有需要用到的头文件，常量的定义和函数的声明，其他文件只需要声明game.h 即可。</li><li>game.c:写入游戏所需要的功能函数。</li><li>test.c:代码的整合</li></ul> 
<h3>1、主函数的实现</h3> 
<blockquote> 
 <p>在主函数中我们先创建一个input值，用于输入我们的选择，根据 do while 循环判断我们是否进行游戏，并且每次循环都打印菜单，在接着使用switch语句根据玩家输入进行判断，如果输入为1就开始游戏执行game(),如果为0，游戏结束并跳出循环，如果输入错误就继续进行循环直到主动退出。</p> 
</blockquote> 
<pre><code class="language-cs">int main()
{
	int input = 0;
	srand((unsigned int)time(NULL));
	do {
		menu();
		printf("请输入选项：");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			printf("开始游戏\n");
			game();
			break;
		case 0:
			printf("游戏结束\n");
			break;
		default:
			printf("选择错误，请重新选择：\n");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<h3> 2、菜单的实现</h3> 
<p><strong>不需要返回所以用void</strong></p> 
<pre><code class="language-cs">void menu()
{
	printf("****************\n");
	printf("**** 1.play ****\n");
	printf("**** 0.exit ****\n");
	printf("****************\n");
}
</code></pre> 
<h3> 3、游戏函数的实现</h3> 
<h4>1、棋盘的设计</h4> 
<blockquote> 
 <p>在排雷的过程中如果我们选择的位置不是雷就会看它周围的8个坐标中是否有雷，如果有雷就会显示雷的个数。</p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/8f/36/eYls7Wqh_o.png" width="271"></p> 
 <p>但如果我们选择的是边界位置，就会超出棋盘的范围，导致越界。</p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/ea/9b/VxxJur7n_o.png" width="252"></p> 
 <p>所以我们要将棋盘扩大一圈，这样就不存在越界问题了。</p> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/3a/4a/Myl5Uvnq_o.png" width="276"></p> 
 <p></p> 
 <p>假设我们现在已经布置好了雷(雷用1表示，不是雷用0表示)，当我们输入一个坐标的时候，如果这个坐标周围有一个雷，那么我们需要将这个雷的数量信息记录并存储下来，同时打印给玩家，但是我们存放雷的数组里面已经有数据了，如果再存放在里面就会可能产生混淆从而导致棋盘混乱打印困难，所以我们可以设置两个棋盘，一个是雷的棋盘mine，一个是用于放置雷的信息的棋盘show，我们后面会把雷布置到到mine数组里面，再mine数组排查雷之后，将雷的信息存放到show数组里面，然后打印show数组的信息给用户参考排查，这样就不会存在数据混淆了。</p> 
 <p><img alt="" height="110" src="https://images2.imgbox.com/93/70/rMhYcggi_o.png" width="781"></p> 
 <p>同时我们也要在game.h文件里进行常量的定义。</p> 
 <p><img alt="" height="160" src="https://images2.imgbox.com/31/36/KFr3pm1S_o.png" width="356"></p> 
</blockquote> 
<h4>2、棋盘的初始化</h4> 
<p>在设计好棋盘后，我们就应该对棋盘进行初始化，首先，我们将mine棋盘全初始化为'0'，show棋盘全初始化为'*'.</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/db/25/KvOrbOIY_o.png" width="445"></p> 
<p><img alt="" height="83" src="https://images2.imgbox.com/41/0f/xFX9xtWX_o.png" width="967"></p> 
<pre><code class="language-cs">//棋盘的初始化
void InitBoard(char board[ROWS][COLS], int row, int col, char set)
{
	for (int i = 1; i &lt; row; i++)
	{
		for (int j = 1; j &lt; col; j++)
		{
			board[i][j] = set;
		}
	}
}</code></pre> 
<p>因为要初始化两个数组，所以我们需要创建一个char set,用于接收'0' 和 '*' 。</p> 
<h4>3、打印棋盘</h4> 
<p>因为是扫雷游戏，所以我们只需要打印一个隐藏信息的棋盘即可</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/99/95/mnBn4NKv_o.png" width="475"></p> 
<p><img alt="" height="46" src="https://images2.imgbox.com/e1/23/7eaumqPq_o.png" width="864"></p> 
<p>我们只需要将show数组，行和列传给函数，并且为了显示行和列数，我们可以先利用for循环打印0-col的一行数，再进入棋盘的打印 ，在行的循环中打印一列数</p> 
<pre><code class="language-cs">//棋盘的打印
void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	printf("-----------扫雷-------------\n");
	for (i = 0; i &lt;= col; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("-----------扫雷-------------\n");
}</code></pre> 
<p> <img alt="" height="300" src="https://images2.imgbox.com/6a/0a/PFFD7oXs_o.png" width="379"></p> 
<h4>4、雷的布置</h4> 
<p> 我们需要在mine数组里布置雷，那我们该如何布置呢？</p> 
<p>1.这就需要用到我们的rand()函数了。</p> 
<blockquote> 
 <p>rand()函数是随机数生成函数，需要使用stdlib,h文件，但生成的数不是完全的随机数，而是伪随机数，我们需要改变他的种子，才能真正的生成随机数；</p> 
</blockquote> 
<p> 2.这就需要用到我们的srand()函数了</p> 
<blockquote> 
 <p>它一般用于初始化随机数生成器，通常是为rand函数设置种子，以便生成不同的随机数序列。所以我们在每次调用rand函数之前应先调用srand函数，以传入不同的种子。而srand函数通过参数seed来设置它的随机生成数，也就是说我们需要种子的种子不是一个固定值，只有这样，rand函数生成的数才是真正的随机数。</p> 
</blockquote> 
<p> 3、这就用到了time()函数了</p> 
<blockquote> 
 <p>因为时间一直在变化，所以我们可以用时间来当作srand函数的种子，它需要包含time.h的头文件。</p> 
</blockquote> 
<p>所以我们在主函数里设计了srand函数</p> 
<p><img alt="" height="56" src="https://images2.imgbox.com/d1/f7/7B2lRFHy_o.png" width="474"></p> 
<p>但随机数的范围是没法确定的，所以我们需要固定一个范围</p> 
<p><img alt="" height="64" src="https://images2.imgbox.com/2c/1b/OtWOuuqX_o.png" width="341"></p> 
<p>用x表示行用y表示列，如果棋盘长度为9，rand()%9就是0-8，＋1就是0-9，同理列也是这样</p> 
<p>之后我们设置雷的数量, 设为count=EASY_COUNT，在game.h上也定义常量EASY_COUNT 10；</p> 
<p>在利用while循环条件设置为count，布置一个雷count--；在循环中，利用if语句将随机生成的下标位置如果不等与'1',就设置为'1'</p> 
<pre><code class="language-cs">//布置雷
void SetMine(char board[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;
	while (count)
	{
		//生成随机下标
		//x:1-9
		//y:1-9
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (board[x][y] != '1');
		{
			board[x][y] = '1';
			count--;
		}
	}
}</code></pre> 
<h4>5、雷的排查</h4> 
<p>排查雷需要利用循环，那么判断循环结束的条件是什么呢？ </p> 
<blockquote> 
 <p>把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束</p> 
 <p>如果位置是雷，就炸死游戏结束</p> 
</blockquote> 
<p>所以条件就是找到不是雷的所有坐标既</p> 
<blockquote> 
 <p>设置win为不是雷的坐标数</p> 
 <p>row*col:全部坐标数</p> 
 <p>EASY_COUNT：雷数</p> 
 <p>win&lt;row*col-EASY_COUNT </p> 
</blockquote> 
<p>我们需要规定输入坐标的范围，如果判断的坐标值为'1',游戏结束，并打印所有雷；如果不是，win++，并返回周围雷数，由于返回的值应该是字符 ，所以要让返回值+'0'；并打印所有雷。</p> 
<p>如果排查雷数等于win=row*col-EASY_COUNT 就是排查成功，并打印所有雷。</p> 
<pre><code class="language-cs">//排查雷
void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win &lt; row * col - EASY_COUNT)
	{
		printf("请输入你想要排查的坐标：");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (mine[x][y] == '1')
			{
				printf("很遗憾，此处是雷，被炸死\n");
				DisplayBoard(mine, ROW, COL);
				break;
			}
			else
			{
				win++;
				printf("还要排查%d个位置\n", row * col - EASY_COUNT - win);
				int c = GetMineCount(mine, x, y);
				show[x][y] = c + '0';
				DisplayBoard(show, ROW, COL);
			}
		}
		else
		{
			printf("输入坐标有误，请重新输入\n");
		}

	}
	if (win == row * col - EASY_COUNT)
	{
		printf("恭喜你，排雷成功\n");
		DisplayBoard(mine, ROW, COL);
	}
	
}

</code></pre> 
<h4>6、返回周围雷数</h4> 
<pre><code class="language-cs">//返回周围雷数
int GetMineCount(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1] + mine[x][y - 1] + mine[x][y + 1] 
		+ mine[x + 1][y - 1] + mine[x + 1][y] + mine[x + 1][y + 1]-8*'0';
}</code></pre> 
<p><img alt="" height="300" src="https://images2.imgbox.com/70/a7/upk4YFmD_o.png" width="290"></p> 
<p>因为雷的字符为1，非雷为0；所以将周围坐标相加就是雷数，再减去8*'0',就是雷的个数.</p> 
<h2>三、完整代码</h2> 
<p>game.h</p> 
<pre><code class="language-cs">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

#define EASY_COUNT 10

#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

void InitBoard(char board[ROWS][COLS],int row, int col, int set);

void DisplayBoard(char board[ROWS][COLS], int row, int col);

void SetMine(char board[ROWS][COLS], int row, int col);

void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);
</code></pre> 
<p>test.c</p> 
<pre><code class="language-cs">#include"game.h"

void menu()
{
	printf("****************\n");
	printf("**** 1.play ****\n");
	printf("**** 0.exit ****\n");
	printf("****************\n");
}

void game()
{
	//建立数组
	char mine[ROWS][COLS] = { 0 };//用来存放布置好的雷的信息
	char show[ROWS][COLS] = { 0 };//用来存放排查出的雷的信息
	//初始化
	InitBoard(mine, ROWS, COLS, '0');
	InitBoard(show, ROWS, COLS, '*');
	//打印棋盘
	//DisplayBoard(mine, ROW, COL);
	DisplayBoard(show, ROW, COL);
	//布置雷
	SetMine(mine, ROW, COL);
	//排查雷
	FindMine(mine,show, ROW, COL);

}

int main()
{
	int input = 0;
	srand((unsigned int)time(NULL));
	do {
		menu();
		printf("请输入选项：");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			printf("开始游戏\n");
			game();
			break;
		case 0:
			printf("游戏结束\n");
			break;
		default:
			printf("选择错误，请重新选择：\n");
			break;
		}
	} while (input);
	return 0;
}
	</code></pre> 
<p>game.c</p> 
<pre><code class="language-cs">#include"game.h"

//棋盘的初始化
void InitBoard(char board[ROWS][COLS], int row, int col, char set)
{
	for (int i = 1; i &lt; row; i++)
	{
		for (int j = 1; j &lt; col; j++)
		{
			board[i][j] = set;
		}
	}
}

//棋盘的打印
void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	printf("-----------扫雷-------------\n");
	for (i = 0; i &lt;= col; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("-----------扫雷-------------\n");
}

//布置雷
void SetMine(char board[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;
	while (count)
	{
		//生成随机下标
		//x:1-9
		//y:1-9
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (board[x][y] != '1');
		{
			board[x][y] = '1';
			count--;
		}
	}
}

//返回周围雷数
int GetMineCount(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y - 1] + mine[x - 1][y] + mine[x - 1][y + 1] + mine[x][y - 1] + mine[x][y + 1] 
		+ mine[x + 1][y - 1] + mine[x + 1][y] + mine[x + 1][y + 1]-8*'0';
}

//排查雷
void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win &lt; row * col - EASY_COUNT)
	{
		printf("请输入你想要排查的坐标：");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			if (mine[x][y] == '1')
			{
				printf("很遗憾，此处是雷，被炸死\n");
				DisplayBoard(mine, ROW, COL);
				break;
			}
			else
			{
				win++;
				printf("还要排查%d个位置\n", row * col - EASY_COUNT - win);
				int c = GetMineCount(mine, x, y);
				show[x][y] = c + '0';
				DisplayBoard(show, ROW, COL);
			}
		}
		else
		{
			printf("输入坐标有误，请重新输入\n");
		}

	}
	if (win == row * col - EASY_COUNT)
	{
		printf("恭喜你，排雷成功\n");
		DisplayBoard(mine, ROW, COL);
	}
	
}

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6fc778b395b22e5a2473088bdf73b1d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Llama 3.1：Meta迄今为止规模最大、质量最高的开源模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4a2632ad0dc1b1afc72e54b22244e62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WD1.4标签器：Stable Diffusion的提示词反推神器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>