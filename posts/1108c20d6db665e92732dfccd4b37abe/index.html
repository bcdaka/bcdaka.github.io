<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1108c20d6db665e92732dfccd4b37abe/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下)">
  <meta property="og:description" content="【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下) 大家好 我是寸铁👊
【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下)✨
喜欢的小伙伴可以点点关注 💝
前言 本次文章分为上下两部分，上部分为对理论的介绍，下部分为具体的底层代码深度剖析和编程实践，感兴趣的伙伴不要错过哦~
在现代软件工程中，架构设计的精妙编织是构建稳健和高效系统的关键。组合模式作为一种经典的设计模式，通过将对象组合成树形结构以表示“部分-整体”的层次结构，已被广泛应用于各种领域的软件开发中。特别是在Gin框架这样的轻量级、高性能Web框架中，组合模式展现了其在管理复杂性和促进代码复用方面的卓越价值。本文将深入探讨组合模式在Gin框架中的革新实践和技术深度，帮助开发者全面理解如何利用组合模式优化和增强其应用程序的架构设计。
组合模式通过递归结构和多态性质，使得单个对象和组合对象在使用上具有一致性，从而使得整个系统的设计更加灵活和可扩展。在Gin框架中，组合模式可以被应用于路由结构、中间件组合以及请求处理管道的设计中，使得开发者能够更加自如地处理复杂的业务逻辑和请求处理流程。本文旨在为开发者提供深入的技术见解和实用的应用指南，帮助他们有效地运用组合模式，打造出更加稳健和可维护的Gin框架应用程序。
关键的类图和时序图 (1) 类图
Component：是组合中所有对象的基类，定义了组合中对象和组合对象的共有操作。拥有一个操作方法 operation()，可以在具体的Leaf或Composite中被实现。
Path（叶节点）：表示组合中的叶子节点对象，它没有子节点。继承自Component类，实现了operation()方法，表示基本的操作。
PathComposite（复合对象）：表示组合中的复合对象，可以包含其他Path或Composite对象。继承自Component类，包含了管理子组件的方法，如add(), remove(), getChild()等，同时也实现了operation()方法以处理组合对象的操作。
图58 组合模式的类图
由上图58可得:
在Gin框架中，组合模式主要体现在访问路由上，叶子节点为Path路径，组合对象为PathComposite。
先定义Component类，即组合中所有对象的基类，定义了组合中对象和组合对象的共有操作。拥有一个操作方法 operation()，可以在具体的Path或Composite中被实现。
再编写Path（叶节点），即表示组合中的叶子节点对象，它没有子节点。继承自Component类，实现了operation()方法，表示基本的操作。
然后编写PathComposite（复合对象）即表示组合中的复合对象，可以包含其他Path或Composite对象。继承自Component类，包含了真正实现管理子组件的方法，如add(), remove(), getChild()等，同时也实现了operation()方法以处理组合对象的操作。
(2) 时序图
图59 组合模式时序图
由上图59可得：
组合模式时序图说明：
客户端先创建具体的Composite组合对象，继承自Component类。
再创建叶子对象Path，继承自Component类。
接着调用Composite的join方法将叶子对象Path进行拼接得到可访问的路由对象router。
再逐步将拼接好的路由对象router返回给客户端Client进行调用和其他操作operation()。
主程序的流程 图60 组合模式主程序流程图
由上图60可得：程序一开始，客户端先创建路由组合对象Composite ，接着创建叶子对象Path ，然后调用组合对象Composite的join方法将Path进行拼接，再逐步返回拼接好后的路由对象给客户端，客户端获得路由对象后，进行业务处理，业务处理完毕后，程序结束。
程序模块之间的调用关系 图61 组合模式程序调用图
由上图61可得：
Gin 框架的组合模式，涉及的角色如下：
路由引擎 (Router Engine)：
router := gin.Default() 创建了 Gin 框架的路由引擎实例。该引擎负责注册路由、处理 HTTP 请求，并根据请求的路径和方法分发到相应的处理函数。
(1) 路由组 (Router Group)：
api := router.Group(“/api”) 和 admin := router.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T16:58:34+08:00">
    <meta property="article:modified_time" content="2024-07-24T16:58:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="GinGin_3"></a>【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下)</h2> 
<blockquote> 
 <p>大家好 我是寸铁👊<br> 【Gin】架构的精妙编织：Gin框架中组合模式的革新实践与技术深度解析(下)✨<br> 喜欢的小伙伴可以点点关注 💝</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3e/e1/Qa5g5SFb_o.gif" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_14"></a>前言</h3> 
<p><em><strong>本次文章分为上下两部分，上部分为对理论的介绍，下部分为具体的底层代码深度剖析和编程实践，感兴趣的伙伴不要错过哦~</strong></em></p> 
<blockquote> 
 <p>在现代软件工程中，架构设计的精妙编织是构建稳健和高效系统的关键。组合模式作为一种经典的设计模式，通过将对象组合成树形结构以表示“部分-整体”的层次结构，已被广泛应用于各种领域的软件开发中。特别是在Gin框架这样的轻量级、高性能Web框架中，组合模式展现了其在管理复杂性和促进代码复用方面的卓越价值。本文将深入探讨组合模式在Gin框架中的革新实践和技术深度，帮助开发者全面理解如何利用组合模式优化和增强其应用程序的架构设计。<br> 组合模式通过递归结构和多态性质，使得单个对象和组合对象在使用上具有一致性，从而使得整个系统的设计更加灵活和可扩展。在Gin框架中，组合模式可以被应用于路由结构、中间件组合以及请求处理管道的设计中，使得开发者能够更加自如地处理复杂的业务逻辑和请求处理流程。本文旨在为开发者提供深入的技术见解和实用的应用指南，帮助他们有效地运用组合模式，打造出更加稳健和可维护的Gin框架应用程序。</p> 
</blockquote> 
<hr> 
<h3><a id="_22"></a>关键的类图和时序图</h3> 
<p>(1) 类图<br> <code>Component</code>：是组合中所有对象的基类，定义了组合中对象和组合对象的共有操作。拥有一个操作方法<code> operation()</code>，可以在具体的<code>Leaf</code>或<code>Composite</code>中被实现。<br> <code>Path</code>（叶节点）：表示组合中的叶子节点对象，它没有子节点。继承自<code>Component</code>类，实现了<code>operation()</code>方法，表示基本的操作。<br> <code>PathComposite</code>（复合对象）：表示组合中的复合对象，可以包含其他<code>Path</code>或<code>Composite</code>对象。继承自Component类，包含了管理子组件的方法，如<code>add()</code>,<code> remove()</code>, <code>getChild()</code>等，同时也实现了<code>operation()</code>方法以处理组合对象的操作。<br> <img src="https://images2.imgbox.com/e2/9e/Z89om0Sc_o.png" alt="在这里插入图片描述"></p> 
<p>图58 组合模式的类图</p> 
<p>由上图58可得:<br> 在Gin框架中，组合模式主要体现在访问路由上，叶子节点为<code>Path</code>路径，组合对象为<code>PathComposite</code>。<br> 先定义<code>Component</code>类，即组合中所有对象的基类，定义了组合中对象和组合对象的共有操作。拥有一个操作方法 <code>operation()</code>，可以在具体的<code>Path</code>或<code>Composite</code>中被实现。<br> 再编写<code>Path</code>（叶节点），即表示组合中的叶子节点对象，它没有子节点。继承自<code>Component</code>类，实现了<code>operation()</code>方法，表示基本的操作。<br> 然后编写<code>PathComposite</code>（复合对象）即表示组合中的复合对象，可以包含其他<code>Path</code>或<code>Composite</code>对象。继承自<code>Component</code>类，包含了真正实现管理子组件的方法，如<code>add(), remove(), getChild()</code>等，同时也实现了<code>operation()</code>方法以处理组合对象的操作。</p> 
<hr> 
<p>(2) 时序图</p> 
<p><img src="https://images2.imgbox.com/65/65/2ZHga316_o.png" alt="在这里插入图片描述"></p> 
<p>图59 组合模式时序图<br> 由上图59可得：<br> 组合模式时序图说明：<br> 客户端先创建具体的<code>Composite</code>组合对象，继承自<code>Component</code>类。<br> 再创建叶子对象<code>Path</code>，继承自<code>Component</code>类。<br> 接着调用<code>Composite</code>的<code>join</code>方法将叶子对象<code>Path</code>进行拼接得到可访问的路由对象<code>router</code>。<br> 再逐步将拼接好的路由对象router返回给客户端<code>Client</code>进行调用和其他操作<code>operation()</code>。</p> 
<hr> 
<h3><a id="_54"></a>主程序的流程</h3> 
<p><img src="https://images2.imgbox.com/6f/c4/NBjWfbzi_o.png" alt="在这里插入图片描述"></p> 
<p>图60 组合模式主程序流程图</p> 
<blockquote> 
 <p>由上图60可得：程序一开始，客户端先创建路由组合对象<code>Composite</code> ，接着创建叶子对象<code>Path </code>，然后调用组合对象<code>Composite</code>的<code>join</code>方法将Path进行拼接，再逐步返回拼接好后的路由对象给客户端，客户端获得路由对象后，进行业务处理，业务处理完毕后，程序结束。</p> 
</blockquote> 
<hr> 
<h3><a id="_63"></a>程序模块之间的调用关系</h3> 
<p><img src="https://images2.imgbox.com/1b/92/dapAEl0c_o.png" alt="在这里插入图片描述"></p> 
<p>图61 组合模式程序调用图</p> 
<p>由上图61可得：<br> Gin 框架的组合模式，涉及的角色如下：<br> <code>路由引擎 (Router Engine)</code>：<br> <code>router := gin.Default() </code>创建了 Gin 框架的路由引擎实例。该引擎负责注册路由、处理 HTTP 请求，并根据请求的路径和方法分发到相应的处理函数。</p> 
<hr> 
<p><code>(1) 路由组 (Router Group)：</code><br> api := router.Group(“/api”) 和 admin := router.Group(“/admin”) 定义了两个路由组。路由组是将相关联的路由进行组织和管理的机制。在这段代码中，/api 和 /admin 分别是两个不同的路径前缀，用于区分不同的功能模块或权限要求。</p> 
<hr> 
<p><code>(2) 路由处理函数 (Route Handlers)：</code><br> 在路由组中使用 api.GET(“/users”, …)、api.GET(“/admins”, …) 和 admin.POST(“/login”, …) 注册了三个具体的路由处理函数。这些处理函数定义了当匹配到特定 HTTP 方法和路径时应执行的操作。例如，GET /api/users 返回一个 JSON 响应，而 POST /admin/login 处理用户登录操作。</p> 
<hr> 
<p><code>(3) 中间件 (Middleware)：</code><br> 虽然在提供的代码中未显式使用中间件，但是 Gin 框架支持在路由组或全局中应用中间件。中间件可以用来处理认证、日志记录、错误处理等通用功能，以增强路由的功能性和可复用性。</p> 
<hr> 
<p><code>(4) Context 对象 (gin.Context)：</code><br> <code>c *gin.Context </code>是在每个路由处理函数中作为参数传递的上下文对象。它包含了关于 HTTP 请求的所有信息，如请求头、请求体、路径参数等，并且提供了用于设置响应的方法。<br> 可以将访问路由整理成一棵路由组合树如下图62：<br> <img src="https://images2.imgbox.com/3c/67/aX31wLAs_o.png" alt="在这里插入图片描述"></p> 
<p>图62 路由组合树</p> 
<p>下面是对上图61各层次调用关系的描述：</p> 
<blockquote> 
 <p>客户端调用<code>router.Group</code>定义路由组，要访问的路由类型为String类型，用于拼接路由的路径。进一步在<code>router.Group</code>方法中的<code>RouterGroup</code>结构体中调用<code>basePath</code>: group.calculateAbsolutePath(relativePath)计算绝对路径方法，在基础路径的基础上对相对路径进行拼接。group.calculateAbsolutePath方法中再调用<code>joinPaths(group.basePath, relativePath)</code>方法将相对路径进行拼接返回拼接好的路由组基础路由，在将组装好的路由组对象<code>router.Group</code>返回给客户端的<code>api</code>对象。<br> <code>api</code>对象拿到<code>router.Group</code>对象后，调用GET方法，设置要访问的路由组的子路由路径，实现在路由组的基础上，添加子路由路径到路由组形成部分-整体的树形结构，GET方法将要拼接的路径转发给里面的<code>group.handle(http.MethodGet, relativePath, handlers)</code>方法，再调用<code>group.calculateAbsolutePath(relativePath)</code>方法计算每个子路由访问的绝对路径，方法内部调用<code>joinPaths(group.basePath, relativePath)</code>计算出最后的绝对路径。最后将要访问的子路由对象返回给客户端。</p> 
</blockquote> 
<hr> 
<p>在上图的基础上，下面对各个模块的代码进行深入剖析：<br> <img src="https://images2.imgbox.com/2a/9d/AJ9stT3P_o.png" alt="在这里插入图片描述"></p> 
<p>图63 组合模式Group方法声明<br> 代码位置：routergroup.go的72-78行</p> 
<blockquote> 
 <p>72行：<code>Group()</code> 方法是<code> RouterGroup</code> 结构体的一个方法。它接受一个相对路径<code>relativePath</code>和一个或多个<code>HandlerFunc</code>类型的中间件函数作为参数，并返回一个指向 <code>RouterGroup </code>结构体的指针。在方法内部，创建了一个新的 <code>RouterGroup </code>对象，并用一个结构体字面量初始化该对象。<br> 75行：<code>basePath</code>: 使用<code>group.calculateAbsolutePath(relativePath)</code>方法计算相对路径 <code>relativePath</code> 的绝对路径，赋值给<code> basePath</code>。这是为了构建新路由组的完整路径。</p> 
</blockquote> 
<hr> 
<p><code>calculateAbsolutePath</code>方法的代码如下，将构建路径的请求转发给<code>joinPaths</code>方法：<br> <img src="https://images2.imgbox.com/e3/46/YP4UFWG1_o.png" alt="在这里插入图片描述"></p> 
<p>图64 组合模式计算绝对路径方法代码</p> 
<p>代码位置：routergroup.go的250-252行</p> 
<blockquote> 
 <p><code>calculateAbsolutePath()</code> 方法是<code>RouterGroup</code>结构体的一个方法。它接受一个 <code>relativePath</code> 参数，该参数表示相对路径，返回一个字符串类型的绝对路径。在方法内部，调用了<code>joinPaths()</code>函数，将 <code>group.basePath</code> 和<code>relativePath</code>作为参数传递给它，并返回其计算结果。</p> 
</blockquote> 
<hr> 
<p><code>joinPaths</code>的代码如下：<br> <img src="https://images2.imgbox.com/52/ec/r5JoJQpx_o.png" alt="在这里插入图片描述"></p> 
<p>图65 组合模式的joinPaths方法代码<br> 代码位置：routergroup.go的128-137行</p> 
<blockquote> 
 <p><code>joinPaths()</code> 是一个函数，接受两个字符串类型的参数<code>absolutePath</code>和 <code>relativePath</code>，分别表示绝对路径和相对路径。如果<code>relativePath</code>是空字符串，直接返回<code> absolutePath</code>。这种情况下，无需进行路径连接，直接返回当前的绝对路径。使用标准库中的<code>path.Join()</code>函数将 <code>absolutePath </code>和 <code>relativePath</code> 进行路径连接，生成最终的路径 <code>finalPath</code>。 检查<code>relativePath</code>的最后一个字符是否为<code> '/'</code>，并且 <code>finalPath </code>的最后一个字符不是 ‘/’。如果满足这个条件，将<code>finalPath</code>的末尾添加 ‘/’，以确保路径的一致性和正确性。返回经过处理后的最终路径 <code>finalPath</code>。<br> 在得到路由组对象的基础路径后，下面要对子路由的路径进行组合，先调用GET方法对要组合的路径进行转发，转发到<code>group.handle()</code>方法进行处理：<br> 代码位置：routergroup.go的116-118行<br> <img src="https://images2.imgbox.com/75/59/xnazKc1q_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>图66 GET方法代码</p> 
<blockquote> 
 <p><code>GET() </code>方法是<code>RouterGroup</code>结构体的一个方法。它接受一个 <code>relativePath </code>参数作为路径，以及一个或多个 <code>HandlerFunc </code>类型的处理函数作为中间件，返回一个实现了<code>IRoutes</code>接口的对象。调用 <code>group.handle() </code>方法，将 HTTP 方法、路径和中间件函数传递给该方法处理，进而配置 GET 请求的路由和处理流程。<br> 转发到<code>handle</code>方法中，调用<code>group.calculateAbsolutePath (relativePath)</code>方法对路径进行拼接。<br> <img src="https://images2.imgbox.com/1e/c6/IaEZi3CM_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>图67 组合模式的handle方法代码<br> 代码位置：routergroup.go的86-87行</p> 
<hr> 
<p><img src="https://images2.imgbox.com/4b/aa/nyyStN5x_o.png" alt="在这里插入图片描述"></p> 
<p>图68 组合模式计算路由代码<br> 代码位置：routergroup.go的250-252行</p> 
<blockquote> 
 <p><code>calculateAbsolutePath() </code>方法是<code>RouterGroup</code>结构体的一个方法。它接受一个<code>relativePath</code>参数，该参数表示相对路径，返回一个字符串类型的绝对路径。在方法内部，调用了<code>joinPaths()</code>函数，将 <code>group.basePath </code>和<code> relativePath</code> 作为参数传递给它，并返回最后拼接的子路由路径。</p> 
</blockquote> 
<hr> 
<h3><a id="_146"></a>组合模式案例及调试分析</h3> 
<p>组合模式主要用于处理树形结构的问题，其中包含两种基本对象类型：叶子对象和组合对象。在编写组合模式案例中，我们可以将路由组和路由视作组合模式中的组合对象和叶子对象。<br> <img src="https://images2.imgbox.com/d5/58/bwCRmfPg_o.png" alt="在这里插入图片描述"></p> 
<p>图113 定义路由组代码</p> 
<blockquote> 
 <p><code>组合对象 (RouteGroup):</code><br> 定义:<code>RouteGroup</code>类型表示路由的组合对象，它可以包含自己的访问路径<code>Path</code>、子路由 (<code>Route </code>对象) 和子路由组 (<code>RouteGroup 对象</code>)。<br> 角色: 在组合模式中，<code>RouteGroup </code>充当组合对象角色。<br> 职责:<br> 维护子对象列表 (<code>Routes 和 SubGroups</code>)。<br> 提供方法 (<code>AddRoute 和 AddSubGroup</code>)，用于添加子对象。<br> 可以被递归地操作，因为它可以包含其他<code>RouteGroup</code>对象作为子组。</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/bf/ad/iHsPVslN_o.png" alt="在这里插入图片描述"></p> 
<p>图114 定义单个路由Route代码</p> 
<blockquote> 
 <p><code>叶子对象 (Route):</code><br> 定义: <code>Route</code> 类型表示单个的路由对象，包含了请求路径<code>Path</code>、<code>HTTP </code>方法Method和处理函数Handler。<br> 角色: 在组合模式中，<code>Route </code>充当叶子对象角色。<br> 职责:<br> 表示组合对象的最小单位，不能包含其他对象。包含具体的路由信息和对应的处理逻辑。<br> <code>AddRoute</code>方法向路由组中添加子路由</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4e/3f/I6rrIM6c_o.png" alt="在这里插入图片描述"></p> 
<p>图115 AddRoute代码</p> 
<blockquote> 
 <p><code>AddRoute </code>是一个方法，它绑定到<code> RouteGroup</code> 结构体上。参数包括 <code>path（路由路径）</code>、<code>method（HTTP 方法）</code>和<code> handler（处理函数）</code>。在 <code>AddRoute </code>方法内部，首先创建了一个 <code>Route </code>对象<code> route</code>。<code>route</code> 是指向 <code>Route </code>结构体的指针。<code>Path </code>被赋值为传入的 path 参数，表示路由的路径。<code>Method </code>被赋值为传入的 method 参数，表示路由的 HTTP 方法。<code>Handler</code> 被赋值为传入的 handler 参数，即处理该路由的函数。将路由route添加到 Routes 切片rg.Routes。</p> 
</blockquote> 
<p>主程序 (main 函数):<br> <img src="https://images2.imgbox.com/47/91/xu5v7JgR_o.png" alt="在这里插入图片描述"></p> 
<p>图116 main方法代码</p> 
<blockquote> 
 <p>定义: main 函数作为程序的入口点。<br> 角色: 在组合模式中不直接对应特定角色，但是通过创建和管理 <code>RouteGroup</code> 和 <code>Route </code>对象来实现组合模式中的结构。<br> 职责:<br> 创建顶级的<code> RouteGroup</code> 对象 (api)。<br> 使用<code>AddRoute</code>方法向 <code>api </code>路由组添加GET路由。<br> 使用<code> api.AddRoute</code> 方法向 api 路由组添加一个 GET 方法的路由，路径为<code>/users</code>。匿名函数作为处理函数，当请求 /api/users 时，控制台输出发送响应信息完毕，组合对象成功，组合模式测试成功！并返回 JSON 格式的数据。<br> 类似地，向 api 路由组添加另一个 POST方法的路由，路径为 <code>/admins</code>。<br> 当请求<code>/api/admins</code>时，控制台输出发送响应信息完毕，组合对象成功，组合模式测试成功！返回 JSON 格式的数据。<br> 调用<code>router.Run(":8080")</code>方法启动 Gin 路由引擎，监听本地的 8080 端口，开始接受和处理来自客户端的 HTTP 请求。<br> 使用<code>initializeRoutes</code>函数将路由组注册到 Gin 路由引擎中。</p> 
</blockquote> 
<p>initializeRoutes 函数如下：<br> <img src="https://images2.imgbox.com/61/b2/OHzNfedw_o.png" alt="在这里插入图片描述"></p> 
<p>图117 initializeRoutes函数代码</p> 
<blockquote> 
 <p><code>initializeRoutes </code>的函数，接收两个参数：<br> <code>router</code>：Gin 框架的路由引擎，用于注册路由。<br> <code>group</code>：自定义的 RouteGroup 结构体指针，包含了一组相关的路由信息。<br> 从传入的 group 结构体中获取 Path 属性，表示当前路由组的路径。<br> 使用 range 遍历 group 中的 Routes 数组，<br> 对于每个路由条目 route，根据其 Method 字段的值进行注册：<br> 如果是 <code>"GET" </code>方法，调用<code>router.GET()</code>方法注册 GET 请求处理器，路径为 <code>groupPath + route.Path</code>，处理函数为<code> route.Handler</code>。<br> 如果是 “POST” 方法，调用 router.POST() 方法注册 POST 请求处理器，路径同样为 <code>groupPath + route.Path</code>，处理函数为 <code>route.Handler。</code><br> 可以根据实际需求继续添加其他 HTTP 方法的注册，例如<code> PUT</code>、<code>DELETE </code>等。<br> 遍历当前 <code>group </code>的子路由组 <code>SubGroups</code>，对每个子路由组递归调用 <code>initializeRoutes </code>函数。<br> 这确保了所有子路由组中的路由也会被注册到 router 中，实现了路由的嵌套和层级管理。</p> 
</blockquote> 
<p>调试分析：<br> 启动测试案例的服务端,完成对象的组合，形成访问路由树，并等待客户端请求的发送。运行测试组合模式案例成功！</p> 
<p><img src="https://images2.imgbox.com/7b/a2/Rk0sQjjf_o.png" alt="在这里插入图片描述"></p> 
<p>图118 运行测试组合模式案例成功</p> 
<p>使用API测试工具APIfox，向服务器监听的端口发送<code>GET</code>请求，并得到服务端发送的响应信息，调试组合模式案例成功！如下图119：<br> <img src="https://images2.imgbox.com/68/09/XNZZL8nj_o.png" alt="在这里插入图片描述"></p> 
<p>图119 Apifox测试GET请求</p> 
<p>使用API测试工具APIfox，向服务器监听的端口发送<code>POST</code>请求，并得到服务端发送的响应信息，调试组合模式案例成功！如下图120：<br> <img src="https://images2.imgbox.com/2c/4a/M7ZqVeEi_o.png" alt="在这里插入图片描述"></p> 
<p>图120 Apifox测试POST请求</p> 
<hr> 
<h3><a id="_230"></a>组合模式测试结果</h3> 
<p>使用API测试工具APIfox，向服务器监听的端口发送GET请求，并得到服务端发送的响应信息，说明可以正常的访问路由，路由组合成功！测试组合模式案例成功！</p> 
<p><img src="https://images2.imgbox.com/fd/3b/4GVHixPj_o.png" alt="在这里插入图片描述"></p> 
<p>图142 Apifox发起GET请求</p> 
<p>使用API测试工具APIfox，向服务器监听的端口发送POST请求，并得到服务端发送的响应信息，说明可以正常的访问路由，路由组合成功！测试组合模式案例成功！</p> 
<p><img src="https://images2.imgbox.com/c9/d6/MzdBvMtb_o.png" alt="---"></p> 
<p>图143 Apifox发起POST请求</p> 
<p>再观察服务端的监控信息，预估是否与测试案例编写的一致。<br> 服务端在监听客户端发送完请求后，应该在控制台中输出如下的语句：发送响应信息完毕，组合对象成功，组合模式测试成功！</p> 
<p><img src="https://images2.imgbox.com/d2/e1/ku3DID3Y_o.png" alt="在这里插入图片描述"></p> 
<p>图144 路由对象添加路由<br> 发现控制台输出的信息确实是：发送响应信息完毕，组合对象成功，组合模式案例测试成功！<br> 这表明路由对象组合成功，可以正常地访问组合的路由，组合模式测试成功！<br> <img src="https://images2.imgbox.com/80/7b/V62sVhHz_o.png" alt="在这里插入图片描述"></p> 
<p>图145 服务端后台监控信息测试成功</p> 
<hr> 
<h3><a id="_259"></a>结语</h3> 
<blockquote> 
 <p>通过本文的深入探讨，我们详细分析了组合模式在Gin框架中的应用场景和实际案例。组合模式不仅能够优雅地解决复杂系统中的结构化问题，还能够提升系统的灵活性和可扩展性，使开发者能够更加高效地应对不断变化的业务需求和技术挑战。在实际项目中，合理运用组合模式能够有效地简化系统的设计与维护，降低代码的复杂度，从而为Gin框架应用的长期发展提供坚实的技术基础。希望本文能够为广大开发者提供有益的参考和实用的指导，帮助他们在实际应用中充分发挥组合模式的优势，构建出更加强大和灵活的软件系统。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>看到这里的小伙伴，恭喜你又掌握了一个技能👊<br> 希望大家能取得胜利，坚持就是胜利💪<br> 我是寸铁！我们下期再见💕</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/e3/cc/UNbkaIz9_o.gif" alt="在这里插入图片描述"></p> 
<h3><a id="two_hearts_269"></a>往期好文💕</h3> 
<h4><a id="_271"></a>保姆级教程</h4> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135901228?spm=1001.2014.3001.5501">【保姆级教程】Windows11下go-zero的etcd安装与初步使用</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135888765?spm=1001.2014.3001.5502">【保姆级教程】Windows11安装go-zero代码生成工具goctl、protoc、go-zero</a></strong></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135922507?spm=1001.2014.3001.5501"><strong>【Go-Zero】手把手带你在goland中创建api文件并设置高亮</strong></a></p> 
<hr> 
<h4><a id="_281"></a>报错解决</h4> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136037952?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error: user.api 27:9 syntax error: expected ‘:‘ | ‘IDENT‘ | ‘INT‘, got ‘(‘ 报错解决方案及api路由注意事项</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136029821?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error: only one service expected goctl一键转换生成rpc服务错误解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136021340?spm=1001.2014.3001.5501"><strong>【Go-Zero】【error】 failed to initialize database, got error Error 1045 (28000):报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136014038?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES)报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136005713?spm=1001.2014.3001.5501"><strong>【Go-Zero】type mismatch for field “Auth.AccessSecret“, expect “string“, actual “number“报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/136002880?spm=1001.2014.3001.5501"><strong>【Go-Zero】Error: user.api 30:2 syntax error: expected ‘)‘ | ‘KEY‘, got ‘IDENT‘报错解决方案</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135921378?spm=1001.2014.3001.5501"><strong>【Go-Zero】Windows启动rpc服务报错panic:context deadline exceeded解决方案</strong></a></p> 
<hr> 
<h4><a id="Go_306"></a>Go面试向</h4> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135777735?spm=1001.2014.3001.5502">【Go面试向】defer与time.sleep初探</a></strong></p> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135686421?spm=1001.2014.3001.5502">【Go面试向】defer与return的执行顺序初探</a></strong></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135723403?spm=1001.2014.3001.5502"><strong>【Go面试向】Go程序的执行顺序</strong></a></p> 
<p><a href="https://blog.csdn.net/joeyoj/article/details/135723403?spm=1001.2014.3001.5502"><strong>【Go面试向】rune和byte类型的认识与使用</strong></a></p> 
<p><strong><a href="https://blog.csdn.net/joeyoj/article/details/135722887?spm=1001.2014.3001.5502">【Go面试向】实现map稳定的有序遍历的方式</a></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79bb748ff650d3960ded8fef51a5f8b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">通过使用Excel VBA来进行Outlook自动邮件发送</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e85093612d6ced635e438b8734e1bd54/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">3 Go语言的变量声明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>