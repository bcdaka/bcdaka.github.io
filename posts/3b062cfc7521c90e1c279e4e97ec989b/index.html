<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[动态规划]---part1 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3b062cfc7521c90e1c279e4e97ec989b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[动态规划]---part1">
  <meta property="og:description" content="前言
作者：小蜗牛向前冲
专栏：小蜗牛算法之路
专栏介绍：&#34;蜗牛之道，攀登大厂高峰，让我们携手学习算法。在这个专栏中，将涵盖动态规划、贪心算法、回溯等高阶技巧，不定期为你奉上基础数据结构的精彩算法之旅。一同努力，追逐技术的星辰大海。&#34;
目录
一、什么是动态规划
1、什么是动态规划
2、动态规划的学习
二、动态规划刷题
1、第 N 个泰波那契数
a、解题思路：
b、代码 2、 面试题 08.01. 三步问题
a、解题思路：
b、代码
3 、746. 使用最小花费爬楼梯
a、解题思路 b、代码
4、解码方法
a、解题思路 b、代码
c、代码优化 5、不同路径（medium）
a、解题思路 b、代码
本期我们将探讨动态规划，并提供5道经典动态规划问题，难度由浅入深。
一、什么是动态规划 1、什么是动态规划 在学习算法的过程中，我们往往会遇到一些算法题是要用动态规划来解决。
但是做为小白的我们哪里知道动态规划是什么？
从概念上说
动态规划（Dynamic Programming）是一种解决复杂问题的算法设计技术。它通常用于解决具有重叠子问题和最优子结构性质的问题，通过将问题分解为更小的子问题，并利用子问题的解来构建原始问题的解。
看完概念我们知道什么是动态规划，求重叠类子问题的 一般会用到动态规划的思路。
那我们如何求学习动态规划
2、动态规划的学习 对于算法类题目，在我们掌握算法的基本原理后，就是进行大量刷题，进经验的总结。
求解动态规划的五步骤：
1、状态表示
在求解过程中，我们往往要创建dp表(其实就是数组），状态表示就是我们要找出dp表中值的含义是什么。
状态表 怎么来？
根据题目要求经验&#43;题目要求分析题目的过程中，发现重复子问题 2、状态转移方程
简单说是和dp[i]有关的一个方程
3、初始化
保证在填写dp表的时候不越界
4、填写顺序 根据前面的计算得来，可以从前往后，也可以从后往前。
5、返回值
根据题目要求&#43;状态表示
讲完了解题步骤，下面就进行刷题训练。
特别提醒：后面博客会带领大家由易到难进行刷题，每期都为五题。
二、动态规划刷题 1、第 N 个泰波那契数 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn&#43;3 = Tn &#43; Tn&#43;1 &#43; Tn&#43;2">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-07T20:53:33+08:00">
    <meta property="article:modified_time" content="2024-06-07T20:53:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[动态规划]---part1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>前言</strong></p> 
 <p><img alt="" height="28" src="https://images2.imgbox.com/f5/42/EzQVwzlW_o.png" width="28"><strong><span style="color:#956fe7;">作者</span>：小蜗牛向前冲</strong></p> 
 <p><img alt="" height="28" src="https://images2.imgbox.com/2b/cc/L6eokMJV_o.png" width="28"><strong><span style="color:#956fe7;">专栏</span>：</strong><strong>小蜗牛算法之路</strong></p> 
 <p> <img alt="" height="28" src="https://images2.imgbox.com/9a/56/O1Pre1Z4_o.png" width="28"><strong><span style="color:#956fe7;">专栏介绍</span>：<span style="color:#38d8f0;">"蜗牛之道，攀登大厂高峰，让我们携手学习算法。在这个专栏中，将涵盖动态规划、贪心算法、回溯等高阶技巧，不定期为你奉上基础数据结构的精彩算法之旅。一同努力，追逐技术的星辰大海。"</span></strong></p> 
 <p><strong> </strong><img alt="" height="471" src="https://images2.imgbox.com/67/10/xWk28xUG_o.png" width="1114"></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" rel="nofollow"> 一、什么是动态规划</a></p> 
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" rel="nofollow">1、什么是动态规划</a></p> 
<p id="2%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%AD%A6%E4%B9%A0-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%AD%A6%E4%B9%A0" rel="nofollow">2、动态规划的学习</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98" rel="nofollow">二、动态规划刷题</a></p> 
<p id="1%E3%80%81%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0" rel="nofollow">1、第 N 个泰波那契数</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A-toc" style="margin-left:80px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow">a、解题思路：</a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:80px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">b、代码 </a></p> 
<p id="2%E3%80%81%C2%A0%20%C2%A0%E9%9D%A2%E8%AF%95%E9%A2%98%2008.01.%20%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#2%E3%80%81%C2%A0%20%C2%A0%E9%9D%A2%E8%AF%95%E9%A2%98%2008.01.%20%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98" rel="nofollow">2、   面试题 08.01. 三步问题</a></p> 
<p id="%C2%A0a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A" rel="nofollow"> a、解题思路：</a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<p id="3%20%E3%80%81746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-toc" style="margin-left:40px;"><a href="#3%20%E3%80%81746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF" rel="nofollow">3 、746. 使用最小花费爬楼梯</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:80px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<p id="%C2%A0%204%E3%80%81%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%204%E3%80%81%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95" rel="nofollow">  4、解码方法</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:80px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<p id="c%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%C2%A0-toc" style="margin-left:80px;"><a href="#c%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%C2%A0" rel="nofollow">c、代码优化 </a></p> 
<p id="%C2%A05%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88medium%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A05%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88medium%EF%BC%89" rel="nofollow"> 5、不同路径（medium）</a></p> 
<p id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0-toc" style="margin-left:80px;"><a href="#a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0" rel="nofollow">a、解题思路 </a></p> 
<p id="b%E3%80%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#b%E3%80%81%E4%BB%A3%E7%A0%81" rel="nofollow">b、代码</a></p> 
<hr id="hr-toc"> 
<p>本期我们将探讨动态规划，并提供5道经典动态规划问题，难度由浅入深。</p> 
<p></p> 
<h2 id="%C2%A0%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"> 一、什么是动态规划</h2> 
<h3 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">1、什么是动态规划</h3> 
<p>在学习算法的过程中，我们往往会遇到一些算法题是要用动态规划来解决。</p> 
<p>但是做为小白的我们哪里知道动态规划是什么？</p> 
<p><strong>从概念上说</strong></p> 
<blockquote> 
 <p>动态规划（Dynamic Programming）是一种解决复杂问题的算法设计技术。它<strong>通常用于解决具有重叠子问题和最优子结构性质的问题</strong>，<strong>通过将问题分解为更小的子问题，并利用子问题的解来构建原始问题的解。</strong></p> 
</blockquote> 
<p><img alt="" height="721" src="https://images2.imgbox.com/0a/83/FlJvudiZ_o.png" width="1012"></p> 
<p>看完概念我们知道什么是动态规划，求重叠类子问题的 一般会用到动态规划的思路。</p> 
<p>那我们如何求学习动态规划</p> 
<h3 id="2%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%AD%A6%E4%B9%A0">2、动态规划的学习</h3> 
<p>对于算法类题目，在我们掌握算法的基本原理后，就是进行大量刷题，进经验的总结。</p> 
<p><strong>求解动态规划的五步骤：</strong></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>1、状态表示</strong></span></p> 
<hr> 
<p> 在求解过程中，我们往往要创建dp表(其实就是数组），<span style="color:#fe2c24;"><strong>状态表示</strong></span>就是我们要找出dp表中值的含义是什么。</p> 
<p>状态表 怎么来？</p> 
<blockquote> 
 <ul><li>根据题目要求</li><li>经验+题目要求</li><li>分析题目的过程中，发现重复子问题</li></ul> 
</blockquote> 
<hr> 
<p><span style="color:#ff9900;"><strong> 2、状态转移方程</strong></span></p> 
<hr> 
<blockquote> 
 <p> 简单说是和dp[i]有关的一个方程</p> 
</blockquote> 
<hr> 
<p><span style="color:#a2e043;"><strong> 3、初始化</strong></span></p> 
<hr> 
<blockquote> 
 <p>保证在填写dp表的时候不越界</p> 
</blockquote> 
<hr> 
<p><strong><span style="color:#38d8f0;">4、填写顺序 </span></strong></p> 
<hr> 
<blockquote> 
 <p> 根据前面的计算得来<strong>，可以从前往后，也可以从后往前</strong>。</p> 
</blockquote> 
<hr> 
<p><span style="color:#4da8ee;"><strong> 5、返回值</strong></span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">根据题目要求+状态表示</span></p> 
</blockquote> 
<p> 讲完了解题步骤，下面就进行刷题训练。</p> 
<p>特别提醒：<strong>后面博客会带领大家由<span style="color:#fe2c24;">易到难</span>进行刷题，每期都为五题。</strong></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98">二、动态规划刷题</h2> 
<h3 id="1%E3%80%81%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0">1、<a class="link-info" href="https://leetcode.cn/problems/n-th-tribonacci-number/" rel="nofollow" title="第 N 个泰波那契数">第 N 个泰波那契数</a></h3> 
<blockquote> 
 <p>泰波那契序列 Tn 定义如下： </p> 
 <p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p> 
 <p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p> 
</blockquote> 
<blockquote> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>n = 4
<strong>输出：</strong>4
<strong>解释：</strong>
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>n = 25
<strong>输出：</strong>1389537
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>0 &lt;= n &lt;= 37</code></li><li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li></ul> 
</blockquote> 
<h4 id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><strong>a、解题思路：</strong></h4> 
<p><strong>1、题目中的状态表示是什么？</strong></p> 
<p><img alt="" height="623" src="https://images2.imgbox.com/da/51/NoDKMOUB_o.png" width="1160"></p> 
<p> dp[i] 表⽰：第 i 个泰波那契数的值。</p> 
<p><strong>2、状态转移方程</strong></p> 
<p>由题目意很很容易知道是T(n) = T(n-1)+T(n-2)+T(n-3)</p> 
<p><strong>3、初始化dp表</strong></p> 
<p>为了防止数组越界我们只需要初始化:</p> 
<blockquote> 
 <p>dp[0]=0;</p> 
 <p>dp[1]=1;</p> 
 <p>dp[2]=1;</p> 
</blockquote> 
<p><strong>4、 填表顺序</strong></p> 
<p>由状态方程+题意知道从左往右填写到N</p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/d7/9f/ZUDudImB_o.png" width="1200"></p> 
<p><strong>5、返回值</strong></p> 
<p>根据题目要求和dp[i]就为<strong>dp[n]</strong></p> 
<h4 id="b%E3%80%81%E4%BB%A3%E7%A0%81%C2%A0">b、代码 </h4> 
<pre><code class="language-cpp">class Solution {
public:
    int tribonacci(int n) 
    {
        //动态规划
        //1.创建dp表
        //2.初始化表
        //3.填表
        //4.返回值

        //处理边界情况
        if(n==0)return 0;
        if(n==1||n==2)return 1;

        //1、创建dp表
        vector&lt;int&gt; dp(n+1);
        //2、初始化表
        dp[0]=0,dp[1]=1,dp[2]=1;
        //3、填表
        for(int i = 3;i&lt;=n;i++)
        {
            dp[i] = dp[i-1]+dp[i-2]+dp[i-3];
        }
        //4、返回
        return dp[n];

    }
};</code></pre> 
<p><strong>Leetcode 测试结果： </strong></p> 
<p><img alt="" height="772" src="https://images2.imgbox.com/42/1f/Ms0vBKfa_o.png" width="732"></p> 
<h3 id="2%E3%80%81%C2%A0%20%C2%A0%E9%9D%A2%E8%AF%95%E9%A2%98%2008.01.%20%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98">2、   <a href="https://leetcode.cn/problems/three-steps-problem-lcci/" rel="nofollow" title="面试题 08.01. 三步问题">面试题 08.01. 三步问题</a></h3> 
<blockquote> 
 <p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p><strong>示例1:</strong></p> 
 <pre><strong> 输入</strong>：n = 3 
<strong> 输出</strong>：4
<strong> 说明</strong>: 有四种走法
</pre> 
 <p><strong>示例2:</strong></p> 
 <pre><strong> 输入</strong>：n = 5
<strong> 输出</strong>：13
</pre> 
 <p><strong>提示:</strong></p> 
 <ol><li>n范围在[1, 1000000]之间</li></ol> 
</blockquote> 
<h4 id="%C2%A0a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%9A"><strong> a、解题思路：</strong></h4> 
<p>从0位置开始跳，下面我们来思考一下题意：</p> 
<p> -----&gt;（表示跳台阶）</p> 
<p></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>n=1时候</strong></span></p> 
 <p>从0-----&gt;1 </p> 
 <p><strong>走法为1</strong></p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>n=2时候</strong></span></p> 
 <p>从0-----&gt;2</p> 
 <p>或者说我们让1-----&gt;2因为从 0-----&gt;1的走法我们已经考虑过了</p> 
 <p><strong>走法为2</strong></p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>n=3时候</strong></span></p> 
 <p>从0-----&gt;3或者说</p> 
 <p>我们让1-----&gt;3因为从 0-----&gt;1的走法我们已经考虑过了<strong>走法为1</strong></p> 
 <p>也可以2-----&gt;3因为从 0-----&gt;2的走法我们已经考虑过了<strong>走法为2</strong></p> 
 <p><strong>走法为1+1+2=4</strong></p> 
 <hr> 
 <p><strong>n=4时候</strong></p> 
 <p>不管怎么说先走到1，在从1-----&gt;4走法为1</p> 
 <p>不管怎么说先走到2，在从2-----&gt;4走法为2</p> 
 <p>不管怎么说先走到3，在从3-----&gt;4走法为4</p> 
 <p><strong>总共走法：1+2+4=7</strong></p> 
</blockquote> 
<p>大家这里是不是已经思路清晰起来了 </p> 
<p><strong>1、转态表示</strong></p> 
<p>以i位置为结尾，正好是到达第N个台阶，所以我们认为：</p> 
<p><strong>dp[i]表示：到达i位置时，一共有多少方法。</strong></p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/89/a8/EFYbhGAf_o.png" width="1094"></p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>以i位置的状态，最近进的一步进行划分</p> 
<blockquote> 
 <p>从(i-1)---&gt;i   dp[i-1]种走法</p> 
 <p>从(i-2)---&gt;i   dp[i-2]种走法</p> 
 <p>从(i-3)---&gt;i   dp[i-3]种走法</p> 
</blockquote> 
<p>所以状态方程为：dp[i]=dp[i-1]+dp[i-2]+dp[i-3] ;</p> 
<p><strong>3、初始化</strong></p> 
<p>这里我们注意我们用不到i==0,因为0台阶的研究没有意义。</p> 
<p><strong>  dp[1] = 1, dp[2] = 2, dp[3] = 4;</strong></p> 
<p><strong>4、 填表顺序</strong></p> 
<p>根据前面的推断肯定是从左往右。</p> 
<p><strong>5、返回值</strong></p> 
<p>根据题目要求和dp[i]就为<strong>dp[n]</strong></p> 
<h4 id="b%E3%80%81%E4%BB%A3%E7%A0%81"><strong>b、代码</strong></h4> 
<p>这题虽然和第一题非常相似但是有细节要处理、</p> 
<pre><code class="language-cpp">class Solution {
public:
    //取模
    const int MOD = 1e9 + 7;
    int waysToStep(int n)
    {
        //处理边界情况：
        if (n == 1 || n == 2)return n;
        if (n == 3)return 4;

        //创建dp表
        vector&lt;int&gt; dp(n + 1);

        //初始化
        dp[1] = 1, dp[2] = 2, dp[3] = 4;

        //填表
        for (int i = 4; i &lt;= n; i++)
        {
            //结果可能很大要进去取模
            dp[i] = ((dp[i - 1] + dp[i - 2]) % MOD + dp[i - 3]) % MOD;
        }
        //返回
        return dp[n];
    }
};</code></pre> 
<p><strong>Leetcode 测试结果： </strong><img alt="" height="774" src="https://images2.imgbox.com/2c/68/YsN0zoXp_o.png" width="739"></p> 
<h3 id="3%20%E3%80%81746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF" style="background-color:transparent;">3 、<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" rel="nofollow" title="746. 使用最小花费爬楼梯">746. 使用最小花费爬楼梯</a></h3> 
<blockquote> 
 <p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p> 
 <p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p> 
 <p>请你计算并返回达到楼梯顶部的最低花费。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>cost = [10,<em><strong>15</strong></em>,20]
<strong>输出：</strong>15
<strong>解释：</strong>你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>cost = [<em><strong>1</strong></em>,100,<em><strong>1</strong></em>,1,<em><strong>1</strong></em>,100,<em><strong>1</strong></em>,<em><strong>1</strong></em>,100,<em><strong>1</strong></em>]
<strong>输出：</strong>6
<strong>解释：</strong>你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul> 
</blockquote> 
<h4 id="a%E3%80%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%C2%A0">a、解题思路 </h4> 
<p>这里我们要注意到达楼顶，应该是const数组最后一个位置的下一个位置</p> 
<p>这里我们有二种思路：</p> 
<p><span style="color:#fe2c24;"><strong>思路一：</strong></span></p> 
<p><strong>1、转态表示</strong></p> 
<p>以i位置为结尾，正好是楼顶，所以我们认为：</p> 
<p><strong>dp[i]表示：到达i位置时，最小花费</strong></p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分</p> 
<blockquote> 
 <p>先到达i-1的位置，然后支付const[i-1],走一步， 花费：dp[i-1]+cost[i-1]</p> 
 <p>先到达i-2的位置，然后支付const[i-2],走二步， 花费：dp[i-2]+cost[i-2]</p> 
</blockquote> 
<p><strong>所以</strong>dp[i] =min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);</p> 
<p><strong>3、初始化</strong></p> 
<p>保证dp表不越界就好dp[0]=dp[1]=0;</p> 
<p><strong>4、 填表顺序</strong></p> 
<p>从左往右</p> 
<p><strong>5、返回值</strong></p> 
<p>dp[n]</p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>思路2：</strong></span></p> 
<p><strong>1、转态表示</strong></p> 
<p>以i位置为起点，到达楼顶，所以我们认为：</p> 
<p><strong>dp[i]表示：从i位置出发到达楼顶，此时最小花费</strong></p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分</p> 
<blockquote> 
 <ul><li>支付const[i],往后走一步， 从i+1位置出发到楼顶，花费：dp[i+1]+cost[i]</li><li>支付const[i],往后走二步， 从i+2位置出发到楼顶，花费：dp[i+2]+cost[i]</li></ul> 
</blockquote> 
<p><strong>所以</strong>dp[i] =min(dp[i+1]+cost[i],dp[i+2]+cost[i]);</p> 
<p><strong>3、初始化</strong></p> 
<p>保证dp表不越界就好dp[n-1]=cost[n-1],dp[n-2]=cost[n-2];</p> 
<p><strong>4、 填表顺序</strong></p> 
<p>从右往左</p> 
<p><strong>5、返回值</strong></p> 
<p>min(dp[0],dp[1]);</p> 
<h4>b、代码</h4> 
<p>这里有二种解题思路：</p> 
<p>思路一：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) 
    {
        //处理边界情况
        int n = cost.size();
        if(n==0||n==1)return cost[n];
        //创建dp表
        vector&lt;int&gt; dp(n+1);
        //填表
        for(int i = 2;i&lt;=n;i++)
        {
            dp[i] =min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        //返回
        return dp[n];
    }
};</code></pre> 
<p> <strong>Leetcode 测试结果： </strong><img alt="" height="687" src="https://images2.imgbox.com/4a/c7/gtI7u1qJ_o.png" width="714"></p> 
<p> 解法二：</p> 
<pre><code class="language-cpp">class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost)
    {
        int n = cost.size();
        //创建dp表
        vector&lt;int&gt; dp(n+1);
        //初始化
        dp[n-1]=cost[n-1],dp[n-2]=cost[n-2];
        //填表
        for(int i = n-3;i&gt;=0;i--)
        {
            dp[i] = min(dp[i+1]+cost[i],dp[i+2]+cost[i]);
        }
        //返回
        return min(dp[0],dp[1]);
    }
};</code></pre> 
<p> <strong>Leetcode 测试结果： </strong> </p> 
<p><img alt="" height="820" src="https://images2.imgbox.com/ea/fa/lEMFEJtZ_o.png" width="773"></p> 
<h3 id="%C2%A0%204%E3%80%81%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95">  4、<a class="link-info" href="https://leetcode.cn/problems/decode-ways/description/" rel="nofollow" title="解码方法">解码方法</a></h3> 
<blockquote> 
 <p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p> 
 <pre>'A' -&gt; "1"
'B' -&gt; "2"
...
'Z' -&gt; "26"</pre> 
 <p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>"11106"</code> 可以映射为：</p> 
 <ul><li><code>"AAJF"</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>"KJF"</code> ，将消息分组为 <code>(11 10 6)</code></li></ul> 
 <p>注意，消息不能分组为  <code>(1 11 06)</code> ，因为 <code>"06"</code> 不能映射为 <code>"F"</code> ，这是由于 <code>"6"</code> 和 <code>"06"</code> 在映射中并不等价。</p> 
 <p>给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p> 
 <p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>s = "12"
<strong>输出：</strong>2
<strong>解释：</strong>它可以解码为 "AB"（1 2）或者 "L"（12）。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>s = "226"
<strong>输出：</strong>3
<strong>解释：</strong>它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>s = "06"
<strong>输出：</strong>0
<strong>解释：</strong>"06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul> 
</blockquote> 
<h4>a、解题思路 </h4> 
<p>看我们题目后，根据经验此题位动态规划解题</p> 
<p><strong>1、转态表示</strong></p> 
<p>首先我们想以i位置为结尾表示什么</p> 
<p><strong>dp[i]表示：以i位置结尾的时候，解码的方法有多少种</strong></p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分</p> 
<p><span style="color:#fe2c24;"><strong>让s[i]单独解码的时候,假设a=s[i]</strong></span></p> 
<blockquote> 
 <ul><li>成功,a!='0'（或者说是a&gt;='1'&amp;&amp;a&lt;='9'），<strong>解码的种类有dp[i-1]种</strong></li><li>失败为0</li></ul> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>让s[i-1]和s[i]组合进行解码 假设组合为b</strong></span></p> 
<blockquote> 
 <ul><li>成功b&gt;='10'&amp;&amp;b&lt;='26',<strong>解码的种类有dp[i-2]种</strong></li><li>失败为0</li></ul> 
</blockquote> 
<p>有同学可能会想为什么不让dp[i]和dp[i+1]进行组合，但是大家 要明白，填表到dp[i]的时候，我们是知道dp[i-1]有多少种解码，但是<strong>我们不知道dp[i+1]有多少种解码。</strong></p> 
<p><strong>所以状态转移方法为</strong></p> 
<blockquote> 
 <p><strong>单独解码</strong></p> 
 <p><strong>dp[i] +=dp[i-1];</strong></p> 
 <p><strong>组合解码</strong></p> 
 <p><strong>dp[i]=dp[i-2];</strong></p> 
</blockquote> 
<p><strong>3、初始化</strong></p> 
<p>保证dp表</p> 
<pre><code class="language-cpp">dp[0] = s[0]!='0';

if(s[0]!='0'&amp;&amp;s[1]!='0') dp[1] +=dp[0];

//这里我们还要把组合转换为数字进行判断

int t = (s[0]-'0')*10+(s[1]-'0');

if(t&gt;=10&amp;&amp;t&lt;=26) dp[1] +=1;</code></pre> 
<p><strong>4、 填表顺序</strong></p> 
<p>从左往右</p> 
<p><strong>5、返回值</strong></p> 
<p>dp[n-1]</p> 
<h4>b、代码</h4> 
<pre><code class="language-cpp">class Solution {
public:
    int numDecodings(string s)
    {
        //创建dp表
        int n = s.size();
        vector&lt;int&gt; dp(n);
        //初始化
        dp[0] = s[0]!='0';
        //处理边界情况
        if(n==1) return dp[0];
        //单解码
        if(s[0]!='0'&amp;&amp;s[1]!='0') dp[1] +=dp[0];
        //组合起来
        int t = (s[0]-'0')*10+(s[1]-'0');
        if(t&gt;=10&amp;&amp;t&lt;=26) dp[1] +=1;

        //填表
        for(int i = 2;i&lt;n;i++)
        {
            //单解码
            if(s[i]!='0') dp[i] +=dp[i-1];
            //双解码
            int t = (s[i-1]-'0')*10+(s[i]-'0');
            if(t&gt;=10&amp;&amp;t&lt;=26) dp[i] +=dp[i-2];
        }

        //返回
        return dp[n-1];
    }
};</code></pre> 
<p> <strong>Leetcode 测试结果： </strong></p> 
<p><img alt="" height="692" src="https://images2.imgbox.com/a2/a4/Qgkp1k9R_o.png" width="944"></p> 
<h4 id="c%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%C2%A0"><strong>c、代码优化 </strong></h4> 
<p>不知道大家分发现没，我们在初始化的代码和填表的代码，有着非常相似的特色，那我们能不能进行优化呢？</p> 
<p>其实是可以的，多一个数组的空间就可以了。</p> 
<p><img alt="" height="492" src="https://images2.imgbox.com/c8/70/39PCX0EF_o.png" width="1200"></p> 
<p>简单的理解就是，把初始化的过程和填表合并了。但要注意二个问题：</p> 
<p>那个虚拟节点dp[0]填写多少？后面大家做都了这种题，很多情况下都是填写0但，但是这里却是填写<strong>dp[0]=1; </strong></p> 
<p><strong>为什么了，因为我们这里要保证后面填写的正确</strong></p> 
<p>比如：在进双解码的时候dp[i]+=dp[i-2]，如何i=2时候，这里我们吧dp[0]初始化为0就会漏掉这种情况。</p> 
<p><strong>下标映射关系如上图。</strong></p> 
<pre><code class="language-cpp">class Solution {
public:
    int numDecodings(string s)
    {
        //创建dp表
        int n = s.size();
        vector&lt;int&gt; dp(n+1);
        //初始化
        dp[0] = 1;//保证后面的填表的正确性
        //处理边界情况
        dp[1] = s[1-1]!='0';
        if(n==1) return dp[1];
        //填表
        for(int i = 2;i&lt;=n;i++)
        {
            //单解码
            if(s[i-1]!='0') dp[i] +=dp[i-1];
            //双解码
            int t = (s[i-2]-'0')*10+(s[i-1]-'0');
            if(t&gt;=10&amp;&amp;t&lt;=26) dp[i] +=dp[i-2];
        }

        //返回
        return dp[n];
    }
};</code></pre> 
<p> <strong>Leetcode 测试结果： </strong> </p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/1c/96/rA2SGhVW_o.png" width="926"></p> 
<h3 id="%C2%A05%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88medium%EF%BC%89"> 5、<a class="link-info" href="https://leetcode.cn/problems/unique-paths/description/" rel="nofollow" title="不同路径（medium）">不同路径（medium）</a></h3> 
<blockquote> 
 <p>一个机器人位于一个 <code>m x n</code><em> </em>网格的左上角 （起始点在下图中标记为 “Start” ）。</p> 
 <p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p> 
 <p>问总共有多少条不同的路径？</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="183" src="https://images2.imgbox.com/44/5c/0G3x32KV_o.png" width="400"></p> 
 <pre><strong>输入：</strong>m = 3, n = 7
<strong>输出：</strong>28</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>m = 3, n = 2
<strong>输出：</strong>3
<strong>解释：</strong>
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向下
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>m = 7, n = 3
<strong>输出：</strong>28
</pre> 
 <p><strong>示例 4：</strong></p> 
 <pre><strong>输入：</strong>m = 3, n = 3
<strong>输出：</strong>6
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul> 
</blockquote> 
<h4>a、解题思路 </h4> 
<p>看我们题目后，根据经验此题位动态规划解题</p> 
<p><strong>1、转态表示</strong></p> 
<p>首先我们想以i，j位置为结尾表示什么</p> 
<p><strong>dp[i][j表示：以i,j位置结尾的时候，机器人到这里有多少条路径</strong></p> 
<p><strong> 2、状态转移方程</strong></p> 
<p>根据最近的一个位置划分</p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/06/f0/fwnV1eWi_o.png" width="1118"></p> 
<p>我要求到[i,j] 路径，本质上就<strong>是求dp[i - 1][j] + dp[i][j - 1]的路径和</strong></p> 
<p></p> 
<p><strong>所以状态转移方法为</strong></p> 
<blockquote> 
 <p>dp[i][j] = dp[i-1][j]+dp[i][j-1];</p> 
</blockquote> 
<p><strong>3、初始化</strong></p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/82/e9/Co61MnUc_o.png" width="795"></p> 
<p>这里我们要初始化，就是在二维数组多开一行和一列，但我们要思路多开的行列填什么呢（一切都是为了填表走服务）？，很明显，在根据dp[i][j] = dp[i-1][j]+dp[i][j-1];填写表格的时候，走一步就到终点，那最外层从从到都应该填1（<strong>dp[i][j表示：以i,j位置结尾的时候，机器人到这里有多少条路径</strong>），为达到这不目的，应该把dp[0][1]=1其余为0。</p> 
<p><strong>4、 填表顺序</strong></p> 
<p>从上往下填写每一行，每一行都是从左往又开始填写 </p> 
<p><strong>5、返回值</strong></p> 
<p>dp[m][n]</p> 
<h4>b、代码</h4> 
<pre><code class="language-cpp">class Solution {
public:
    int uniquePaths(int m, int n)
    {
        //创建二维dp表
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
        //初始化
        dp[0][1] = 1;
        //填表
        for (int i = 1; i &lt;= m; i++)
        {
            for (int j = 1; j &lt;= n; j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
};</code></pre> 
<p> <strong>Leetcode 测试结果： </strong> <img alt="" height="644" src="https://images2.imgbox.com/92/25/TSPdu1YP_o.png" width="895"> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5329f75ee63071fa4e19b4187f9bb282/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">当C&#43;&#43;的static遇上了继承</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d934b182baa79cde06d45846164fb5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">无涯教程-C&#43;&#43; 算法 - reverse函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>