<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构~~排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3c2072bf9a29cc0755701cac29a94c6e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构~~排序">
  <meta property="og:description" content="目录
一、排序的概念
二、插入排序
直接插入排序
希尔排序
三、选择排序
选择排序
堆排序
四、交换排序
冒泡排序
快速排序
递归实现
非递归实现
五、归并排序
递归
非递归
六、非比较排序（计数排序）
七、其他排序
基数排序
桶排序
八、总结
一、排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
常见的排序算法：
二、插入排序 基本思想：直接插入排序是一种简单的插入排序法 ，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。 实际中我们玩扑克牌时，就用了插入排序的思想
直接插入排序 当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移
代码实现 // 插入排序 void InsertSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i&#43;&#43;) { int end=i; int tmp = a[end &#43; 1]; while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end &#43; 1] = a[end]; end--; } else { break; } } a[end &#43; 1] = tmp; } } 直接插入排序的特性总结：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-07T13:08:53+08:00">
    <meta property="article:modified_time" content="2024-06-07T13:08:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构~~排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、排序的概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">二、插入排序</a></p> 
<p id="%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">直接插入排序</a></p> 
<p id="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" rel="nofollow">希尔排序</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">三、选择排序</a></p> 
<p id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">选择排序</a></p> 
<p id="%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">堆排序</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F" rel="nofollow">四、交换排序</a></p> 
<p id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">冒泡排序</a></p> 
<p id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow">快速排序</a></p> 
<p id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">递归实现</a></p> 
<p id="%C2%A0%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%C2%A0%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow"> 非递归实现</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="nofollow">五、归并排序</a></p> 
<p id="%E9%80%92%E5%BD%92-toc" style="margin-left:80px;"><a href="#%E9%80%92%E5%BD%92" rel="nofollow">递归</a></p> 
<p id="%E9%9D%9E%E9%80%92%E5%BD%92-toc" style="margin-left:80px;"><a href="#%E9%9D%9E%E9%80%92%E5%BD%92" rel="nofollow">非递归</a></p> 
<p id="%E5%85%AD%E3%80%81%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89" rel="nofollow">六、非比较排序（计数排序）</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F" rel="nofollow">七、其他排序</a></p> 
<p id="%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" rel="nofollow">基数排序</a></p> 
<p id="%E6%A1%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F" rel="nofollow">桶排序</a></p> 
<p id="%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">八、总结</a></p> 
<hr id="hr-toc"> 
<h3 style="background-color:transparent;">一、排序的概念</h3> 
<p><strong>排序：</strong>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p> 
<p><strong>稳定性：</strong>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。</p> 
<p><strong>内部排序：</strong>数据元素全部放在内存中的排序。</p> 
<p><strong>外部排序：</strong>数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p> 
<p><strong>常见的排序算法：</strong></p> 
<p class="img-center"><img alt="" height="364" src="https://images2.imgbox.com/7c/27/uxhVdUag_o.png" width="455"></p> 
<h3 id="%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">二、插入排序</h3> 
<p> 基本思想：直接插入排序是一种简单的插入排序法 ，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。 实际中我们玩扑克牌时，就用了插入排序的思想</p> 
<p class="img-center"><img alt="" height="293" src="https://images2.imgbox.com/64/10/8Mzjq38H_o.png" width="333"></p> 
<p></p> 
<h4 id="%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序</h4> 
<p>当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移</p> 
<p class="img-center"><img alt="" height="304" src="https://images2.imgbox.com/28/e6/xiHu2ZUN_o.png" width="900"></p> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">// 插入排序
void InsertSort(int* a, int n)
{
	for (int i = 0; i &lt; n - 1; i++)
	{
		int end=i;
		int tmp = a[end + 1];
		while (end &gt;= 0)
		{
			if (tmp &lt; a[end])
			{
				a[end + 1] = a[end];
				end--;
			}
			else
			{
				break;
			}
		}
		a[end + 1] = tmp;
	}
}</code></pre> 
<blockquote> 
 <p>直接插入排序的特性总结：</p> 
 <p>1. 元素集合越接近有序，直接插入排序算法的时间效率越高</p> 
 <p>2. 时间复杂度：O(N^2)</p> 
 <p>3. 空间复杂度：O(1)，它是一种稳定的排序算法</p> 
 <p>4. 稳定性：稳定 </p> 
</blockquote> 
<h4 id="%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</h4> 
<p>希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成个 组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工作。当到达=1时，所有记录在统一组内排好序。 </p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/6a/be/p4t18Zx8_o.png" width="683"></p> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">// 希尔排序
void ShellSort(int* a, int n)
{
	int get = n;
	while (get &gt; 1)
	{
		get = get / 3 + 1;
		for (int i = 0; i &lt; n - get; i++)
		{
			int end = i;
			int tmp = a[end + get];
			while (end &gt;= 0)
			{
				if (tmp &lt; a[end])
				{
					a[end + get] = a[end];
					end -= get;
				}
				else
				{
					break;
				}
			}
			a[end+get] = tmp;
		}
	}
}</code></pre> 
<blockquote> 
 <p>希尔排序的特性总结：</p> 
 <p>1. 希尔排序是对直接插入排序的优化。</p> 
 <p>2. 当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。</p> 
 <p>3. 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，因此在好些树中给出的 希尔排序的时间复杂度都不固定：</p> 
 <p><strong>《数据结构(C语言版)》--- 严蔚敏</strong></p> 
 <p><img alt="" height="375" src="https://images2.imgbox.com/18/91/pW4E6itG_o.png" width="1200"><strong> 《数据结构-用面相对象方法与C++描述》--- 殷人昆</strong><img alt="" height="417" src="https://images2.imgbox.com/8b/6b/E2wmowDm_o.png" width="1200"></p> 
 <p>4. 稳定性：不稳定</p> 
</blockquote> 
<h3 id="%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">三、选择排序</h3> 
<p><strong>基本思想</strong>： 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的 数据元素排完 。</p> 
<h4 id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</h4> 
<p>直接选择排序: 在元素集合array[i]--array[n-1]中选择关键码最大(小)的数据元素 若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换 在剩余的array[i]--array[n-2]（array[i+1]--array[n-1]）集合中，重复上述步骤，直到集合剩余1个元素</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/a8/bd/ACYxntHI_o.png" width="811"><strong> 代码实现</strong></p> 
<pre><code class="language-cpp">void Swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
// 选择排序
void SelectSort(int* a, int n)
{
	int begin = 0, end = n - 1;
	while (begin &lt; end)
	{
		int max = begin, min = begin;
		for (int i = begin + 1; i &lt;= end; i++)
		{
			if (a[i]&gt;a[max])
			{
				max = i;
			}
			if (a[i] &lt; a[min])
			{
				min = i;
			}
		}
		Swap(&amp;a[begin], &amp;a[min]);
		if (max == begin)
			max = min;
		Swap(&amp;a[end], &amp;a[max]);
		begin++;
		end--;
	}
}</code></pre> 
<blockquote> 
 <p>直接选择排序的特性总结：</p> 
 <p>1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用</p> 
 <p>2. 时间复杂度：O(N^2)</p> 
 <p>3. 空间复杂度：O(1)</p> 
 <p>4. 稳定性：不稳定</p> 
</blockquote> 
<h4 id="%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</h4> 
<p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是 通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆。</p> 
<p><img alt="" height="793" src="https://images2.imgbox.com/35/af/v5OEs5Hv_o.png" width="819"></p> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">void Swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
// 堆排序
void AdjustDwon(int* a, int n, int root)
{
	int child = root * 2 + 1;
	while (child &lt; n)
	{
		if (child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child])
		{
			child++;
		}
		if (a[child] &gt; a[root])
		{
			Swap(&amp;a[root], &amp;a[child]);
			root = child;
			child = root * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
void HeapSort(int* a, int n)
{
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDwon(a, n, i);
	}
	int end = n - 1;
	while (end&gt;0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDwon(a, end, 0);
		end--;
	}
}</code></pre> 
<p><strong>关于TOP--K问题在之前的文章讲过：</strong><a class="link-info" href="http://t.csdnimg.cn/B35RB" rel="nofollow" title="TOP-K问题">TOP-K问题</a></p> 
<blockquote> 
 <p>直接选择排序的特性总结：</p> 
 <p>1. 堆排序使用堆来选数，效率就高了很多。</p> 
 <p>2. 时间复杂度：O(N*logN)</p> 
 <p>3. 空间复杂度：O(1)</p> 
 <p>4. 稳定性：不稳定  </p> 
</blockquote> 
<h3 id="%E5%9B%9B%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F" style="background-color:transparent;">四、交换排序</h3> 
<p>基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排 序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p> 
<h4 id="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</h4> 
<p><img alt="" height="257" src="https://images2.imgbox.com/0c/1b/I9IVQekI_o.png" width="826"></p> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">void Swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
// 冒泡排序
void BubbleSort(int* a, int n)
{
	for (int i = 0; i &lt; n - 1; i++)
	{
		for (int j = 0; j &lt; n - 1 - i; j++)
		{
			if (a[j] &gt; a[j + 1])
			{
				Swap(&amp;(a[j]),&amp;(a[j+1]));
			}
		}
	}
}</code></pre> 
<blockquote> 
 <p>冒泡排序的特性总结：</p> 
 <p>1. 冒泡排序是一种非常容易理解的排序</p> 
 <p>2. 时间复杂度：O(N^2)</p> 
 <p>3. 空间复杂度：O(1)</p> 
 <p>4. 稳定性：稳定  </p> 
</blockquote> 
<h4 id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" style="background-color:transparent;">快速排序</h4> 
<h5 id="%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">递归实现</h5> 
<p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：任取待排序元素序列中 的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右 子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</p> 
<p>快速排序递归实现的主框架，发现与二叉树前序遍历规则非常像，在写递归框架时可想想二叉树前序遍历规则即可快速写出来，后序只需分析如何按照基准值来对区间中数据进行划分的方式即可。</p> 
<p><strong>常见快排方式有</strong></p> 
<p><strong>1. hoare版本</strong></p> 
<p><img alt="" height="546" src="https://images2.imgbox.com/9e/d1/53BBXUR1_o.png" width="1145"><strong> </strong></p> 
<blockquote> 
 <p>思路： </p> 
 <p>1. 选择一个基准元素。</p> 
 <p>2. 定义两个指针，一个从数组开头（left），一个从数组末尾（right）。</p> 
 <p>3. 从右向左找第一个小于基准的元素，从左向右找第一个大于基准的元素，然后交换这两个元素，使得左边小于等于基准的元素都在基准左侧，右边大于等于基准的元素都在基准右侧。</p> 
 <p>4. 重复这个过程，直到 left 和 right 指针相遇，此时基准元素的位置就确定了，该位置左侧都是小于等于它的，右侧都是大于等于它的。</p> 
 <p>5. 对基准元素左右两侧的子数组分别重复上述过程进行排序。</p> 
 <p>通过不断地划分和对子部分排序，最终实现整个数组的排序。</p> 
</blockquote> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">void QuickSort(int* a, int left, int right)
{
	if (left &gt;= right)
	{
		return;
	}
	int key = left;
	int begin = left;
	int end = right;
	while (begin&lt;end)
	{
		while (begin &lt; end &amp;&amp; a[key]&lt;=a[end])
		{
			end--;
		}
		while (begin &lt; end &amp;&amp; a[key]&gt;=a[begin])
		{
			begin++;
		}
		Swap(&amp;a[end],&amp;a[begin]);
	}
	Swap(&amp;a[key], &amp;a[begin]);
	key = begin;
	QuickSort(a, left, key - 1);
	QuickSort(a, key + 1, right);
}</code></pre> 
<p><strong>2. 挖坑法</strong></p> 
<p><img alt="" height="546" src="https://images2.imgbox.com/8a/3a/1UF6OKiM_o.png" width="1145"></p> 
<blockquote> 
 <p>思路： </p> 
 <p>1. 选择基准元素：通常选择数组的第一个元素或最后一个元素作为基准。</p> 
 <p>2. 初始化左右指针：将左右指针分别指向数组的第一个元素和最后一个元素。</p> 
 <p>3. 挖坑：将基准元素保存到一个临时变量中，此时基准元素的位置就形成了一个“坑”。</p> 
 <p>4. 从右向左移动右指针：找到第一个小于基准的元素，将其填入“坑”中，同时右指针原来的位置形成了一个新的“坑”。</p> 
 <p>5. 从左向右移动左指针：找到第一个大于基准的元素，将其填入新的“坑”中，同时左指针原来的位置形成了一个新的“坑”。</p> 
 <p>6. 重复步骤 4 和 5，直到左指针和右指针相遇，此时将基准元素填入最后的“坑”中，完成一次划分。</p> 
 <p>7. 对基准元素左边和右边的子数组分别重复步骤 1 到 6，进行递归排序。</p> 
 <p>通过不断地划分和递归，最终可以将整个数组排序。</p> 
</blockquote> 
<p><strong>代码实现： </strong></p> 
<pre><code class="language-cpp">int PartSort(int* a, int begin, int end)
{
	//begin是坑
	int key = a[begin];
	while (begin &lt; end)
	{
		while (begin &lt; end &amp;&amp; a[end] &gt;= key)
			--end;

		// end给begin这个坑，end就变成了新的坑。
		a[begin] = a[end];

		while (begin &lt; end &amp;&amp; a[begin] &lt;= key)
			++begin;

		// end给begin这个坑，begin就变成了新的坑。
		a[end] = a[begin];
	}

	a[begin] = key;

	return begin;
}

void QuickSort(int* a, int left, int right)  
{
	if (left &gt;= right)
	{
		return;
	}
	int	key = PartSort(a,left,right);
	QuickSort(a, left, key - 1);
	QuickSort(a, key + 1, right);
}</code></pre> 
<p><strong>3. 前后指针版本</strong></p> 
<p><img alt="" height="546" src="https://images2.imgbox.com/0f/5b/mFtK0VUR_o.png" width="1145"></p> 
<blockquote> 
 <p>思路 ：</p> 
 <p>1. 选择一个基准元素。</p> 
 <p>2. 初始化两个指针：前指针 prev 从数组起始位置开始，后指针 cur 也从起始位置开始。</p> 
 <p>3. cur 指针向后移动，遇到小于等于基准元素的就停下来。</p> 
 <p>4. 此时 prev 指针向前移动一步（如果 prev 和 cur 不相等），然后交换 prev 所指向的元素和 cur 所指向的元素。</p> 
 <p>5. 继续重复步骤 3 和 4，直到 cur 遍历完整个数组。</p> 
 <p>6. 交换基准元素和 prev 指针最终停留位置的元素，这样就完成了一次划分，基准元素左边都是小于等于它的，右边都是大于等于它的。</p> 
 <p>7. 对基准元素左右两侧的子数组分别重复上述过程进行递归排序。</p> 
 <p>通过这样不断地划分和递归，最终实现数组的排序。</p> 
</blockquote> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">// 快速排序前后指针法
int PartSort(int* a, int left, int right)
{
	int key = left;
	int prev = left;
	int cur = left + 1;
	while (cur &lt;= right)
	{
		if (a[cur] &lt; a[key] &amp;&amp; ++prev != cur)
			Swap(&amp;a[prev], &amp;a[cur]);
		cur++;
	}
	Swap(&amp;a[prev], &amp;a[key]);
	return prev;
}
void QuickSort(int* a, int left, int right) 
{
	if (left &gt;= right)
	{
		return;
	}
	int	key = PartSort(a,left,right);
	QuickSort(a, left, key - 1);
	QuickSort(a, key + 1, right);
}</code></pre> 
<p><strong>快速排序优化 </strong></p> 
<blockquote> 
 <p><strong>三数取中法选key</strong></p> 
 <p>1. 从待排序序列中选择三个元素，可以是第一个元素、中间元素和最后一个元素，或者其他固定位置的元素。</p> 
 <p>2. 对这三个元素进行比较，找出中间大小的元素。</p> 
 <p>3. 将中间大小的元素作为基准元素。</p> 
 <p>通过使用三数取中法选择基准元素，可以减少快速排序在最坏情况下的时间复杂度，提高排序的效率。这种方法在处理大部分数据时都能取得较好的效果，但在某些特殊情况下，可能仍然需要进一步的优化或选择其他合适的排序算法。</p> 
</blockquote> 
<blockquote> 
 <p><strong>小区间优化</strong></p> 
 <p>快速排序的小区间优化是指在快速排序的递归过程中，当待排序的区间长度较小时，不再继续进行递归调用，而是采用其他更高效的排序算法对小区间进行排序。常见的小区间优化方法包括以下几种：</p> 
 <p>• 插入排序：当区间长度小于某个阈值时，使用插入排序算法对小区间进行排序。插入排序在小型数据集上的性能较好，能够提高排序效率。</p> 
 <p>• 选择排序：与插入排序类似，当区间长度较小时，选择排序也是一种简单有效的排序算法。</p> 
 <p>• 直接排序：对于非常小的区间，可以直接使用冒泡排序或其他简单的排序算法进行排序。</p> 
 <p>通过采用小区间优化，可以减少递归调用的次数，降低时间复杂度，特别是在处理大规模数据时，能够提高快速排序的整体性能。</p> 
 <p><strong>通过采用小区间优化，可以减少递归调用的次数，降低时间复杂度，特别是在处理大规模数据时，能够提高快速排序的整体性能。</strong></p> 
</blockquote> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">int GetMidi(int* a, int left, int right) //三数取中
{
	int midi = (left + right)/2;
	if (a[left] &gt; a[midi])
	{
		if (a[midi] &gt; a[right])
			return midi;
		else if (a[left] &gt; a[right])
			return right;
		else
			return left;
	}
	else//a[left]&lt;a[midi]
	{
		if (a[midi] &lt; a[right])
			return midi;
		else if (a[left] &gt; a[right])
			return left;
		else
			return right;
	}

}
 //快速排序递归实现
void QuickSort(int* a, int left, int right)
{
	if (left &gt;= right)
	{
		return;
	}
	if (( right- left  + 1) &lt; 10)  //小区间优化  最后10个数 走插入排序
	{
		InsertSort(a + left, right - left + 1);//插入排序
	}
	else
	{
		int midi = GetMidi(a, left, right);  //三数取中  
		Swap(&amp;a[left], &amp;a[midi]);
		int key = left;
		int begin = left;
		int end = right;
		while (begin &lt; end)
		{
			while (begin &lt; end &amp;&amp; a[end] &gt;= a[key])
			{
				end--;
			}
			while (begin &lt; end &amp;&amp; a[begin] &lt;= a[key])
			{
				begin++;
			}
			Swap(&amp;a[end], &amp;a[begin]);
		}
		Swap(&amp;a[key], &amp;a[begin]);
		key = begin;
		QuickSort(a, left, key - 1);
		QuickSort(a, key + 1, right);
	}
}</code></pre> 
<h5 id="%C2%A0%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"> 非递归实现</h5> 
<blockquote> 
 <p>思路：</p> 
 <p>1. 初始化栈：创建一个栈来模拟递归过程。</p> 
 <p>2. 选择基准并划分：先选择一个基准元素，对当前区间进行划分，得到左右两个子区间。</p> 
 <p>3. 入栈：将左右子区间的边界信息（起始位置和结束位置）分别入栈。</p> 
 <p>4. 循环处理：不断从栈中取出区间信息，对取出的区间重复进行划分和入栈操作，直到栈为空。</p> 
 <p>在这个过程中，通过栈来保存未处理完的子区间，从而以非递归的方式实现了原本递归的逻辑。这样可以避免递归调用带来的栈空间开销过大等问题。</p> 
</blockquote> 
<p><strong>代码实现 </strong></p> 
<p><strong>栈的代码：</strong></p> 
<pre><code class="language-cpp">void STInit(ST* pst)
{
	assert(pst);
	pst-&gt;a = NULL;
	pst-&gt;top = 0;
	pst-&gt;capacity = 0;
}
void STDestroy(ST* pst)
{
	assert(pst);
	free(pst-&gt;a);
	pst-&gt;a = NULL;
	pst-&gt;capacity = pst-&gt;top = 0;
}
void STPush(ST* pst, STDataType x)
{
	if (pst-&gt;top == pst-&gt;capacity)
	{
		int newCapacity = pst-&gt;capacity == 0 ? 4 : pst-&gt;capacity * 2;
		STDataType* tmp = (STDataType*)realloc(pst-&gt;a, newCapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc err");
			return;
		}
		pst-&gt;a = tmp;
		pst-&gt;capacity = newCapacity;
	}
	pst-&gt;a[pst-&gt;top] = x;
	pst-&gt;top++;
}
void STPop(ST* pst)
{
	assert(pst);
	assert(!STEmpty(pst));
	pst-&gt;top--;
}
STDataType STTop(ST* pst)
{
	assert(pst);
	assert(!STEmpty(pst));
	return pst-&gt;a[pst-&gt;top - 1];
}
bool STEmpty(ST* pst)
{
	assert(pst);
	return pst-&gt;top == 0;
}</code></pre> 
<p><strong>快排非递归代码 </strong></p> 
<pre><code class="language-cpp">void QuickSortNonR(int* a, int left, int right)
{
	ST st;
	STInit(&amp;st);
	STPush(&amp;st, right);
	STPush(&amp;st, left);
	while (!STEmpty(&amp;st))
	{
		int begin = STTop(&amp;st);
		STPop(&amp;st);
		int end = STTop(&amp;st);
		STPop(&amp;st);
		int keyi = PartSort1(a, begin, end);
		if (keyi + 1 &lt; end)
		{
			STPush(&amp;st, end);
			STPush(&amp;st, keyi + 1);
		}
		if (begin &lt; keyi - 1)
		{
			STPush(&amp;st, keyi - 1);
			STPush(&amp;st, begin);
		}
	}

}</code></pre> 
<blockquote> 
 <p>快速排序的特性总结：</p> 
 <p>1. 快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序</p> 
 <p>2. 时间复杂度：O(N*logN)</p> 
 <p>3. 空间复杂度：O(logN)</p> 
 <p>4. 稳定性：不稳定</p> 
</blockquote> 
<h3 id="%E4%BA%94%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" style="background-color:transparent;">五、归并排序</h3> 
<p><strong>基本思想：</strong> 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有 序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序核心步骤：</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/94/5d/T1BMJneN_o.png" width="762"></p> 
<p> </p> 
<h4 id="%E9%80%92%E5%BD%92" style="background-color:transparent;">递归</h4> 
<blockquote> 
 <p>1. 将数组不断地分成两半，直到每个部分只剩下一个元素或为空。</p> 
 <p>2. 对分成的左右两部分分别进行排序。</p> 
 <p>3. 将已排序的左右两部分合并成一个有序的整体。</p> 
 <p>在递归过程中，先找到中间位置将数组一分为二，然后对左右两部分递归调用归并排序函数进行排序。在合并阶段，创建一个辅助数组，通过比较左右两部分的元素，依次将较小的元素放入辅助数组，最后将辅助数组的内容复制回原数组对应的位置，从而完成一次合并，经过多次这样的递归和合并操作，最终使整个数组有序。</p> 
</blockquote> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">void _MergeSort(int* a,int* tmp,int begin,int end)
{
	if (begin &gt;= end)
	{
		return;
	}
	int mini = (begin + end) / 2;
	_MergeSort(a, tmp, begin, mini);
	_MergeSort(a, tmp, mini + 1, end);
	int i = begin;
	int begin1 = begin, end1 = mini;
	int begin2 = mini + 1, end2 = end;
	while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
	{
		if (a[begin1] &gt; a[begin2])
			tmp[i++] = a[begin2++];
		else
			tmp[i++] = a[begin1++];
	}
	while (begin1 &lt;= end1)
	{
		tmp[i++] = a[begin1++];
	}
	while (begin2 &lt;= end2)
	{
		tmp[i++] = a[begin2++];
	}
	memcpy(a + begin, tmp + begin, (end - begin + 1) * sizeof(int));
}
// 归并排序递归实现
void MergeSort(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);
	if (tmp == NULL)
	{
		perror("malloc err");
		return;
	}
	_MergeSort(a, tmp, 0, n - 1);
	free(tmp);
	tmp = NULL;
}</code></pre> 
<h4 id="%E9%9D%9E%E9%80%92%E5%BD%92" style="background-color:transparent;">非递归</h4> 
<blockquote> 
 <p>1. 首先从较小的子序列长度开始，比如初始子序列长度为 1。</p> 
 <p>2. 不断将相邻的具有相同长度的子序列两两合并，得到新的长度翻倍的子序列。</p> 
 <p>3. 在合并过程中，对两个子序列进行比较和排序操作，将它们合并成一个有序的子序列。</p> 
 <p>4. 逐步增加子序列的长度，重复进行合并操作，直到整个数组被合并完成为止。</p> 
 <p>具体实现时，通过循环逐步扩大子序列的长度，每次循环中对所有满足当前子序列长度的相邻区间进行合并操作。这样就可以在不使用递归的情况下实现归并排序的过程。</p> 
</blockquote> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">// 归并排序非递归实现
void MergeSortNonR(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);
	if (tmp == NULL)
	{
		perror("malloc err");
	}
	int gap = 1;
	while(gap &lt; n)
	{
		for (int i = 0; i &lt; n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + 2 * gap - 1;
			if (begin2 &gt;= n)
				break;
			if (end2 &gt;= n)
				end2 = n - 1;
			int j = i;
			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				if (a[begin1] &gt; a[begin2])
					tmp[j++] = a[begin2++];
				else
					tmp[j++] = a[begin1++];
			}
			while (begin1 &lt;= end1)
			{
				tmp[j++] = a[begin1++];
			}
			while (begin2 &lt;= end2)
			{
				tmp[j++] = a[begin2++];
			}
			memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1));
		}
		gap *= 2;
	}
	free(tmp);
	tmp = NULL;
}</code></pre> 
<blockquote> 
 <p>归并排序的特性总结：</p> 
 <p>1. 归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。</p> 
 <p>2. 时间复杂度：O(N*logN)</p> 
 <p>3. 空间复杂度：O(N)</p> 
 <p>4. 稳定性：稳定</p> 
</blockquote> 
<h3 id="%E5%85%AD%E3%80%81%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%EF%BC%88%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89" style="background-color:transparent;">六、非比较排序（计数排序）</h3> 
<blockquote> 
 <p><strong>思想：</strong>计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。</p> 
 <p> 操作步骤： 1. 统计相同元素出现次数  2. 根据统计的结果将序列回收到原来的序列中</p> 
</blockquote> 
<p class="img-center"><img alt="" height="299" src="https://images2.imgbox.com/70/1d/PT6W5Q0M_o.png" width="643"></p> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">// 计数排序
void CountSort(int* a, int n)
{
	int min = a[0], max = a[0];
	for (int i = 1; i &lt; n; i++)
	{
		if (a[i] &gt; max)
			max = a[i];
		if (a[i] &lt; min)
			min = a[i];
	}
	int ragn = max - min + 1;
	int* count = calloc(ragn, sizeof(int));
	if (count == NULL)
	{
		perror("calloc err");
		return;
	}
	for (int i = 0; i &lt; n; i++)
	{
		count[a[i]-min]++;
	}
	int j = 0;
	for (int i = 0; i &lt; ragn; i++)
	{
		while (count[i]--)
		{
			a[j++] = i + min;
		}
	}
}</code></pre> 
<blockquote> 
 <p>计数排序的特性总结：</p> 
 <p>1. 计数排序在数据范围集中时，效率很高，但是适用范围及场景有限。</p> 
 <p>2. 时间复杂度：O(MAX(N,范围))</p> 
 <p>3. 空间复杂度：O(范围) </p> 
 <p>4. 稳定性：稳定</p> 
</blockquote> 
<h3 id="%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F">七、其他排序</h3> 
<h4 id="%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</h4> 
<blockquote> 
 <p>1. 确定基数：通常根据待排序元素的特征（如数字的个位、十位、百位等）确定一个基数。</p> 
 <p>2. 按位分配和收集：从最低位（如个位）开始，将所有元素按照当前位的值分配到不同的“桶”中；然后按桶的顺序依次取出元素，这就完成了当前位的排序。接着对下一位重复这样的操作，依次向高位推进。</p> 
 <p>3. 重复过程：不断重复上述步骤，对每一位进行排序和收集，直到对最高位完成操作，此时整个数组就实现了排序。</p> 
 <p>基数排序适用于特殊情况，尤其是当元素的每一位都比较容易提取和处理时，它可以高效地对大量数据进行排序。</p> 
</blockquote> 
<p><strong>代码实现 </strong></p> 
<pre><code class="language-cpp">// 获取数字指定位上的数字
int getDigit(int num, int digit) {
    int divisor = 1;
    for (int i = 0; i &lt; digit - 1; i++) {
        divisor *= 10;
    }
    return (num / divisor) % 10;
}

// 对指定基数进行计数排序
void countingSort(int arr[], int n, int exp) {
    int output[n];
    int count[10] = {0};

    for (int i = 0; i &lt; n; i++) {
        count[getDigit(arr[i], exp)]++;
    }

    for (int i = 1; i &lt; 10; i++) {
        count[i] += count[i - 1];
    }

    for (int i = n - 1; i &gt;= 0; i--) {
        output[count[getDigit(arr[i], exp)] - 1] = arr[i];
        count[getDigit(arr[i], exp)]--;
    }

    for (int i = 0; i &lt; n; i++) {
        arr[i] = output[i];
    }
}

// 基数排序函数
void radixSort(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i &lt; n; i++) {
        if (arr[i] &gt; max) {
            max = arr[i];
        }
    }

    for (int exp = 1; max / exp &gt; 0; exp *= 10) {
        countingSort(arr, n, exp);
    }
}
</code></pre> 
<h4 id="%E6%A1%B6%E6%8E%92%E5%BA%8F" style="background-color:transparent;">桶排序</h4> 
<blockquote> 
 <p>1. 创建桶：根据待排序数据的范围和特点，创建若干个桶。</p> 
 <p>2. 数据分配：将各个元素根据特定规则分配到相应的桶中。</p> 
 <p>3. 桶内排序：对每个桶内的元素进行排序，可以使用其他简单排序方法。</p> 
 <p>4. 依次取出：按照桶的顺序依次取出所有桶中的元素，得到有序序列。</p> 
 <p>桶排序的关键在于合理地划分桶以及高效地处理桶内数据。通常适用于数据分布比较均匀且容易划分桶的情况。它在一些特定场景下能高效地完成排序任务。</p> 
</blockquote> 
<p><strong>代码实现</strong> </p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 对每个桶进行插入排序
void insertionSort(int bucket[], int bucketSize) {
    for (int i = 1; i &lt; bucketSize; i++) {
        int key = bucket[i];
        int j = i - 1;

        while (j &gt;= 0 &amp;&amp; bucket[j] &gt; key) {
            bucket[j + 1] = bucket[j];
            j = j - 1;
        }
        bucket[j + 1] = key;
    }
}

// 桶排序函数
void bucketSort(int arr[], int n, int bucketCount) {
    int min = arr[0], max = arr[0];
    for (int i = 1; i &lt; n; i++) {
        if (arr[i] &lt; min) min = arr[i];
        if (arr[i] &gt; max) max = arr[i];
    }

    double bucketRange = (double)(max - min + 1) / bucketCount;

    int** buckets = (int**)malloc(bucketCount * sizeof(int*));
    for (int i = 0; i &lt; bucketCount; i++) {
        buckets[i] = (int*)malloc(n * sizeof(int));
    }

    for (int i = 0; i &lt; n; i++) {
        int bucketIndex = (int)((arr[i] - min) / bucketRange);
        buckets[bucketIndex][0]++;
        buckets[bucketIndex][buckets[bucketIndex][0]] = arr[i];
    }

    int index = 0;
    for (int i = 0; i &lt; bucketCount; i++) {
        insertionSort(buckets[i], buckets[i][0] + 1);
        for (int j = 1; j &lt;= buckets[i][0]; j++) {
            arr[index++] = buckets[i][j];
        }
    }

    for (int i = 0; i &lt; bucketCount; i++) {
        free(buckets[i]);
    }
    free(buckets);
}
</code></pre> 
<h3 id="%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93" style="background-color:transparent;">八、总结</h3> 
<p><strong>排序算法复杂度及稳定性分析</strong></p> 
<p><img alt="" height="582" src="https://images2.imgbox.com/dc/91/JeumBWoe_o.png" width="1135"></p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/23/18/RK5GvOIG_o.png" width="690"></p> 
<blockquote> 
 <p><strong>数据结构排序算法的总结：</strong></p> 
 <p><strong>冒泡排序：</strong></p> 
 <p>• 两两比较相邻元素，若顺序不对则进行交换，每一轮将最大元素“浮”到末尾。</p> 
 <p><strong>选择排序：</strong></p> 
 <p>• 不断从待排序部分选择最小（或最大）元素放在已排序部分的末尾。</p> 
 <p><strong>插入排序：</strong></p> 
 <p>• 逐个将元素插入已排序的合适位置。</p> 
 <p><strong>快速排序：</strong></p> 
 <p>• 选择一个基准元素，通过划分操作将数组分为两部分，递归地对两部分进行排序。</p> 
 <p><strong>归并排序：</strong></p> 
 <p>• 不断将数组分成两半，对两半分别排序，再将排序好的两部分合并。</p> 
 <p><strong>堆排序：</strong></p> 
 <p>• 先构建最大堆，然后不断取出堆顶元素并调整堆，实现排序。</p> 
 <p><strong>希尔排序：</strong></p> 
 <p>• 基于插入排序，通过不断缩小增量进行分组插入排序。</p> 
 <p><strong>这些排序算法各有特点：</strong></p> 
 <p>• 时间复杂度方面：冒泡、选择、插入排序在最坏情况下为 ，快速、归并、堆排序在平均和最坏情况下有更好的性能<strong>。</strong></p> 
 <p>• 空间复杂度上，有些是原地排序（如冒泡、选择、插入、快速、希尔排序），而归并排序等可能需要额外空间。</p> 
 <p>• 稳定性方面也各有不同，比如冒泡、插入排序是稳定的，而快速排序通常不稳定。</p> 
 <p>在实际应用中，需要根据数据规模、特点以及具体需求来选择合适的排序算法。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/270b80cf96d49397979409f56cb20c60/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2014年上海高考作文题目（ChatGPT版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0004ec76d74dc524023daa14e178823f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Cloud系列——使用Sentinel进行微服务保护</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>