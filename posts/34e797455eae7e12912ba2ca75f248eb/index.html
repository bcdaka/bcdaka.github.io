<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python-AST语法树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/34e797455eae7e12912ba2ca75f248eb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python-AST语法树">
  <meta property="og:description" content="一、抽象语法树 1、什么是抽象语法树 在计算机科学中，抽象语法树（abstract syntax tree ，AST），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。AST是编译器或解释器在处理源代码时所使用的一种中间表示形式，在编译和代码生成过程中起着关键作用。
之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。
AST中的每个节点表示源代码中的一个语法构造，如变量声明、表达式、函数调用、控制结构等。树的根节点通常表示整个源代码文件，而子节点表示具体的语法元素及其关系。例如，一个函数声明的AST节点可能包含多个子节点，如函数名、参数列表和函数体等。
2、使用场景 python 和 Java 类似，解释器实际上分为两部分：编译器和虚拟机，先将代码编译成字节码，然后再由虚拟机执行。
编译器的编译过程,书中分为了6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。
词法分析：源代码可以看成字符序列，词法分析就是将源代码的字符序列分割成一系列的记号（Token，如关键字、标识符、字面量、特殊符号）。过程就是源代码程序被输入扫描器(Scanner，这里扫描器也是一个程序)，然后扫描器运用算法（如有限状态机）将字符序列分割成记号。同时扫描器会将这些记号放入一些表中。语法分析：使用语法分析器对词法分析阶段产生的记号进行语法分析，产生一棵语法树（采用上下文无关语法分析）。语法分析同时会确定符号优先级和含义，报告表达式不合法的错误等。语义分析：使用语义分析器来确定语句的语义，分为两种。静态语义：在编译期可以确定的语义，包括声明、类型匹配、类型转换。动态语义：在运行期才能确定的语义。中间语言生成（源代码优化）：编译器有很多层次的优化，对源代码级别有一个优化，使用源码级优化器。目标代码生成和优化：代码生成器将中间代码转换成目标机器代码，这个过程依赖目标机器。目标代码优化器对目标代码进行优化，如选择合适寻址方式、删除多余指令、使用位移代替乘法运算。 在编译时，AST主要用途包括：
语法检查：编译器可以通过遍历AST来检查源代码中是否存在语法错误。语义分析：编译器可以使用AST来分析源代码的语义，例如识别类型错误、作用域错误等。优化：编译器可以通过对AST进行变换和简化，实现源代码的优化。代码生成：编译器可以根据AST生成目标代码，例如汇编语言或机器代码。 在实际应用中，AST除了用于编译器或解释器，还被用于诸如代码重构、静态分析和代码格式化等工具和技术中。
编译器和解释器的核心：AST是编译器和解释器处理源代码的关键数据结构。在对源代码进行语法分析之后，编译器或解释器会生成AST。接下来，它们可以在AST上进行进一步的分析、优化和代码生成。这使得编译器和解释器能够更高效地处理源代码，为生成可执行程序或执行脚本提供基础。
代码分析：AST在静态代码分析和静态类型检查中起着重要作用。通过分析AST，我们可以检测代码中的潜在错误、不良实践和安全漏洞，从而提高代码质量。
代码转换和优化：编译器、解释器和其他工具（如Babel或Webpack）可以使用AST来进行代码转换和优化。这些工具可以在AST上执行各种操作，如语法转换（例如将ES6&#43;语法转换为ES5语法）、代码压缩、代码拆分和常量传播等。这有助于提高程序的性能和兼容性。
代码生成：基于AST，编译器和解释器可以生成目标代码（例如机器代码、字节码或其他编程语言的代码）。这使得跨平台编译和运行成为可能，例如：将C&#43;&#43;代码编译为WebAssembly，以便在Web浏览器中运行。
代码重构和编辑器支持：AST在代码重构和编辑器支持中也起着重要作用。通过分析和操作AST，我们可以实现自动化的代码重构、代码补全、语法高亮、错误检查等功能，从而提高开发者的生产力。
3、AST还能做什么 抽象语法树（AST）在编程语言处理、软件工程和开发工具中发挥着关键作用。除了前面讨论过的用途之外，AST还可以用于以下方面：
代码生成器：可以根据AST生成代码模板和脚手架工具。例如，根据类和方法定义生成REST API的客户端和服务器端实现。
语言转换：通过分析源语言的AST，然后将其转换为目标语言的AST，可以实现源代码到目标代码的转换。例如，将TypeScript代码转换为JavaScript代码。
代码覆盖率分析：通过分析AST，我们可以检测测试用例覆盖的代码范围，从而衡量测试质量和查找潜在的漏洞。
文档生成：AST可以用于提取源代码中的注释、类、方法和属性等信息，从而自动生成API文档。
代码安全性分析：通过分析AST，可以识别不安全的代码模式和潜在的安全漏洞，从而提高软件安全性。
代码审查：AST可以帮助自动化检查代码是否符合团队的编程规范和约定，从而提高代码质量和一致性。
依赖关系分析：通过分析AST，可以识别源代码中的模块、类和函数之间的依赖关系，从而理解代码结构和优化代码组织。
自动补全和代码导航：通过分析AST，集成开发环境（IDE）和代码编辑器可以提供自动补全、代码导航、变量重命名等智能功能，从而提高开发者的生产力。
语言扩展和领域特定语言（DSL）：AST可以用于设计和实现领域特定语言，这些语言可以更简洁地表示特定领域的问题和解决方案。例如，通过将DSL转换为目标编程语言的AST，可以生成可执行代码。
三、Python AST Python AST是Python源代码的抽象语法树表示形式。它是Python编译器在解析源代码时生成的一种数据结构，用于表示源代码的语法结构。
Python官方提供的CPython解释器对python源码的处理过程如下：
Parse source code into a parse tree (Parser/pgen.c)Transform parse tree into an Abstract Syntax Tree (Python/ast.c)Transform AST into a Control Flow Graph (Python/compile.c)Emit bytecode based on the Control Flow Graph (Python/compile.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-09T22:10:05+08:00">
    <meta property="article:modified_time" content="2024-03-09T22:10:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python-AST语法树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="一、什么是抽象语法树">一、抽象语法树</h2> 
<h3>1、什么是抽象语法树</h3> 
<p>在计算机科学中，<strong>抽象语法树</strong>（<code>abstract syntax tree</code> ，<code>AST</code>），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。AST是<strong>编译器或解释器</strong>在处理源代码时所使用的一种中间表示形式，在编译和代码生成过程中起着关键作用。</p> 
<p>之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p> 
<p>AST中的每个节点表示源代码中的一个语法构造，如变量声明、表达式、函数调用、控制结构等。<strong>树的根节点通常表示整个源代码文件，而子节点表示具体的语法元素及其关系</strong>。例如，一个函数声明的AST节点可能包含多个子节点，如函数名、参数列表和函数体等。</p> 
<h3>2、使用场景</h3> 
<p>python 和 Java 类似，解释器实际上分为两部分：编译器和虚拟机，先将代码编译成字节码，然后再由虚拟机执行。</p> 
<p></p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/21/98/6MWBFyD0_o.png" width="927"></p> 
<p> 编译器的编译过程,书中分为了6步：<strong>扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化</strong>。</p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/d1/67/i5gqZnRB_o.png" width="1024"></p> 
<ul><li><strong>词法分析：</strong>源代码可以看成字符序列，词法分析就是将源代码的字符序列分割成一系列的<strong>记号（Token，</strong>如关键字、标识符、字面量、特殊符号）<strong>。</strong>过程就是源代码程序被输入<strong>扫描器(Scanner</strong>，这里扫描器也是一个程序)，然后扫描器运用算法（如有限状态机）将字符序列分割成记号。同时扫描器会将这些记号放入一些表中。</li><li><strong>语法分析：</strong>使用<strong>语法分析器</strong>对词法分析阶段产生的记号进行语法分析，产生一棵语法树（采用上下文无关语法分析）。语法分析同时会确定符号优先级和含义，报告表达式不合法的错误等。</li><li><strong>语义分析：</strong>使用<strong>语义分析器</strong>来确定语句的语义，分为两种。静态语义：在编译期可以确定的语义，包括声明、类型匹配、类型转换。动态语义：在运行期才能确定的语义。</li><li><strong>中间语言生成（源代码优化）：</strong>编译器有很多层次的优化，对源代码级别有一个优化，使用源码级优化器。</li><li><strong>目标代码生成和优化：代码生成器</strong>将中间代码转换成目标机器代码，这个过程依赖目标机器。<strong>目标代码优化器</strong>对目标代码进行优化，如选择合适寻址方式、删除多余指令、使用位移代替乘法运算。</li></ul> 
<p>在编译时，AST主要用途包括：</p> 
<ol><li>语法检查：编译器可以通过遍历AST来检查源代码中是否存在语法错误。</li><li>语义分析：编译器可以使用AST来分析源代码的语义，例如识别类型错误、作用域错误等。</li><li>优化：编译器可以通过对AST进行变换和简化，实现源代码的优化。</li><li>代码生成：编译器可以根据AST生成目标代码，例如汇编语言或机器代码。</li></ol> 
<p>在实际应用中，AST除了用于<strong>编译器或解释器，</strong>还被用于诸如<strong>代码重构、静态分析和代码格式化</strong>等工具和技术中。</p> 
<p><strong>编译器和解释器的核心：</strong>AST是编译器和解释器处理源代码的关键数据结构。在对源代码进行语法分析之后，编译器或解释器会生成AST。接下来，它们可以在AST上进行进一步的分析、优化和代码生成。这使得编译器和解释器能够更高效地处理源代码，为生成可执行程序或执行脚本提供基础。</p> 
<p><strong>代码分析：</strong>AST在静态代码分析和静态类型检查中起着重要作用。通过分析AST，我们可以检测代码中的潜在错误、不良实践和安全漏洞，从而提高代码质量。</p> 
<p><strong>代码转换和优化：</strong>编译器、解释器和其他工具（如Babel或Webpack）可以使用AST来进行代码转换和优化。这些工具可以在AST上执行各种操作，如语法转换（例如将ES6+语法转换为ES5语法）、代码压缩、代码拆分和常量传播等。这有助于提高程序的性能和兼容性。</p> 
<p><strong>代码生成：</strong>基于AST，编译器和解释器可以生成目标代码（例如机器代码、字节码或其他编程语言的代码）。这使得跨平台编译和运行成为可能，例如：将C++代码编译为WebAssembly，以便在Web浏览器中运行。</p> 
<p><strong>代码重构和编辑器支持：</strong>AST在代码重构和编辑器支持中也起着重要作用。通过分析和操作AST，我们可以实现自动化的代码重构、代码补全、语法高亮、错误检查等功能，从而提高开发者的生产力。</p> 
<h3>3、AST还能做什么</h3> 
<p>抽象语法树（AST）在编程语言处理、软件工程和开发工具中发挥着关键作用。除了前面讨论过的用途之外，AST还可以用于以下方面：</p> 
<p><strong>代码生成器：</strong>可以根据AST生成代码模板和脚手架工具。例如，根据类和方法定义生成REST API的客户端和服务器端实现。</p> 
<p><strong>语言转换</strong>：通过分析源语言的AST，然后将其转换为目标语言的AST，可以实现源代码到目标代码的转换。例如，将TypeScript代码转换为JavaScript代码。</p> 
<p><strong>代码覆盖率分析：</strong>通过分析AST，我们可以检测测试用例覆盖的代码范围，从而衡量测试质量和查找潜在的漏洞。</p> 
<p><strong>文档生成：</strong>AST可以用于提取源代码中的注释、类、方法和属性等信息，从而自动生成API文档。</p> 
<p><span style="color:#fe2c24;"><strong>代码安全性分析</strong></span>：通过分析AST，可以识别不安全的代码模式和潜在的安全漏洞，从而提高软件安全性。</p> 
<p><strong><span style="color:#fe2c24;">代码审查：</span></strong>AST可以帮助自动化检查代码是否符合团队的编程规范和约定，从而提高代码质量和一致性。</p> 
<p><strong>依赖关系分析：</strong>通过分析AST，可以识别源代码中的模块、类和函数之间的依赖关系，从而理解代码结构和优化代码组织。</p> 
<p><strong>自动补全和代码导航：</strong>通过分析AST，集成开发环境（IDE）和代码编辑器可以提供自动补全、代码导航、变量重命名等智能功能，从而提高开发者的生产力。</p> 
<p><strong>语言扩展和领域特定语言（DSL）：</strong>AST可以用于设计和实现领域特定语言，这些语言可以更简洁地表示特定领域的问题和解决方案。例如，通过将DSL转换为目标编程语言的AST，可以生成可执行代码。</p> 
<h2>三、Python AST</h2> 
<p>Python AST是Python源代码的抽象语法树表示形式。它是Python编译器在解析源代码时生成的一种数据结构，用于表示源代码的语法结构。</p> 
<p>Python官方提供的CPython解释器对python源码的处理过程如下：</p> 
<ul><li>Parse source code into a parse tree (Parser/pgen.c)</li><li>Transform parse tree into an Abstract Syntax Tree (Python/ast.c)</li><li>Transform AST into a Control Flow Graph (Python/compile.c)</li><li>Emit bytecode based on the Control Flow Graph (Python/compile.c)</li></ul> 
<p>即实际python代码的处理过程如下：</p> 
<ul><li>源代码解析 --&gt; 语法树 --&gt; 抽象语法树(AST) --&gt; 控制流程图 --&gt; 字节码</li></ul> 
<h3>1、Python AST的基本结构</h3> 
<p>Python AST是由一系列节点（Node）组成的树形结构。每个节点代表了Python源代码中的一个语法结构，例如函数、类、变量、表达式等。每个节点都有一个类型（Type）和一些属性（Attribute），用于描述节点的语法结构和语义信息。</p> 
<p>节点可以分类为：</p> 
<ul><li>常量节点（Literals）</li><li>变量节点（Variables）</li><li>表达式节点（Expressions）</li><li>声明节点（Statements）</li><li>控制流节点（Control flow，if/for/while等）</li><li>函数和类的定义节点（Function and class definitions）</li><li>异步和等待节点（Async and await）</li><li>顶层节点（Top level nodes）</li></ul> 
<p>以下是Python AST的一些常见节点类型：</p> 
<ul><li><code>Module</code>: 代表整个Python模块。</li><li><code>FunctionDef</code>: 代表函数定义。</li><li><code>ClassDef</code>: 代表类定义。</li><li><code>Name</code>: 代表变量名。</li><li><code>Constant</code>: 代表常量。</li><li><code>BinOp</code>: 代表二元操作符表达式。</li></ul> 
<p>其余的节点类型见：<a class="link-info" href="https://docs.python.org/zh-cn/3/library/ast.html" rel="nofollow" title="ast --- 抽象语法树 — Python 3.12.1 文档">ast --- 抽象语法树 — Python 3.12.1 文档</a></p> 
<h3>2、AST模块的基本用法 </h3> 
<p>在Python中，我们可以使用ast模块提供的parse()函数将源代码解析为抽象语法树对象，并使用walk()方法遍历该对象。</p> 
<p>除了ast.dump，有很多dump ast的第三方库，如astprety，astunparse，codegen，unparse等。这些第三方库不仅能够以更好的方式展示出ast结构，还能够将ast反向导出python source代码。</p> 
<pre><code class="language-python">import ast
import astpretty

# 解析源代码，获得抽象语法树对象
ast_tree = ast.parse("print('Hello, world!')")
# 遍历抽象语法树对象
for node in ast.walk(ast_tree):
    # print(type(node).__name__)
    print("*"*66)
    astpretty.pprint(node)

</code></pre> 
<p>以上代码输出内容如下：</p> 
<pre><code class="language-python">Module(
    body=[
        Expr(
            lineno=1,
            col_offset=0,
            end_lineno=1,
            end_col_offset=22,
            value=Call(
                lineno=1,
                col_offset=0,
                end_lineno=1,
                end_col_offset=22,
                func=Name(lineno=1, col_offset=0, end_lineno=1, end_col_offset=5, id='print', ctx=Load()),
                args=[Constant(lineno=1, col_offset=6, end_lineno=1, end_col_offset=21, value='Hello, world!', kind=None)],
                keywords=[],
            ),
        ),
    ],
    type_ignores=[],
)
******************************************************************
Module(
    body=[
        Expr(
            lineno=1,
            col_offset=0,
            end_lineno=1,
            end_col_offset=22,
            value=Call(
                lineno=1,
                col_offset=0,
                end_lineno=1,
                end_col_offset=22,
                func=Name(lineno=1, col_offset=0, end_lineno=1, end_col_offset=5, id='print', ctx=Load()),
                args=[Constant(lineno=1, col_offset=6, end_lineno=1, end_col_offset=21, value='Hello, world!', kind=None)],
                keywords=[],
            ),
        ),
    ],
    type_ignores=[],
)
******************************************************************
Expr(
    lineno=1,
    col_offset=0,
    end_lineno=1,
    end_col_offset=22,
    value=Call(
        lineno=1,
        col_offset=0,
        end_lineno=1,
        end_col_offset=22,
        func=Name(lineno=1, col_offset=0, end_lineno=1, end_col_offset=5, id='print', ctx=Load()),
        args=[Constant(lineno=1, col_offset=6, end_lineno=1, end_col_offset=21, value='Hello, world!', kind=None)],
        keywords=[],
    ),
)
******************************************************************
Call(
    lineno=1,
    col_offset=0,
    end_lineno=1,
    end_col_offset=22,
    func=Name(lineno=1, col_offset=0, end_lineno=1, end_col_offset=5, id='print', ctx=Load()),
    args=[Constant(lineno=1, col_offset=6, end_lineno=1, end_col_offset=21, value='Hello, world!', kind=None)],
    keywords=[],
)
******************************************************************
Name(lineno=1, col_offset=0, end_lineno=1, end_col_offset=5, id='print', ctx=Load())
******************************************************************
Constant(lineno=1, col_offset=6, end_lineno=1, end_col_offset=21, value='Hello, world!', kind=None)
******************************************************************
Load()
</code></pre> 
<p> 以上内容是抽象语法树中的6个节点，其中，Module表示整个模块，Expr表示一个表达式，Call表示一个函数调用。那么我们可以画出来：</p> 
<pre><code class="language-python">import ast
import ctree
ast_tree = ast.parse("print('Hello, world!')")
ctree.ipython_show_ast(ast_tree)
</code></pre> 
<p><img alt="" height="553" src="https://images2.imgbox.com/d1/5e/s06FSkxO_o.png" width="354"></p> 
<p>从语法树中可以看出，该语句加载(Load())了名(Name())为print的函数接口(func)，函数传参(args)是值为’Hello, world!’(value)的常量(Constant)。 </p> 
<p>C语言分析：</p> 
<pre><code class="language-python">import ast
import ctree
from ctree.transformations import PyBasicConversions

ast_tree = ast.parse("print('Hello, world!')")
# ctree.ipython_show_ast(ast_tree)
t = PyBasicConversions()
tree2 = t.visit(ast_tree)
ctree.ipython_show_ast(tree2)</code></pre> 
<p><img alt="" height="580" src="https://images2.imgbox.com/bf/6a/6nStJjCt_o.png" width="354"></p> 
<h3 id="title-2">3、使用AST模块进行代码分析</h3> 
<p>由于AST可以表示源代码的结构，因此，我们可以结合AST模块对Python代码进行语法分析、代码检查、重构等操作。</p> 
<h4>3.1. 语法分析</h4> 
<p>我们可以使用AST模块提供的NodeVisitor类来遍历代码并进行分析。NodeVisitor是一个抽象基类，它定义了许多方法，我们只需要重写需要的方法即可。</p> 
<pre><code>import ast

class MyVisitor(ast.NodeVisitor):
    def visit_BinOp(self, node):
        print(type(node).__name__)

# 解析源代码，获得抽象语法树对象
tree = ast.parse("a + b")

# 实例化并遍历分析器
visitor = MyVisitor()
visitor.visit(tree)</code></pre> 
<p>以上代码定义了一个分析器类MyVisitor，它继承自NodeVisitor并重写了visit_BinOp方法。visit_BinOp方法指在遍历二元运算符节点时被调用，因此可以在该方法中进行具体的分析。</p> 
<h4>3.2. 代码检查</h4> 
<p>AST模块提供了许多内置函数和类，可以用于检查代码是否符合某些规范。</p> 
<pre><code>import ast

# 检查函数名是否符合规范
def check_func_name(node):
    func_name = node.name
    if not func_name.startswith("test_"):
        print(f"函数名{func_name}不符合规范！")

# 解析源代码，获得抽象语法树对象
tree = ast.parse("def test_add(a, b):\n    return a + b\n\ndef sub(a, b):\n    return a - b")

# 遍历抽象语法树对象
for node in ast.walk(tree):
    if isinstance(node, ast.FunctionDef):
        check_func_name(node)</code></pre> 
<p>以上代码定义了一个检查器函数check_func_name，它判断函数名是否以"test_"开头。在遍历抽象语法树时，如果找到了函数节点，就可以调用check_func_name进行检查。</p> 
<h4>3.3. 代码重构</h4> 
<p>代码重构是指对已有代码的结构和实现进行修改以改进代码的质量和维护性。AST模块可以帮助我们对Python代码进行重构，例如，将代码中的print语句替换为logging模块。</p> 
<pre><code>import ast

# 重构代码，将所有的print语句替换为调用logging模块
class MyTransformer(ast.NodeTransformer):
    def visit_Print(self, node):
        print_node = ast.Name(id="logging.info", ctx=ast.Load())
        args_node = [ast.Str(s="Print statement at line {0}".format(node.lineno))]
        args_node += node.values
        return ast.Expr(value=ast.Call(func=print_node, args=args_node, keywords=[]))

# 解析源代码，获得抽象语法树对象
tree = ast.parse("print('Hello, world!')\n")

# 将抽象语法树对象重构为新的语法树对象
my_transformer = MyTransformer()
new_tree = my_transformer.visit(tree)

# 使用astunparse将语法树源代码还原为字符串
import astunparse
print(astunparse.unparse(new_tree))</code></pre> 
<p>以上代码定义了一个重构器类MyTransformer，它继承自NodeTransformer并重写了visit_Print方法。visit_Print方法指在遍历print语句节点时被调用，可以在该方法中进行替换操作。</p> 
<hr> 
<h2>附：运行ctree没有结果图&amp;ctree的安装与使用</h2> 
<p>好多人问ctree的安装方式，介绍一下：</p> 
<h3>1、安装ctree</h3> 
<blockquote> 
 <p>pip install ctree</p> 
 <p></p> 
</blockquote> 
<h3>2、安装graphviz </h3> 
<blockquote> 
 <p> pip install graphviz</p> 
</blockquote> 
<p>除了安装python的graphviz ，本地还要安装Graphviz：<a class="link-info" href="https://graphviz.org/download/" rel="nofollow" title="Download | Graphviz">Download | Graphviz</a></p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/68/e0/UrzxwVLU_o.png" width="705"></p> 
<p>选择添加系统环境变量： </p> 
<p> <img alt="" height="243" src="https://images2.imgbox.com/06/72/uypUGwVt_o.png" width="496"></p> 
<p>添加不成功可以手动添加：</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/fc/57/K7MVI65K_o.png" width="528"></p> 
<p>CMD运行dot -version查看是否安装成功 ：</p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/30/81/0z8RyCuF_o.png" width="1092"></p> 
<h3>3、安装jupyter notebook</h3> 
<blockquote> 
 <p>pip install jupyter notebook</p> 
</blockquote> 
<h3>4、运行jupyter notebook</h3> 
<p> <strong>CMD输入：</strong>jupyter notebook</p> 
<p><img alt="" height="774" src="https://images2.imgbox.com/17/37/0nqVuBCS_o.png" width="1200"></p> 
<p><strong>会自动跳转到：</strong>http://localhost:8888/tree</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/d2/fc/ncZrOQwR_o.png" width="1172"><strong> 新建notebook</strong></p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/b5/79/QiqUSRNd_o.png" width="1166"></p> 
<p><strong>运行代码还是没有结果？</strong></p> 
<p><strong>修改代码：</strong></p> 
<pre><code class="language-python">D:\Program Files\anaconda3\Lib\site-packages\ctree\visual/dot_manager.py
</code></pre> 
<p> <strong>注释如下代码：</strong><img alt="" height="340" src="https://images2.imgbox.com/68/8a/PUOFG72N_o.png" width="759"></p> 
<p><strong>再次重新运行jupyter notebook--&gt;新建notebook--&gt;运行代码</strong></p> 
<p><img alt="" height="854" src="https://images2.imgbox.com/f1/e1/3Je5E1BO_o.png" width="1174"></p> 
<p>OK！！！！！！ </p> 
<hr> 
<p>参考：</p> 
<p><a href="https://zhuanlan.zhihu.com/p/621016342" rel="nofollow" title="你知道什么是AST语法树嘛？你真的了解AST语法树嘛？读到最后你将对AST语法树有新的认识！ - 知乎">你知道什么是AST语法树嘛？你真的了解AST语法树嘛？读到最后你将对AST语法树有新的认识！ - 知乎</a></p> 
<p><a href="https://docs.python.org/zh-cn/3/library/ast.html" rel="nofollow" title="ast --- 抽象语法树 — Python 3.12.1 文档">ast --- 抽象语法树 — Python 3.12.1 文档</a></p> 
<p><a href="https://pythonjishu.com/kylcsgnoparhtuh/" rel="nofollow" title="Python Ast抽象语法树的介绍及应用详解 - Python技术站">Python Ast抽象语法树的介绍及应用详解 - Python技术站</a></p> 
<p><a href="https://www.cnblogs.com/qiulinzhang/p/14258626.html" rel="nofollow" title="https://www.cnblogs.com/qiulinzhang/p/14258626.html">https://www.cnblogs.com/qiulinzhang/p/14258626.html</a></p> 
<p><a href="https://www.python100.com/html/L1X6DO22JA94.html" rel="nofollow" title="Python中ast模块是什么？_笔记大全_设计学院">Python中ast模块是什么？_笔记大全_设计学院</a></p> 
<p><a href="https://blog.csdn.net/guozhibin123/article/details/128234702" title="【python】ast模块介绍和使用_import ast-CSDN博客">【python】ast模块介绍和使用_import ast-CSDN博客</a></p> 
<p><a href="https://xie.infoq.cn/article/250ae7febfaf2b5be0a69bd6a" rel="nofollow" title="不要再手动批量替换了，使用python AST模块批量替换_Python_阿呆_InfoQ写作社区">不要再手动批量替换了，使用python AST模块批量替换_Python_阿呆_InfoQ写作社区</a></p> 
<p><a href="https://www.cnblogs.com/yssjun/p/10069199.html" rel="nofollow" title="https://www.cnblogs.com/yssjun/p/10069199.html">https://www.cnblogs.com/yssjun/p/10069199.html</a></p> 
<p><a href="https://blog.51cto.com/u_16175461/6848482" rel="nofollow" title="python语法树可视化_mob649e815b1a71的技术博客_51CTO博客">python语法树可视化_mob649e815b1a71的技术博客_51CTO博客</a></p> 
<p><a href="https://www.python100.com/html/L1X6DO22JA94.html" rel="nofollow" title="Python中ast模块是什么？_笔记大全_设计学院">Python中ast模块是什么？_笔记大全_设计学院</a></p> 
<p><a href="https://www.cnblogs.com/qiulinzhang/p/14258626.html" rel="nofollow" title="https://www.cnblogs.com/qiulinzhang/p/14258626.html">https://www.cnblogs.com/qiulinzhang/p/14258626.html</a></p> 
<p><a href="https://blog.csdn.net/yntantan/article/details/127558380" title="python 可视化AST、CFG学习_python显示ast树形状-CSDN博客">python 可视化AST、CFG学习_python显示ast树形状-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/guozhibin123/article/details/128234702" title="【python】ast模块介绍和使用_import ast-CSDN博客">【python】ast模块介绍和使用_import ast-CSDN博客</a></p> 
<p><a href="https://ucb-sejits.github.io/ctree-docs/ipythontips.html" rel="nofollow" title="Using IPython for AST Visualization — ctree alpha documentation">Using IPython for AST Visualization — ctree alpha documentation</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58401db4a6c2391416a8ae791055d9dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人工智能如何发展到AIGC？解密一份我四年前写的机器学习分享材料</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6155b3706366cab48c276c218ca93ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">macOS上实现「灵动岛」效果</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>