<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自动驾驶入门算法lattice planner介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6ad90e3030baa8e35a9fa14e08cd2369/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="自动驾驶入门算法lattice planner介绍">
  <meta property="og:description" content="今天带大家了解一下Lattice planner自动驾驶避障算法，让喜欢自动驾驶的同学可以有个初步了解，并介绍一下CARLA仿真模拟器，没有实车也可以进行自动驾驶的研究。
算法结果展示 首先Carla lattice planner是一种用于自动驾驶的路径规划算法。它基于lattice-based motion planning方法，可以生成连续的、光滑的轨迹，以应对复杂的交通环境和不同的行驶场景。相比于传统的A*和Dijkstra等搜索算法，lattice planner可以更好地处理高维状态空间，并且可以通过自定义cost function来灵活控制路径规划的优化目标。
话不多说，先给各位上个视频
CARLA避障算法
Lattice planner算法简介 除此之外，Carla lattice planner还具有以下特点：
1.基于采样的方法生成可行的轨迹，可以较好地处理障碍物和限制条件。
2.采用基于状态的代价映射方法，可以有效避免路径重复和锯齿状路径。
3.支持多目标、多车道、多速度等复杂场景下的路径规划。
Lattice planner 是一种基于图论和搜索算法的路径规划方法，与传统算法相比，它具有几个优势：
高效性： Lattice planner 通常能够在复杂环境中快速生成高质量的路径。它利用了图论中的一些高效算法，如 A* 算法等，以及搜索空间的结构化表示，这使得它在计算上更为高效。 适应性： Lattice planner 能够适应不同类型的环境和车辆动力学模型。通过调整参数和优化策略，它可以应对不同的车辆行驶条件，如高速公路、城市街道或者复杂的障碍物环境。 全局规划能力： Lattice planner 能够考虑到全局路径规划的因素，而不仅仅是局部路径规划。它能够在整个地图范围内搜索最优路径，并且通常能够保证路径的全局最优性。 障碍物避让： Lattice planner 在路径生成过程中能够有效地避开障碍物。它通过搜索空间中的合法节点，并考虑到障碍物的影响，生成可行的路径。 轨迹优化： 除了路径规划，Lattice planner 还可以与轨迹优化方法结合，生成更加平滑和符合车辆动力学特性的行驶轨迹。 总的来说，Lattice planner 结合了图论、搜索算法和车辆动力学模型，能够在复杂的环境中生成高效、安全的路径，因此在自动驾驶和机器人导航等领域得到了广泛的应用。
对此我对lattice planner进行了简化，可供在CARLA中进行避障，并与基于规则的自动驾驶决策算法结合。
CARLA仿真模拟器简介 Carla是一款开源的城市驾驶模拟器，专为自动驾驶系统的研究、开发和测试而设计。以下是关于Carla的详细介绍：
基本架构：Carla采用Client-Server的交互形式，其中服务器负责模拟环境，客户端则用于发送控制命令并接收传感器数据。这种架构允许用户在仿真环境中测试和训练自动驾驶算法。
核心模块：Carla支持多种自动驾驶系统的开发方法，包括经典模块化方法、端到端的模仿学习和强化学习方法。这些方法涵盖了从感知、规划到控制的各个环节。
环境模拟：基于Unreal Engine 4，Carla能够提供高度真实的3D城市场景，包括详细的建筑物、车辆、行人、交通标志等静态和动态物体。它还能够模拟不同的天气和时间条件，为自动驾驶系统提供丰富的测试环境。
传感器支持：Carla支持灵活配置的传感器套件，包括但不限于GPS、速度计、加速度计以及各种视觉和雷达传感器。这些传感器数据可以用于训练和验证自动驾驶策略。
平台兼容性：Carla可以在Linux和Windows操作系统上安装和使用，提供了Python API以便于开发者进行编程和接口操作。
社区资源：Carla拥有一个活跃的社区和丰富的文档资源，用户可以通过官方文档和社区分享来获取帮助和学习如何使用这个平台。
代码示例讲解 首先automatic control主要用于对接carla仿真服务器，进行车辆的播撒，天气的改变，全局路径的规划。
class World(object) #世界的设置 class KeyboardControl(object)# 键盘控制车辆 class HUD(object)#车辆信息通过最下面一行进行显示，可以辅助显示当前车辆行为或者状态 class CollisionSensor(object)#碰撞检测传感器 class LaneInvasionSensor(object)#越线检测传感器，检测是否压线等 class GnssSensor(object)#定位传感器，记录车辆行驶轨迹 class CameraManager(object)#车载前视摄像头 class Game(object)#车辆从起始到最终的整个循环 def main()#初始配置设置，定义了服务器ip地址，起点坐标、世界天气、障碍车数量以及位置等用于环境搭建的初始化信息 同所有代码一样">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-20T22:47:13+08:00">
    <meta property="article:modified_time" content="2024-05-20T22:47:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自动驾驶入门算法lattice planner介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天带大家了解一下Lattice planner自动驾驶避障算法，让喜欢自动驾驶的同学可以有个初步了解，并介绍一下CARLA仿真模拟器，没有实车也可以进行自动驾驶的研究。</p> 
<h2><a id="_1"></a>算法结果展示</h2> 
<p>首先Carla lattice planner是一种用于自动驾驶的路径规划算法。它基于lattice-based motion planning方法，可以生成连续的、光滑的轨迹，以应对复杂的交通环境和不同的行驶场景。相比于传统的A*和Dijkstra等搜索算法，lattice planner可以更好地处理高维状态空间，并且可以通过自定义cost function来灵活控制路径规划的优化目标。<br> 话不多说，先给各位上个视频</p> 
<p></p> 
<div class="csdn-video-box"> 
 <iframe id="UrifUIsi-1716214042248" frameborder="0" src="https://live.csdn.net/v/embed/387345" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>CARLA避障算法</p> 
</div> 
<p></p> 
<h2><a id="Lattice_planner_7"></a>Lattice planner算法简介</h2> 
<p>除此之外，Carla lattice planner还具有以下特点：</p> 
<p>1.基于采样的方法生成可行的轨迹，可以较好地处理障碍物和限制条件。<br> 2.采用基于状态的代价映射方法，可以有效避免路径重复和锯齿状路径。<br> 3.支持多目标、多车道、多速度等复杂场景下的路径规划。<br> <img src="https://images2.imgbox.com/52/ac/iAQuBOtd_o.png" alt="lattice planner"><br> Lattice planner 是一种基于图论和搜索算法的路径规划方法，与传统算法相比，它具有几个优势：</p> 
<pre><code>高效性： Lattice planner 通常能够在复杂环境中快速生成高质量的路径。它利用了图论中的一些高效算法，如 A* 算法等，以及搜索空间的结构化表示，这使得它在计算上更为高效。

适应性： Lattice planner 能够适应不同类型的环境和车辆动力学模型。通过调整参数和优化策略，它可以应对不同的车辆行驶条件，如高速公路、城市街道或者复杂的障碍物环境。

全局规划能力： Lattice planner 能够考虑到全局路径规划的因素，而不仅仅是局部路径规划。它能够在整个地图范围内搜索最优路径，并且通常能够保证路径的全局最优性。

障碍物避让： Lattice planner 在路径生成过程中能够有效地避开障碍物。它通过搜索空间中的合法节点，并考虑到障碍物的影响，生成可行的路径。

轨迹优化： 除了路径规划，Lattice planner 还可以与轨迹优化方法结合，生成更加平滑和符合车辆动力学特性的行驶轨迹。
</code></pre> 
<p>总的来说，Lattice planner 结合了图论、搜索算法和车辆动力学模型，能够在复杂的环境中生成高效、安全的路径，因此在自动驾驶和机器人导航等领域得到了广泛的应用。<br> 对此我对lattice planner进行了简化，可供在CARLA中进行避障，并与基于规则的自动驾驶决策算法结合。</p> 
<h2><a id="CARLA_29"></a>CARLA仿真模拟器简介</h2> 
<p>Carla是一款开源的城市驾驶模拟器，专为自动驾驶系统的研究、开发和测试而设计。以下是关于Carla的详细介绍：</p> 
<p>基本架构：Carla采用Client-Server的交互形式，其中服务器负责模拟环境，客户端则用于发送控制命令并接收传感器数据。这种架构允许用户在仿真环境中测试和训练自动驾驶算法。<br> 核心模块：Carla支持多种自动驾驶系统的开发方法，包括经典模块化方法、端到端的模仿学习和强化学习方法。这些方法涵盖了从感知、规划到控制的各个环节。<br> 环境模拟：基于Unreal Engine 4，Carla能够提供高度真实的3D城市场景，包括详细的建筑物、车辆、行人、交通标志等静态和动态物体。它还能够模拟不同的天气和时间条件，为自动驾驶系统提供丰富的测试环境。<br> 传感器支持：Carla支持灵活配置的传感器套件，包括但不限于GPS、速度计、加速度计以及各种视觉和雷达传感器。这些传感器数据可以用于训练和验证自动驾驶策略。<br> 平台兼容性：Carla可以在Linux和Windows操作系统上安装和使用，提供了Python API以便于开发者进行编程和接口操作。<br> 社区资源：Carla拥有一个活跃的社区和丰富的文档资源，用户可以通过官方文档和社区分享来获取帮助和学习如何使用这个平台。</p> 
<h2><a id="_38"></a>代码示例讲解</h2> 
<p><img src="https://images2.imgbox.com/cc/20/i4iza4jg_o.png" alt="整个避障算法主要包括这四个文件"><br> 首先automatic control主要用于对接carla仿真服务器，进行车辆的播撒，天气的改变，全局路径的规划。</p> 
<pre><code>class World(object) #世界的设置
class KeyboardControl(object)# 键盘控制车辆
class HUD(object)#车辆信息通过最下面一行进行显示，可以辅助显示当前车辆行为或者状态
class CollisionSensor(object)#碰撞检测传感器
class LaneInvasionSensor(object)#越线检测传感器，检测是否压线等
class GnssSensor(object)#定位传感器，记录车辆行驶轨迹
class CameraManager(object)#车载前视摄像头
class Game(object)#车辆从起始到最终的整个循环
def main()#初始配置设置，定义了服务器ip地址，起点坐标、世界天气、障碍车数量以及位置等用于环境搭建的初始化信息
</code></pre> 
<p>同所有代码一样<br> 先从main开始看，main定义了Carla服务器ip、车辆起始位置等信息，比较简单所以我简略说明一下。</p> 
<pre><code>#配合界面的改动
    # 加载IP端口数据
    with open('/home/linux/PythonAPI/parameters_json/IP.json', 'r') as f:
        host = json.load(f)
    with open('/home/linux/PythonAPI/parameters_json/Behavior.json', 'r') as f:
        Behavior = json.load(f)
    with open('/home/linux/PythonAPI/parameters_json/start.json', 'r') as f:
        start = json.load(f)
    with open('/home/linux/PythonAPI/parameters_json/destion.json', 'r') as f:
        destion = json.load(f)
    argparser = argparse.ArgumentParser(
        description='CARLA Automatic Control Client')
    argparser.add_argument(
        '-v', '--verbose',
        action='store_true',
        dest='debug',
        help='Print debug information')
    argparser.add_argument(
        '--host',
        metavar='H',
        # default='127.0.0.1',
        default=host['IP'],
        #default='192.168.31.29',
        help='IP of the host server (default: 127.0.0.1)')
</code></pre> 
<p>这里呢，我是便于更改配置文件，用json文件形式将ip地址，车辆行为，目的地以及起始位置通过json格式文件存储，当代码开始运行后，读取本地json文件信息，获取起始、终点位置等信息，agrparse是参数化的结构体，用于储存配置信息，方便调用。</p> 
<pre><code>game = Game()
    try:
        
        game.game_loop(args)

    except KeyboardInterrupt:
        print('\nCancelled by user. Bye!')
</code></pre> 
<p>配置文件加载完就可以进行自动驾驶了，这里采用循环的方式进行，你可以设置循环次数，车辆到达目的地后可以再次随机选择地图上的目的地进行连续的驾驶任务，否则就将退出。这里用try语句是开始运行后，你可以按键盘ctrl 和c 键安全的退出程序，为什么这样呢，因为这里是与服务器进行联合调试的，若突然中断进程，服务器里面的车辆会还存在，导致服务器中的世界混乱，因此采用此种方式。<br> 这就是第一个文件的大致思路。</p> 
<h2><a id="local_planner_94"></a>local planner</h2> 
<p>接下来看一看局部规划，local planner，这篇文章有些长了可以看下一篇。<br> 未完待续…</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d674b10f7daee8be9843e8ba5fb11aa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI积累-CPU（中央处理单元）和GPU（图形处理单元）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38dab102d6dee3218fd8d3092c2e20f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL详细安装、配置过程，多图，详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>