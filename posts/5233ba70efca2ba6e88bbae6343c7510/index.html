<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DOM Clobbring个人理解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5233ba70efca2ba6e88bbae6343c7510/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="DOM Clobbring个人理解">
  <meta property="og:description" content="目录
toString
One Level
Two Level
Three Level
More
Dom Clobbering：就是⼀种将 HTML 代码注⼊⻚⾯中以操纵 DOM 并最终更改⻚⾯上 JavaScript ⾏为的技术
DOM Clobbering中的操作也是根据JavaScript行为的层级来分为一层、两层、三层和更多
toString 我们通过以下代码进行fuzz去获取可以通过toString方法将转换成字符串的标签。这些标签的属性值是能够控制的，因此我们也就不再是获取无用的标签了，而是变成了获取到我们想要的字符串
Object.getOwnPropertyNames(window) .filter(p =&gt; p.match(/Element$/)) .map(p =&gt; window[p]) .filter(p =&gt; p &amp;&amp; p.prototype &amp;&amp; p.prototype.toString !== Object.prototype.toString) 这段代码主要是对 window 对象的属性进行一系列操作：
Object.getOwnPropertyNames(window) 获取 window 对象的所有自身属性的名称。然后通过 filter 方法筛选出名称以 Element$ 结尾的属性。接着通过 map 方法将这些属性对应的值提取出来。最后再通过 filter 方法进一步筛选出那些值存在且有原型且原型的 toString 方法不同于 Object.prototype.toString 的元素。 我们得到了两种标签对象：HTMLAreaElement（&lt;area&gt;）&amp;HTMLAnchorElement（&lt;a&gt;），这两个标签对象，我们都可以利用href属性来进行字符串转换
One Level 当JavaScript的行为只有一层时，只需要简单的使用id或name属性来定义该名称，即可在JavaScript进行执行时对该变量覆盖，如
Two Level 当JavaScript的行为为两层时，需要两层嵌套才能覆盖
需要注意：内外层使用id还是name，需要取决标签之间的层级关系
在双id属性的情况下，可以使用以下来嵌套双层标签：
form-&gt;buttonform-&gt;fieldsetform-&gt;imageform-&gt;imgform-&gt;inputform-&gt;objectform-&gt;output var log=[]; var html = [&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-17T23:17:13+08:00">
    <meta property="article:modified_time" content="2024-08-17T23:17:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DOM Clobbring个人理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="cDf7k-toc" style="margin-left:0px;"><a href="#cDf7k" rel="nofollow">toString</a></p> 
<p id="wCP4G-toc" style="margin-left:0px;"><a href="#wCP4G" rel="nofollow">One Level</a></p> 
<p id="wU9Ws-toc" style="margin-left:0px;"><a href="#wU9Ws" rel="nofollow">Two Level</a></p> 
<p id="l7X8x-toc" style="margin-left:0px;"><a href="#l7X8x" rel="nofollow">Three Level</a></p> 
<p id="S6hr7-toc" style="margin-left:0px;"><a href="#S6hr7" rel="nofollow">More</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p id="u4b463265"><strong>Dom Clobbering：</strong>就是⼀种将 HTML 代码注⼊⻚⾯中以操纵 DOM 并最终更改⻚⾯上 JavaScript ⾏为的技术</p> 
<p id="u6f1ffc0c">DOM Clobbering中的操作也是根据JavaScript行为的层级来分为一层、两层、三层和更多</p> 
<h2 id="cDf7k">toString</h2> 
<p id="u9a51a5ac">我们通过以下代码进行fuzz去获取可以通过toString方法将转换成字符串的标签。这些标签的属性值是能够控制的，因此我们也就不再是获取无用的标签了，而是变成了获取到我们想要的字符串</p> 
<pre id="sXfPG"><code>    Object.getOwnPropertyNames(window)
    .filter(p =&gt; p.match(/Element$/))
    .map(p =&gt; window[p])
    .filter(p =&gt; p &amp;&amp; p.prototype &amp;&amp; p.prototype.toString 
    !== Object.prototype.toString)</code></pre> 
<p id="ub2c74fb1">这段代码主要是对 <code>window</code> 对象的属性进行一系列操作：</p> 
<ul><li id="u540234d7"><code>Object.getOwnPropertyNames(window)</code> 获取 <code>window</code> 对象的所有自身属性的名称。</li><li id="u9c717e87">然后通过 <code>filter</code> 方法筛选出名称以 <code>Element$</code> 结尾的属性。</li><li id="ue4cb6c6f">接着通过 <code>map</code> 方法将这些属性对应的值提取出来。</li><li id="u609edec3">最后再通过 <code>filter</code> 方法进一步筛选出那些值存在且有原型且原型的 <code>toString</code> 方法不同于 <code>Object.prototype.toString</code> 的元素。</li></ul> 
<p id="uc5c63ffa"></p> 
<p class="img-center"><img alt="" height="120" id="ufdb7b814" src="https://images2.imgbox.com/0e/8e/ZulvlcS4_o.png" width="361"></p> 
<p id="ue85f8894">我们得到了两种标签对象：HTMLAreaElement（&lt;area&gt;）&amp;HTMLAnchorElement（&lt;a&gt;），这两个标签对象，我们都可以利用<code>href</code>属性来进行字符串转换</p> 
<p id="ued506f77"></p> 
<p class="img-center"><img alt="" height="156" id="u700008b1" src="https://images2.imgbox.com/24/cc/9tKJKIgL_o.png" width="371"></p> 
<p id="u01f7adc6"></p> 
<p class="img-center"><img alt="" height="256" id="u44085385" src="https://images2.imgbox.com/2e/f9/XmLhOYNR_o.png" width="921"></p> 
<h2 id="wCP4G">One Level</h2> 
<p id="u232cbe0d"><strong>当JavaScript的行为只有一层时</strong>，只需要简单的使用id或name属性来定义该名称，即可在JavaScript进行执行时对该变量覆盖，如</p> 
<p id="u278a6b57"></p> 
<p class="img-center"><img alt="" height="79" id="sDqGu" src="https://images2.imgbox.com/19/62/EfDyKYJi_o.png" width="297"></p> 
<p id="u278a6b57"></p> 
<p class="img-center"><img alt="" height="63" id="hXZHP" src="https://images2.imgbox.com/85/4b/NmtGDVzN_o.png" width="299"></p> 
<h2 id="wU9Ws">Two Level</h2> 
<p id="u45aef96a"><strong>当JavaScript的行为为两层时</strong>，需要两层嵌套才能覆盖</p> 
<p id="ucd39473c"></p> 
<p class="img-center"><img alt="" height="151" id="lyOKn" src="https://images2.imgbox.com/0b/f6/8T1WTWHv_o.png" width="797"></p> 
<p id="u7848ff74"><strong>需要注意：</strong>内外层使用id还是name，需要取决标签之间的层级关系</p> 
<p id="u2f6e9245">在双id属性的情况下，可以使用以下来嵌套双层标签：</p> 
<ul><li id="u4769ea45">form-&gt;button</li><li id="ufed4255b">form-&gt;fieldset</li><li id="ufff80df5">form-&gt;image</li><li id="u529b8d96">form-&gt;img</li><li id="ubfe9e000">form-&gt;input</li><li id="u8fef7848">form-&gt;object</li><li id="uc8961cd0">form-&gt;output</li></ul> 
<pre id="Xx4Rb"><code>var log=[];
var html = ["a","abbr","acronym","address","applet","area","article","aside","audio","b",
						"base","basefont","bdi","bdo","bgsound","big","blink","blockquote","body","br"
						,"button","canvas","caption","center","cite","code","col","colgroup","command"
						,"content","data","datalist","dd","del","details","dfn","dialog","dir","div",
						"dl","dt","element","em","embed","fieldset","figcaption","figure","font","footer"
						,"form","frame","frameset","h1","head","header","hgroup","hr","html","i","iframe"
						,"image","img","input","ins","isindex","kbd","keygen","label","legend","li","link"
						,"listing","main","map","mark","marquee","menu","menuitem","meta","meter","multicol"
						,"nav","nextid","nobr","noembed","noframes","noscript","object","ol","optgroup",
						"option","output","p","param","picture","plaintext","pre","progress","q","rb","rp"
						,"rt","rtc","ruby","s","samp","script","section","select","shadow","slot","small"
						,"source","spacer","span","strike","strong","style","sub","summary","sup","svg",
						"table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr",
						"track","tt","u","ul","var","video","wbr","xmp "], logs = [];
div=document.createElement('div'); 
for(var i=0;i&lt;html.length;i++){
	for(var j=0;j&lt;html.length;j++) {
		div.innerHTML='&lt;'+html[i]+' id=element1&gt;'+'&lt;'+html[j]+'id=element2&gt;'; 
		document.body.appendChild(div);
		if(window.element1 &amp;&amp; element1.element2){ 
			log.push(html[i]+','+html[j]);
		}
		document.body.removeChild(div);
	}
}
console.log(log.join('\n'));</code></pre> 
<p id="u86aa4621">可以修改代码去获取id和name之间标签的层级关系</p> 
<h2 id="l7X8x">Three Level</h2> 
<p id="u02e676d7"><strong>当JavaScript的行为为三层时</strong>，需要构造同名称的同级标签，在其中一同级目录标签同时具有<code>id</code>和<code>name</code>属性，然后在其中再嵌套一个子标签。</p> 
<p id="u3de40815"></p> 
<p class="img-center"><img alt="" height="176" id="ken84" src="https://images2.imgbox.com/34/65/xXeafj72_o.png" width="748"></p> 
<p id="u3ca7fd66">这样在定位<code>x</code>时，返回是数组，即<code>HTMLCollection</code>。<code>HTMLCollection</code>是可以通过<code>name</code>作为索引进行查找的。所以<code>x.y</code>才会定位到第一个form标签。所以当定位到<code>z</code>时，就成功为三层了。</p> 
<p id="u84c4b39c"></p> 
<p class="img-center"><img alt="" height="357" id="JhUtD" src="https://images2.imgbox.com/50/81/tltb1sLF_o.png" width="547"></p> 
<h2 id="S6hr7">More</h2> 
<p id="u35c979ed">三层以上的层级，需要用到<code>iframe</code>与<code>srcdoc</code>来配合使用</p> 
<pre id="pnVQo"><code>&lt;body&gt;
    &lt;iframe name=a srcdoc="&lt;iframe name=b srcdoc='&lt;a id=c name=d href=cid:Clobbered&gt;&lt;/a&gt;&lt;a id=c&gt;' &gt;"&gt;
    &lt;/iframe&gt;
    &lt;script&gt;setTimeout(()=&gt;alert(a.b.c.d),500)&lt;/script&gt;
&lt;/body&gt;</code></pre> 
<p id="u56975295">因为需要等待所有的<code>iframe</code>加载完毕我们才能获得这个层级关系，所以需要⽤到延时，不⽤延时也可以通过⽹络请求来进⾏延缓</p> 
<pre id="hjA07"><code>&lt;iframe name=a srcdoc="
&lt;iframe srcdoc='&lt;a id=c name=d href=cid:Clobbered&gt;test&lt;/a&gt;&lt;a id=c&gt;' name=b&gt;"&gt;
&lt;/iframe&gt;
&lt;style&gt;@import 'http://example.com';&lt;/style&gt;
&lt;script&gt; 
alert(a.b.c.d)
&lt;/script&gt;</code></pre> 
<p id="ubf25ae63"><strong>需要注意：</strong>如果没有延时或者延缓，可能会导致<code>iframe</code>加载不全，导致undefined</p> 
<p id="u51bdee6e">只使用<code>a</code>返回的是最外层<code>iframe</code>标签的<code>srcdoc</code>属性，<code>a.b</code>返回内层<code>iframe</code>标签的<code>srcdoc</code>属性，到<code>a.b.c</code>时，返回的才是<code>HTMLCollection</code></p> 
<p id="u2d7fa4c3">最内层的标签也可以转换成form标签和output标签的嵌套</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4dee7e0e3f252a9ad3d9c9fb162f495c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ruby在嵌入式系统：轻量级语言的灵活应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c07c19468ea77bd06a946f5ee32ca829/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中的经典排序算法：插入排序、希尔排序、选择排序、堆排序与冒泡排序（如果想知道Java中有关插入排序、希尔排序、选择排序、堆排序与冒泡排序的知识点，那么只看这一篇就足够了！）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>