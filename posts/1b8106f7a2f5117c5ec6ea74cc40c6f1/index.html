<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>利用C&#43;&#43;与Python调用千帆免费大模型，构建个性化AI对话系统 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1b8106f7a2f5117c5ec6ea74cc40c6f1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="利用C&#43;&#43;与Python调用千帆免费大模型，构建个性化AI对话系统">
  <meta property="og:description" content="千帆大模型已于2024年4月25日正式免费，调用这个免费的模型以实现自己的AI对话功能，遵循以下步骤：
了解千帆大模型： 千帆大模型是百度智能云推出的一个平台，提供了一系列AI能力和工具，用于快速开发和应用AI技术。该平台提供了从数据管理、数据标注、模型开发、模型纳管到部署上线的全生命周期AI能力研发与应用管理服务。
注册与登录： 如果已经是开发者，可以直接登录百度智能云千帆大模型平台。如果没有账号，需要先进行注册，并按照提示完成账号的创建和登录。
数据准备： 在开始之前，需要准备用于训练和测试的数据。这些数据应该包含对话的输入和期望的输出。千帆大模型平台支持多种数据格式和导入方式，可以根据实际情况选择合适的方式进行数据导入。
数据标注： 对于导入的数据，需要进行标注，以便模型能够理解和学习对话的模式和规则。在千帆大模型平台上，可以使用平台提供的工具进行数据的标注工作。
模型训练： 在完成数据标注后，可以使用千帆大模型平台提供的工具进行模型的训练。训练过程中，可以根据需要调整模型的参数和配置，以获得更好的对话效果。
模型评估与优化： 训练完成后，可以对模型进行评估，查看其在测试数据上的表现。如果模型的表现不佳，可以根据评估结果进行模型的优化和调整。
部署与测试： 当模型训练和优化完成后，可以将其部署到千帆大模型平台上，并进行实际的测试。通过与模型进行对话，验证模型的性能和效果，并根据需要进行进一步的调整和优化。
集成与应用： 如果模型的表现符合预期，可以将其集成到自己的应用中，实现自己的AI对话功能。在集成过程中，需要注意与千帆大模型平台的接口和协议进行匹配和对接。需要注意的是，虽然千帆大模型已经免费，但在使用过程中可能会产生一些额外的费用，如数据存储、计算资源等。因此，在使用之前需要了解平台的收费标准和计费方式，以便做好预算和规划。
python实现与千帆大模型交互 import sys
sys.path.append(r&#39;C:\Users\XXX\AppData\Local\Programs\Python\Python312-32\Lib\site-packages&#39;)
import requests
import json
def getcookies(): url = &#34; https://aip.baidubce.com/oauth/2.0/token&#34; params = { &#39;grant_type&#39;: &#39;client_credentials&#39;, &#39;client_id&#39;:&#39;4O0GgKpCfUT5mxZ4s3f&#39;, # 替换为你的客户端ID &#39;client_secret&#39;: &#39;RKETeu3iLn4YbCclMUei21ZVVnD6Y&#39; # 替换为你的客户端密钥 } headers = { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Accept&#39;: &#39;application/json&#39; } response = requests.post(url, params=params, headers=headers) if response.status_code == 200: data = response.json() if&#39;access_token&#39; in data: print(data[&#39;access_token&#39;])
return data[&#39;access_token&#39;] else: print(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-29T19:07:59+08:00">
    <meta property="article:modified_time" content="2024-05-29T19:07:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">利用C&#43;&#43;与Python调用千帆免费大模型，构建个性化AI对话系统</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>千帆大模型已于2024年4月25日正式免费，调用这个免费的模型以实现自己的AI对话功能，遵循以下步骤：</p> 
<h2>了解千帆大模型：</h2> 
<p>千帆大模型是百度智能云推出的一个平台，提供了一系列AI能力和工具，用于快速开发和应用AI技术。该平台提供了从数据管理、数据标注、模型开发、模型纳管到部署上线的全生命周期AI能力研发与应用管理服务。</p> 
<h2>注册与登录：</h2> 
<p>如果已经是开发者，可以直接登录百度智能云千帆大模型平台。如果没有账号，需要先进行注册，并按照提示完成账号的创建和登录。</p> 
<h2>数据准备：</h2> 
<p>在开始之前，需要准备用于训练和测试的数据。这些数据应该包含对话的输入和期望的输出。千帆大模型平台支持多种数据格式和导入方式，可以根据实际情况选择合适的方式进行数据导入。</p> 
<h2>数据标注：</h2> 
<p>对于导入的数据，需要进行标注，以便模型能够理解和学习对话的模式和规则。在千帆大模型平台上，可以使用平台提供的工具进行数据的标注工作。</p> 
<h2>模型训练：</h2> 
<p>在完成数据标注后，可以使用千帆大模型平台提供的工具进行模型的训练。训练过程中，可以根据需要调整模型的参数和配置，以获得更好的对话效果。</p> 
<h2>模型评估与优化：</h2> 
<p>训练完成后，可以对模型进行评估，查看其在测试数据上的表现。如果模型的表现不佳，可以根据评估结果进行模型的优化和调整。</p> 
<h2>部署与测试：</h2> 
<p>当模型训练和优化完成后，可以将其部署到千帆大模型平台上，并进行实际的测试。通过与模型进行对话，验证模型的性能和效果，并根据需要进行进一步的调整和优化。</p> 
<h2>集成与应用：</h2> 
<p>如果模型的表现符合预期，可以将其集成到自己的应用中，实现自己的AI对话功能。在集成过程中，需要注意与千帆大模型平台的接口和协议进行匹配和对接。需要注意的是，虽然千帆大模型已经免费，但在使用过程中可能会产生一些额外的费用，如数据存储、计算资源等。因此，在使用之前需要了解平台的收费标准和计费方式，以便做好预算和规划。</p> 
<h2>python实现与千帆大模型交互</h2> 
<p>import sys</p> 
<p>sys.path.append(r'C:\Users\XXX\AppData\Local\Programs\Python\Python312-32\Lib\site-packages')</p> 
<p>import requests</p> 
<p>import json</p> 
<p>def getcookies():  </p> 
<p>  url = " https://aip.baidubce.com/oauth/2.0/token"  </p> 
<p>  params = {  </p> 
<p>      'grant_type': 'client_credentials',  </p> 
<p>      'client_id':'4O0GgKpCfUT5mxZ4s3f',  # 替换为你的客户端ID  </p> 
<p>      'client_secret': 'RKETeu3iLn4YbCclMUei21ZVVnD6Y' # 替换为你的客户端密钥  </p> 
<p>    }  </p> 
<p>  headers = {  </p> 
<p>      'Content-Type': 'application/x-www-form-urlencoded',  </p> 
<p>      'Accept': 'application/json'  </p> 
<p>    }  </p> 
<p>     </p> 
<p>  response = requests.post(url, params=params, headers=headers)  </p> 
<p>  if response.status_code == 200:  </p> 
<p>      data = response.json()  </p> 
<p>      if'access_token' in data:  </p> 
<p>          print(data['access_token'])</p> 
<p>          return data['access_token']  </p> 
<p>      else:  </p> 
<p>          print("服务器响应中未找到 access_token")  </p> 
<p>          return None  </p> 
<p>  else:  </p> 
<p>      print(f"请求失败，状态码：{response.status_code}")  </p> 
<p>      returnNone</p> 
<p>   </p> 
<p>def getvalue(content, token):  </p> 
<p>  token = getcookies()        </p> 
<p>#如果成功获取的token格式如下，一个月获取一次</p> 
<p> # token = "24.0a2e1101e19ebe5e500a0962b30468fb.2592000.1700073516.282335-70004478"</p> 
<p>  url = " https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/ernie-speed-128k?access_token=" + token</p> 
<p>  #content为填充的润色语句，要求可以自行改进</p> 
<p>  payload = json.dumps({<!-- --></p> 
<p>      "messages": [</p> 
<p>            {    </p> 
<p>              "content": "原文内容:{<!-- -->{" + content + "}}\</p> 
<p>要求：\</p> 
<p>1. 使用更专业与精准的词汇，提取关键内容，重构文本表达更加简洁、准确和有层次。\</p> 
<p>2. 调整结构顺序，使文字更具吸引力、可读性和说服力，内容简短精炼，字数不超过原始内容的70%。\</p> 
<p>3. 重构后的文本相较于原文有较大的提升和改良，无需展示修改过程。\</p> 
<p>4. 直接按新序号展示最终修订后的内容，无需添加任何说明。",</p> 
<p>"role": "user"</p> 
<p>            }</p> 
<p>        ]</p> 
<p>    })</p> 
<p>  headers = {<!-- --></p> 
<p>      'Content-Type': 'application/json'</p> 
<p>    }</p> 
<p>   </p> 
<p>  response = requests.request("POST", url, headers=headers, data=payload)</p> 
<p>   </p> 
<p>  #print(response.text)</p> 
<p>  return response.text</p> 
<h2>C++调用pyhton文件中的函数</h2> 
<h3>头文件定义</h3> 
<p>#ifndef PYTHONCALLER_H</p> 
<p>#define PYTHONCALLER_H</p> 
<p>#include &lt;Python.h&gt;</p> 
<p>#include &lt;string&gt;</p> 
<p>class PythonCaller {<!-- --></p> 
<p>private:</p> 
<p>  PyObject* pModule;</p> 
<p>  PyObject* pGetvalueFunc;</p> 
<p>  PyObject* pGetcookiesFunc;</p> 
<p>public:</p> 
<p>  PythonCaller();</p> 
<p>  ~PythonCaller();</p> 
<p>  bool Initialize(std::string path, std::string name);</p> 
<p>  void Finalize();</p> 
<p>  std::string CallGetValue(const std::string&amp; url, const std::string&amp; cookies);</p> 
<p>  std::string CallGetCookies();</p> 
<p>};</p> 
<p>#endif  // PYTHONCALLER_H</p> 
<p>#else</p> 
<p>#endif</p> 
<h3>源文件定义</h3> 
<p>#include "PythonCaller.h"</p> 
<p>PythonCaller::PythonCaller() : pModule(nullptr) {}</p> 
<p>PythonCaller::~PythonCaller() {<!-- --></p> 
<p>  Finalize();</p> 
<p>}</p> 
<p>bool PythonCaller::Initialize(std::string path, std::string name) {<!-- --></p> 
<p>  Py_Initialize();</p> 
<p>  PyRun_SimpleString("import sys");</p> 
<p>  PyRun_SimpleString(("sys.path.append('" + path + "')").c_str());</p> 
<p>  PyObject* pName = PyUnicode_DecodeFSDefault(name.c_str());</p> 
<p>  pModule = PyImport_Import(pName);</p> 
<p>  Py_DECREF(pName);</p> 
<p>  if (pModule == nullptr) {<!-- --></p> 
<p>      return0;</p> 
<p>    }</p> 
<p>  pGetvalueFunc = PyObject_GetAttrString(pModule,"getvalue");</p> 
<p>  if (!pGetvalueFunc || !PyCallable_Check(pGetvalueFunc)) {<!-- --></p> 
<p>      Py_XDECREF(pGetvalueFunc);</p> 
<p>      return0;</p> 
<p>    }</p> 
<p>  pGetcookiesFunc = PyObject_GetAttrString(pModule,"getcookies");</p> 
<p>  if (!pGetcookiesFunc || !PyCallable_Check(pGetcookiesFunc)) {<!-- --></p> 
<p>      Py_XDECREF(pGetcookiesFunc);</p> 
<p>      return0;</p> 
<p>    }</p> 
<p>  return 1;</p> 
<p>}</p> 
<p>void PythonCaller::Finalize() {<!-- --></p> 
<p>  if (pModule != nullptr) {<!-- --></p> 
<p>      Py_DECREF(pModule);</p> 
<p>      pModule = nullptr;  //将 pModule 置为 nullptr</p> 
<p>    }</p> 
<p>  if (pGetvalueFunc != nullptr) {<!-- --></p> 
<p>      Py_DECREF(pGetvalueFunc);</p> 
<p>      pGetvalueFunc = nullptr;  //将 pModule 置为 nullptr</p> 
<p>    }</p> 
<p>  if (pGetcookiesFunc != nullptr) {<!-- --></p> 
<p>      Py_DECREF(pGetcookiesFunc);</p> 
<p>      pGetcookiesFunc = nullptr;  //将 pModule 置为 nullptr</p> 
<p>    }</p> 
<p>  Py_Finalize();</p> 
<p>}</p> 
<p>std::string PythonCaller::CallGetValue(const std::string&amp; url, const std::string&amp; cookies) {<!-- --></p> 
<p>  if (!pGetvalueFunc || !PyCallable_Check(pGetvalueFunc)) {<!-- --></p> 
<p>      Py_XDECREF(pGetvalueFunc);</p> 
<p>      return"";</p> 
<p>    }</p> 
<p>   </p> 
<p>  PyObject* pArgs = PyTuple_New(2);</p> 
<p>  PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(url.c_str()));</p> 
<p>  PyTuple_SetItem(pArgs, 1, PyUnicode_FromString(cookies.c_str()));// 设置第二个参数为字符串</p> 
<p>  PyObject* pValue = PyObject_CallObject(pGetvalueFunc, pArgs);</p> 
<p>  Py_DECREF(pArgs);</p> 
<p>  if (pValue == nullptr) {<!-- --></p> 
<p>      PyErr_Print();</p> 
<p>      return"Error: Call to 'getvalue' failed";</p> 
<p>    }</p> 
<p>  std::string result;</p> 
<p>  if (pValue == Py_None) {<!-- --></p> 
<p>      result = "Result of call: None";</p> 
<p>    }</p> 
<p>  else {<!-- --></p> 
<p>      PyObject* pStr = PyObject_Str(pValue);</p> 
<p>      if (pStr != nullptr) {<!-- --></p> 
<p>          const char* utf8_str = PyUnicode_AsUTF8(pStr);</p> 
<p>          result = std::string(utf8_str);</p> 
<p>          Py_DECREF(pStr);</p> 
<p>        }</p> 
<p>      else {<!-- --></p> 
<p>          result = "Error: Unable to convert result to string";</p> 
<p>        }</p> 
<p>    }</p> 
<p>  Py_DECREF(pValue);</p> 
<p>  return result;</p> 
<p>}</p> 
<p>std::string PythonCaller::CallGetCookies() {<!-- --></p> 
<p>  if (!pGetcookiesFunc || !PyCallable_Check(pGetcookiesFunc)) {<!-- --></p> 
<p>      Py_XDECREF(pGetcookiesFunc);</p> 
<p>      return"";</p> 
<p>    }</p> 
<p>  PyObject* pArgs = PyTuple_New(0);</p> 
<p>  PyObject* pValue = PyObject_CallObject(pGetcookiesFunc, pArgs);</p> 
<p>  Py_DECREF(pArgs);</p> 
<p>  if (pValue == nullptr) {<!-- --></p> 
<p>      PyErr_Print();</p> 
<p>      return"Error: Call to 'getvalue' failed";</p> 
<p>    }</p> 
<p>  std::string result;</p> 
<p>  if (pValue == Py_None) {<!-- --></p> 
<p>      result = "Result of call: None";</p> 
<p>    }</p> 
<p>  else {<!-- --></p> 
<p>      PyObject* pStr = PyObject_Str(pValue);</p> 
<p>      if (pStr != nullptr) {<!-- --></p> 
<p>          const char* utf8_str = PyUnicode_AsUTF8(pStr);</p> 
<p>          result = std::string(utf8_str);</p> 
<p>          Py_DECREF(pStr);</p> 
<p>        }</p> 
<p>      else {<!-- --></p> 
<p>          result = "Error: Unable to convert result to string";</p> 
<p>        }</p> 
<p>    }</p> 
<p>  Py_DECREF(pValue);</p> 
<p>  return result;</p> 
<p>}</p> 
<h2>C++与python函数的交互过程</h2> 
<p>  if (mgIspythonCaller == 0) {<!-- --></p> 
<p>      mgIspythonCaller = mgpythonCaller.Initialize(mgSelfPath, "ai");</p> 
<p>    }</p> 
<p>   </p> 
<p>  if (!mgIspythonCaller) {<!-- --></p> 
<p>      return1;</p> 
<p>    }</p> 
<p>  string str = mgpythonCaller.CallGetValue(content, "");</p> 
<h2>visualstudio中python环境设置</h2> 
<p>根据程序环境，选择对应版本的python安装</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="269" src="https://images2.imgbox.com/64/19/kxDHE0LG_o.png" width="799"></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="267" src="https://images2.imgbox.com/eb/bf/9gnVDvdt_o.png" width="811"></p> 
<p></p> 
<p class="img-center"><img alt="图片" height="197" src="https://images2.imgbox.com/58/1c/L76A6r5Y_o.png" width="517"></p> 
<p>下载源码地址：https://www.lanzoub.com/iAFK0203yd4h</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8de3128fa5b3aa73df0db92e70850a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端】vue&#43;element项目中select下拉框label想要显示多个值多个字段</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/06cb80ceaddc9280739e512b7c0903c0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学业辅导导师：文心一言智能体详细介绍和开发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>