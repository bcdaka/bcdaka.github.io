<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>uniapp实现将页面转换成pdf（小程序、app、h5） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ac906ccf6b0d4415fd1886ccd76e44f0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="uniapp实现将页面转换成pdf（小程序、app、h5）">
  <meta property="og:description" content="使用html2Canvas和jspdf
安装这两个
npm i jspdf html2canvas uniapp在小程序无法获取dom，app端可在renderjs中获取 dom，小程序需要使用web-view导入一个h5页面，实现转pdf
H5和小程序 &lt;template&gt; &lt;div&gt; &lt;div id=&#34;content&#34;&gt; 要转换的内容 &lt;/div&gt; &lt;button type=&#34;button&#34; class=&#34;btn btn-primary&#34; @click=&#34;getPdf()&#34;&gt;导出PDF&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import html2Canvas from &#39;html2canvas&#39; import { jsPDF } from &#39;jspdf&#39; let BaseUrl = &#39;url&#39; //域名 export default{ methods:{ getPdf(){ let that = this var shareContent = document.getElementById(&#39;content&#39;); var width = shareContent.offsetWidth / 4; var height = shareContent.offsetHeight / 4; html2Canvas(shareContent , { dpi: 900, scrolly: 0, // width:eleW,//生成后的宽度 // height:eleH,//生成后的高度 scrollx: -10, useCORS: true, //允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。 // backgroundColor: null //避免图片有白色边框 }).">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-15T17:53:59+08:00">
    <meta property="article:modified_time" content="2023-11-15T17:53:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">uniapp实现将页面转换成pdf（小程序、app、h5）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>使用html2Canvas和jspdf</p> 
<p>安装这两个</p> 
<pre><code>npm i jspdf html2canvas </code></pre> 
<p>uniapp在小程序无法获取dom，app端可在renderjs中获取 dom，小程序需要使用web-view导入一个h5页面，实现转pdf</p> 
<h5>H5和小程序</h5> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div&gt;
        &lt;div id="content"&gt;
            要转换的内容
        &lt;/div&gt;
        &lt;button type="button" class="btn btn-primary" @click="getPdf()"&gt;导出PDF&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
	import html2Canvas from 'html2canvas'
	import { jsPDF } from 'jspdf'
	let BaseUrl = 'url'    //域名
	export default{
		methods:{
			getPdf(){
				let that = this
				var shareContent = document.getElementById('content');
				var width = shareContent.offsetWidth / 4;
				var height = shareContent.offsetHeight / 4;
				html2Canvas(shareContent , {
					dpi: 900,
					scrolly: 0,
					// width:eleW,//生成后的宽度
					// height:eleH,//生成后的高度
					scrollx: -10,
					useCORS: true, //允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。
	
					// backgroundColor: null //避免图片有白色边框
				}).then((canvas) =&gt; {
					var context = canvas.getContext('2d');
					context.mozImageSmoothingEnabled = false;
					context.webkitImageSmoothingEnabled = false;
					context.msImageSmoothingEnabled = false;
					context.imageSmoothingEnabled = false;
					var pageData = canvas.toDataURL('image/jpeg', 1.0);
					var img = new Image();
					img.src = pageData;
					img.onload = () =&gt; {
						// 获取dom高度、宽度
						img.width = img.width / 2;
						img.height = img.height / 2;
						console.log(img.width, '------ img.width');
						console.log(img.height, '------img.height');
						img.style.transform = 'scale(0.5)';
						if (width &gt; height) {
							// 此可以根据打印的大小进行自动调节
							// eslint-disable-next-line
							var pdf = new jsPDF('l', 'mm', [width * 0.505, height * 0.545]);
						} else {
							// eslint-disable-next-line
							var pdf = new jsPDF('p', 'mm', [width * 0.505, height * 0.545]);
						}
						pdf.addImage(pageData, 'jpeg', 0, 0, width * 0.505, height * 0.545);
						pdf.save('安全服务协议' + '.pdf');  //h5在这就可以保存pdf

                        //内嵌到微信小程序
						var blob = pdf.output("datauristring");
						console.log(wx,'wx')
						wx.miniProgram.getEnv(function (res) {
							console.log("当前环境：" + JSON.stringify(res));
						});
						wx.miniProgram.postMessage({
							data: {
								imageData:blob
							},
						});
						wx.miniProgram.navigateBack()
					};
				}).catch((r) =&gt; {
					console.log(r);
				})
			},
			
		},
		onLoad(e) {
			this.id = e.id 
		}
	}
	
&lt;/script&gt;</code></pre> 
<p>其中通过web-view导入到微信小程序的话，需要导入微信的sdk</p> 
<p>在index.html中导入也不知道咋回事，有wx，但是wx.miniProgram是undefined</p> 
<pre><code class="language-javascript">&lt;script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"&gt;&lt;/script&gt;</code></pre> 
<p>然后网上找到大佬的方法</p> 
<p>在App.vue里面写</p> 
<pre><code class="language-javascript">onLaunch: function() {
	console.log('App Launch')
	// #ifdef H5
	var script = document.createElement('script');
	script.src = "https://res.wx.qq.com/open/js/jweixin-1.4.0.js";
	script.type = 'text/javascript';
	document.body.appendChild(script);
	// #endif		
},</code></pre> 
<p>然后在小程序中使用web-view导入这个h5</p> 
<pre><code class="language-javascript">&lt;template&gt;
	&lt;view class=""&gt;
		&lt;web-view :src="url" @message="message"&gt;&lt;/web-view&gt;
	&lt;/view&gt;
&lt;/template&gt;

&lt;script&gt;
	export default{
		data(){
			return{
				imageData:'',
				id:'',
				url:''
			}
		},
		methods:{
			message(e){
				console.log(e,'e')
				this.imageData = e.detail.data[0].imageData
				let path = this.imageData.split('base64,')[1]
				this.download(path)
			},
			async download(url) {
				let result = url.replace(/[\r\n]/g, '');
				var fs = wx.getFileSystemManager();
				let fileName = '';
				var times = new Date().getTime();
				url = wx.base64ToArrayBuffer(result);
				// console.log(url,'图片临时路径')
				const filePath = wx.env.USER_DATA_PATH + '/' + Date.now() + '.pdf'
				fs.writeFile({
				    filePath,
				    data: url,  // 将 base64 转为 arrayuffer
				    success (res) {
				      uni.openDocument({
				        showMenu: true,
				        fileType: 'pdf',
				        filePath,
				        success: function (res) {
				          console.log('打开文档成功')
				        }
				      })
				    },
				    fail (err) {
				      console.log('错误', err)
				    }
				  })
			},
		},
		onLoad(e) {
			this.id = e.id || 0
			this.url = this.$http.BaseUrl+`/h5/#/?id=${this.id}`
			console.log(this.url,'url')
		}
	}
&lt;/script&gt;</code></pre> 
<h5>App端</h5> 
<p>也可以使用web-view，但我直接在renderjs中写了</p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div&gt;
        &lt;div id="content"&gt;
            要转换的内容
        &lt;/div&gt;
        &lt;button type="button" class="btn btn-primary" @click="canvasImage.save"&gt;导出PDF&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { base64ToPath } from '../../../common/imageTools.js';
export default{

    methods:{
        receiveRenderData(url){
			this.loadBase64Url(url)
		},
		/* 将base64 位的图片路径转换为 临时路径 */
		loadBase64Url(url) {
			const imageStr = url;
			base64ToPath(imageStr)
			.then(path =&gt; {
					console.log(path,'path')
					this.saveImage(path);  
			})
			.catch(error =&gt; {
				 console.error('临时路径转换出错了：', error);
			});
		},
			saveImage(url){
				uni.saveFile({
					tempFilePath:url,
					async success(res) {
						uni.openDocument({
							filePath:res.savedFilePath,
							success: function(FileRes) {
								console.log('打开成功');
							}
						}); 
					},
					complete(res) {
						console.log(res,'res')
					}
				})
			},
    }
}
&lt;/script&gt;

&lt;script lang="renderjs" module="canvasImage"&gt;
import html2Canvas from 'html2canvas'
import { jsPDF } from 'jspdf'
export default {
  methods: {
    // 生成图片需要调用的方法
    generateImage(e, ownerFun) {
		return new Promise((resolve, reject) =&gt; {
			var shareContent = document.getElementById('content');
			var width = shareContent.offsetWidth / 4;
			var height = shareContent.offsetHeight / 4;
			html2Canvas(document.getElementById('content'), {
				dpi: 900,
				scrolly: 0,
				// width:eleW,//生成后的宽度
				// height:eleH,//生成后的高度
				scrollx: -10,
				useCORS: true, //允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。
				
				// backgroundColor: null //避免图片有白色边框
			}).then((canvas) =&gt; {
				setTimeout(()=&gt; {
					var context = canvas.getContext('2d');
					context.mozImageSmoothingEnabled = false;
					context.webkitImageSmoothingEnabled = false;
					context.msImageSmoothingEnabled = false;
					context.imageSmoothingEnabled = false;
					var pageData = canvas.toDataURL('image/jpeg', 1.0);
					// resolve(pageData)
					var img = new Image();
					img.src = pageData
					img.onload = () =&gt; {
						// 获取dom高度、宽度
						img.width = img.width / 2;
						img.height = img.height / 2;
						// console.log(img.width, '------ img.width');
						// console.log(img.height, '------img.height');
						img.style.transform = 'scale(0.5)';
						if (width &gt; height) {
							// 此可以根据打印的大小进行自动调节
							// eslint-disable-next-line
							var pdf = new jsPDF('l', 'mm', [width * 0.505, height * 0.545]);
						} else {
							// eslint-disable-next-line
							var pdf = new jsPDF('p', 'mm', [width * 0.505, height * 0.545]);
						}
						pdf.addImage(pageData, 'jpeg', 0, 0, width * 0.505, height * 0.545);
						var url = pdf.output("datauristring");
						resolve(url)
					};
				}, 500);
				
			}).catch((r) =&gt; {
				console.log(r);
			})
		})
    },
	async save(e,ownerFun){
		let img =  await this.generateImage().then()
		ownerFun.callMethod('receiveRenderData',img)
	},
  },
}
&lt;/script&gt;</code></pre> 
<p>然后发现在ios中pdf中的网络路径的图片不显示，用过其他方法，太笨还是不行，只能转base64</p> 
<pre><code class="language-javascript">urlTobase64(url){
	return new Promise((resolve,reject)=&gt;{
			uni.request({
				url: url,
				method:'GET',
				responseType:'arraybuffer',
				success: res =&gt; {
					let base64 = wx.arrayBufferToBase64(res.data); //把arraybuffer转成base64 
					base64 = ('data:image/jpg;base64,' + base64).replace(/[\r\n]/g, "")
					resolve(base64)
			    },fail: (e) =&gt; {
				    resolve(url)
				    console.log("图片转换失败");
		        }
		    })
	})
},</code></pre> 
<p>资源绑定那个js下载居然还要vip -_-，imageTool.js如下</p> 
<pre><code class="language-javascript">function getLocalFilePath(path) {
    if (path.indexOf('_www') === 0 || path.indexOf('_doc') === 0 || path.indexOf('_documents') === 0 || path.indexOf('_downloads') === 0) {
        return path
    }
    if (path.indexOf('file://') === 0) {
        return path
    }
    if (path.indexOf('/storage/emulated/0/') === 0) {
        return path
    }
    if (path.indexOf('/') === 0) {
        var localFilePath = plus.io.convertAbsoluteFileSystem(path)
        if (localFilePath !== path) {
            return localFilePath
        } else {
            path = path.substr(1)
        }
    }
    return '_www/' + path
}

function dataUrlToBase64(str) {
    var array = str.split(',')
    return array[array.length - 1]
}

var index = 0
function getNewFileId() {
    return Date.now() + String(index++)
}

function biggerThan(v1, v2) {
    var v1Array = v1.split('.')
    var v2Array = v2.split('.')
    var update = false
    for (var index = 0; index &lt; v2Array.length; index++) {
        var diff = v1Array[index] - v2Array[index]
        if (diff !== 0) {
            update = diff &gt; 0
            break
        }
    }
    return update
}

export function pathToBase64(path) {
    return new Promise(function(resolve, reject) {
        if (typeof window === 'object' &amp;&amp; 'document' in window) {
            if (typeof FileReader === 'function') {
                var xhr = new XMLHttpRequest()
                xhr.open('GET', path, true)
                xhr.responseType = 'blob'
                xhr.onload = function() {
                    if (this.status === 200) {
                        let fileReader = new FileReader()
                        fileReader.onload = function(e) {
                            resolve(e.target.result)
                        }
                        fileReader.onerror = reject
                        fileReader.readAsDataURL(this.response)
                    }
                }
                xhr.onerror = reject
                xhr.send()
                return
            }
            var canvas = document.createElement('canvas')
            var c2x = canvas.getContext('2d')
            var img = new Image
            img.onload = function() {
                canvas.width = img.width
                canvas.height = img.height
                c2x.drawImage(img, 0, 0)
                resolve(canvas.toDataURL())
                canvas.height = canvas.width = 0
            }
            img.onerror = reject
            img.src = path
            return
        }
        if (typeof plus === 'object') {
            plus.io.resolveLocalFileSystemURL(getLocalFilePath(path), function(entry) {
                entry.file(function(file) {
                    var fileReader = new plus.io.FileReader()
                    fileReader.onload = function(data) {
                        resolve(data.target.result)
                    }
                    fileReader.onerror = function(error) {
                        reject(error)
                    }
                    fileReader.readAsDataURL(file)
                }, function(error) {
                    reject(error)
                })
            }, function(error) {
                reject(error)
            })
            return
        }
        if (typeof wx === 'object' &amp;&amp; wx.canIUse('getFileSystemManager')) {
            wx.getFileSystemManager().readFile({
                filePath: path,
                encoding: 'base64',
                success: function(res) {
                    resolve('data:image/png;base64,' + res.data)
                },
                fail: function(error) {
                    reject(error)
                }
            })
            return
        }
        reject(new Error('not support'))
    })
}

export function base64ToPath(base64) {
    return new Promise(function(resolve, reject) {
        if (typeof window === 'object' &amp;&amp; 'document' in window) {
            base64 = base64.split(',')
            var type = base64[0].match(/:(.*?);/)[1]
            var str = atob(base64[1])
            var n = str.length
            var array = new Uint8Array(n)
            while (n--) {
                array[n] = str.charCodeAt(n)
            }
            return resolve((window.URL || window.webkitURL).createObjectURL(new Blob([array], { type: type })))
        }
        var extName = base64.split(',')[0].match(/data\:\S+\/(\S+);/)
        if (extName) {
            extName = extName[1]
        } else {
            reject(new Error('base64 error'))
        }
        var fileName = getNewFileId() + '.' + extName
        if (typeof plus === 'object') {
            var basePath = '_doc'
            var dirPath = 'uniapp_temp'
            var filePath = basePath + '/' + dirPath + '/' + fileName
            if (!biggerThan(plus.os.name === 'Android' ? '1.9.9.80627' : '1.9.9.80472', plus.runtime.innerVersion)) {
                plus.io.resolveLocalFileSystemURL(basePath, function(entry) {
                    entry.getDirectory(dirPath, {
                        create: true,
                        exclusive: false,
                    }, function(entry) {
                        entry.getFile(fileName, {
                            create: true,
                            exclusive: false,
                        }, function(entry) {
                            entry.createWriter(function(writer) {
                                writer.onwrite = function() {
                                    resolve(filePath)
                                }
                                writer.onerror = reject
                                writer.seek(0)
                                writer.writeAsBinary(dataUrlToBase64(base64))
                            }, reject)
                        }, reject)
                    }, reject)
                }, reject)
                return
            }
            var bitmap = new plus.nativeObj.Bitmap(fileName)
            bitmap.loadBase64Data(base64, function() {
                bitmap.save(filePath, {}, function() {
                    bitmap.clear()
                    resolve(filePath)
                }, function(error) {
                    bitmap.clear()
                    reject(error)
                })
            }, function(error) {
                bitmap.clear()
                reject(error)
            })
            return
        }
        if (typeof wx === 'object' &amp;&amp; wx.canIUse('getFileSystemManager')) {
            var filePath = wx.env.USER_DATA_PATH + '/' + fileName
            wx.getFileSystemManager().writeFile({
                filePath: filePath,
                data: dataUrlToBase64(base64),
                encoding: 'base64',
                success: function() {
                    resolve(filePath)
                },
                fail: function(error) {
                    reject(error)
                }
            })
            return
        }
        reject(new Error('not support'))
    })
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b79b22695b3749c1a9ce415ce0a0adb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">不用写一行代码！Python最强自动化神器！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3c71f93311ad1eec7858bf2a58fe4326/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring中，为什么前端明明传了值，后端却接收不到</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>