<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>昇思MindSpore学习总结十五 ——基于Mindspore 实现BERT对话情绪识别 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/84b4dab80b739da686b1b4f475774e4c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="昇思MindSpore学习总结十五 ——基于Mindspore 实现BERT对话情绪识别">
  <meta property="og:description" content="1、环境配置 根据实际情况，选择合适版本。
%%capture captured_output # 实验环境已经预装了mindspore==2.2.14，如需更换mindspore版本，可更改下面mindspore的版本号 !pip uninstall mindspore -y !pip install -i https://pypi.mirrors.ustc.edu.cn/simple mindspore==2.2.14 # 该案例在 mindnlp 0.3.1 版本完成适配，如果发现案例跑不通，可以指定mindnlp版本，执行`!pip install mindnlp==0.3.1` !pip install mindnlp 2、模型简介 BERT全称是来自变换器的双向编码器表征量（Bidirectional Encoder Representations from Transformers），它是Google于2018年末开发并发布的一种新型语言模型。与BERT模型相似的预训练语言模型例如问答、命名实体识别、自然语言推理、文本分类等在许多自然语言处理任务中发挥着重要作用。模型是基于Transformer中的Encoder并加上双向的结构，因此一定要熟练掌握Transformer的Encoder的结构。
BERT模型的主要创新点都在pre-train方法上，即用了Masked Language Model和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation。
在用Masked Language Model方法训练BERT的时候，随机把语料库中15%的单词做Mask操作。对于这15%的单词做Mask操作分为三种情况：80%的单词直接用[Mask]替换、10%的单词直接替换成另一个新的单词、10%的单词保持不变。
因为涉及到Question Answering (QA) 和 Natural Language Inference (NLI)之类的任务，增加了Next Sentence Prediction预训练任务，目的是让模型理解两个句子之间的联系。与Masked Language Model任务相比，Next Sentence Prediction更简单些，训练的输入是句子A和B，B有一半的几率是A的下一句，输入这两个句子，BERT模型预测B是不是A的下一句。
BERT预训练之后，会保存它的Embedding table和12层Transformer权重（BERT-BASE）或24层Transformer权重（BERT-LARGE）。使用预训练好的BERT模型可以对下游任务进行Fine-tuning，比如：文本分类、相似度判断、阅读理解等。
对话情绪识别（Emotion Detection，简称EmoTect），专注于识别智能对话场景中用户的情绪，针对智能对话场景中的用户文本，自动判断该文本的情绪类别并给出相应的置信度，情绪类型分为积极、消极、中性。 对话情绪识别适用于聊天、客服等多个场景，能够帮助企业更好地把握对话质量、改善产品的用户交互体验，也能分析客服服务质量、降低人工质检成本。
下面以一个文本情感分类任务为例子来说明BERT模型的整个应用过程。
import os # 导入操作系统相关的模块 import mindspore # 导入MindSpore框架 from mindspore.dataset import text, GeneratorDataset, transforms # 从MindSpore的数据集模块导入文本处理、生成器数据集和转换功能 from mindspore import nn, context # 从MindSpore导入神经网络模块和上下文管理模块 from mindnlp.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T23:17:53+08:00">
    <meta property="article:modified_time" content="2024-07-12T23:17:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">昇思MindSpore学习总结十五 ——基于Mindspore 实现BERT对话情绪识别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、环境配置</h3> 
<p>根据实际情况，选择合适版本。</p> 
<pre><code class="hljs">%%capture captured_output
# 实验环境已经预装了mindspore==2.2.14，如需更换mindspore版本，可更改下面mindspore的版本号
!pip uninstall mindspore -y
!pip install -i https://pypi.mirrors.ustc.edu.cn/simple mindspore==2.2.14

# 该案例在 mindnlp 0.3.1 版本完成适配，如果发现案例跑不通，可以指定mindnlp版本，执行`!pip install mindnlp==0.3.1`
!pip install mindnlp</code></pre> 
<h3>2、模型简介</h3> 
<p>        BERT全称是来自变换器的双向编码器表征量（Bidirectional Encoder Representations from Transformers），它是Google于2018年末开发并发布的一种新型语言模型。与BERT模型相似的预训练语言模型例如问答、命名实体识别、自然语言推理、文本分类等在许多自然语言处理任务中发挥着重要作用。模型是基于Transformer中的Encoder并加上双向的结构，因此一定要熟练掌握Transformer的Encoder的结构。</p> 
<p>        BERT模型的主要创新点都在pre-train方法上，即用了Masked Language Model和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation。</p> 
<p>        在用Masked Language Model方法训练BERT的时候，随机把语料库中15%的单词做Mask操作。对于这15%的单词做Mask操作分为三种情况：80%的单词直接用[Mask]替换、10%的单词直接替换成另一个新的单词、10%的单词保持不变。</p> 
<p>        因为涉及到Question Answering (QA) 和 Natural Language Inference (NLI)之类的任务，增加了Next Sentence Prediction预训练任务，目的是让模型理解两个句子之间的联系。与Masked Language Model任务相比，Next Sentence Prediction更简单些，训练的输入是句子A和B，B有一半的几率是A的下一句，输入这两个句子，BERT模型预测B是不是A的下一句。</p> 
<p>        BERT预训练之后，会保存它的Embedding table和12层Transformer权重（BERT-BASE）或24层Transformer权重（BERT-LARGE）。使用预训练好的BERT模型可以对下游任务进行Fine-tuning，比如：文本分类、相似度判断、阅读理解等。</p> 
<p>        对话情绪识别（Emotion Detection，简称EmoTect），专注于识别智能对话场景中用户的情绪，针对智能对话场景中的用户文本，自动判断该文本的情绪类别并给出相应的置信度，情绪类型分为积极、消极、中性。 对话情绪识别适用于聊天、客服等多个场景，能够帮助企业更好地把握对话质量、改善产品的用户交互体验，也能分析客服服务质量、降低人工质检成本。</p> 
<p>下面以一个文本情感分类任务为例子来说明BERT模型的整个应用过程。</p> 
<pre><code class="hljs">import os  # 导入操作系统相关的模块

import mindspore  # 导入MindSpore框架
from mindspore.dataset import text, GeneratorDataset, transforms  # 从MindSpore的数据集模块导入文本处理、生成器数据集和转换功能
from mindspore import nn, context  # 从MindSpore导入神经网络模块和上下文管理模块

from mindnlp._legacy.engine import Trainer, Evaluator  # 从MindNLP的引擎模块导入训练器和评估器
from mindnlp._legacy.engine.callbacks import CheckpointCallback, BestModelCallback  # 从MindNLP的引擎模块导入检查点回调和最佳模型回调
from mindnlp._legacy.metrics import Accuracy  # 从MindNLP的指标模块导入准确率度量</code></pre> 
<p><img alt="" height="81" src="https://images2.imgbox.com/cb/8b/1Z7wpH5D_o.png" width="1116"> </p> 
<pre><code class="hljs"># prepare dataset
class SentimentDataset:  # 定义一个情感数据集类
    """Sentiment Dataset"""

    def __init__(self, path):  # 初始化函数，接受文件路径作为参数
        self.path = path  # 存储文件路径
        self._labels, self._text_a = [], []  # 初始化标签和文本列表
        self._load()  # 加载数据

    def _load(self):  # 私有方法，用于加载数据
        with open(self.path, "r", encoding="utf-8") as f:  # 打开文件
            dataset = f.read()  # 读取文件内容
        lines = dataset.split("\n")  # 按行分割文件内容
        for line in lines[1:-1]:  # 遍历除首行和末行的每一行
            label, text_a = line.split("\t")  # 按制表符分割标签和文本
            self._labels.append(int(label))  # 将标签转换为整数并添加到标签列表
            self._text_a.append(text_a)  # 将文本添加到文本列表

    def __getitem__(self, index):  # 获取指定索引的数据
        return self._labels[index], self._text_a[index]  # 返回对应索引的标签和文本

    def __len__(self):  # 获取数据集的长度
        return len(self._labels)  # 返回标签列表的长度
</code></pre> 
<h3>3、数据集</h3> 
<p>                这里提供一份已标注的、经过分词预处理的机器人聊天数据集，来自于百度飞桨团队。数据由两列组成，以制表符（'\t'）分隔，第一列是情绪分类的类别（0表示消极；1表示中性；2表示积极），第二列是以空格分词的中文文本，如下示例，文件为 utf8 编码。</p> 
<p>label--text_a</p> 
<p>0--谁骂人了？我从来不骂人，我骂的都不是人，你是人吗 ？</p> 
<p>1--我有事等会儿就回来和你聊</p> 
<p>2--我见到你很高兴谢谢你帮我</p> 
<p>这部分主要包括数据集读取，数据格式转换，数据 Tokenize 处理和 pad 操作。</p> 
<pre><code class="hljs"># download dataset
!wget https://baidu-nlp.bj.bcebos.com/emotion_detection-dataset-1.0.0.tar.gz -O emotion_detection.tar.gz
!tar xvf emotion_detection.tar.gz</code></pre> 
<p><img alt="" height="291" src="https://images2.imgbox.com/20/4c/I8MOaeBd_o.png" width="1101"></p> 
<h3> 4、数据加载和数据预处理</h3> 
<h4>4.1 加载</h4> 
<p>新建 process_dataset 函数用于数据加载和数据预处理，具体内容可见下面代码注释。</p> 
<pre><code class="hljs">import numpy as np  # 导入NumPy库

def process_dataset(source, tokenizer, max_seq_len=64, batch_size=32, shuffle=True):
    # 定义处理数据集的函数，接受数据源、分词器、最大序列长度、批次大小和是否打乱数据作为参数
    is_ascend = mindspore.get_context('device_target') == 'Ascend'
    # 检查MindSpore的运行设备是否为Ascend

    column_names = ["label", "text_a"]  
    # 定义数据集的列名

    dataset = GeneratorDataset(source, column_names=column_names, shuffle=shuffle)
    # 创建生成器数据集，并指定列名和是否打乱数据

    # transforms
    type_cast_op = transforms.TypeCast(mindspore.int32)
    # 定义类型转换操作，将数据类型转换为int32

    def tokenize_and_pad(text):  
        # 定义分词和填充函数
        if is_ascend:  
            # 如果设备是Ascend
            tokenized = tokenizer(text, padding='max_length', truncation=True, max_length=max_seq_len)
            # 使用分词器对文本进行分词、填充和截断，最大长度为max_seq_len
        else:
            tokenized = tokenizer(text)
            # 如果不是Ascend设备，仅进行分词
        return tokenized['input_ids'], tokenized['attention_mask']
        # 返回分词后的输入ID和注意力掩码

    # map dataset
    dataset = dataset.map(operations=tokenize_and_pad, input_columns="text_a", output_columns=['input_ids', 'attention_mask'])
    # 将分词和填充操作映射到数据集的"text_a"列，输出列为'input_ids'和'attention_mask'
    dataset = dataset.map(operations=[type_cast_op], input_columns="label", output_columns='labels')
    # 将类型转换操作映射到数据集的"label"列，输出列为'labels'

    # batch dataset
    if is_ascend:
        # 如果设备是Ascend
        dataset = dataset.batch(batch_size)
        # 直接将数据集分成批次
    else:
        # 如果不是Ascend设备
        dataset = dataset.padded_batch(batch_size, pad_info={'input_ids': (None, tokenizer.pad_token_id),
                                                             'attention_mask': (None, 0)})
        # 使用指定的填充值将数据集分成批次

    return dataset
    # 返回处理后的数据集
</code></pre> 
<h4>4.2 处理</h4> 
<p>昇腾NPU环境下暂不支持动态Shape，数据预处理部分采用静态Shape处理：</p> 
<pre><code class="hljs">from mindnlp.transformers import BertTokenizer  # 从MindNLP的transformers模块导入BertTokenizer
tokenizer = BertTokenizer.from_pretrained('bert-base-chinese')  # 从预训练模型'bert-base-chinese'中加载BertTokenizer分词器
</code></pre> 
<pre><code class="hljs">tokenizer.pad_token_id  # 获取分词器中用于填充的token的ID</code></pre> 
<p></p> 
<p><img alt="" height="37" src="https://images2.imgbox.com/97/6b/ghnjyCNr_o.png" width="1112"><code>tokenizer.pad_token_id</code> 返回 <code>0</code>，这意味着在使用这个分词器进行填充时，[PAD] 标记的ID是 <code>0</code>。</p> 
<pre><code class="hljs">dataset_train = process_dataset(SentimentDataset("data/train.tsv"), tokenizer)
# 使用训练数据集文件 "data/train.tsv" 创建 SentimentDataset 实例，并使用 process_dataset 函数处理数据集
# 得到处理后的训练数据集 dataset_train

dataset_val = process_dataset(SentimentDataset("data/dev.tsv"), tokenizer)
# 使用验证数据集文件 "data/dev.tsv" 创建 SentimentDataset 实例，并使用 process_dataset 函数处理数据集
# 得到处理后的验证数据集 dataset_val

dataset_test = process_dataset(SentimentDataset("data/test.tsv"), tokenizer, shuffle=False)
# 使用测试数据集文件 "data/test.tsv" 创建 SentimentDataset 实例，并使用 process_dataset 函数处理数据集
# 得到处理后的测试数据集 dataset_test
# 注意，这里设置了 shuffle=False，表示不打乱数据集

dataset_train.get_col_names()
# 获取处理后的训练数据集的列名
</code></pre> 
<p><img alt="" height="37" src="https://images2.imgbox.com/17/b3/zSMS3ghm_o.png" width="1104"></p> 
<pre><code class="hljs">print(next(dataset_train.create_tuple_iterator()))
# 创建一个元组迭代器并获取数据集中的第一个批次，然后打印该批次的数据</code></pre> 
<p><img alt="" height="280" src="https://images2.imgbox.com/d1/c3/ybmnI87o_o.png" width="1096"></p> 
<h3> 5、模型构建</h3> 
<p>        通过 BertForSequenceClassification 构建用于情感分类的 BERT 模型，加载预训练权重，设置情感三分类的超参数自动构建模型。后面对模型采用自动混合精度操作，提高训练的速度，然后实例化优化器，紧接着实例化评价指标，设置模型训练的权重保存策略，最后就是构建训练器，模型开始训练。</p> 
<pre><code class="hljs">from mindnlp.transformers import BertForSequenceClassification, BertModel
# 从MindNLP的transformers模块导入BertForSequenceClassification和BertModel类

from mindnlp._legacy.amp import auto_mixed_precision
# 从MindNLP的_legacy.amp模块导入auto_mixed_precision函数

# set bert config and define parameters for training
# 设置BERT配置并定义训练参数

model = BertForSequenceClassification.from_pretrained('bert-base-chinese', num_labels=3)
# 从预训练模型 'bert-base-chinese' 中加载BERT用于序列分类的模型，设置分类标签数为3

model = auto_mixed_precision(model, 'O1')
# 使用混合精度训练，将模型转换为混合精度模式，优化训练速度和内存占用
# 'O1' 表示在混合精度训练中采用混合模式

optimizer = nn.Adam(model.trainable_params(), learning_rate=2e-5)
# 定义优化器，使用Adam优化算法，并设置模型可训练参数和学习率为2e-5</code></pre> 
<p><img alt="" height="134" src="https://images2.imgbox.com/22/3a/g2G2qkdg_o.png" width="1111"></p> 
<pre><code class="hljs">metric = Accuracy()
# 定义度量标准，用于评估模型性能，这里使用准确率（Accuracy）作为度量标准。

# 定义用于保存检查点的回调函数
ckpoint_cb = CheckpointCallback(save_path='checkpoint', ckpt_name='bert_emotect', epochs=1, keep_checkpoint_max=2)
# CheckpointCallback回调函数每1个epoch保存一次模型检查点（checkpoint），
# 保存路径为'checkpoint'，检查点文件名为'bert_emotect'，最多保留2个检查点。

best_model_cb = BestModelCallback(save_path='checkpoint', ckpt_name='bert_emotect_best', auto_load=True)
# BestModelCallback回调函数用于保存性能最好的模型，保存路径为'checkpoint'，
# 最佳模型文件名为'bert_emotect_best'，在训练开始时自动加载最好的模型（如果存在）。

trainer = Trainer(network=model, train_dataset=dataset_train,
                  eval_dataset=dataset_val, metrics=metric,
                  epochs=5, optimizer=optimizer, callbacks=[ckpoint_cb, best_model_cb])
# 初始化Trainer对象，用于训练和评估模型。
# 参数解释：
# - network=model：指定要训练的模型。
# - train_dataset=dataset_train：指定用于训练的数据集。
# - eval_dataset=dataset_val：指定用于评估的数据集。
# - metrics=metric：指定评估指标，这里使用的是准确率（Accuracy）。
# - epochs=5：指定训练的轮数（epochs）。
# - optimizer=optimizer：指定用于优化模型的优化器。
# - callbacks=[ckpoint_cb, best_model_cb]：指定回调函数列表，包括检查点回调和最佳模型回调。
</code></pre> 
<pre><code class="hljs">%%time
# 开始训练
trainer.run(tgt_columns="labels")
# 这行代码开始训练模型，并计时训练过程的执行时间。
# 参数解释：
# - tgt_columns="labels"：指定目标列（标签列）的名称，用于训练模型。</code></pre> 
<p><img alt="" height="176" src="https://images2.imgbox.com/c3/af/tX9vep7z_o.png" width="368"></p> 
<h3>6、模型推理</h3> 
<p>遍历推理数据集，将结果与标签进行统一展示。</p> 
<pre><code class="hljs">dataset_infer = SentimentDataset("data/infer.tsv")</code></pre> 
<pre><code class="hljs">from mindspore import Tensor
# 导入Tensor类

for label, text in dataset_infer:
    predict(text, label)
    # 遍历推理数据集dataset_infer，每次循环获取一对标签和文本。
    # 调用predict函数对文本进行预测，并输出预测结果和真实标签。
</code></pre> 
<p><img alt="" height="231" src="https://images2.imgbox.com/d7/8b/zKwZQ1OE_o.png" width="1105"></p> 
<h3>7、自定义推理数据集</h3> 
<p>自己输入推理数据，展示模型的泛化能力。</p> 
<pre><code class="hljs">predict("都说的是啥玩意儿啊 都听不懂")</code></pre> 
<p><img alt="" height="27" src="https://images2.imgbox.com/88/21/QQSlAZyu_o.png" width="1087"></p> 
<p>打卡</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/64/f1/8WmGt0Pl_o.png" width="1099"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d82e24942b064d698e5b663861766337/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">M0G3507完美移植江科大软件IIC MPU6050</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59d6afe2aa3fa1c38e9ace964dbed56f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Redis】哨兵(sentinel)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>