<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>saas服务，对同一个功能，需要使用不同客户的接口。那么哪种设计模式可以解决我的问题? - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/80a8f25000e073bd1ba3df3175d8b2df/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="saas服务，对同一个功能，需要使用不同客户的接口。那么哪种设计模式可以解决我的问题?">
  <meta property="og:description" content="Q: 我现在遇到的问题：我在做一个saas服务，现在面对多家客户。对同一个功能，需要使用不同客户的接口。比如，我的发送短信功能，每个客户的发消息接口都不同。那么哪种设计模式可以解决我的问题，可以使用c#来给我演示 A:
面对这种需要根据不同客户使用不同接口的情况，一个常见的解决方案是使用策略模式（Strategy Pattern）。策略模式允许在运行时选择算法或行为，非常适合于你描述的场景，即根据不同的客户使用不同的发送短信接口。
以下是使用C#实现策略模式的一个简单示例：
定义发送短信的接口： public interface ISmsSender { void SendSms(string message, string phoneNumber); } 实现具体的发送短信策略： public class SmsSenderA : ISmsSender { public void SendSms(string message, string phoneNumber) { Console.WriteLine($&#34;Sending SMS with provider A to {phoneNumber}: {message}&#34;); // 实现使用客户A的接口发送短信的逻辑 } } public class SmsSenderB : ISmsSender { public void SendSms(string message, string phoneNumber) { Console.WriteLine($&#34;Sending SMS with provider B to {phoneNumber}: {message}&#34;); // 实现使用客户B的接口发送短信的逻辑 } } 创建一个上下文类，用于设置和执行发送短信的操作： public class SmsService { private ISmsSender _smsSender; public SmsService(ISmsSender smsSender) { _smsSender = smsSender; } public void SetSmsSender(ISmsSender smsSender) { _smsSender = smsSender; } public void SendMessage(string message, string phoneNumber) { _smsSender.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-16T17:56:27+08:00">
    <meta property="article:modified_time" content="2024-08-16T17:56:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">saas服务，对同一个功能，需要使用不同客户的接口。那么哪种设计模式可以解决我的问题?</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>Q: 我现在遇到的问题：我在做一个saas服务，现在面对多家客户。对同一个功能，需要使用不同客户的接口。比如，我的发送短信功能，每个客户的发消息接口都不同。那么哪种设计模式可以解决我的问题，可以使用c#来给我演示</strong></h3> 
<p><strong>A:</strong></p> 
<p></p> 
<p>面对这种需要根据不同客户使用不同接口的情况，一个常见的解决方案是使用<strong>策略模式（Strategy Pattern）</strong>。策略模式允许在运行时选择算法或行为，非常适合于你描述的场景，即根据不同的客户使用不同的发送短信接口。</p> 
<p>以下是使用C#实现策略模式的一个简单示例：</p> 
<ul><li> <h4><strong>定义发送短信的接口</strong>：</h4> </li></ul> 
<pre><code class="language-cs">public interface ISmsSender
{
    void SendSms(string message, string phoneNumber);
}</code></pre> 
<ul><li> <h4><strong>实现具体的发送短信策略</strong>：</h4> </li></ul> 
<pre><code class="language-cs">public class SmsSenderA : ISmsSender
{
    public void SendSms(string message, string phoneNumber)
    {
        Console.WriteLine($"Sending SMS with provider A to {phoneNumber}: {message}");
        // 实现使用客户A的接口发送短信的逻辑
    }
}

public class SmsSenderB : ISmsSender
{
    public void SendSms(string message, string phoneNumber)
    {
        Console.WriteLine($"Sending SMS with provider B to {phoneNumber}: {message}");
        // 实现使用客户B的接口发送短信的逻辑
    }
}</code></pre> 
<ul><li> <h4><strong>创建一个上下文类，用于设置和执行发送短信的操作</strong>：</h4> </li></ul> 
<pre><code class="language-cs">public class SmsService
{
    private ISmsSender _smsSender;

    public SmsService(ISmsSender smsSender)
    {
        _smsSender = smsSender;
    }

    public void SetSmsSender(ISmsSender smsSender)
    {
        _smsSender = smsSender;
    }

    public void SendMessage(string message, string phoneNumber)
    {
        _smsSender.SendSms(message, phoneNumber);
    }
}</code></pre> 
<ul><li> <h4><strong>使用策略模式</strong>：</h4> </li></ul> 
<pre><code class="language-cs">class Program
{
    static void Main(string[] args)
    {
        // 假设根据客户类型选择不同的发送短信策略
        ISmsSender smsSender = null;
        if (客户类型 == "A")
        {
            smsSender = new SmsSenderA();
        }
        else if (客户类型 == "B")
        {
            smsSender = new SmsSenderB();
        }

        SmsService smsService = new SmsService(smsSender);
        smsService.SendMessage("Hello, this is a test message.", "1234567890");
    }
}</code></pre> 
<p><strong>在这个示例中，<code>ISmsSender</code>是一个发送短信的策略接口，<code>SmsSenderA</code>和<code>SmsSenderB</code>是具体的策略实现。<code>SmsService</code>是一个上下文类，它依赖于<code>ISmsSender</code>接口，可以在运行时根据不同的客户类型注入不同的发送短信策略。</strong></p> 
<p><strong>这种设计模式的好处是，你可以轻松地添加更多的发送短信策略，而不需要修改<code>SmsService</code>类或其他策略类。你只需要添加新的策略实现并根据需要注入即可。这提高了代码的可扩展性和可维护性。</strong></p> 
<p></p> 
<h3>是否有更优雅的实现方式?</h3> 
<p>策略模式本身已经是一个优雅的解决方案，但如果想要进一步改进和封装，可以考虑以下几个方面：</p> 
<ol><li> <p><strong>使用工厂模式</strong>：结合工厂模式来创建具体的发送短信策略对象，这样可以进一步封装创建逻辑，使得<code>SmsService</code>类不需要关心具体的策略实现。</p> </li><li> <p><strong>依赖注入</strong>：使用依赖注入（DI）框架，如.NET Core内置的DI容器，可以更优雅地管理对象的生命周期和依赖关系。</p> </li><li> <p><strong>配置驱动</strong>：通过配置文件来定义不同客户的策略实现，使得添加或修改策略不需要修改代码，只需要更新配置。</p> </li><li> <p><strong>接口抽象化</strong>：如果不同客户的接口差异较大，可能需要定义更抽象的接口或多个接口来更好地适应不同的需求。</p> </li></ol> 
<p>下面是一个结合了工厂模式和依赖注入的示例：</p> 
<ul><li> <h4><strong>定义发送短信的接口</strong>（不变）：</h4> </li></ul> 
<pre><code class="language-cs">public interface ISmsSender
{
    void SendSms(string message, string phoneNumber);
}</code></pre> 
<ul><li> <h4><strong>实现具体的发送短信策略</strong>（不变）：</h4> </li></ul> 
<pre><code class="language-cs">public class SmsSenderA : ISmsSender
{
    // ...
}

public class SmsSenderB : ISmsSender
{
    // ...
}</code></pre> 
<ul><li> <h4><strong>创建一个策略工厂</strong>：</h4> </li></ul> 
<pre><code class="language-cs">public class SmsSenderFactory
{
    public static ISmsSender GetSmsSender(string clientType)
    {
        switch (clientType)
        {
            case "A":
                return new SmsSenderA();
            case "B":
                return new SmsSenderB();
            default:
                throw new ArgumentException("Unknown client type");
        }
    }
}</code></pre> 
<ul><li> <h4><strong>使用依赖注入和配置驱动</strong>：</h4> </li></ul> 
<pre><code class="language-cs">public class SmsService
{
    private readonly ISmsSender _smsSender;

    public SmsService(ISmsSender smsSender)
    {
        _smsSender = smsSender;
    }

    public void SendMessage(string message, string phoneNumber)
    {
        _smsSender.SendSms(message, phoneNumber);
    }
}</code></pre> 
<ul><li> <h4><strong>配置和注入</strong>：</h4> </li></ul> 
<pre><code class="language-cs">class Program
{
    static void Main(string[] args)
    {
        // 假设从配置文件或环境变量获取客户类型
        string clientType = Configuration.GetClientType();

        // 使用依赖注入容器来创建SmsService实例
        var serviceProvider = new ServiceCollection()
            .AddSingleton&lt;ISmsSender&gt;(provider =&gt; SmsSenderFactory.GetSmsSender(clientType))
            .BuildServiceProvider();

        var smsService = new SmsService(serviceProvider.GetService&lt;ISmsSender&gt;());
        smsService.SendMessage("Hello, this is a test message.", "1234567890");
    }
}</code></pre> 
<p>在这个示例中，我们使用了一个简单的<code>SmsSenderFactory</code>来根据客户类型创建具体的发送短信策略对象。然后，我们使用依赖注入容器来注入<code>ISmsSender</code>的实现。这样，<code>SmsService</code>类就不需要知道具体的发送短信策略是如何创建的，只需要依赖于<code>ISmsSender</code>接口。</p> 
<p>通过这种方式，你可以很容易地通过更新配置来添加或修改发送短信策略，而不需要修改代码。同时，使用依赖注入可以使代码更加模块化和易于测试。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b6a8555f8614dbf02f4282a610490ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux 操作系统 --- 信号</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3782f317cb26809aaeeb9e5aadd1aee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【JAVA多线程】JDK线程同步工具：Semaphore、CountDownLatch、CyclicBarrier</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>