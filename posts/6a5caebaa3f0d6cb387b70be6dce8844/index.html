<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法专题】动态规划之简单多状态 dp 问题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6a5caebaa3f0d6cb387b70be6dce8844/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法专题】动态规划之简单多状态 dp 问题">
  <meta property="og:description" content="动态规划3.0 动态规划 - - - 简单多状态 dp 问题1. 按摩师(打家劫舍Ⅰ的变形)2. 打家劫舍Ⅱ3. 删除并获得点数4. 粉刷房子5. 买卖股票的最佳时机含冷冻期6. 买卖股票的最佳时机含手续费7. 买卖股票的最佳时机Ⅲ8. 买卖股票的最佳时机Ⅳ 动态规划 - - - 简单多状态 dp 问题 1. 按摩师(打家劫舍Ⅰ的变形) 题目链接 -&gt; Leetcode -面试题 17.16.按摩师
Leetcode -面试题 17.16.按摩师
题目：一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。
在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。
注意：本题相对原题稍作改动
示例 1：
输入：[1, 2, 3, 1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 &#43; 3 = 4。
示例 2：
输入：[2, 7, 9, 3, 1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 &#43; 9 &#43; 1 = 12。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-25T00:18:31+08:00">
    <meta property="article:modified_time" content="2024-01-25T00:18:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法专题】动态规划之简单多状态 dp 问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>动态规划3.0</h4> 
 <ul><li><a href="#_____dp__2" rel="nofollow">动态规划 - - - 简单多状态 dp 问题</a></li><li><ul><li><a href="#1__5" rel="nofollow">1. 按摩师(打家劫舍Ⅰ的变形)</a></li><li><a href="#2__74" rel="nofollow">2. 打家劫舍Ⅱ</a></li><li><a href="#3__154" rel="nofollow">3. 删除并获得点数</a></li><li><a href="#4__217" rel="nofollow">4. 粉刷房子</a></li><li><a href="#5__289" rel="nofollow">5. 买卖股票的最佳时机含冷冻期</a></li><li><a href="#6__383" rel="nofollow">6. 买卖股票的最佳时机含手续费</a></li><li><a href="#7__473" rel="nofollow">7. 买卖股票的最佳时机Ⅲ</a></li><li><a href="#8__576" rel="nofollow">8. 买卖股票的最佳时机Ⅳ</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_____dp__2"></a>动态规划 - - - 简单多状态 dp 问题</h2> 
<h3><a id="1__5"></a>1. 按摩师(打家劫舍Ⅰ的变形)</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/the-masseuse-lcci/" rel="nofollow">Leetcode -面试题 17.16.按摩师</a></p> 
<p>Leetcode -面试题 17.16.按摩师</p> 
<p>题目：一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。<br> 在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p> 
<p>注意：本题相对原题稍作改动</p> 
<p>示例 1：<br> 输入：[1, 2, 3, 1]<br> 输出： 4<br> 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</p> 
<p>示例 2：<br> 输入：[2, 7, 9, 3, 1]<br> 输出： 12<br> 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</p> 
<p>示例 3：<br> 输入：[2, 1, 4, 5, 3, 1, 1, 3]<br> 输出： 12<br> 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</p> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：假设我们以以前的经验用 dp[i] 表示：选择到 i 位置时，此时的最长预约时长；但是我们这个题在 i 位置的时候，会面临「选择」或者「不选择」两种抉择，所依赖的状态需要细分：</strong></li></ol> 
<ul><li><strong>f[i] 表示：选择到 i 位置时， nums[i] 必选，此时的最长预约时长；</strong></li><li><strong>g[i] 表示：选择到 i 位置时， nums[i] 不选，此时的最长预约时长；</strong></li></ul> 
<ol start="2"><li><strong>状态转移方程：因为状态表示定义了两个，因此我们的状态转移方程也要分析两个：</strong></li></ol> 
<ul><li><strong>对于 f[i] ：如果 nums[i] 必选，那么我们仅需知道 i - 1 位置在不选的情况下的最长预约时长，然后加上 nums[i] 即可，因此 f[i] = g[i - 1] + nums[i] ；</strong></li><li><strong>对于 g[i] ：如果 nums[i] 不选，那么 i - 1 位置上选或者不选都可以。因此，我们需要知道 i - 1 位置上选或者不选两种情况下的最长时长，因此 g[i] = max(f[i - 1], g[i - 1])；</strong></li></ul> 
<ol start="3"><li><strong>返回值：根据状态表示，应该返回 max(f[n - 1], g[n - 1]) ；</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int massage(vector&lt;int&gt;&amp; nums) 
		    {
		        int n = nums.size();
		        if(n == 0) return 0;
		
		        // f[i] 表示：选择到 i 位置时， nums[i] 必选，此时的最长预约时长
		        // g[i] 表示：选择到 i 位置时， nums[i] 不选，此时的最长预约时长
		        vector&lt;int&gt; f(n), g(n);
		        f[0] = nums[0], g[0] = 0;
		
		        for(int i = 1; i &lt; n; i++)
		        {
		            f[i] = g[i - 1] + nums[i];
		            g[i] = max(f[i - 1], g[i - 1]);
		        }
		
		        return max(f[n - 1], g[n - 1]);
		    }
		};
</code></pre> 
<h3><a id="2__74"></a>2. 打家劫舍Ⅱ</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/house-robber-ii/" rel="nofollow">Leetcode -213.打家劫舍Ⅱ</a></p> 
<p>Leetcode -213.打家劫舍Ⅱ</p> 
<p>题目：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。<br> 这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。<br> 同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p> 
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p> 
<p>示例 1：<br> 输入：nums = [2, 3, 2]<br> 输出：3<br> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p> 
<p>示例 2：<br> 输入：nums = [1, 2, 3, 1]<br> 输出：4<br> 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br> 偷窃到的最高金额 = 1 + 3 = 4 。</p> 
<p>示例 3：<br> 输入：nums = [1, 2, 3]<br> 输出：3</p> 
<p>提示：</p> 
<ul><li>1 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul> 
<p><strong>思路：这一个问题是「打家劫舍I」问题的变形。上一个问题是一个「单排」的模式，这一个问题是一个「环形」的模式，也就是首尾是相连的。但<br> 是我们可以将「环形」问题转化为「两个单排」问题：</strong></p> 
<ol><li><strong>偷第一个房屋时的最大金额 x ，此时不能偷最后一个房子，因此就是偷 [0, n - 2] 区间的房子；</strong></li><li><strong>不偷第一个房屋时的最大金额 y ，此时可以偷最后一个房子，因此就是偷 [1, n - 1] 区间的房子；</strong></li></ol> 
<p><strong>两种情况下的「最大值」，就是最终的结果。因此，问题就转化成求「两次单排结果的最大值」</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		
		    int rob1(vector&lt;int&gt;&amp; nums)
		    {
		        int n = nums.size();
		        vector&lt;int&gt; f(n), g(n);
		        f[0] = nums[0], g[0] = 0;
		
		        for(int i = 1; i &lt; n; i++)
		        {
		            g[i] = max(g[i - 1], f[i - 1]);
		            f[i] = g[i - 1] + nums[i];
		        }
		
		        return max(g[n - 1], f[n - 1]);
		    }
		
		    int rob(vector&lt;int&gt;&amp; nums) 
		    {
		        if(nums.size() == 1) return nums[0];
		        
		        // 去除最后一个元素，做一次打家劫舍Ⅰ
		        vector&lt;int&gt; arr1(nums.begin() + 1, nums.end());
		
		        // 去除第一个元素，做一次打家劫舍Ⅰ
		        vector&lt;int&gt; arr2(nums.begin(), nums.end() - 1);
		
		        // 取这两个的最大值即可
		        return max(rob1(arr1), rob1(arr2));
		    }
		};
</code></pre> 
<h3><a id="3__154"></a>3. 删除并获得点数</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/delete-and-earn/" rel="nofollow">Leetcode -740.删除并获得点数</a></p> 
<p>Leetcode -740.删除并获得点数</p> 
<p>题目：给你一个整数数组 nums ，你可以对它进行一些操作。<br> 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。<br> 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p> 
<p>示例 1：<br> 输入：nums = [3, 4, 2]<br> 输出：6<br> 解释：<br> 删除 4 获得 4 个点数，因此 3 也被删除。<br> 之后，删除 2 获得 2 个点数。总共获得 6 个点数。</p> 
<p>示例 2：<br> 输入：nums = [2, 2, 3, 3, 3, 4]<br> 输出：9<br> 解释：<br> 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。<br> 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。<br> 总共获得 9 个点数。</p> 
<p>提示：</p> 
<ul><li>1 &lt;= nums.length &lt;= 2 * 10^4</li><li>1 &lt;= nums[i] &lt;= 10^4</li></ul> 
<p><strong>思路：其实这道题依旧是「打家劫舍Ⅰ」问题的变型。我们注意到题目描述，选择 x 数字的时候， x - 1 与 x + 1 是不能被选择的，像「打家劫舍」问题中，选择 i 位置的金额之后，就不能选择 i - 1 位置以及 i + 1 位置的金额。</strong></p> 
<p><strong>因此，我们可以创建一个大小为 10001 （根据题目的数据范围）的 hash 数组，将 nums 数组中每一个元素 x ，累加到 hash 数组下标为 x 的位置处，然后在 hash 数组上来一次「打家劫舍」即可。</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int deleteAndEarn(vector&lt;int&gt;&amp; nums) 
		    {
		        const int N = 10001;
		
		        int hash[N] = {0};
		        for(const auto&amp; e : nums) hash[e] += e;
		
		        vector&lt;int&gt; f(N), g(N);
		 
		        for(int i = 1; i &lt; N; i++)
		        {
		            f[i] = g[i - 1] + hash[i];
		            g[i] = max(g[i - 1], f[i - 1]);
		        }
		
		        return max(f[N - 1], g[N - 1]);
		    }
		};
</code></pre> 
<h3><a id="4__217"></a>4. 粉刷房子</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/JEj789/" rel="nofollow">Leetcode -LCR 091.粉刷房子</a></p> 
<p>Leetcode -LCR 091.粉刷房子</p> 
<p>题目：假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。<br> 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。<br> 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。<br> 请计算出粉刷完所有房子最少的花费成本。</p> 
<p>示例 1：<br> 输入 : costs = [[17, 2, 17], [16, 16, 5], [14, 3, 19]]<br> 输出 : 10<br> 解释 : 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br> 最少花费 : 2 + 5 + 3 = 10。</p> 
<p>示例 2：<br> 输入 : costs = [[7, 6, 2]]<br> 输出 : 2</p> 
<p>提示 :</p> 
<ul><li>costs.length == n</li><li>costs[i].length == 3</li><li>1 &lt;= n &lt;= 100</li><li>1 &lt;= costs[i][j] &lt;= 20</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：我们这个题在 i 位置的时候，会面临「红」「蓝」「绿」三种抉择，所依赖的状态需要细分：</strong></li></ol> 
<ul><li><strong>dp[i][0] 表示：粉刷到 i 位置的时候，最后一个位置粉刷上「红色」，此时的最小花费；</strong></li><li><strong>dp[i][1] 表示：粉刷到 i 位置的时候，最后一个位置粉刷上「蓝色」，此时的最小花费；</strong></li><li><strong>dp[i][2] 表示：粉刷到 i 位置的时候，最后一个位置粉刷上「绿色」，此时的最小花费</strong></li></ul> 
<ol start="2"><li><strong>状态转移方程：因为状态表示定义了三个，因此我们的状态转移方程也要分析三个：</strong></li></ol> 
<ul><li><strong>对于 dp[i][0] ：如果第 i 个位置粉刷上「红色」，那么 i - 1 位置上可以是「蓝色」或者「绿色」。因此我们需要知道粉刷到 i - 1 位置上的时候，粉刷上「蓝色」或者「绿色」的最小花费，然后加上 i 位置的花费即可。于是状态转移方程为： dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + costs[i - 1][0] ;</strong></li></ul> 
<p><strong>同理，我们可以推导出另外两个状态转移方程为：</strong></p> 
<ul><li><strong>dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + costs[i - 1][1] ；</strong></li><li><strong>dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + costs[i - 1][2]</strong></li></ul> 
<ol start="3"><li><strong>返回值：根据「状态表示」，应该返回最后一个位置粉刷上三种颜色情况下的最小值，因此需要返回：min(dp[n][0], min(dp[n][1], dp[n][2]))</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) 
		    {
		        int n = costs.size();
		
		        // f[i] 表示这一次选红色 
		        // g[i] 表示这一次选蓝色
		        // h[i] 表示这一次选绿色
		        vector&lt;int&gt; f(n), g(n), h(n);
		        f[0] = costs[0][0], g[0] = costs[0][1], h[0] = costs[0][2];
		
		        for(int i = 1; i &lt; n; i++)
		        {
		            f[i] = min(g[i - 1], h[i - 1]) + costs[i][0];
		            g[i] = min(f[i - 1], h[i - 1]) + costs[i][1];
		            h[i] = min(f[i - 1], g[i - 1]) + costs[i][2];
		        }
		
		        return min(min(f[n - 1], g[n - 1]), h[n - 1]); 
		    }
		};
</code></pre> 
<h3><a id="5__289"></a>5. 买卖股票的最佳时机含冷冻期</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" rel="nofollow">Leetcode -309.买卖股票的最佳时机含冷冻期</a></p> 
<p>Leetcode -309.买卖股票的最佳时机含冷冻期</p> 
<p>题目：给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。​</p> 
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票） :</p> 
<p>卖出股票后，你无法在第二天买入股票(即冷冻期为 1 天)。<br> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<p>示例 1:<br> 输入: prices = [1, 2, 3, 0, 2]<br> 输出 : 3<br> 解释 : 对应的交易状态为 : [买入, 卖出, 冷冻期, 买入, 卖出]</p> 
<p>示例 2 :<br> 输入 : prices = [1]<br> 输出 : 0</p> 
<p>提示：</p> 
<ul><li>1 &lt;= prices.length &lt;= 5000</li><li>0 &lt;= prices[i] &lt;= 1000</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：由于有「买入」「可交易」「冷冻期」三个状态，因此我们可以选择用三个数组，其中：</strong></li></ol> 
<ul><li><strong>dp[i][0] 表示：第 i 天结束后，处于「买入」状态，此时的最大利润；</strong></li><li><strong>dp[i][1] 表示：第 i 天结束后，处于「可交易」状态，此时的最大利润；</strong></li><li><strong>dp[i][2] 表示：第 i 天结束后，处于「冷冻期」状态，此时的最大利润</strong></li></ul> 
<ol start="2"><li><strong>状态转移方程：我们要谨记规则：</strong><br> <strong>i. 处于「买入」状态的时候，我们现在有股票，此时不能买股票，只能继续持有股票，或者卖出股票；</strong><br> <strong>ii. 处于「卖出」状态的时候：如果「在冷冻期」，不能买入；如果「不在冷冻期」，才能买入；</strong></li></ol> 
<ul><li><strong>对于 dp[i][0] ，我们有「两种情况」能到达这个状态：</strong><br> <strong>i. 在 i - 1 天持有股票，此时最大收益应该和 i - 1 天的保持一致： dp[i - 1][0] ；<br> ii. 在 i 天买入股票，那我们应该选择 i - 1 天不在冷冻期的时候买入，由于买入需要花钱，所以此时最大收益为： dp[i - 1][1] - prices[i]；</strong></li></ul> 
<p><strong>两种情况应取最大值，因此： dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]) 。</strong></p> 
<ul><li><strong>对于 dp[i][1] ，我们有「两种情况」能到达这个状态：</strong><br> <strong>i. 在 i - 1 天的时候，已经处于冷冻期，然后啥也不干到第 i 天，此时对应的状态为：dp[i - 1][2] ；<br> ii. 在 i - 1 天的时候，手上没有股票，也不在冷冻期，但是依旧啥也不干到第 i 天，此时对应的状态为 dp[i - 1][1] ；</strong></li></ul> 
<p><strong>两种情况应取最大值，因此： dp[i][1] = max(dp[i - 1][1], dp[i - 1][2])；</strong></p> 
<ul><li><strong>对于 dp[1][i] ，我们只有「一种情况」能到达这个状态：<br> i. 在 i - 1 天的时候，卖出股票。</strong></li></ul> 
<p><strong>因此对应的状态转移为： dp[i][2] = dp[i - 1][0] + prices[i]</strong></p> 
<ol start="3"><li><strong>初始化：三种状态都会用到前一个位置的值，因此需要初始化每一行的第一个位置：</strong></li></ol> 
<ul><li><strong>dp[0][0] ：此时要想处于「买入」状态，必须把第一天的股票买了，因此 dp[0][0] = -prices[0] ；</strong></li><li><strong>dp[0][1] ：啥也不用干即可，因此 dp[0][1] = 0 ；</strong></li><li><strong>dp[0][2] ：手上没有股票，买一下卖一下就处于冷冻期，此时收益为 0 ，因此 dp[0][2] = 0；</strong></li></ul> 
<ol start="4"><li><strong>返回值：应该返回「卖出状态」下的最大值，因此应该返回 max(dp[n - 1][1], dp[n - 1][2]) ；</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int maxProfit(vector&lt;int&gt;&amp; prices) 
		    {
		        int n = prices.size();
		        
		        // dp[i][0] 表示第 i 天处于买入状态
		        // dp[i][1] 表示第 i 天处于卖出状态
		        // dp[i][2] 表示第 i 天处于冷冻期
		        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(3));
		        dp[0][0] = -prices[0];
		
		        for(int i = 1; i &lt; n; i++)
		        {
		            dp[i][0] = max(dp[i - 1][1] - prices[i], dp[i - 1][0]);
		            dp[i][1] = max(dp[i - 1][2], dp[i - 1][1]);
		            dp[i][2] = dp[i - 1][0] + prices[i];
		        }
		
		        return max(dp[n - 1][1], dp[n - 1][2]);
		    }
		};
</code></pre> 
<h3><a id="6__383"></a>6. 买卖股票的最佳时机含手续费</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" rel="nofollow">Leetcode -714.买卖股票的最佳时机含手续费</a></p> 
<p>Leetcode -714.买卖股票的最佳时机含手续费</p> 
<p>题目：给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p> 
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p> 
<p>返回获得利润的最大值。</p> 
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p> 
<p>示例 1：<br> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2<br> 输出：8<br> 解释：能够达到的最大利润 :<br> 在此处买入 prices[0] = 1<br> 在此处卖出 prices[3] = 8<br> 在此处买入 prices[4] = 4<br> 在此处卖出 prices[5] = 9<br> 总利润 : ((8 - 1) - 2) + ((9 - 4) - 2) = 8</p> 
<p>示例 2：<br> 输入：prices = [1, 3, 7, 5, 10, 3], fee = 3<br> 输出：6</p> 
<p>提示：</p> 
<ul><li>1 &lt;= prices.length &lt;= 5 * 10^4</li><li>1 &lt;= prices[i] &lt; 5 * 10^4</li><li>0 &lt;= fee &lt; 5 * 10^4</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：由于有「买入」「可交易」两个状态，因此我们可以选择用两个数组，其中：</strong></li></ol> 
<ul><li><strong>f[i] 表示：第 i 天结束后，处于「买入」状态，此时的最大利润；</strong></li><li><strong>g[i] 表示：第 i 天结束后，处于「卖出」状态，此时的最大利润；</strong></li></ul> 
<ol start="2"><li><strong>状态转移方程：我们选择在「卖出」的时候，⽀付这个手续费，那么在「买入」的时候，就不用再考虑手续费的问题。</strong></li></ol> 
<ul><li><strong>对于 f[i] ，我们有两种情况能到达这个状态：<br> i. 在 i - 1 天「持有」股票，第 i 天啥也不干；此时最大收益为 f[i - 1] ；<br> ii. 在 i - 1 天的时候「没有」股票，在第 i 天买入股票；此时最大收益为 g[i - 1] - prices[i]) ；</strong></li></ul> 
<p><strong>两种情况下应该取最大值，因此 f[i] = max(f[i - 1], g[i - 1] - prices[i]) ；</strong></p> 
<ul><li><strong>对于 g[i] ，我们也有两种情况能够到达这个状态：<br> i. 在 i - 1 天「持有」股票，但是在第 i 天将股票卖出；此时最大收益为： f[i - 1] + prices[i] - fee) ，记得手续费；<br> ii. 在 i - 1 天「没有」股票，然后第 i 天啥也不干；此时最大收益为： g[i - 1] ；</strong></li></ul> 
<p><strong>两种情况下应该取最大值，因此 g[i] = max(g[i - 1], f[i - 1] + prices[i] - fee)；</strong></p> 
<ol start="3"><li><strong>初始化：由于需要用到前面的状态，因此需要初始化第一个位置。</strong></li></ol> 
<ul><li><strong>对于 f[0] ，此时处于「买入」状态，因此 f[0] = -prices[0] ；</strong></li><li><strong>对于 g[0] ，此时处于「没有股票」状态，啥也不干即可获得最大收益，因此 g[0] = 0</strong></li></ul> 
<ol start="4"><li><strong>返回值：应该返回「卖出」状态下，最后一天的最大值收益： g[n - 1]；</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution 
		{
		public:
		    int maxProfit(vector&lt;int&gt;&amp; prices, int fee)
		    {
		        int n = prices.size();
		        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2));
		        dp[0][0] = -prices[0];
		
		        // dp[i][0] 表⽰：第 i 天结束后，处于「买⼊」状态，此时的最⼤利润
		        // dp[i][1] 表⽰：第 i 天结束后，处于「卖出」状态，此时的最⼤利润
		        for (int i = 1; i &lt; n; i++)
		        {
		            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
		            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
		        }
		
		        return dp[n - 1][1];
		    }
		};
</code></pre> 
<h3><a id="7__473"></a>7. 买卖股票的最佳时机Ⅲ</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" rel="nofollow">Leetcode -123.买卖股票的最佳时机Ⅲ</a></p> 
<p>Leetcode -123.买卖股票的最佳时机Ⅲ</p> 
<p>题目：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<p>示例 1:<br> 输入：prices = [3, 3, 5, 0, 0, 3, 1, 4]<br> 输出：6<br> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3 - 0 = 3 。<br> 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4 - 1 = 3 。</p> 
<p>示例 2：<br> 输入：prices = [1, 2, 3, 4, 5]<br> 输出：4<br> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br> 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br> 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p> 
<p>示例 3：<br> 输入：prices = [7, 6, 4, 3, 1]<br> 输出：0<br> 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</p> 
<p>示例 4：<br> 输入：prices = [1]<br> 输出：0</p> 
<p>提示：</p> 
<ul><li>1 &lt;= prices.length &lt;= 10^5</li><li>0 &lt;= prices[i] &lt;= 10^5</li></ul> 
<p><strong>思路：</strong></p> 
<ol><li><strong>状态表示：由于有「买入」「可交易」两个状态，因此我们可以选择用两个数组。但是这道题里面还有交易次数的限制，因此我们还需要再加上一维，用来表示交易次数。其中：</strong></li></ol> 
<ul><li><strong>f[i][j] 表示：第 i 天结束后，完成了 j 次交易，处于「买入」状态，此时的最大利润；</strong></li><li><strong>g[i][j] 表示：第 i 天结束后，完成了 j 次交易，处于「卖出」状态，此时的最大利润。</strong></li></ul> 
<ol start="2"><li><strong>状态转移方程：</strong></li></ol> 
<ul><li><strong>对于 f[i][j] ，我们有两种情况到这个状态：<br> i. 在 i - 1 天的时候，交易了 j 次，处于「买入」状态，第 i 天啥也不干即可。此时最大利润为： f[i - 1][j] ；<br> ii. 在 i - 1 天的时候，交易了 j 次，处于「卖出」状态，第 i 天的时候把股票买了。此时的最大利润为： g[i - 1][j] - prices[i] ；</strong></li></ul> 
<p><strong>综上，我们要的是「最大利润」，因此是两者的最大值： f[i][j] = max(f[i - 1][j], g[i - 1][j] - prices[i]) ；</strong></p> 
<ul><li><strong>对于 g[i][j] ，我们也有两种情况可以到达这个状态：</strong><br> <strong>i. 在 i - 1 天的时候，交易了 j 次，处于「卖出」状态，第 i 天啥也不干即可。此时的最大利润为： g[i - 1][j] ；<br> ii. 在 i - 1 天的时候，交易了 j - 1 次，处于「买入」状态，第 i 天把股票卖了，然后就完成了 j 笔交易。此时的最大利润为： f[i - 1][j - 1] + prices[i] 。但是这个状态不⼀定存在，要先判断⼀下；</strong></li></ul> 
<p><strong>综上，我们要的是最大利润，因此状态转移方程为：<br> g[i][j] = g[i - 1][j];<br> if(j &gt;= 1) g[i][j] = max(g[i][j], f[i - 1][j - 1] + prices[i]);</strong></p> 
<ol start="3"><li><strong>初始化：由于需要用到 i = 0 时的状态，因此我们初始化第一行即可。</strong></li></ol> 
<ul><li><strong>当处于第 0 天的时候，只能处于「买入过一次」的状态，此时的收益为 -prices[0] ，因此 f[0][0] = - prices[0] ；</strong></li><li><strong>为了取 max 的时候，一些不存在的状态「起不到干扰」的作用，我们统统将它们初始化为 -INF （用 INT_MIN 在计算过程中会有「溢出」的风险，这里 INF 折半取 0x3f3f3f3f ，足够小即可）</strong></li></ul> 
<ol start="4"><li><strong>返回值：返回处于「卖出状态」的最大值，但是我们也「不知道是交易了几次」，因此返回 g 表最后一行的最大值。</strong></li></ol> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int maxProfit(vector&lt;int&gt;&amp; prices)
		    {
		        const int INF = 0x3f3f3f3f; // 整型最大的一半，足够大
		        int n = prices.size();
		
		        // 为了防止不存在的状态影响 max 的取值，初始化为整型最大值的一半的负数，即足够小
		        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(3, -INF));
		        vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(3, -INF));
		        f[0][0] = -prices[0], g[0][0] = 0;
		
		        // f[i][j] 表示：第 i 天结束后，完成了 j 次交易，处于「买⼊」状态，此时的最⼤利润；
		        // g[i][j] 表示：第 i 天结束后，完成了 j 次交易，处于「卖出」状态，此时的最⼤利润。
		        for (int i = 1; i &lt; n; i++)
		        {
		            for (int j = 0; j &lt; 3; j++)
		            {
		                f[i][j] = max(f[i - 1][j], g[i - 1][j] - prices[i]);
		
		                if (j &gt;= 1) g[i][j] = max(g[i - 1][j], f[i - 1][j - 1] + prices[i]);
		                else g[i][j] = g[i - 1][j];
		            }
		        }
		
		        int ret = 0;
		        for (int i = 0; i &lt; 3; i++) ret = max(ret, g[n - 1][i]);
		        return ret;
		    }
		};
</code></pre> 
<h3><a id="8__576"></a>8. 买卖股票的最佳时机Ⅳ</h3> 
<p><strong>题目链接</strong> -&gt; <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" rel="nofollow">Leetcode -188.买卖股票的最佳时机Ⅳ<br> </a></p> 
<p>Leetcode -188.买卖股票的最佳时机Ⅳ</p> 
<p>题目：给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。<br> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。<br> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> 
<p>示例 1：<br> 输入：k = 2, prices = [2, 4, 1]<br> 输出：2<br> 解释：在第 1 天(股票价格 = 2) 的时候买入，在第 2 天(股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4 - 2 = 2 。</p> 
<p>示例 2：<br> 输入：k = 2, prices = [3, 2, 6, 5, 0, 3]<br> 输出：7<br> 解释：在第 2 天(股票价格 = 2) 的时候买入，在第 3 天(股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6 - 2 = 4 。<br> 随后，在第 5 天(股票价格 = 0) 的时候买入，在第 6 天(股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3 - 0 = 3 。</p> 
<p>提示：</p> 
<ul><li>1 &lt;= k &lt;= 100</li><li>1 &lt;= prices.length &lt;= 1000</li><li>0 &lt;= prices[i] &lt;= 1000</li></ul> 
<p><strong>思路：本题思路与上题思路类似，只是上题最多可以交易两次，本题是可以交易 k 次，所以在代码上稍作修改即可；</strong></p> 
<p>代码如下：</p> 
<pre><code>		class Solution {
		public:
		    int maxProfit(int k, vector&lt;int&gt;&amp; prices)
		    {
		        const int INF = 0x3f3f3f3f;
		        int n = prices.size();
		        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(k + 1, -INF)), g(n, vector&lt;int&gt;(k + 1, -INF));
		        f[0][0] = -prices[0], g[0][0] = 0;
		
		        // f[i][j] 表示第 i 天结束后，进行了 j 次交易，此时处于买入状态，此时的最大利益
		        // g[i][j] 表示第 i 天结束后，进行了 j 次交易，此时处于卖出状态，此时的最大利益   
		        for (int i = 1; i &lt; n; i++)
		        {
		            for (int j = 0; j &lt; k + 1; j++)
		            {
		                f[i][j] = max(f[i - 1][j], g[i - 1][j] - prices[i]);
		
		                if (j &gt;= 1) g[i][j] = max(g[i - 1][j], f[i - 1][j - 1] + prices[i]);
		                else g[i][j] = g[i - 1][j];
		            }
		        }
		
		        int ret = 0;
		        for (int i = 0; i &lt; k + 1; i++) ret = max(ret, g[n - 1][i]);
		        return ret;
		    }
		};
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dcb064c68928f34582a991acfee8309c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue2使用axios封装请求数据，教会你封装，简单易懂，轻松学会axios封装请求数据 看一眼就会 手把手教会</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7766b25efbc9108a6434f531c54d284/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android ORM 框架之 greenDAO</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>