<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构刷题训练——链表篇（一） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9944702b85e91ea4a5d1b26f9b8df418/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构刷题训练——链表篇（一）">
  <meta property="og:description" content="目录
前言
题目一：链表的中间节点
思路
分析
题解
题目二：链表中倒数第k个结点
思路
分析
题解
题目三：合并两个有序链表
思路
分析
题解
方法二
题解
题目四：链表的回文结构
思路
分析
题解
总结
前言 今天我将开启一个新的专栏，数据结构与算法刷题训练营，题目从基础简单题目开始逐步进阶，以便于初学者巩固和运用所学的知识。
题目一：链表的中间节点 题目描述：
示例与提示：
题目链接
链表的中间节点https://leetcode.cn/problems/middle-of-the-linked-list/description/
思路 题目中的链表属于单链表，我们要怎么计算中间节点呢？先遍历一遍链表统计链表节点个数，然后计算出中间节点，再遍历到需要返回的节点。这或许是大多数人能想到的方法。但是这种方法效率太低。今天我向大家介绍一种新的做题思路，这种方法在其他题目中也是适用。
快慢指针法：
我们可以创建两个指针，一个快指针一次走两步，一个慢指针一次走一步。当快指针走到尾时，返回慢指针就是中间节点。
分析 情况一：
节点为奇数个。
假设节点有5个，那需要返回的节点就是第3个节点。初始时，两指针都指向第一个节点，慢指针一次走一步，快指针一次走两步。执行一次情况如上图。当快指针走到最后一个节点时就要结束如下图：
情况二：
节点为偶数个。
这是已经执行两次后的状态，接下来fast指针继续走：
fast指向NULL，而slow指向要返回的节点。
题解 了解完整体思路，我们依据分析中的情况进行编写代码：
struct ListNode* middleNode(struct ListNode* head) { struct ListNode* fast=head,*slow=head; while(fast&amp;&amp;fast-&gt;next) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; } return slow; } 题目二：链表中倒数第k个结点 题目描述：
题目链接
倒数第k个节点https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking
思路 这道题目依然可以使用快慢指针的方法来寻找倒数第k个节点。先让快指针走k步，然后让两指针同时向后移动，知道快指针遍历完链表结束。
分析 初始情况下，两指针都指向第一个节点，先让fast指针走k步：
我们假设要找倒数第3个节点，fast走3步就指向了第四个节点。
然后两指针开始同时移动：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-06T14:32:59+08:00">
    <meta property="article:modified_time" content="2023-08-06T14:32:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构刷题训练——链表篇（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9" rel="nofollow">题目一：链表的中间节点</a></p> 
<p id="%C2%A0%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%80%9D%E8%B7%AF" rel="nofollow">思路</a></p> 
<p id="%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E5%88%86%E6%9E%90" rel="nofollow">分析</a></p> 
<p id="%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3" rel="nofollow">题解</a></p> 
<p id="%C2%A0%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%9A%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9-toc" style="margin-left:0px;"><a href="#%C2%A0%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%9A%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9" rel="nofollow"> 题目二：链表中倒数第k个结点</a></p> 
<p id="%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF" rel="nofollow">思路</a></p> 
<p id="%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E5%88%86%E6%9E%90" rel="nofollow">分析</a></p> 
<p id="%C2%A0%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%C2%A0%E9%A2%98%E8%A7%A3" rel="nofollow"> 题解</a></p> 
<p id="%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">题目三：合并两个有序链表</a></p> 
<p id="%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF" rel="nofollow">思路</a></p> 
<p id="%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E5%88%86%E6%9E%90" rel="nofollow">分析</a></p> 
<p id="%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3" rel="nofollow">题解</a></p> 
<p id="%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C" rel="nofollow"> 方法二</a></p> 
<p id="%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3" rel="nofollow">题解</a></p> 
<p id="%C2%A0%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%C2%A0%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84" rel="nofollow"> 题目四：链表的回文结构</a></p> 
<p id="%E6%80%9D%E8%B7%AF-toc" style="margin-left:40px;"><a href="#%E6%80%9D%E8%B7%AF" rel="nofollow">思路</a></p> 
<p id="%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E5%88%86%E6%9E%90" rel="nofollow">分析</a></p> 
<p id="%E9%A2%98%E8%A7%A3-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E8%A7%A3" rel="nofollow">题解</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<div> 
 <p></p> 
</div> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p>        今天我将开启一个新的专栏，数据结构与算法刷题训练营，题目从基础简单题目开始逐步进阶，以便于初学者巩固和运用所学的知识。</p> 
<hr> 
<h2 id="%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9">题目一：链表的中间节点</h2> 
<p> 题目描述：<img alt="" height="197" src="https://images2.imgbox.com/6d/13/XHvTomn4_o.png" width="626"></p> 
<p> 示例与提示：</p> 
<p><img alt="" height="630" src="https://images2.imgbox.com/6d/e5/AKu3BzYS_o.png" width="892"></p> 
<p> <strong>题目链接<br><br><a class="link-info has-card" href="https://leetcode.cn/problems/middle-of-the-linked-list/description/" rel="nofollow" title="链表的中间节点"><span class="link-card-box"><span class="link-title">链表的中间节点</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/45/2e/8KMUMvNK_o.png" alt="icon-default.png?t=N6B9">https://leetcode.cn/problems/middle-of-the-linked-list/description/</span></span></a></strong></p> 
<h3 id="%C2%A0%E6%80%9D%E8%B7%AF"> 思路</h3> 
<p>        题目中的链表属于单链表，我们要怎么计算中间节点呢？先遍历一遍链表统计链表节点个数，然后计算出中间节点，再遍历到需要返回的节点。这或许是大多数人能想到的方法。但是这种方法效率太低。今天我向大家介绍一种新的做题思路，这种方法在其他题目中也是适用。</p> 
<p><strong>快慢指针法：</strong></p> 
<p>        我们可以创建两个指针，一个快指针一次走两步，一个慢指针一次走一步。当快指针走到尾时，返回慢指针就是中间节点。</p> 
<h3 id="%E5%88%86%E6%9E%90">分析</h3> 
<p>情况一：</p> 
<p>节点为奇数个。</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/4e/b5/aq9PSrah_o.png" width="823"></p> 
<p>         假设节点有5个，那需要返回的节点就是第3个节点。初始时，两指针都指向第一个节点，慢指针一次走一步，快指针一次走两步。执行一次情况如上图。当快指针走到最后一个节点时就要结束如下图：</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/02/c5/0caIY1yP_o.png" width="781"></p> 
<p> 情况二：</p> 
<p>节点为偶数个。</p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/3e/ac/XZo7S1Ay_o.png" width="948"></p> 
<p>         这是已经执行两次后的状态，接下来fast指针继续走：</p> 
<p><img alt="" height="242" src="https://images2.imgbox.com/91/c7/kZdYnDAf_o.png" width="1011"></p> 
<p>         fast指向NULL，而slow指向要返回的节点。</p> 
<h3 id="%E9%A2%98%E8%A7%A3">题解</h3> 
<p>         了解完整体思路，我们依据分析中的情况进行编写代码：</p> 
<pre><code class="language-cpp">struct ListNode* middleNode(struct ListNode* head)
{
    struct ListNode* fast=head,*slow=head;
    while(fast&amp;&amp;fast-&gt;next)
    {
        slow=slow-&gt;next;
        fast=fast-&gt;next-&gt;next;
    }
    return slow;

}</code></pre> 
<p> <img alt="" height="354" src="https://images2.imgbox.com/65/29/k7NfW7Jh_o.png" width="868"></p> 
<h2 id="%C2%A0%E9%A2%98%E7%9B%AE%E4%BA%8C%EF%BC%9A%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"> 题目二：链表中倒数第k个结点</h2> 
<p> 题目描述：<img alt="" height="504" src="https://images2.imgbox.com/5e/e9/hphWRYgi_o.png" width="913"></p> 
<p> <strong>题目链接</strong></p> 
<p><strong><a class="link-info has-card" href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="倒数第k个节点"><span class="link-card-box"><span class="link-title">倒数第k个节点</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/04/1f/xWT4WysX_o.png" alt="icon-default.png?t=N6B9">https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking</span></span></a></strong></p> 
<h3 id="%E6%80%9D%E8%B7%AF">思路</h3> 
<p>         这道题目依然可以使用快慢指针的方法来寻找倒数第k个节点。先让快指针走k步，然后让两指针同时向后移动，知道快指针遍历完链表结束。</p> 
<h3>分析</h3> 
<p>         初始情况下，两指针都指向第一个节点，先让fast指针走k步：</p> 
<p>        我们假设要找倒数第3个节点，fast走3步就指向了第四个节点。</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/d0/e4/TxgyxV6C_o.png" width="947"></p> 
<p>         然后两指针开始同时移动：</p> 
<p><img alt="" height="666" src="https://images2.imgbox.com/a0/84/5NnGA9C5_o.png" width="1122"></p> 
<p>         当fast指针指向NULL时就结束，此时slow指向的就是倒数第k个节点。</p> 
<h3 id="%C2%A0%E9%A2%98%E8%A7%A3"> 题解</h3> 
<p> 根据上述的分析，我们进行编写代码：</p> 
<pre><code class="language-cpp">struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) {
    struct ListNode* fast=pListHead,*slow=pListHead;
    
        
    for(int i=0;i&lt;k;i++)
    {
        if(fast==NULL)
        {
            return NULL;
        }
        fast=fast-&gt;next;
    }
    while(fast)
    {
        fast=fast-&gt;next;
        slow=slow-&gt;next;
    }
    return slow;
}</code></pre> 
<p>        在代码实现时要注意特殊情况，如果链表为NULL或者k大于链表长度，传进来就要进行特殊处理。</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/9a/63/RAgexZsg_o.png" width="919"></p> 
<h2 id="%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">题目三：合并两个有序链表</h2> 
<p> 题目描述：</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/67/17/YQzDRDhJ_o.png" width="850"></p> 
<p> 示例：</p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/9c/df/3b4cZV9Q_o.png" width="873"></p> 
<p> 题目链接：</p> 
<p><a class="link-info has-card" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/" rel="nofollow" title="合并两个有序链表"><span class="link-card-box"><span class="link-title">合并两个有序链表</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/47/05/fJSYGdCv_o.png" alt="icon-default.png?t=N6B9">https://leetcode.cn/problems/merge-two-sorted-lists/description/</span></span></a></p> 
<h3>思路</h3> 
<p>        题目中给的是升序数组，解题思路就是比较链表元素，取小的进行尾插。思路较为简单。</p> 
<h3>分析</h3> 
<p> 接下来我们对整体规划进行分析假设初始时：</p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/58/f9/6L0ovuA9_o.png" width="650"></p> 
<p>         把一个链表的元素插入到另一个链表这样操作太麻烦，所以我们可以重新创建一个头指针，将两个链表上的节点插入到新的链表中，创建新链表时，初始化头和尾都为NULL。</p> 
<p> <img alt="" height="436" src="https://images2.imgbox.com/6d/27/snHkYxry_o.png" width="683"></p> 
<p>         然后进行比较，第一步两个大小相同，任取一个插入：</p> 
<p> <img alt="" height="439" src="https://images2.imgbox.com/8e/02/k8gGVhaT_o.png" width="682"></p> 
<p>         然后再拿着list2中的第一个节点与list1节点进行比较，插入：</p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/55/71/x21D6eEm_o.png" width="1105"></p> 
<p>         以此类推不断进行比较尾插。</p> 
<p> <img alt="" height="484" src="https://images2.imgbox.com/df/de/ATrRed9H_o.png" width="1120"></p> 
<p>        结束条件就是一个链表为NULL结束 </p> 
<p> <img alt="" height="272" src="https://images2.imgbox.com/1f/d3/xk3bdFgK_o.png" width="967"></p> 
<p>         最后将剩余节点的链表尾插到新链表中，返回新链表的头。</p> 
<p></p> 
<h3>题解</h3> 
<p>        理解了思路就根据分析的内容进行编写代码：</p> 
<pre><code class="language-cpp">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)
{
    if(list1==NULL)                //考虑原链表中有空链表的情况。
        return list2;
    if(list2==NULL)
        return list1;
    struct ListNode* head=NULL,*tail=NULL;
    while(list1&amp;&amp;list2)
    {
        if(list1-&gt;val &gt; list2-&gt;val)//比较大小取小的尾插
        {
            if(head==NULL)         //考虑特殊情况新建链表为NULL时进行特殊处理
            {
                tail=head=list2;
                
            }
            else                   //尾插
            {
                tail-&gt;next=list2;
                tail=tail-&gt;next;
            }
            list2=list2-&gt;next;    //尾插后继续向后
        }
        else
        {
             if(head==NULL)
            {
              tail=head=list1;
               
            }
           else
           {
                tail-&gt;next=list1;
                tail=tail-&gt;next;
           }
           
            list1=list1-&gt;next;
        }
    }
    if(list2==NULL)            //一个链表为NULL时将另一个链表剩余的节点尾插到新链表。
        tail-&gt;next=list1;
    else
        tail-&gt;next=list2;
    return head;
}</code></pre> 
<p> 虽然思路非常简单，但是代码实现却很不容易，需要很多要考虑的特殊情况。</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/a1/8d/j4yxtbeV_o.png" width="857"> </p> 
<h3 id="%C2%A0%E6%96%B9%E6%B3%95%E4%BA%8C"> 方法二</h3> 
<p>        和思路一相同，也是比较大小，将小的尾插到新的链表。但是可以使用带头结点的链表，这样再插入时就不需要考虑新链表为NULL时的情况，进行特殊处理。可以更好的简化代码。</p> 
<h3>题解</h3> 
<pre><code class="language-cpp">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)
{
    if(list1==NULL)
        return list2;
    if(list2==NULL)
        return list1;
    struct ListNode* head=NULL,*tail=NULL;
    head=tail=(struct ListNode*)malloc(sizeof(struct ListNode));
    while(list1&amp;&amp;list2)
    {
        if(list1-&gt;val &gt; list2-&gt;val)
        {
           
            
            tail-&gt;next=list2;
            tail=tail-&gt;next;
            list2=list2-&gt;next;
        }
        else
        {
             
            tail-&gt;next=list1;
            tail=tail-&gt;next;
           
            list1=list1-&gt;next;
        }
    }
    if(list2==NULL)
        tail-&gt;next=list1;
    else
        tail-&gt;next=list2;
    struct ListNode* del=head;
    head=head-&gt;next;
    free(del);
    return head;
}</code></pre> 
<p>         <strong>注意：</strong>原链表中不带头节点，返回时不能返回头节点，需要将头节点释放掉，返回头节点的下一个节点。</p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/02/3c/dkSQ4sP4_o.png" width="863"></p> 
<p> </p> 
<h2 id="%C2%A0%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%9A%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84"> 题目四：链表的回文结构</h2> 
<p>题目描述：</p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/a3/03/lyuREdiQ_o.png" width="897"></p> 
<p> 题目链接：</p> 
<p><a class="link-info has-card" href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking" rel="nofollow" title="链表的回文结构"><span class="link-card-box"><span class="link-title">链表的回文结构</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/12/52/Fzm8787g_o.png" alt="icon-default.png?t=N6B9">https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking</span></span></a></p> 
<h3>思路</h3> 
<p>        有人可能会想，这不很简单吗？把这个链表反转一下，再和原链表数据依次比较不就解决了，但是这里注意题目要求。</p> 
<p>        题目要求时间复杂度为O(N)，空间复杂度为O(1)，上述思路需要将原链表复制一份后才可以与逆置是链表进行比较，空间复杂度为O(N)。</p> 
<p>        这道题的思路是这样的，可以先找到链表的中间节点，然后从中间节点开始，对后部分的链表进行逆置，然后从中间开始与开头的节点对比，看两个值是否相同。</p> 
<h3>分析</h3> 
<p> 情况一：</p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/a2/57/CiHkY9rc_o.png" width="694"></p> 
<p>         节点为偶数个，把后半部分节点逆置，然后依次比较，这里注意其实前半部分的2节点的next这时依然指向的是后半部分的2，后半部分的2节点的next指向NULL。如下图：</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/4c/76/crMQou7u_o.png" width="640"></p> 
<p> 逆置之后，返回的是后半部分1节点的地址，然后进行遍历，直到为NULL结束。</p> 
<p>情况二：</p> 
<p>        节点数量为奇数个</p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/5f/6f/jZcoNIAX_o.png" width="889"></p> 
<p> 实际情况和上述一样：</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/8a/d8/fKdLhwpA_o.png" width="777"></p> 
<p>         但这里在比较的时候就要注意一下3节点，这里不需要把前半部分2节点的next置为NULL，当遍历到最后时，都遍历到了3节点一定是相同的</p> 
<h3>题解</h3> 
<p>        当然这些逆置、找中间节点的接口我们已经写过了，可以CV一下前边的代码，这样写代码还是很舒服的Ctrl+C、Ctrl+V</p> 
<p>        当然借此我再介绍一种新的逆置链表的方法，我们可以使用头插来实现链表逆置。将原链表的节点依次头插到新的节点，这样就轻松实现了逆置。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">struct ListNode* reverseList(struct ListNode* head)
{
    struct ListNode* cur=head;
    struct ListNode* newhead=NULL;
    while(cur)
    {
        struct ListNode* next=cur-&gt;next;
    //头插
        cur-&gt;next=newhead;
        newhead=cur;

        cur=next;
    }
    return newhead;
}</code></pre> 
<p> 整体题解：</p> 
<pre><code class="language-cpp">class PalindromeList {
public:
struct ListNode* reverseList(struct ListNode* head)
{
    struct ListNode* cur=head;
    struct ListNode* newhead=NULL;
    while(cur)
    {
        struct ListNode* next=cur-&gt;next;
        cur-&gt;next=newhead;
        newhead=cur;

        cur=next;
    }
    return newhead;
}

struct ListNode* middleNode(struct ListNode* head)
{
    struct ListNode* fast=head,*slow=head;
    while(fast &amp;&amp; fast-&gt;next)
    {
        slow=slow-&gt;next;
        fast=fast-&gt;next-&gt;next;
        
    }
    return slow;
}

    bool chkPalindrome(ListNode* A) {
        struct ListNode* mid=middleNode(A);//中间节点
        struct ListNode* rmid=reverseList(mid);//反转后的中间节点

       while(A &amp;&amp; rmid)    
       {
        if(A-&gt;val!=rmid-&gt;val)
        {
            return false;
        }
        else
        {
            rmid=rmid-&gt;next;
            A=A-&gt;next;
        }
       }
       return true;
    }
};</code></pre> 
<p> <img alt="" height="238" src="https://images2.imgbox.com/c0/9d/OnMzaHuk_o.png" width="901"></p> 
<hr> 
<p> </p> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p>        好的本期内容到此结束，后续我将会分享更多数据结构相关的题目，通过画图逐步分析，来帮助大家刷题，这些题目建议大家先做一遍，然后看思路与分析，一定要动手敲一敲代码。最后，感谢阅读!</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9010acf725fa40a79fc4f0d2fa0f9fe5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springcloud微服务架构（eureka、nacos、ribbon、feign、gateway等组件的详细介绍和使用）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/369d7004ac2ac8184e95e8a0dc576ef0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">全网最清晰JAVA NIO，看一遍就会</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>