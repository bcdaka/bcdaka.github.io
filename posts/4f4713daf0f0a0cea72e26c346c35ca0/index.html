<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法--顺序表(Java) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4f4713daf0f0a0cea72e26c346c35ca0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构与算法--顺序表(Java)">
  <meta property="og:description" content="📝个人主页🌹：誓则盟约
⏩收录专栏⏪：Java SE
🤡往期回顾🤡：Java SE--基本数据类型（详细讲解）
🌹🌹期待您的关注 🌹🌹
什么是顺序表？ 顺序表是一种线性表的数据结构。顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素。 顺序表的主要特点： 逻辑上相邻的元素在物理位置上也相邻。可以随机访问表中的任意元素，通过元素的位置序号可以在 O(1) 的时间复杂度内直接获取对应元素。插入和删除操作的效率相对较低。例如，在顺序表的中间位置插入一个元素，需要移动大量后续元素，时间复杂度为 O(n) ；删除操作同理。 顺序表的优点： 随机访问速度快，能够快速获取指定位置的元素。存储密度高，不需要额外的指针来链接元素。 顺序表的缺点： 长度固定，不易扩展。插入和删除操作可能涉及大量元素的移动，效率较低。 举个例子，如果有一个顺序表存储了学生的成绩 [85, 90, 78, 95, 88] ，如果要获取第三个学生的成绩，直接通过索引 2 就能快速得到 78 。但如果要在第二个位置插入一个新成绩 80 ，就需要将后面的元素 90, 78, 95, 88 依次向后移动一位，然后再插入 80 。
顺序表在很多程序设计中都有应用，比如简单的数组实现、一些对随机访问要求较高而插入删除操作较少的场景等，今天我们用java来简单实现一下顺序表。
构造方法： 首先，构造一个顺序表，需要int capacity 表示顺序表的内存大小(这里先传入一个值作为参数，后面内存不够用我们会有专门申请内存的方法)、int size表示表里面元素的个数、Object [] array 来命名这个顺序表，这时候一个最基本的顺序表就被构造出来了，以下是代码实现：
public class Linear_List&lt;E&gt; { private int capacity = 10; private int size=0; private Object [] array = new Object [capacity]; 添加方法： 要对顺序表array进行添加操作，需要传入两个参数 泛型 element 以及 int index，代表在index下标插入 泛型 element。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T19:25:09+08:00">
    <meta property="article:modified_time" content="2024-07-26T19:25:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法--顺序表(Java)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>📝个人主页🌹：<a href="https://blog.csdn.net/Xxy_1008?spm=1010.2135.3001.5343" title="誓则盟约">誓则盟约</a><br> ⏩收录专栏⏪：<a href="https://blog.csdn.net/xxy_1008/category_12731002.html?spm=1001.2014.3001.5482" title="Java SE">Java SE</a><br> 🤡往期回顾🤡：<a href="https://blog.csdn.net/Xxy_1008/article/details/140457830" title="Java SE--基本数据类型（详细讲解）">Java SE--基本数据类型（详细讲解）</a><br> 🌹🌹期待您的关注 🌹🌹</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/aa/65/EqoX124e_o.gif"></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2d/dc/zll0isb0_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/93/XZiFDHGb_o.gif"></p> 
<h2>什么是顺序表？</h2> 
<ul><li><strong>顺序表</strong>是一种<strong>线性表</strong>的数据结构。</li><li>顺序表是用一组<strong>地址连续</strong>的存储单元<strong>依次存储</strong>线性表中的数据元素。</li></ul> 
<h4><strong>顺序表的主要特点：</strong></h4> 
<ol><li>逻辑上相邻的元素在物理位置上也相邻。</li><li>可以随机访问表中的任意元素，通过元素的位置序号可以在 <code>O(1)</code> 的时间复杂度内直接获取对应元素。</li><li>插入和删除操作的效率相对较低。例如，在顺序表的中间位置插入一个元素，需要移动大量后续元素，时间复杂度为 <code>O(n)</code> ；删除操作同理。</li></ol> 
<h4><strong>顺序表的优点：</strong></h4> 
<ol><li>随机访问速度快，能够快速获取指定位置的元素。</li><li>存储密度高，不需要额外的指针来链接元素。</li></ol> 
<h4><strong>顺序表的缺点：</strong></h4> 
<ol><li>长度固定，不易扩展。</li><li>插入和删除操作可能涉及大量元素的移动，效率较低。</li></ol> 
<p>        举个例子，如果有一个顺序表存储了学生的成绩 <code>[85, 90, 78, 95, 88]</code> ，如果要获取第三个学生的成绩，直接通过索引 <code>2</code> 就能快速得到 <code>78</code> 。但如果要在第二个位置插入一个新成绩 <code>80</code> ，就需要将后面的元素 <code>90, 78, 95, 88</code> 依次向后移动一位，然后再插入 <code>80</code> 。</p> 
<p>        顺序表在很多程序设计中都有应用，比如简单的数组实现、一些对随机访问要求较高而插入删除操作较少的场景等，今天我们用java来简单实现一下顺序表。</p> 
<hr> 
<h3>构造方法：    </h3> 
<p>    首先，构造一个顺序表，需要int capacity 表示顺序表的内存大小(这里先传入一个值作为参数，后面内存不够用我们会有专门申请内存的方法)、int size表示表里面元素的个数、Object [] array 来命名这个顺序表，这时候一个最基本的顺序表就被构造出来了，以下是代码实现：</p> 
<pre><code class="language-java">public class Linear_List&lt;E&gt; {

    private  int capacity = 10;
    private int size=0;
    private Object [] array = new Object [capacity];</code></pre> 
<h3>添加方法：</h3> 
<p>        要对顺序表array进行添加操作，需要传入两个参数 泛型 element 以及 int index，代表在index下标插入 泛型 element。</p> 
<p>        <strong>注意：这里需要判断 index 和 size 的大小，如果index&lt;0 || index&gt;size,则理应抛出错误。</strong></p> 
<p>        在index位置插入元素，只需要将原来index以及index后面的元素往后移一位，空出来的位置给element即可。下面是添加方法的代码实现：</p> 
<pre><code class="language-java">public void add(E element , int index) {
        if (index&lt;0 || index&gt;size)
            throw new IndexOutOfBoundsException("Index out of bounds");
        for (int i = size; i &gt;index; i--) {
        array[i] = array[i-1];
        }
        array[index] = element;
        size++;
    }</code></pre> 
<p>        但是<strong>当顺序表中存储的元素数量达到当前分配的存储空间上限时，就需要进行扩容</strong>。具体来说，常见的情况有：</p> 
<ul><li><strong>持续向顺序表中添加元素，导致已分配的存储空间被填满。</strong></li></ul> 
<p>        例如，最初分配的顺序表空间能存储 10 个整数，当已经存储了 10 个整数后，如果还需要继续添加新的整数，就需要扩容。</p> 
<ul><li><strong>事先无法准确预估元素数量，且实际存储的元素数量超出了初始的预计。</strong></li></ul> 
<p>        假设一个用于存储用户订单信息的顺序表，由于促销活动导致订单数量大幅增加，超出了初始分配的空间。</p> 
<ul><li><strong>业务需求发生变化，导致需要存储更多的元素。</strong></li></ul> 
<p>        比如原本的系统只需要存储一个月内的交易记录，但业务调整后需要存储半年甚至更长时间的交易记录，原有的顺序表空间可能就不够了。</p> 
<p>        在进行扩容时，通常会<strong>重新分配一块更大的连续存储空间</strong>，并将原有的元素复制到新的空间中。扩容的策略可以是按照一定的比例增加空间，例如每次扩容为原来的两倍；也可以是增加固定的大小，如每次增加一定数量的存储单元，<strong>原来的那块空间也并不会造成空间浪费，通常会被JVM的垃圾回收机制自动回收。</strong></p> 
<p>        <strong>通常把扩容操作放在添加方法内部</strong>，因为在添加元素时才会有可能需要用到扩容操作，以下是添加了扩容操作的添加方法的代码实现：</p> 
<pre><code class="language-java">public void add(E element, int index) {
    // 如果索引不在有效范围内，抛出异常
    if (index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException("Index out of bounds");
    // 如果当前元素数量达到容量，进行扩容操作
    if (size &gt;= capacity) {  
        int newCapacity = capacity * 2;  // 新容量为原容量的两倍
        Object[] newArray = new Object[newCapacity];  // 创建新的数组
        System.arraycopy(array, 0, newArray, 0, size);  // 将原数组内容复制到新数组
        array = newArray;  // 更新数组引用
        capacity = newCapacity;  // 更新容量
    }
    // 将指定索引及之后的元素向后移动一位
    for (int i = size; i &gt; index; i--) {
        array[i] = array[i - 1];
    }
    array[index] = element;  // 在指定索引位置插入新元素
    size++;  // 元素数量加 1
}</code></pre> 
<h3>删除方法：</h3> 
<p>        首先，要检查删除操作中指定的索引是否合法。<strong>如果索引小于 0 或者大于等于顺序表的当前元素数量，就会抛出一个索引越界的异常</strong>，因为这样的索引不存在有效的元素可删除。</p> 
<p>        若索引合法，就将指定索引位置之后的元素依次向前移动一位，覆盖要删除的元素位置。然后，把原本顺序表的最后一个位置设置为 <code>null</code>，并将顺序表的元素数量减 1，表示完成了一个元素的删除操作。以下是删除方法的代码实现：</p> 
<pre><code class="language-java">public E remove(int index) {
        if (index&lt;0 || index&gt;size-1)  throw new IndexOutOfBoundsException("Index out of bounds");
        E key = (E) array[index];
        for (int i = index; i &lt;size; i++) {
            array[i] = array[i+1];
        }size--;
        return key;
    }
</code></pre> 
<h3>判空和get方法：</h3> 
<p>        <strong>判空方法通常用于判断顺序表是否为空。</strong>这可以通过检查顺序表中元素的数量来实现。如果元素数量为 0 ，则认为顺序表为空。</p> 
<p>       <strong> get方法用于获取顺序表中指定索引位置的元素。</strong>在实现时，需要先检查索引的合法性，如果索引不合法（小于 0 或大于等于元素数量），则抛出异常。如果索引合法，就返回该索引位置的元素。以下是两种方法的代码实现：</p> 
<pre><code class="language-java"> public boolean is_Empty(){
        return size==0;
    }

    public E get(int index) {
        if (index&lt;0 || index&gt;size-1)  throw new IndexOutOfBoundsException("Index out of bounds");
        return (E) array[index];
    }</code></pre> 
<h3>转字符串输出(toString)方法：</h3> 
<p>        toString方法其主要目的是将顺序表的相关信息以字符串的形式进行展示。通常会先获取顺序表中实际存储元素的数组部分，并将其转换为字符串表示。同时，还会获取顺序表中当前元素的数量。</p> 
<p>        当调用顺序表对象的 <code>toString</code> 方法时，就能得到一个清晰反映顺序表内部状态的字符串描述，方便进行输出、调试或其他需要以字符串形式获取顺序表信息的操作。以下是toString方法的代码实现：</p> 
<pre><code class="language-java">    public String toString() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; size; i++){
        builder.append(array[i]).append(" "); }
        return builder.toString();
    }</code></pre> 
<h3><strong>完整代码实现：</strong></h3> 
<pre><code class="language-java">public class Linear_List&lt;E&gt; {

    private  int capacity = 10;
    private int size=0;
    private Object [] array = new Object [capacity];
    public void add(E element , int index) {
        if (index&lt;0 || index&gt;size)
            throw new IndexOutOfBoundsException("Index out of bounds");
        if (size&gt;=capacity){  // 扩容
            int newCapacity = capacity*2;
            Object[] newArray = new Object[newCapacity];
            System.arraycopy(array,0,newArray,0,size);
            array = newArray;
            capacity = newCapacity;
        }
        for (int i = size; i &gt;index; i--) {
        array[i] = array[i-1];
        }
        array[index] = element;
        size++;
    }

    public E remove(int index) {
        if (index&lt;0 || index&gt;size-1)  throw new IndexOutOfBoundsException("Index out of bounds");
        E key = (E) array[index];
        for (int i = index; i &lt;size; i++) {
            array[i] = array[i+1];
        }size--;
        return key;
    }

    public boolean is_Empty(){
        return size==0;
    }

    public E get(int index) {
        if (index&lt;0 || index&gt;size-1)  throw new IndexOutOfBoundsException("Index out of bounds");
        return (E) array[index];
    }

    public String toString() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; size; i++) { builder.append(array[i]).append(" "); }
        return builder.toString();
    }
}
</code></pre> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4a/d4/iFpHK47h_o.jpg"></p> 
<h2 style="text-align:center;"><span style="color:#0d0016;"><span style="background-color:#ff9900;">“静静地目送，享受这一刻，在混乱之中。”——《xingyu_xuan》</span></span></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8614afb07b63191b17760b9791f3788f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AI人工智能】文心智能体，00后疯感工牌生成器，低代码工作流的简单应用以及图片快速响应解决方案，干货满满，不容错过哦</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81543bb048dff7b55e1fd6dda480073a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大疆创新2025校招内推</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>