<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详细说明Java中Map和Set接口的使用方法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8bc1971884e76d9d2f741eb12ffc91fb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="详细说明Java中Map和Set接口的使用方法">
  <meta property="og:description" content="Map与Set的基本概念与场景 Map和set是一种专门用来进行搜索的容器或者数据结构，其搜索的效率与其具体的实例化子类有关。以前常见的搜索方式有：
1. 直接遍历，时间复杂度为O(N)，元素如果比较多效率会非常慢。
2. 二分查找，时间复杂度为,但搜索前必须要求序列是有序的。
上述排序比较适合静态类型的查找，即一般不会对区间进行插入和删除操作了，而现实中的查找比如：
1. 根据姓名查询考试成绩
2. 通讯录，即根据姓名查询联系方式
3. 不重复集合，即需要先搜索关键字是否已经在集合中
可能在查找时进行一些插入和删除的操作，即动态查找，那上述两种方式就不太适合了，本节介绍的Map和Set是一种适合动态查找的集合容器。
模型概念 一般把搜索的数据称为关键字（Key），和关键字对应的称为值（Value），将其称之为Key-value的键值对，所以模型会有两种：
纯 key 模型，例如： 有一个英文词典，快速查找一个单词是否在词典中快速查找某个名字在不在通讯录中 Key-Value 模型，例如： 统计文件中每个单词出现的次数，统计结果是每个单词都有与其对应的次数：&lt;单词，单词出现的次数&gt;梁山好汉的江湖绰号：每个好汉都有自己的江湖绰号 Map接口的性质 在Java中，Map接口是一个用于存储键值对（key-value pairs）的对象，它属于Java Collections Framework的一部分。Map接口的主要特点包括：
键值对存储：Map存储的数据是以键值对的形式组织的，每个键（key）唯一对应一个值（value）。可以通过键来快速获取对应的值。
无序性：大多数实现类（如HashMap）不会保证元素的顺序，除非使用特定的实现（如LinkedHashMap，它可以保持插入顺序，或者TreeMap，它会按照键的自然顺序或指定的比较器进行排序）。
键的唯一性：在同一个Map中，不能有重复的键。如果试图将一个新的值与已有的键关联，原有的值将被新值替换。
实现类：Java提供了多种Map接口的实现，例如：
HashMap：基于哈希表的实现，允许null值和null键，查找速度快。TreeMap：基于红黑树的实现，支持排序的键，查找速度相对较慢。LinkedHashMap：结合了HashMap的哈希表和链表特性，维护插入顺序。 常用方法：Map接口提供了一系列的方法，例如：
put(K key, V value)：将指定的值与指定的键关联。get(Object key)：返回指定键所映射的值。remove(Object key)：移除指定键的键值对。containsKey(Object key)：检查是否存在指定的键。keySet()：返回Map中所有键的集合。values()：返回Map中所有值的集合。 总之，Map接口是Java中重要的数据结构之一，方便有效地进行数据的存储和检索，广泛应用于各种场景中。
Map接口的使用方法 put(K key, V value)：将指定的值与指定的键关联。
public class Main { public static void main(String[] args) { Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;(); map.put(&#34;one&#34;,1); map.put(&#34;two&#34;,2); map.put(&#34;three&#34;,3); map.put(&#34;four&#34;,4); } } get(Object key)：返回指定键所映射的值。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-01T20:20:57+08:00">
    <meta property="article:modified_time" content="2024-08-01T20:20:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详细说明Java中Map和Set接口的使用方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Map与Set的基本概念与场景</h2> 
<p>Map和set是一种专门用来进行搜索的容器或者数据结构，其搜索的效率与其具体的实例化子类有关。以前常见的搜索方式有：</p> 
<p>1. 直接遍历，时间复杂度为O(N)，元素如果比较多效率会非常慢。<br> 2. 二分查找，时间复杂度为<img alt="O(\log _{2}^{N})" class="mathcode" src="https://images2.imgbox.com/88/16/CoILImCC_o.png">,但搜索前必须要求序列是有序的。</p> 
<p>上述排序比较适合静态类型的查找，即一般不会对区间进行插入和删除操作了，而现实中的查找比如：</p> 
<p>1. 根据姓名查询考试成绩<br> 2. 通讯录，即根据姓名查询联系方式<br> 3. 不重复集合，即需要先搜索关键字是否已经在集合中</p> 
<p>可能在查找时进行一些插入和删除的操作，即动态查找，那上述两种方式就不太适合了，本节介绍的Map和Set是一种适合动态查找的集合容器。</p> 
<h3>模型概念</h3> 
<p>一般把搜索的数据称为关键字（Key），和关键字对应的称为值（Value），将其称之为Key-value的键值对，所以模型会有两种：</p> 
<ol><li>纯 key 模型，例如：</li></ol> 
<ul><li>有一个英文词典，快速查找一个单词是否在词典中</li><li>快速查找某个名字在不在通讯录中</li></ul> 
<ol><li>Key-Value 模型，例如：</li></ol> 
<ul><li>统计文件中每个单词出现的次数，统计结果是每个单词都有与其对应的次数：&lt;单词，单词出现的次数&gt;</li><li>梁山好汉的江湖绰号：每个好汉都有自己的江湖绰号</li></ul> 
<p><img alt="" height="884" src="https://images2.imgbox.com/ce/d5/FP5LL1Ey_o.png" width="1200"></p> 
<p></p> 
<h2>Map接口的性质</h2> 
<p>在Java中，<code>Map</code>接口是一个用于存储键值对（key-value pairs）的对象，它属于Java Collections Framework的一部分。<code>Map</code>接口的主要特点包括：</p> 
<ol><li> <p><strong>键值对存储</strong>：<code>Map</code>存储的数据是以键值对的形式组织的，每个键（key）唯一对应一个值（value）。可以通过键来快速获取对应的值。</p> </li><li> <p><strong>无序性</strong>：大多数实现类（如<code>HashMap</code>）不会保证元素的顺序，除非使用特定的实现（如<code>LinkedHashMap</code>，它可以保持插入顺序，或者<code>TreeMap</code>，它会按照键的自然顺序或指定的比较器进行排序）。</p> </li><li> <p><strong>键的唯一性</strong>：在同一个<code>Map</code>中，不能有重复的键。如果试图将一个新的值与已有的键关联，原有的值将被新值替换。</p> </li><li> <p><strong>实现类</strong>：Java提供了多种<code>Map</code>接口的实现，例如：</p> 
  <ul><li><code>HashMap</code>：基于哈希表的实现，允许null值和null键，查找速度快。</li><li><code>TreeMap</code>：基于红黑树的实现，支持排序的键，查找速度相对较慢。</li><li><code>LinkedHashMap</code>：结合了<code>HashMap</code>的哈希表和链表特性，维护插入顺序。</li></ul></li><li> <p><strong>常用方法</strong>：<code>Map</code>接口提供了一系列的方法，例如：</p> 
  <ul><li><code>put(K key, V value)</code>：将指定的值与指定的键关联。</li><li><code>get(Object key)</code>：返回指定键所映射的值。</li><li><code>remove(Object key)</code>：移除指定键的键值对。</li><li><code>containsKey(Object key)</code>：检查是否存在指定的键。</li><li><code>keySet()</code>：返回Map中所有键的集合。</li><li><code>values()</code>：返回Map中所有值的集合。</li></ul></li></ol> 
<p>总之，<code>Map</code>接口是Java中重要的数据结构之一，方便有效地进行数据的存储和检索，广泛应用于各种场景中。</p> 
<p></p> 
<h3 style="background-color:transparent;">Map接口的使用方法</h3> 
<p><strong><code>put(K key, V value)</code>：将指定的值与指定的键关联。</strong></p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
        map.put("four",4);
    }
}</code></pre> 
<p><img alt="" height="489" src="https://images2.imgbox.com/43/d0/D7o6E3Iv_o.png" width="1200"></p> 
<p><strong><code>get(Object key)</code>：返回指定键所映射的值。</strong></p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
        map.put("four",4);
        System.out.println(map.get("two"));
    }
}</code></pre> 
<p><img alt="" height="751" src="https://images2.imgbox.com/e1/01/Y8hZAIu7_o.png" width="1200"></p> 
<p><strong>V getOrDefault(Object key, V defaultValue) ：返回 key 对应的 value，key 不存在，返回默认值 </strong></p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
        map.put("four",4);
        System.out.println(map.getOrDefault("five",-1));
    }
}</code></pre> 
<p><img alt="" height="740" src="https://images2.imgbox.com/7b/0b/VMPlUZ5D_o.png" width="1200"></p> 
<p><strong> Set&lt;K&gt; keySet() ：返回所有 key 的不重复集合，用 Set 容器接收</strong></p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
        map.put("four",4);
        Set&lt;String&gt; strings = map.keySet();
        
    }
}</code></pre> 
<p> <img alt="" height="861" src="https://images2.imgbox.com/6d/ec/n52J8MNP_o.png" width="1200"></p> 
<p><strong>Collection&lt;V&gt; values() ：返回所有 value 的可重复集合 ，用 Collection 容器接收</strong></p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
        map.put("four",4);
        Collection&lt;Integer&gt; values = map.values();
        System.out.println("==");
    }
}</code></pre> 
<p><img alt="" height="876" src="https://images2.imgbox.com/ef/84/gnliAtm9_o.png" width="1200"></p> 
<p><strong>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() ：返回所有的 key-value 映射关系 </strong></p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Map&lt;String,Integer&gt; map = new TreeMap&lt;&gt;();
        map.put("one",1);
        map.put("two",2);
        map.put("three",3);
        map.put("four",4);
        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
        for (Map.Entry&lt;String, Integer&gt; entry : entries) {
            System.out.println("Key = "+entry.getKey()+" Val = "+entry.getValue());
        }
    }
}</code></pre> 
<p><img alt="" height="417" src="https://images2.imgbox.com/d1/bd/C4GegvCw_o.png" width="1137"></p> 
<p><strong>注意： </strong></p> 
<ol><li><strong>Map是一个接口，不能直接实例化对象，如果要实例化对象只能实例化其实现类TreeMap或者HashMap</strong></li><li><strong>Map中存放键值对的Key是唯一的，value是可以重复的</strong></li><li><strong>在TreeMap中插入键值对时，key不能为空，否则就会抛NullPointerException异常，value可以为空。但是HashMap的key和value都可以为空。</strong></li><li><strong>Map中的Key可以全部分离出来，存储到Set中来进行访问(因为Key不能重复)。</strong></li><li><strong> Map中的value可以全部分离出来，存储在Collection的任何一个子集合中(value可能有重复)。</strong></li><li><strong>Map中键值对的Key不能直接修改，value可以修改，如果要修改key，只能先将该key删除掉，然后再来进行重新插入。</strong></li></ol> 
<p></p> 
<h2 style="background-color:transparent;">Set接口的性质</h2> 
<p>在Java中，<code>Set</code>接口是一个用于存储唯一元素的集合，它也是Java Collections Framework的一部分。<code>Set</code>接口的主要特点包括：</p> 
<ol><li> <p><strong>唯一性</strong>：<code>Set</code>中不允许重复的元素，这意味着集合中的每个元素都是唯一的。如果试图添加重复元素，操作将被拒绝，集合的状态不会改变。</p> </li><li> <p><strong>无序性</strong>：<code>Set</code>通常不保证元素的顺序。尤其是使用<code>HashSet</code>时，元素的存储顺序是随机的。而<code>LinkedHashSet</code>可以维护元素的插入顺序，<code>TreeSet</code>则会按自然顺序或自定义的比较器进行排序。</p> </li><li> <p><strong>实现类</strong>：Java提供了多种<code>Set</code>接口的实现，包括：</p> 
  <ul><li><code>HashSet</code>：基于哈希表的实现，允许null元素，查找速度快，但不保证元素的顺序。</li><li><code>LinkedHashSet</code>：结合了哈希表和链表的特性，保持元素的插入顺序。</li><li><code>TreeSet</code>：基于红黑树的实现，按升序排序元素，不允许null值。</li></ul></li><li> <p><strong>常用方法</strong>：<code>Set</code>接口提供了一系列的方法，例如：</p> 
  <ul><li><code>add(E e)</code>：向集合中添加元素，如果元素已存在，则返回false。</li><li><code>remove(Object o)</code>：移除指定元素。</li><li><code>contains(Object o)</code>：检查集合中是否包含指定元素。</li><li><code>size()</code>：返回集合中元素的数量。</li><li><code>clear()</code>：移除集合中的所有元素。</li><li><code>iterator()</code>：返回一个迭代器，用于遍历集合中的元素。</li></ul></li><li> <p><strong>应用场景</strong>：<code>Set</code>常用于需要存储不重复元素的场景，比如去重、集合运算（如交集、并集和差集）等。</p> </li></ol> 
<p>总之，<code>Set</code>接口是Java中重要的数据结构，适合用于处理唯一性要求的数据集合，具有高效的存储和检索特性。</p> 
<h3>Set接口的使用方法</h3> 
<p><strong>set 接口中的方法和 Map 接口中的常见方法大差不差，就不一 一介绍了。</strong></p> 
<pre><code class="language-java">import java.util.TreeSet;
import java.util.Iterator;
import java.util.Set;
public static void TestSet(){
   Set&lt;String&gt; s = new TreeSet&lt;&gt;();
   // add(key): 如果key不存在，则插入，返回ture
   // 如果key存在，返回false
   boolean isIn = s.add("apple");
   s.add("orange");
   s.add("peach");
   s.add("banana");
   System.out.println(s.size());
   System.out.println(s);
isIn = s.add("apple");
   // add(key): key如果是空，抛出空指针异常
   //s.add(null);
   // contains(key): 如果key存在，返回true，否则返回false
   System.out.println(s.contains("apple"));
   System.out.println(s.contains("watermelen"));
   // remove(key): key存在，删除成功返回true
   //             key不存在，删除失败返回false
   //             key为空，抛出空指针异常
   s.remove("apple");
   System.out.println(s);
   s.remove("watermelen");
   System.out.println(s);
   Iterator&lt;String&gt; it = s.iterator();
   while(it.hasNext()){
       System.out.print(it.next() + " ");
  }
   System.out.println();
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3fc74f7119f2b76bc13a5ce92b0107a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">河南萌新联赛2024第（三）场：河南大学</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d4117e28efb39f1cd4fcd140c500a09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Springboot和SpringMVC</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>