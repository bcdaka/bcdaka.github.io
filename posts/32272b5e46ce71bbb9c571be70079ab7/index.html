<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【07】JVM是怎么实现invokedynamic的 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/32272b5e46ce71bbb9c571be70079ab7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【07】JVM是怎么实现invokedynamic的">
  <meta property="og:description" content="在Java中，方法调用会被编译为invokeStatic，invokeSpecial，invokVirtual以及invokeInterface四种指令。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑，在实际运行之前，JVM根据这个符号引用链接到具体目标方法。
JDK7 引入新的指令invodeDynamic该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。同时JDK7 还配套引入了更加低层、更加抽象的方法抽象：方法句柄（invokedynamic 底层机制的基石：方法句柄。）。
一、方法句柄 1.方法句柄概念 强类型，能够被直接执行的引用。
方法句柄的类型是由所指向方法的参数以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。
方法句柄的获取 class Foo { private static void bar(Object o) { .. } public static Lookup lookup() { return MethodHandles.lookup(); } } // 获取方法句柄的不同方式 MethodHandles.Lookup l = Foo.lookup(); // 具备 Foo 类的访问权限 Method m = Foo.class.getDeclaredMethod(&#34;bar&#34;, Object.class); MethodHandle mh0 = l.unreflect(m); MethodType t = MethodType.methodType(void.class, Object.class); MethodHandle mh1 = l.findStatic(Foo.class, &#34;bar&#34;, t); 方法句柄的权限
与反射 API 不同，其权限检查是在句柄的创建阶段完成的。在实际调用过程中，JVM不会检查方法句柄的权限。 方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于 Lookup对象的创建位置
举个例子，对于一个私有字段，如果 Lookup 对象是在私有字段所在类中获取的，则这个Lookup对象便拥有对该私有字段的访问权限， 即使是在所在类的外边，也能够通过该 Lookup 对象创建该私有字段的getter 或 setter 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-10T22:23:20+08:00">
    <meta property="article:modified_time" content="2024-08-10T22:23:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【07】JVM是怎么实现invokedynamic的</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在Java中，方法调用会被编译为<code>invokeStatic</code>，<code>invokeSpecial</code>，<code>invokVirtual</code>以及<code>invokeInterface</code>四种指令。这些指令与包含目标方法类名、方法名以及方法描述符的符号引用捆绑，在实际运行之前，JVM根据这个符号引用链接到具体目标方法。</p> 
<p>JDK7 引入新的指令<code>invodeDynamic</code>该指令的调用机制抽象出调用点这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上。同时JDK7 还配套引入了更加低层、更加抽象的方法抽象：方法句柄（invokedynamic 底层机制的基石：方法句柄。）。</p> 
<h3><a id="_4"></a>一、方法句柄</h3> 
<h4><a id="1_6"></a>1.方法句柄概念</h4> 
<p>强类型，能够被直接执行的引用。<br> 方法句柄的类型是由所指向<code>方法的参数以及返回类型</code>组成的。它是用来确认方法句柄是否适配的唯一关键。</p> 
<ul><li>方法句柄的获取</li></ul> 
<pre><code>class Foo {
  private static void bar(Object o) {
    ..
  }
  public static Lookup lookup() {
    return MethodHandles.lookup();
  }
}

// 获取方法句柄的不同方式
MethodHandles.Lookup l = Foo.lookup(); // 具备 Foo 类的访问权限
Method m = Foo.class.getDeclaredMethod("bar", Object.class);
MethodHandle mh0 = l.unreflect(m);

MethodType t = MethodType.methodType(void.class, Object.class);
MethodHandle mh1 = l.findStatic(Foo.class, "bar", t);

</code></pre> 
<ul><li>方法句柄的权限<br> 与反射 API 不同，其权限检查是在句柄的创建阶段完成的。在实际调用过程中，JVM不会检查方法句柄的权限。</li></ul> 
<blockquote> 
 <p>方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于 Lookup对象的创建位置</p> 
</blockquote> 
<pre><code>举个例子，对于一个私有字段，如果 Lookup 对象是在私有字段所在类中获取的，则这个Lookup对象便拥有对该私有字段的访问权限，
即使是在所在类的外边，也能够通过该 Lookup 对象创建该私有字段的getter 或 setter
</code></pre> 
<h4><a id="2_41"></a>2.方法句柄的操作</h4> 
<ol><li>方法句柄的调用有两种模式：</li></ol> 
<ul><li>invokeExact（需要严苛匹配参数类型）<br> 一个方法句柄将接收一个 Object 类型的参数，如果你直接传入String作为实际参数，则方法句柄的调用会在运行时抛出方法类型不匹配的异常</li><li>invoke（自动适配参数类型）<br> invoke 会调用 MethodHandle.asType方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法句柄；调用原方法句柄的返回值同样会先进行适配，然后再返回给调用者。</li></ul> 
<ol start="2"><li>方法句柄支持增删改参数的操作</li></ol> 
<ul><li>改操作：MethodHandle.asType 方法</li><li>删操作：将传入的部分参数就地抛弃，再调用另一个方法句柄。它对应的API 是 MethodHandles.dropArguments方法</li><li>增操作：它会往传入的参数中插入额外的参数，再调用另一个方法句柄，它对应的 API 是 MethodHandle.bindTo 方法；Java 8 中捕获类型的 Lambda 表达式便是用这种操作来实现的</li></ul> 
<pre><code>增操作还可以用来实现方法的柯里化。举个例子，有一个指向 f(x, y) 的方法句柄，我们可以通过将 x 绑定为 4，生成另一个方法句柄 g(y) = f(4, y)。
在执行过程中，每当调用 g(y) 的方法句柄，它会在参数列表最前面插入一个 4，再调用指向 f(x, y) 的方法句柄。
</code></pre> 
<blockquote> 
 <p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p> 
</blockquote> 
<h4><a id="3_60"></a>3.方法句柄的实现</h4> 
<p>方法句柄的调用和反射调用一样，都是间接调用。因此，它也会面临无法内联的问题。不过，与反射调用不同的是，方法句柄的内联瓶颈在于即时编译器能否将该方法句柄识别为常量。</p> 
<h3><a id="invokeDynamic_63"></a>二、invokeDynamic指令</h3> 
<h4><a id="1_65"></a>1.调用点介绍</h4> 
<blockquote> 
 <p>invokedynamic 是 Java 7 引入的一条新指令，用以支持动态语言的方法调用。具体来说，它将调用点（CallSite）抽象成一个 Java 类，并且将原本由 Java 虚拟机控制的方法调用以及方法链接暴露给了应用程序。在运行过程中，每一条 invokedynamic 指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄。<br> 在第一次执行 invokedynamic 指令时，Java 虚拟机会调用该指令所对应的启动方法（BootStrap Method），来生成前面提到的调用点，并且将之绑定至该 invokedynamic 指令中。在之后的运行过程中，Java 虚拟机则会直接调用绑定的调用点所链接的方法句柄。</p> 
</blockquote> 
<p>invokedynamic 的目的，就是将调用点与目标方法的链接交由应用程序来做，并且依赖于应用程序对目标方法进行验证。所以，如果应用程序将赛跑方法链接至兔子的睡觉方法，那也只能怪应用程序自己了。</p> 
<h4><a id="2Java8_lambda_71"></a>2.Java8 中lambda表达式</h4> 
<p>Java8中的lambda是借助于invokeDynamic来实现的。</p> 
<p>具体来说，Java 编译器利用 invokedynamic 指令来生成实现了函数式接口的适配器。</p> 
<blockquote> 
 <p>函数式接口指的是仅包括一个非 default 接口方法的接口，一般通过 @FunctionalInterface 注解,不过就算是没有使用该注解，Java 编译器也会将符合条件的接口辨认为函数式接口</p> 
</blockquote> 
<pre><code>int x = ..
IntStream.of(1, 2, 3).map(i -&gt; i * 2).map(i -&gt; i * x);

上面这段代码会对 IntStream 中的元素进行两次映射。映射方法 map 所接收的参数是 IntUnaryOperator（这是一个函数式接口）。
也就是说，在运行过程中我们需要将 i-&gt;i*2 和 i -&gt; i*x 这两个lambda表达式转化成IntUnaryOperator实例，
这个转换过程就是通过invokeDynamic实现的；

在编译过程中，Java 编译器会对 Lambda 表达式进行解语法糖（desugar），
生成一个方法来保存 Lambda 表达式的内容。该方法的参数列表不仅包含原本 Lambda 表达式的参数，还包含它所捕获的变量。
(注：方法引用，如 Horse::race，则不会生成生成额外的方法。)

在上面那个例子中，第一个 Lambda 表达式没有捕获其他变量，而第二个 Lambda 表达式（也就是 i-&gt;i*x）则会捕获局部变量 x。
这两个 Lambda 表达式对应的方法如下所示。可以看到，所捕获的变量同样也会作为参数传入生成的方法之中。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84078c8f6b17c584f58e8feac7724fea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深度解析 MetaArena 游戏引擎，如何让 GameFi 应用更具生命力？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8cbbe671c13e2074c595c4e32bc9703f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL】视图——视图、视图的概念、为什么要使用视图、视图的基本使用、视图规则和限制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>