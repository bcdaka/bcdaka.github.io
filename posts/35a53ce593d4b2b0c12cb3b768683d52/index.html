<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】优先级队列(堆) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/35a53ce593d4b2b0c12cb3b768683d52/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】优先级队列(堆)">
  <meta property="og:description" content="目录
1.前言
2.优先级队列
2.1概念
3.优先级队列的模拟实现
3.1堆的概念
​3.2堆的存储方式
3.3堆的创建
3.3.1堆向下调整
3.3.2建堆的时间复杂度
3.4堆的插入与删除
3.4.1堆的插入
3.4.2堆的删除
3.5用堆模拟实现优先级队列
4.常用接口介绍
4.1PriorityQueue的特性
4.2PriorityQueue常用接口介绍
4.2.1优先级队列的构造
4.2.2插入/删除/获取优先级最高的元素
4.3最小的K个数OJ题
5. 堆的应用
5.1PriorityQueue的实现
5.2堆排序
6.总结
1.前言 我们上一篇文章给大家分享树和二叉树的概念、基本操作等。当在手机上玩游戏的时候，如果有来电，那么系统应该优先处理打进来的电话；初中那会班主任排座位时可能会让成绩好的同学先挑座位，在这种情况下，就会使用优先级队列。今天就将与大家分享数据结构中关于堆的知识点。
2.优先级队列 2.1概念 前面介绍过队列， 队列是一种先进先出 的数据结构 ，但有些情况下， 操作的数据可能带有优先级，一般出队 列时，可能需要优先级高的元素先出队列，该中场景下，使用队列显然不合适，这时候 数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象 。这种数据结构就是优先级队列 (Priority Queue)。 3.优先级队列的模拟实现 JDK1.8 中的 PriorityQueue 底层使用了堆这种数据结构 ，而堆实际就是在完全二叉树的基础上进行了一些调整。 3.1堆的概念 如果有一个关键码的集合K = {k0，k1， k2，…，kn-1}，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足：Ki &lt;= K2i&#43;1 且 Ki&lt;= K2i&#43;2 (Ki &gt;= K2i&#43;1 且 Ki &gt;= K2i&#43;2) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
堆的性质：
堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-27T18:03:57+08:00">
    <meta property="article:modified_time" content="2024-07-27T18:03:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】优先级队列(堆)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#1.%E5%89%8D%E8%A8%80" rel="nofollow">1.前言</a></p> 
<p id="2.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#2.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">2.优先级队列</a></p> 
<p id="2.1%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%E6%A6%82%E5%BF%B5" rel="nofollow">2.1概念</a></p> 
<p id="3.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">3.优先级队列的模拟实现</a></p> 
<p id="3.1%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#3.1%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">3.1堆的概念</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.2%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.2%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F" rel="nofollow">​3.2堆的存储方式</a></p> 
<p id="3.3%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#3.3%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">3.3堆的创建</a></p> 
<p id="3.3.1%E5%A0%86%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4-toc" style="margin-left:80px;"><a href="#3.3.1%E5%A0%86%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4" rel="nofollow">3.3.1堆向下调整</a></p> 
<p id="3.3.2%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:80px;"><a href="#3.3.2%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">3.3.2建堆的时间复杂度</a></p> 
<p id="3.4%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#3.4%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4" rel="nofollow">3.4堆的插入与删除</a></p> 
<p id="3.4.1%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#3.4.1%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">3.4.1堆的插入</a></p> 
<p id="3.4.2%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#3.4.2%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">3.4.2堆的删除</a></p> 
<p id="3.5%E7%94%A8%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#3.5%E7%94%A8%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">3.5用堆模拟实现优先级队列</a></p> 
<p id="4.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#4.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" rel="nofollow">4.常用接口介绍</a></p> 
<p id="4.1PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#4.1PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">4.1PriorityQueue的特性</a></p> 
<p id="4.2PriorityQueue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#4.2PriorityQueue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" rel="nofollow">4.2PriorityQueue常用接口介绍</a></p> 
<p id="4.2.1%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#4.2.1%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E9%80%A0" rel="nofollow">4.2.1优先级队列的构造</a></p> 
<p id="4.2.2%E6%8F%92%E5%85%A5%2F%E5%88%A0%E9%99%A4%2F%E8%8E%B7%E5%8F%96%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#4.2.2%E6%8F%92%E5%85%A5%2F%E5%88%A0%E9%99%A4%2F%E8%8E%B7%E5%8F%96%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">4.2.2插入/删除/获取优先级最高的元素</a></p> 
<p id="4.3%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0OJ%E9%A2%98-toc" style="margin-left:40px;"><a href="#4.3%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0OJ%E9%A2%98" rel="nofollow">4.3最小的K个数OJ题</a></p> 
<p id="5.%C2%A0%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#5.%C2%A0%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">5. 堆的应用</a></p> 
<p id="5.1PriorityQueue%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#5.1PriorityQueue%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">5.1PriorityQueue的实现</a></p> 
<p id="5.2%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#5.2%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">5.2堆排序</a></p> 
<p id="6.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#6.%E6%80%BB%E7%BB%93" rel="nofollow">6.总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%89%8D%E8%A8%80" style="background-color:transparent;">1.前言</h2> 
<p>我们上一篇文章给大家分享树和二叉树的概念、基本操作等。当<span style="color:#333333;">在手机上玩游戏的时候，如果有来电，那么系统应该优先处理打进来的电话；初中那会班主任排座位时可能会让成绩好的同学先挑座位，在这种情况下，就会使用<strong>优先级队列。</strong></span>今天就将与大家分享数据结构中关于堆的知识点。</p> 
<h2 id="2.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">2.<span style="color:#333333;"><strong>优先级队列</strong></span></h2> 
<h3 id="2.1%E6%A6%82%E5%BF%B5">2.1概念</h3> 
<div> 
 <span style="color:#333333;">前面介绍过队列，</span> 
 <span style="color:#333333;"><strong>队列是一种先进先出</strong></span> 
 <span style="color:#333333;"><strong>的数据结构</strong></span> 
 <span style="color:#333333;">，但有些情况下，</span> 
 <span style="color:#333333;"><strong>操作的数据可能带有优先级，一般出队</strong></span> 
 <span style="color:#333333;"><strong>列时，可能需要优先级高的元素先出队列</strong>，该中场景下，使用队列显然不合适，这时候</span> 
 <span style="color:#333333;"><strong>数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象</strong></span> 
 <span style="color:#333333;">。这种数据结构就是<strong>优先级队列</strong></span> 
 <span style="color:#333333;"><strong>(Priority Queue)。</strong></span> 
</div> 
<h2 id="3.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span style="color:#333333;"><strong>3.优先级队列的模拟实现</strong></span></h2> 
<div> 
 <span style="color:#333333;">JDK1.8</span> 
 <span style="color:#333333;">中的</span> 
 <span style="color:#333333;"><strong>PriorityQueue</strong></span> 
 <span style="color:#333333;"><strong>底层使用了堆这种数据结构</strong></span> 
 <span style="color:#333333;">，而堆实际就是在完全二叉树的基础上进行了一些调整。 </span> 
</div> 
<h3 id="3.1%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" style="background-color:transparent;"><span style="color:#333333;">3.1<strong>堆的概念</strong></span></h3> 
<p><span style="color:#333333;">如果有一个<strong>关键码的集合</strong></span><span style="color:#333333;"><strong>K = {k0</strong></span><span style="color:#333333;"><strong>，</strong></span><span style="color:#333333;"><strong>k1</strong></span><span style="color:#333333;"><strong>，</strong></span><span style="color:#333333;"><strong> k2</strong></span><span style="color:#333333;"><strong>，</strong></span><span style="color:#333333;"><strong>…</strong></span><span style="color:#333333;"><strong>，</strong></span><span style="color:#333333;"><strong>kn-1}</strong></span><span style="color:#333333;">，把它的所有元素</span><span style="color:#333333;"><strong>按完全二叉树的顺序存储方式存储 在一</strong></span><span style="color:#333333;"><strong>个一维数组中</strong></span><span style="color:#333333;">，并满足：</span><span style="color:#333333;"><strong>Ki &lt;= K2i+1 </strong></span><span style="color:#333333;"><strong>且</strong></span><span style="color:#333333;"><strong> Ki&lt;= K2i+2</strong></span><span style="color:#333333;"> (Ki &gt;= K2i+1 </span><span style="color:#333333;">且</span><span style="color:#333333;"> Ki &gt;= K2i+2) i = 0</span><span style="color:#333333;">，</span><span style="color:#333333;">1</span><span style="color:#333333;">，</span><span style="color:#333333;">2…</span><span style="color:#333333;">，则</span><span style="color:#333333;"><strong>称为小堆</strong></span><span style="color:#333333;">(</span><span style="color:#333333;">或大堆)</span><span style="color:#333333;">。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</span></p> 
<p><span style="color:#333333;"><strong>堆的性质：</strong></span></p> 
<blockquote> 
 <ul><li><span style="color:#333333;">堆中某个节点的值总是不大于或不小于其父节点的值； </span></li><li><span style="color:#333333;">堆总是一棵完全二叉树。</span></li></ul> 
</blockquote> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A03.2%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><img alt="" height="661" src="https://images2.imgbox.com/f8/ee/lpJg6EKa_o.png" width="843">3.2<span style="color:#333333;"><strong>堆的存储方式</strong></span></h3> 
<div> 
 <div> 
  <span style="color:#333333;">从堆的概念可知，<strong>堆是一棵完全二叉树，因此可以层序的规则采用顺序的方式来高效存储。</strong></span> 
  <img alt="" height="516" src="https://images2.imgbox.com/1f/78/TRaGGysK_o.png" width="1200"> 
 </div> 
 <div> 
  <div> 
   <span style="color:#fe2c24;"><strong>注意：</strong></span> 
   <span style="color:#333333;">对于</span> 
   <span style="color:#333333;"><strong>非完全二叉树，则不适合使用顺序方式进行存储</strong></span> 
   <span style="color:#333333;">，因为为了能够还原二叉树，</span> 
   <span style="color:#333333;"><strong>空间中必须要存储空节</strong></span> 
   <span style="color:#333333;"><strong>点，就会导致空间利用率比较低</strong></span> 
   <span style="color:#333333;">。</span> 
  </div> 
  <div> 
   <div> 
    <span style="color:#333333;">将元素存储到数组中后，可以根据二叉树章节的性质</span> 
    <span style="color:#333333;">5</span> 
    <span style="color:#333333;">对树进行还原。假设</span> 
    <span style="color:#333333;">i</span> 
    <span style="color:#333333;">为节点在数组中的下标，则有：</span> 
   </div> 
   <div> 
    <ul><li><span style="color:#333333;">如果</span><span style="color:#333333;">i</span><span style="color:#333333;">为</span><span style="color:#333333;">0</span><span style="color:#333333;">，则</span><span style="color:#333333;">i</span><span style="color:#333333;">表示的节点为根节点，否则</span><span style="color:#333333;">i</span><span style="color:#333333;">节点的双亲节点为</span><span style="color:#333333;"> (i - 1)/2 </span></li><li><span style="color:#333333;">如果</span><span style="color:#333333;">2 * i + 1 </span><span style="color:#333333;">小于节点个数，则节点</span><span style="color:#333333;">i</span><span style="color:#333333;">的左孩子下标为</span><span style="color:#333333;">2 * i + 1</span><span style="color:#333333;">，否则没有左孩子</span></li><li><span style="color:#333333;">如果</span><span style="color:#333333;">2 * i + 2 </span><span style="color:#333333;">小于节点个数，则节点</span><span style="color:#333333;">i</span><span style="color:#333333;">的右孩子下标为</span><span style="color:#333333;">2 * i + 2</span><span style="color:#333333;">，否则没有右孩子</span></li></ul> 
    <h3 id="3.3%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" style="background-color:transparent;">3.3<span style="color:#333333;"><strong>堆的创建</strong></span></h3> 
    <h4 id="3.3.1%E5%A0%86%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4" style="background-color:transparent;">3.3.1<span style="color:#333333;"><strong>堆向下调整</strong></span></h4> 
    <p><span style="color:#333333;">下面举个例子：对于集合</span><span style="color:#333333;">{ 27,15,19,18,28,34,65,49,25,37 }</span><span style="color:#333333;">中的数据，将其创建成大根堆。</span></p> 
    <p><img alt="" height="501" src="https://images2.imgbox.com/2e/b3/8jCz8J4l_o.png" width="921"></p> 
    <div> 
     <span style="color:#333333;"><strong>我们发现：根节点的左右子树已经完全满足堆的性质，因此只需将根节点向下调整好即可</strong></span> 
     <span style="color:#333333;">。</span> 
    </div> 
    <div> 
     <pre><code class="language-java">public class TestHeap {
    public int[] elem;
    public int UsedSize;

    public TestHeap() {
        this.elem = new int[10];
    }

    public void inti(int[] array) {
        for (int i = 0; i &lt; array.length; i++) {
            elem[i] = array[i];
            UsedSize++;
        }
    }

    //将堆中的数据调整为大根堆
    public void createHeap() {
        for (int parent = (UsedSize - 1 - 1) / 2; parent &gt;= 0; parent--) {
            siftDown(parent, UsedSize);
        }
    }

    //左右孩子的最大值跟根节点比较，比根节点大则交换
    private void swap(int i, int j) {
        int temp = elem[i];
        elem[i] = elem[j];
        elem[j] = temp;
    }

    public void siftDown(int parent, int end) {
        int child = 2 * parent + 1;
        while (child &lt; end) {
            //防止数组越界
            if (child + 1 &lt; end &amp;&amp; elem[child] &lt; elem[child + 1]) {
                child++;
            }
            //child下标就是左右孩子的最大值
            if (elem[child] &gt; elem[parent]) {
                swap(child, parent);
                parent = child;
                child = 2 * parent + 1;
            } else {
                break;
            }
        }
    }
}
</code></pre> 
     <pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //创建大根堆
        int[] array={27,15,19,18,28,34,65,49,25,37};
        TestHeap testHeap= new TestHeap();
        testHeap.inti(array);
        testHeap.createHeap();
    }
}
</code></pre> 
     <p><img alt="" height="491" src="https://images2.imgbox.com/a3/65/XA45eIJJ_o.png" width="1097"></p> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="color:#fe2c24;"><strong>注意：</strong></span> 
 <span style="color:#333333;"><strong>在调整以</strong></span> 
 <span style="color:#333333;"><strong>parent</strong></span> 
 <span style="color:#333333;"><strong>为根的二叉树时，必须要满足</strong></span> 
 <span style="color:#333333;"><strong>parent</strong></span> 
 <span style="color:#333333;"><strong>的左子树和右子树已经是堆了才可以向下调整。 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>时间复杂度分析： 最坏的情况</strong>即图示的情况，<strong>从根一路比较到叶子</strong>，比较的次数为完全二叉树的高度，即时间复杂度为</span> 
 <span style="color:#0d0016;"><strong>O(log₂N)</strong></span> 
 <span style="color:#333333;"><strong>。</strong></span> 
</div> 
<h4 id="3.3.2%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span style="color:#333333;"><strong>3.3.2建堆的时间复杂度</strong></span></h4> 
<p><span style="color:#333333;">因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明(</span><span style="color:#333333;">时间复杂度本来看的就是近似值，多几个节点不影响最终结果)</span><span style="color:#333333;">：</span></p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/f0/0d/C5OgZRj9_o.png" width="1197"></p> 
<p> 所以可得<span style="color:#333333;"><strong>建堆的时间复杂度为O(N)。</strong></span></p> 
<h3 id="3.4%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span style="color:#333333;"><strong>3.4堆的插入与删除</strong></span></h3> 
<h4 id="3.4.1%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5" style="background-color:transparent;"><span style="color:#333333;"><strong>3.4.1堆的插入</strong></span></h4> 
<p><span style="color:#333333;">堆的插入总共需要两个步骤： </span></p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">先将元素放入到底层空间中</span> 
  <span style="color:#333333;">(</span> 
  <span style="color:#333333;">注意：空间不够时需要扩容</span> 
  <span style="color:#333333;">) </span> 
 </div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;">将最后新插入的节点向上调整，直到满足堆的性质 </span> 
 </div> 
</blockquote> 
<p><img alt="" height="287" src="https://images2.imgbox.com/0f/25/ieAUG7jK_o.png" width="1200"></p> 
<p> </p> 
<pre><code class="language-java">//插入元素
    public void offer(int val){
        if(isFull()){
            //满了则进行扩容
            elem= Arrays.copyOf(elem,2*elem.length);
        }
        elem[UsedSize]=val;
        UsedSize++;
        //向上调整
        shitUp(UsedSize-1);
    }

    public void shitUp(int child){
        int parent =(child-1)/2;
        while(parent&gt;=0){
            if(elem[child]&gt;elem[parent]){
                swap(child,parent);
                child=parent;
                parent=(child-1)/2;
            }else {
                break;
            }
        }
    }

    //判断空间是否满了
    public boolean isFull(){
        return UsedSize== elem.length;
    }</code></pre> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //创建大根堆
        int[] array={27,15,19,18,28,34,65,49,25,37};
        TestHeap testHeap= new TestHeap();
        testHeap.inti(array);
        testHeap.createHeap();
        testHeap.offer(80);
    }
}</code></pre> 
<p><img alt="" height="743" src="https://images2.imgbox.com/e8/91/BUbICAug_o.png" width="1121"></p> 
<h4 id="3.4.2%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" style="background-color:transparent;">3.4.2<span style="color:#333333;"><strong>堆的删除</strong></span></h4> 
<div> 
 <span style="color:#333333;"><strong>堆的删除一定删除的是堆顶元素。</strong></span> 
 <span style="color:#333333;">具体如下</span>： 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#333333;">1. </span> 
   <span style="color:#333333;">将堆顶元素对堆中最后一个元素交换；</span> 
  </div> 
  <div> 
   <span style="color:#333333;">2. </span> 
   <span style="color:#333333;">将堆中有效数据个数减少一个；</span> 
  </div> 
  <div> 
   <span style="color:#333333;">3. </span> 
   <span style="color:#333333;">对堆顶元素进行向下调整。</span> 
  </div> 
 </div> 
</blockquote> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0"><img alt="" height="445" src="https://images2.imgbox.com/0b/91/IL2FpGkC_o.png" width="1200"></h3> 
<pre><code class="language-java">//删除元素
    public int poll(){
        if(isEmpty()){
            return -1;
        }
        int old=elem[0];
        swap(0,UsedSize-1);
        UsedSize--;
        siftDown(0,UsedSize);
        return old;
    }
    public boolean isEmpty(){
        return UsedSize==0;
    }</code></pre> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        //创建大根堆
        int[] array={27,15,19,18,28,34,65,49,25,37};
        TestHeap testHeap= new TestHeap();
        testHeap.inti(array);
        testHeap.createHeap();
        testHeap.poll();
    }
}
</code></pre> 
<p><img alt="" height="479" src="https://images2.imgbox.com/fd/99/poxpgvby_o.png" width="995"></p> 
<p></p> 
<p></p> 
<h3 id="3.5%E7%94%A8%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" style="background-color:transparent;">3.5<span style="color:#333333;"><strong>用堆模拟实现优先级队列</strong></span></h3> 
<pre><code class="language-java">import java.util.Arrays;

public class TestHeap {
    public int[] elem;
    public int UsedSize;

    public TestHeap() {
        this.elem = new int[10];
    }

    public void inti(int[] array) {
        for (int i = 0; i &lt; array.length; i++) {
            elem[i] = array[i];
            UsedSize++;
        }
    }

    //将堆中的数据调整为大根堆
    public void createHeap() {
        for (int parent = (UsedSize - 1 - 1) / 2; parent &gt;= 0; parent--) {
            siftDown(parent, UsedSize);
        }
    }

    //左右孩子的最大值跟根节点比较，比根节点大则交换
    private void swap(int i, int j) {
        int temp = elem[i];
        elem[i] = elem[j];
        elem[j] = temp;
    }

    public void siftDown(int parent, int end) {
        int child = 2 * parent + 1;
        while (child &lt; end) {
            //防止数组越界
            if (child + 1 &lt; end &amp;&amp; elem[child] &lt; elem[child + 1]) {
                child++;
            }
            //child下标就是左右孩子的最大值
            if (elem[child] &gt; elem[parent]) {
                swap(child, parent);
                parent = child;
                child = 2 * parent + 1;
            } else {
                break;
            }
        }
    }

    //插入元素
    public void offer(int val){
        if(isFull()){
            //满了则进行扩容
            elem= Arrays.copyOf(elem,2*elem.length);
        }
        elem[UsedSize]=val;
        UsedSize++;
        //向上调整
        shitUp(UsedSize-1);
    }

    public void shitUp(int child){
        int parent =(child-1)/2;
        while(parent&gt;=0){
            if(elem[child]&gt;elem[parent]){
                swap(child,parent);
                child=parent;
                parent=(child-1)/2;
            }else {
                break;
            }
        }
    }

    //判断空间是否满了
    public boolean isFull(){
        return UsedSize== elem.length;
    }

    //删除元素
    public int poll(){
        if(isEmpty()){
            return -1;
        }
        int old=elem[0];
        swap(0,UsedSize-1);
        UsedSize--;
        siftDown(0,UsedSize);
        return old;
    }
    public boolean isEmpty(){
        return UsedSize==0;
    }
}
</code></pre> 
<pre><code class="language-java">import java.util.PriorityQueue;

public class Test {
    public static void main(String[] args) {
        //堆模拟优先级队列
        PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;();
        priorityQueue.offer(10);
        priorityQueue.offer(5);
        priorityQueue.offer(25);
        System.out.println(priorityQueue.poll());//5
        System.out.println(priorityQueue.poll());//10
    }
}</code></pre> 
<p><img alt="" height="176" src="https://images2.imgbox.com/ed/62/kYjZavfk_o.png" width="652"></p> 
<p><span style="color:#333333;">下面来几道关于堆的练习题给大家练练手。</span></p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">1.</span> 
  <span style="color:#333333;">下列关键字序列为堆的是</span> 
  <span style="color:#333333;">:() </span> 
 </div> 
 <div> 
  <span style="color:#333333;">A: 100,60,70,50,32,65                 B: 60,70,65,50,32,100                 C: 65,100,70,32,50,60</span> 
 </div> 
 <div> 
  <span style="color:#333333;">D: 70,65,100,32,50,60                 E: 32,50,100,70,65,60                 F: 50,100,70,65,60,32</span> 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#333333;">2.</span> 
   <span style="color:#333333;">已知小根堆为</span> 
   <span style="color:#333333;">8,15,10,21,34,16,12</span> 
   <span style="color:#333333;">，删除关键字</span> 
   <span style="color:#333333;">8</span> 
   <span style="color:#333333;">之后需重建堆，在此过程中，关键字之间的比较次数是</span> 
   <span style="color:#333333;">()</span> 
  </div> 
  <div> 
   <span style="color:#333333;">A: 1          B: 2          C: 3         D: 4</span> 
  </div> 
  <div></div> 
  <div> 
   <div> 
    <span style="color:#333333;">3.</span> 
    <span style="color:#333333;">最小堆</span> 
    <span style="color:#333333;">[0,3,2,5,7,4,6,8],</span> 
    <span style="color:#333333;">在删除堆顶元素</span> 
    <span style="color:#333333;">0</span> 
    <span style="color:#333333;">之后，其结果是</span> 
    <span style="color:#333333;">()</span> 
   </div> 
   <div> 
    <span style="color:#333333;">A: [3</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">2</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">5</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">7</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">4</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">6，8]                B: [2，3</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">5</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">7</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">4</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">6</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">8] </span> 
   </div> 
   <div> 
    <span style="color:#333333;">C: [2</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">3</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">4</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">5</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">7</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">8，6]                D: [2，3</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">4</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">5</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">6</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">7</span> 
    <span style="color:#333333;">，</span> 
    <span style="color:#333333;">8]</span> 
   </div> 
   <div></div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#fe2c24;"><strong>参考答案：</strong></span> 
    </div> 
    <div> 
     <div> 
      <span style="color:#333333;">1.A    2.C    3.C</span> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</blockquote> 
<h2 id="4.%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">4.<span style="color:#333333;"><strong>常用接口介绍</strong></span></h2> 
<h3 id="4.1PriorityQueue%E7%9A%84%E7%89%B9%E6%80%A7" style="background-color:transparent;">4.1<span style="color:#333333;"><strong>PriorityQueue</strong></span><span style="color:#333333;"><strong>的特性</strong></span></h3> 
<p><span style="color:#333333;">Java集合框架中提供了</span><span style="color:#333333;"><strong>PriorityQueue</strong></span><span style="color:#333333;">和</span><span style="color:#333333;"><strong>PriorityBlockingQueue</strong></span><span style="color:#333333;">两种类型的优先级队列，</span><span style="color:#333333;"><strong>PriorityQueue</strong></span><span style="color:#333333;"><strong>是线</strong></span><span style="color:#333333;"><strong>程不安全的，</strong></span><span style="color:#333333;"><strong>PriorityBlockingQueue</strong></span><span style="color:#333333;"><strong>是线程安全的</strong></span><span style="color:#333333;">，本文以介绍</span><span style="color:#333333;">PriorityQueue为主。</span></p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/e0/4a/ZaAeNg4a_o.png" width="729"></p> 
<p> <strong>使用PriorityQueue时需要注意:</strong></p> 
<p><span style="color:#333333;">1. </span><span style="color:#333333;">使用时必须导入</span><span style="color:#333333;">PriorityQueue</span><span style="color:#333333;">所在的包，即：</span></p> 
<pre><code class="language-java">import java.util.PriorityQueue;</code></pre> 
<p>2. PriorityQueue中放置的元素必须要能够比较大小，不能插入无法比较大小的对象，否则会抛出ClassCastException异常；</p> 
<p>3.不能插入null对象，否则会抛出NullPointeException；</p> 
<p>4.没有容量限制，可以插入任意多个元素，其内部可以自动扩容；</p> 
<p>5.插入和删除元素的时间复杂度为O(log₂N)；</p> 
<p>6.PriorityQueue底层使用了堆数据结构；</p> 
<p>7.PriorityQueue默认情况下是小根堆–即每次获取到的元素都是最小的元素。</p> 
<h3 id="4.2PriorityQueue%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">4.2<span style="color:#333333;"><strong>PriorityQueue</strong></span><span style="color:#333333;"><strong>常用接口介绍</strong></span></h3> 
<h4 id="4.2.1%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E6%9E%84%E9%80%A0"><span style="color:#333333;"><strong>4.2.1优先级队列的构造</strong></span></h4> 
<div> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td><span style="color:#0d0016;"><strong>构造器</strong></span></td><td><span style="color:#0d0016;"><strong>功能介绍</strong></span></td></tr><tr><td><span style="color:#0d0016;">PriorityQueue()</span></td><td><span style="color:#0d0016;">创建一个空的优先级队列，默认容量是11</span></td></tr><tr><td> <p><span style="color:#0d0016;">PriorityQueue(int initialCapacity)</span></p> </td><td><span style="color:#0d0016;">创建一个初始容量为initialCapacity的优先级队列，注意： initialCapacity不能小于1，否则会抛IllegalArgumentException异常</span></td></tr><tr><td><span style="color:#0d0016;">PriorityQueue(Collection&lt;? extends E&gt; c)</span></td><td><span style="color:#0d0016;">用一个集合来创建优先级队列</span></td></tr></tbody></table> 
 <pre><code class="language-java">import java.util.ArrayList;
import java.util.PriorityQueue;

public class Test {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(10);
        list.add(20);
        list.add(30);
        PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(list);
        //PriorityQueue队列默认是小根堆
        System.out.println(priorityQueue);
        System.out.println("队头元素为：" + priorityQueue.peek());
        System.out.println("长度为：" + priorityQueue.size());
    }
}
</code></pre> 
 <p><img alt="" height="213" src="https://images2.imgbox.com/6d/4b/Is4cyoEb_o.png" width="664"></p> 
 <p><span style="color:#fe2c24;"><strong>注：默认情况下，PriorityQueue队列是小根堆，如果需要大根堆需要用户提供比较器。</strong></span></p> 
 <h4 id="4.2.2%E6%8F%92%E5%85%A5%2F%E5%88%A0%E9%99%A4%2F%E8%8E%B7%E5%8F%96%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E7%B4%A0" style="background-color:transparent;"><span style="color:#0d0016;"><strong>4.2.2插入/删除/获取优先级最高的元素</strong></span></h4> 
 <table border="1" cellpadding="1" cellspacing="1" style="width:660px;"><tbody><tr><td style="text-align:center;width:175px;"><span style="color:#0d0016;"><strong>函数名</strong></span></td><td style="text-align:center;width:483px;"><span style="color:#0d0016;"><strong>功能介绍</strong></span></td></tr><tr><td style="text-align:center;width:175px;"><span style="color:#0d0016;">boolean offer(E e)</span></td><td style="text-align:center;width:483px;"><span style="color:#0d0016;">插入元素e，插入成功返回true，如果e对象为空，抛出NullPointerException异常，时 间复杂度 ，注意：空间不够时候会进行自动扩容</span></td></tr><tr><td style="text-align:center;width:175px;"><span style="color:#0d0016;">E peek()</span></td><td style="text-align:center;width:483px;"><span style="color:#0d0016;">获取优先级最高的元素，如果优先级队列为空，返回null</span></td></tr><tr><td style="text-align:center;width:175px;"><span style="color:#0d0016;">E poll()</span></td><td style="text-align:center;width:483px;"><span style="color:#0d0016;">移除优先级最高的元素并返回，如果优先级队列为空，返回null</span></td></tr><tr><td style="text-align:center;width:175px;"><span style="color:#0d0016;">int size()</span></td><td style="text-align:center;width:483px;"><span style="color:#0d0016;">获取有效元素的个数</span></td></tr><tr><td style="text-align:center;width:175px;"><span style="color:#0d0016;">void clear()</span></td><td style="text-align:center;width:483px;"><span style="color:#0d0016;">清空</span></td></tr><tr><td style="text-align:center;width:175px;"><span style="color:#0d0016;">boolean isEmpty()</span></td><td style="text-align:center;width:483px;"><span style="color:#0d0016;">检测优先级队列是否为空，空返回true</span></td></tr></tbody></table> 
 <pre><code class="language-java">import java.util.ArrayList;
import java.util.PriorityQueue;

public class Test {
    public static void main(String[] args) {
        int[] arr={27,15,19,18,28,34,65,49,25,37};
        PriorityQueue&lt;Integer&gt; priorityQueue =new PriorityQueue&lt;&gt;(arr.length);
        //通过for循环遍历插入元素
        for (int i = 0; i &lt; arr.length ; i++) {
            priorityQueue.offer(arr[i]);
        }
        System.out.println(priorityQueue);

        //获取优先级队列最高的元素
        System.out.println(priorityQueue.peek());

        //弹出优先级最高的元素
        System.out.println(priorityQueue.poll());
        System.out.println(priorityQueue);

        //获取有效元素的个数
        System.out.println(priorityQueue.size());

        //清空
        priorityQueue.clear();
        System.out.println(priorityQueue);

        //检测优先级队列是否为空，空返回true
        System.out.println(priorityQueue.isEmpty());
    }
}
</code></pre> 
 <p><strong>运行结果如下：</strong></p> 
 <p><img alt="" height="369" src="https://images2.imgbox.com/d2/fd/JYvFvTqE_o.png" width="820"></p> 
</div> 
<h3 id="4.3%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0OJ%E9%A2%98" style="background-color:transparent;">4.3<span style="color:#0d0016;"><strong>最小的K个数OJ题</strong></span></h3> 
<p><span style="color:#0d0016;"><strong>题目链接：</strong></span><a href="https://leetcode.cn/problems/smallest-k-lcci/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<pre><code class="language-java">import java.util.PriorityQueue;

public class Test {
    //最小K个数
    //设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
    public static int[] smallestK(int[] arr, int k) {
        PriorityQueue&lt;Integer&gt; priorityQueue =new PriorityQueue&lt;&gt;();
        for(int i = 0;i&lt;arr.length;i++){
            priorityQueue.offer(arr[i]);
        }
        int[] temp = new int[k];
        for(int i=0;i&lt;k;i++){
            int value =priorityQueue.poll();
            temp[i] =value;
        }
        return temp;
    }

    public static void main(String[] args) {
        int[] arr={27,15,19,18,28,34,65,49,25,37};
        int[] arr1 =smallestK(arr,3);
        System.out.println(Arrays.toString(arr1));
    }
}</code></pre> 
<p><span style="color:#0d0016;"><strong>运行结果如下：</strong></span></p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/4a/d1/UNfjBK2k_o.png" width="664"> </p> 
<h2 id="5.%C2%A0%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8">5. 堆的应用</h2> 
<h3 id="5.1PriorityQueue%E7%9A%84%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">5.1<span style="color:#333333;"><strong>PriorityQueue</strong></span><span style="color:#333333;"><strong>的实现</strong></span></h3> 
<div> 
 <span style="color:#333333;">用堆作为底层结构</span> 
 <span style="color:#333333;"><strong>封装优先级队。</strong></span> 
</div> 
<h3 id="5.2%E5%A0%86%E6%8E%92%E5%BA%8F" style="background-color:transparent;"><span style="color:#333333;"><strong>5.2堆排序</strong></span></h3> 
<div> 
 <span style="color:#333333;">堆排序即利用堆的思想来进行排序，总共分为两个步骤：</span> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#333333;">1. <strong>建堆：</strong></span> 
  <ul><li><span style="color:#333333;">升序：建大堆</span></li><li><span style="color:#333333;">降序：建小堆</span></li></ul> 
  <p><span style="color:#333333;">2. </span><span style="color:#333333;"><strong>利用堆删除思想来进行排序：</strong></span></p> 
  <p><span style="color:#333333;">建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序。</span></p> 
 </div> 
</blockquote> 
<p><img alt="" height="834" src="https://images2.imgbox.com/f5/e8/KOSHybLh_o.png" width="857"></p> 
<pre><code class="language-java">//进行堆排序
    public void headSort(){
        int endIndex = UsedSize-1;
        while(endIndex&gt;0){
            swap(0,endIndex);
            siftDown(0,endIndex);
            endIndex--;
        }</code></pre> 
<p><img alt="" height="498" src="https://images2.imgbox.com/90/33/t60Wrzrn_o.png" width="1082"> </p> 
<h2 id="6.%E6%80%BB%E7%BB%93" style="background-color:transparent;">6.总结</h2> 
<div> 
 <span style="color:#333333;">本文主要介绍堆的创建、堆的用法、PriorityQueue接口的使用以及堆排序等，有一点要注意，优先级队列在插入元素时有个要求，插入的元素不能是</span> 
 <span style="color:#333333;">null</span> 
 <span style="color:#333333;">或者元素之间必须要能够</span> 
 <span style="color:#333333;">进行比较。</span>  
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94d52bd1681349a78a6a40790164d740/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flink-CDC解析（第47天）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4f9bf5cdfd28b96b54c9f5a5a632854c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">给ACM小白的学习建议（干货满满）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>