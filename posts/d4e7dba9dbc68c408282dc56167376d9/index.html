<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java数据结构】初始线性表之一：链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d4e7dba9dbc68c408282dc56167376d9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java数据结构】初始线性表之一：链表">
  <meta property="og:description" content="为什么要有链表 上一节我们描述了顺序表：【Java数据结构】初识线性表之一：顺序表-CSDN博客
并且进行了简单模拟实现。通过源码知道，ArrayList底层使用数组来存储元素。
由于其底层是一段连续空间，当在ArrayList任意位置插入或者删除元素时，就需要将后序元素整体往前或者往后搬移，时间复杂度为O(n)，效率比较低，因此ArrayList不适合做任意位置插入和删除比较多的场景。因此：java集合中又引入了LinkedList，即链表结构。
链表 链表的概念及结构
链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的 。
注意：
链表的结构在逻辑上是连续的，但是在物理位置上不一定连续。节点一般都是从堆上申请出来的。从堆上申请空间是按一定策略来分配的，两次申请的空间可能会连续，也可能不连续。 实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：
单向或者双向带头或者不带头循环或者非循环 本章节我们来描述其中两种：
无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。无头双向链表：在Java的集合框架库中LinkedList底层实现就是无头双向循环链表。 模拟实现无头单向非循环链表 模拟实现无头单向非循环链表主要有以下的方法：
public class SingleLinkedList {
//头插法
public void addFirst(int data){
}
//尾插法
public void addLast(int data){
}
//任意位置插入,第一个数据节点为0号下标
public void addIndex(int index,int data){
}
//查找是否包含关键字key是否在单链表当中
public boolean contains(int key){
return false;
}
//删除第一次出现关键字为key的节点
public void remove(int key){
}
//删除所有值为key的节点
public void removeAllKey(int key){
}
//得到单链表的长度
public int size(){
return -1;
}
public void clear() {">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T22:16:31+08:00">
    <meta property="article:modified_time" content="2024-07-17T22:16:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java数据结构】初始线性表之一：链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>为什么要有链表</h2> 
<p>上一节我们描述了顺序表：<a href="https://blog.csdn.net/yican2580/article/details/140336468?spm=1001.2014.3001.5501" title="【Java数据结构】初识线性表之一：顺序表-CSDN博客">【Java数据结构】初识线性表之一：顺序表-CSDN博客</a></p> 
<p>并且进行了简单模拟实现。通过源码知道，ArrayList底层使用数组来存储元素。</p> 
<p>由于其底层是一段连续空间，当在ArrayList任意位置插入或者删除元素时，就需要将后序元素整体往前或者往后搬移，时间复杂度为O(n)，效率比较低，因此ArrayList不适合做任意位置插入和删除比较多的场景。因此：java集合中又引入了LinkedList，即链表结构。</p> 
<h2>链表</h2> 
<p><img alt="" height="456" src="https://images2.imgbox.com/fb/77/8Of3LpvY_o.jpg" width="885"></p> 
<p> <strong>链表的概念及结构</strong></p> 
<p>链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的 。</p> 
<p><strong>注意：</strong></p> 
<ul><li>链表的结构在逻辑上是连续的，但是在物理位置上不一定连续。</li><li>节点一般都是从堆上申请出来的。</li><li>从堆上申请空间是按一定策略来分配的，两次申请的空间可能会连续，也可能不连续。</li></ul> 
<p><strong>实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：</strong></p> 
<ul><li><strong>单向或者双向</strong></li><li><strong>带头或者不带头</strong></li><li><strong>循环或者非循环</strong></li></ul> 
<p>本章节我们来描述其中两种：</p> 
<ol><li>无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。</li><li>无头双向链表：在Java的集合框架库中LinkedList底层实现就是无头双向循环链表。</li></ol> 
<h3>模拟实现无头单向非循环链表</h3> 
<p>模拟实现无头单向非循环链表主要有以下的方法：</p> 
<blockquote> 
 <p>public class SingleLinkedList {<!-- --><br>    //头插法<br>    public void addFirst(int data){<!-- --><br>   }<br>    //尾插法<br>    public void addLast(int data){<!-- --><br>   }<br>    //任意位置插入,第一个数据节点为0号下标<br>    public void addIndex(int index,int data){<!-- --><br>   }<br>    //查找是否包含关键字key是否在单链表当中<br>    public boolean contains(int key){<!-- --><br>        return false;<br>   }<br>    //删除第一次出现关键字为key的节点<br>    public void remove(int key){<!-- --><br>   }</p> 
 <p>  //删除所有值为key的节点<br>    public void removeAllKey(int key){<!-- --><br>   }<br>    //得到单链表的长度<br>    public int size(){<!-- --><br>        return -1;<br>   }<br>    public void clear() {<!-- --><br>   }<br>    <br>    public void display() {}<br> }</p> 
</blockquote> 
<p>链表的插入：</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/38/6d/IqKEeKLV_o.png" width="984"> </p> 
<p>链表的删除：</p> 
<p><img alt="" height="730" src="https://images2.imgbox.com/66/3c/FJZM66iN_o.jpg" width="1200"> 模拟链表的代码实现：</p> 
<pre><code class="language-java">public class MySingLeList {
    static class ListNode{
        public int val;
        public ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
    public ListNode head;

    public void createList(){
        ListNode node1 = new ListNode(12);
        ListNode node2 = new ListNode(34);
        ListNode node3 = new ListNode(45);
        ListNode node4 = new ListNode(56);
        ListNode node5 = new ListNode(67);

        node1.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node5;
        this.head = node1;
    }

    public void display(){
        ListNode tmp = this.head;
        while(!(tmp == null)){
            System.out.print(tmp.val+" ");
            tmp = tmp.next;
        }
    }

    public int size(){
        ListNode tmp = this.head;
        int count = 0;
        while(!(tmp == null)){
            count++;
            tmp = tmp.next;
        }
        return count;
    }

    public boolean contains(int findData){
        ListNode tmp = this.head;
        while(!(tmp == null)){
            if(tmp.val == findData){
                return true;
            }
        }
        return false;
    }

    public void addFirst(int data){
        ListNode node = new ListNode(data);
        node.next = this.head;
        this.head = node;
    }

    public void addLast(int data){
        ListNode node = new ListNode(data);
        ListNode tmp = this.head;
        if(tmp == null){
            this.head = node;
            return;
        }
        while(!(tmp.next == null)){
            tmp = tmp.next;
        }
        tmp.next = node;
    }

    public void addIndex(int pos,int data){
        ListNode node = new ListNode(data);
        ListNode tmp = this.head;
        if(pos == 0){
            node.next = tmp;
            this.head = node;
            return;
        } else if (pos == this.size()) {
            this.addLast(data);
        } else if (pos &gt; this.size()) {
            System.out.println("输入的位置错误！");
        }else{
            for (int i = 0; i &lt; pos -1; i++) {
                tmp = tmp.next;
            }
            node.next = tmp.next;
            tmp.next = node;
        }
    }

    public void remove(int data){
        int flag = 1;
        ListNode tmp = this.head;
        if(this.head.val == data){
            this.head = this.head.next;
            return;
        }
        while(tmp.next != null){
            if(tmp.next.val== data){
                flag = 0;
                break;
            }
            tmp = tmp.next;
        }
        if(flag == 0){
            tmp.next = tmp.next.next;
        }else{
            System.out.println("链表中没有该元素！");
        }
    }
    public void removeAll(int data){
        ListNode prv = this.head;
        ListNode tmp = this.head.next;
        while(tmp != null){
            if(tmp.val == data){
                prv.next = tmp.next;
                tmp = tmp.next;
            }else{
                prv = tmp;
                tmp = tmp.next;
            }
        }
        if(this.head.val == data){
            this.head = this.head.next;
        }
    }

    public void clear(){
        this.head = null;
    }
}</code></pre> 
<h3>模拟实现无头双向链表</h3> 
<p>无头双向链表主要有以下的方法：</p> 
<blockquote> 
 <p>public class MyLinkedList {<!-- --><br>   //头插法<br>    public void addFirst(int data){ }<br>    //尾插法<br>    public void addLast(int data){}<br>    //任意位置插入,第一个数据节点为0号下标<br>    public void addIndex(int index,int data){}<br>    //查找是否包含关键字key是否在单链表当中<br>    public boolean contains(int key){}<br>    //删除第一次出现关键字为key的节点<br>    public void remove(int key){}<br>    //删除所有值为key的节点<br>    public void removeAllKey(int key){}<br>    //得到单链表的长度<br>    public int size(){}<br>    public void display(){}<br>    public void clear(){}<br> }</p> 
</blockquote> 
<p>双向链表的插入：</p> 
<p><img alt="" height="879" src="https://images2.imgbox.com/4b/a1/9JwG6ZnK_o.png" width="1200"> </p> 
<p>双向链表的删除：</p> 
<p> <img alt="" height="1080" src="https://images2.imgbox.com/0d/2c/1cUdXygr_o.jpg" width="1200"></p> 
<p> 模拟代码实现：</p> 
<pre><code class="language-java">public class MyLinkedList {
    static class ListNode{
        private int val;
        private ListNode prev;
        private ListNode next;

        public ListNode(int val) {
            this.val = val;
        }
    }
    ListNode head;
    ListNode last;

        //头插法
        public void addFirst(int data){
            ListNode node = new ListNode(data);
            if(head == null){
                head = node;
                last = node;
            }else{
                node.next = head;
                head.prev = node;
                head = node;
            }
        }
        //尾插法
        public void addLast(int data){
            ListNode node = new ListNode(data);
            if(head == null){
                head = node;
                last = node;
            }else{
                last.next = node;
                node.prev = last;
                last = node;
            }
        }
        //任意位置插入,第一个数据节点为0号下标
        public void addIndex(int pos,int data){
            ListNode node = new ListNode(data);
            ListNode cur = head;
            if(pos == 0){
                addFirst(data);
            }else if(pos == this.size()){
                addLast(data);
            }else if(pos &lt; 0 || pos &gt; this.size()){
                System.out.println("插入位置错误！");
            }else{
                for (int i = 0; i &lt; pos; i++) {
                    cur = cur.next;
                }
                cur.prev.next = node;
                node.prev = cur.prev;
                node.next = cur;
                cur.prev = node;
            }

        }
        //查找是否包含关键字key是否在单链表当中
        public boolean contains(int key){
            ListNode tmp = this.head;
            while(!(tmp == null)){
                if(tmp.val == key){
                    return true;
                }
            }
            return false;
        }
        //删除第一次出现关键字为key的节点
        public void remove(int key){
            ListNode cur = head;
            while(cur != null){
                if(cur.val == key){
                    if(cur == head){
                        head = head.next;
                        if(head != null){
                            head.prev =null;
                        }else{
                            last = null;
                        }
                        return;
                    }else if(cur == last){
                        last = last.prev;
                        last.next = null;
                        return;
                    }else{
                        cur.prev.next = cur.next;
                        cur.next.prev = cur.prev;
                        return;
                    }
                }else{
                    cur = cur.next;
                }
            }
            System.out.println("没有该元素！");
            return;
        }
        //删除所有值为key的节点
        public void removeAllKey(int key){
            ListNode cur = head;
            while(cur != null){
                if(cur.val == key){
                    if(cur == head){
                        head = head.next;
                        if(head != null){
                            head.prev =null;
                        }else{
                            last = null;
                        }
                    }else if(cur == last){
                        last = last.prev;
                        last.next = null;
                    }else{
                        cur.prev.next = cur.next;
                        cur.next.prev = cur.prev;
                    }
                }
                cur = cur.next;
            }
            System.out.println("没有该元素！");
            return;
        }
        //得到链表的长度
        public int size(){
            int count = 0;
            ListNode cur = head;
            while(cur != null){
                count++;
                cur = cur.next;
            }
            return count;
        }
        public void display(){
            ListNode tmp = this.head;
            while(!(tmp == null)){
                System.out.print(tmp.val+" ");
                tmp = tmp.next;
            }
        }
        public void clear(){
            ListNode cur = head;
            while(cur != null){
                ListNode curNext = cur.next;
                cur.prev = null;
                cur.next = null;
                cur = curNext;
            }
            head = null;
            last = null;
        }
}</code></pre> 
<h2>LinkedList 的使用</h2> 
<h3>什么是LinkedList</h3> 
<p>LinkedList的底层是双向链表结构(链表后面介绍)，由于链表没有将元素存储在连续的空间中，元素存储在单独的节点中，然后通过引用将节点连接起来了，因此在在任意位置插入或者删除元素时，不需要搬移元素，效率比较高。</p> 
<p><strong>在集合框架中，LinkedList也实现了List接口，具体如下：</strong></p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/54/7f/Xy47ScVC_o.png" width="804"></p> 
<p><strong>注意 ：</strong></p> 
<ul><li>1. LinkedList实现了List接口</li><li>2. LinkedList的底层使用了双向链表</li><li>3. LinkedList没有实现RandomAccess接口，因此LinkedList不支持随机访问 </li><li>4. LinkedList的任意位置插入和删除元素时效率比较高，时间复杂度为O(1)</li><li>5. LinkedList比较适合任意位置插入的场景</li></ul> 
<h3>LinkedList 的构造方法</h3> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();//无参构造

        List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(1);
        list2.add(2);
        list2.add(3);
        List&lt;Integer&gt; list3 = new LinkedList&lt;&gt;(list2);//使用其他集合容器中元素构造List
        list3.add(4);
        System.out.println(list3);
    }
}</code></pre> 
<h3>LinkedList 常用方法介绍</h3> 
<h4>插入节点</h4> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();
        list1.add(5);
        list1.add(6);
        List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(1);//尾插
        list2.add(2);
        list2.add(3);
        list2.add(1,4);//在指定位置插入节点
        list2.addAll(list1);//尾插其他容器中的所有节点
        System.out.println(list2);
    }
}</code></pre> 
<h4>删除节点：</h4> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(1);
        list2.add(2);
        list2.add(3);
        list2.remove(1);//删除指定位置的节点
        list2.remove(new Integer(3));//删除指定元素的节点
        System.out.println(list2);
    }
}</code></pre> 
<h4>获取指定位置的元素：</h4> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(1);
        list2.add(2);
        list2.add(3);

        System.out.println(list2.get(1));
    }
}</code></pre> 
<h4>更新指定位置的元素：</h4> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(1);
        list2.add(2);
        list2.add(3);
        list2.set(1,4);
        System.out.println(list2);
    }
}</code></pre> 
<h4>判断指定元素是否在链表中：</h4> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(1);
        list2.add(2);
        list2.add(3);
        System.out.println(list2.contains(new Integer(2)));
    }
}</code></pre> 
<h4>截取部分 list</h4> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;();
        list2.add(1);
        list2.add(2);
        list2.add(3);
        System.out.println(list2.subList(0,2));
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7df0462161de18c89308446579ef854d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络和安全操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7fe68c2374cb85b37c3b706f6befb3d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">浅谈数学模型在UGC/AIGC游戏数值配置调参中的应用(AI智能体)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>