<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL 简介（标准模板库） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fa60774432b042b237ce7b93aa71513b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="STL 简介（标准模板库）">
  <meta property="og:description" content="前言 通过对C&#43;&#43;的特性，类和对象的学习和C&#43;&#43;的内存管理对C&#43;&#43;基本上有了全面的认识，但是C&#43;&#43;的核心在于STL
一、STL简介 什么是STL C&#43;&#43; STL（Standard Template Library，标准模板库）是C&#43;&#43;编程语言中一个功能强大的模板库，它提供了一系列通用的数据结构和算法。STL的设计基于泛型编程，这意味着它使用模板来编写独立于任何特定数据类型的代码。STL的核心组件包括容器（如向量、链表、集合等）、迭代器、算法、函数对象和适配器等。这些组件使得程序员能够以简洁、高效的方式处理数据结构和算法问题，减少了编码工作量，提高了代码的可重用性和性能 STL版本 HP STL：由Alexander Stepanov和Meng Lee在惠普实验室完成的原始版本，是所有STL实现版本的始祖。PJ STL：由P. J. Plauger开发，继承自HP版本，被Windows Visual C&#43;&#43;采用。SGI STL：由Silicon Graphics Computer Systems, Inc公司开发，继承自HP版本，被GCC（Linux）采用，可移植性好，可公开、修改甚至贩卖。STLport：由Boris Fomitchev开发，继承自SGI STL，旨在提供一个可移植到不同平台的STL版本 STL为什么可以成为C&#43;&#43;标准库的一部分 泛型编程支持：STL利用C&#43;&#43;的模板机制实现了泛型编程，使得容器和算法能够处理不同类型的数据，提高了代码的重用性和灵活性。 !高效的数据结构：STL提供了多种容器类，如向量（vector）、链表（list）、双端队列（deque）、集合（set）、映射（map）等，这些容器具有高效的数据存储和访问方式，并且可以方便地进行插入、删除和查找等操作。统一的迭代器接口：STL的容器和算法都使用迭代器来访问和操作元素，迭代器提供了统一的接口，使得算法可以独立于具体的数据类型进行操作丰富的算法库：STL提供了一系列算法库，包括排序、查找、合并、堆操作、数值算法等，这些算法都被实现为函数模板，可以方便地应用于不同的容器和数据类型。函数对象的使用：STL的算法库中使用了函数对象（Functor）来封装操作，通过函数对象，STL可以将自定义的操作应用于算法中，提高了代码的可定制性和扩展性。自动内存管理：STL的容器类和算法库都采用了自动的内存管理机制，有效避免了内存泄漏和访问越界等问题。 STL六大组件 STL 仿函数 空间适配器 算法 容器 迭代器 配接器 二、模板 模板特性 函数模板特化：当需要为特定类型提供不同于模板定义的函数行为时，可以使用函数模板特化。例如，对于内置类型int，可能需要一个优化过的打印函数，而对于其他类型则使用通用模板定义。类模板特化：类模板特化允许为特定类型或类型组合提供定制化的类成员函数或数据成员。这在需要为特定类型提供特定的类行为时非常有用。模板偏特化：模板偏特化是模板特化的一种形式，它允许部分参数的定制化，而保留其他参数的泛化行为。这在处理具有共同基类或接口的不同派生类型时特别有用。全特化：全特化是指为模板提供一个具体类型的实现，这样编译器在遇到该具体类型时会直接使用特化版本，而不是泛化版本。这有助于提高代码的效率和减少编译时间。参数修饰特化：参数修饰特化是通过改变模板参数的类型或数量来实现特化的技术。这可以用来解决模板参数匹配的歧义或提供额外的功能。非类型模板参数特化：非类型模板参数特化允许为特定的非类型参数值提供定制化的模板实现，这在需要根据不同的常量大小或值来调整模板行为时非常有用 泛型编程 在学习C语言的时候如果实现两个数交换 比如：整形，浮点型，字符，会写三个函数。
void Swap(int&amp; left, int&amp; right) { int temp = left; left = right; right = temp; } void Swap(double&amp; left, double&amp; right) { double temp = left; left = right; right = temp; } void Swap(char&amp; left, char&amp; right) { char temp = left; left = right; right = temp; } 这样重复性的代码，是很多人讨厌的地方，正因为这个出现了泛型编程。以上的代码一个用一个函数模板替代，交给编译器实现。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T21:20:58+08:00">
    <meta property="article:modified_time" content="2024-07-23T21:20:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL 简介（标准模板库）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<blockquote> 
 <p>通过对C++的特性，类和对象的学习和C++的内存管理对C++基本上有了全面的认识，但是C++的核心在于<code>STL</code></p> 
</blockquote> 
<h2><a id="STL_4"></a>一、<code>STL</code>简介</h2> 
<h3><a id="STL_6"></a>什么是<code>STL</code></h3> 
<ul><li>C++ <code>STL</code>（Standard Template Library，标准模板库）是C++编程语言中一个功能强大的模板库，它提供了一系列通用的数据结构和算法。</li><li><code>STL</code>的设计基于泛型编程，这意味着它使用模板来编写独立于任何特定数据类型的代码。</li><li><code>STL</code>的核心组件包括容器（如向量、链表、集合等）、迭代器、算法、函数对象和适配器等。</li><li>这些组件使得程序员能够以简洁、高效的方式处理数据结构和算法问题，减少了编码工作量，提高了代码的可重用性和性能</li></ul> 
<h3><a id="STL_13"></a><code>STL</code>版本</h3> 
<ul><li><strong><code>HP STL</code></strong>：由Alexander <code>Stepanov</code>和<code>Meng Lee</code>在惠普实验室完成的原始版本，是所有STL实现版本的始祖。</li><li><strong><code>PJ STL</code></strong>：由<code>P. J. Plauge</code>r开发，继承自HP版本，被Windows Visual C++采用。</li><li><strong><code>SGI STL</code></strong>：由Silicon Graphics Computer Systems, Inc公司开发，继承自HP版本，被<code>GCC</code>（Linux）采用，可移植性好，可公开、修改甚至贩卖。</li><li><strong><code>STLport</code></strong>：由<code>Boris Fomitchev</code>开发，继承自<code>SGI STL</code>，旨在提供一个可移植到不同平台的<code>STL</code>版本</li></ul> 
<h3><a id="STLC_20"></a><code>STL</code>为什么可以成为C++标准库的一部分</h3> 
<ol><li><strong>泛型编程支持</strong>：<code>STL</code>利用C++的模板机制实现了泛型编程，使得容器和算法能够处理不同类型的数据，提高了代码的重用性和灵活性。 !</li><li><strong>高效的数据结构</strong>：<code>STL</code>提供了多种容器类，如向量（vector）、链表（list）、双端队列（deque）、集合（set）、映射（map）等，这些容器具有高效的数据存储和访问方式，并且可以方便地进行插入、删除和查找等操作。</li><li><strong>统一的迭代器接口</strong>：<code>STL</code>的容器和算法都使用迭代器来访问和操作元素，迭代器提供了统一的接口，使得算法可以独立于具体的数据类型进行操作</li><li><strong>丰富的算法库</strong>：<code>STL</code>提供了一系列算法库，包括排序、查找、合并、堆操作、数值算法等，这些算法都被实现为函数模板，可以方便地应用于不同的容器和数据类型。</li><li><strong>函数对象的使用</strong>：<code>STL</code>的算法库中使用了函数对象（Functor）来封装操作，通过函数对象，<code>STL</code>可以将自定义的操作应用于算法中，提高了代码的可定制性和扩展性。</li><li><strong>自动内存管理</strong>：<code>STL</code>的容器类和算法库都采用了自动的内存管理机制，有效避免了内存泄漏和访问越界等问题。</li></ol> 
<h3><a id="STL_29"></a><code>STL</code>六大组件</h3> 
<div class="mermaid"> 
 <svg id="mermaid-svg-JwiJESxk02w8pE7M" width="644" xmlns="http://www.w3.org/2000/svg" height="148" viewbox="0 0 644 148" class="mermaid-svg"> 
  <style>#mermaid-svg-JwiJESxk02w8pE7M {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-svg-JwiJESxk02w8pE7M .error-icon{fill:#552222;}#mermaid-svg-JwiJESxk02w8pE7M .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-JwiJESxk02w8pE7M .edge-thickness-normal{stroke-width:2px;}#mermaid-svg-JwiJESxk02w8pE7M .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-JwiJESxk02w8pE7M .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-JwiJESxk02w8pE7M .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-JwiJESxk02w8pE7M .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-JwiJESxk02w8pE7M .marker{fill:#333333;stroke:#333333;}#mermaid-svg-JwiJESxk02w8pE7M .marker.cross{stroke:#333333;}#mermaid-svg-JwiJESxk02w8pE7M svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-JwiJESxk02w8pE7M .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-JwiJESxk02w8pE7M .cluster-label text{fill:#333;}#mermaid-svg-JwiJESxk02w8pE7M .cluster-label span{color:#333;}#mermaid-svg-JwiJESxk02w8pE7M .label text,#mermaid-svg-JwiJESxk02w8pE7M span{fill:#333;color:#333;}#mermaid-svg-JwiJESxk02w8pE7M .node rect,#mermaid-svg-JwiJESxk02w8pE7M .node circle,#mermaid-svg-JwiJESxk02w8pE7M .node ellipse,#mermaid-svg-JwiJESxk02w8pE7M .node polygon,#mermaid-svg-JwiJESxk02w8pE7M .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-JwiJESxk02w8pE7M .node .label{text-align:center;}#mermaid-svg-JwiJESxk02w8pE7M .node.clickable{cursor:pointer;}#mermaid-svg-JwiJESxk02w8pE7M .arrowheadPath{fill:#333333;}#mermaid-svg-JwiJESxk02w8pE7M .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-JwiJESxk02w8pE7M .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-JwiJESxk02w8pE7M .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid-svg-JwiJESxk02w8pE7M .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid-svg-JwiJESxk02w8pE7M .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-JwiJESxk02w8pE7M .cluster text{fill:#333;}#mermaid-svg-JwiJESxk02w8pE7M .cluster span{color:#333;}#mermaid-svg-JwiJESxk02w8pE7M div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-JwiJESxk02w8pE7M :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style> 
  <g transform="translate(0, 0)"> 
   <marker id="flowchart-pointEnd" class="marker flowchart" viewbox="0 0 10 10" refx="9" refy="5" markerunits="userSpaceOnUse" markerwidth="12" markerheight="12" orient="auto"> 
    <path d="M 0 0 L 10 5 L 0 10 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <marker id="flowchart-pointStart" class="marker flowchart" viewbox="0 0 10 10" refx="0" refy="5" markerunits="userSpaceOnUse" markerwidth="12" markerheight="12" orient="auto"> 
    <path d="M 0 5 L 10 10 L 10 0 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <marker id="flowchart-circleEnd" class="marker flowchart" viewbox="0 0 10 10" refx="11" refy="5" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle> 
   </marker> 
   <marker id="flowchart-circleStart" class="marker flowchart" viewbox="0 0 10 10" refx="-1" refy="5" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></circle> 
   </marker> 
   <marker id="flowchart-crossEnd" class="marker cross flowchart" viewbox="0 0 11 11" refx="12" refy="5.2" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <marker id="flowchart-crossStart" class="marker cross flowchart" viewbox="0 0 11 11" refx="-1" refy="5.2" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"> 
    <path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path> 
   </marker> 
   <g class="root"> 
    <g class="clusters"></g> 
    <g class="edgePaths"> 
     <path d="M317.953125,31.555721314907874L271.5442708333333,38.62976776242323C225.13541666666666,45.70381420993858,132.31770833333334,59.85190710496929,85.90885416666667,71.09262021915131C39.5,82.33333333333333,39.5,90.66666666666667,39.5,94.83333333333333L39.5,99" id="L-STL-仿函数-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-STL LE-仿函数" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M317.953125,33.8813145280236L293.0442708333333,40.56776210668634C268.1354166666667,47.254209685349075,218.31770833333334,60.627104842674534,193.40885416666666,71.48021908800393C168.5,82.33333333333333,168.5,90.66666666666667,168.5,94.83333333333333L168.5,99" id="L-STL-空间适配器-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-STL LE-空间适配器" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M317.953125,47.30686211340206L313.2109375,51.755718427835056C308.46875,56.20457474226804,298.984375,65.10228737113403,294.2421875,73.71781035223368C289.5,82.33333333333333,289.5,90.66666666666667,289.5,94.83333333333333L289.5,99" id="L-STL-算法-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-STL LE-算法" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M358.046875,47.30686211340206L362.7890625,51.755718427835056C367.53125,56.20457474226804,377.015625,65.10228737113403,381.7578125,73.71781035223368C386.5,82.33333333333333,386.5,90.66666666666667,386.5,94.83333333333333L386.5,99" id="L-STL-容器-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-STL LE-容器" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M358.046875,34.442233306188925L380.2890625,41.03519442182411C402.53125,47.628155537459286,447.015625,60.814077768729646,469.2578125,71.5737055510315C491.5,82.33333333333333,491.5,90.66666666666667,491.5,94.83333333333333L491.5,99" id="L-STL-迭代器-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-STL LE-迭代器" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
     <path d="M358.046875,31.92263719512195L399.1223958333333,38.93553099593496C440.1979166666667,45.948424796747965,522.3489583333334,59.974212398373986,563.4244791666666,71.15377286585367C604.5,82.33333333333333,604.5,90.66666666666667,604.5,94.83333333333333L604.5,99" id="L-STL-配接器-0" class=" edge-thickness-normal edge-pattern-solid flowchart-link LS-STL LE-配接器" style="fill:none;" marker-end="url(#flowchart-pointEnd)"></path> 
    </g> 
    <g class="edgeLabels"> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="edgeLabel"> 
      <g class="label" transform="translate(0, 0)"> 
       <foreignobject width="0" height="0"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="edgeLabel"></span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
    </g> 
    <g class="nodes"> 
     <g class="node default default" id="flowchart-STL-60" transform="translate(338, 28.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-20.046875" y="-20.5" width="40.09375" height="41"></rect> 
      <g class="label" style="" transform="translate(-12.546875, -13)"> 
       <foreignobject width="25.09375" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">STL</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-仿函数-61" transform="translate(39.5, 119.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-31.5" y="-20.5" width="63" height="41"></rect> 
      <g class="label" style="" transform="translate(-24, -13)"> 
       <foreignobject width="48" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">仿函数</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-空间适配器-63" transform="translate(168.5, 119.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-47.5" y="-20.5" width="95" height="41"></rect> 
      <g class="label" style="" transform="translate(-40, -13)"> 
       <foreignobject width="80" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">空间适配器</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-算法-65" transform="translate(289.5, 119.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-23.5" y="-20.5" width="47" height="41"></rect> 
      <g class="label" style="" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">算法</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-容器-67" transform="translate(386.5, 119.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-23.5" y="-20.5" width="47" height="41"></rect> 
      <g class="label" style="" transform="translate(-16, -13)"> 
       <foreignobject width="32" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">容器</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-迭代器-69" transform="translate(491.5, 119.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-31.5" y="-20.5" width="63" height="41"></rect> 
      <g class="label" style="" transform="translate(-24, -13)"> 
       <foreignobject width="48" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">迭代器</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
     <g class="node default default" id="flowchart-配接器-71" transform="translate(604.5, 119.5)"> 
      <rect class="basic label-container" style="" rx="0" ry="0" x="-31.5" y="-20.5" width="63" height="41"></rect> 
      <g class="label" style="" transform="translate(-24, -13)"> 
       <foreignobject width="48" height="26"> 
        <div style="display: inline-block; white-space: nowrap;"> 
         <span class="nodeLabel">配接器</span> 
        </div> 
       </foreignobject> 
      </g> 
     </g> 
    </g> 
   </g> 
  </g> 
 </svg> 
</div> 
<h2><a id="_41"></a>二、模板</h2> 
<h3><a id="_43"></a>模板特性</h3> 
<ul><li><strong>函数模板特化</strong>：当需要为特定类型提供不同于模板定义的函数行为时，可以使用函数模板特化。例如，对于内置类型<code>int</code>，可能需要一个优化过的打印函数，而对于其他类型则使用通用模板定义。</li><li><strong>类模板特化</strong>：类模板特化允许为特定类型或类型组合提供定制化的类成员函数或数据成员。这在需要为特定类型提供特定的类行为时非常有用。</li><li><strong>模板偏特化</strong>：模板偏特化是模板特化的一种形式，它允许部分参数的定制化，而保留其他参数的泛化行为。这在处理具有共同基类或接口的不同派生类型时特别有用。</li><li><strong>全特化</strong>：全特化是指为模板提供一个具体类型的实现，这样编译器在遇到该具体类型时会直接使用特化版本，而不是泛化版本。这有助于提高代码的效率和减少编译时间。</li><li><strong>参数修饰特化</strong>：参数修饰特化是通过改变模板参数的类型或数量来实现特化的技术。这可以用来解决模板参数匹配的歧义或提供额外的功能。</li><li><strong>非类型模板参数特化</strong>：非类型模板参数特化允许为特定的非类型参数值提供定制化的模板实现，这在需要根据不同的常量大小或值来调整模板行为时非常有用</li></ul> 
<h3><a id="_52"></a>泛型编程</h3> 
<p>在学习C语言的时候如果实现两个数交换 比如：整形，浮点型，字符，会写三个函数。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">int</span> temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
 left <span class="token operator">=</span> right<span class="token punctuation">;</span>
 right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">double</span> temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
 left <span class="token operator">=</span> right<span class="token punctuation">;</span>
 right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> left<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">char</span> temp <span class="token operator">=</span> left<span class="token punctuation">;</span>
 left <span class="token operator">=</span> right<span class="token punctuation">;</span>
 right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样重复性的代码，是很多人讨厌的地方，正因为这个出现了泛型编程。以上的代码一个用一个函数模板替代，交给编译器实现。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>在实现整形交换的时候传整形，实现浮点型减缓的时候传浮点型。</li></ul> 
<h3><a id="_93"></a>函数模板的的原理</h3> 
<ul><li>传不同的类型编译器会自动生成不同类型的函数。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">//在调用这三个函数的时候编译器底层调用的函数地址是不样的</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token char">'e'</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token char">'f'</span><span class="token punctuation">;</span>
<span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Swap</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Swap</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token number">23</span><span class="token operator">:</span> 	<span class="token function">Swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">00007FF</span>760C019EE  lea         rdx<span class="token punctuation">,</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span>  
<span class="token number">00007FF</span>760C019F2  lea         rcx<span class="token punctuation">,</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span>  
<span class="token number">00007FF</span>760C019F6  call        <span class="token generic-function"><span class="token function">Swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span> <span class="token punctuation">(</span><span class="token number">07FF</span>760C012F8h<span class="token punctuation">)</span>  
<span class="token number">00007FF</span>760C019FB  nop  
    <span class="token number">24</span><span class="token operator">:</span> 	<span class="token function">Swap</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">00007FF</span>760C019FC  lea         rdx<span class="token punctuation">,</span><span class="token punctuation">[</span>d<span class="token punctuation">]</span>  
<span class="token number">00007FF</span>760C01A00  lea         rcx<span class="token punctuation">,</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>  
<span class="token number">00007FF</span>760C01A04  call        <span class="token generic-function"><span class="token function">Swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span> <span class="token punctuation">(</span><span class="token number">07FF</span>760C012F8h<span class="token punctuation">)</span>  
<span class="token number">00007FF</span>760C01A09  nop  
    <span class="token number">25</span><span class="token operator">:</span> 	<span class="token function">Swap</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">00007FF</span>760C01A0A  lea         rdx<span class="token punctuation">,</span><span class="token punctuation">[</span>f<span class="token punctuation">]</span>  
<span class="token number">00007FF</span>760C01A11  lea         rcx<span class="token punctuation">,</span><span class="token punctuation">[</span>e<span class="token punctuation">]</span>  
<span class="token number">00007FF</span>760C01A18  call        <span class="token generic-function"><span class="token function">Swap</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span> <span class="token punctuation">(</span><span class="token number">07FF</span>760C012F8h<span class="token punctuation">)</span>  
<span class="token number">00007FF</span>760C01A1D  nop  
</code></pre> 
<p>函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模 板就是将本来应该我们做的重复的事情交给了编译器</p> 
<h3><a id="_129"></a>类模板</h3> 
<p>类模板是一种强大的编程技术，它允许开发者定义泛型类，这些类可以在创建时指定不同的数据类型。</p> 
<h4><a id="_133"></a>类模板的定义</h4> 
<ol><li><strong>关键字<code>template</code></strong>：用于声明模板的开始。</li><li><strong>模板参数列表</strong>：位于尖括号<code>&lt; &gt;</code>内，定义了模板的类型参数或非类型参数。类型参数通常使用<code>typename</code>或<code>class</code>关键字声明。</li><li><strong>类模板名</strong>：紧随模板参数列表之后，是模板的名称。</li><li><strong>类模板体</strong>：包含类模板的成员声明，可以是类的定义、函数定义或类型别名等。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    T member<span class="token punctuation">;</span>
    <span class="token function">MyClass</span><span class="token punctuation">(</span>T initialValue<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">member</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
    <span class="token comment">// 其他成员函数和类型定义</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_152"></a>模板的实例化</h3> 
<ul><li>函数模板实例化是指编译器根据函数模板和具体类型的实参生成特定类型的函数定义的过程。</li></ul> 
<h4><a id="_156"></a>隐式实例化</h4> 
<ul><li>隐式实例化是编译器在遇到函数模板调用时自动进行的实例化过程。编译器根据函数调用的实参类型来推导模板参数的实际类型，并生成相应的模板函数实例。</li></ul> 
<p>例如，如果有一个模板函数 <code>template &lt;typename T&gt; void f(T a, T b)</code>，当调用 <code>f(1, 2)</code> 时，编译器会自动实例化一个 <code>f&lt;int&gt;(int, int)</code> 的函数版本。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//写出一个模板</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//在调用f(1,1)，会生成 int swap(int&amp; a,int&amp; b)</span>
<span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_180"></a>显示实例化</h4> 
<ul><li>显式实例化是指程序员在代码中明确指定模板实例化的具体类型，以便提前生成相应的模板函数实例。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">//写出一个模板</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//在调用f&lt;int&gt;(1.0,1.0)，会生成 int swap(float&amp; a,float&amp; b)</span>
<span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span><span class="token keyword">float</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>
	a <span class="token operator">=</span> b<span class="token punctuation">;</span>
	b <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a098f48609d4aaca628f7cbe56c9fc8b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何查看Kafka的偏移量offset</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2914cda935dbed435053b4c28e0beeaf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript 进阶必备：掌握 Symbol 新标识符用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>