<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>priority_queue模拟实现【C&#43;&#43;】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1c20d56a6bf49b9056378adc8d350a52/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="priority_queue模拟实现【C&#43;&#43;】">
  <meta property="og:description" content="文章目录 全部的实现代码放在了文章末尾什么是适配器模式？准备工作包含头文件定义命名空间类的成员变量什么是仿函数？比较仿函数在priority_queue中的作用通过传入不同的仿函数可以做到大堆和小堆之间的切换通过传入不同的仿函数可以做到改变priority_queue里面的比较逻辑 构造函数默认构造迭代器区间构造 sizeemptytoppushpop 全部代码 全部的实现代码放在了文章末尾 【不了解堆（priority_queue）的可以看我这篇文章：模拟实现堆的接口函数】
priority_queue的模拟实现和stack，queue一样，采用了C&#43;&#43;适配器模式
priority_queue的适配器一般是vector，也可以是deque
因为priority_queue是有特殊限制的线性表【只能取堆顶数据，并且需要高效的尾插尾删，还要支持高效的下标访问（因为priority_queue的push和pop一般是调用适配器的尾插，尾删。 实现向下（上）调整算法的时候需要高效的下标访问方法）】
所以只要是线性结构并且可以高效的实现尾插和尾删，支持高效的下标访问的线性表，就可以作为priority_queue的适配器
什么是适配器模式？ 适配器模式是一种设计模式，它允许将不兼容接口的类一起工作。
适配器模式通常用于以下情况：
希望使用一个类，但其接口与其他代码不兼容。希望创建一个可重用的类，它能够将接口转换为其他接口。希望使用第三方库或遗留代码，但其接口与其他代码不兼容。 适配器模式通常包括以下三个主要部分：
目标接口（Target）：这是期望使用的接口，客户端代码只能与目标接口交互。源接口（Adaptee）：这是需要适配的类，其接口与目标接口不兼容。适配器（Adapter）：这是一个类，它实现了目标接口，并将调用转换为对源接口的调用。适配器将源接口的调用转换为目标接口的调用，使得客户端代码可以与目标接口交互。 可以类比我们生活中的家庭电源接口和笔记本电脑充电口与电源适配器，它们之间也是一种适配器关系
笔记本电脑充电口是上面提到的目标接口
家庭电源接口是上面提到的源接口
电源适配器是上面提到的适配器
笔记本电脑的充电口是不能和家庭电源接口直接连接进行充电的，因为笔记本电脑用的是直流电，而家庭电源输出的是交流电，所以要把交流电转换为直流电才能给笔记本电脑供电，而电源适配器就能做到这一点
对应了上面提到的适配器模式解决的问题：
可以将不兼容接口的类一起工作
准备工作 创建两个文件，一个头文件mypriority_queue.hpp，一个源文件test.cpp
【因为模板的声明和定义不能分处于不同的文件中，所以把成员函数的声明和定义放在了同一个文件mypriority_queue.hpp中】
mypriority_queue.hpp：存放包含的头文件，命名空间的定义，成员函数和命名空间中的函数的定义
test.cpp：存放main函数，以及测试代码
包含头文件 iostream：用于输入输出vector：提供vector类型的适配对象deque: 提供deque类型的适配对象assert.h:提供assert报错函数 定义命名空间 在文件mypriority_queue.hpp中定义上一个命名空间mypriority_queue
把priority_queue类和它的成员函数放进命名空间封装起来，防止与包含的头文件中的函数/变量重名的冲突问题
类的成员变量 有两个一个是适配器对象，一个是提供比较的仿函数，默认con是vector类型，comp是std库里面的less
什么是仿函数？ C&#43;&#43;中的仿函数是指那些能够像函数一样调用的对象，它们的类至少需要有成员函数operator()()。
仿函数可以是任何类型的对象，只要它的类重载了运算符()，它就能够被调用，就可以作为函数使用。
在C&#43;&#43;中，标准模板库（STL）中的一些容器算法使用仿函数来封装各种操作，使得这些操作可以应用于容器中的元素。
仿函数可以是用户自定义的，也可以是C&#43;&#43;标准库中定义的。例如，STL中的std::less和std::greater就是两个标准的比较仿函数，它们用于排序算法中。用户也可以定义自己的仿函数
总结：
C&#43;&#43;的仿函数是重载了operator()的类实例化的对象，它可以被像函数那样调用
举个例子：
下图是一个可以简单进行大于比较的仿函数和它的类
比较仿函数在priority_queue中的作用 通过传入不同的仿函数可以做到大堆和小堆之间的切换 【stl库里面是传入less类型的仿函数为大堆，传入greater为小堆。 即大于是小堆，小于是大堆】
为什么呢？
因为priority_queue需要用到比较的地方是向上（下）调整算法
如下图：
【向上（调整）这篇文章不做详细讲解，不了解的可以看我这篇文章：模拟实现堆的接口函数】
根据传给priorit_queue的第三个模板参数的不同，就可以得到不同类型的comp
这样调用comp实现的功能就不一样
std::less类型的comp的功能是判断左参数是否小于右参数
std::greater类型的comp的功能是判断左参数是否大于右参数
通过这一点就可以调整大小堆了
因为
如果comp是小于，那么comp(con[parent],con[child])就是父亲节点&lt;孩子节点就交换，那么就会把大的节点一直往堆顶送，就可以实现大堆
comp是小于的时候同理
通过传入不同的仿函数可以做到改变priority_queue里面的比较逻辑 我们使用priority_queue的时候，一般不需要我们传入我们自己写的仿函数，使用库里面的std::less和std::greater就可以满足我们的大部分需求
但是总规有一些情况，库里面的比较仿函数的比较逻辑不符合我们的要求
此时就需要我们自己写一个比较仿函数，传给priority_queue
例
如果我们定义了一个坐标类pos">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T21:40:59+08:00">
    <meta property="article:modified_time" content="2024-08-08T21:40:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">priority_queue模拟实现【C&#43;&#43;】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">全部的实现代码放在了文章末尾</a></li><li><a href="#_17" rel="nofollow">什么是适配器模式？</a></li><li><a href="#_51" rel="nofollow">准备工作</a></li><li><ul><li><a href="#_63" rel="nofollow">包含头文件</a></li><li><a href="#_73" rel="nofollow">定义命名空间</a></li><li><a href="#_81" rel="nofollow">类的成员变量</a></li><li><a href="#_88" rel="nofollow">什么是仿函数？</a></li><li><a href="#priority_queue_110" rel="nofollow">比较仿函数在priority_queue中的作用</a></li><li><ul><li><a href="#_112" rel="nofollow">通过传入不同的仿函数可以做到大堆和小堆之间的切换</a></li><li><a href="#priority_queue_134" rel="nofollow">通过传入不同的仿函数可以做到改变priority_queue里面的比较逻辑</a></li></ul> 
   </li><li><a href="#_168" rel="nofollow">构造函数</a></li><li><ul><li><a href="#_169" rel="nofollow">默认构造</a></li><li><a href="#_179" rel="nofollow">迭代器区间构造</a></li></ul> 
   </li><li><a href="#size_188" rel="nofollow">size</a></li><li><a href="#empty_206" rel="nofollow">empty</a></li><li><a href="#top_223" rel="nofollow">top</a></li><li><a href="#push_242" rel="nofollow">push</a></li><li><a href="#pop_259" rel="nofollow">pop</a></li></ul> 
  </li><li><a href="#_283" rel="nofollow">全部代码</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>全部的实现代码放在了文章末尾</h2> 
<p>【不了解堆（priority_queue）的可以看我这篇文章：<a href="http://t.csdnimg.cn/Iv7tw" rel="nofollow">模拟实现堆的接口函数</a>】</p> 
<p><mark>priority_queue的模拟实现和stack，queue一样，采用了C++适配器模式</mark></p> 
<p><code>priority_queue</code>的适配器一般是<code>vector</code>，也可以是<code>deque</code></p> 
<p>因为<code>priority_queue</code>是有特殊限制的线性表【<mark>只能取堆顶数据，并且需要高效的尾插尾删，还要支持高效的下标访问</mark>（<code>因为priority_queue的push和pop一般是调用适配器的尾插，尾删。 实现向下（上）调整算法的时候需要高效的下标访问方法</code>）】<br> 所以只要是线性结构并且可以<mark>高效的实现尾插和尾删，支持高效的下标访问</mark>的线性表，就可以作为priority_queue的适配器</p> 
<hr> 
<h2><a id="_17"></a>什么是适配器模式？</h2> 
<blockquote> 
 <p>适配器模式是一种设计模式，它<mark>允许将不兼容接口的类一起工作</mark>。</p> 
 <p>适配器模式通常用于以下情况：</p> 
 <ol><li>希望使用一个类，但其接口与其他代码不兼容。</li><li>希望创建一个可重用的类，它能够将接口转换为其他接口。</li><li>希望使用第三方库或遗留代码，但其接口与其他代码不兼容。</li></ol> 
 <p>适配器模式通常包括以下三个主要部分：</p> 
 <ol><li><mark>目标接口（Target）</mark>：这是期望使用的接口，客户端代码只能与目标接口交互。</li><li><mark>源接口（Adaptee）</mark>：这是需要适配的类，其接口与目标接口不兼容。</li><li><mark>适配器（Adapter）</mark>：这是一个类，它实现了目标接口，并将调用转换为对源接口的调用。适配器将源接口的调用转换为目标接口的调用，使得客户端代码可以与目标接口交互。</li></ol> 
</blockquote> 
<p>可以类比我们生活中的<code>家庭电源接口</code>和<code>笔记本电脑充电口</code>与<code>电源适配器</code>，它们之间也是一种适配器关系</p> 
<p><code>笔记本电脑充电口</code>是上面提到的<mark>目标接口</mark><br> <code>家庭电源接口</code>是上面提到的<mark>源接口</mark><br> <code>电源适配器</code>是上面提到的<mark>适配器</mark></p> 
<p><code>笔记本电脑的充电口</code>是不能和<code>家庭电源接口</code>直接连接进行充电的，因为笔记本电脑用的是直流电，而家庭电源输出的是交流电，所以要把交流电转换为直流电才能给笔记本电脑供电，而<code>电源适配器</code>就能做到这一点</p> 
<p>对应了上面提到的适配器模式解决的问题：<br> <mark>可以将不兼容接口的类一起工作</mark></p> 
<hr> 
<h2><a id="_51"></a>准备工作</h2> 
<p>创建两个文件，一个头文件<code>mypriority_queue.hpp</code>，一个源文件<code>test.cpp</code></p> 
<p>【因为模板的<mark>声明和定义<code>不能</code>分处于不同的文件中</mark>，所以把成员函数的声明和定义放在了同一个文件<code>mypriority_queue.hpp</code>中】</p> 
<ol><li> <p>mypriority_queue.hpp：存放包含的头文件，命名空间的定义，成员函数和命名空间中的函数的定义</p> </li><li> <p>test.cpp：存放main函数，以及测试代码</p> </li></ol> 
<hr> 
<h3><a id="_63"></a>包含头文件</h3> 
<ol><li>iostream：用于输入输出</li><li>vector：提供vector类型的适配对象</li><li>deque: 提供deque类型的适配对象</li><li>assert.h:提供assert报错函数</li></ol> 
<hr> 
<h3><a id="_73"></a>定义命名空间</h3> 
<p>在文件<code>mypriority_queue.hpp</code>中定义上一个命名空间<code>mypriority_queue</code><br> 把priority_queue类和它的成员函数<mark>放进命名空间封装起来</mark>，防止与包含的头文件中的函数/变量重名的冲突问题</p> 
<hr> 
<h3><a id="_81"></a>类的成员变量</h3> 
<p>有两个<mark>一个是适配器对象，一个是提供比较的仿函数</mark>，默认con是<code>vector</code>类型，comp是std库里面的<code>less</code><br> <img src="https://images2.imgbox.com/a4/24/0rHsjTLr_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_88"></a>什么是仿函数？</h3> 
<blockquote> 
 <p>C++中的仿函数是指那些<mark>能够像函数一样调用的对象</mark>，它们的类至少需要有成员函数<code>operator()()</code>。<br> 仿函数可以是任何类型的对象，只要它的类<code>重载了运算符()</code>，它就能够被调用，就可以作为函数使用。<br> 在C++中，标准模板库（STL）中的一些容器算法使用仿函数来封装各种操作，使得这些操作可以应用于容器中的元素。</p> 
</blockquote> 
<blockquote> 
 <p>仿函数可以是用户自定义的，也可以是C++标准库中定义的。例如，STL中的<code>std::less</code>和<code>std::greater</code>就是两个标准的比较仿函数，它们用于排序算法中。用户也可以定义自己的仿函数</p> 
</blockquote> 
<p><code>总结</code>：<br> <mark>C++的仿函数是<code>重载了operator()</code>的类实例化的对象，它可以被像函数那样调用</mark></p> 
<p>举个例子：<br> 下图是一个可以简单进行大于比较的仿函数和它的类<br> <img src="https://images2.imgbox.com/ff/a3/P4WfRHeL_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="priority_queue_110"></a>比较仿函数在priority_queue中的作用</h3> 
<h4><a id="_112"></a>通过传入不同的仿函数可以做到大堆和小堆之间的切换</h4> 
<p>【stl库里面是传入<code>less</code>类型的仿函数为大堆，传入<code>greater</code>为小堆。 即<code>大于是小堆，小于是大堆</code>】<br> 为什么呢？<br> 因为priority_queue需要用到比较的地方是<mark>向上（下）调整算法</mark><br> 如下图：<br> 【向上（调整）这篇文章不做详细讲解，不了解的可以看我这篇文章：<a href="http://t.csdnimg.cn/Iv7tw" rel="nofollow">模拟实现堆的接口函数</a>】<br> <img src="https://images2.imgbox.com/21/57/6ocUOWVU_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ff/97/oEPkUAu4_o.png" alt="在这里插入图片描述"><br> 根据传给priorit_queue的第三个模板参数的不同，就可以得到不同类型的comp<br> 这样调用comp实现的功能就不一样<br> <code>std::less</code>类型的comp的功能是<mark>判断左参数是否<code>小于</code>右参数</mark><br> <code>std::greater</code>类型的comp的功能是<mark>判断左参数是否<code>大于</code>右参数</mark><br> 通过这一点就可以调整大小堆了<br> 因为<br> 如果comp是小于，那么<code>comp(con[parent],con[child])</code>就是<code>父亲节点&lt;孩子节点</code>就交换，那么就会把大的节点一直往堆顶送，就可以实现大堆<br> comp是小于的时候同理</p> 
<hr> 
<h4><a id="priority_queue_134"></a>通过传入不同的仿函数可以做到改变priority_queue里面的比较逻辑</h4> 
<p>我们使用priority_queue的时候，一般不需要我们传入<code>我们自己写的仿函数</code>，使用库里面的<code>std::less</code>和<code>std::greater</code>就可以满足我们的大部分需求</p> 
<p><mark>但是总规有一些情况，库里面的比较仿函数的比较逻辑不符合我们的要求</mark><br> 此时就需要我们自己写一个比较仿函数，传给priority_queue</p> 
<p>例<br> 如果我们定义了一个坐标类pos<br> <img src="https://images2.imgbox.com/98/bd/0VBK6Dwj_o.png" alt="在这里插入图片描述"></p> 
<p>假设我们比较两个pos对象的大小的时候分两种情况</p> 
<ol><li><code>优先比x</code>，谁的x大谁就大，x相等时y大就大</li><li><code>优先比y</code>，谁的y大谁就大，y相等时x大就大</li></ol> 
<p>如果我们用这两种比较方式建出来的堆（priority_queue）肯定是不同的</p> 
<p>这个时候库里面的仿函数就满足不了我们的要求了</p> 
<p>我们要自己写仿函数：<br> <img src="https://images2.imgbox.com/8f/ac/6j33q5bU_o.png" alt="在这里插入图片描述"></p> 
<p>此时传入不同的仿函数，得到的堆就不同<br> 例<br> <img src="https://images2.imgbox.com/f7/a0/6iCRstf1_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/f2/77/tRktMAqp_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="_168"></a>构造函数</h3> 
<h4><a id="_169"></a>默认构造</h4> 
<p>由于默认构造可以直接传入适配器对象，<mark>因为传入的适配器对象里面可能已经有数据了，所以要把这些数据给建成堆</mark>，就算传入的适配器对象是空的也能处理<br> <img src="https://images2.imgbox.com/bf/b8/xMaH2Uhq_o.png" alt="在这里插入图片描述"></p> 
<p>例<br> <img src="https://images2.imgbox.com/03/69/NoiQdMYX_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="_179"></a>迭代器区间构造</h4> 
<p><img src="https://images2.imgbox.com/8b/9a/0kv2nuuC_o.png" alt="在这里插入图片描述"></p> 
<p>例<br> <img src="https://images2.imgbox.com/68/0b/MWliwFeK_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h3><a id="size_188"></a>size</h3> 
<pre><code class="prism language-cpp">因为把priority_queue的数据都存储在了适配器对象里面

所以适配器对象的size，就是priority_queue的size

加<span class="token keyword">const</span>是为了让<span class="token keyword">const</span>修饰的对象也能调用

size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> _con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="empty_206"></a>empty</h3> 
<pre><code class="prism language-cpp">因为把priority_queue的数据都存储在了适配器对象里面

所以判断适配器对象是否为空即可
加<span class="token keyword">const</span>是为了让<span class="token keyword">const</span>修饰的对象也能调用

<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="top_223"></a>top</h3> 
<pre><code class="prism language-cpp">堆顶的数据只支持读取，  不支持  修改
因为改了就有可能不是 堆 了
所以返回值是<span class="token keyword">const</span> T<span class="token operator">&amp;</span>

<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{<!-- --></span>
    因为把priority_queue的数据都存储在了适配器对象里面
	而且堆顶的数据存储在适配器对象的第一个数据位置
	所以直接调用front即可
	<span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="push_242"></a>push</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	因为要把priority_queue的数据都存储在适配器对象里面
	所以新数据，直接尾插到适配器对象里面存储
	con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

	再堆新插入的数据调用向上调整算法
	保持插入之后也还是  堆  结构
	<span class="token function">AdiuUp</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="pop_259"></a>pop</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	堆不为空才能删除
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	把堆顶与适配器最后一个数据交换
	方便尾删
	std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>con<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> con<span class="token punctuation">[</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	尾删，把原来的堆顶数据删除
	con<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	对换到堆顶的数据进行向下调整算法
	保持删除之后也还是  堆  结构
	<span class="token function">AdiuDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h2><a id="_283"></a>全部代码</h2> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;deque&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;assert.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> mypriority_queue
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token operator">=</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">priority_queue</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token comment">//拥有比较大小能力的仿函数</span>
		Compare comp<span class="token punctuation">;</span>

		<span class="token comment">//适配器对象</span>
		Container con<span class="token punctuation">;</span>
	    
		<span class="token comment">//向上调整算法</span>
		<span class="token keyword">void</span> <span class="token function">AdiuUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> child<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//找到  逻辑结构  中的父亲节点</span>
			<span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>child <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

			<span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//使用  比较仿函数comp  进行比较大小</span>
				<span class="token comment">//默认的comp是 std::less 类型的</span>
				<span class="token comment">//即  左参数&lt;右参数  就返回true，否则返回false</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">comp</span><span class="token punctuation">(</span>con<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">,</span>con<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>con<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">,</span> con<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					child <span class="token operator">=</span> parent<span class="token punctuation">;</span>
					parent <span class="token operator">=</span> <span class="token punctuation">(</span>child <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//向下调整算法</span>
		<span class="token keyword">void</span> <span class="token function">AdiuDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> parent<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//找到  逻辑结构  中的左孩子节点</span>
			<span class="token keyword">int</span> child <span class="token operator">=</span> parent<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;</span>n<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token function">comp</span><span class="token punctuation">(</span>con<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> con<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					child<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token comment">//使用  比较仿函数comp  进行比较大小</span>
				<span class="token comment">//默认的comp是 std::less 类型的</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">comp</span><span class="token punctuation">(</span>con<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">,</span> con<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>con<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">,</span> con<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
					child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">else</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">public</span><span class="token operator">:</span>

		<span class="token function">priority_queue</span><span class="token punctuation">(</span><span class="token keyword">const</span> Container <span class="token operator">&amp;</span> ctnr <span class="token operator">=</span> <span class="token function">Container</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">const</span> Compare <span class="token operator">&amp;</span> comp <span class="token operator">=</span> <span class="token function">Compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token operator">-&gt;</span>comp <span class="token operator">=</span> comp<span class="token punctuation">;</span>

			<span class="token keyword">this</span><span class="token operator">-&gt;</span>con <span class="token operator">=</span> ctnr<span class="token punctuation">;</span>

			<span class="token keyword">int</span> n <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">//建堆，从最后一个叶子节点的父亲节点开始</span>
			<span class="token comment">//n-1为逻辑结构上的  最后一个叶子节点的下标 </span>
			<span class="token comment">//它的父亲节点的下标等于  它的下标-1，再除以2</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//向下调整算法</span>
				<span class="token function">AdiuDown</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIterator</span><span class="token operator">&gt;</span>
		<span class="token function">priority_queue</span><span class="token punctuation">(</span>InputIterator first<span class="token punctuation">,</span> InputIterator last<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//遍历迭代器区间</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> last<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token comment">//复用push进行插入</span>
				<span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">++</span>first<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">//堆顶的数据只支持读取，  不支持  修改</span>
		<span class="token comment">//因为改了就有可能不是 堆 了</span>
		<span class="token comment">//所以返回值是const T&amp;</span>
		<span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//堆顶的数据存储在适配器对象的第一个数据位置</span>
			<span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//因为要把priority_queue的数据都存储在适配器对象里面</span>
			<span class="token comment">//所以新数据，直接尾插到适配器对象里面存储</span>
			con<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//再堆新插入的数据调用向上调整算法</span>
			<span class="token comment">//保持插入之后也还是  堆  结构</span>
			<span class="token function">AdiuUp</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>


		<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token comment">//堆不为空才能删除</span>
			<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//把堆顶与适配器最后一个数据交换</span>
			<span class="token comment">//方便尾删</span>
			std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>con<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> con<span class="token punctuation">[</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//尾删，把原来的堆顶数据删除</span>
			con<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

			<span class="token comment">//对换到堆顶的数据进行向下调整算法</span>
			<span class="token comment">//保持删除之后也还是  堆  结构</span>
			<span class="token function">AdiuDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94ac08f2387210029c4453a9e1278df4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MessageBox弹框替代系统自带的alert、confirm -- 高仿ElementUI MessageBox</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2fa66df51357387a7b5f64891d0a4ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">queue的模拟实现【C&#43;&#43;】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>