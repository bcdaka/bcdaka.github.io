<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[SA8155] 探索QNX Hypervisor如何管理Android系统的AB分区（一） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9e1ee90b7e85b65c615f06bb45f750aa/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[SA8155] 探索QNX Hypervisor如何管理Android系统的AB分区（一）">
  <meta property="og:description" content="本文建议在对高通8155车机系统有一定的了解下进行阅读
文章目录
前言
一、VMM中的关键LOG
二、VMM中的关键CODES
1.VMM状态机管理
2.QNX的slot状态
3.Android的slot状态
总结
参考
前言 高通SA8155的基建默认采用的是A/B系统升级作为OTA升级方案。
而在虚拟化系统中，如何保证Host QNX和Guest Android两个不同系统的AB分区一致是个值得探究的问题。
本文探索了，Host QNX中的资源管理模块VMM(Virtual Machine Manager)在启动Android虚拟机的时候是如何获取Android系统的AB分区信息。
一、VMM中的关键LOG 关于高通的虚拟机资源管理器VMM见文末参考，这里以该模块打印的log作为引子。
在启动Android虚拟机的log中，一行来自vmm_service的关键log提示了Host QNX和Guest Android的slot状态(A/B升级系统中用slots表示ab分区集合状态，参考Android OTA A/B system update)：
Jan 01 00:00:07.830 vmm.868420 default 16130 vmm_service[vmm_fsm.c:762]:
guest target slot : a host current slot: b Config slot:@/mnt/vm/images/la_dp_enabled_a.config
根据这行log中，我们可以获取以下信息：
打印来自VMM模块的vmm_fsm.c文件guest指的是Android系统，目标slot为ahost指的是QNX系统，当前slot为bguest slot配置文件名为/mnt/vm/images/la_dp_enabled_a.config 从中可以推测出以下信息：
QNX和Android可以处于不同的AB分区状态下运行根据配置文件名，可以推断此配置的两个使用条件： 动态分区被使能slot为a的分区配置被采用 二、VMM中的关键CODES 通过以上分析可以发现，在Android虚拟机启动的过程中，VMM模块参与了安卓AB分区的管理。
让我们进一步进行探索：
1.VMM状态机管理 由获取的信息定位到这行关键的log在vmm_fsm.c文件的位置：
static int launch_gvm(struct gvm_context *ctx) { ... if (ctx-&gt;vm_avb_version == 2) { pthread_barrier_wait(&amp;ctx-&gt;config_barrier); if (!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-03T00:25:08+08:00">
    <meta property="article:modified_time" content="2024-08-03T00:25:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[SA8155] 探索QNX Hypervisor如何管理Android系统的AB分区（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>本文建议在对高通8155车机系统有一定的了解下进行阅读</p> 
</blockquote> 
<div> 
 <p id="main-toc"><strong>文章目录</strong></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81VMM%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AELOG-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81VMM%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AELOG" rel="nofollow">一、VMM中的关键LOG</a></p> 
 <p id="%E4%BA%8C%E3%80%81VMM%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AECODES-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81VMM%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AECODES" rel="nofollow">二、VMM中的关键CODES</a></p> 
 <p id="1.VMM%E7%8A%B6%E6%80%81%E6%9C%BA%E7%AE%A1%E7%90%86-toc" style="margin-left:40px;"><a href="#1.VMM%E7%8A%B6%E6%80%81%E6%9C%BA%E7%AE%A1%E7%90%86" rel="nofollow">1.VMM状态机管理</a></p> 
 <p id="2.QNX%E7%9A%84slot%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#2.QNX%E7%9A%84slot%E7%8A%B6%E6%80%81" rel="nofollow">2.QNX的slot状态</a></p> 
 <p id="3.%E5%AE%89%E5%8D%93%E7%9A%84slot%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#3.%E5%AE%89%E5%8D%93%E7%9A%84slot%E7%8A%B6%E6%80%81" rel="nofollow">3.Android的slot状态</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
 <p id="%E5%8F%82%E8%80%83-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83" rel="nofollow">参考</a></p> 
 <p style="margin-left:0px;"></p> 
 <hr> 
 <h2 id="%E5%89%8D%E8%A8%80"><strong>前言</strong></h2> 
</div> 
<p><span style="color:#0d0016;">高通SA8155的基建默认采用的是A/B系统升级作为OTA升级方案。</span></p> 
<p><span style="color:#0d0016;">而在虚拟化系统中，如何保证Host QNX和Guest Android两个不同系统的AB分区一致是个值得探究的问题。</span></p> 
<p><span style="color:#0d0016;">本文探索了，Host QNX中的资源管理模块VMM(Virtual Machine Manager)在启动Android虚拟机的时候是如何获取Android系统的AB分区信息。</span></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81VMM%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AELOG"><strong>一、VMM中的关键LOG</strong></h2> 
<p><span style="color:#0d0016;">关于高通的虚拟机资源管理器VMM见文末参考，这里以该模块打印的log作为引子。</span></p> 
<p><span style="color:#0d0016;">在启动Android虚拟机的log中，一行来自</span><span style="color:#1c7331;"><em><span style="background-color:#f3f3f4;">vmm_service</span></em></span><span style="color:#0d0016;">的关键log提示了Host QNX和Guest Android的slot状态(A/B升级系统中用slots表示ab分区集合状态，参考<a class="link-info" href="https://source.android.google.cn/docs/core/ota/ab#slots" rel="nofollow" title="Android OTA A/B system update">Android OTA A/B system update</a>)：</span></p> 
<blockquote> 
 <p>Jan 01 00:00:07.830        vmm.868420        default  16130  vmm_service[vmm_fsm.c:762]:</p> 
 <p>guest target slot : a host current slot: b Config slot:@/mnt/vm/images/la_dp_enabled_a.config</p> 
</blockquote> 
<p><span style="color:#0d0016;">根据这行log中，我们可以获取以下信息：</span></p> 
<ul><li><span style="color:#494949;">打印来自VMM模块的</span><span style="color:#1c7331;"><em><span style="background-color:#f3f3f4;">vmm_fsm.c</span></em></span><span style="color:#494949;">文件</span></li><li><span style="color:#494949;">guest指的是Android系统，目标slot为a</span></li><li><span style="color:#494949;">host指的是QNX系统，当前slot为b</span></li><li><span style="color:#494949;">guest slot配置文件名为</span><em><span style="color:#1c7331;"><span style="background-color:#f3f3f4;">/mnt/vm/images/la_dp_enabled_a.config</span></span></em></li></ul> 
<p><span style="color:#0d0016;">从中可以推测出以下信息：</span></p> 
<ul><li><span style="color:#494949;">QNX和Android可以处于不同的AB分区状态下运行</span></li><li><span style="color:#494949;">根据配置文件名，可以推断此配置的两个使用条件：</span> 
  <ol><li><span style="color:#494949;">动态分区被使能</span></li><li><span style="color:#494949;">slot为a的分区配置被采用</span></li></ol></li></ul> 
<h2 id="%E4%BA%8C%E3%80%81VMM%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AECODES"><a id="_19"></a>二、<strong>VMM中的关键CODES</strong></h2> 
<p><a id="1_20"></a><span style="color:#0d0016;">通过以上分析可以发现，在</span><span style="color:#494949;">Android</span><span style="color:#0d0016;">虚拟机启动的过程中，VMM模块参与了安卓AB分区的管理。</span></p> 
<p><span style="color:#0d0016;">让我们进一步进行探索：</span></p> 
<h3 id="1.VMM%E7%8A%B6%E6%80%81%E6%9C%BA%E7%AE%A1%E7%90%86">1.VMM状态机管理</h3> 
<p><span style="color:#0d0016;">由获取的信息定位到这行关键的log在</span><span style="color:#1c7331;"><em><span style="background-color:#f3f3f4;">vmm_fsm.c</span></em></span><span style="color:#0d0016;">文件的位置：</span></p> 
<pre><code class="language-cpp">static int launch_gvm(struct gvm_context *ctx)
{
    ...
    if (ctx-&gt;vm_avb_version == 2) {

        pthread_barrier_wait(&amp;ctx-&gt;config_barrier);

        if (!ctx-&gt;bank || ctx-&gt;slot_switch_config == SYMMETRIC_SLOT_SWITCH) {
            ctx-&gt;bank = ctx-&gt;swdl_slot;
        }
        ...
        /* Dynamic Parition is Enabled only for LA GVM */
        if (ctx-&gt;vmid == 2) {
            if (ctx-&gt;qvb.is_dp_enabled == true) {
                _argv[3] = (ctx-&gt;bank == 'a')? ctx-&gt;qvb.dp_enabled_a_conf_fname: ctx-&gt;qvb.dp_enabled_b_conf_fname;
                vmm_info("guest target slot : %c host current slot: %c Config slot :%s ",ctx-&gt;bank, ctx-&gt;swdl_slot, _argv[3]);
                ctx-&gt;swdl_slot = '\0';
            } else {
                _argv[3] = ctx-&gt;qvb.dp_disabled_conf_fname;
            }
        }
    } else if (ctx-&gt;vm_avb_version == 1 &amp;&amp; ctx-&gt;is_recovery) {
        ...
    } else {
        ...
    }
    ...
}</code></pre> 
<p><span style="color:#0d0016;">该log来自</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">launch_gvm</span></span><span style="color:#0d0016;">接口，从相关代码中，可以获取到以下信息：</span></p> 
<ul><li><span style="color:#494949;">启动GVM的时候，VMM会根据Android系统的功能的使能状态，传入启动所需的不同配置</span></li><li><span style="color:#494949;">动态分区功能是针对Android虚拟机特别处理的</span></li><li><span style="color:#494949;">动态分区在非使能的条件下，有对应的配置文件作为入参</span></li><li><span style="color:#494949;">动态分区在使能的条件下，根据</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">context</span></span><span style="color:#494949;">中的</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#494949;">值为a还是b，采用对应的配置文件作为入参</span></li><li><span style="color:#494949;">当</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#494949;">为空的情况，让</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#494949;">与</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">swdl_slot</span></span><span style="color:#494949;">状态一致</span></li></ul> 
<p><span style="color:#0d0016;"><strong>那么:</strong></span></p> 
<ul><li><strong><span style="color:#b95514;"><span style="background-color:#f3f3f4;">context</span></span><span style="color:#494949;">中的成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">swdl_slot</span></span><span style="color:#494949;">应该代表Host QNX的slot状态，</span></strong></li><li><strong><span style="color:#b95514;"><span style="background-color:#f3f3f4;">context</span></span><span style="color:#494949;">中的成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#494949;">应该代表Guest Android的slot状态，</span></strong></li><li><strong><span style="color:#b95514;"><span style="background-color:#f3f3f4;">swdl_slot</span></span><span style="color:#494949;">与</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#494949;">分别从哪儿获取赋值的呢<em>？</em></span></strong></li></ul> 
<p><span style="color:#0d0016;">还是在</span><span style="color:#1c7331;"><em><span style="background-color:#f3f3f4;">vmm_fsm.c</span></em></span><span style="color:#0d0016;">文件中，可以搜索到相关代码。在加载启动镜像的时候，QNX和Android的slot状态被提取出来：</span></p> 
<pre><code class="language-c language-cpp">void* vm_load_img(void *data)
{
    struct gvm_context *ctx = (struct gvm_context *)data;
    ...
    char bank = '\0';
    ...
    while (1){
        ...
        ret = get_gvm_boot_slot_info(ctx);
        if (ret == -1) {
            goto err;
        }
        ctx-&gt;qvb.slot_data = NULL;

        ctx-&gt;swdl_slot = get_swdl_bank_info();
        if (ctx-&gt;swdl_slot) {
            if (!ctx-&gt;bank ||  ctx-&gt;slot_switch_config == SYMMETRIC_SLOT_SWITCH) {
                bank = ctx-&gt;swdl_slot;
            } else{
                bank = ctx-&gt;bank;
            }
            ...
            ret = verify_load_img(&amp;ctx-&gt;qvb, (const char * const*)requested_partition, ctx-&gt;vmid, bank, is_avb_enforced);
        } else {
            vmm_err("Error while reading the swdl_slot");
            ctx-&gt;config = NULL;
        }
        ...
    }
err:
    return NULL;
}
</code></pre> 
<h3 id="2.QNX%E7%9A%84slot%E7%8A%B6%E6%80%81"><a id="2_34"></a>2.QNX的slot状态</h3> 
<p><span style="color:#0d0016;">先看看成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">swdl_slot</span></span><span style="color:#0d0016;">的获取接口（注：代码中</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#0d0016;">和</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">slot</span></span><span style="color:#0d0016;">都指的是ab分区状态，基建中会混用，但是只要区分好属于哪个系统的ab分区状态就行了）：</span></p> 
<pre><code class="language-c language-cpp">...
#include &lt;amss/core/qc_sysinfo.h&gt;
...
static char get_swdl_bank_info(void)
{
    bank_t bank_id;
    char bank = '\0';

    bank_id = _get_active_bank();
    bank = bank_id == BANK_A ? 'a' : 'b';
    vmm_info("VMM System banked to %c", bank);

    return bank;
}</code></pre> 
<p><span style="color:#0d0016;">根据实现，成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">swdl_slot</span></span><span style="color:#0d0016;"><em>确实</em>来自QNX系统中slot状态，并且有以下两个信息：</span></p> 
<ul><li><span style="color:#494949;">返回值存在</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">‘a’</span></span><span style="color:#494949;">和</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">'b'</span></span><span style="color:#494949;">两种状态</span></li><li><span style="color:#494949;">调用了来自头文件</span><span style="color:#1c7331;"><em><span style="background-color:#f3f3f4;">qc_sysinfo.h</span></em></span><span style="color:#494949;">的</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">_get_active_bank()</span></span><span style="color:#494949;">接口（无法搜到具体实现）</span></li></ul> 
<p><span style="color:#0d0016;">成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">swdl_slot</span></span><span style="color:#0d0016;">确认完毕。</span></p> 
<h3 id="3.%E5%AE%89%E5%8D%93%E7%9A%84slot%E7%8A%B6%E6%80%81">3.Android的slot状态</h3> 
<p><span style="color:#0d0016;">再看看成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#0d0016;">的获取接口：</span></p> 
<pre><code class="language-c language-cpp">...
#include "amss/lcm_utils.h"
...
int get_gvm_boot_slot_info(struct gvm_context* ctx)
{
    int ret = 0;
    struct boot_slot_info slot_info;
    ...
    if (ctx-&gt;misc_partition_name == NULL) {
        vmm_info("misc partition is empty for vmid : %d",ctx-&gt;vmid);
        ...
        goto err;
    }
    ret = check_for_recovery_boot_slot_info(ctx-&gt;misc_partition_name, ctx-&gt;vmid, &amp;slot_info);
    if (ret == -1) {
        vmm_err("Failure in boot slot check");
        ret = -1;
        goto err;
    }
    ...
    if (slot_info.target_slot == 'a' || slot_info.target_slot == 'b')
        ctx-&gt;bank = slot_info.target_slot;
    else
        ctx-&gt;bank = '\0';
    ...
err:
    return ret;
}
</code></pre> 
<p><span style="color:#0d0016;">根据实现，成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#0d0016;">来自<strong>misc分区</strong>，同样的有以下两个信息：</span></p> 
<ul><li><span style="color:#494949;">返回值存在</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">‘a’</span></span><span style="color:#494949;">，</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">'b'</span></span><span style="color:#494949;">，</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">'\0'</span></span><span style="color:#494949;">三种状态（</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">'\0'</span></span><span style="color:#494949;">为空）</span></li><li><span style="color:#494949;">调用了来自头文件</span><span style="color:#1c7331;"><em><span style="background-color:#f3f3f4;">lcm_utils.h</span></em></span><span style="color:#494949;">的</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">check_for_recovery_boot_slot_info()</span></span><span style="color:#494949;">接口（来自LCM模块）</span></li></ul> 
<p><span style="color:#0d0016;"><strong>但是，QNX和Android系统都存在misc分区，那么这里的misc分区是不是安卓的呢？</strong></span></p> 
<p><span style="color:#0d0016;">从VMM模块中的驱动文件</span><span style="color:#1c7331;"><em><span style="background-color:#f3f3f4;">vmm_drv.c</span></em></span><span style="color:#0d0016;">，可以找到相关逻辑：</span></p> 
<pre><code class="language-cpp">static int parse_gvm_list_and_populate_ctx(struct vmm_dev_t *vmm_dev)
{
    struct gvm_context *ctx;
    ...
    vmm_dev-&gt;num_gvms = fdt_get_num_vm();

    list_initialize(&amp;vmm_dev-&gt;gvm_ctx_head);

    while (count &lt; vmm_dev-&gt;num_gvms) {
        ctx = calloc(1, sizeof(*ctx));
        ...
        if (ctx-&gt;vm_avb_version == 2) {
            ...
            vm_partition_prefix = fdt_get_vm_partition_prefix(vmid);
            if (vm_partition_prefix == NULL){
                vmm_err("Failed to get vm_partition_prefix for vmid: %d", vmid);
                goto gvm_vm_partition_prefixget_error;
            }

            if (strstr(vm_partition_prefix, "la1")) {
                ctx-&gt;get_config = &amp;get_config_la1;
                ctx-&gt;qvb.is_dp_enabled = check_for_partition("/dev/disk/la1_super");
                ctx-&gt;misc_partition_name = check_for_partition("/dev/disk/la1_misc")? "la1_misc": NULL;
            } else if (strstr(vm_partition_prefix, "la")) {
                ctx-&gt;get_config = &amp;get_config_la;
                ctx-&gt;qvb.is_dp_enabled = check_for_partition("/dev/disk/la_super");
                ctx-&gt;misc_partition_name = check_for_partition("/dev/disk/la_misc")? "la_misc": NULL;
            } else if (strstr(vm_partition_prefix, "agl")) {
                ctx-&gt;get_config = &amp;get_config_lv;
                ctx-&gt;qvb.is_dp_enabled = check_for_partition("/dev/disk/agl_super");
                ctx-&gt;misc_partition_name = check_for_partition("/dev/disk/agl_misc")? "agl_misc": NULL;
            } else if (strstr(vm_partition_prefix, "lv")) {
                ctx-&gt;get_config = &amp;get_config_lv;
                ctx-&gt;qvb.is_dp_enabled = check_for_partition("/dev/disk/lv_super");
                ctx-&gt;misc_partition_name = check_for_partition("/dev/disk/lv_misc")? "lv_misc": NULL;
            } else if (strstr(vm_partition_prefix, "qnx")) {
                ctx-&gt;get_config = &amp;get_config_qnx1;
                ctx-&gt;qvb.is_dp_enabled = false;
                ctx-&gt;misc_partition_name = NULL;
            } else {
                vmm_err("Failed to set the function pointer");
                goto func_pointer_alloc_failed;
            }
            ...
        } else {
            ...
        }

        if (ctx-&gt;qvb.is_dp_enabled == true) {
            ...
            dp_enabled_a_conf_fname = fdt_get_dp_enabaled_a_config(vmid);
            ...
            dp_enabled_b_conf_fname = fdt_get_dp_enabaled_b_config(vmid);
            ...
        } else {
            ...
            dp_disabled_conf_fname = fdt_get_dp_disabled_config(vmid);
            ...
        }
        ...
        count++;
    }
    ...
    return -1;
}</code></pre> 
<p><span style="color:#0d0016;">接口</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">parse_gvm_list_and_populate_ctx</span></span><span style="color:#0d0016;">的主要功能是解析虚拟机的设备树配置文件。</span></p> 
<p><span style="color:#0d0016;">在接口的实现中，一眼就可以找到为成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">misc_partition_name</span></span><span style="color:#0d0016;">赋值的代码段。</span></p> 
<p><span style="color:#0d0016;">这段“朴实无华”的代码考虑了不同虚拟机系统的情况，其中，“la”指的是Linux Android，因此</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">misc_partition_name</span></span><span style="color:#0d0016;">获取的是Android的misc分区名。</span></p> 
<p><span style="color:#0d0016;">另外，分区配置文件名的获取逻辑也在此接口的实现中。</span></p> 
<p><span style="color:#0d0016;">至此，成员变量</span><span style="color:#b95514;"><span style="background-color:#f3f3f4;">bank</span></span><span style="color:#0d0016;">确认完毕。</span></p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p><span style="color:#333333;">在启动Android虚拟机的时候，QNX中的VMM模块会获取两个系统的slot状态，然后根据Android的ab分区状态，传入启动所需的配置文件。</span></p> 
<p><strong><span style="color:#333333;">Host QNX的slot状态是通过高通系统接口获取的；而Guest Android的slot状态是通过解析Android的misc分区获取的。</span></strong></p> 
<p><span style="color:#333333;">回到关于如何保证两个不同系统ab分区一致的问题，我们可以基于本文分析出的相关信息，做进一步的探索。</span></p> 
<hr> 
<h2 id="%E5%8F%82%E8%80%83">参考</h2> 
<p>VMM：<a class="link-info" href="https://blog.csdn.net/u012139744/article/details/140595781" title="[SA8155] 虚拟机管理器VMM介绍(部分内容)">[SA8155] 虚拟机管理器VMM介绍(部分内容)</a></p> 
<p><img alt="" height="101" src="https://images2.imgbox.com/7d/b3/Tlx3pnUi_o.png" width="162"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce6470157c4e5073347531df7f596ba9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端素材】推荐优质多用途水果外卖电商手机系统GoFruit平台模板（附源码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0d67995c8e19a15dc14bd11b5b268e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Meta最新SAM2模型开源直接封神</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>