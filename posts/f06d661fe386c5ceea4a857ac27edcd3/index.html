<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hive SQL中的列转行（lateral view与explode）、行转列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f06d661fe386c5ceea4a857ac27edcd3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Hive SQL中的列转行（lateral view与explode）、行转列">
  <meta property="og:description" content="一、列转行 1、相关函数 列转行：将某列一行中的数据拆分成多行
1）Explode炸裂函数 将hive某列一行中复杂的 array 或 map 结构拆分成多行（只能输入array或map）
语法： select explode(字段) as 字段命名 from 表名; 举例： explode(array)使得结果中将array列表里的每个元素生成一行
select(array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)) explode(map)使得结果中将map里的每一对元素作为一行，key为一列，value为一列
select explode(map(&#39;A&#39;,&#39;1&#39;,&#39;B&#39;,&#39;2&#39;,&#39;C&#39;,&#39;3&#39;)) 局限性： 1、不能关联原有的表中的其他字段
2、不能与group by、cluster by、distribute by、sort by联用
3、不能进行UDTF嵌套
2）posexplode()函数 explode()：对一列进行炸裂可以使用
posexplode()：对两列都进行多行转换，可以将index和数据都取出来，使用两次posexplode并令两次取到的index相等即可
举例： select posexplode(collect_set(&#39;AA&#39;)) posval0AA collect_set：将某字段进行去重处理，返回array类型
3）Lateral View Lateral View配合 split, explode 等UDTF函数一起使用，它能够将一列数据拆成多行数据，并且对拆分后结果进行聚合，即将多行结果组合成一个支持别名的虚拟表。相当于拆出一张虚拟表，与原表进行关联。
语法： select o.*, table_view.new_col from table_origin o lateral view UDTF(expression) table_view as new_col_1, new_col_2 lateral view：表示将UDTF分裂的字段放在虚拟表中, 然后和主表table_origin进行关联。
UDTF(expression)：使用的UDTF函数，例如explode()
table_view : 对应的虚拟表的表名
new_col: 虚拟表里存放的有效字段（可多个）
注意：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-30T14:46:05+08:00">
    <meta property="article:modified_time" content="2024-01-30T14:46:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hive SQL中的列转行（lateral view与explode）、行转列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%80%E3%80%81%E5%88%97%E8%BD%AC%E8%A1%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0" style="background-color:transparent;">一、列转行</h2> 
<h3>1、相关函数</h3> 
<p>列转行：将某列一行中的数据拆分成多行</p> 
<h4 id="Explode%E7%82%B8%E8%A3%82%E5%87%BD%E6%95%B0">1）Explode炸裂函数</h4> 
<p>将hive某列一行中复杂的 array 或 map 结构拆分成多行（只能输入array或map）</p> 
<h5 id="%E8%AF%AD%E6%B3%95%EF%BC%9A">语法：</h5> 
<pre><code class="language-sql">select explode(字段) as 字段命名 from 表名;</code></pre> 
<h5 id="%E4%B8%BE%E4%BE%8B%EF%BC%9A">举例：</h5> 
<p>explode(array)使得结果中将array列表里的每个元素生成一行</p> 
<pre><code class="language-sql">select(array('1','2','3')) </code></pre> 
<p>explode(map)使得结果中将map里的每一对元素作为一行，key为一列，value为一列</p> 
<pre><code class="language-sql">select explode(map('A','1','B','2','C','3'))</code></pre> 
<p><img alt="" height="267" src="https://images2.imgbox.com/c3/ee/ny4DF2zU_o.png" width="775"></p> 
<h5 id="%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%9A">局限性：</h5> 
<p>1、不能关联原有的表中的其他字段</p> 
<p>2、不能与group by、cluster by、distribute by、sort by联用</p> 
<p>3、不能进行UDTF嵌套</p> 
<h4 id="posexplode()%E5%87%BD%E6%95%B0">2）posexplode()函数</h4> 
<p>explode()：对一列进行炸裂可以使用</p> 
<p>posexplode()：对两列都进行多行转换，可以将index和数据都取出来，使用两次posexplode并令两次取到的index相等即可</p> 
<h5>举例：</h5> 
<pre><code class="language-sql">select posexplode(collect_set('AA'))</code></pre> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>pos</strong></td><td><strong>val</strong></td></tr><tr><td>0</td><td>AA</td></tr></tbody></table> 
<p>collect_set：将某字段进行去重处理，返回array类型</p> 
<h4>3）Lateral View</h4> 
<p>Lateral View配合 split, explode 等UDTF函数一起使用，它能够将一列数据拆成多行数据，并且对拆分后结果进行聚合，即将多行结果组合成一个支持别名的虚拟表。相当于拆出一张虚拟表，与原表进行关联。</p> 
<h5>语法：</h5> 
<pre><code class="language-sql">select o.*, table_view.new_col
from table_origin o
lateral view UDTF(expression) table_view as new_col_1, new_col_2</code></pre> 
<p>lateral view：表示将UDTF分裂的字段放在虚拟表中, 然后和主表table_origin进行关联。<br> UDTF(expression)：使用的UDTF函数，例如explode()<br> table_view : 对应的虚拟表的表名<br> new_col: 虚拟表里存放的有效字段（可多个）<br><strong>注意：</strong></p> 
<ul><li>lateral view的位置是from后where条件前</li><li>生成的虚拟表的表名不可省略</li><li>from后可带多个lateral view</li><li>如果要拆分的字段有null值，需要使用lateral view outer 替代，避免数据缺失</li></ul> 
<h3>2、案例</h3> 
<h4 style="background-color:transparent;">例子1-<span style="color:#0d0016;">explode+<span style="background-color:#ffffff;">split</span></span></h4> 
<p>假设有如下movies表，字段名分别为<code>movie(string)</code>和<code>category(array&lt;string&gt;)</code></p> 
<p><img alt="" height="181" src="https://images2.imgbox.com/be/c9/rQv7koKu_o.png" width="411"></p> 
<p>转换为</p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/49/88/ncqpAiX3_o.png" width="320"></p> 
<pre><code class="language-sql">select movie,category_name
from  movies 
lateral view explode(category) table_tmp as category_name;

-- 结果:
--《疑犯追踪》	悬疑
--《疑犯追踪》	动作
--《疑犯追踪》	科幻
--《疑犯追踪》	剧情
--《海豹突击队》	动作
-- ...</code></pre> 
<p></p> 
<p><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><span style="color:#FF0000;">注：explode函数输入了一个string类型的参数，搭配split()函数</span></span></span></p> 
<h4 style="background-color:transparent;"> 例子2-<span style="color:#0d0016;">explode+<span style="background-color:#ffffff;">split</span></span></h4> 
<p><img alt="" height="96" src="https://images2.imgbox.com/ba/04/xwK4acaL_o.png" width="465"></p> 
<p> 转换为</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/59/6d/8YIQUjwf_o.png" width="357"></p> 
<pre><code class="language-sql">select col1, col2, col5
from test
lateral view explode(split(col3,','))  b AS col5
-- split(col3,",")相对字符串切割，得到数组</code></pre> 
<p><span style="color:#fe2c24;">注：explode函数输入了一个string类型的参数，搭配split()函数</span></p> 
<h4 style="background-color:transparent;">例子3-<span style="color:#0d0016;">explode+<span style="background-color:#ffffff;">split</span></span></h4> 
<p><img alt="" height="255" src="https://images2.imgbox.com/2b/17/LmK8xPSb_o.png" width="1038"></p> 
<pre><code class="language-sql">select uid_split, game 
from ( 
	select uid,game
	from user_game
	lateral view explode(split(game_list,",")) tmpTable as game
) a
lateral view explode(split(uid, ",")) m as uid_split</code></pre> 
<h4> 例子4-多列炸裂</h4> 
<p><strong>1）创建测试表，插入数据</strong></p> 
<pre><code class="language-sql">CREATE table student_score(
	stu_id string comment '学号',
	stu_name string comment '姓名',
	courses string comment '各个科目',
	scores string comment '各个分数'
) comment '学生成绩表';</code></pre> 
<pre><code class="language-sql">insert into student_score values 
("1001", "张三","语文,数学,英语,历史,地理", "88,87,94,86,84"),
("1002", "李四", "语文,数学,英语,历史,地理", "78,89,75,79,68"),
("1003", "王五", "语文,数学,英语,历史,地理", "98,97,91,93,92"),
("1004", "朱六", "语文,数学,英语,历史,地理", "66,63,64,67,68");</code></pre> 
<p><strong> 2）测试explode 行转列</strong></p> 
<pre><code class="language-sql">select a.stu_id, a.stu_name, table_view.course 
from student_score a 
lateral view explode(split(courses, ',')) table_view as `course`;</code></pre> 
<p><img alt="" height="647" src="https://images2.imgbox.com/fc/a7/4XWpcp7q_o.png" width="645"> </p> 
<p><strong>3）查询每个学生课程对应的分数，使用posexplode函数 </strong></p> 
<p>先测试使用explode, 看看效果：</p> 
<pre><code class="language-sql">select a.stu_id, a.stu_name, 
    table_view1.course, table_view2.score
from student_score a 
lateral view explode(split(courses, ',')) table_view1 as `course` 
lateral view explode(split(scores, ',')) table_view2 as `score`;</code></pre> 
<p>结果:</p> 
<p><img alt="" height="659" src="https://images2.imgbox.com/4e/35/mPdL2U8I_o.png" width="1113"></p> 
<p>出现这种情况是因为两个并列的explode的sql没办法识别每个科目对应的成绩是多少，<strong>对于多个数组的行转列可以使用posexplode函数。</strong><br> 例如使用如下查询语句:</p> 
<pre><code class="language-sql">select stu_id, stu_name, course, score 
from student_score 
lateral view posexplode(split(courses, ',')) table_view1 as a, course 
lateral view posexplode(split(scores, ',')) table_view2 as b, score 
where a = b;</code></pre> 
<p><img alt="" height="646" src="https://images2.imgbox.com/f0/d4/OozaZQ2x_o.png" width="619"></p> 
<h4 style="background-color:transparent;"> 例子5-posexplode</h4> 
<p><img alt="" height="79" src="https://images2.imgbox.com/82/9e/Ke6Efy43_o.png" width="458"></p> 
<p>转换为</p> 
<p><img alt="" height="311" src="https://images2.imgbox.com/95/3c/Xw8m6Zsm_o.png" width="312"></p> 
<p>一次posexplode</p> 
<pre><code class="language-sql">select id,tim,single_id_index,single_id 
from test.a 
lateral view posexplode(split(id,',')) t as single_id_index, single_id;d;</code></pre> 
<p> 结果</p> 
<pre><code class="language-sql">single_id_index		single_id
0					a
1					b
2					c
3					d
0					f
1					b
2					c
3					d</code></pre> 
<p>两次posexplode+where筛选</p> 
<pre><code class="language-sql">select 
	id,tim,single_id,single_tim 
from 
	test.a 
	lateral view posexplode(split(id,',')) t as single_id_index, single_id
	lateral view posexplode(split(tim,',')) t as single_yim_index, single_tim
where 
	single_id_index = single_yim_index;</code></pre> 
<h4 style="background-color:transparent;">例子6-<span style="color:#0d0016;">explode+</span>map</h4> 
<p><img alt="" height="666" src="https://images2.imgbox.com/4f/33/eVCxgeRE_o.png" width="809"></p> 
<pre><code class="language-sql">select column1, column2, column3, m_key, m_val from
    (select column1, column2, column3, map("X1", X1, "X2", X2, "X3", X3, "X4", X4) as map1
    from table1) as t1
lateral view explode(map1) xyz as m_key, m_val </code></pre> 
<h4>例子7-explode+str_to_map</h4> 
<p><img alt="" height="310" src="https://images2.imgbox.com/70/70/jK5ubIhY_o.png" width="1200"></p> 
<p>转换为</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/21/c2/Uv7AdtC6_o.png" width="711"></p> 
<pre><code class="language-sql">select table_4.name,
a.item,
a.score
from table_4
lateral view explode(
str_to_map(concat('math=',math,'&amp;english=',english),'&amp;','=')
) a as item,score；</code></pre> 
<p><span style="color:#fe2c24;">解析：</span>首先使用str_to_map函数将math字段与english字段拼接后的结果转换为map类型，然后通过侧视图和explode函数将其爆炸开，给生成的临时侧视图一个名字，取名a并给列名取名为item,score，因为explode(map)爆炸的结果是每一个item为行，key为1列，value为1列，这样就恰好形成我们想要的结果。</p> 
<h2>二、行专列</h2> 
<h3>1、相关函数</h3> 
<p>行转列：将多个列中的数据在一列中输出</p> 
<h4>1）<strong>Concat</strong></h4> 
<pre><code class="language-sql">concat(string1/col, string2/col, …)</code></pre> 
<p>输入任意个字符串(或字段,可以为int类型等)，返回拼接后的结果</p> 
<pre><code class="language-sql">select concat(id,'-',name,'-',age) 
from student;</code></pre> 
<h4>2）<strong>Concat_ws</strong></h4> 
<pre><code class="language-sql">concat_ws(separator, str1, str2, …)</code></pre> 
<p>特殊形式的 concat()，参数只能为字符串，第一个参数为后面参数的分隔符。分隔符可以是与后面参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间；</p> 
<pre><code class="language-sql">select concat_ws('-', name, gender) 
from student;</code></pre> 
<h4>3）<strong>Collect_set（聚合，返回数组类型）</strong></h4> 
<pre><code class="language-sql">collect_set(col)</code></pre> 
<p>将某字段进行去重处理，返回array类型；该函数只接受基本数据类型</p> 
<pre><code class="language-sql">select collect_set(age) 
from student;</code></pre> 
<p><span style="color:#fe2c24;">collect_set 与 collect_list 的区别就是set去重，list不去重</span></p> 
<h4><span style="color:#0d0016;">4）</span>case when</h4> 
<pre><code class="language-sql">case when &lt;expr&gt; then &lt;result&gt;…else &lt;default&gt; end
if(expr, true_result, false_result)</code></pre> 
<p>case when 语句是SQL中的一个非常重要的功能，可以完成很多复杂的计算，相当于一个表达式，可以放在任何可放表达式的地方。</p> 
<h3>2、案例</h3> 
<h4>例子1</h4> 
<p><img alt="" height="369" src="https://images2.imgbox.com/52/6a/rFzGW9yB_o.png" width="915"></p> 
<p> 转换为</p> 
<p><img alt="" height="123" src="https://images2.imgbox.com/74/19/ewxjayUs_o.png" width="459"></p> 
<pre><code class="language-sql">select
    t1.base,
    concat_ws('|', collect_set(t1.name)) as name
from
    (select name,concat(constellation, ",", blood_type) as base
    from person_info) as t1
group by
    t1.base;</code></pre> 
<h4>例子2</h4> 
<p><img alt="" height="415" src="https://images2.imgbox.com/bf/20/LRWmAex0_o.png" width="955"></p> 
<p>转换为</p> 
<p><img alt="" height="80" src="https://images2.imgbox.com/4a/76/ImjbI7MC_o.png" width="522"> </p> 
<pre><code class="language-sql">select 
	stu_name,
	concat_ws(',',collect_set(course)) as course,
	concat_ws(',',collect_set(score)) as score
from student
group by stu_name</code></pre> 
<h4> 例子3</h4> 
<p><img alt="" height="281" src="https://images2.imgbox.com/c0/9f/pbNPt7rS_o.png" width="711"></p> 
<p>转换为</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/1b/da/ZUpYMGWD_o.png" width="1049"></p> 
<pre><code class="language-sql">Select
name,
sum(case when item=数学 then score end) as math,
sum(case when item=英语 then score end) as english,
From table
Group by name</code></pre> 
<p><span style="color:#fe2c24;">解析：</span>首先写出select name from table group by name, 因为select后有几个字段，最终输出就是几个字段，所以我们需要把目标数据的”math”和“english”两个字段想办法得出来。</p> 
<p>之后可以对item字段所有枚举的结果进行case when判断，将score填值进入，因为最后我们需要对name做一下聚合，需要明确的是一般选取字段一定要出现在groupby里面。</p> 
<p>聚合函数可以不用，所以我们在外面套一层sum做聚合，这样得到sum的结果和单人得分结果是一致的，因为我们以name做了一遍聚合，而每个用户对一门课程只有一个成绩，所以这样就可以得到最终结果。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21406c38c4eb5c57ddd10c8eb06bebe8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中如何详细的打印出具体报错的堆栈信息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/980443924292033d18fb8505a00f4267/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI创作之旅：探索提示工程的奇妙世界</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>