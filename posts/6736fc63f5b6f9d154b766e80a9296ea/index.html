<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【一步一步了解Java系列】：重磅多态 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6736fc63f5b6f9d154b766e80a9296ea/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【一步一步了解Java系列】：重磅多态">
  <meta property="og:description" content="看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
何为多态 在Java中，多态（Polymorphism）是一种允许不同类的对象对同一消息做出响应的能力，即同一个接口可以被不同的实例以不同的方式实现。多态性是面向对象编程的一个核心概念，它使得代码更加灵活和可扩展。
多态性主要通过以下几种方式实现：
方法重载（Overloading）：这是编译时多态的一个例子。方法重载允许同一个类中有多个同名方法，只要它们的参数列表不同（参数的类型、数量或顺序不同）。方法重写（Overriding）：这是运行时多态的一个例子。当子类继承父类时，子类可以重写父类的方法。如果子类对象调用了一个被重写的方法，将执行子类中的方法实现，而不是父类中的实现。接口实现：一个类可以实现一个或多个接口，接口定义了一组方法规范，具体的实现类必须提供这些方法的具体实现。不同的实现类可以以不同的方式实现同一个接口中定义的方法。抽象类：抽象类可以包含抽象方法，这些方法没有具体的实现，必须由继承抽象类的子类来实现。这也是一种多态的体现，因为不同的子类可以提供不同的实现。 多态的使用可以带来以下好处：
代码复用：通过继承和接口实现，可以减少代码的重复编写。扩展性：通过多态，可以在不修改现有代码的情况下，引入新的类和对象。灵活性：多态允许程序在运行时动态地绑定方法调用，使得程序更加灵活。 多态是Java中实现开闭原则（对扩展开放，对修改封闭）的关键机制之一，它允许程序更容易适应变化，同时保持代码的稳定性和可维护性。
多态实现的条件：
必须在继承体系下子类必须要对父类中方法进行重写通过父类的引用调用重写的方法 总的来说：多态即是不同对象，不同的的态度。
方法重载的多态 方法重载在前面其实已经说过了，下面是一个方法重载多态的情况：
public class Cat { String type=&#34;猫咪&#34;; public void eat(){ System.out.println(type&#43;&#34;吃猫粮&#34;); } public void eat(int n){ System.out.println(type&#43;&#34;吃&#34;&#43;n&#43;&#34;两猫粮&#34;); } } class Test{ public static void main(String[] args) { Cat cat=new Cat(); cat.eat(); cat.eat(1); } } 上面我们对方法进行重载，然后传参不同时，同一个方法却呈现不同的打印方式即（不同的形态）。
方法重写的多态 我们先要认识，何为重写：
在Java中，重写（Overriding）是指子类提供一个特定的实现，覆盖从父类继承来的方法的实现。这是运行时多态的一个体现，意味着在程序运行时，会根据对象的实际类型来调用相应的方法。
要实现方法重写，需要满足以下条件：
方法名、参数列表和返回类型：子类重写的方法必须具有与父类被重写方法相同的方法名、参数列表和返回类型。如果返回类型不同，则不是重写，而是重载（Overloading）。访问权限：子类重写的方法不能具有比父类更严格的访问权限。例如，如果父类中的方法是public的，子类重写的方法也必须是public或protected，但不能是private。非静态方法：重写必须发生在非静态方法上。静态方法（Static methods）不能被重写。非最终方法：如果父类中的方法是final的，则不能被重写。 下面是一个简单的示例，展示如何在Java中重写方法：
class Animal { public void sound() { System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-05T17:12:05+08:00">
    <meta property="article:modified_time" content="2024-06-05T17:12:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【一步一步了解Java系列】：重磅多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>看到这句话的时候证明：此刻你我都在努力</strong><br> <strong>加油陌生人</strong><br> <img src="https://images2.imgbox.com/31/5d/9PjRvUWO_o.png" alt="微信图片编辑_20240229212205.png"><br> <br><strong>个人主页：</strong><a href="https://blog.csdn.net/2302_81249757?type=lately"><strong>Gu Gu Study</strong></a><strong><br><strong>专栏：</strong><a href="https://blog.csdn.net/2302_81249757/category_12656486.html?spm=1001.2014.3001.5482"><strong>一步一步了解Java</strong></a><br><br> 喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹</strong><br> <br><strong>喜欢的话可以点个赞谢谢了。</strong><br> <strong>作者：小闭</strong></p> 
<hr> 
<h2><a id="_12"></a>何为多态</h2> 
<p>在Java中，多态（Polymorphism）是一种允许不同类的对象对同一消息做出响应的能力，即同一个接口可以被不同的实例以不同的方式实现。多态性是面向对象编程的一个核心概念，它使得代码更加灵活和可扩展。<br> 多态性主要通过以下几种方式实现：</p> 
<ol><li><strong>方法重载（Overloading）</strong>：这是编译时多态的一个例子。方法重载允许同一个类中有多个同名方法，只要它们的参数列表不同（参数的类型、数量或顺序不同）。</li><li><strong>方法重写（Overriding）</strong>：这是运行时多态的一个例子。当子类继承父类时，子类可以重写父类的方法。如果子类对象调用了一个被重写的方法，将执行子类中的方法实现，而不是父类中的实现。</li><li><strong>接口实现</strong>：一个类可以实现一个或多个接口，接口定义了一组方法规范，具体的实现类必须提供这些方法的具体实现。不同的实现类可以以不同的方式实现同一个接口中定义的方法。</li><li><strong>抽象类</strong>：抽象类可以包含抽象方法，这些方法没有具体的实现，必须由继承抽象类的子类来实现。这也是一种多态的体现，因为不同的子类可以提供不同的实现。</li></ol> 
<p>多态的使用可以带来以下好处：</p> 
<ul><li><strong>代码复用</strong>：通过继承和接口实现，可以减少代码的重复编写。</li><li><strong>扩展性</strong>：通过多态，可以在不修改现有代码的情况下，引入新的类和对象。</li><li><strong>灵活性</strong>：多态允许程序在运行时动态地绑定方法调用，使得程序更加灵活。</li></ul> 
<p>多态是Java中实现开闭原则（对扩展开放，对修改封闭）的关键机制之一，它允许程序更容易适应变化，同时保持代码的稳定性和可维护性。<br> <strong>多态实现的条件：</strong></p> 
<ol><li><strong>必须在继承体系下</strong></li><li><strong>子类必须要对父类中方法进行重写</strong></li><li><strong>通过父类的引用调用重写的方法</strong></li></ol> 
<p><strong>总的来说：多态即是不同对象，不同的的态度。</strong></p> 
<hr> 
<h3><a id="_38"></a>方法重载的多态</h3> 
<p>方法重载在前面其实已经说过了，下面是一个方法重载多态的情况：</p> 
<pre><code>public class Cat {

    String type="猫咪";
    public void eat(){
        System.out.println(type+"吃猫粮");

    }


    public void eat(int n){

        System.out.println(type+"吃"+n+"两猫粮");

    }

}

class Test{
    public static void main(String[] args) {
        Cat cat=new Cat();
        cat.eat();
        cat.eat(1);

    }


}
</code></pre> 
<p><img src="https://images2.imgbox.com/6d/bf/O8KojkgU_o.png" alt="image.png"><br> 上面我们对方法进行重载，然后传参不同时，同一个方法却呈现不同的打印方式即（不同的形态）。</p> 
<h4><a id="_72"></a>方法重写的多态</h4> 
<p>我们先要认识，<strong>何为重写</strong>：<br> 在Java中，重写（Overriding）是指子类提供一个特定的实现，覆盖从父类继承来的方法的实现。这是运行时多态的一个体现，意味着在程序运行时，会根据对象的实际类型来调用相应的方法。<br> 要实现方法重写，需要满足以下条件：</p> 
<ol><li><strong>方法名、参数列表和返回类型</strong>：子类重写的方法必须具有与父类被重写方法相同的方法名、参数列表和返回类型。如果返回类型不同，则不是重写，而是重载（Overloading）。</li><li><strong>访问权限</strong>：子类重写的方法不能具有比父类更严格的访问权限。例如，如果父类中的方法是public的，子类重写的方法也必须是public或protected，但不能是private。</li><li><strong>非静态方法</strong>：重写必须发生在非静态方法上。静态方法（Static methods）不能被重写。</li><li><strong>非最终方法</strong>：如果父类中的方法是final的，则不能被重写。</li></ol> 
<p>下面是一个简单的示例，展示如何在Java中重写方法：</p> 
<pre><code>class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override // 这是一个注解，用于指示该方法重写了父类的方法
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 向上转型
        myAnimal.sound(); // 输出 "Dog barks"，展示了运行时多态
    }
}
</code></pre> 
<p>在这个例子中，Dog 类继承自 Animal 类，并重写了 sound() 方法。当我们创建 Dog 类的实例并将其向上转型为 Animal 类型时，调用 sound() 方法会执行 Dog 类中重写的方法，而不是 Animal 类中的原始方法。这就是多态性的一个典型应用，它允许程序在运行时根据对象的实际类型来确定调用哪个方法。</p> 
<p>了解完重写我们在看看，下面的代码：</p> 
<pre><code>public class Animal {
    String name="aaaa";

    public void eat(){
        System.out.println("吃东西。。。。。");

    }
}


class Dog extends Animal{

    String name;

    public Dog(String name) {
        this.name = name;
    }

    public void eat(){
       System.out.println("吃狗粮。。。");


    }




}

class Cat extends Animal{

    String name;

    public Cat(String name) {
        this.name = name;
    }

    public void eat(){
        System.out.println("吃猫粮。。。");


    }




}

class Test{

    public static void main(String[] args) {
        Animal animal=new Dog("旺财");
       animal.eat();
        animal=new Cat("小黑");
        animal.eat();
     
    }



}
</code></pre> 
<p><img src="https://images2.imgbox.com/3d/aa/hAXM0NOa_o.png" alt="image.png"><br> 我们在调用eat（）方法时却呈现了不同的形态，即：一个吃猫粮，一个吃狗粮。</p> 
<p>我们也可以用静态方法实现多态如下：</p> 
<pre><code>public class Animal {
    String name="aaaa";

    public void eat(){
        System.out.println("吃东西。。。。。");

    }
}


class Dog extends Animal{

    String name;

    public Dog(String name) {
        this.name = name;
    }

    public void eat(){
        System.out.println("吃狗粮。。。");


    }




}

class Cat extends Animal{

    String name;

    public Cat(String name) {
        this.name = name;
    }

    public void eat(){
        System.out.println("吃猫粮。。。");


    }




}

class Test{
public static void eat(Animal animal){
    animal.eat();

}
    public static void main(String[] args) {
        Dog dog=new Dog("旺财");
       eat(dog);
       Cat cat=new Cat("小黑");
       eat(cat);

    }



}
</code></pre> 
<p><img src="https://images2.imgbox.com/c1/99/tHj6uIHr_o.png" alt="image.png"><br> 这里我们在Test中实现了一个静态方法eat（Animal animal）然后传递一个对象进去即可完成多态。<br> 其实上面的代码还涉及了，类的向上转型。我们接下来就讲讲向上转型和向下转型。</p> 
<h5><a id="_247"></a>向上转型和向下转型</h5> 
<p>在Java中，向上转型（Upcasting）和向下转型（Downcasting）是面向对象编程中多态性的一部分，它们允许我们处理不同类型的对象，但以更通用的类型进行操作。<br> <strong>向上转型（Upcasting）</strong><br> 向上转型是指将子类对象赋值给父类引用的过程。向上转型是安全的，因为子类是父类的特化。这意味着子类继承了父类的所有属性和方法，所以子类对象可以被看作是父类对象。<br> <strong>示例代码：</strong></p> 
<pre><code>class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 向上转型
        myAnimal.makeSound(); // 将调用Dog类的makeSound方法
    }
}
</code></pre> 
<p>在这个例子中，Dog 类是 Animal 类的子类。我们创建了一个 Dog 类的实例，并将这个实例赋值给 Animal 类型的引用 myAnimal。由于向上转型是安全的，编译器允许这样做，并且当我们调用 makeSound() 方法时，将调用 Dog 类中重写的方法。<br> <strong>向下转型（Downcasting）</strong><br> 向下转型是指将父类对象赋值给子类引用的过程。向下转型是不安全的，因为父类引用可能没有指向实际的子类对象。如果向下转型不正确，将会导致 ClassCastException。<br> <strong>示例代码：</strong></p> 
<pre><code>class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        Dog myDog = (Dog) myAnimal; // 向下转型

        if (myAnimal instanceof Dog) {
            Dog myDogSafe = (Dog) myAnimal; // 安全的向下转型
            myDogSafe.makeSound(); // 将调用Dog类的makeSound方法
        } else {
            System.out.println("myAnimal is not a Dog");
        }
    }
}
</code></pre> 
<p>在这个例子中，我们首先向上转型，将 Dog 对象赋值给 Animal 类型的引用 myAnimal。然后我们尝试向下转型，将 myAnimal 转换为 Dog 类型的引用 myDog。如果 myAnimal 实际上指向了一个 Dog 对象，那么向下转型将成功，否则将抛出 ClassCastException。<br> 为了安全地进行向下转型，可以使用 instanceof 操作符来检查 myAnimal 是否确实指向了一个 Dog 对象。如果 instanceof 检查为 true，那么向下转型是安全的。</p> 
<p>注意：<br> 向上转型后只能调用父类的成员和方法，无法再调用子类特有的成员变量或方法。</p> 
<hr> 
<h6><a id="_311"></a>一个小坑</h6> 
<p>避免在调用构造方法时调用已经重写过的方法，否则很容易出错。<br> 如下代码：在实例化子类对象时，我们必须先调用完成父类的构造方法，然而Animal的构造方法又调用了子类的已经重写的方法func，这时发生动态绑定，方法执行重写的func，而此时num的值未完成初始化，就打印了0出来，所以打印结果就如下图：</p> 
<pre><code>public class Test {

    public static void main(String[] args) {
        Dog dog=new Dog();

    }
}

class Animal{

public void func(){
    System.out.println("动物");
}

public Animal(){
    func();
}


}


class Dog extends Animal{

    int num=999;
    public void func(){
        System.out.println("狗");
        System.out.println(num);
    }


}
</code></pre> 
<p><img src="https://images2.imgbox.com/6a/04/FYDoPdVb_o.png" alt="image.png"></p> 
<h6><a id="final_350"></a>浅谈final关键字</h6> 
<p>第一：final修饰类，则类不能被继承<br> <img src="https://images2.imgbox.com/23/62/Bw4XVYSg_o.png" alt="image.png"></p> 
<p>第二：修饰类的方法则方法不能被重写<br> <img src="https://images2.imgbox.com/e0/13/zLTVTdB4_o.png" alt="image.png"></p> 
<p>第三：修饰成员变量则变量相当于常量，无法在进行修改。<br> <img src="https://images2.imgbox.com/7f/3e/QOHbkY0M_o.png" alt="image.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70451bb5100500be0db029e51051bd5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">完美解决 mysql 报错ERROR 1524 (HY000): Plugin ‘mysql_native_password‘ is not loaded</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5ffb471173e9c4262f8fecca99ae463a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高效数据处理的前沿：【C&#43;&#43;】、【Redis】、【人工智能】与【大数据】的深度整合</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>