<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ常见问题及解决方案 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f9237d543d66c012c16de41ecf0348a7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMQ常见问题及解决方案">
  <meta property="og:description" content="目录
一、消息丢失
1、生产者重连
2、生产者确认
3、数据持久化
4、惰性队列
5、消费失败处理
二、消息重复
1、通过业务保证幂等性（优先）
2、通过消息状态去重保证幂等性
三、消息堆积
1、优化消费者处理逻辑
2、增加队列及消费者数量
3、使用惰性队列
四、保证消息顺序消费
一、消息丢失 1、生产者重连 由于网络波动，可能会出现客户端连接失败的情况，需开启重连机制。
SpringBoot项目配置：
spring: rabbitmq: # 连接超时时间 connection-timeout: 500ms template: retry: # 开启失败重连 enabled: true # 失败后重连初始间隔时间 initial-interval: 1000ms # 失败后下次间隔的时长倍数，下次间隔时长=本次间隔时长*multiplier multiplier: 1 # 最大重试次数 max-attempts: 3 注意：重试过程线程是被阻塞的，合理配置等待时长及最大重试次数，或开启异步线程执行，以免影响业务性能。
2、生产者确认 SpringBoot项目配置：
spring: rabbitmq: # 开启生产者确认 publisher-confirm-type: correlated # 返回路由失败消息，一般是开发问题，无需开启 publisher-returns: true publisher-confirm-type三种模式：
none关闭simple同步阻塞等待MQ回执消息correlated（推荐）MQ异步回调返回回执消息 注意：以上两种方式均会造成MQ性能下降，非必要不建议开启。失败情况毕竟非常少，可在代码中通过输出日志或存储数据库等方式将发送失败的消息记录下来，稍后手动处理。
3、数据持久化 交换机持久化：在声明交换器时将“durable”参数设置为true队列持久化：在声明队列的时将“durable”参数设置为true消息持久化：生产消息时设置属性delivery_mode=2 SpringBoot项目：
交换机和消息默认为持久化，需自行设置队列持久化。
@RabbitListener(bindings = @QueueBinding( value = @Queue(name = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-04T13:40:16+08:00">
    <meta property="article:modified_time" content="2024-01-04T13:40:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ常见问题及解决方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1" rel="nofollow">一、消息丢失</a></p> 
<p id="1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%BF%9E-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%BF%9E" rel="nofollow">1、生产者重连</a></p> 
<p id="%C2%A02%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4-toc" style="margin-left:40px;"><a href="#%C2%A02%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4" rel="nofollow">2、生产者确认</a></p> 
<p id="3%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">3、数据持久化</a></p> 
<p id="4%E3%80%81%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97" rel="nofollow">4、惰性队列</a></p> 
<p id="5%E3%80%81%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86" rel="nofollow">5、消费失败处理</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D" rel="nofollow">二、消息重复</a></p> 
<p id="1%E3%80%81%E9%80%9A%E8%BF%87%E4%B8%9A%E5%8A%A1%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E4%BC%98%E5%85%88%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%80%9A%E8%BF%87%E4%B8%9A%E5%8A%A1%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E4%BC%98%E5%85%88%EF%BC%89" rel="nofollow">1、通过业务保证幂等性（优先）</a></p> 
<p id="2%E3%80%81%E9%80%9A%E8%BF%87%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81%E5%8E%BB%E9%87%8D%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E9%80%9A%E8%BF%87%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81%E5%8E%BB%E9%87%8D%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7" rel="nofollow">2、通过消息状态去重保证幂等性</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF" rel="nofollow">三、消息堆积</a></p> 
<p id="1%E3%80%81%E4%BC%98%E5%8C%96%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BC%98%E5%8C%96%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91" rel="nofollow">1、优化消费者处理逻辑</a></p> 
<p id="2%E3%80%81%E5%A2%9E%E5%8A%A0%E9%98%9F%E5%88%97%E5%8F%8A%E6%B6%88%E8%B4%B9%E8%80%85%E6%95%B0%E9%87%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%A2%9E%E5%8A%A0%E9%98%9F%E5%88%97%E5%8F%8A%E6%B6%88%E8%B4%B9%E8%80%85%E6%95%B0%E9%87%8F" rel="nofollow">2、增加队列及消费者数量</a></p> 
<p id="3%E3%80%81%E4%BD%BF%E7%94%A8%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97" rel="nofollow">3、使用惰性队列</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9" rel="nofollow">四、保证消息顺序消费</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1">一、消息丢失</h2> 
<h3 id="1%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E9%87%8D%E8%BF%9E">1、生产者重连</h3> 
<p>由于网络波动，可能会出现客户端连接失败的情况，需开启重连机制。</p> 
<p><strong>SpringBoot项目配置：</strong></p> 
<pre><code>spring:
  rabbitmq:
    # 连接超时时间
    connection-timeout: 500ms
    template:
      retry:
        # 开启失败重连
        enabled: true
        # 失败后重连初始间隔时间
        initial-interval: 1000ms
        # 失败后下次间隔的时长倍数，下次间隔时长=本次间隔时长*multiplier
        multiplier: 1
        # 最大重试次数
        max-attempts: 3</code></pre> 
<blockquote> 
 <p>注意：重试过程线程是被阻塞的，合理配置等待时长及最大重试次数，或开启异步线程执行，以免影响业务性能。</p> 
</blockquote> 
<h3 id="%C2%A02%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E7%A1%AE%E8%AE%A4">2、生产者确认</h3> 
<p><strong>SpringBoot项目配置：</strong></p> 
<pre><code>spring:
  rabbitmq:
    # 开启生产者确认
    publisher-confirm-type: correlated
    # 返回路由失败消息，一般是开发问题，无需开启
    publisher-returns: true</code></pre> 
<p><strong> publisher-confirm-type三种模式：</strong></p> 
<table align="left" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>none</td><td>关闭</td></tr><tr><td>simple</td><td>同步阻塞等待MQ回执消息</td></tr><tr><td>correlated（推荐）</td><td>MQ异步回调返回回执消息</td></tr></tbody></table> 
<blockquote> 
 <p>注意：以上两种方式均会造成MQ性能下降，非必要不建议开启。失败情况毕竟非常少，可在代码中通过输出日志或存储数据库等方式将发送失败的消息记录下来，稍后手动处理。</p> 
</blockquote> 
<h3 id="3%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">3、数据持久化</h3> 
<ul><li>交换机持久化：在声明交换器时将“durable”参数设置为true</li><li>队列持久化：在声明队列的时将“durable”参数设置为true</li><li>消息持久化：生产消息时设置属性delivery_mode=2</li></ul> 
<p><strong>SpringBoot项目：</strong></p> 
<p>交换机和消息默认为持久化，需自行设置队列持久化。</p> 
<pre><code class="language-bash">@RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = "xx.queue", durable = "true"),
            exchange = @Exchange(name = "xx.topic", type = ExchangeTypes.TOPIC),
            key = "xx"
    ))</code></pre> 
<h3 id="4%E3%80%81%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97">4、惰性队列</h3> 
<p>从<strong>RabbitMQ</strong>的<strong>3.6.0</strong>版本开始，就增加了<strong>Lazy Queues</strong>的概念，也就是惰性队列。惰性队列的特征如下：</p> 
<ol><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ol> 
<p><strong>声明LazyQueue：</strong></p> 
<pre><code class="language-bash">@RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = "xx.queue", durable = "true",
                    arguments = {@Argument(name = "x-queue-mode", value = "lazy"),
            exchange = @Exchange(name = "xx.topic", type = ExchangeTypes.TOPIC),
            key = "xx"
    ))</code></pre> 
<blockquote> 
 <p><strong>优点： </strong></p> 
 <ol><li> <p>基于磁盘存储，消息上限高</p> </li><li> <p>没有间歇性的page-out，性能比较稳定</p> </li></ol> 
 <p><strong>缺点：</strong></p> 
 <ol><li> <p>基于磁盘存储，消息时效性会降低</p> </li><li> <p>性能受限于磁盘的IO</p> </li></ol> 
</blockquote> 
<h3 id="5%E3%80%81%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86">5、消费失败处理</h3> 
<p>失败后尝试在本地重试，重试后依然失败，将消息投递到用于投递失败消息的交换机，存储到失败消息队列中，等待后续手动处理。</p> 
<p>SpringBoot项目配置：</p> 
<pre><code class="language-java">spring:
  rabbitmq:
    listener:
      simple:
        retry:
          # 开启失败重试
          enabled: true</code></pre> 
<p> SpringBoot项目配置类：</p> 
<pre><code class="language-java">import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.MessageRecoverer;
import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitMqErrorConfig {

    @Bean
    public DirectExchange errorExchange() {
        return new DirectExchange("error.direct");
    }

    @Bean
    public Queue errorQueue() {
        return new Queue("error.queue");
    }

    @Bean
    public Binding errorBinding(Queue errorQueue, DirectExchange errorExchange) {
        return BindingBuilder.bind(errorQueue).to(errorExchange).with("error");
    }

    @Bean
    public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate) {
        return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");
    }
}</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D">二、消息重复</h2> 
<p>由于网络问题或消息生产消费过程中出现问题，均会导致消息重复的情况。</p> 
<h3 id="1%E3%80%81%E9%80%9A%E8%BF%87%E4%B8%9A%E5%8A%A1%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E4%BC%98%E5%85%88%EF%BC%89">1、通过业务保证幂等性（优先）</h3> 
<p>在业务层面上，保证重复执行对结果不产生影响。例如：支付成功后修改订单状态，可以将未支付状态作为修改语句的执行条件。</p> 
<h3 id="2%E3%80%81%E9%80%9A%E8%BF%87%E6%B6%88%E6%81%AF%E7%8A%B6%E6%80%81%E5%8E%BB%E9%87%8D%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7">2、通过消息状态去重保证幂等性</h3> 
<p>如果不能通过业务保证幂等性，可以将处理过的消息ID记录到redis，如果新到的消息ID已经在记录中，那么就不再处理这条消息。</p> 
<h2 id="%E4%B8%89%E3%80%81%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF">三、消息堆积</h2> 
<h3 id="1%E3%80%81%E4%BC%98%E5%8C%96%E6%B6%88%E8%B4%B9%E8%80%85%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91">1、优化消费者处理逻辑</h3> 
<p>优化消费者处理逻辑，使消费者更快处理。</p> 
<h3 id="2%E3%80%81%E5%A2%9E%E5%8A%A0%E9%98%9F%E5%88%97%E5%8F%8A%E6%B6%88%E8%B4%B9%E8%80%85%E6%95%B0%E9%87%8F">2、增加队列及消费者数量</h3> 
<p>将队列绑定多个消费者，提高消费速度。</p> 
<h3 id="3%E3%80%81%E4%BD%BF%E7%94%A8%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97">3、使用惰性队列</h3> 
<p>基于磁盘存储，消息上限高。</p> 
<h2 id="%E5%9B%9B%E3%80%81%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9">四、保证消息顺序消费</h2> 
<p><strong>发生原因：</strong></p> 
<ol><li>一个队列绑定多个消费者</li><li>一个消费者开启多个线程</li></ol> 
<p><strong>1、将一个队列拆分成多个队列，保证一个队列只绑定一个消费者，生产者在投递消息时根据业务数据关键值来将需要保证先后顺序的同一类数据发送到同一个队列当中。</strong></p> 
<p><strong>2、将队列设置为单活模式</strong></p> 
<blockquote> 
 <p>x-single-active-consumer：单活模式，表⽰是否最多只允许⼀个消费者消费，如果有多个消费者同时绑定，则只会激活第⼀个，除⾮第⼀个消费者被取消或者死亡，才会⾃动转到下⼀个消费者。</p> 
</blockquote> 
<pre><code class="language-bash">@RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = "xx.queue", durable = "true",
                    arguments = {@Argument(name = "x-single-active-consumer", value = "true", type = "java.lang.Boolean")}),
            exchange = @Exchange(name = "xx.topic", type = ExchangeTypes.TOPIC),
            key = "xx"
    ))</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9ab22e1e8585b9abf6e7c6930dc44c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity 工具“常用插件九大分类汇总”（UI/VR/AR/建模/Shader/动画/网络/AI/资源/数据/区块链等）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea388122f0271478912bbb452e95a131/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Hive不支持delete、update问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>