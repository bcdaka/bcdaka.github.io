<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring之AOP的详细讲解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1040ff0a48b8a530206f8935d67d5b2f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Spring之AOP的详细讲解">
  <meta property="og:description" content="目录
一.SpringAOP是什么？
1.1理论知识点
1.2简单的AOP例子
二.SpringAOP的核心概念 2.1切点(Pointcut)
2.2通知（Advice）
2.3切⾯(Aspect)
2.4通知类型
2.5切⾯优先级 @Order
2.6切点表达式
2.6.1 @execution表达式
2.6.2@annotation表达式
总结
一.SpringAOP是什么？ 1.1理论知识点 在学习SpringAOP前，我们需要了解一下什么是AOP？
AOP（Aspect Oriented Programming）：⾯向切⾯编程，通过预编译和运行期间动态代理来实现程序功能的统一维护的一种技术。 它是⼀种思想，它是对某⼀类事情的集中处理。 ⽐如⽤户登录权限的效验，没学 AOP 之前，我们所有需要判断⽤户登录的⻚⾯（中 的⽅法），都要各⾃实现或调⽤⽤户验证的⽅法，然⽽有了 AOP 之后，我们只需要在某⼀处配置⼀下，所有需要判断⽤户登录⻚⾯（中的⽅法）就全部可以实现⽤户登录验证了，不再需要每个⽅法中都写相同的⽤户登录验证了。 AOP中的基本单元是 Aspect(切面)
1.2简单的AOP例子 理论永远没有代码直观！
引入依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 定义切面： @Aspect // 定义切面 @Component public class UserAspect { // 切点 @Pointcut(&#34;execution(* com.example.interview.Controller.UserController.*(..))&#34;) public void pointcut() { } // 前置通知通知 @Before(&#34;pointcut()&#34;) public void doBefore() { System.out.println(&#34;执行了前置通知&#34;); } // 后置通知 @After(&#34;pointcut()&#34;) public void doAfter() { System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-09T11:26:53+08:00">
    <meta property="article:modified_time" content="2024-04-09T11:26:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring之AOP的详细讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>      </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.SpringAOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80.SpringAOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">一.SpringAOP是什么？</a></p> 
<p id="1.1%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%82%B9-toc" style="margin-left:40px;"><a href="#1.1%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%82%B9" rel="nofollow">1.1理论知识点</a></p> 
<p id="1.2%E7%AE%80%E5%8D%95%E7%9A%84AOP%E4%BE%8B%E5%AD%90-toc" style="margin-left:40px;"><a href="#1.2%E7%AE%80%E5%8D%95%E7%9A%84AOP%E4%BE%8B%E5%AD%90" rel="nofollow">1.2简单的AOP例子</a></p> 
<p id="%E4%BA%8C.SpringAOP%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.SpringAOP%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%C2%A0" rel="nofollow">二.SpringAOP的核心概念 </a></p> 
<p id="2.1%E5%88%87%E7%82%B9(Pointcut)-toc" style="margin-left:40px;"><a href="#2.1%E5%88%87%E7%82%B9%28Pointcut%29" rel="nofollow">2.1切点(Pointcut)</a></p> 
<p id="2.2%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89" rel="nofollow">2.2通知（Advice）</a></p> 
<p id="2.3%E5%88%87%E2%BE%AF(Aspect)-toc" style="margin-left:40px;"><a href="#2.3%E5%88%87%E2%BE%AF%28Aspect%29" rel="nofollow">2.3切⾯(Aspect)</a></p> 
<p id="2.4%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2.4%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B" rel="nofollow">2.4通知类型</a></p> 
<p id="2.5%E5%88%87%E2%BE%AF%E4%BC%98%E5%85%88%E7%BA%A7%20%40Order-toc" style="margin-left:40px;"><a href="#2.5%E5%88%87%E2%BE%AF%E4%BC%98%E5%85%88%E7%BA%A7%20%40Order" rel="nofollow">2.5切⾯优先级 @Order</a></p> 
<p id="2.6%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2.6%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">2.6切点表达式</a></p> 
<p id="2.6.1%C2%A0%40execution%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2.6.1%C2%A0%40execution%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">2.6.1 @execution表达式</a></p> 
<p id="2.6.2%40annotation%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2.6.2%40annotation%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">2.6.2@annotation表达式</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.SpringAOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">一.SpringAOP是什么？</h2> 
<h3 id="1.1%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%E7%82%B9">1.1理论知识点</h3> 
<p>        在学习SpringAOP前，我们需要了解一下什么是AOP？</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/fb/93/28jY0lng_o.png" width="437"></p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">  </span> 
  <span style="color:#0d0016;">      AOP（Aspect Oriented Programming）：⾯向切⾯编程，</span>通过预编译和运行期间动态代理来实现程序功能的统一维护的一种技术。 
  <span style="color:#0d0016;">它是⼀种思想，它是对某⼀类事情的集中处理。</span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">        ⽐如⽤户登录权限的效验，没学 AOP 之前，我们所有需要判断⽤户登录的⻚⾯（中 </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">的⽅法），都要各⾃实现或调⽤⽤户验证的⽅法，然⽽有了 AOP 之后，我们只需要在某⼀处配置⼀下，所有需要判断⽤户登录⻚⾯（中的⽅法）就全部可以实现⽤户登录验证了，不再需要每个⽅法中都写相同的⽤户登录验证了。</span> 
 </div> 
</blockquote> 
<p>        AOP中的基本单元是 Aspect(切面)</p> 
<h3 id="1.2%E7%AE%80%E5%8D%95%E7%9A%84AOP%E4%BE%8B%E5%AD%90">1.2简单的AOP例子</h3> 
<p>        理论永远没有代码直观！</p> 
<p><strong>引入依赖：</strong></p> 
<pre><code class="language-java">&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<p><strong>定义切面： </strong></p> 
<pre><code class="language-java">@Aspect // 定义切面
@Component
public class UserAspect {

    // 切点
    @Pointcut("execution(* com.example.interview.Controller.UserController.*(..))")
    public void pointcut() {
        
    }

    // 前置通知通知
    @Before("pointcut()")
    public void doBefore() {
        System.out.println("执行了前置通知");
    }

    // 后置通知
    @After("pointcut()")
    public void doAfter() {
        System.out.println("执行了后置通知");
    }

    // 环绕通知
    @Around("pointcut()")
    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("环绕通知执行之前");
        // 执行目标方法
        Object result = joinPoint.proceed();
        System.out.println("环绕通知执行之后");
        return result;
    }

}</code></pre> 
<p><strong>设计的Controller类：</strong></p> 
<pre><code class="language-java">package com.example.interview.Controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/getuser")
    public String getUser(){
        System.out.println("do getUser");
        return "get user";
    }

    @RequestMapping("/deluser")
    public String delUser(){
        System.out.println("do delUser");
        return "del user";
    }

}</code></pre> 
<p><strong>执行结果：</strong><br><img alt="" height="346" src="https://images2.imgbox.com/6e/48/JmNbzt9H_o.png" width="619"></p> 
<h3></h3> 
<h2 id="%E4%BA%8C.SpringAOP%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%C2%A0">二.SpringAOP的核心概念 </h2> 
<p>我们接下来分析一下切面代码：</p> 
<p>从上面的代码中，我们可以得到哪些要素呢？</p> 
<ul><li><strong>@Aspect</strong>：切面类，告诉Spring我这个类是个切面，里面有特殊处理方法</li><li><strong>@Pointcut</strong>：切点，告诉Spring我要针对什么</li><li><strong>@Before、@Around、@AfterReturning、@After、@AfterThrowing</strong>：通知，告诉Spring针对后要做什么处理</li></ul> 
<h3 id="2.1%E5%88%87%E7%82%B9(Pointcut)">2.1切点<span style="color:#1f2329;">(Pointcut)</span></h3> 
<blockquote> 
 <div> 
  <span style="color:#1f2329;"><strong>切点(Pointcut)</strong>, 也称之为"切⼊点" </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">Pointcut 的作⽤就是提供⼀组规则 (使⽤ AspectJ pointcut expression language 来描述), 告诉程序对 哪些⽅法来进⾏功能增强.<span style="background-color:#ffd900;">也称：公共切点表达式！</span></span> 
 </div> 
</blockquote> 
<p><img alt="" height="192" src="https://images2.imgbox.com/32/3c/7fcGDe1t_o.png" width="820"></p> 
<p>如果我们不使用@<span style="color:#1f2329;">Pointcut注释，将会让代码冗余大量的切点表达式！</span></p> 
<p><span style="color:#1f2329;">不使用情况下：</span></p> 
<pre><code class="language-java">@Aspect // 定义切面
@Component
public class UserAspect {

    // 前置通知通知
    @Before("execution(* com.example.interview.Controller.UserController.*(..))")
    public void doBefore() {
        System.out.println("执行了前置通知");
    }

    // 后置通知
    @After("execution(* com.example.interview.Controller.UserController.*(..))")
    public void doAfter() {
        System.out.println("执行了后置通知");
    }

    // 环绕通知
    @Around("execution(* com.example.interview.Controller.UserController.*(..))")
    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("环绕通知执行之前");
        // 执行目标方法
        Object result = joinPoint.proceed();
        System.out.println("环绕通知执行之后");
        return result;
    }

}</code></pre> 
<blockquote> 
 <p>我们会发现<span style="color:#1f2329;">存在⼤量重复的切点表达 execution(*com.example.interview.Controller.UserController.*(..))") </span></p> 
 <p></p> 
 <p><strong><span style="background-color:#ffd900;">execution，</span></strong>也可以说是<strong>连接点</strong>，就是告诉Spring，该路径下需要控制的方法，*代表的是所有方法，(..)代表任意参数。</p> 
</blockquote> 
<p>注： <span style="color:#1f2329;">当切点定义使⽤private修饰时, 仅能在当前切⾯类中使⽤, 当其他切⾯类也要使⽤当前切点定义时, 就需要把private改为public. 引⽤⽅式为: <span style="background-color:#ffd900;">全限定类名.⽅法名() </span></span></p> 
<p><span style="color:#1f2329;">例如：</span></p> 
<pre><code class="language-java">@Slf4j
@Aspect
@Component
public class AspectDemo2 {
 //前置通知
 @Before("com.example.demo.aspect.AspectDemo.pt()")
 public void doBefore() {
 log.info("执⾏ AspectDemo2 -&gt; Before ⽅法");
 }
}</code></pre> 
<h3 id="2.2%E9%80%9A%E7%9F%A5%EF%BC%88Advice%EF%BC%89">2.2<strong>通知（Advice）</strong></h3> 
<ul><li>通知包括前置通知、后置通知和环绕通知。 
  <ul><li>前置通知在 <code>doBefore()</code> 方法中定义，使用了 <code>@Before</code> 注解，在切点方法执行之前被调用。</li><li>后置通知在 <code>doAfter()</code> 方法中定义，使用了 <code>@After</code> 注解，在切点方法执行之后被调用。</li><li>环绕通知在 <code>doAround()</code> 方法中定义，使用了 <code>@Around</code> 注解，在切点方法执行前后都可以进行一些额外的处理。环绕通知方法的参数类型为 <code>ProceedingJoinPoint</code>，可以通过调用 <code>proceed()</code> 方法执行目标方法，并在执行前后进行其他操作。</li></ul></li></ul> 
<p>例如： </p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/82/3e/KJJx5oMx_o.png" width="769"></p> 
<p></p> 
<h3 id="2.3%E5%88%87%E2%BE%AF(Aspect)">2.3<span style="color:#1f2329;">切⾯(Aspect)</span></h3> 
<div> 
 <span style="color:#1f2329;">       注： 切⾯(Aspect) = 切点(Pointcut) + 通知(Advice) </span> 
</div> 
<div>
  就是整个代码全是切面的知识点 
</div> 
<div></div> 
<h3 id="2.4%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B">2.4通知类型</h3> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#1f2329;">Spring中AOP的通知类型有以下⼏种: </span> 
  </div> 
  <ul><li><span style="color:#1f2329;">@Around: 环绕通知, 此注解标注的通知⽅法在⽬标⽅法前, 后都被执⾏ </span></li><li><span style="color:#1f2329;">@Before: 前置通知, 此注解标注的通知⽅法在⽬标⽅法前被执⾏ </span></li><li><span style="color:#1f2329;">@After: 后置通知, 此注解标注的通知⽅法在⽬标⽅法后被执⾏, ⽆论是否有异常都会执⾏ </span></li><li><span style="color:#1f2329;">@AfterReturning: 返回后通知, 此注解标注的通知⽅法在⽬标⽅法后被执⾏, 有异常不会执⾏ </span></li><li><span style="color:#1f2329;">@AfterThrowing: 异常后通知, 此注解标注的通知⽅法发⽣异常后执⾏</span></li></ul> 
 </blockquote> 
</div> 
<p>        前面五种，我们都可以通过之前代码看出，但是第五种是异常通知，<span style="color:#1f2329;">程序正常运⾏的情况下, </span><span style="color:#1f2329;">@AfterThrowing </span><span style="color:#1f2329;">标识的通知⽅法不会执⾏。但是如果发生异常了呢？什么会执行，上面不会执行呢？</span></p> 
<p></p> 
<ul><li> 
  <div> 
   <span style="color:#1f2329;">@AfterReturning </span> 
   <span style="color:#1f2329;">标识的通知⽅法不会执⾏， </span> 
   <span style="color:#1f2329;">@AfterThrowing </span> 
   <span style="color:#1f2329;">标识的通知⽅法执⾏了</span> 
  </div> </li><li> 
  <div> 
   <span style="color:#1456f0;"> </span> 
   <span style="color:#1f2329;">@Around </span> 
   <span style="color:#1f2329;">环绕通知中原始⽅法调⽤时有异常，通知中的环绕后的代码逻辑也不会在执⾏了(因为原始⽅法调⽤出异常了) </span> 
  </div> </li></ul> 
<p><img alt="" height="95" src="https://images2.imgbox.com/30/22/XQs9TrfV_o.png" width="829"></p> 
<h3 id="2.5%E5%88%87%E2%BE%AF%E4%BC%98%E5%85%88%E7%BA%A7%20%40Order">2.5<span style="color:#1f2329;">切⾯优先级 @Order </span></h3> 
<p>        <span style="color:#1f2329;">当我们在⼀个项⽬中, 定义了多个切⾯类时, 并且这些切⾯类的多个切⼊点都匹配到了同⼀个⽬标⽅法. 当⽬标⽅法运⾏的时候, 这些切⾯类中的通知⽅法都会执⾏, 那么这⼏个通知⽅法的执⾏顺序是什么样的呢? </span></p> 
<p>切面定义三个，分别为AspectDemo2、AspectDemo3、AspectDemo4，为了简易化，只写@Before和@After，而这里只展示一个代码，其他在修改一下类名即可：</p> 
<pre><code class="language-java">@Aspect // 定义切面
@Component
public class AspectDemo2 {
 @Pointcut("execution(* com.example.interview.Controller.UserController.*(..))")
 private void pt(){}
 // 前置通知通知
 @Before("pt()")
 public void doBefore() {
  System.out.println("执行了前置通知2");
 }

 // 后置通知
 @After("pt()")
 public void doAfter() {
  System.out.println("执行了后置通知2");
 }
}</code></pre> 
<p>UserControer代码：</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/getuser")
    public String getUser(){
        System.out.println("do getUser");
        return "get user";
    }

    @RequestMapping("/deluser")
    public String delUser(){
        System.out.println("do delUser");
        return "del user";
    }

}</code></pre> 
<p>访问对应的接口程序：<a href="http://localhost:8080/user/getuser" rel="nofollow" title="http://localhost:8080/user/getuser">http://localhost:8080/user/getuser</a></p> 
<p>运行结果如下图：</p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/41/af/ko2lqrx5_o.png" width="522"></p> 
<p>通过对比我们可以发现：<span style="color:#1f2329;">存在多个切⾯类时, 默认按照切⾯类的类名字⺟排序： </span></p> 
<ul><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">@Before </span><span style="color:#1f2329;">通知：字⺟排名靠前的先执⾏ </span></li><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">@After </span><span style="color:#1f2329;">通知：字⺟排名靠前的后执⾏ </span></li></ul> 
<blockquote> 
 <p><strong><span style="background-color:#ffd900;">问：如果我们需要指定某个切面先执行呢？</span></strong></p> 
 <p>答： <span style="color:#1f2329;">Spring 给我们提供了⼀个新的注解, 来控制这些切⾯通知的执⾏顺序: </span><span style="color:#1f2329;">@Order </span></p> 
</blockquote> 
<p>使用方式如下：</p> 
<p>我们在切面类AspectDemo2、AspectDemo3、AspectDemo4上分别加上注解：<span style="color:#4078f2;">@Order(3)、@Order(2)、</span><span style="color:#4078f2;">@Order(1).</span></p> 
<p><span style="color:#0d0016;">例如:</span></p> 
<pre><code class="language-java">@Aspect // 定义切面
@Component
@Order(1)
public class AspectDemo4 {
     //代码照旧
}</code></pre> 
<p> 访问对应的接口程序：<a href="http://localhost:8080/user/getuser" rel="nofollow" title="​​​​​​http://localhost:8080/user/getuser">​​​​​​http://localhost:8080/user/getuser</a></p> 
<p>运行结果： </p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/86/fa/42aU6b2k_o.png" width="489"></p> 
<blockquote> 
 <div> 
  <span style="color:#1f2329;">通过上述程序的运⾏结果, 得出结论: </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">@Order 注解标识的切⾯类, 执⾏顺序如下: </span> 
 </div> 
 <ul><li><span style="color:#1f2329;">@Before </span><span style="color:#1f2329;">通知：数字越⼩先执⾏ </span></li><li><span style="color:#1f2329;">@After </span><span style="color:#1f2329;">通知：数字越⼤先执⾏ </span></li></ul> 
 <div> 
  <span style="color:#1f2329;">@Order </span> 
  <span style="color:#1f2329;">控制切⾯的优先级, 先执⾏优先级较⾼的切⾯, 再执⾏优先级较低的切⾯, 最终执⾏⽬标⽅法. </span> 
 </div> 
</blockquote> 
<h3></h3> 
<h3 id="2.6%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.6切点表达式</h3> 
<blockquote> 
 <div> 
  <span style="color:#1f2329;">切点表达式常⻅有两种表达⽅式 </span> 
 </div> 
 <ol><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">execution(……)：根据⽅法的签名来匹配 </span></li><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">@annotation(……) ：根据注解匹配 </span></li></ol> 
</blockquote> 
<h4 id="2.6.1%C2%A0%40execution%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.6.1<span style="color:#0d0016;"> @</span><span style="color:#1f2329;">execution表达式</span></h4> 
<div> 
 <span style="color:#1f2329;">execution() 是最常⽤的切点表达式, ⽤来匹配⽅法, 语法为:</span> 
</div> 
<pre><code class="language-java"> execution(&lt;访问修饰符&gt; &lt;返回类型&gt; &lt;包名.类名.⽅法(⽅法参数)&gt; &lt;异常&gt;)</code></pre> 
<p><img alt="" height="168" src="https://images2.imgbox.com/3d/76/IITguVIh_o.png" width="834"></p> 
<p></p> 
<div> 
 <span style="color:#1f2329;">切点表达式⽀持通配符表达: </span> 
</div> 
<ol><li><strong><span style="color:#1f2329;"><span style="background-color:#ffd900;">* </span></span></strong><span style="color:#1f2329;">：匹配任意字符，只匹配⼀个元素(返回类型, 包, 类名, ⽅法或者⽅法参数)</span> 
  <ol><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">包名使⽤ </span><span style="color:#1f2329;">* </span><span style="color:#1f2329;">表⽰任意包(⼀层包使⽤⼀个*) </span></li><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">类名使⽤ </span><span style="color:#1f2329;">* </span><span style="color:#1f2329;">表⽰任意类 </span></li><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">返回值使⽤ </span><span style="color:#1f2329;">* </span><span style="color:#1f2329;">表⽰任意返回值类型 </span></li><li><span style="color:#1f2329;">⽅法名使⽤ </span><span style="color:#1f2329;">* </span><span style="color:#1f2329;">表⽰任意⽅法 </span></li><li><span style="color:#1f2329;">参数使⽤ </span><span style="color:#1f2329;">* </span><span style="color:#1f2329;">表⽰⼀个任意类型的参数 </span></li></ol></li><li><span style="color:#1f2329;"><span style="background-color:#ffd900;"><strong>.. </strong></span>:匹配多个连续的任意符号, 可以通配任意层级的包, 或任意类型, 任意个数的参数 </span> 
  <ul><li><span style="color:#1456f0;"> </span><span style="color:#1f2329;">使⽤ </span><span style="color:#1f2329;">.. </span><span style="color:#1f2329;">配置包名，标识此包以及此包下的所有⼦包</span></li><li><span style="color:#1f2329;">可以使⽤ </span><span style="color:#1f2329;">.. </span><span style="color:#1f2329;">配置参数，任意个任意类型的参数</span></li></ul></li></ol> 
<h4 id="2.6.2%40annotation%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.6.2<span style="color:#1f2329;">@annotation表达式</span></h4> 
<blockquote> 
 <div> 
  <span style="color:#1f2329;">       <span style="background-color:#ffd900;"> execution表达式更适⽤有规则的</span>, 如果我们要匹配多个⽆规则的⽅法呢, </span> 
 </div> 
 <div>
   问：如果我们 
  <span style="background-color:#ffd900;">匹配两个不同类的一个方法</span>，怎么操作呢？ 
 </div> 
 <div> 
  <span style="color:#1f2329;">我们可以借助⾃定义注解的⽅式以及另⼀种切点表达式 </span> 
  <span style="color:#1f2329;">@annotation </span> 
  <span style="color:#1f2329;">来描述这⼀类的切点</span> 
 </div> 
</blockquote> 
<p><strong>第一步准备测试方法：</strong></p> 
<pre><code class="language-java">@RequestMapping("/test")
@RestController
public class TestController {
     @RequestMapping("/t1")
     public String t1() {
         return "t1";
     }
    @RequestMapping("/t2")
     public boolean t2() {
         return true;
     }
}</code></pre> 
<pre><code class="language-java">@RequestMapping("/user")
@RestController
public class UserController {
     @RequestMapping("/u1")
     public String u1(){
         return "u1";
     }
     @RequestMapping("/u2")
     public String u2(){
         return "u2";
     }
}</code></pre> 
<p><strong>第二步自定义注解@MyAspect</strong></p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/5b/d0/8s3eB0pL_o.png" width="505"></p> 
<p>代码内容：</p> 
<pre><code class="language-java">import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAspect {

}</code></pre> 
<p>注解解释：</p> 
<div> 
 <strong><span style="color:#1f2329;">一.@Target </span><span style="color:#1f2329;">标识了 </span><span style="color:#1f2329;">Annotation </span><span style="color:#1f2329;">所修饰的对象范围, 即该注解可以⽤在什么地⽅. </span></strong> 
 <span style="color:#646a73;"><strong>常⽤取值</strong>: </span> 
</div> 
<ul><li><span style="color:#646a73;">ElementType.</span><span style="color:#646a73;"><em>TYPE</em></span><span style="color:#646a73;">: ⽤于描述类、接⼝(包括注解类型) 或enum声明 </span></li><li><span style="color:#646a73;">ElementType.METHOD: 描述⽅法 </span></li><li><span style="color:#646a73;">ElementType.PARAMETER: 描述参数 </span></li><li><span style="color:#646a73;"><em>ElementType.</em></span><span style="color:#646a73;">TYPE_USE</span><span style="color:#646a73;"><em>: 可以标注任意类型 </em></span></li></ul> 
<div> 
 <strong><span style="color:#1f2329;">二.</span><span style="color:#1456f0;"> </span><span style="color:#1f2329;">@Retention 指Annotation被保留的时间⻓短, 标明注解的⽣命周期，</span><span style="color:#646a73;">@Retention 的取值有三种: </span></strong> 
</div> 
<ul><li><span style="color:#646a73;">RetentionPolicy.SOURCE：表⽰注解仅存在于源代码中, 编译成字节码后会被丢弃. 这意味着</span><span style="color:#646a73;">在运⾏时⽆法获取到该注解的信息, 只能在编译时使⽤. ⽐如 </span><span style="color:#646a73;">@SuppressWarnings </span><span style="color:#646a73;">, 以及 </span><span style="color:#646a73;">lombok提供的注解 </span><span style="color:#646a73;">@Data </span><span style="color:#646a73;">, </span><span style="color:#646a73;">@Slf4j </span></li><li><span style="color:#646a73;">RetentionPolicy.CLASS：编译时注解. 表⽰注解存在于源代码和字节码中, 但在运⾏时会被丢</span><span style="color:#646a73;">弃. 这意味着在编译时和字节码中可以通过反射获取到该注解的信息, 但在实际运⾏时⽆法获 </span><span style="color:#646a73;">取. 通常⽤于⼀些框架和⼯具的注解. </span></li><li><span style="color:#646a73;">RetentionPolicy.RUNTIME：运⾏时注解. 表⽰注解存在于源代码, 字节码和运⾏时中. 这意味</span><span style="color:#646a73;">着在编译时, 字节码中和实际运⾏时都可以通过反射获取到该注解的信息. 通常⽤于⼀些需要 </span><span style="color:#646a73;">在运⾏时处理的注解, 如Spring的 </span><span style="color:#646a73;">@Controller @ResponseBody </span></li></ul> 
<p><strong>第三步：切面类定义，将</strong><span style="color:#0d0016;">@</span><span style="color:#1f2329;">execution修改为@annotation</span>  ，但是目标源为自定义的<strong>注解@MyAspect</strong></p> 
<pre><code class="language-java">@Slf4j
@Component
@Aspect
public class MyAspectDemo {
     //前置通知
     @Before("@annotation(com.example.demo.aspect.MyAspect)")
     public void before(){
         log.info("MyAspect -&gt; before ...");
     }
     //后置通知
    @After("@annotation(com.example.demo.aspect.MyAspect)")
     public void after(){
         log.info("MyAspect -&gt; after ...");
     }
}</code></pre> 
<p><strong>第四步：在测试方法当中添加自定义的注解--@MyAspect</strong></p> 
<pre><code class="language-java">@MyAspect
@RequestMapping("/t1")
public String t1() {
 return "t1";
}

@MyAspect
@RequestMapping("/u1")
public String u1(){
 return "u1";
}</code></pre> 
<p><strong>第五步，访问</strong></p> 
<div> 
 <span style="color:#336df4;">http://127.0.0.1:8080/test/t1, </span> 
 <span style="color:#1f2329;">切⾯通知执⾏ </span> 
</div> 
<div> 
 <span style="color:#336df4;">http://127.0.0.1:8080/user/u1 </span> 
 <span style="color:#1f2329;">, 切⾯通知执⾏. </span> 
</div> 
<div> 
 <span style="color:#1f2329;">未添加注解：</span> 
</div> 
<div> 
 <span style="color:#336df4;">http://127.0.0.1:8080/test/t2, </span> 
 <span style="color:#1f2329;">切⾯未通知执⾏ </span> 
</div> 
<div> 
 <span style="color:#336df4;">http://127.0.0.1:8080/user/u2</span> 
 <span style="color:#1f2329;">, 切⾯未通知执⾏.</span> 
</div> 
<p></p> 
<p></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>        Spring AOP（Aspect-Oriented Programming，面向切面编程）是 Spring 框架中的一个模块，用于实现横切关注点的模块化开发。<strong>代理</strong>是 Spring AOP 实现的一种方式。</p> 
<p>        在 Spring AOP 中，<span style="background-color:#ffd900;">代理是实现切面的一种方式之一</span>。通过代理，Spring AOP 可以在目标对象的方法执行前、执行后或抛出异常时，执行额外的逻辑（如日志记录、性能监控、事务管理等）。Spring AOP 使用代理机制来实现横切关注点的织入。 </p> 
<p>Spring AOP 实现代理的方式有两种：</p> 
<ol><li> <p><strong>基于 JDK 动态代理：</strong> 如果目标对象实现了至少一个接口，Spring AOP 就会使用 JDK 动态代理来为目标对象创建代理。在运行时，Spring AOP 会动态生成一个实现了目标对象所有接口的代理对象，并在代理对象的方法中织入切面逻辑。</p> </li><li> <p><strong>基于 CGLIB 代理：</strong> 如果目标对象没有实现任何接口，Spring AOP 就会使用 CGLIB（Code Generation Library）来为目标对象创建代理。CGLIB 使用字节码生成技术，在运行时生成目标对象的子类，并重写其中的方法来织入切面逻辑。</p> </li></ol> 
<p>详细见此章：<a href="http://t.csdnimg.cn/iAZZG" rel="nofollow" title="http://t.csdnimg.cn/iAZZG">http://t.csdnimg.cn/iAZZG</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/501361e08e92390d631070c6684c001f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对比chatgpt和文心一言的优缺点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fa227c5a3fe76f87c006f64074d378c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac OS系统中Beyond Compare 4破解方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>