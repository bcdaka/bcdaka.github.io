<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言：函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1a129f409a21d96a07811b65d3bf26d8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言：函数">
  <meta property="og:description" content="创作不易，友友们给个三连吧！！ 一、函数的概念 数学中我们见过函数的概念，例如y=kx&#43;b，k和b都是常数，给任意一个x就可以得到y
而C语言也引入了函数（function）这个概念，C语言中的函数就是一个完成某项特定任务的一小段代码。而这段代码有自己的特殊写法和调用方法。
因为C语言的程序是由无数个小的函数组合而成的，所以我们也把函数叫做子程序。
也就是说：一个大的计算任务可以分解成若干个小任务（函数）来完成，而C语言作为一个面向过程的语言，每个函数的设置都是为了完成某些特定的任务，并且也可以在工程中是可以重复使用的，因此也提高了开发效率。
综上,我们可以简单总结出函数的两个好处：
1、可以将一个大型的任务拆分成多个小任务，也方便程序员之间的协作。
2、函数本身是为了实现工程中的某个特定功能的，而该功能有些时候可能会使用多次，所以函数封装之后的重复使用可以有效提高开发效率。
而在C语言中存在这样两种类型的函数：
库函数：现成的，可以直接使用的函数
自定义函数：根据实际需要自己设计的函数
二、库函数 2.1 标准库和头文件 1、C语言只是规定了使用的语法规则
2、但C语言不提供库函数的
3、不过C语言的国际标准ANSI C规定了一些库函数的各种信息
比如说scanf：名字，参数，返回类型，函数的功能…………
4、而C语言的编译器厂商根据这些规定来实现这些函数
比如微软——MSVC——微软的团队就实现对应的库函数
苹果——clang——苹果的团队就实现对应的库函数
5、库函数实现后，厂商们将这些库函数的具体实现隐藏起来，导入静态库，并将这些库函数根据功能的划分在不同的头文件中进行的声明，使得我们程序员可以通过对应的头文件去直接使用相应的库函数。
比如我们想要使用printf、scanf，就要通过头文件&lt;stdio.h&gt;（标准输入、标准输出有关库函数的头文件），这里面有这俩函数的声明。
6、库函数在编译器的标准库中，可以直接使用，所以不需要程序员自己去实现，大大提高了开发效率，同时库函数的实现往往是公司的一个团队一起完成的，所以基本上封装得很好，库函数的质量和执行效率都是更有保证的，所以我们能使用库函数的时候就尽量使用库函数，不能用库函数解决问题的时候才会去根据自己的需求创建自定义函数。
7、因为不同编译器的团队不同，所以不同编译器的库函数的实现细节可能略有差异，但因为都是根据国际标准去实现的，所以使用起来基本没有什么感觉，在有些编译器中可能会封装得更好，但是绝对不会低于国际标准。
比如memcpy函数在C语言标准中规定的是拷贝空间不重叠的内存，而memmove函数在C语言中规定的是拷贝空间重叠的内存。但是在vs2022中，memcpy也可以做到拷贝空间重叠的内存，但是在其他编译器可能就不一定了，所以我们使用的时候也要尽量根据标准去使用。
2.2 库函数的使用方法 库函数有非常多，要慢慢去学习，逐个击破。
库函数相关头⽂件：https://zh.cppreference.com/w/c/header
C/C&#43;&#43;官⽅的链接：https://zh.cppreference.com/w/c/header
cplusplus.com：https://legacy.cplusplus.com/reference/clibrary/
比如sqrt
double sqrt (double x); sqrt是函数名
x是函数的参数，表示调用函数需要传递一个double类型的值
double是返回值类型，表示函数计算的结果是double类型的值
功能：Compute square root 计算平⽅根
square root of x 返回平方根
头文件：&lt;cmath&gt;/&lt;math.h&gt;
2.3 库函数文档的一般格式 1. 函数原型
2. 函数功能介绍
3. 参数和返回类型说明
4. 代码举例
5. 代码输出
6. 相关知识链接
三、自定义函数 相比库函数，其实自定义函数更加重要，因为库函数远远不能满足我们的需求，而自定义函数使得我们写代码更具有创造性。
ret_type fun_name(形式参数) { } ret_type是函数的返回类型：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-07T18:21:27+08:00">
    <meta property="article:modified_time" content="2024-02-07T18:21:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言：函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="211" src="https://images2.imgbox.com/35/03/UZKfzYFe_o.gif" width="412"></h2> 
<p>                                             <strong>    创作不易，友友们给个三连吧！！ </strong></p> 
<h2>一、函数的概念</h2> 
<p>数学中我们见过函数的概念，例如y=kx+b，k和b都是常数，给任意一个x就可以得到y</p> 
<p>         而C语言也引入了函数（function）这个概念，<strong>C语言中的函数就是一个<span style="color:#fe2c24;">完成某项特定任务</span>的<span style="color:#fe2c24;">一小段代码</span></strong>。而这段代码有自己的特殊写法和调用方法。</p> 
<p>         因为<strong>C语言的程序是由无数个小的函数组合而成</strong>的，所以我们也把函数叫做<strong>子程序。</strong></p> 
<p><strong>        </strong> 也就是说：一个大的计算任务可以分解成若干个小任务（函数）来完成，而C语言作为一个面向过程的语言，<strong>每个函数的设置都是为了完成某些特定的任务，并且也可以在工程中是可以重复使用的，因此也提高了开发效率</strong>。</p> 
<p>综上,我们可以简单总结出函数的两个好处：</p> 
<p>1、可以<strong>将一个大型的任务拆分成多个小任务</strong>，也方便程序员之间的协作。</p> 
<p>2、函数本身是为了实现工程中的某个特定功能的，而该功能有些时候可能会使用多次，所以<strong>函数封装之后的重复使用可以有效提高开发效率。</strong></p> 
<p>而在C语言中存在这样两种类型的函数：</p> 
<p><strong>库函数</strong>：现成的，可以直接使用的函数</p> 
<p><strong>自定义函数</strong>：根据实际需要自己设计的函数</p> 
<h2>二、库函数</h2> 
<h3>2.1 标准库和头文件</h3> 
<p><strong>1、C语言只是规定了使用的语法规则</strong></p> 
<p><strong>2、但C语言不提供库函数的</strong></p> 
<p><strong>3、不过C语言的国际标准ANSI C规定了一些库函数的各种信息</strong></p> 
<p>比如说scanf：名字，参数，返回类型，函数的功能…………</p> 
<p><strong>4、而C语言的编译器厂商根据这些规定来实现这些函数</strong></p> 
<p>比如微软——MSVC——微软的团队就实现对应的库函数</p> 
<p>        苹果——clang——苹果的团队就实现对应的库函数</p> 
<p><strong>5、库函数实现后，厂商们将这些库函数的具体实现隐藏起来，导入静态库，并将这些库函数根据功能的划分在不同的头文件中进行的声明，使得我们程序员可以通过对应的头文件去直接使用相应的库函数。</strong></p> 
<p>比如我们想要使用printf、scanf，就要通过头文件&lt;stdio.h&gt;（标准输入、标准输出有关库函数的头文件），这里面有这俩函数的声明。</p> 
<p><strong>6、库函数在编译器的标准库中，可以直接使用，所以不需要程序员自己去实现，大大提高了开发效率，同时库函数的实现往往是公司的一个团队一起完成的，所以基本上封装得很好，库函数的质量和执行效率都是更有保证的，所以我们能使用库函数的时候就尽量使用库函数，不能用库函数解决问题的时候才会去根据自己的需求创建自定义函数。</strong></p> 
<p><strong>7、因为不同编译器的团队不同，所以不同编译器的库函数的实现细节可能略有差异，但因为都是根据国际标准去实现的，所以使用起来基本没有什么感觉，在有些编译器中可能会封装得更好，但是绝对不会低于国际标准。</strong></p> 
<p>比如memcpy函数在C语言标准中规定的是拷贝空间不重叠的内存，而memmove函数在C语言中规定的是拷贝空间重叠的内存。但是在vs2022中，memcpy也可以做到拷贝空间重叠的内存，但是在其他编译器可能就不一定了，所以我们使用的时候也要尽量根据标准去使用。</p> 
<h3>2.2 库函数的使用方法</h3> 
<p>库函数有非常多，要慢慢去学习，逐个击破。</p> 
<p><strong>库函数相关头⽂件：</strong><a class="link-info" href="https://zh.cppreference.com/w/c/header" rel="nofollow" title="https://zh.cppreference.com/w/c/header">https://zh.cppreference.com/w/c/header</a></p> 
<p><strong>C/C++官⽅的链接：<a class="link-info" href="https://zh.cppreference.com/w/c/header" rel="nofollow" title="https://zh.cppreference.com/w/c/header">https://zh.cppreference.com/w/c/header</a></strong></p> 
<p><strong>cplusplus.com</strong>：<a class="link-info" href="https://legacy.cplusplus.com/reference/clibrary/" rel="nofollow" title="https://legacy.cplusplus.com/reference/clibrary/">https://legacy.cplusplus.com/reference/clibrary/</a></p> 
<p>比如sqrt</p> 
<p><img alt="" height="855" src="https://images2.imgbox.com/97/01/F1Nbm1t0_o.png" width="937"></p> 
<pre><code class="language-cpp">double sqrt (double x);</code></pre> 
<p>sqrt是函数名</p> 
<p>x是函数的参数，表示调用函数需要传递一个double类型的值</p> 
<p> double是返回值类型，表示函数计算的结果是double类型的值</p> 
<p>功能：Compute square root 计算平⽅根</p> 
<p>            square root of x          返回平方根</p> 
<p>头文件：&lt;cmath&gt;/&lt;math.h&gt;</p> 
<h3>2.3 库函数文档的一般格式</h3> 
<p>1. 函数原型</p> 
<p>2. 函数功能介绍</p> 
<p>3. 参数和返回类型说明</p> 
<p>4. 代码举例</p> 
<p>5. 代码输出</p> 
<p>6. 相关知识链接</p> 
<h2 style="background-color:transparent;">三、自定义函数</h2> 
<p>相比库函数，其实自定义函数更加重要，因为库函数远远不能满足我们的需求，而自定义函数使得我们写代码更具有创造性。</p> 
<pre><code class="language-cpp">ret_type fun_name(形式参数)
{

}
</code></pre> 
<p><strong>ret_type是函数的返回类型：</strong></p> 
<p>1、函数的返回类型可以是char、int、short、double……这些内置类型，也可以是自定义类型</p> 
<p>2、函数的返回类型也可以是void，void的意思是函数不需要返回值，也不需要返回值</p> 
<p><strong>注：即使我们不需要返回值，我们也要写void，不能省略，因为返回类型如果不写，默认的返回类型是int！！</strong></p> 
<pre><code class="language-cpp">test()
{
	int a = 0;
	printf("%d ", a);
}
int main()
{
	int a = test();
	printf("%d ", a);
}</code></pre> 
<blockquote> 
 <p>运行结果：0 2  </p> 
</blockquote> 
<p>3、函数需不需要返回值是根据实际情况来设计的</p> 
<p><strong>fun_name是函数名：</strong></p> 
<p>函数名是为了⽅便使⽤函数；就像⼈的名字⼀样，有了名字⽅便称呼，函数有了名字⽅便调⽤，所以函数名尽量要根据函数的功能起的有意义。比如说该函数的功能是实现加法，我们就起名Add</p> 
<p><strong>括号里放的是形式参数</strong></p> 
<p>1、函数的参数类型可以是char、int、short、double……这些内置类型，也可以是自定义类型</p> 
<p>2、函数的参数如果是0个，也就是不需要参数，函数的参数类型可以写成void，void在这里表示函数没有参数，也不需要参数！！</p> 
<p><strong>注：如果我们不需要参数，括号里也没有写void：</strong></p> 
<pre><code class="language-cpp">void test()
{
	int a = 0;
	printf("%d ", a);
}
int main()
{
	test(1);
	test(1,2);
	test(1,2,3);
}</code></pre> 
<blockquote> 
 <p>运行结果0 0 0  </p> 
</blockquote> 
<p>我们发现因为test没有形参，所以没有办法接收对应的值，所以test不管传什么结果都是一样的，但是我们的test函数设计的时候就是不需要参数，这样子去使用显然不合适。</p> 
<p><strong> 如果我们在括号里写上void：</strong></p> 
<pre><code class="language-cpp">void test(void)
{
	int a = 0;
	printf("%d ", a);
}
int main()
{
	test(1);
	test(1,2);
	test(1,2,3);
}</code></pre> 
<p> 虽然最后的运行结果还是一样的，但是void会明确告诉编译器这个函数不需要传参，所以如果你在调用的传了参数，就会有警告</p> 
<p><img alt="" height="85" src="https://images2.imgbox.com/8e/78/nq8ZgPba_o.png" width="1200"></p> 
<p>3、函数的参数可以有0个，也可以有多个，这个根据实际的需要来确定。</p> 
<p><strong>{ }括起来的就是函数体，也就是函数的定义（具体实现）</strong></p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/fd/57/dE48V1x7_o.png" width="631"></p> 
<p>      函数的设计有点像这个工厂，参数是原材料，函数体里是材料的加工过程，而计算结果相当于产品。 </p> 
<p><strong>     为什么有的函数在调用时明明不需要传参，却还要写括号？？因为（ ）本质上就是一个函数调用操作符！！！</strong></p> 
<h2 style="background-color:transparent;">四、形参和实参</h2> 
<pre><code class="language-cpp">int Add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 0;
	int b = 0;
	//输⼊
	scanf("%d%d", &amp;a, &amp;b);
	//调⽤加法函数，完成a和b的相加
	//求和的结果放在r中
	int r = Add(a, b);
	//输出
	printf("%d\n", r);
	return 0;
}</code></pre> 
<p>调用Add函数传的参数a和b我们叫做实参，<strong>实参就是真实传递给函数的参数</strong> </p> 
<p>定义Add函数中的x和y就是形参，为什么叫做形参呢？实际上我们如果<strong>只是定义了Add函数而不去调用的话，Add函数的x和y只是形式上存在，并不会向内存申请空间，不会真实存在，所以叫形式参数。</strong></p> 
<p>形参只要在函数调用的过程中为了存放实参传递过来的值，才向内存申请空间，这个过程就是<strong>形参的实例化。</strong></p> 
<p>实参是传递给形参的，他们之间是有联系的的，但是形参和实参是在各自独立的空间！！</p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/ac/64/szf8oJDh_o.png" width="999"></p> 
<p><strong>所以形参只是实参的一份临时拷贝 ，改变形参的值并不会影响实参！！</strong></p> 
<p><strong>具体的过程可以参考博主的文章：</strong><a href="https://blog.csdn.net/weixin_51142926/article/details/135554399?spm=1001.2014.3001.5501" title="C语言：底层剖析——函数栈帧的创建和销毁-CSDN博客">C语言：底层剖析——函数栈帧的创建和销毁-CSDN博客</a></p> 
<h2 style="background-color:transparent;">五、数组充当函数参数</h2> 
<p>有些时候我们需要将数组作为参数传递给函数，在函数内部进行操作。</p> 
<p>⽐如：写⼀个函数对将⼀个整型数组的内容，全部置为-1，再写⼀个函数打印数组的内容。 简单思考⼀下，基本的形式应该是这样的：</p> 
<pre><code class="language-cpp">int main()
{
 int arr[] = {1,2,3,4,5,6,7,8,9,10};
 set_arr();//设置数组内容为-1
 print_arr();//打印数组内容
 return 0;
}
</code></pre> 
<p>      这⾥的set_arr函数要能够对数组内容进⾏设置，就得把数组作为参数传递给函数，同时函数内部在设 置数组每个元素的时候，也得遍历数组，需要知道数组的元素个数。所以我们需要给set_arr传递2个参 数，<strong>⼀个是数组，另外⼀个是数组的元素个数</strong>。仔细分析print_arr也是⼀样的，只有拿到了数组和元 素个数，才能遍历打印数组的每个元素。</p> 
<pre><code class="language-cpp">void set_arr(int arr[], int sz)
{
 int i = 0;
 for(i=0; i&lt;sz; i++)
 {
 arr[i] = -1;
 }
}
void print_arr(int arr[], int sz)
{
 int i = 0;
 for(i=0; i&lt;sz; i++)
 {
 printf("%d ", arr[i]);
 }
 printf("\n");
}</code></pre> 
<p><strong>数组传参的重要知识点： </strong></p> 
<p><strong>1、函数的实参是数组，形参也可以写成数组的形式</strong></p> 
<p><strong>2、形参如果是一维数组，数组大小可以省略不写</strong></p> 
<p><strong>3、形参如果是二维数组，行可以省略，但列不能省略</strong></p> 
<p><span style="color:#fe2c24;"><strong>4、数组传参，形参是不会创建新的数组的，因为形参和实参操作的数组就是同一个数组！！</strong></span></p> 
<h2 style="background-color:transparent;">六、return语句</h2> 
<p>1、return后边可以是⼀个数值，也可以是⼀个表达式，如果是表达式则先执⾏表达式，再返回表达式的结果。</p> 
<pre><code class="language-cpp">int Add(int x, int y)
{
	return x+y;
}
int main()
{
	int a = 0;
	int b = 0;
	//输⼊
	scanf("%d%d", &amp;a, &amp;b);
	//调⽤加法函数，完成a和b的相加
	//求和的结果放在r中
	int r = Add(a, b);
	//输出
	printf("%d\n", r);
	return 0;
}
</code></pre> 
<p>2、return后边也可以什么都没有，直接写return; 这种写法适合函数返回类型是void的情况。</p> 
<pre><code class="language-cpp">void print(int arr[], int n)
{
	if (n &lt; 1)
		return;//因为n传小于1的数没有意义
	for (int i = 0; i &lt; n; i++)
		printf("%d ", arr[i]);
}</code></pre> 
<p>3、return返回的值和函数返回类型不⼀致，系统会⾃动将返回的值隐式转换为函数的返回类型。</p> 
<pre><code class="language-cpp">int test()
{
	return 3.5;
}
int main()
{
	int a = test();
	printf("%d", a);
}</code></pre> 
<blockquote> 
 <p>输出结果：3 </p> 
</blockquote> 
<p>4、return语句执⾏后，函数就彻底返回，后边的代码不再执⾏。</p> 
<pre><code class="language-cpp">void print(int arr[], int n)
{
	if (n &lt; 1)
		return;
	for (int i = 0; i &lt; n; i++)
		printf("%d ", arr[i]);
}
int main()
{
	int a[10] = { 1,2,3,4,5,6,7,8,9,10 };
	print(a, 0);
}</code></pre> 
<blockquote> 
 <p>什么也没输出，因为传进去的n等于0，直接返回了。 </p> 
</blockquote> 
<p>5、如果函数中存在if等分⽀的语句，则要保证每种情况下都有return返回，否则会出现编译错误。</p> 
<pre><code class="language-cpp">//如果是奇数返回1，是偶数返回0
int test()
{
	int n = 0;
	scanf("%d", &amp;n);
	if (n % 2 == 1)
	return 1;
}</code></pre> 
<blockquote> 
 <p> 这样写是有问题的，因为没有考虑是偶数的时候应该返回什么</p> 
</blockquote> 
<pre><code class="language-cpp">int test()
{
	int n = 0;
	scanf("%d", &amp;n);
	if (n % 2 == 1)
	return 1;
	else
	return 0;
}</code></pre> 
<h2>七、嵌套访问</h2> 
<p>       嵌套调⽤就是函数之间的互相调⽤，每个函数就⾏⼀个乐⾼零件，正是因为多个乐⾼的零件互相⽆缝 的配合才能搭建出精美的乐⾼玩具，也正是因为函数之间有效的互相调⽤，最后写出来了相对⼤型的程序。</p> 
<pre><code class="language-cpp">int is_leap_year(int y)
{
 if(((y%4==0)&amp;&amp;(y%100!=0))||(y%400==0))
 return 1;
 else
 return 0;
}
int get_days_of_month(int y, int m)
{
 int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 int day = days[m];
 if (is_leap_year(y) &amp;&amp; m == 2)
 day += 1;
 
 return day;
}
int main()
{
 int y = 0;
 int m = 0;
 scanf("%d %d", &amp;y, &amp;m);
 int d = get_days_of_month(y, m);
 printf("%d\n", d);
 return 0;
}</code></pre> 
<p>这⼀段代码，完成了⼀个独⽴的功能。代码中反应了不少的函数调⽤：</p> 
<p>• main 函数调⽤ scanf 、 printf 、 get_days_of_month</p> 
<p>• get_days_of_month 函数调⽤ is_leap_year</p> 
<p><strong>未来的稍微大⼀些代码都是函数之间的嵌套调用，但是函数是不能嵌套定义的。 </strong></p> 
<h2>八、链式访问</h2> 
<p>       所谓链式访问就是将⼀个函数的返回值作为另外⼀个函数的参数，像链条⼀样将函数串起来就是函数的链式访问。</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
 printf("%d\n", strlen("abcdef"));//链式访问
 return 0;
}</code></pre> 
<blockquote> 
 <p> strlen的返回值作为printf的参数</p> 
</blockquote> 
<p>下面有一段有趣的代码，我们来探究一下他的执行结果</p> 
<pre><code class="language-cpp">int main()
{
 printf("%d", printf("%d", printf("%d", 43)));
 return 0;
}</code></pre> 
<p> <strong>printf函数返回的是打印在屏幕上的字符的个数。</strong></p> 
<p>上⾯的例⼦中，我们就第⼀个printf打印的是第⼆个printf的返回值，第⼆个printf打印的是第三个 printf的返回值。</p> 
<p>第三个printf打印43，在屏幕上打印2个字符，再返回2</p> 
<p>第⼆个printf打印2，  在屏幕上打印1个字符，再放回1</p> 
<p>第⼀个printf打印1      所以屏幕上最终打印：4321</p> 
<h2>九、函数的声明和定义</h2> 
<h3>9.1 单个文件</h3> 
<p>       一般我们习惯将main函数需要调用的函数写在main函数的前面，但是在以后有些大型工程的情况下避免不了函数的相互之间调用，这个时候就不得不把有些函数写在下面了！！而定义写在下面然后去调用的话编译器是会报错的</p> 
<p>         因为编译器在对代码进行编译的时候是从第一行开始扫描的，如果我们在main函数中要调用的函数的定义写在main函数的下面，那么当编译时扫到这里的时候并不认识该调用函数，就会直接报错，为了避免这种情况，我们就需要进行<strong>函数声明</strong></p> 
<p><strong>函数声明的作用就是告诉编译器，这个函数是被定义过的，虽然编译器看不到他的实现，但是至少让编译器认识这个函数，在扫描到他被调用的时候就不会报错！！</strong></p> 
<pre><code class="language-cpp">int is_leap_year(int y)；//函数声明
int main()
{
 int y = 0;
 scanf("%d", &amp;y);
 int r = is_leap_year(y);
 if(r == 1)
 printf("闰年\n");
 else
 printf("⾮闰年\n");
 return 0;
}
//判断⼀年是不是闰年
int is_leap_year(int y)
{
 if(((y%4==0)&amp;&amp;(y%100!=0)) || (y%400==0))
 return 1;
 else
 return 0;
}</code></pre> 
<p>函数声明：</p> 
<pre><code class="language-cpp">int is_leap_year(int y)；</code></pre> 
<p>函数定义：</p> 
<pre><code class="language-cpp">int is_leap_year(int y)
{
 if(((y%4==0)&amp;&amp;(y%100!=0)) || (y%400==0))
 return 1;
 else
 return 0;
}</code></pre> 
<p>函数调用：</p> 
<pre><code class="language-cpp">int r = is_leap_year(y);
</code></pre> 
<p>所以</p> 
<p>1、函数的调用一定要先声明后使用！ </p> 
<p>2、函数的定义本身也是一种特殊的声明，所以如果函数定义放在调用之前也是可以的。</p> 
<h3>9.2 多个文件</h3> 
<p>       一般来说，以后面对大项目的时候，代码可能会比较多，我们不会把代码放在一个文件里，往往会根据程序的功能，将代码拆分到多个文件中。</p> 
<p><strong>好处：</strong></p> 
<p>1、逻辑清晰</p> 
<p>2、方便协作</p> 
<p>3、方便代码的隐藏（想让别人使用，但是不想让别人看到里面的源码实现）</p> 
<p><strong>一般情况下，函数的声明、类型的声明放在头文件（.h）中，函数的实现是放在源文件（.c）中的，当我们需要去使用这些函数的时候，包含我们自定义的头文件即可！！</strong></p> 
<p>add.c（add函数的实现）</p> 
<pre><code class="language-cpp">//函数的定义
int Add(int x, int y)
{
 return x+y;
}</code></pre> 
<p>add.h（add函数的声明）</p> 
<pre><code class="language-cpp">//函数的声明
int Add(int x, int y);</code></pre> 
<p> test.c(测试)</p> 
<pre><code class="language-cpp">int main()
{
 int a = 10;
 int b = 20;
//函数调⽤
 int c = Add(a, b);
 printf("%d\n", c);
 return 0;
}
</code></pre> 
<h2>十、static和extern（重点）</h2> 
<p><strong>static 和 extern 都是C语⾔中的关键字。</strong></p> 
<p>static是静态的意思，可以⽤来：</p> 
<p>• 修饰局部变量</p> 
<p>• 修饰全局变量</p> 
<p>• 修饰函数</p> 
<p>而extern是⽤来声明外部符号的。</p> 
<h3>10.1 extern</h3> 
<p>在一个文件中定义了变量和函数， 在其他文件中要使用它们， 可以有两种方式：</p> 
<p>1、使用头文件，然后声明它们，然后其他文件去包含头文件</p> 
<p>2、在其他文件中直接extern。</p> 
<p><strong>extern 是⽤来声明外部符号的，如果⼀个全局的符号在A文件中定义的，在B文件中想使用，就可以使 ⽤ extern 进⾏声明，然后使⽤。</strong></p> 
<h3>10.2 作用域和生命周期</h3> 
<p><strong>作⽤域（scope）是程序设计概念，通常来说，⼀段程序代码中所⽤到的名字并不总是有效（可⽤） 的，⽽限定这个名字的可⽤性的代码范围就是这个名字的作⽤域。</strong></p> 
<p>1. 局部变量的作⽤域是变量所在的局部范围。(在{  }内部)</p> 
<pre><code class="language-cpp">int main()
{
	int i = 0;
	int b = 20;

	for (i = 0; i &lt; 10; i++)
	{
		int a = 10;
		printf("b = %d\n", b);
	}
	printf("a = %d\n", a);//err
	printf("b = %d\n", b);
	return 0;
}</code></pre> 
<blockquote> 
 <p>     作用域可以直接看{ }，对于a来说，他的作用域就在for循环的{ }中，出了作用域就会被销毁，所以打印不了a，但是b的作用域在main函数的{ }中，所以可以打印b！ </p> 
</blockquote> 
<p>2. 全局变量的作⽤域是整个⼯程（项⽬）。（相当于共享单车，谁都可以用）</p> 
<pre><code class="language-cpp">int c = 100;//全局变量

void test()
{
	printf("c = %d\n", c);
}

int main()
{
	int i = 0;
	int b = 20;

	for (i = 0; i &lt; 10; i++)
	{
		int a = 10;
		printf("c = %d\n", c);
	}
	printf("c = %d\n", c);
	return 0;
}</code></pre> 
<blockquote> 
 <p> c作为全局变量，在任何地方都可以被使用</p> 
</blockquote> 
<p>⽣命周期指的是变量的创建(申请内存)到变量的销毁(收回内存)之间的⼀个时间段。</p> 
<p>1. 局部变量的⽣命周期是：进⼊作⽤域变量创建，⽣命周期开始，出作⽤域⽣命周期结束。     （出{  }，相关的变量就会被销毁）</p> 
<p>2. 全局变量的⽣命周期是：整个程序的⽣命周期。（相当于main函数的生命周期）</p> 
<p><img alt="" height="680" src="https://images2.imgbox.com/83/19/ufedz0lE_o.png" width="877"></p> 
<h3>10.3 static修饰局部变量</h3> 
<p>我们来分析下面2段代码</p> 
<pre><code class="language-cpp">//代码1
void test()
{
 int i = 0;
 i++;
 printf("%d ", i);
}
int main()
{
 int i = 0;
 for(i=0; i&lt;5; i++)
 {
 test();
 }
 return 0;
}
</code></pre> 
<blockquote> 
 <p>输出结果:1 1 1 1 1 </p> 
</blockquote> 
<pre><code class="language-cpp">void test ()
{
//static修饰局部变量
 static int i = 0;
 i++;
 printf("%d ", i);
}
int main()
{
 int i = 0;
 for(i=0; i&lt;5; i++)
 {
 test();
 }
 return 0;
}</code></pre> 
<blockquote> 
 <p> 输出结果:1 2 3 4 5 </p> 
</blockquote> 
<p> 代码1的test函数中的局部变量i是每次进⼊test函数先创建变量（⽣命周期开始）并赋值为0，然后 ++，再打印，出函数的时候变量⽣命周期将要结束（释放内存）。</p> 
<p>代码2中，我们从输出结果来看，i的值有累加的效果，其实 test函数中的i创建好后，出函数的时候是 不会销毁的，重新进⼊函数也就不会重新创建变量，直接上次累积的数值继续计算。</p> 
<p><strong>总结：static修饰局部变量，本质上影响了变量的存储类型，一个局部变量本来是存放在栈区的，但是被static修饰后就存放在静态区的，因为存储类型的变化，生命周期变长了，但是作用域不变。</strong></p> 
<p><strong>使用建议：未来一个局部变量出了函数后，我们还想保留他的值等到下次函数继续使用，就可以使用static修饰。</strong></p> 
<h3>10.4 static修饰全局变量</h3> 
<p>我们来分析下面2段代码：</p> 
<p>代码1：</p> 
<p>add.c</p> 
<pre><code class="language-cpp">int g_val = 2018;
</code></pre> 
<p> test.c</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
extern int g_val;
int main()
{
 printf("%d\n", g_val);
 return 0;
}</code></pre> 
<p>代码2： </p> 
<p>add.c</p> 
<pre><code class="language-cpp">static int g_val = 2018;</code></pre> 
<p> test.c</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
extern int g_val;
int main()
{
 printf("%d\n", g_val);
 return 0;
}</code></pre> 
<p><strong>代码1正常，代码2在编译的时候会出现链接性错误。 </strong></p> 
<p><strong>总结：</strong></p> 
<p><strong>1、全局变量是具有外部链接属性的</strong></p> 
<p><strong>2、全局变量被static修饰后，外部链接属性变成了内部链接属性，使得这个全局变量只能在自己所在的.c文件中使用了，其他文件即使声明了也用不了。相当于作用域变小了</strong></p> 
<p><strong>使用建议：如果我们只想让一个全局变量在所在的源文件内部使用，而不想被其他文件发现，就而已使用static修饰</strong></p> 
<h3>10.5 static修饰函数</h3> 
<p>我们来分析下面2段代码：</p> 
<p>代码1：</p> 
<p>add.c</p> 
<pre><code class="language-cpp">int Add(int x, int y)
{
 return x+y;
}</code></pre> 
<p>test.c</p> 
<pre><code class="language-cpp">extern int Add(int x, int y);
int main()
{
 printf("%d\n", Add(2, 3));
 return 0;
}</code></pre> 
<p>代码2： </p> 
<p>add.c</p> 
<pre><code class="language-cpp">static int Add(int x, int y)
{
 return x+y;
}</code></pre> 
<p> test.c</p> 
<pre><code class="language-cpp">extern int Add(int x, int y);
int main()
{
 printf("%d\n", Add(2, 3));
 return 0;
}</code></pre> 
<p>       其实 static 修饰函数和 static 修饰全局变量是⼀模⼀样的，⼀个函数在整个⼯程都可以使⽤， 被static修饰后，只能在本⽂件内部使⽤，其他⽂件⽆法正常的链接使⽤了。</p> 
<p><strong>总结：</strong></p> 
<p><strong>1、函数也是具有外部链接属性的</strong></p> 
<p><strong>2、函数被static修饰后，外部链接属性变成了内部链接属性，使得这个函数只能在自己所在的.c文件中使用了，其他文件即使声明了也不能用。</strong></p> 
<p><strong>使用建议：如果我们只想让一个函数在所在的源文件内部使用，而不想被其他文件使用，就而已使用static修饰</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5b/3f/PnwWJffi_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5363bd97686d13eb058198301e025ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言：进制转换以及原码、反码、补码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/707d2523cc73ba7f7714bf2fef81d06d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Matlab图像处理——基于小波变换的数字图像水印嵌入和提取算法（GUI界面）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>