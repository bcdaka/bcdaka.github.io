<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HR青睐的数据库热门考题——事务 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/01ed3872366b093bac96a1791e4bd81a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="HR青睐的数据库热门考题——事务">
  <meta property="og:description" content="本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 在上一篇MySQL数据库的文章中，我们提及HR喜欢考的 一个话题 就是：索引 。
我们讲解了
索引是什么？ 索引就是相当于书本的一种特殊的 目录 , 对于 特定的索引列 的查询能够加快 查询的速度
索引的使用特点 像 主键 ，unique ， 外键 会自带索引， 但不能通过 SQL 删除这些索引。 我们也可以通过 SQL 来创建 自身的索引 ，并且删除 自己创建 的索引
索引的不足 创建索引会占用 额外的内存空间 索引可能会加快，减慢，数据库的 增删改 操作的速度 。 索引底层的数据结构 底层是一颗 N叉的B&#43; 搜索树 B&#43; 的 特点 B&#43; 树的 优势 关于这些小伙伴们可以移步 HR眷恋的数据库高频考题之一 —— 索引 文章中。
而本篇文章中
我们核心讲解事务的概念和它最核心的四个特性
目录 事务的初识
事务的四大核心特性
隔离性需要解决的三大问题
不同隔离级别的特点
一. 事务的初始 在提及事务，和小伙伴们分享个场景">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T23:11:54+08:00">
    <meta property="article:modified_time" content="2024-06-01T23:11:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HR青睐的数据库热门考题——事务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本篇会加入个人的所谓<code>鱼式疯言</code></p> 
<p>❤️❤️❤️<code>鱼式疯言</code>:❤️❤️❤️此疯言非彼疯言</p> 
<p>而是理解过并总结出来通俗易懂的<mark>大白话</mark>,</p> 
<p>小编会尽可能的在每个概念后插入<code>鱼式疯言</code>,帮助大家理解的.</p> 
<p>🤭🤭🤭可能说的不是那么<code>严谨</code>.但小编初心是能让更多人能接受我们这个<code>概念</code> ！！！</p> 
<p><img src="https://images2.imgbox.com/3d/8d/kTpPjKWX_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_18"></a>前言</h2> 
<p>在上一篇MySQL数据库的文章中，我们提及HR喜欢考的 <strong>一个话题</strong> 就是：<code>索引</code> 。</p> 
<p>我们讲解了</p> 
<ul><li>索引是什么？</li></ul> 
<blockquote> 
 <p>索引就是相当于书本的一种特殊的 <code>目录</code> , 对于 <code>特定的索引列</code> 的查询能够加快 <code>查询的速度</code></p> 
</blockquote> 
<ul><li>索引的使用特点</li></ul> 
<blockquote> 
 <ol><li>像 <code>主键</code> ，<code>unique</code> ， <code> 外键</code> 会自带索引， 但不能通过 SQL 删除这些索引。</li></ol> 
</blockquote> 
<p>我们也可以通过 <code>SQL</code> 来创建 <mark>自身的索引</mark> ，并且删除 <mark>自己创建</mark> 的索引</p> 
<ul><li>索引的不足</li></ul> 
<blockquote> 
 <ol><li>创建索引会占用 <mark>额外的内存空间</mark></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="2"><li>索引可能会加快，减慢，数据库的 <code>增删改</code> 操作的速度 。</li></ol> 
</blockquote> 
<ul><li>索引底层的数据结构</li></ul> 
<blockquote> 
 <ol><li>底层是一颗 <mark>N叉的B+ 搜索树</mark></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="2"><li>B+ 的 <code>特点</code></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="3"><li>B+ 树的 <code> 优势</code></li></ol> 
</blockquote> 
<p>关于这些小伙伴们可以移步 <mark>HR眷恋的数据库高频考题之一 —— 索引</mark> 文章中。</p> 
<p>而本篇文章中</p> 
<p>我们核心讲解事务的概念和它最核心的四个特性</p> 
<h2><a id="_69"></a>目录</h2> 
<ol><li> <p>事务的初识</p> </li><li> <p>事务的四大核心特性</p> </li><li> <p>隔离性需要解决的三大问题</p> </li><li> <p>不同隔离级别的特点</p> </li></ol> 
<h2><a id="__83"></a>一. 事务的初始</h2> 
<p>在提及事务，和小伙伴们分享个场景</p> 
<p>假如 甲同学的数据库下 有 <code>1000</code> 元<br> 乙同学的数据库下有 <code>500</code> 元</p> 
<p>现在甲同学向乙同学买东西，需要转账 <code>500</code> 给他， 那么我们的数据库是怎么操作的？</p> 
<p>就需要先将甲同学的 <code>SQL语句 1</code> ： <mark>数据库先减去 500</mark></p> 
<p>然后再执行乙同学的 <code> SQL语句 2</code> ： <mark>数据库加上 500</mark> 。</p> 
<p>这样就完成了转账 😁 😁 😁</p> 
<p>但是，但是，但是，难免有时候会有意外发生的，当我们执行完 <mark>SQL语句 1</mark> 的时候，突然程序崩了或者主机断电了 ，<code>SQL 语句 2</code> 就被 <mark>终止执行</mark> 了 ， 那么最终的结果就变成了 <code>甲同学 500</code> ， <code>乙同学500</code> 这样的问题产生 。</p> 
<p>那么这样的问题该怎么解决呢 🤔 🤔 🤔 🤔 。</p> 
<p>于是我们就必须要借助事务的特性来解决上述问题 💥 💥 💥 💥</p> 
<h3><a id="1__111"></a>1. 事务的简介</h3> 
<p>对于上面的问题，我们要解决该问题的方法就是</p> 
<p>把上面的 <mark>两条语句</mark> 都打包成 <code>一个整体</code> ， 要不<strong>两条语句都执行</strong>，要不<strong>两条语句都不执行 。</strong> 这样的话我们就 <code>不会</code> 出现上述的问题 。</p> 
<blockquote> 
 <p>但 <code>注意哦</code> ，这里的 <em><strong>一条语句都不执行</strong></em> ，<mark>不是真不执行</mark> ，而是出现上述这样的问题时， 假如我们只执行了 <code>语句一</code> ， 而执行不了 <code>语句二</code> ， 数据库自身就会把 <mark>前面执行过</mark> 的所有语句都 <mark>还原，撤销回去</mark> ，就好像之前的语句都 <strong>没有执行过一样</strong> 。</p> 
</blockquote> 
<blockquote> 
 <p>而像这样我们把所有语句都当成 <code>一个整体</code> 时， <mark>成功执行所有语句</mark> ，或者执行了 <mark>一部分语句</mark> ，出现问题时会 <strong>自动还原</strong> ，相当于 <strong>一条语句都没有执行</strong> 的特性 我们就称之为 <em><strong>事务</strong></em></p> 
</blockquote> 
<p>而我们把这种 <mark>自动还原的特性</mark> 称之为 <code>回归机制</code> 。</p> 
<h3><a id="2__127"></a>2. 回滚机制的本质</h3> 
<p>对于<code>回滚机制</code> 本质</p> 
<blockquote> 
 <p>我们知道数据库是一种 <code>客户端-服务器结构</code> 的程序 , 我们 <code>平常的数据</code> 都在存储到 <code>硬盘</code> 上，但还有一个 <code>特殊的机制</code> ，叫做 <mark>日志机制</mark></p> 
</blockquote> 
<blockquote> 
 <p>当我们 <code>执行事务</code> 时，<mark>回滚日志</mark> 就会 <code>记录</code> 你每一次使用 <mark>SQL语句</mark> 对 <strong>数据的影响</strong> , 而这些 <mark>日志记录</mark> 都会存储到 <code>某个特定的文件</code> 中</p> 
</blockquote> 
<blockquote> 
 <p>当我们主机出现<code>程序崩溃</code> 时， 我们回滚日志保留了前面 <code>SQL语句执行</code> 的过程,当下次程序恢复正常时，就会 <mark>回撤这些执行</mark> 的语句，还原成 <code>原来的样子</code> .</p> 
</blockquote> 
<blockquote> 
 <p>当主机出现掉电的情况，我们回滚日志也会 <mark>保留前面 SQL语句执行的过程以及对数据的各种影响</mark> ， 当下次主机重新启动时， <code>回滚日志就会回退前面</code> 的过程，还原成 <code>执行前的样子</code> 。</p> 
</blockquote> 
<h2><a id="__148"></a>二. 事务的四大核心特性</h2> 
<p>事务有四大核心特性： <code>原子性</code>，<code>一致性</code>，<code>永久性</code>，<code>隔离性</code> 。</p> 
<h3><a id="1__154"></a>1. 原子性</h3> 
<p>其实，小编在 <mark>上一小标题</mark> 提及的，把所以的执行的语句都当成 <mark>一个整体</mark> ，有可能都执行成功，有可能都执行失败的特性，我们称之为原子性</p> 
<p>对于 <code>事务</code> 来说， 上述的特性是<strong>最核心也是事务最重要的特性</strong></p> 
<h3><a id="2___167"></a>2. 一致性</h3> 
<p>事务的 <code>一致性</code> 就是在说，在 <code>执行事务</code> 的过程， 不会在某一点出现和 <mark>事务本身</mark> <code>数据不合法</code> 的情况</p> 
<h3><a id="3__172"></a>3. 永久性</h3> 
<p>在 <mark>执行完一项事务</mark> 的过程中，对于 <strong>硬盘上修改的数据</strong> 是永久修改的，是不会出现 <mark>还原回去</mark> 的情况的。</p> 
<h3><a id="4__178"></a>4. 隔离性</h3> 
<p>关于隔离性，小编就就不得不提及和 <strong>隔离性相反</strong> 的概念： <code>并发性</code></p> 
<p>什么是并发性？？？</p> 
<p>我们知道数据库是一种 <mark>客户端-服务器结构</mark> 的程序，当多项事务在不同客户端执行到同一个服务器上时，并且同时 <mark>一起执行</mark> ， 没有 <strong>间隔执行</strong> 时，我们就称之为并发执行，而这种特性我们就称为 并发性 。</p> 
<blockquote> 
 <p>好比 小编和小伙伴们去餐馆吃饭， 小编点了一个辣椒炒肉，小伙伴们点了麻婆豆腐，红烧肉等…</p> 
</blockquote> 
<blockquote> 
 <p>餐馆的老板就会叫后厨中 <mark>多个师傅用多个锅同时炒菜</mark> ，一起做，这样就好比我们事务的 <mark>并发执行</mark> 。</p> 
</blockquote> 
<blockquote> 
 <p>这样的执行能 <code>减少时间</code> ，<code>提高效率</code></p> 
</blockquote> 
<blockquote> 
 <p>但是缺点就是 <mark>不够精细</mark>，会影响数据的准确性。</p> 
</blockquote> 
<p>而我们与之相反的就是 <strong>隔离性</strong> ，</p> 
<blockquote> 
 <p>而 <strong>隔离性</strong> 的出现就是为了解决 <mark>事务的并发执行可能出现的各种问题。</mark></p> 
</blockquote> 
<p>那么都有 <code>哪些问题</code> 呢？</p> 
<p>因为问题比较复杂，小编在下面的章节会详细讲解 💞 💞 💞 💞</p> 
<p>小伙伴们请移步下面</p> 
<p><img src="https://images2.imgbox.com/77/63/gXgYJk2O_o.png" alt=""><br> 内容</p> 
<h2><a id="__222"></a>三. 隔离性需要解决的三大问题</h2> 
<h3><a id="1__227"></a>1. 脏读</h3> 
<h4><a id="1__230"></a>&lt;1&gt;. 产生原因</h4> 
<p>对于这个<code>脏读</code> 的理解，给小伙伴分享个 <mark>故事</mark> 吧</p> 
<p>有一天，有一个小伙伴在小编写文章讲 <code>类和对象</code> 的时候，喵了一眼我当时正在写文章的内容， 上面写了 代码</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">String</span> name <span class="token punctuation">;</span>
      <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>,于是他就提前知道了我这篇文章要发布的内容，就高兴的离开了。</p> 
<p>当我刚要写完这篇类和对象的时候，</p> 
<p>为了严谨一点就把代码改成了</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">String</span> studentName<span class="token punctuation">;</span>
		<span class="token keyword">int</span> <span class="token class-name">Studentage</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>当这个小伙伴看到我发布后的文章时，就惊讶了，<strong>怎么内容不一样啊</strong> ，明明我看到的内容是 <mark>那个代码</mark> 啊，怎么就变成 <mark>这个代码</mark> 了 😭 😭 😭 😭<br> 读取的结果就 <code>不一样</code> 了 。</p> 
</blockquote> 
<blockquote> 
 <p>像上面这样当 <code>事务A</code> 正在执行的过程中，<code>事务B</code> 读取 <code>事务A</code> 的数据，事务B读取到了那时候 事务A <mark>还没提交</mark> 的数据 ， 当 <strong>事务A提交完成</strong> 之后，得到的事务A本身的数据和 <code>事务B读取到的数据</code> ，就会出现差异，而我们事务B读取到的数据，我们就称为 <code>脏数据</code> 。 而这个过程我们就称之为 <code>脏读</code> 过程。</p> 
</blockquote> 
<p>那么 <mark>脏读</mark> 该怎么解决呢？</p> 
<h4><a id="2__277"></a>&lt;2&gt;. 解决方案</h4> 
<p>我们就需要给 <code>写</code> 加上 <strong>锁</strong> 。</p> 
<p>什么意思 ？ ？ ？</p> 
<p>就是小编和小伙伴约定好， 当小编在写文章的时候，<strong>小伙伴不可以读</strong>，如果小伙伴们要学习该内容的话，只有当 <mark>小编真正发布本篇文章时</mark> ，才 <code>读取数据</code> 。</p> 
<blockquote> 
 <p>同步到我们事务上说就是当 <code>事务A</code> 在 <mark>未提交之前</mark> ，不允许 <code>事务B</code> 进行读取 ， 只有当 <strong>事务A 完全执行完并且提交之后</strong> , 事务 B 才能进行读取 。 这就是给 <strong>写</strong> 上锁 。</p> 
</blockquote> 
<h3><a id="_291"></a>鱼式疯言</h3> 
<blockquote> 
 <ol><li>这里的脏数据 <mark>不是说数据是脏</mark> ， 而是我们读到的 <strong>数据</strong> 是 <code>临时的</code> , <code>过时的</code> ，<code> 不准确的</code> ，我们才称为 <code>脏数据</code></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="2"><li><strong>给写上锁</strong> 的含义就是 ： 把 <code>写</code> 锁住保护起来，其他事务 <mark>不进行任何读</mark> 的操作。</li></ol> 
</blockquote> 
<h3><a id="2__300"></a>2. 不可重复读</h3> 
<h4><a id="1__303"></a>&lt;1&gt;. 产生原因</h4> 
<p>什么叫不可重复读呢？</p> 
<p>小编在这里还是分享一个故事给大家理解</p> 
<p>上面我们说到，当小编发布完文章之后，发现有些代码<strong>有点问题</strong>，但当小伙伴们正在读的文章的时候，我正在 <strong>修改文章</strong> ，我把 <code>原先文章中代码</code></p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">String</span> studentName<span class="token punctuation">;</span>
		<span class="token keyword">int</span> <span class="token class-name">Studentage</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>改成了</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span>  <span class="token class-name">String</span> studentName<span class="token punctuation">;</span>
		<span class="token keyword">public</span>  <span class="token keyword">int</span> <span class="token class-name">Studentage</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>这样小伙伴们读到的数据就从 <mark>原先的那段代码</mark> 变成了 <mark>另外一段代码</mark> ，就会导致数据 <code>读之前</code> 和 <code>读之后</code> 的数据出现 <code>不一致的情况</code>。 像这样的过程我们就叫做 <mark>不可重复读</mark></p> 
</blockquote> 
<blockquote> 
 <p>那么在我们的事务中的用语就是： 当 <code>事务A</code> 已经提交了，而 <code>事务B</code> 正在读取 <code>事务A</code> 的数据，此时 <code>事务C</code> 正在修改 <code>事务A</code> 的数据，就会导致 <strong>事务B</strong> 在 <mark>读取</mark> <strong>事务A</strong> 的数据的前后的 <em><strong>不一致</strong></em> ，从而造成 <mark>不可重复读</mark> 的问题。</p> 
</blockquote> 
<p>那么 <strong>面对这种问题</strong> 我们该怎么解决呢 ？ ？ ？</p> 
<h4><a id="2__343"></a>&lt;2&gt;. 解决方案</h4> 
<p>需要解决上述问题的方案就是</p> 
<blockquote> 
 <p><mark>给读上锁</mark></p> 
</blockquote> 
<blockquote> 
 <p>所以 我就和 <code>小伙伴们约定</code> ，当小伙伴们正在读 <code>我的文章</code> 时，我就 <strong>不修改文章中的那些代码</strong> ，当小伙伴们 <mark>读完之后</mark> ，我再去 <code>修改代码</code> ，以保证小伙伴们读的前后的 <mark>数据不变</mark> 。</p> 
</blockquote> 
<blockquote> 
 <p>那么 <code>回归到事务执行</code> 也一样，当 <mark>事务B</mark> 正在读 <mark>事务A</mark> 的数据时， <code>事务C</code> 就 <em><strong>不要修改</strong></em> <code>事务A</code> 的数据，当事务B读完数据之后，<mark>事务C</mark> 才去 <code>修改</code> <mark>事务 A</mark> 的内容 。 以此 来保证事务B读数据 <strong>前后相一致</strong> ， 所以我们把这样的 <mark>解决方案</mark> 称为 <strong>给读上锁</strong> 。</p> 
</blockquote> 
<h3><a id="_358"></a>鱼式疯言</h3> 
<blockquote> 
 <p><code>给读上锁</code> 的含义就是 ： 给读 <mark>上把锁保护起来</mark> ，让其他事务在读的过程中，进行不了修改的操作。</p> 
</blockquote> 
<h3><a id="3_367"></a>3.幻读</h3> 
<h4><a id="1__369"></a>&lt;1&gt;. 产生原因</h4> 
<blockquote> 
 <p><code>幻读</code> 本质上是我们的不可重复的 <mark>一种特殊情况</mark></p> 
</blockquote> 
<p>下面就让小编来细细讲解为什么 <strong>幻读</strong> 是我们 <strong>不可重复读</strong> 的一种 <code>特殊情况</code> 吧。</p> 
<p>小编还是以故事来开头吧</p> 
<p>话说上面我和小伙伴们都约定好，小伙伴读的时候小编 <code>不能修改</code> ， 但是呢？</p> 
<blockquote> 
 <p>小编突然在看我自己写的文章的时候，发现我自己写的有个 <mark>代码没有补充完整</mark></p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span>  <span class="token class-name">String</span> studentName<span class="token punctuation">;</span>
		<span class="token keyword">public</span>  <span class="token keyword">int</span> <span class="token class-name">Studentage</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>还 <strong>少了一些内容</strong>，于是就我在小伙伴们<code>读</code>的时候，就加上了一些代码</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span>  <span class="token class-name">String</span> studentName<span class="token punctuation">;</span>
		<span class="token keyword">public</span>  <span class="token keyword">int</span> <span class="token class-name">Studentage</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> teacher <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> classroom<span class="token punctuation">;</span>
	<span class="token keyword">public</span>  <span class="token class-name">String</span>  course<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>这样的话，当小伙伴 <code>读的时候</code> ，就会发现，我们 <mark>读的代码</mark> 怎么突然多了一个 <code>teacher</code> 的类呢？？？</p> 
</blockquote> 
<blockquote> 
 <p>是的，当小编在小伙伴们读的时候，就会发现读的内容 <mark>前后不一致</mark><br> 而这样的过程就是幻读。</p> 
</blockquote> 
<blockquote> 
 <p>而在我们<strong>事务的执行过程</strong>中，当一个事务A执行完成之后，<code>事务B</code> 正在读取 <code>事务A</code> 的数据，而此时 <code>事务C</code> 想要在 <code> 事务A</code> 中 <mark>增加(补充)数据</mark> ， 这时就会导致<code>事务B</code> 在读取的过程中造成 <strong>读取数据的不一致</strong> 。 这样的问题就称为： <mark>事务的幻读</mark> 。</p> 
</blockquote> 
<h3><a id="_425"></a>鱼式疯言</h3> 
<blockquote> 
 <p>所以我们不难发现，和我们上面的 <mark>不可重复读</mark> 一样的是，事务B 在读取 事务A前后 的数据是 <strong>不一致的</strong> 。 所以小编才说 <code>幻读</code> 本质上就是 <code>不可重复读</code> 的一种 <code>特殊情况</code></p> 
</blockquote> 
<h4><a id="2__432"></a>&lt;2&gt;. 解决方案</h4> 
<p>对于幻读来说，我们的解决方案就是三个字：</p> 
<p><code>串行化</code></p> 
<p>什么是串行化？？？</p> 
<p>我们还是根据上面的故事来诠释</p> 
<blockquote> 
 <p>于是我就和小伙伴又约定，当小伙伴 <code>正在读代码</code> 的时候，我就<mark>什么都不做</mark>，在那边摸鱼就可以啦，当小伙伴 <code>读完代码</code> 的时候，我就进行 <mark>代码的补充</mark> 。 这样就可以保证小伙伴们 <mark>读代码的前后</mark> 是 <code>一致相同</code> 的。</p> 
</blockquote> 
<blockquote> 
 <p>那么当 <code>事务B</code> 正在读已经提交完的 <code>事务A</code> 的时候，<code>事务C</code> 就不能对 <code>事务A</code> 进行 <mark>任何操作</mark> ，这样 <code>事务B</code> 在读取 <code>事务A</code> 的前后就能保证<mark>数据的一致性</mark> 。 而这种解决方案我们就称之为 <strong>事务的串行化</strong> 。</p> 
</blockquote> 
<h3><a id="_451"></a>鱼式疯言</h3> 
<p>说了那么多，到底什么事串行化呢？、</p> 
<blockquote> 
 <p>串行化的含义：不让多个事务 <mark>同时在服务器上执行</mark>， 而是让 <em><strong>一个事务执行完之后</strong></em> ， <em><strong>另一个事务才能继续</strong></em> 在 <code>服务器</code> 上执行。</p> 
</blockquote> 
<p>谈完这三种不同的并发执行产生的问题的 <code>产生原因</code> 和 <code>解决方案</code></p> 
<p>那么我们数据的隔离是以哪些方式来应对这些并发执行可能产生的问题的 🤔 🤔 🤔 🤔</p> 
<h2><a id="__468"></a>四. 不同隔离级别的特点</h2> 
<p>对应并发执行事务产生的不同问题， 数据库专门划分了 <code>四种不同的等级</code> 来应对这可能产生的 <mark>三个不同的问题</mark> 。</p> 
<h3><a id="1__475"></a>1. 隔离等级一</h3> 
<h4><a id="1__478"></a>&lt;1&gt;. 等级一简介</h4> 
<blockquote> 
 <p>隔离等级一称为 ： <strong>read uncommitted 读未提交</strong></p> 
</blockquote> 
<p>这个等级是最初始的等级， 并没有解决以上出现的三种问题， 就有可能会并发执行的过程产生 <code>脏读</code> ，<code>不可重复读</code> ， <code>幻读</code> 的问题。</p> 
<h4><a id="2__487"></a>&lt;2&gt;. 等级一的特点</h4> 
<blockquote> 
 <p>并发性 <code>最高</code>， 速度 <code>最快</code> ， 但是隔离性 <code>最低</code>，数据的<strong>准确性最差</strong>。</p> 
</blockquote> 
<h3><a id="2__494"></a>2. 等级二</h3> 
<h4><a id="1__497"></a>&lt;1&gt;. 等级二的简介</h4> 
<blockquote> 
 <p>隔离等级二称为 ： <strong>committed 读已提交</strong></p> 
</blockquote> 
<blockquote> 
 <p>这种等级是第二等级，有效的解决了我们事务的<strong>并发执行</strong> 过程产生的 <mark>脏读问题</mark> ，但并没有解决 <mark>不可重复读</mark> 和 <mark>幻读问题</mark> 。</p> 
</blockquote> 
<h4><a id="2__508"></a>&lt;2&gt;. 等级二的特点</h4> 
<p>读已提交的特点就是 ：</p> 
<blockquote> 
 <p>并发程度 <code>较高</code> ， 速度 <code>较快</code> ， 隔离程度 <code>较低</code> , 准确性 <code>较低</code> 。</p> 
</blockquote> 
<h3><a id="3__525"></a>3. 等级三</h3> 
<h4><a id="1__527"></a>&lt;1&gt;. 等级三简介</h4> 
<blockquote> 
 <p>隔离等级三 ： <strong>repeatable read 可重复读</strong></p> 
</blockquote> 
<blockquote> 
 <p>这个等级的主要是解决了我们 <strong>并发过程</strong> 的 <code>脏读</code> 和 <code>不可重复读</code> 的问题， 但是并没有解决我们的 <mark>幻读</mark> 的问题 。</p> 
</blockquote> 
<h4><a id="2__541"></a>&lt;2&gt;. 等级三特点</h4> 
<blockquote> 
 <p>并发程度 <code>较低</code> ， 速度 <code>较快</code> ，隔离程度就 <code>较高</code> ， 准确性 <code>较好</code> 。</p> 
</blockquote> 
<h3><a id="_548"></a>鱼式疯言</h3> 
<blockquote> 
 <p>其实我们 <mark>MySQL</mark> 中就是用的这 一套的 <strong>隔离等级</strong> 。</p> 
</blockquote> 
<h3><a id="4___555"></a>4. 等级四</h3> 
<h4><a id="1__558"></a>&lt;1&gt;. 等级四的简介</h4> 
<blockquote> 
 <p>等级四 ： <strong>Serializable 串行化</strong></p> 
</blockquote> 
<blockquote> 
 <p>隔离的最后的一个等级 <mark>串行化</mark>，成功的解决了事务 <strong>并发执行</strong> 过程中会的出现的 <code>脏读</code> ，<code> 不可重复读</code> 和 <code>幻读</code>。</p> 
</blockquote> 
<h4><a id="2__567"></a>&lt;2&gt;. 等级四的特点</h4> 
<p>并发程度 <code>最低</code>，速度 <code>最慢</code>，隔离性 <code>最高</code> ， 准确性也是 <code>最好的</code> 。</p> 
<h3><a id="_574"></a>鱼式疯言</h3> 
<ol><li>以上小编就可以总结出 ：</li></ol> 
<blockquote> 
 <p>并发程度和隔离程度是效果是 <code>互斥相反的</code>, 并发程度 <code>越高</code> ，隔离程度 <code>越低</code> 。 同时并发程度和我们执行速度是 <code>相同的</code> ，隔离程度和准确程度是 <code>相同的</code> ， 并发程度 <mark>越高</mark> ，执行速度 <mark>越快</mark>。</p> 
</blockquote> 
<ol start="2"><li>对于这四种不同的隔离等级</li></ol> 
<p>我们得根据不同的使用场景来确定我们是需要 <strong>并发程度高，速度快</strong> 的隔离等级， 还是需要隔离程度高，准确性高的隔离等级 。</p> 
<blockquote> 
 <p>好比我们 <mark>银行的事务执行</mark> ，就需要像隔离等级四这个<strong>隔离等级高，准确性好</strong>的。</p> 
</blockquote> 
<blockquote> 
 <p>而像我们平常的抖音，快手等短视频的 <code>几万几十万的点击率 </code> 就需要并发 <strong>程度高，速度快</strong> 的</p> 
</blockquote> 
<h2><a id="_598"></a>总结</h2> 
<ul><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 事务的初识 ： 我们介绍了事务的最根本的特性： 原子性是把 <code>多个SQL语句</code> 包装成一个整体，要不都执行，要不都不执行。</p> <p>从而理解事务本身就是以原子性执行的，</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 事务的四大核心特性 ： 有原子性，一致性，永久性，和隔离性。</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 隔离性需要解决的三大问题： 事务并发执行过程中有可能会产生： 脏读，不可重复读，幻读。</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 不同隔离级别的特点 ： 数据库构造了四种不同的等级来应对以上三种问题： 读未提交，读已提交， 重复读， 串行化 。</p> </li></ul> 
<blockquote> 
 <p>如果觉得小编写的还不错的咱可支持 <strong>三连</strong> 下 (定有回访哦) , 不妥当的咱请评论区 <strong>指正</strong></p> 
</blockquote> 
<blockquote> 
 <p>希望我的文章能给各位宝子们带来哪怕一点点的收获就是 小编创作 的最大 <strong>动力</strong> 💖 💖 💖</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e0/20/HIKRN6MF_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/845ebef0f4f6efa844b009d17a573043/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024蓝桥杯国赛C&#43;&#43;研究生组游记&#43;个人题解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05899385ba72c74a0787299f01003dc9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法思想总结：哈希表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>