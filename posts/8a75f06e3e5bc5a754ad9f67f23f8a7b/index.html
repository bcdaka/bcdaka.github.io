<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaSE--基础语法--继承和多态(第三期) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8a75f06e3e5bc5a754ad9f67f23f8a7b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JavaSE--基础语法--继承和多态(第三期)">
  <meta property="og:description" content="一.继承 1.1我们为什么需要继承? 首先，Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是 现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。
例如猫和狗：
public class Dog { String name; int age; float weight; public void eat(){ System.out.println(name&#43;&#34;正在吃饭！&#34;); } public void sleep(){ System.out.println(name&#43;&#34;正在睡觉！&#34;); } public void bark(){ System.out.println(name&#43;&#34;正在汪汪汪！&#34;); } } public class Cat { String name; int age; float weight; public void eat(){ System.out.println(name&#43;&#34;正在吃饭！&#34;); } public void sleep(){ System.out.println(name&#43;&#34;正在睡觉！&#34;); } public void bark(){ System.out.println(name&#43;&#34;正在喵喵喵！&#34;); } } 我们可以看到上面的代码我们可以知道，猫和狗他们有一些共性代码例如eat和sleep,这时我们就可以想到它们都是动物我们是否有什么方法可以将使用一个类方法它们放在一起。确实我们这就就可以用到我们的继承方法，因为它们都是动物这时我们就可以定义一个Animal作为父类用于存放相同共性的代码，之后我们Dog和Cat就只需要继承Animal这时就达到了简便，从而实现代码的复用。
1.2继承的概念 继承(inheritance)机制：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了 由简单到复杂的认知过程。继承主要解决的问题是：共性的抽取，实现代码复用。
继承关系如图所示：
这里我们可以看出继承其实就是父类和子类的关系，当我们父类中有的代码时子类可以继承，子类只需要关心自已特有的特性。
继承的意义：实现代码的复用。
1.3继承的语法 在Java中类之间的继承需要我们用到extends关键字。
例如：上面的猫和狗我们就可以用继承关系进行eat和sleep方法的复用。
public class Animal { String name; int age; public void eat(){ System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T18:42:23+08:00">
    <meta property="article:modified_time" content="2024-07-25T18:42:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaSE--基础语法--继承和多态(第三期)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.继承</h2> 
<h3>1.1我们为什么需要继承?</h3> 
<p>首先，Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是 现实世界错综复杂，事物之间可能会存在一些<strong><span style="color:#fe2c24;">关联</span></strong>，那在设计程序是就需要考虑。</p> 
<p>例如猫和狗：</p> 
<pre><code class="language-java">public class Dog {
    String name;
    int age;
    float weight;

    public void eat(){
        System.out.println(name+"正在吃饭！");
    }
    public void sleep(){
        System.out.println(name+"正在睡觉！");
    }
    public void bark(){
        System.out.println(name+"正在汪汪汪！");
    }
}


public class Cat {
    String name;
    int age;
    float weight;

    public void eat(){
        System.out.println(name+"正在吃饭！");
    }
    public void sleep(){
        System.out.println(name+"正在睡觉！");
    }
    public void bark(){
        System.out.println(name+"正在喵喵喵！");
    }

}
</code></pre> 
<p>我们可以看到上面的代码我们可以知道，猫和狗他们有一些共性代码例如eat和sleep,这时我们就可以想到它们都是动物我们是否有什么方法可以将使用一个类方法它们放在一起。确实我们这就就可以用到我们的继承方法，因为它们都是动物这时我们就可以定义一个Animal作为父类用于<strong><span style="color:#fe2c24;">存放相同共性</span></strong>的代码，之后我们Dog和Cat就只需要继承Animal这时就达到了简便，从而实现<strong><span style="color:#fe2c24;">代码的复用。</span></strong></p> 
<h3>1.2继承的概念</h3> 
<p><strong><span style="color:#fe2c24;">继承(inheritance)机制</span></strong>：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有<strong><span style="color:#fe2c24;">类特性</span></strong>的基础上进行扩展，<strong>增加新功能，</strong>这样产生新的类，称<strong>派生类</strong>。继承呈现了面向对象程序设计的层次结构， 体现了 由<strong>简单到复杂</strong>的认知过程。继承主要解决的问题是：<strong>共性的抽取，实现代码复用。</strong></p> 
<p>继承关系如图所示：</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/35/83/9KCoBZsP_o.png" width="854"></p> 
<p> 这里我们可以看出继承其实就是父类和子类的关系，当我们父类中有的代码时子类可以继承，子类只需要关心自已特有的特性。</p> 
<blockquote> 
 <p><strong>继承的意义：实现代码的复用。</strong></p> 
</blockquote> 
<h3> 1.3继承的语法</h3> 
<p>在Java中类之间的<strong>继承</strong>需要我们用到<strong>extends关键字</strong>。</p> 
<p>例如：上面的猫和狗我们就可以用继承关系进行eat和sleep方法的复用。</p> 
<pre><code class="language-java">public class Animal {
    String name;
    int age;

    public void eat(){
        System.out.println(name+"正在吃饭！");
    }
    public void sleep() {
        System.out.println(name + "正在睡觉！");
    }
}

public class Cat extends Animal{
    public void bark(){
        System.out.println(name+"正在汪汪汪！");
    }

}
public class Dog extends Animal {
    public void bark(){
        System.out.println(name+"正在喵喵喵！！");
    }
}
public class Test {
    public static void main(String[] args) {
        Dog dog=new Dog();
        dog.name="旺财";
        dog.age=10;

        dog.sleep();
        dog.eat();
        dog.bark();
    }
}</code></pre> 
<p>例如上面这一段代码，我们可以看到在测试方法里面我们可以直接通过dog.的形式来调用name,age,sleep,eat方法，但是我们的dog类方法中并没有这这些方法，这是它就是继承了父类Animal中的方法。</p> 
<blockquote> 
 <p>注意事项： </p> 
 <p>1. 子类会将父类中的成员变量或者成员方法继承到子类中了</p> 
 <p>2. 子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了</p> 
</blockquote> 
<h3>1.4父类成员的访问</h3> 
<h4>1.4.1子类访问父类的成员变量</h4> 
<p>1.当子类和父类不存在同名成员变量时</p> 
<pre><code class="language-java">public class Base {
    int a;
    int b;

}
public class Derived extends Base{
    int c;
    public void method(){
        a=200;
        b=59;
        c=50;
    }

}
</code></pre> 
<p> 其中a,b是从父类继承过来的，子类自己的。</p> 
<p>2.当父类和子类存在同名变量时</p> 
<pre><code class="language-java">public class Base {
    int a;
    int b;
    int c;

}
public class Derived extends Base {
    int a;
    char b;

    public void method(){
        int a=100;//此处的a访问子类的a还是继承父类的a?
        int b=200;//此处的b访问子类的b还是继承父类的b?
        int c=300;//此处的c子类中没有所以肯定是继承父类的c
    }
}</code></pre> 
<p>通过以上两个我们可以总结出：</p> 
<blockquote> 
 <p>在子类方法中或者通过子类对象访问成员时：</p> 
 <p>1.如果子类和父类同时拥有相同的成员变量时优先访问子类自己的。</p> 
 <p>2.如果访问成员变量子类没有，则继承父类的成员变量，如果父类也没有，则编译报错。</p> 
 <p><strong><span style="color:#fe2c24;">总结规律：采用就近原则，子类自己由就访问自己的，没有才去继承父类的。</span></strong></p> 
</blockquote> 
<h4>1.4.2子类中访问父类的成员方法</h4> 
<p>1.成员方法名不同</p> 
<pre><code class="language-java">public class Base {
public void methodA(){
System.out.println("Base中的methodA()");
}
}
public class Derived extends Base{
public void methodB(){
System.out.println("Derived中的methodB()方法");
}
public void methodC(){
methodB(); // 访问子类自己的methodB()
methodA(); // 访问父类继承的methodA()
// methodD(); // 编译失败，在整个继承体系中没有发现方法methodD()
}
}</code></pre> 
<p>总结：子类中有的成员方法就访问自己的，如果没有在去访问父类的方法名，若两者都没有则编译报错。</p> 
<p>2.成员方法名字相同</p> 
<pre><code class="language-java">public class Base {
public void methodA(){
System.out.println("Base中的methodA()");
}
public void methodB(){
System.out.println("Base中的methodB()");
}
}
public class Derived extends Base{
public void methodA(int a) {
System.out.println("Derived中的method(int)方法");
}
public void methodB(){
System.out.println("Derived中的methodB()方法");
}
public void methodC(){
methodA(); // 没有传参，访问父类中的methodA()
methodA(20); // 传递int参数，访问子类中的methodA(int)
methodB(); // 直接访问，则永远访问到的都是子类中的methodB()，基类的无法访问到
}
}</code></pre> 
<blockquote> 
 <p>总结：</p> 
 <p>1.通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到 则访问，否则编译报错。</p> 
 <p>2.通过派生类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同(重载)，根据调用 方法适传递的参数选择合适的方法访问，如果没有则报错；</p> 
</blockquote> 
<p>这时我们可能会想如果子类中存在与父类中相同的成员时，那如何在子类中访问父类相同名称的成员呢？答案很明显我们就会引用super关键字。</p> 
<h3>1.5super关键字</h3> 
<p>我们平时在设计场景的时候我们通常会遇到父类和子类的成员变量名相同，那么我们如何来访问父类的相同变量名呢？这时我们就会用到我们的super关键字，<strong>super的作用：在子类方法中访问父类成员。</strong></p> 
<p><strong>例如：</strong></p> 
<pre><code class="language-java">public class Base {
    int a;
    int b;
    public void methodA(){
        System.out.println("Base中的methodA().......");
    }
    public void methodB(){
        System.out.println("Base中的methodB().......");
    }
}
public class Derived extends Base{
    int a;//与父类的成员变量名相同且类型相同
    char b;//与父类的成员变量名相同但类型不同

    //与父类中的methodA构成了重载
    public void methodA(int a){
        System.out.println("Derived中的methodA().....");
    }

    //与父类中的methodB构成了重写
    public void methodB(){
        System.out.println("Derived中的methodB.......");
    }

    public void methodC(){
        a=100;//等价于 this.a=a;
        b=200;//等价于 this.b=b;
        //之前我们讲过this是对当前类中成员变量的直接引用

        //这里如果我们要访问父类的a和b,需要借助super关键字
        //super是指子类从父类继承下来的部分
        super.a=300;
        super.b=400;

        //父类和子类中构成重载的方法，直接可以通过参数列表区分清访问父类还是子类方法
        methodA();
        methodA(10);

        // 如果在子类中要访问重写的基类方法，则需要借助super关键字
        methodB();
        super.methodB();//调用父类的methodB
    }
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>总结：在子类中调用父类的成员变量和方法名只需要用上super变量就可以了。</strong></span></p> 
<p>上面我们提到了this和super关键字我们来区分以下它们。具体如下：</p> 
<p><img alt="" height="743" src="https://images2.imgbox.com/75/60/ozwj6erS_o.png" width="1200"></p> 
<p></p> 
<h3> 1.6初始化</h3> 
<p>说起子类构造方法我们其实可以在这个板块里面把父类和子类的<strong>静态，实例，构造</strong>这三个的执行顺序全部总结出来。我们来看以下一段代码：</p> 
<pre><code class="language-java">public class Animal {
    static{
        System.out.println("static::Animal().......");
    }

    private final String name;
    private final int age;


    {
        System.out.println("实例代码块Animal().....");
    }
    public Animal(String name,int age){
        this.name=name;
        this.age=age;
        System.out.println("Animal().......");
    }

}
public class Dog extends Animal{
    static{
        System.out.println("static::Dog()....");
    }
    {
        System.out.println("实例代码块Dog().......");
    }

    public Dog(String name, int age) {
        super(name, age);
        System.out.println("Dog().......");
    }
}
</code></pre> 
<p>以上是父类和子类的静态，实例，构造代码，那么我们接下来就可以通过运行结果来获得它们的执行顺序是怎样的？</p> 
<p><img alt="" height="796" src="https://images2.imgbox.com/90/c5/8BzKaDmf_o.png" width="1200"></p> 
<p>通过上图我们可以看出代码执行顺序：</p> 
<p><img alt="" height="808" src="https://images2.imgbox.com/51/19/hjs56IcR_o.png" width="1200"> 从而我们可以得到以下结论：</p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/33/56/sEINh1JT_o.png" width="173"></p> 
<blockquote> 
 <p>注意：第二次实例化子类对象时子类和父类的静态方法将不再执行</p> 
</blockquote> 
<h3> 1.7protect关键字</h3> 
<p>我们在前面学习了类和对象中我们可以知道在实现封装的时候，Java中引入了限定修饰符，主要限定：类或者类中成员能否在类外或者其他包中被访问。</p> 
<p>protect的定义如下：</p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/9a/18/vXbMJpFI_o.png" width="1200"></p> 
<p>那么在不同包中的子类使用具体是如何的呢？我们用下面的具体实例来说明</p> 
<p> <img alt="" height="772" src="https://images2.imgbox.com/d4/93/6jLb1s1H_o.png" width="1200"></p> 
<p>上面这一段代码就很好的说明了protect在不同包中子类的使用。 </p> 
<h3>1.8继承方式 </h3> 
<p>Java中继承的方式多种多样下面我们来举出几个具体的例子：</p> 
<p><img alt="" height="587" src="https://images2.imgbox.com/97/c0/zU4xSGDK_o.png" width="1200"></p> 
<p>在Java中我们一般采用前三种继承方式，多继承一般不会被使用。我们又是想要限制继承，这时我们就要用到关键字final。</p> 
<h3>1.9final关键字</h3> 
<p>1.修饰变量</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/00/db/061WCVxG_o.png" width="857"></p> 
<p>被final修饰的变量不能被修改。</p> 
<p>2.修饰类</p> 
<p>此类将无法被继承。 </p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/20/90/Es28RZ3o_o.png" width="1200"></p> 
<p>3.修饰方法</p> 
<p>此方法不能被重写。</p> 
<h3>1.10继承和组合</h3> 
<p>和继承相似组合也是一种表达类之间的关系，也可以起到代码复用的效果，给我们带来简便，但在组合中并没用想继承中的extend之类的关键词，仅仅时将一个类的实例作为另一个类的字段。</p> 
<p>继承表示对象是is-a的关系，例如： 狗是动物，猫是动物</p> 
<p>组合表示对象时has-a的关系，例如：汽车</p> 
<pre><code class="language-java">// 轮胎类
class Tire{
// ...
}
// 发动机类
class Engine{
// ...
}
// 车载系统类
class VehicleSystem{
// ...
}
class Car{
private Tire tire; // 可以复用轮胎中的属性和方法
private Engine engine; // 可以复用发动机中的属性和方法
private VehicleSystem vs; // 可以复用车载系统中的属性和方法
// ...
}
// 奔驰是汽车
class Benz extend Car{
// 将汽车中包含的：轮胎、发送机、车载系统全部继承下来
}</code></pre> 
<p>组合和继承都可以实现代码复用，应该使用继承还是组合，需要根据应用场景来选择，一般建议：能用组合尽量用 组合。</p> 
<h2>二.多态</h2> 
<h3>2.1多态的概念</h3> 
<p>多态的概念简单的来说就是当不同的对象去完成相同的事的时候会产生不同的状态。</p> 
<p>例如：</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/fe/0f/Rz4RQTgp_o.png" width="1200"></p> 
<p>从上面两个例子我们可以看出：<strong>同一件事情发生在不同的对象身上就会产生不同的结果。 </strong></p> 
<h3><strong>2.2多态的实现条件</strong></h3> 
<p>首先在Java中多态实现的必要条件：</p> 
<blockquote> 
 <p><strong>1. 必须在继承体系下</strong></p> 
 <p><strong>2. 子类必须要对父类中方法进行重写 </strong></p> 
 <p><strong>3. 通过父类的引用调用重写的方法</strong></p> 
</blockquote> 
<pre><code class="language-java">public class Animal {
    String name;
    int age;

    public Animal(String name,int age){
        this.name=name;
        this.age=age;
    }
    public void eat(){
        System.out.println(name+"正在吃饭");
    }

}
public class Dog extends Animal{
    public Dog(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        super.eat();
        System.out.println(name+"吃骨头");
    }
}
public class Cat extends Animal{
    public Cat(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        super.eat();
        System.out.println(name+"正在吃鱼");
    }
}
public class TestAnimal {
    public void eat(Animal a){
        a.eat();
    }

    public static void main(String[] args) {
        Dog dog=new Dog("旺财",1);
        Cat cat=new Cat("元宝",2);
        dog.eat();
        cat.eat();
    }
}
</code></pre> 
<p><img alt="" height="180" src="https://images2.imgbox.com/be/84/Mes7lrAc_o.png" width="1200"></p> 
<p>当不同的对象进行相同的行为会产生 不同的结果这就是多态。</p> 
<h3>2.3重写</h3> 
<p><strong>重写</strong>：就是覆盖，重写是子类对父类非静态、非private修饰，非final修饰，非构造方法等的实现过程 进行重新编写，<span style="color:#fe2c24;"><strong>返回值和形参都不能改变。即外壳不变，核心重写。</strong></span></p> 
<p><img alt="" height="751" src="https://images2.imgbox.com/f1/3a/LPunCgv0_o.png" width="1200"></p> 
<blockquote> 
 <p><strong>注意：</strong> 1.被重写的方法返回值类型可以不同，但是必须是具有父子关系的。</p> 
 <p>            2.访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类方法被public修饰，则子类中重写该方 法就不能声明为 protected</p> 
 <p>            3.父类被static、private修饰的方法、构造方法都不能被重写。</p> 
 <p>            4.重写的方法, 可以使用 @Override 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验. 例如不小心 将方法名字拼写错了 (比如写成 aet), 那么此时编译器就会发现父类中没有 aet 方法, 就会编译报错, 提示无法 构成重写.</p> 
</blockquote> 
<p>重写和重载的区别：</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/5c/5f/DeiVxey2_o.png" width="1163"></p> 
<h3> 2.4静态绑定和动态绑定</h3> 
<p><strong>静态绑定</strong>：也称为前期绑定(早绑定)，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。典型代 表函数重载。</p> 
<p><strong>动态绑定</strong>：也称为后期绑定(晚绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体 调用那个类的方法。</p> 
<p>动态绑定具体如下：</p> 
<p><img alt="" height="791" src="https://images2.imgbox.com/80/ab/L59itmjJ_o.png" width="1200"></p> 
<p></p> 
<h3>2.5向上转型和向下转型</h3> 
<h4>2.5.1向上转型：</h4> 
<p>向上转型顾名思义在我们的继承中就是由子类向父类进行向上转型。也就是创造一个子类对象把它当作父类对象来使用。</p> 
<p>语法格式：<img alt="" height="63" src="https://images2.imgbox.com/fb/17/grmnuqfu_o.png" width="676"></p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/33/ab/LjWMoWhf_o.png" width="1200"></p> 
<p>使用场景具体的有三种：</p> 
<p>1.直接赋值</p> 
<p>2.方法传参</p> 
<p>3.方法返回</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/04/e2/4v7soWAk_o.png" width="1200"></p> 
<blockquote> 
 <p>向上转型的优点：让代码实现更简单灵活。</p> 
 <p>向上转型的缺陷：不能调用到子类特有的方法。</p> 
</blockquote> 
<h4> 2.5.2向下转型</h4> 
<p>将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的 方法，此时：将父类引用再还原为子类对象即可，即向下转换。</p> 
<p>但我们需要注意的是向下转型存在安全隐患</p> 
<pre><code class="language-java">public static void main(String[] args) {
        Cat cat=new Cat("元宝",10);
        Dog dog=new Dog("旺财",20);

        //向上转型
        Animal animal=cat;
        animal.eat();
        animal=dog;
        animal.eat();

        //向下转型
        cat=(Cat)animal;//此时animal指向的是dog但这里向下转型为cat运行时会抛出异常
        cat.mew();

        dog=(Dog)animal;
        dog.bark();//这里animal指向的就是dog故这里不会报错
    }</code></pre> 
<p>向下转型用的比较少，而且不安全，万一转换失败，运行时就会抛异常。Java中为了提高向下转型的安全性，引入 了 instanceof ，如果该表达式为true，则可以安全转换。</p> 
<pre><code class="language-java">public class TestAnimal {
public static void main(String[] args) {
Cat cat = new Cat("元宝",2);
Dog dog = new Dog("小七", 1);
// 向上转型
Animal animal = cat;
animal.eat();
animal = dog;
animal.eat();
if(animal instanceof Cat){
cat = (Cat)animal;
cat.mew();
}
if(animal instanceof Dog){
dog = (Dog)animal;
dog.bark();
}
}
}</code></pre> 
<h3>2.6多态的优缺点</h3> 
<p>使用多态能够大大降低代码的“<strong>圈复杂度</strong>”，避免大量使用if-else.</p> 
<p><strong>圈复杂度:</strong>圈复杂度是一种描述一段代码复杂程度的方式. 一段代码如果平铺直叙, 那么就比较简单容易理解. 而如 果有很多的条件分支或者循环语句, 就认为理解起来更复杂.</p> 
<p>例如：</p> 
<pre><code class="language-java">public class Shape {
    public void draw(){
        System.out.println("画图形！");
    }
}
public class Cycle extends Shape{
    @Override
    public void draw() {
        super.draw();
        System.out.println("●");
    }
}
public class Rect extends Shape{
    @Override
    public void draw() {
        super.draw();
        System.out.println("♦");
    }
}
public class Flower extends Shape{
    @Override
    public void draw() {
        super.draw();
        System.out.println("❀");
    }
}
public class TestShape {
    public static void main(String[] args) {
        Rect rect = new Rect();
        Cycle cycle = new Cycle();
        Flower flower = new Flower();
        String[] shapes = {"cycle", "rect", "cycle", "rect", "flower"};
        for (String shape : shapes) {
            if (shape.equals("cycle")) {
                cycle.draw();
            } else if (shape.equals("rect")) {
                rect.draw();
            } else if (shape.equals("flower")) {
                flower.draw();
            }
        }
    }
}</code></pre> 
<p>这里我们没有使用多态我们就会使用大量的if-else循环语句这时代码就比较繁琐，那当我们使用多态会是什么效果呢？</p> 
<pre><code class="language-java">public class Shape {
    public void draw(){
        System.out.println("画图形！");
    }
}
public class Cycle extends Shape{
    @Override
    public void draw() {
        super.draw();
        System.out.println("●");
    }
}
public class Rect extends Shape{
    @Override
    public void draw() {
        super.draw();
        System.out.println("♦");
    }
}
public class Flower extends Shape{
    @Override
    public void draw() {
        super.draw();
        System.out.println("❀");
    }
}
public class TestShape {
    public static void main(String[] args) {
        Shape[] shapes = {new Cycle(), new Rect(), new Cycle(),
                new Rect(), new Flower()};
        for (Shape shape : shapes) {
            shape.draw();
        }
    }
   
}</code></pre> 
<p>这里我们不难看出当我们使用了多态以后，代码就会变得简单易懂，这就是多态的好处。</p> 
<p>2.<strong>使用多态可扩展性强</strong></p> 
<p>简而言之就是当我们要增加一种新的形状的时候，改动代码的成本比较低，例如：</p> 
<pre><code class="language-java">class Triangle extends Shape {
@Override
public void draw() {
System.out.println("△");
</code></pre> 
<p>我们只需要在上面代码的基础上新增加一个类就可以了，不需要去改动其他地方。</p> 
<blockquote> 
 <p>但是多态除了它的优点也有缺点</p> 
 <p>1. 属性没有多态性 当父类和子类都有同名属性的时候，通过父类引用，只能引用父类自己的成员属性</p> 
 <p>2. 构造方法没有多态性</p> 
</blockquote> 
<p>好了以上就是关于继承和多态的全部内容，我们下期见！ </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e26f4949778c358e4d18ad2e43872aae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">软件测试中的压力测试和性能测试区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88ee4c9375c79e7f4e0d7c5133fd3504/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BUUCTF [MRCTF2020]Ezpop</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>