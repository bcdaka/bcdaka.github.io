<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring WebFlux 实现 SSE 流式回复：类GPT逐字显示回复效果完整指南 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fdc7d439fef786bd167567ec04bd100f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Spring WebFlux 实现 SSE 流式回复：类GPT逐字显示回复效果完整指南">
  <meta property="og:description" content="本节将提供基于 Spring WebFlux 和 SSE 实现类ChatGPT流式回复效果的完整代码示例，并详细说明所需的依赖和配置。
1. 项目配置 构建工具: Maven 或 Gradle依赖: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; 2. 后端代码 (Spring WebFlux) package com.example.ssedemo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; import org.springframework.http.codec.ServerSentEvent; import java.time.Duration; @SpringBootApplication @RestController public class SseDemoApplication { public static void main(String[] args) { SpringApplication.run(SseDemoApplication.class, args); } @GetMapping(value = &#34;/stream&#34;, produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamChatGPTReply(@RequestParam String message) { // 模拟调用 ChatGPT API 获取回复 String reply = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T11:21:46+08:00">
    <meta property="article:modified_time" content="2024-08-13T11:21:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring WebFlux 实现 SSE 流式回复：类GPT逐字显示回复效果完整指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本节将提供基于 Spring WebFlux 和 SSE 实现类ChatGPT流式回复效果的完整代码示例，并详细说明所需的依赖和配置。</p> 
<h4>1. 项目配置</h4> 
<ul><li><strong>构建工具:</strong> Maven 或 Gradle</li><li><strong>依赖:</strong></li></ul> 
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<h4>2. 后端代码 (Spring WebFlux)</h4> 
<pre><code>package com.example.ssedemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;
import org.springframework.http.codec.ServerSentEvent;

import java.time.Duration;

@SpringBootApplication
@RestController
public class SseDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(SseDemoApplication.class, args);
    }

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamChatGPTReply(@RequestParam String message) {
        // 模拟调用 ChatGPT API 获取回复
        String reply = "收到消息: " + message + ". 正在思考...";
        return Flux.&lt;String&gt;create(sink -&gt; {
                    sink.next(reply); // 先发送初始回复
                    // 模拟逐字生成回复
                    for (int i = 0; i &lt; reply.length(); i++) {
                        try {
                            Thread.sleep(100); // 模拟延迟
                            sink.next(reply.substring(0, i + 1));
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                    sink.complete();
                })
                .map(data -&gt; ServerSentEvent.&lt;String&gt;builder()
                        .data(data)
                        .build())
                .delayElements(Duration.ofMillis(100)); // 每隔一段时间发送一个字符
    }
}
</code></pre> 
<p> 另外一种方式：</p> 
<pre><code>private final WebClient webClient; // 用于调用外部 API

public ChatController(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("http://api.example.com").build(); 
}

@GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamChatGPTReply(@RequestParam String message) {
    // 使用 WebClient 异步调用外部 API
    return webClient.post()
            .uri("/api/external") 
            .bodyValue(message)
            .retrieve()
            .bodyToFlux(String.class) // 假设 API 返回 String 类型数据
            .map(data -&gt; ServerSentEvent.&lt;String&gt;builder()
                    .data(data) // 将 API 响应数据包装到 SSE 事件中
                    .build())
            .delayElements(Duration.ofMillis(100));
}
</code></pre> 
<h4>3. 前端代码 (HTML &amp; JavaScript)</h4> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;SSE Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;SSE Chat Demo&lt;/h1&gt;
    &lt;div id="output"&gt;&lt;/div&gt;
    &lt;input type="text" id="message"&gt;
    &lt;button onclick="sendMessage()"&gt;发送&lt;/button&gt;

    &lt;script&gt;
        const output = document.getElementById('output');

        function sendMessage() {
            const message = document.getElementById('message').value;
            const eventSource = new EventSource('/stream?message=' + message);

            eventSource.onmessage = (event) =&gt; {
                output.innerHTML += event.data + '&lt;br&gt;';
            };

            eventSource.onerror = (error) =&gt; {
                console.error('SSE 连接错误:', error);
                eventSource.close();
            };
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h4>4. 代码解析</h4> 
<ul><li><strong>后端:</strong> 
  <ul><li><code>@GetMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)</code>: 指定响应类型为 <code>text/event-stream</code>，这是 SSE 的标准 MIME 类型。</li><li><code>Flux&lt;ServerSentEvent&lt;String&gt;&gt;</code>: 使用 Spring WebFlux 的 <code>Flux</code> 类型返回数据流，并使用 <code>ServerSentEvent</code> 包装每个数据项.</li><li><code>sink.next()</code>: 向数据流中发送数据。</li><li><code>sink.complete()</code>: 通知数据流结束。</li></ul></li><li><strong>前端:</strong> 
  <ul><li><code>new EventSource('/stream')</code>: 创建 EventSource 对象，连接到后端 SSE 接口.</li><li><code>eventSource.onmessage</code>: 监听 <code>message</code> 事件，接收后端推送的数据.</li><li><code>eventSource.onerror</code>: 监听连接错误.</li></ul></li></ul> 
<h4>5. 运行 &amp; 测试</h4> 
<ol><li>启动 Spring Boot 应用.</li><li>访问 <code>http://localhost:8080</code> (默认端口).</li><li>在输入框中输入消息并点击发送，观察逐字显示的效果.</li></ol> 
<h4>总结</h4> 
<p>本文详细介绍了如何使用 Spring WebFlux 和 SSE 实现类似 ChatGPT 的流式回复效果，并提供了完整的代码示例。希望读者能够通过本文掌握该技术，并在实际项目中灵活运用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d9c981a2e042460a05b9aa7ba728e6fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Django 使用 Session 实现用户唯一标识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/311dcc786525006f7bc5c0cef2566791/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">租用服务器建站要考虑网站的哪些因素？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>