<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分享 .NET EF6 查询并返回树形结构数据的 2 个思路和具体实现方法 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fedb3c9b58af02a3166fd2b7acec51f0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="分享 .NET EF6 查询并返回树形结构数据的 2 个思路和具体实现方法">
  <meta property="og:description" content="前言 树形结构是一种很常见的数据结构，类似于现实生活中的树的结构，具有根节点、父子关系和层级结构。
所谓根节点，就是整个树的起始节点。
节点则是树中的元素，每个节点可以有零个或多个子节点，节点按照层级排列，根节点属于第一层，其子节点属于第二层，以此类推，没有子节点的节点，则称为叶子，是最后一层。
父子关系就是节点之间的关系，每个节点都有父节点。
树形结构的应用非常广泛，例如在数据库中用来表示组织结构、目录结构，还用于实现树状菜单、文件系统等。
树形结构的灵活性和层次性使其成为处理具有层级关系数据的有力工具。
常见的树形结构包括二叉树、平衡树、B树等，它们在各个领域都有不同的应用场景和算法实现。
下面分享 EF6 查询并返回树形结构数据的 2 个思路和具体实现方法。
1. EF 生成数据表的实体类 /// &lt;summary&gt; /// HTFP14 表实体类 /// &lt;/summary&gt; public partial class HTFP14 { public string COMPHT14 { get; set; } public string ACDEHT14 { get; set; } public string PGRPHT14 { get; set; } public string PKEYHT14 { get; set; } public string DESCHT14 { get; set; } public Nullable&lt;decimal&gt; PVALHT14 { get; set; } public string PSTRHT14 { get; set; } public string GLNOHT14 { get; set; } public string PCDEHT14 { get; set; } public string ATLVHT14 { get; set; } public string USERHT14 { get; set; } public System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T17:56:03+08:00">
    <meta property="article:modified_time" content="2024-07-17T17:56:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分享 .NET EF6 查询并返回树形结构数据的 2 个思路和具体实现方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/96/fc/l34Yq5xB_o.png" alt="image"></p> 
<h2><a id="_1"></a>前言</h2> 
<p>树形结构是一种很常见的数据结构，类似于现实生活中的树的结构，具有根节点、父子关系和层级结构。</p> 
<p>所谓根节点，就是整个树的起始节点。</p> 
<p>节点则是树中的元素，每个节点可以有零个或多个子节点，节点按照层级排列，根节点属于第一层，其子节点属于第二层，以此类推，没有子节点的节点，则称为叶子，是最后一层。</p> 
<p>父子关系就是节点之间的关系，每个节点都有父节点。</p> 
<p>树形结构的应用非常广泛，例如在数据库中用来表示组织结构、目录结构，还用于实现树状菜单、文件系统等。</p> 
<p>树形结构的灵活性和层次性使其成为处理具有层级关系数据的有力工具。</p> 
<p>常见的树形结构包括二叉树、平衡树、B树等，它们在各个领域都有不同的应用场景和算法实现。</p> 
<p>下面分享 EF6 查询并返回树形结构数据的 2 个思路和具体实现方法。</p> 
<h2><a id="1_EF__19"></a>1. EF 生成数据表的实体类</h2> 
<pre><code class="prism language-c#">/// &lt;summary&gt;
/// HTFP14 表实体类
/// &lt;/summary&gt;
public partial class HTFP14
{
	public string COMPHT14 { get; set; }
	public string ACDEHT14 { get; set; }
	public string PGRPHT14 { get; set; }
	public string PKEYHT14 { get; set; }
	public string DESCHT14 { get; set; }
	public Nullable&lt;decimal&gt; PVALHT14 { get; set; }
	public string PSTRHT14 { get; set; }
	public string GLNOHT14 { get; set; }
	public string PCDEHT14 { get; set; }
	public string ATLVHT14 { get; set; }
	public string USERHT14 { get; set; }
	public System.DateTime LMDTMHT14 { get; set; }
}
</code></pre> 
<h2><a id="2__ViewModel__42"></a>2. 创建用于前端的 ViewModel 类</h2> 
<pre><code class="prism language-c#">/// &lt;summary&gt;
/// 主菜单 UI 树形结构 ViewModel 类
/// &lt;/summary&gt;
public class MainMenuViewModel
{
	[Description("菜单层次")]
	public int MenuLevel { get; set; }

	[Description("菜单码")]
	public string MenuCode { get; set; }

	[Description("菜单名称")]
	public string MenuName { get; set; }

	[Description("菜单对外显示名称")]
	public string MenuLabel
	{
		get
		{
			return $"{MenuCode} - {MenuName}";
		}
	}

	[Description("父菜单码")]
	public string ParentMenuCode { get; set; }

	[Description("菜单URL")]
	public string MenuUrl { get; set; }

	[Description("菜单授权用户")]
	public string MenuUser { get; set; }

	[Description("是否禁止")]
	public bool Disabled
	{
		get
		{
			if (string.IsNullOrEmpty(MenuUser))
			{
				return true;
			}
			return false;
		}
	}
	[Description("菜单排序")]
	public decimal MenuOrder { get; set; }

	[Description("子级菜单")]
	public IList&lt;MainMenuViewModel&gt; Children { get; set; }
}
</code></pre> 
<h2><a id="3__97"></a>3. 数据准备</h2> 
<ol><li> <p>获取初级菜单</p> <pre><code class="prism language-c#">/// &lt;summary&gt;
/// 查询第一级菜单
/// &lt;/summary&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private IQueryable&lt;MainMenuViewModel&gt; GetFirstMenu()
{
	var query = from t1 in _dbContext.HTFP14 
				where t1.PGRPHT14 == "MNGP" 
				select new MainMenuViewModel
				{
					MenuCode = t1.PKEYHT14,
					MenuName = t1.DESCHT14,
					ParentMenuCode = "",
					MenuUrl = "",
					MenuUser = ""
				};
	return query;
}
</code></pre> </li><li> <p>获取二级菜单</p> <pre><code class="prism language-c#">/// &lt;summary&gt;
/// 查询第二级菜单
/// &lt;/summary&gt;
/// &lt;param name="companyCode"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private IQueryable&lt;MainMenuViewModel&gt; GetSecondMenu(string companyCode)
{
	var query = from t1 in _dbContext.HTFP14
				where t1.PGRPHT14 == "MUGP" &amp;&amp; 
					  t1.COMPHT14 == companyCode
				select new MainMenuViewModel
				{
					MenuCode = t1.PKEYHT14,
					MenuName = t1.DESCHT14,
					ParentMenuCode = t1.PCDEHT14,
					MenuUrl = "",
					MenuUser = ""
				};
	return query;
}
</code></pre> </li><li> <p>获取三级（最终）菜单</p> <pre><code class="prism language-c#">/// &lt;summary&gt;
/// 查询第三级（最终）菜单
/// &lt;/summary&gt;
/// &lt;param name="companyCode"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private IQueryable&lt;MainMenuViewModel&gt; GetThirdMenu(string menuUser, string companyCode)
{
	var query = from t1 in _dbContext.HTFP02
				where t1.COMPHT02 == companyCode &amp;&amp; 
					  t1.STSHT02 == "A"
				join t2 in (from t21 in _dbContext.HTFP03 where t21.USRMNHT03==menuUser &amp;&amp; t21.COMPHT03==companyCode select t21) on t1.MNUCDHT02 equals t2.MNUCDHT03 into t1_t2
				from t12 in t1_t2.DefaultIfEmpty()
				select new MainMenuViewModel
				{
					MenuCode = t1.MNUCDHT02,
					MenuName = t1.DESCHT02,
					ParentMenuCode = t1.MNUGPHT02,
					MenuUrl = t1.URLHT02,
					MenuUser = t12.USRMNHT03
				};
	return query;
}
</code></pre> </li><li> <p>解释：这样分开查询，简化代码，避免太复杂的 Linq 拼接</p> </li></ol> 
<h2><a id="_176"></a>方法一</h2> 
<p>思路：使用 Linq 语法拼接查询，具体步骤如下：</p> 
<ol><li> <p>在数据层用 Linq 拼接写查询方法</p> <pre><code class="prism language-c#">/// &lt;summary&gt;
/// 查询主菜单树形结构数据
/// &lt;/summary&gt;
/// &lt;param name="companyCode"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public IQueryable&lt;object&gt; QueryMainMenus(string menuUser, string companyCode)
{
	var query1 = GetFirstMenu();
	var query2 = GetSecondMenu(companyCode);
	var query3 = GetThirdMenu(menuUser, companyCode);
	var query = from t1 in query1
				select new
				{
					MenuCode = t1.MenuCode,
					MenuName = t1.MenuName,
					ParentMenuCode = t1.ParentMenuCode,
					MenuUrl = t1.MenuUrl,
					MenuUser = t1.MenuUser,
					Children = (from t2 in query2
								where t2.ParentMenuCode == t1.MenuCode
								select new
								{
									MenuCode = t2.MenuCode,
									MenuName = t2.MenuName,
									ParentMenuCode = t2.ParentMenuCode,
									MenuUrl = t2.MenuUrl,
									MenuUser = t2.MenuUser,
									Children = (from t3 in query3
												where t3.ParentMenuCode == t2.MenuCode
												select new
												{
													MenuCode = t3.MenuCode,
													MenuName = t3.MenuName,
													ParentMenuCode = t3.ParentMenuCode,
													MenuUrl = t3.MenuUrl,
													MenuUser = t3.MenuUser
												})
								})
				};
	return query;
}
</code></pre> </li><li> <p>在业务层直接调用方法生成 List 返回给前端</p> </li><li> <p>总结</p> <p>逻辑比较简单，有多个菜单可以一直添加下去，但代码会变得很长，所以比较适合事先知道层级并且层级数量不多的场景。</p> </li></ol> 
<h2><a id="_232"></a>方法二（推荐）</h2> 
<p>思路：实体类 + 递归方法，具体步骤如下：</p> 
<ol><li> <p>数据层 EF 使用 Union 方法返回整个树形结构数据：</p> <pre><code>/// &lt;summary&gt;
/// 查询主菜单树形结构数据
/// &lt;/summary&gt;
/// &lt;param name="companyCode"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public IQueryable&lt;MainMenuViewModel&gt; QueryMainMenus(string menuUser, string companyCode)
{
	var query1 = GetFirstMenu();
	var query2 = GetSecondMenu(companyCode);
	var query3 = GetThirdMenu(menuUser, companyCode);
	var query = query1.Union(query2).Union(query3);
	return query;
}
</code></pre> </li><li> <p>业务层递归处理并返回集合数据给前端</p> <pre><code class="prism language-c#">public List&lt;MainMenuViewModel&gt; QueryMainMenus(string menuUser, string companyCode)
{
	var list = hTFP02Reposition.QueryMainMenus(menuUser, companyCode).ToList();
	var list2 = GetData(list);
	return list2;
}

/// &lt;summary&gt;
/// 处理树形结构数据
/// &lt;/summary&gt;
/// &lt;param name="source"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private List&lt;MainMenuViewModel&gt; GetData(List&lt;MainMenuViewModel&gt; source)
{
	List&lt;MainMenuViewModel&gt; nodes = source.Where(x =&gt; x.ParentMenuCode == "").Select(x =&gt; x).ToList();
	foreach (MainMenuViewModel item in nodes)
	{
		item.Children = GetChildren(source, item);
	}
	return nodes;
}

/// &lt;summary&gt;
/// 递归处理树形结构数据
/// &lt;/summary&gt;
/// &lt;param name="source"&gt;&lt;/param&gt;
/// &lt;param name="node"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
private IList&lt;MainMenuViewModel&gt; GetChildren(List&lt;MainMenuViewModel&gt; source, MainMenuViewModel node)
{
	IList&lt;MainMenuViewModel&gt; childrens = source.Where(c =&gt; c.ParentMenuCode == node.MenuCode).Select(x =&gt; x).ToList();
	foreach (MainMenuViewModel item in childrens)
	{
		item.Children = GetChildren(source, item);
	}
	return childrens;
}
</code></pre> </li><li> <p>总结</p> <p>代码比较简单，但逻辑相对不如第一种方法好理解，递归方法的性能略逊于第一种方法，但可扩展性比较强，适用于无法事先知道层级数量的树形数据结构。</p> </li></ol> 
<h2><a id="_304"></a>往期精彩</h2> 
<ol><li><a href="https://blog.csdn.net/yangshuquan/article/details/140363762">分享一个 .NET 通过监听器拦截 EF 消息写日志的详细例子</a></li><li><a href="https://blog.csdn.net/yangshuquan/article/details/135137349">不会使用 EF Core 的 Code First 模式？来看看这篇文章，手把手地教你</a></li><li><a href="https://blog.csdn.net/yangshuquan/article/details/135202647">EF Core 性能很差？试试这 6 个小技巧</a></li><li><a href="https://blog.csdn.net/yangshuquan/article/details/135226750">如何在 EF Core 中使用乐观并发控制</a></li><li><a href="https://blog.csdn.net/yangshuquan/article/details/135462485">EF Core 在实际开发中，如何分层？</a></li></ol> 
<blockquote> 
 <p>我是老杨，一个奋斗在一线的资深研发老鸟，让我们一起聊聊技术，聊聊程序人生，共同学习，共同进步</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/629a5d6c3c5af486db443f17dbb4bd5b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python与GUI开发】事件处理与打包分发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de45ad413245faed1012f25f65fe8d9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python】从基础到进阶（四）：深入了解Python中的控制流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>