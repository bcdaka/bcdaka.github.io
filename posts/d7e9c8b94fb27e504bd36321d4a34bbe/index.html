<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP全队列连接，tcpdum抓包 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d7e9c8b94fb27e504bd36321d4a34bbe/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="TCP全队列连接，tcpdum抓包">
  <meta property="og:description" content="TCP全队列连接，tcpdum抓包 1. listen的第二个参数作用2. 理解全连接队列（原理）3. 为什么要有全连接队列并且队列长度要适当4. 使用不tcpdump 进行抓包，分析TCP过程（三次握手，四次挥手）4.1安装tcpdump4.2常见使用4.3测试 1. listen的第二个参数作用 准备工作
我们把这个测试tcp实验的代码中的server端中的accept关闭，也就说现在服务器只是做listen监听工作。并且把listen中的的第二个参数设置为1。观察现象。
当我们启动两台客户端的时候，使用netstat -natp查看是没有什么问题的。
但是当我们增加客户端的时候，就出现问题了
除了刚开始的两个连接时处于Established状态下（也就是三次握手成功了），后面的两个客户端的状态却是处于SYN_SENT状态（也就是三次握手没有成功）
所以上面的实验也验证了，建立连接的过程和用户是否accept无关。也就是说在服务器来不及进行accept的时候，底层TCP listen sock允许用户进行三次握手，并构建连接。但是构建成功连接的数量是有限的。而这个数量就是listen中的第二个参数backlog &#43; 1
2. 理解全连接队列（原理） 服务器在一定事件内肯定会同时受到众多的客户端发起的请求，这些请求可能是申请建立新连接，也可能是申请发数据。大那是不管是什么申请，终究可以归咎到申请一个连接。那么这么多的连接，服务器要不要进行管理，操作系统要不要进行管理呢？答案是肯定的，也就说操作系统要对连接进行管理，说到管理我们就要想起之前提到的六字真言&#34;先描述，再组织&#34;，所以说其实操作系统底层是使用数据结构来管理好一个一个的结构化的连接的。而这个数据结构就是全连接队列。 但是这并不是说服务器只能处理backlog &#43; 1个连接，而是再accept忙不过来去对列中拿走连接时，全连接队列所能装下的连接个数。所以其实我们也不难发现，这其实是一个生产者消费者模型。 3. 为什么要有全连接队列并且队列长度要适当 这个全连接对队列其实类似于缓冲区的样子，既然是服务器那么必然在某个时间段是服务高峰期，同时也有服务低峰期。如果是在高峰期的话，假设全连接队列为空了，也就是说来了一个连接直接对接引用层让服务器直接处理，但是啊服务器的处理能里是有限的啊，如果同时来了多个请求连接那么必然会有很多的请求连接被拒绝了，这非常降低用户的体验感，并且势必会造成同一个服务器会发起多次请求，也间接的导致加重了服务器的处理工作量，降低服务器的处理效率。那么是不是将全连接队列的空间设置的很大呢？这样的话，就算有很多的连接到来了，也可直接添加到全连接队列中了，这样不久解决了服务器拒绝用户请求的问题吗？看似解决了，但是归根结底服务器的处理能力是有限的，服务器也是从全连接队列中取出数据，如果队列太大了，也就说明用户排队人数就变多了，那么就势必会有用户排在很后面，也就是该用户可能要等待很长一段事件才能进行业务处理。那么这样也有问题，设想一下，如果你在请求一个连接时他就一直转圈圈不给你处理请求你会怎么想，如果是耐心好的可能会等一会，要是没有耐心的是不是直接退出找其他的服务器申请了啊。所以如果队列太长了的话，可能排再更后后面的用户会直接退出，也就将全连接队列开辟好的空间闲置下来的，这不就是一种浪费内核内存资源吗！所以综合上述来讲，为什么要有全队列连接呢：主要是讲全连接队列当作一个缓冲区，在服务器处理不过来过多连接时进行一定的缓存，减少服务器的闲置率，提高用户的体验感。同时开辟的队列大小要适中，减少不必要的内核空间浪费。 4. 使用不tcpdump 进行抓包，分析TCP过程（三次握手，四次挥手） 4.1安装tcpdump tcpdump 通常已经预装在大多数 Linux 发行版中。如果没有安装，可以使用包管理器进行安装。例如 Ubuntu，可以使用以下命令安装：
Bash sudo apt-get update sudo apt-get install tcpdump 在 Red Hat 或 CentOS 系统中，可以使用以下命令：
Bash sudo yum install tcpdump 4.2常见使用 捕获所有网络接口上的TCP报文 Bash $ sudo tcpdump -i any tcp 注意：-i any 指定捕获所有网络接口上的数据包，tcp 指定捕获 TCP 协议的数据包。i 可以理解成为 interface 的意思">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-07T19:33:32+08:00">
    <meta property="article:modified_time" content="2024-08-07T19:33:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP全队列连接，tcpdum抓包</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>TCP全队列连接，tcpdum抓包</h4> 
 <ul><li><a href="#1_listen_1" rel="nofollow">1. listen的第二个参数作用</a></li><li><a href="#2__12" rel="nofollow">2. 理解全连接队列（原理）</a></li><li><a href="#3__18" rel="nofollow">3. 为什么要有全连接队列并且队列长度要适当</a></li><li><a href="#4_tcpdump_TCP_23" rel="nofollow">4. 使用不tcpdump 进行抓包，分析TCP过程（三次握手，四次挥手）</a></li><li><ul><li><a href="#41tcpdump_24" rel="nofollow">4.1安装tcpdump</a></li><li><a href="#42_37" rel="nofollow">4.2常见使用</a></li><li><a href="#43_97" rel="nofollow">4.3测试</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_listen_1"></a>1. listen的第二个参数作用</h2> 
<ol><li> <p>准备工作<br> 我们把这个测试<code>tcp</code>实验的代码中的server端中的<code>accept</code>关闭，也就说现在服务器只是做<code>listen</code>监听工作。并且把<code>listen</code>中的的第二个参数设置为1。观察现象。</p> </li><li> <p>当我们启动两台客户端的时候，使用netstat -natp查看是没有什么问题的。<br> <img src="https://images2.imgbox.com/13/c5/zERbsn62_o.png" alt="在这里插入图片描述"></p> </li><li> <p>但是当我们增加客户端的时候，就出现问题了<br> <img src="https://images2.imgbox.com/45/a8/EGIZq3FA_o.png" alt="在这里插入图片描述"><br> 除了刚开始的两个连接时处于<code>Established</code>状态下（也就是三次握手成功了），后面的两个客户端的状态却是处于<code>SYN_SENT</code>状态（也就是三次握手没有成功）</p> </li><li> <p>所以上面的实验也验证了，建立连接的过程和用户是否<code>accept</code>无关。也就是说在服务器来不及进行<code>accept</code>的时候，底层<code>TCP listen sock</code>允许用户进行三次握手，并构建连接。但是构建成功连接的数量是有限的。而这个数量就是<code>listen</code>中的第二个参数<code>backlog + 1</code></p> </li></ol> 
<h2><a id="2__12"></a>2. 理解全连接队列（原理）</h2> 
<ul><li>服务器在一定事件内肯定会同时受到众多的客户端发起的请求，这些请求可能是申请建立新连接，也可能是申请发数据。大那是不管是什么申请，终究可以归咎到申请一个连接。那么这么多的连接，服务器要不要进行管理，操作系统要不要进行管理呢？答案是肯定的，也就说操作系统要对连接进行管理，说到管理我们就要想起之前提到的六字真言"先描述，再组织"，所以说其实操作系统底层是使用数据结构来管理好一个一个的结构化的连接的。而这个数据结构就是全连接队列。</li></ul> 
<p><img src="https://images2.imgbox.com/c8/31/T5lnKJYh_o.png" alt="在这里插入图片描述"></p> 
<ul><li>但是这并不是说服务器只能处理backlog + 1个连接，而是再accept忙不过来去对列中拿走连接时，全连接队列所能装下的连接个数。所以其实我们也不难发现，这其实是一个生产者消费者模型。</li><li></ul> 
<h2><a id="3__18"></a>3. 为什么要有全连接队列并且队列长度要适当</h2> 
<ul><li><li>这个全连接对队列其实类似于缓冲区的样子，既然是服务器那么必然在某个时间段是服务高峰期，同时也有服务低峰期。如果是在高峰期的话，假设全连接队列为空了，也就是说来了一个连接直接对接引用层让服务器直接处理，但是啊服务器的处理能里是有限的啊，如果同时来了多个请求连接那么必然会有很多的请求连接被拒绝了，这非常降低用户的体验感，并且势必会造成同一个服务器会发起多次请求，也间接的导致加重了服务器的处理工作量，降低服务器的处理效率。</li><li>那么是不是将全连接队列的空间设置的很大呢？这样的话，就算有很多的连接到来了，也可直接添加到全连接队列中了，这样不久解决了服务器拒绝用户请求的问题吗？看似解决了，但是归根结底服务器的处理能力是有限的，服务器也是从全连接队列中取出数据，如果队列太大了，也就说明用户排队人数就变多了，那么就势必会有用户排在很后面，也就是该用户可能要等待很长一段事件才能进行业务处理。那么这样也有问题，设想一下，如果你在请求一个连接时他就一直转圈圈不给你处理请求你会怎么想，如果是耐心好的可能会等一会，要是没有耐心的是不是直接退出找其他的服务器申请了啊。所以如果队列太长了的话，可能排再更后后面的用户会直接退出，也就将全连接队列开辟好的空间闲置下来的，这不就是一种浪费内核内存资源吗！</li><li>所以综合上述来讲，为什么要有全队列连接呢：主要是讲全连接队列当作一个缓冲区，在服务器处理不过来过多连接时进行一定的缓存，减少服务器的闲置率，提高用户的体验感。同时开辟的队列大小要适中，减少不必要的内核空间浪费。</li></ul> 
<h2><a id="4_tcpdump_TCP_23"></a>4. 使用不tcpdump 进行抓包，分析TCP过程（三次握手，四次挥手）</h2> 
<h3><a id="41tcpdump_24"></a>4.1安装tcpdump</h3> 
<p>tcpdump 通常已经预装在大多数 Linux 发行版中。如果没有安装，可以使用包管理器进行安装。例如 Ubuntu，可以使用以下命令安装：</p> 
<pre><code class="prism language-c">Bash
sudo apt<span class="token operator">-</span>get update
sudo apt<span class="token operator">-</span>get install tcpdump
</code></pre> 
<p>在 Red Hat 或 CentOS 系统中，可以使用以下命令：</p> 
<pre><code class="prism language-c">Bash
sudo yum install tcpdump
</code></pre> 
<h3><a id="42_37"></a>4.2常见使用</h3> 
<ol><li><strong>捕获所有网络接口上的TCP报文</strong></li></ol> 
<pre><code class="prism language-c">Bash
$ sudo tcpdump <span class="token operator">-</span>i any tcp
</code></pre> 
<p>注意：-i any 指定捕获所有网络接口上的数据包，tcp 指定捕获 TCP 协议的数据包。i 可以理解成为 interface 的意思</p> 
<ol start="2"><li><strong>捕获指定网络接口上的 TCP 报文</strong></li></ol> 
<pre><code class="prism language-c">Bash
$ sudo tcpdump <span class="token operator">-</span>i <span class="token function">enh0</span><span class="token punctuation">(</span>虚拟机的话就是ens33<span class="token punctuation">)</span> tcp
</code></pre> 
<ol start="3"><li><strong>捕获特定源或目的 IP 地址的 TCP 报文</strong></li></ol> 
<p>使用 host 关键字可以指定源或目的 IP 地址。例如，要捕获源 IP 地址为 xxx.xxx.xxx.xxx 的 TCP 报文，可以使用以下命令：</p> 
<pre><code class="prism language-c">Bash
$ sudo tcpdump src host xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx and tcp
</code></pre> 
<p>要捕获目的 IP 地址为 xxx.xxx.xxx.xxx 的 TCP 报文，可以使用以下命令：</p> 
<pre><code class="prism language-c">Bash
$ sudo tcpdump dst host xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx and tcp
</code></pre> 
<p>同时指定源和目的 IP 地址，可以使用 and 关键字连接两个条件：</p> 
<pre><code class="prism language-c">Bash
$ sudo tcpdump src host xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx and dst host yyy<span class="token punctuation">.</span>yyy<span class="token punctuation">.</span>yyy<span class="token punctuation">.</span>yyy
and tcp
</code></pre> 
<ol start="4"><li><strong>捕获特定端口的 TCP 报文</strong></li></ol> 
<p>使用 port 关键字可以指定端口号。例如，要捕获端口号为 80 的 TCP 报文（通常是HTTP 请求），可以使用以下命令：<br> Bash<br> $ sudo tcpdump port 80 and tcp</p> 
<ol start="5"><li><strong>保存捕获的数据包到文件</strong></li></ol> 
<p>使用 -w 选项可以将捕获的数据包保存到文件中，以便后续分析。例如：</p> 
<pre><code class="prism language-c">Bash
$ sudo tcpdump <span class="token operator">-</span>i eth0 port <span class="token number">80</span> <span class="token operator">-</span>w data<span class="token punctuation">.</span>pcap
</code></pre> 
<p>这将把捕获到的 HTTP 流量保存到名为 data.pcap 的文件中。<br> 了解：pcap 后缀的文件通常与 PCAP（Packet Capture）文件格式相关，这是一种用于捕获网络数据包的文件格式</p> 
<ol start="6"><li><strong>从文件中读取数据包进行分析</strong></li></ol> 
<p>使用 -r 选项可以从文件中读取数据包进行分析。例如：</p> 
<pre><code class="prism language-c">Bash
tcpdump <span class="token operator">-</span>r data<span class="token punctuation">.</span>pcap
</code></pre> 
<p>这将读取 data.pcap 文件中的数据包并进行分析。<br> 注意事项</p> 
<ul><li>使用 tcpdump 时，请确保你有足够的权限来捕获网络接口上的数据包。通常，你需要以 root 用户身份运行 tcpdump。</li><li>使用 tcpdump 的时候，有些主机名会被云服务器解释成为随机的主机名，如果不想要，就用-n 选项</li><li>主机观察三次握手的第三次握手，不占序号</li></ul> 
<h3><a id="43_97"></a>4.3测试</h3> 
<ol><li>三次握手和四次挥手<br> <img src="https://images2.imgbox.com/14/6e/oIPdFEXK_o.png" alt="在这里插入图片描述"></li></ol> 
<p>上面的是三次握手，下面的是四次挥手。但是我们会发现四次挥手怎么变成了三次挥手呢？我们之前也是讲过了原理的，虽然客户端立马就关闭了，如果服务端也立马进行关闭了，也就是说客户端关闭的瞬间，服务端响应ACK报文的同时也发送了断开连接的请求，这个时候就可以进行捎带应答了。如果我们要看到全过程，只需要控制客户端和用户端断开连接的时机不同即可。</p> 
<p><img src="https://images2.imgbox.com/a9/61/8qlPGQi1_o.png" alt="在这里插入图片描述"><br> 这个时候就可以看到四次挥手的过程了</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ed54d4b7325da2e21af2d6d8c41ca78/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue3使用el-table实现多级表头合并列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08a9958add770cafecd72ee1f0cfc21f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">史上最全C/C&#43;&#43;面试、C&#43;&#43;面经八股文，一文带你彻底搞懂C/C&#43;&#43;面试、C&#43;&#43;面经！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>