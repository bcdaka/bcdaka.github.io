<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go中的并发处理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/516ff4808d6bd0b6d1bb84d0ea45028a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="go中的并发处理">
  <meta property="og:description" content=". Goroutines 概念：
Goroutines 是 Go 的核心并发机制。它们是由 Go 运行时管理的轻量级线程，具有比操作系统线程更少的开销。每个 goroutine 只需少量的内存（大约 2KB），并且由 Go 运行时负责调度和管理,哪怕是java发展到21的虚拟线程和go比也还是不够轻量
创建：
go func() { fmt.Println(&#34;Hello from goroutine&#34;) }() 使用 go 关键字前缀一个函数调用即可创建一个新的 goroutine。它将异步执行指定的函数。
调度模型：
Go 使用 M调度模型，其中 M 个用户级线程（goroutines）通过 N 个操作系统线程（OS threads）进行调度。Go 运行时会动态地将 goroutines 分配到操作系统线程上，减少了上下文切换的开销。
底层原理：
Go 的调度器使用协作式调度，依靠 goroutine 的堆栈跟踪（stack traces）和调度策略（如抢占式调度）来管理并发执行。调度器负责在 goroutines 和 OS threads 之间进行合理分配，以实现高效的并发执行。
###Channel
概念：
Channel 是用于 goroutine 之间通信的管道，可以安全地传递数据。它们实现了数据传递的同步机制，避免了传统的锁竞争问题。
创建：
ch := make(chan int) 发送和接收：
// 发送数据 ch &lt;- 42 // 接收数据 value := &lt;-ch //数据通过 &lt;- 操作符在 channel 中发送和接收。发送操作会阻塞直到有接收方，接收操作会阻塞直到有发送方。 这样就可以简单模拟java的join 操作 ,只有上一个任务执行完才允许接下来的线程执行">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-21T14:19:35+08:00">
    <meta property="article:modified_time" content="2024-08-21T14:19:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go中的并发处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_Goroutines_1"></a>. Goroutines</h4> 
<p>概念：</p> 
<blockquote> 
 <p>Goroutines 是 Go 的核心并发机制。它们是由 Go 运行时管理的轻量级线程，具有比操作系统线程更少的开销。每个 goroutine 只需少量的内存（大约 2KB），并且由 Go 运行时负责调度和管理,哪怕是java发展到21的虚拟线程和go比也还是不够轻量</p> 
</blockquote> 
<p>创建：</p> 
<pre><code class="prism language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello from goroutine"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>使用 go 关键字前缀一个函数调用即可创建一个新的 goroutine。它将异步执行指定的函数。<br> 调度模型：</p> 
<blockquote> 
 <p>Go 使用 M调度模型，其中 M 个用户级线程（goroutines）通过 N 个操作系统线程（OS threads）进行调度。Go 运行时会动态地将 goroutines 分配到操作系统线程上，减少了上下文切换的开销。<br> 底层原理：<br> Go 的调度器使用协作式调度，依靠 goroutine 的堆栈跟踪（stack traces）和调度策略（如抢占式调度）来管理并发执行。调度器负责在 goroutines 和 OS threads 之间进行合理分配，以实现高效的并发执行。<br> ###Channel</p> 
</blockquote> 
<p>概念：<br> Channel 是用于 goroutine 之间通信的管道，可以安全地传递数据。它们实现了数据传递的同步机制，避免了传统的锁竞争问题。<br> 创建：</p> 
<pre><code class="prism language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre> 
<p>发送和接收：</p> 
<pre><code class="prism language-go"><span class="token comment">// 发送数据</span>
ch <span class="token operator">&lt;-</span> <span class="token number">42</span>

<span class="token comment">// 接收数据</span>
value <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
<span class="token comment">//数据通过 &lt;- 操作符在 channel 中发送和接收。发送操作会阻塞直到有接收方，接收操作会阻塞直到有发送方。</span>
</code></pre> 
<p>这样就可以简单模拟java的join 操作 ,只有上一个任务执行完才允许接下来的线程执行</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">testTrueCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//如果是无缓冲的 需要立即读取 所以异步写入</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
		ch <span class="token operator">&lt;-</span> <span class="token string">"hello"</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch<span class="token punctuation">)</span><span class="token comment">//不采用读取 那么可能子携程还没有执行主协诚就结束了</span>
	fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"这个输出第一是在hello之后"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>缓冲区：</p> 
<p>无缓冲 channel：发送和接收操作必须匹配，否则会阻塞。<br> 注意 串行的代码块不能写如通道会立即死锁 ，因为 无缓冲通道在写入数据时必须立刻有其他协程来读取数据，否则会导致阻塞。串行中，写入数据和读取数据是在同一个协程中进行的，阻塞后根本不会执行下一个代码 这会导致死锁。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">testFialChannelCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 创建无缓冲管道</span>
	ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// 正因为无缓冲管道无法存放数据，在向管道写入数据时必须立刻有其他协程来读取数据</span>
	<span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>

	<span class="token comment">// 启动一个新的协程来读取数据</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		n <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 写入数据</span>
	ch <span class="token operator">&lt;-</span> <span class="token number">123</span> <span class="token comment">// 不在串行 写入后必须读取 没有容量可以保存 会报错</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/8a/31/EuoaOd5N_o.png" alt="在这里插入图片描述"></p> 
<p>缓冲 channel：创建时指定缓冲区大小，发送操作只有在缓冲区满时才会阻塞，接收操作只有在缓冲区空时才会阻塞。<br> go</p> 
<pre><code class="prism language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个缓冲区大小为 2 的 channel</span>
</code></pre> 
<p>关闭：</p> 
<p>可以使用 close 函数关闭 channel，以表明没有更多数据将被发送。</p> 
<pre><code class="prism language-go"><span class="token comment">//建议创建号channel后就使用</span>
 <span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
关闭后的 channel 仍然可以读取数据，但不能再发送数据。读取操作会返回 channel 的零值。
</code></pre> 
<p>底层原理：</p> 
<blockquote> 
 <p>Channel 是基于锁和条件变量实现的。每个 channel 有一个缓冲区和一个互斥锁，用于协调数据的发送和接收操作。</p> 
</blockquote> 
<p>只读通道和只写通道的申明创建</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> ch <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span> <span class="token comment">// 只读通道，只能接收 int 类型的数据</span>
<span class="token keyword">var</span> ch <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span> <span class="token comment">// 只写通道，只能发送 int 类型的数据</span>


</code></pre> 
<h4><a id="WaitGroup_112"></a>WaitGroup</h4> 
<p>刚才使用无缓冲的通道模拟 java中的join api 效果<br> 概念：</p> 
<blockquote> 
 <p>sync.WaitGroup 用于等待一组 goroutine 完成任务，确保所有并发操作完成后才继续执行。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">var</span> wg <span class="token class-name"><span class="token namespace">sync<span class="token punctuation">.</span></span>WaitGroup</span>
<span class="token class-name"><span class="token namespace">wg<span class="token punctuation">.</span></span>Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 增加等待计数</span>
go <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    defer <span class="token class-name"><span class="token namespace">wg<span class="token punctuation">.</span></span>Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 任务完成时减少计数</span>
    <span class="token comment">// 任务代码</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name"><span class="token namespace">wg<span class="token punctuation">.</span></span>Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 等待所有任务完成</span>
</code></pre> 
<p>底层就是维护了一个原子性的任务数 wg.Done() 进行任务数自减1wg.Wait() // 等待所有任务完成 只有为0才会进行执行</p> 
<p>这样就更直观的可以发出来 可以保证多个无序携程的有序性</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">quicktest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> wait sync<span class="token punctuation">.</span>WaitGroup
	<span class="token comment">// 指定子协程的数量  本质是原子性的自增自减</span>
	wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//自增</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token comment">// 执行完毕</span>
		wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//自减</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 等待子协程</span>
	wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//判断是否为0 阻塞等待 只有为0才会继续执行 这样就保证了执行的有序性</span>
	wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
		<span class="token comment">// 执行完毕</span>
		wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//自减</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
		<span class="token comment">// 执行完毕</span>
		wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//自减</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
		<span class="token comment">// 执行完毕</span>
		wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//自减</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 等待子协程</span>
	wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//判断是否为0 阻塞等待</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"完成"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="Select_171"></a>Select</h4> 
<p>概念：</p> 
<blockquote> 
 <p>select 语句允许一个 goroutine 等待多个 channel 操作，并在其中一个操作准备好时执行相应的代码块。它类似于 Java 中的 Selector，用于处理多个异步事件,和netty一样 用到了seletor 多路复用思想<br> 使用：</p> 
</blockquote> 
<p>go<br> 基本用法 类似 swtich case go中的stich 不会像Java一样需要显示申明return返回</p> 
<pre><code class="prism language-go"><span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received from ch1:"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
<span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Received from ch2:"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Timeout"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>select 语句会阻塞，直到其中一个 case 准备好。time.After 是一个用于超时的示例，它创建一个定时器 channel。<br> 默认分支：</p> 
<p>可以使用 default 分支来避免 select 阻塞。</p> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	chA <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	chB <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	chC <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">close</span><span class="token punctuation">(</span>chA<span class="token punctuation">)</span>
		<span class="token function">close</span><span class="token punctuation">(</span>chB<span class="token punctuation">)</span>
		<span class="token function">close</span><span class="token punctuation">(</span>chC<span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 开启一个新的协程</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 向A管道写入数据</span>

		chA <span class="token operator">&lt;-</span> <span class="token number">1</span>

	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 向A管道写入数据</span>

		chB <span class="token operator">&lt;-</span> <span class="token number">1</span>

	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 向A管道写入数据</span>

		chC <span class="token operator">&lt;-</span> <span class="token number">1</span>

	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 选择器 这样就可以监控 多个通道 有数据的时候就触发 如果都没有数据 就阻塞</span>
	<span class="token comment">// 这里的select 语句会阻塞，直到有某个通道有数据可读</span>
	<span class="token comment">//如果都同时 检查到有数据可读，则随机选择一个进行读取</span>
Loop<span class="token punctuation">:</span> <span class="token comment">//break Loop 后不会执行:后的代码了</span>
	<span class="token keyword">for</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">case</span> n<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>chA<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"写入通道A"</span><span class="token punctuation">)</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
		<span class="token keyword">case</span> n<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>chB<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"写入通道B"</span><span class="token punctuation">)</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
		<span class="token keyword">case</span> n<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>chC<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"写入通道C"</span><span class="token punctuation">)</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
			<span class="token comment">//超时时间跳出进行下一次循环</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">// 设置1秒的超时时间 //返回只读通通道</span>
			<span class="token keyword">break</span> Loop <span class="token comment">// 退出循环 避免死循环锁毒素 还可以一直监听</span>

		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre> 
<p>底层原理：</p> 
<blockquote> 
 <p>select 通过轮询和系统调用来检查多个 channel 的状态，使用系统级的 poll 或 epoll（在 Linux 上）机制来实现高效的 I/O 多路复用。</p> 
</blockquote> 
<h4><a id="_258"></a>锁</h4> 
<p>go中的锁也相对轻量</p> 
<h5><a id="Mutex_260"></a>Mutex（互斥锁）：</h5> 
<p>概念：</p> 
<blockquote> 
 <p>sync.Mutex 用于保护临界区，确保在同一时间只有一个 goroutine 可以访问共享资源。</p> 
</blockquote> 
<p>使用：</p> 
<pre><code class="prism language-go"><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex
mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 临界区代码</span>
mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>比如这种代码进行应用</p> 
<pre><code class="prism language-go"><span class="token comment">/*
*
这种情况肯定是脏数据的 10个携程并发执行肯定有脏数据 并且还无法确 还没有等待确定有序性

解决方案：
. 加锁 互斥锁l
*/</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 等待10个协程完成</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>data <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 模拟访问耗时</span>
			<span class="token comment">// 加锁 同一时间只有有所的次啊可以执行</span>
			lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token comment">// 访问数据</span>
			temp <span class="token operator">:=</span> <span class="token operator">*</span>data
			<span class="token comment">// 模拟计算耗时</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			ans <span class="token operator">:=</span> <span class="token number">1</span>
			<span class="token comment">// 修改数据</span>
			<span class="token operator">*</span>data <span class="token operator">=</span> temp <span class="token operator">+</span> ans

			lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//数据修改完毕了才可以解锁</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>data<span class="token punctuation">)</span>
			wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"最终结果"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>只有数据处理时候加锁才能保证有序性,多个携程并发处理数据 会造成脏数据</p> 
<p>底层原理：基于自旋锁和操作系统的原子操作实现，使用互斥锁来保护数据的一致性。</p> 
<h5><a id="RWMutex_313"></a>RWMutex（读写锁）：</h5> 
<p>概念：</p> 
<blockquote> 
 <p>sync.RWMutex 允许多个 goroutine 同时读取数据，但在写操作时独占访问。本质就是为了优化读写分离的情况,写锁还是写携程之间互斥,读锁是为了保证有读锁的携程允许时候写锁的携程就堵塞</p> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	wait<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment">//12个任务携程</span>

	<span class="token comment">// 读多写少</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">go</span> <span class="token function">Write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">go</span> <span class="token function">Read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 等待子协程结束</span>
	wait<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"最终结果"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Read</span><span class="token punctuation">(</span>i <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	rw<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"拿到读锁"</span><span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"释放读锁"</span><span class="token punctuation">,</span> <span class="token operator">*</span>i<span class="token punctuation">)</span>
	rw<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Write</span><span class="token punctuation">(</span>i <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	rw<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"拿到写锁"</span><span class="token punctuation">)</span>
	temp <span class="token operator">:=</span> <span class="token operator">*</span>i
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond <span class="token operator">*</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token operator">*</span>i <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"释放写锁"</span><span class="token punctuation">,</span> <span class="token operator">*</span>i<span class="token punctuation">)</span>
	rw<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	wait<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="Context_364"></a>Context</h4> 
<p>概念：</p> 
<p>context 包用于在 goroutine 中传递取消信号、截止时间和请求范围的信息，类似于 Java 中的 Future 或 ExecutorService 的取消机制。</p> 
<p>在 Go 中，context 包提供了上下文管理的功能，主要用于控制 goroutine 的生命周期、传递请求范围的值以及处理超时和取消信号。context 是在并发编程中不可或缺的工具，尤其是在处理网络请求和后台任务时。</p> 
<p>Context 的主要用途</p> 
<ul><li> <p>控制 goroutine 的生命周期：通过 context，你可以在父任务结束或取消时，通知所有子 goroutine 停止执行，从而避免 goroutine 泄漏。</p> </li><li> <p>传递请求范围的值：context 可以在函数调用链之间传递值，这些值通常是与请求有关的信息，比如用户身份、授权令牌、请求截止时间等。</p> </li><li> <p>处理超时和取消信号：context 可以设定超时时间或在外部取消信号时终止操作，这对于网络请求和长时间运行的任务非常有用。</p> </li></ul> 
<p>Context 的类型</p> 
<ul><li>context.Background()：通常作为主函数的起点使用，表示一个空的上下文。</li><li>context.TODO()：当你还不确定要用什么样的上下文时，可以使用它作为占位符。</li></ul> 
<p>Context 的使用模式<br> 在实际编程中，context 通常以以下几种方式使用：</p> 
<p>取消任务：<br> 当需要在某个操作完成后取消所有相关的 goroutine 时，使用 context.WithCancel。<br> 超时控制：<br> 当一个操作需要在指定时间内完成时，使用 context.WithTimeout。<br> 截止时间控制：<br> 与超时类似，但使用的是具体的时间点而不是时间间隔，使用 context.WithDeadline。<br> Context 实例详细讲解<br> go</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"context"</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 模拟一个处理请求的函数</span>
<span class="token keyword">func</span> <span class="token function">processRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> duration time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">select</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>duration<span class="token punctuation">)</span><span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Request processed"</span><span class="token punctuation">)</span>
    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Request canceled:"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建一个 context，设置超时时间为 3 秒</span>
    ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
    <span class="token keyword">defer</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 确保取消函数被调用，以释放资源</span>

    <span class="token comment">// 启动一个 goroutine 来处理请求，预计处理时间为 5 秒</span>
    <span class="token keyword">go</span> <span class="token function">processRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>

    <span class="token comment">// 模拟一些其他操作</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
    
    <span class="token comment">// 主 goroutine 等待 6 秒，以便观察子 goroutine 的处理情况</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Main function ends"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>详细解释<br> 创建 Context：context.WithTimeout(context.Background(), 3*time.Second) 创建了一个有超时限制的 context，3 秒后自动取消。<br> 处理请求：processRequest 是一个模拟的请求处理函数，它要么在指定的 duration 后完成请求处理，要么在 context 被取消时停止操作。<br> 启动 goroutine：我们在主函数中启动了一个 goroutine 来处理请求，这个 goroutine 模拟了一个 5 秒的处理时间。<br> 观察取消效果：由于 context 设置的超时时间是 3 秒，而请求的处理时间是 5 秒，3 秒后 context 会被自动取消，导致 processRequest 提前退出并输出取消原因。<br> 实际用途<br> 在实际应用中，context 经常用于以下场景：</p> 
<p>API 请求的超时控制：确保 API 请求在设定的时间内完成，避免服务阻塞。<br> 批量任务的并发处理：在父任务取消时，自动终止所有子任务，避免资源浪费。<br> 数据库操作：结合 context 来设置数据库查询的超时时间，确保数据库操作不会无限制地阻塞。</p> 
<h4><a id="go_443"></a>go中的池化技术–工作池</h4> 
<p>即使 Goroutine 很轻量，但在某些情况下，仍需要限制同时运行的 Goroutine 数量：</p> 
<p>资源限制：</p> 
<blockquote> 
 <p>当每个任务都涉及到大量的资源（如 CPU、内存、网络）时，过多的 Goroutine 会导致资源竞争，影响系统性能。<br> 后端服务限制：如果你的程序需要调用外部服务或数据库，这些服务可能有并发连接的限制，需要控制并发量。<br> 稳定性和可控性：使用工作池可以更好地管理任务的执行，提供任务队列、超时、重试等机制，提升系统的稳定性和可靠性。<br> 工作池的作用：</p> 
</blockquote> 
<p>限制并发数：</p> 
<blockquote> 
 <p>通过固定数量的工作 Goroutine，限制同时执行的任务数量。<br> 任务调度：将任务放入队列，等待空闲的 Worker 处理。<br> 结果收集：汇总任务执行的结果，方便后续处理。<br> 错误处理：统一管理任务执行中的错误和异常。</p> 
</blockquote> 
<p>在 Go 中，实现工作池通常有以下几种方式：</p> 
<p>使用 Channel 实现简单的工作池：通过创建一定数量的 Worker Goroutine，从任务 Channel 中获取任务并执行。<br> 使用同步包（如 sync.WaitGroup）协调任务执行：确保所有任务执行完毕后再进行后续操作。<br> 使用第三方库：社区中有一些成熟的工作池库，如 antlabs/workerpool、gammazero/workerpool 等，提供了丰富的功能和更好的性能。<br> 接下来，下面的代码示例来演示如何在 Go 中实现工作池。</p> 
<pre><code class="prism language-go">
<span class="token comment">// 任务类型</span>
<span class="token keyword">type</span> Task <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	id <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token comment">// 模拟处理任务的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t Task<span class="token punctuation">)</span> <span class="token function">Process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Processing task with id: %d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// 模拟任务处理耗时</span>
<span class="token punctuation">}</span>

<span class="token comment">// 工作池函数</span>
<span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">,</span> tasks <span class="token operator">&lt;-</span><span class="token keyword">chan</span> Task<span class="token punctuation">,</span> wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> task <span class="token operator">:=</span> <span class="token keyword">range</span> tasks <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Worker %d started task %d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> task<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
		task<span class="token punctuation">.</span><span class="token function">Process</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Worker %d finished task %d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> task<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> numWorkers <span class="token operator">=</span> <span class="token number">3</span> <span class="token comment">// Worker 的数量</span>
	<span class="token keyword">const</span> numTasks <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment">// 任务的数量</span>

	tasks <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> Task<span class="token punctuation">,</span> numTasks<span class="token punctuation">)</span> <span class="token comment">// 创建一个任务通道</span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup

	<span class="token comment">// 启动 worker</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> numWorkers<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> tasks<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wg<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 发送任务到任务通道</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> numTasks<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		tasks <span class="token operator">&lt;-</span> Task<span class="token punctuation">{<!-- --></span>id<span class="token punctuation">:</span> i<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token function">close</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span> <span class="token comment">// 关闭任务通道，不再发送新任务</span>

	<span class="token comment">// 等待所有 worker 完成</span>
	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"All tasks processed"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>


</code></pre> 
<p>详细解释</p> 
<ul><li>Task 类型：</li></ul> 
<p>这是一个简单的任务类型，其中包含了任务的 ID。Process 方法模拟任务的处理过程。<br> Worker 函数：</p> 
<p>worker 函数是每个 worker 执行的工作。它从 tasks 通道中接收任务，并调用 Process 方法处理任务。sync.WaitGroup 用于等待所有 worker 完成任务。</p> 
<ul><li>启动 Worker：</li></ul> 
<p>numWorkers 决定了 worker 的数量。在这里，启动了 3 个 worker。<br> 发送任务：</p> 
<ul><li>将 numTasks 数量的任务发送到 tasks 通道，任务会被 worker 逐一处理。<br> 关闭通道：</li></ul> 
<p>任务发送完毕后，关闭任务通道，告诉所有 worker 没有更多的任务了。<br> 等待所有 Worker 完成：</p> 
<p>使用 sync.WaitGroup 确保主程序在所有 worker 完成任务后再退出。</p> 
<p>Java 线程池通过 Executors 工具类来创建不同类型的线程池，Go 则通过自定义的 worker pool 和 goroutine 来管理并发</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96c661743e19c0c83ce9afe41d6657e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Django 后端架构开发：JWT 项目实践与Drf版本控制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc86f1705984559793becca4f7d43466/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML对信息化大屏的像素适应解决方案autofit.js</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>