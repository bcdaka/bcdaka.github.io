<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图论------迪杰斯特拉（Dijkstra）算法求单源最短路径。 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3a7ccc46ccdf1dc13bec3f531561a5a1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="图论------迪杰斯特拉（Dijkstra）算法求单源最短路径。">
  <meta property="og:description" content="编程要求 在图的应用中，有一个很重要的需求：我们需要知道从某一个点开始，到其他所有点的最短路径。这其中，Dijkstra 算法是典型的最短路径算法。
本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，实现 Dijkstra 算法求单源最短路径，具体要求如下：
补全代码 int[] Paths(int source) 方法，实现 Dijkstra 算法；
输出源点 source 到其他各个定点的距离，如果不可达，则距离输出 INF。
测试举例
测试过程：
平台将创建用户补全后的ShortestPath类的对象；
调用对象的addEdge(int u, int v, int w)方法，添加边和边的权重信息，构建图G；
调用对象的Paths(int source)方法执行Dijkstra算法，求最短路径，并输出返回的最短路径，这里源点设置为1；
接着根据程序的输出判断程序是否正确。
以下是测试样例：
测试输入：
5 7
1 2 8
1 3 1
1 4 2
3 4 2
2 4 3
3 5 3
4 5 3
(5 和 7 分别表示顶点数和边数)
预期输出：
0 5 1 2 4 思路解析： 求单源最短路径就是求一个点到除它以外所有点的最短距离，首先我们还是用邻接矩阵来储存图的信息。以测试输入为例，示意图如下。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T22:43:51+08:00">
    <meta property="article:modified_time" content="2024-08-13T22:43:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图论------迪杰斯特拉（Dijkstra）算法求单源最短路径。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#0d0016;">编程要求</span></h2> 
<p><br><span style="color:#0d0016;"><strong>在图的应用中，有一个很重要的需求：我们需要知道从某一个点开始，到其他所有点的最短路径。这其中，Dijkstra 算法是典型的最短路径算法。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，实现 Dijkstra 算法求单源最短路径，具体要求如下：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>补全代码 int[] Paths(int source) 方法，实现 Dijkstra 算法；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>输出源点 source 到其他各个定点的距离，如果不可达，则距离输出 INF。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>测试举例<br> 测试过程：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>平台将创建用户补全后的ShortestPath类的对象；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>调用对象的addEdge(int u, int v, int w)方法，添加边和边的权重信息，构建图G；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>调用对象的Paths(int source)方法执行Dijkstra算法，求最短路径，并输出返回的最短路径，这里源点设置为1；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>接着根据程序的输出判断程序是否正确。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>以下是测试样例：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>测试输入：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>5 7<br> 1 2 8<br> 1 3 1<br> 1 4 2<br> 3 4 2<br> 2 4 3<br> 3 5 3<br> 4 5 3<br> (5 和 7 分别表示顶点数和边数)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>预期输出：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>0 5 1 2 4 </strong></span></p> 
<h2><span style="color:#0d0016;"><strong>思路解析：</strong></span></h2> 
<p><span style="color:#0d0016;"><strong>        求单源最短路径就是求一个点到除它以外所有点的最短距离，首先我们还是用邻接矩阵来储存图的信息。以测试输入为例，示意图如下。</strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong><img alt="" src="https://images2.imgbox.com/4c/c4/LYDt8SrI_o.png"></strong></span></p> 
<hr> 
<p>        <strong><span style="color:#0d0016;">既然是求1的单源最短路径，那我们就定义一个数组dic[n+1],将dic初始化存储从1到所有点的直接距离。比如dic[1]到dic[5]分别是【0，8，1，2，99999999】，因为1无法直接到5，所以初始化为99999999。</span></strong></p> 
<p><strong><span style="color:#0d0016;">        然后找出dic里面1到2-n之间的最短距离，发现是dic[3] = 1,然后找1通过3能到达的地方，发现能到达4和5，如果1通过3到达4的话，得出dic[4] = 2 &lt; dic[3]+arr[3][4] = 3，无法使到四的路程更短，所以不改变dic[4]的值，但是我们发现到达5，即dic[5] = 99999999&gt;dic[3]+arr[3][5] = 4,能使1到5距离缩短，于是改变dic[5]的值。这样我们就得到能通过3进行优化一轮路径，学术名叫做松弛。</span></strong></p> 
<p style="text-align:center;"><strong><span style="color:#0d0016;">        <img alt="" src="https://images2.imgbox.com/7b/bc/4LZbm68r_o.png"></span></strong></p> 
<hr> 
<p><strong><span style="color:#0d0016;">        我们知道，如果已经通过3实现了一轮优化，那么我们将进一步缩短路程的话，是不能走回头路的，因为如果再次经过3的话没有意义，所以最短路没有重复路径。</span></strong></p> 
<p><strong><span style="color:#0d0016;">        那么我们就要定义一个数组来存储已经作为转点进行一轮松弛的点，我们可以定义book[n+1]来存储。将作为转点的点比如3，用book[3] = 1，表示已经使用过。</span></strong></p> 
<p><strong><span style="color:#0d0016;">        之后便是重复步骤，找除去dic[3]以外的最小值，也就是dic[4],继续进行一轮松弛，将4这个点用book[4] = 1,表示已经使用过。</span></strong></p> 
<p><strong><span style="color:#0d0016;">        之后的图大家可以自己试着来画出。</span></strong></p> 
<p></p> 
<h2><span style="color:#0d0016;">具体代码：</span></h2> 
<p><span style="color:#0d0016;"><strong>#include&lt;stdio.h&gt;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>int main(void)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>{<!-- --></strong></span></p> 
<p><span style="color:#0d0016;"><strong>    int arr[100][100] = { 0 };</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    int dic[100];</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    int book[100] = { 0 };</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    int m, n, a, b, c, u, v;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    int inf = 99999999;</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>    scanf("%d%d", &amp;n, &amp;m);</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>    for (int i = 1; i &lt;= n; i++)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        for (int j = 1; j &lt;= n; j++)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>            if (i == j)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                arr[i][j] = 0;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>            else</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                arr[i][j] = inf;</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>    for (int i = 1; i &lt;= m; i++)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    {<!-- --></strong></span></p> 
<p><span style="color:#0d0016;"><strong>        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        arr[a][b] = c;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        arr[b][a] = c;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    }</strong></span><span style="color:#956fe7;"><strong>//无向图初始化。</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>    for (int i = 1; i &lt;= n; i++)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        dic[i] = arr[1][i];</strong></span><span style="color:#956fe7;"><strong>//初始化dic数组</strong></span></p> 
<p><br>  </p> 
<p><span style="color:#0d0016;"><strong>    for (int i = 1; i &lt;= n - 1; i++)</strong></span><span style="color:#956fe7;"><strong>//最多要进行n-1轮松弛，i值不会使用，仅仅表示循环多少轮。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    {<!-- --></strong></span></p> 
<p><span style="color:#0d0016;"><strong>        int min = inf;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        for (int j = 2; j &lt;= n; j++)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        {<!-- --></strong></span></p> 
<p><span style="color:#0d0016;"><strong>            if (book[j] == 0 &amp;&amp; dic[j] &lt; min)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>            {<!-- --></strong></span></p> 
<p><span style="color:#0d0016;"><strong>                min = dic[j];</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                u = j;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>            }</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        }</strong></span><span style="color:#956fe7;"><strong>//找出从1到任意数字的最短值。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        book[u] = 1;</strong></span><span style="color:#956fe7;"><strong>//将该位置提前存储，表示已经使用过。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        for (v = 2; v &lt;= n; v++)</strong></span><span style="color:#956fe7;"><strong>//优化1通过u到所有点的路径。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        {<!-- --></strong></span></p> 
<p><span style="color:#0d0016;"><strong>            if (arr[u][v] &lt; inf)</strong></span><span style="color:#956fe7;"><strong>//如果u到v没有通路，也就没办法优化。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>            {<!-- --></strong></span></p> 
<p><span style="color:#0d0016;"><strong>                if (dic[v] &gt; dic[u] + arr[u][v])</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                    dic[v] = dic[u] + arr[u][v];</strong></span><span style="color:#956fe7;"><strong>//优化赋值过程。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>            }</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        }</strong></span></p> 
<p><span style="color:#0d0016;"><strong>    }</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>    for (int i = 1; i &lt;= n; i++)</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        printf("%d ", dic[i]);</strong></span><span style="color:#956fe7;"><strong>//打印结果。</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>    return 0;</strong></span></p> 
<p><span style="color:#0d0016;"><strong>}</strong></span></p> 
<p></p> 
<h2><span style="color:#0d0016;"><strong>注意：</strong></span></h2> 
<p><span style="color:#0d0016;"><strong>        实际上迪杰斯特拉算法可以看作是贪心算法，通过每一步的最优解组合成全局最优解，感兴趣的同学们可以去网上查找关于贪心算法的知识，这种类型的题目我们以后也会分享。</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31f39e2d59c1ace595bb7d96c8cd45b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据沙箱：构建安全的数据分析堡垒</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf1a57bf45dba63e2a8381e087a59185/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多字段聚合查询在Elasticsearch中的实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>