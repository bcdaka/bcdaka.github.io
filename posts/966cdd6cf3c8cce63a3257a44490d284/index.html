<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python requests 模块 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/966cdd6cf3c8cce63a3257a44490d284/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python requests 模块">
  <meta property="og:description" content="爬虫、网络编程、接口......对于Python工程师来讲都绕不过一个强大的模块---requests，本篇文章就深入详细讲一讲requests模块。同时也先也分享一下开源API网站：Gitee-API文档、JSONPlaceholder API文档、和风天气API文档、Postman Echo API网站，这四个网站都适合入门级的requests库实战操作。
目录
一、requests库简介
二、安装与导入
三、核心组件及其常见属性
1、request
2、response
3、session
四、不同HTTP请求示例
1、GET请求
2、POST请求
提交请求体表单数据示例：
发送JSON数据示例：
3、PUT请求
4、DELETE请求
5、PATCH请求
6、上传文件
五、请求头管理
六、Session实现会话管理
1、通过Session对象设置全局请求头及全局参数
2、通过Session对象管理cookie：
3、通过Session对象显示操作cookie
一、requests库简介 使用requests库能快速构建 HTTP 请求，而无需深入了解底层网络协议细节。其API设计直观，使得发送请求就像调用函数一样简单，同时提供了丰富的选项以满足复杂网络交互的需求。这种设计使得无论是初学者还是经验丰富的开发者都能高效地使用 Requests 进行网络编程。
requests的特点如下：
全面的 HTTP 支持: 支持所有 HTTP 方法（GET、POST、PUT、DELETE、PATCH 等），以及常见的 HTTP 特性，如 cookies、重定向、压缩、认证、代理、连接池等。自动内容处理: 自动解码响应内容，支持 JSON、HTML、XML 等常见格式，并可通过 .text 和 .content 属性直接访问解码后的文本或原始二进制数据。便捷的请求构建: 可轻松设置请求头、查询参数、请求体、认证信息等，支持多部分表单上传、文件上传、JSON 数据发送等。灵活的会话管理: 提供 Session 对象，用于维护请求之间的状态（如 cookies、headers），并支持连接池复用，提高性能。强大的异常处理: 提供明确的异常层次结构，如 requests.exceptions.RequestException、requests.exceptions.HTTPError，便于捕获和处理网络错误、HTTP 状态码异常等。广泛的兼容性: 支持 Python 2.7 及更高版本的 Python 3.x，与各种操作系统兼容。 Requests 基于 urllib3 模块构建，后者负责底层的网络通信。Requests 采用 Apache2 Licensed 开源协议，这意味着它是一个免费且开放源代码的软件，允许在商业和非商业项目中自由使用、修改和分发。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-09T22:17:38+08:00">
    <meta property="article:modified_time" content="2024-04-09T22:17:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python requests 模块</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>爬虫、网络编程、接口......对于Python工程师来讲都绕不过一个强大的模块---requests，本篇文章就深入详细讲一讲requests模块。同时也先也分享一下开源API网站：<a class="link-info" href="https://gitee.com/api/v5/swagger" rel="nofollow" title="Gitee-API文档">Gitee-API文档</a>、<a class="link-info" href="https://jsonplaceholder.typicode.com/" rel="nofollow" title="JSONPlaceholder API文档">JSONPlaceholder API文档</a>、<a class="link-info" href="https://dev.qweather.com/docs/api/" rel="nofollow" title="和风天气API文档">和风天气API文档</a>、<a class="link-info" href="https://postman-echo.com/" rel="nofollow" title="Postman Echo API网站">Postman Echo API网站</a>，这四个网站都适合入门级的requests库实战操作。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81requests%E5%BA%93%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81requests%E5%BA%93%E7%AE%80%E4%BB%8B" rel="nofollow">一、requests库简介</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%BC%E5%85%A5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%BC%E5%85%A5" rel="nofollow">二、安装与导入</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7" rel="nofollow">三、核心组件及其常见属性</a></p> 
<p id="1%E3%80%81request-toc" style="margin-left:40px;"><a href="#1%E3%80%81request" rel="nofollow">1、request</a></p> 
<p id="2%E3%80%81response-toc" style="margin-left:40px;"><a href="#2%E3%80%81response" rel="nofollow">2、response</a></p> 
<p id="3%E3%80%81session-toc" style="margin-left:40px;"><a href="#3%E3%80%81session" rel="nofollow">3、session</a></p> 
<p id="%E5%9B%9B%E3%80%81%E4%B8%8D%E5%90%8CHTTP%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E4%B8%8D%E5%90%8CHTTP%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B" rel="nofollow">四、不同HTTP请求示例</a></p> 
<p id="1%E3%80%81GET%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#1%E3%80%81GET%E8%AF%B7%E6%B1%82" rel="nofollow">1、GET请求</a></p> 
<p id="2%E3%80%81POST%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#2%E3%80%81POST%E8%AF%B7%E6%B1%82" rel="nofollow">2、POST请求</a></p> 
<p id="%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82%E4%BD%93%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82%E4%BD%93%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow">提交请求体表单数据示例：</a></p> 
<p id="%E5%8F%91%E9%80%81JSON%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%8F%91%E9%80%81JSON%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow">发送JSON数据示例：</a></p> 
<p id="3%E3%80%81PUT%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#3%E3%80%81PUT%E8%AF%B7%E6%B1%82" rel="nofollow">3、PUT请求</a></p> 
<p id="4%E3%80%81DELETE%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#4%E3%80%81DELETE%E8%AF%B7%E6%B1%82" rel="nofollow">4、DELETE请求</a></p> 
<p id="5%E3%80%81PATCH%E8%AF%B7%E6%B1%82-toc" style="margin-left:40px;"><a href="#5%E3%80%81PATCH%E8%AF%B7%E6%B1%82" rel="nofollow">5、PATCH请求</a></p> 
<p id="6%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6" rel="nofollow">6、上传文件</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AE%A1%E7%90%86" rel="nofollow">五、请求头管理</a></p> 
<p id="%E5%85%AD%E3%80%81Session%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81Session%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86" rel="nofollow">六、Session实现会话管理</a></p> 
<p id="1%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0" rel="nofollow">1、通过Session对象设置全局请求头及全局参数</a></p> 
<p id="2%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86cookie%EF%BC%9A-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86cookie%EF%BC%9A" rel="nofollow">2、通过Session对象管理cookie：</a></p> 
<p id="3%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E6%98%BE%E7%A4%BA%E6%93%8D%E4%BD%9Ccookie-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E6%98%BE%E7%A4%BA%E6%93%8D%E4%BD%9Ccookie" rel="nofollow">3、通过Session对象显示操作cookie</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81requests%E5%BA%93%E7%AE%80%E4%BB%8B" style="background-color:transparent;">一、requests库简介</h2> 
<p>使用requests库能快速构建 HTTP 请求，而无需深入了解底层网络协议细节。其API设计直观，使得发送请求就像调用函数一样简单，同时提供了丰富的选项以满足复杂网络交互的需求。这种设计使得无论是初学者还是经验丰富的开发者都能高效地使用 Requests 进行网络编程。</p> 
<p>requests的特点如下：</p> 
<ul><li><strong>全面的 HTTP 支持:</strong> 支持所有 HTTP 方法（GET、POST、PUT、DELETE、PATCH 等），以及常见的 HTTP 特性，如 cookies、重定向、压缩、认证、代理、连接池等。</li><li><strong>自动内容处理: </strong>自动解码响应内容，支持 JSON、HTML、XML 等常见格式，并可通过 .text 和 .content 属性直接访问解码后的文本或原始二进制数据。</li><li><strong>便捷的请求构建: </strong>可轻松设置请求头、查询参数、请求体、认证信息等，支持多部分表单上传、文件上传、JSON 数据发送等。</li><li><strong>灵活的会话管理: </strong>提供 Session 对象，用于维护请求之间的状态（如 cookies、headers），并支持连接池复用，提高性能。</li><li><strong>强大的异常处理: </strong>提供明确的异常层次结构，如 requests.exceptions.RequestException、requests.exceptions.HTTPError，便于捕获和处理网络错误、HTTP 状态码异常等。</li><li><strong>广泛的兼容性:</strong> 支持 Python 2.7 及更高版本的 Python 3.x，与各种操作系统兼容。</li></ul> 
<p>Requests 基于 <code>urllib3</code> 模块构建，后者负责底层的网络通信。Requests 采用 <strong>Apache2 Licensed</strong> 开源协议，这意味着它是一个免费且开放源代码的软件，允许在商业和非商业项目中自由使用、修改和分发。</p> 
<p>Requests 的官方文档详尽且易于阅读，提供了丰富的示例和指南，是学习和查阅库功能的首要资源：<a class="link-info" href="https://requests.readthedocs.io/en/latest/index.html" rel="nofollow" title="Requests官方文档">Requests官方文档</a></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%BC%E5%85%A5">二、<strong>安装与导入</strong></h2> 
<p><strong>安装：</strong></p> 
<p>1、PC终端(CMD)：</p> 
<pre><code>python -m pip install requests</code></pre> 
<p>2、PyCharm终端：</p> 
<pre><code class="language-python">pip install requests</code></pre> 
<p><strong>导入：</strong></p> 
<pre><code class="language-python">import requests</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7">三、核心组件及其常见属性</h2> 
<h3 id="1%E3%80%81request">1、request</h3> 
<p style="margin-left:.0001pt;text-align:justify;">由于requests库主要用于客户端发起HTTP请求，它并不直接暴露一个名为Request的对象供开发者操作，而是提供了requests.Request类作为构建请求的基础，但通常用户更常与requests.Session及其实例方法（如.get()、.post()等）交互。请求构建过程中涉及的属性：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">属性名</p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;">说明</p> </td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">method</p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;">HTTP方法，如GET、POST、PUT、DELETE、PATCH 等</p> </td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">url</p> </td><td style="vertical-align:top;width:565px;">请求的目标URL</td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">params</p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;">附加到URL的查询参数（querystring）字典，用于构建URL的查询字符串。</p> </td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">headers</p> </td><td style="vertical-align:top;width:565px;">请求头字典，包含如<code>User-Agent</code>、<code>Accept</code>、<code>Content-Type</code>等键值对。</td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">auth</p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;">指定鉴权方式</p> </td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">cookies</p> </td><td style="vertical-align:top;width:565px;">请求携带的Cookie字典</td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">data</p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;">请求主体数据，可以是字节串、字符串（通常用于表单数据）</p> </td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">json</p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;">请求主体数据，可以是字节串、字符串（通常用于JSON对象）</p> </td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;">files</p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;">表单上传文件</p> </td></tr><tr><td style="vertical-align:top;width:123px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">proxies</span></p> </td><td style="vertical-align:top;width:565px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">proxies使用代理抓包</span></p> </td></tr></tbody></table> 
<p>请求方法及其区别：</p> 
<table><thead><tr><th>请求方法</th><th>功能与语义</th><th>参数位置</th><th>缓存</th><th>幂等性</th><th>安全性</th></tr></thead><tbody><tr><td>GET</td><td>从服务器获取指定资源</td><td>通常放在URL查询字符串中</td><td>响应通常可被缓存</td><td>是幂等的</td><td>相对安全，不改变服务器状态</td></tr><tr><td>PUT</td><td>更新或替换服务器上的现有资源</td><td>通常放在请求正文中，包含完整的资源表示</td><td>响应通常不应被缓存</td><td>应该是幂等的</td><td>相对安全，仅用于更新资源。恶意或错误请求可能导致数据被覆盖</td></tr><tr><td>POST</td><td>向服务器提交数据，用于创建新资源或执行操作</td><td>通常放在请求正文中，包含完整的资源表示或操作指令及数据</td><td>响应通常不应被缓存</td><td>不一定是幂等的，取决于具体操作</td><td>可能引发副作用，不仅用于创建资源，也可能执行非幂等操作</td></tr><tr><td>DELETE</td><td>请求服务器删除指定资源</td><td>通常放在URL路径中</td><td>响应通常不应被缓存</td><td>应该是幂等的</td><td>具有潜在破坏性，应确保只有授权用户能执行</td></tr><tr><td>PATCH</td><td>局部更新资源</td><td>通常放在请求正文中，描述资源需要更改的部分</td><td>响应通常不应被缓存</td><td>应该是幂等的</td><td>可能引发副作用，应确保只有授权用户能执行，并且请求体正确描述了期望的更改</td></tr></tbody></table> 
<h3 id="2%E3%80%81response">2、response</h3> 
<p>当使用requests库收到服务器的响应时，会得到一个requests.Response对象，其常见属性包括：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;">属性名</p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">说明</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">备注</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">status_code</span></p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">HTTP响应状态码</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">整数</span>如200、404、500等</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;">reason</p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">状态描述</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">字符串</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">headers</span></p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">响应头</span></p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">字典包含如<code>Content-Type</code>、<code>Set-Cookie</code>、<code>Server</code>等键值对。</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">cookies</span></p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">服务端响应的</span><span style="background-color:#ffff00;">cookies</span></p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">字典,可以传输</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">content</span></p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">二进制响应内容</span></p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;"></p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">text</span></p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">文本响应正文</span></p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;"></p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">json()</span></p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffff00;">将json响应正文转为dict</span></p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">是方法不是属性！如果响应内容是JSON格式，可以直接调用此属性解析为Python对象。</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;">url</p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">产生响应的URL</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">实际请求的URL（可能经过重定向）</p> </td></tr><tr><td style="vertical-align:top;width:79pt;">history</td><td style="vertical-align:top;width:159pt;">如果有重定向发生，包含一个响应历史列表</td><td style="vertical-align:top;width:188.1pt;"></td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;">elapsed</p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">请求耗时</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">大概值，不精确</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;">encoding</p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">编码方式</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">可修改</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;">request</p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">生成响应的request</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">Request实例对象</p> </td></tr><tr><td style="vertical-align:top;width:79pt;"> <p style="margin-left:.0001pt;text-align:justify;">ok</p> </td><td style="vertical-align:top;width:159pt;"> <p style="margin-left:.0001pt;text-align:justify;">请求是否成功，status_code小于400为真</p> </td><td style="vertical-align:top;width:188.1pt;"> <p style="margin-left:.0001pt;text-align:justify;">布尔值</p> </td></tr></tbody></table> 
<h3 id="3%E3%80%81session">3、session</h3> 
<p>requests.Session是一个高级接口，用于管理一系列相关的HTTP请求，并且支持会话保持（如自动处理Cookies）。其主要属性和方法包括：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:.0001pt;text-align:justify;">属性名</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">说明</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">备注</p> </td></tr><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:.0001pt;text-align:justify;">params</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:left;">附加到URL的参（querystring）</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;"></p> </td></tr><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:.0001pt;text-align:justify;">headers</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">自定义请求头(token)</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;"></p> </td></tr><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:.0001pt;text-align:justify;">auth</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">指定鉴权方式</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;"></p> </td></tr><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:.0001pt;text-align:justify;">cookies</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">添加Cookies</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:.0001pt;text-align:justify;">会话级的CookieJar对象，存储了所有通过此Session发送请求时接收到的Cookies。</p> </td></tr><tr><td style="vertical-align:top;width:142pt;">.get()、**.post()**等方法</td><td style="vertical-align:top;width:142.05pt;">用于发送HTTP请求</td><td style="vertical-align:top;width:142.05pt;">与直接使用requests.get()等函数相比，会利用会话级的状态。</td></tr></tbody></table> 
<h2 id="%E5%9B%9B%E3%80%81%E4%B8%8D%E5%90%8CHTTP%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B" style="background-color:transparent;">四、不同<strong>HTTP请求示例</strong></h2> 
<h3 id="1%E3%80%81GET%E8%AF%B7%E6%B1%82">1、GET请求</h3> 
<blockquote> 
 <p><strong>功能与语义</strong>： <code>GET</code>请求用于从服务器获取指定资源。发送<code>GET</code>请求相当于询问服务器：“请给我这个资源。”</p> 
 <p><strong>参数位置</strong>： <code>GET</code>请求的参数通常放在URL的查询字符串中，即URL后面以<code>?</code>开始的部分，参数之间用<code>&amp;</code>分隔，每个参数由键值对组成，键与值之间用等号 (<code>=</code>) 连接。例如：<code>https://example.com/api/resource?param1=value1&amp;param2=value2</code></p> 
 <p><strong>缓存</strong>： <code>GET</code>请求的响应通常被认为是安全可缓存的。浏览器、代理服务器和其他中间件可能会缓存<code>GET</code>请求的响应结果，以便在未来相同请求时直接使用缓存，而不是再次向服务器请求。</p> 
 <p><strong>幂等性</strong>： <code>GET</code>请求是幂等的，即多次执行相同<code>GET</code>请求（针对同一资源）应始终返回相同的响应结果，不会对服务器状态产生任何影响。</p> 
 <p><strong>安全性</strong>： 相对安全，因为它不改变服务器状态。</p> 
</blockquote> 
<p>示例：</p> 
<pre><code class="language-python">import requests
url_get='https://postman-echo.com/get?key1=value1&amp;key2=value2'
response = requests.get(url_get)
print(response.text)</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/14/e3/uOFWpBmz_o.png" width="842"></p> 
<p>设置查询参数示例：</p> 
<pre><code class="language-python">param={
    'key3':'value3',
    'key4':'value4',
    'key5':'value5',
}
response_get_param=requests.get(url_get,params=param)
print(response_get_param.url)
print(response_get_param.text)</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/f4/95/hTDkdxjl_o.png" width="1036"></p> 
<p>可以看到使用params参数传参，会将参数自动拼接到url上</p> 
<h3 id="2%E3%80%81POST%E8%AF%B7%E6%B1%82">2、POST请求</h3> 
<blockquote> 
 <p><strong>功能与语义</strong>： <code>POST</code>请求用于向服务器提交数据，主要用于创建新的资源或执行某种操作（更新、删除等，具体取决于API设计）。发送<code>POST</code>请求相当于告诉服务器：“请根据我提供的数据执行某个操作。”</p> 
 <p><strong>参数位置</strong>： <code>POST</code>请求的数据通常放在请求正文中，可以是完整的资源表示（创建资源）或操作指令及关联数据（执行操作）。请求体的格式取决于Content-Type标头，常见的是<code>application/json</code>（JSON格式）或<code>application/xml</code>（XML格式）。</p> 
 <p><strong>缓存</strong>： <code>POST</code>请求的响应通常不应被缓存，因为它们可能改变了服务器状态。</p> 
 <p><strong>幂等性</strong>： <code>POST</code>请求不一定是幂等的，即多次执行相同<code>POST</code>请求可能会产生不同的结果（例如，创建多个新的资源）。但某些情况下，如当<code>POST</code>用于替换资源或执行幂等操作时，它也可以是幂等的。</p> 
 <p><strong>安全性</strong>： <code>POST</code>请求可能引发副作用，因为它不仅用于创建资源，也可能执行非幂等操作。</p> 
</blockquote> 
<h4 id="%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82%E4%BD%93%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A">提交请求体表单数据示例：</h4> 
<p>通过data参数传递表单编码数据，适用于POST、PUT等请求。数据会被编码为application/x-www-form-urlencoded格式</p> 
<pre><code class="language-python">url_post='https://postman-echo.com/post'
data={
    'key':'value',
    'website':'www.baidu.com'
}
response_post_data=requests.post(url_post,data=data)
print(response_post_data.text)</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="691" src="https://images2.imgbox.com/66/78/UtbEmBZO_o.png" width="691"></p> 
<h4 id="%E5%8F%91%E9%80%81JSON%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A">发送JSON数据示例：</h4> 
<p>通过json参数直接传递JSON数据，适用于支持JSON格式请求体的POST、PUT等请求。requests会自动将字典转换为JSON字符串，并设置Content-Type为application/json</p> 
<pre><code class="language-python">json_data={
    'key':'value',
    'website':'www.baidu.com'
}
response_post_json=requests.post(url_post,json=json_data)
print(response_post_json.text)</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="697" src="https://images2.imgbox.com/3a/dc/S72ehrcx_o.png" width="691"></p> 
<p>我们发现使用参数data、json，传参在请求正文中的位置是不一样的，</p> 
<ul><li>使用 data 参数时，数据将以 application/x-www-form-urlencoded 格式编码，并以 key=value 形式的字符串放置在请求正文中。</li><li>使用 json 参数时，数据将以 JSON 文本格式放置在请求正文中，结构清晰，适合传输复杂的数据结构。</li></ul> 
<p>因为我们是在pycharm控制台展示，使用的是postman echo api可能效果不明显</p> 
<h3 id="3%E3%80%81PUT%E8%AF%B7%E6%B1%82">3、PUT请求</h3> 
<blockquote> 
 <p><strong>功能与语义</strong>： <code>PUT</code>请求用于更新或替换服务器上的现有资源。发送<code>PUT</code>请求相当于告诉服务器：“请用我提供的数据替换或更新指定资源。”</p> 
 <p><strong>参数位置</strong>： <code>PUT</code>请求的数据通常放在请求正文中，可以是完整的资源表示。请求体格式同POST请求。</p> 
 <p><strong>缓存</strong>： <code>PUT</code>请求的响应通常不应被缓存，因为它们可能改变了服务器状态。</p> 
 <p><strong>幂等性</strong>： <code>PUT</code>请求应该是幂等的，即多次执行相同<code>PUT</code>请求（携带相同数据）应导致相同的最终资源状态。</p> 
 <p><strong>安全性</strong>： 如果API设计合理，<code>PUT</code>请求相对安全，因为它仅用于更新资源。然而，恶意或错误的<code>PUT</code>请求可能导致数据被意外覆盖。</p> 
</blockquote> 
<p>示例：</p> 
<pre><code class="language-python">json_data = {
    'key1': 'value1',
    'key2': 'value2',
    'key3': 'value3',
    'key4': 'value4',
    'key5': 'value5',
    'key6': 'hahaha'
}
url_put='https://postman-echo.com/put'
response_put_json=requests.put(url_put,json=json_data)
print(response_put_json.json())</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="906" src="https://images2.imgbox.com/38/47/I03aqIR4_o.png" width="702"></p> 
<h3 id="4%E3%80%81DELETE%E8%AF%B7%E6%B1%82">4、DELETE请求</h3> 
<blockquote> 
 <p><strong>功能与语义</strong>： <code>DELETE</code>请求用于请求服务器删除指定的资源。发送<code>DELETE</code>请求相当于告诉服务器：“请删除这个资源。”</p> 
 <p><strong>幂等性</strong>： <code>DELETE</code>请求应该是幂等的，即多次执行相同<code>DELETE</code>请求（针对同一资源）应导致相同的最终结果——资源被删除。</p> 
 <p><strong>安全性</strong>： <code>DELETE</code>请求具有潜在破坏性，因为它会永久删除服务器上的资源。因此，在使用<code>DELETE</code>请求时应格外小心，并确保只有授权用户才能执行此类操作。</p> 
 <p><strong>参数位置</strong>： <code>DELETE</code>请求的参数通常放在URL路径中（用于标识要删除的资源），也可以放在请求头或请求体中，具体取决于API设计。不过，实践中通常不推荐在<code>DELETE</code>请求的请求体中放置数据。</p> 
</blockquote> 
<p>示例：</p> 
<pre><code class="language-python">url_delete='https://postman-echo.com/delete'
response_delete=requests.delete(url_delete)
print(response_delete.status_code)</code></pre> 
<p>一般删除请求返回状态码以及操作提示</p> 
<h3 id="5%E3%80%81PATCH%E8%AF%B7%E6%B1%82">5、PATCH请求</h3> 
<blockquote> 
 <p><strong>功能与语义</strong>： <code>PATCH</code>请求用于局部更新资源。与<code>PUT</code>请求不同，<code>PATCH</code>请求仅需提供资源需要更改的部分，而非整个资源的完整表示。发送<code>PATCH</code>请求相当于告诉服务器：“请根据我提供的数据对指定资源进行部分更新。”</p> 
 <p><strong>参数位置</strong>： <code>PATCH</code>请求的数据通常放在请求正文中，描述资源需要更改的部分。请求体格式通常遵循RFC 6902（JSON Patch）或RFC 7396（JSON Merge Patch）规范，但也可能根据API设计采用自定义格式。</p> 
 <p><strong>缓存</strong>： <code>PATCH</code>请求的响应通常不应被缓存，因为它们可能改变了服务器状态。</p> 
 <p><strong>幂等性</strong>： <code>PATCH</code>请求应该是幂等的，即多次执行相同<code>PATCH</code>请求（携带相同数据）应导致相同的最终资源状态。</p> 
 <p><strong>安全性</strong>： 可能引发副作用，应确保只有授权用户能执行，并且请求体正确描述了期望的更改。与<code>PUT</code>请求类似，恶意或错误的<code>PATCH</code>请求可能导致数据被意外更改。</p> 
</blockquote> 
<p>示例：</p> 
<pre><code class="language-python">url_patch='https://postman-echo.com/patch'
json_data ={ "op": "replace", "path": "/message", "value": "Updated message" }
response_patch=requests.patch(url_patch,json=json_data)
print(response_patch.text)</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="747" src="https://images2.imgbox.com/a5/d5/qnabDf4d_o.png" width="740"></p> 
<h3 id="6%E3%80%81%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6">6、上传文件</h3> 
<p>示例：</p> 
<pre><code class="language-python">import requests

url_post='https://postman-echo.com/post'
file_path='./test.txt'

# 构建 multipart/form-data 格式的文件数据
files = {'file': open(file_path, 'rb')}

# 发起POST请求，携带文件数据
response = requests.post(url_post, files=files)

# 检查响应状态码
if response.status_code == 200:
    print("文件上传成功，响应内容：")
    print(response.text)
else:
    print(f"文件上传失败，状态码：{response.status_code}")</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/b9/11/hXH8W922_o.png" width="890"></p> 
<h2 id="%E4%BA%94%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%AE%A1%E7%90%86" style="margin-left:.0001pt;">五、请求头管理</h2> 
<p>通过headers参数传递请求头信息，可以自定义或覆盖默认的HTTP头部。</p> 
<pre><code class="language-python">import requests

response=requests.get('https://postman-echo.com/headers')
print(response.text)


headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 Edg/123.0.0.0',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6',
    'Cache-Control': 'no-cache',
    'Authorization': 'my_access_token',  # 若需要API认证，替换为实际的访问令牌
    'X-Custom-Header': 'Value-for-custom-header'
}

response_headers = requests.get('https://postman-echo.com/headers', headers=headers)
print(response_headers.text)</code></pre> 
<ul><li>User-Agent: 模拟浏览器标识，这里模拟的是Edg浏览器。</li><li>Accept-Language: 指定接受的语言类型及优先级。</li><li>Cache-Control: 设置不使用缓存。</li><li>Authorization: 提供了API访问所需的Bearer token（如果API需要身份验证的话，请替换为实际的访问令牌）。</li><li>X-Custom-Header: 这是一个示例性的自定义请求头，通常以X-开头，用于向服务器传递特定信息。</li></ul> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">需要注意：</p> 
 <p style="margin-left:.0001pt;text-align:justify;">1. 请求头必须是键值对（python中的字典）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">2. 请求头的内容必须是ascii内容</p> 
</blockquote> 
<p style="margin-left:.0001pt;text-align:justify;">控制台输出如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="729" src="https://images2.imgbox.com/4b/2a/Zss7v2nV_o.png" width="1200"></p> 
<h2 id="%E5%85%AD%E3%80%81Session%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86" style="background-color:transparent;margin-left:.0001pt;text-align:justify;">六、Session实现<strong>会话管理</strong></h2> 
<p>使用requests.Session()创建一个会话对象（session），以便在一系列请求之间保持某些状态，如请求头、公共参数、cookies、认证信息、连接池等。以下是使用session对象的示例：</p> 
<h3 id="1%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%82%E6%95%B0" style="background-color:transparent;">1、通过Session对象设置全局请求头及全局参数</h3> 
<pre><code class="language-python">import requests

# 创建一个Session对象
session = requests.Session()

# 设置全局请求头（适用于所有通过此Session发出的请求）
session.headers.update({
    'User-Agent': 'MyApp/1.0',
    'X-Api-Key': 'your_api_key'
})

# 设置共享公共参数
session.params = {
    'param1': 'value1',
    'param2': 'value2'
}

# 使用Session对象发起GET请求
response = session.get('https://postman-echo.com/get')

# 检查响应状态码
if response.status_code == 200:
    print("GET请求成功，响应内容：")
    print(response.json())
else:
    print(f"GET请求失败，状态码：{response.status_code}")


# 使用Session对象发起POST请求，携带JSON数据
post_data = {
    "key1": "value1",
    "key2": "value2"
}
response = session.post('https://postman-echo.com/post', json=post_data)

# 检查响应状态码
if response.status_code == 200:
    print("POST请求成功，响应内容：")
    print(response.json())
else:
    print(f"POST请求失败，状态码：{response.status_code}")</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/44/8f/HMkoFsFM_o.png" width="1200"></p> 
<p>可以明显发现，使用Session()对象设置的全局请求头以及全局参数都实现了</p> 
<h3 id="2%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86cookie%EF%BC%9A" style="background-color:transparent;">2、通过Session对象管理cookie：</h3> 
<pre><code class="language-python">import requests

session = requests.Session()
# 使用Session对象发起GET请求，获取一个带Set-Cookie响应头的响应
response = session.get('https://postman-echo.com/cookies/set?foo=bar&amp;baz=qux')

# 检查响应状态码
if response.status_code == 200:
    print("GET请求成功，响应内容：")
    print(response.json())

# 使用Session对象再次发起GET请求，此时Session会自动附上之前接收到的cookies
response = session.get('https://postman-echo.com/cookies')

# 检查响应状态码
if response.status_code == 200:
    print("\nCookies检查请求成功，响应内容：")
    print(response.json())
else:
    print(f"Cookies检查请求失败，状态码：{response.status_code}")

# 关闭Session（可选，释放资源）
session.close()</code></pre> 
<blockquote> 
 <p>在这个示例中：</p> 
 <ol><li>首先创建了一个requests.Session()对象，用于管理一系列相关的HTTP请求。</li><li>通过session.headers.update()方法设置了全局请求头。这些头信息将自动应用到通过该Session发出的所有请求上，无需在每次请求时单独设置。</li><li>使用Session对象的get()方法发起一个GET请求，并检查响应状态码。如果状态码为200，说明请求成功，打印响应内容。</li><li>使用Session对象的post()方法发起一个POST请求，携带JSON数据。同样检查响应状态码，如果状态码为200，说明请求成功，打印响应内容。</li><li>（可选）使用session.close()关闭Session，释放相关资源。在实际使用中，尤其是在长生命周期的程序中，确保及时关闭Session以避免资源泄漏。</li></ol> 
</blockquote> 
<p>控制台输出如下：</p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/c9/64/MJd2LazE_o.png" width="442"></p> 
<blockquote> 
 <p>在这个示例中：</p> 
 <ol><li>首先创建了一个requests.Session()对象，用于管理一系列相关的HTTP请求。</li><li>使用Session对象的get()方法向https://postman-echo.com/cookies/set?foo=bar&amp;baz=qux发起一个GET请求。这个端点会设置两个cookies（foo和baz）并在响应中返回它们。检查响应状态码，如果状态码为200，说明请求成功，打印响应内容。</li><li>使用同一个Session对象的get()方法向https://postman-echo.com/cookies发起另一个GET请求。这个端点会返回当前请求所携带的所有cookies。由于我们使用的是同一个Session，requests库会自动将之前接收到的cookies附加到这次请求中。检查响应状态码，如果状态码为200，说明请求成功，打印响应内容。</li><li>（可选）使用session.close()关闭Session，释放相关资源。</li></ol> 
 <p>Postman Echo API 的/cookies/set端点用于设置cookies，/cookies端点用于检查当前请求所携带的cookies。通过这个示例，可以看到requests.Session如何自动处理cookies：</p> 
 <ol><li>当首次请求接收到Set-Cookie响应头时，Session对象会自动存储这些cookies。</li><li>在后续的请求中，Session对象会自动将存储的cookies附带到请求头中，除非我们显式清除或修改它们。</li></ol> 
</blockquote> 
<h3 id="3%E3%80%81%E9%80%9A%E8%BF%87Session%E5%AF%B9%E8%B1%A1%E6%98%BE%E7%A4%BA%E6%93%8D%E4%BD%9Ccookie">3、通过Session对象显示操作cookie</h3> 
<p>示例如下：</p> 
<pre><code class="language-python">import requests

# 创建一个Session对象
session = requests.Session()

# 添加一个初始cookie
session.cookies.set('initial_cookie', 'initial_value')
# 使用Session对象发起GET请求，获取一个带Set-Cookie响应头的响应
response = session.get('https://postman-echo.com/cookies/set?foo=bar&amp;baz=qux')
# 检查响应状态码
if response.status_code == 200:
    print("GET请求成功，响应内容：")
    print(response.json())

# 显式删除指定名称的cookie
session.cookies.pop('foo', None)
response = session.get('https://postman-echo.com/cookies')
if response.status_code == 200:
    print("\n删除cookie后，GET请求成功，响应内容：")
    print(response.json())

# 显式添加一个新的cookie
session.cookies.set('new_cookie', 'new_value')
# 显示更新响应中的cookies
session.cookies.set('baz', 'updated_value')
response = session.get('https://postman-echo.com/cookies')
if response.status_code == 200:
    print("\n添加新cookie以及更新原本接收的旧cookies，GET请求成功，响应内容：")
    print(response.json())

# 显式清除所有cookies
session.cookies.clear()
# 再次使用Session对象发起GET请求，此时Session中的cookies已被清除
response = session.get('https://postman-echo.com/cookies')
# 检查响应状态码
if response.status_code == 200:
    print("\nCookies检查请求成功，响应内容：")
    print(response.json())
else:
    print(f"Cookies检查请求失败，状态码：{response.status_code}")</code></pre> 
<p>控制台输出如下：</p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/6f/97/J6ps1XC1_o.png" width="1021"></p> 
<blockquote> 
 <p>在这个示例中，我们在创建Session对象后添加了一个初始cookie。</p> 
 <p>接着，通过Session对象向Postman Echo API 发送请求，接收并自动存储两个新的cookies。</p> 
 <p>接着，操作删除了一个自动存储的cookies-- "foo"</p> 
 <p>再接着，我们添加了新的cookies以及更新了原本自动存储的cookies。</p> 
 <p>然后，我们调用session.cookies.clear()清除Session中的所有cookies。最后，再次向Postman Echo API 发送请求检查cookies，此时响应中应不再包含任何cookies，证明清除操作成功。</p> 
</blockquote> 
<p></p> 
<p>希望以上内容能帮助大家有效理解requests模块，同时也建议大家通过开源api网站去强化练习使用requests，具备编写Python程序与各类Web服务进行交互的能力，为进一步学习网络编程、API开发与集成等技术打下坚实基础。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c727d7cbadae9963f91b46e68ce809f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring-boot报错 -- java: 程序包javax.servlet.http不存在</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9940157303cfd11b3a85ac9812464a21/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python・统计学】卡方检验（原理及代码）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>