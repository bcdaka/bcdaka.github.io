<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>了解Java中的反射，带你如何使用反射 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/63f7a9ce33e742873aceb45e86cf9c33/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="了解Java中的反射，带你如何使用反射">
  <meta property="og:description" content="反射的定义 反射（Reflection）是Java的一种强大机制，它允许程序在运行时动态地查询和操作类的属性和方法。通过反射，Java程序可以获取类的信息，比如类的名称、方法、字段，以及可以动态地创建对象、调用方法和改变字段的值。
反射的主要用途包括：
动态加载类：在运行时加载类，而不需要在编译时确定。查看类的结构：获取类的方法、字段、构造函数等信息，便于开发和调试。实现通用代码：通过反射可以编写更为通用的代码，例如框架和库可以利用反射来实现插件或扩展机制。访问和修改属性：可以在不知道对象具体类型的情况下，访问和修改其属性。 反射的实现一般通过Java的 java.lang.reflect 包进行，常用的类包括 Class、Method、Field 和 Constructor 等。使用反射需要注意性能开销和安全问题，因此在使用时要权衡其必要性。
反射的用途 反射在Java中的用途非常广泛，以下是一些主要的用途：
动态类加载：
可以在运行时加载和实例化类，而不需要在编译时确定类的确切类型。这对于插件架构和动态模块加载非常有用。 获取类的信息：
通过反射，可以获取类的名称、父类、接口、构造函数、方法和字段等信息，这对于调试和开发工具的实现非常重要。 动态方法调用：
可以在运行时调用对象的方法，而不需要在编译时知道方法名。这使得可以实现更加灵活的代码，比如根据用户输入或配置文件调用不同的方法。 访问和修改属性：
可以访问和修改对象的私有字段，例如进行测试时需要操作私有属性的情况。 实现通用库和框架：
许多Java框架（如Spring、Hibernate）使用反射来实现依赖注入、AOP（面向切面编程）、ORM（对象关系映射）等功能，使得框架能够对用户的应用程序进行灵活处理。 对象序列化与反序列化：
反射可以用于将对象转换为字节流或从字节流恢复对象，常用于对象的持久化和网络传输。 单元测试和Mock对象：
在单元测试中，可以使用反射来创建Mock对象，或访问被测试对象的私有方法和属性，进行更全面的测试。 反射提供了灵活性和可扩展性，但使用时也要注意其性能开销和对程序安全性的影响。
反射相关的类 在Java中，反射相关的类主要集中在 java.lang.reflect 包中，以下是一些常用的反射相关类：
Class：
代表一个类或接口的对象。可以用它来获取类的信息，包括类的名称、父类、实现的接口、字段、方法和构造方法等。 Method：
表示类中的某个方法。可以通过 Method 类调用该方法，获取方法的参数类型、返回值类型等信息。 Field：
表示类中的某个字段（属性）。可以用它来获取字段的类型、访问修饰符，并可以通过反射访问或修改字段的值。 Constructor：
表示类的构造函数。可以通过 Constructor 类创建新的对象实例，并获取构造函数的参数类型、修饰符等信息。 Array：
提供了对数组的静态方法，可以动态地创建和访问数组。 AccessibleObject：
是 Field、Method 和 Constructor 的父类，包含了一个用于设置访问权限的方法 setAccessible(boolean flag)，可以通过它来访问私有成员。 InvocationTargetException：
当通过反射调用方法时，如果被调用的方法抛出异常，将会封装在这个异常中。 这些类提供了强大的能力，使得开发者能够在运行时动态地操作类和对象，从而实现灵活和可扩展的代码设计。在使用反射时，需要注意性能开销和安全性问题。
反射的一些相关类的方法 1. Class 类的方法 getName()：返回类的完全限定名（包括包名）。getSuperclass()：返回此 Class 对象所表示的类的父类的 Class 对象。getInterfaces()：返回一个 Class 对象数组，表示所实现的接口。getDeclaredMethods()：返回一个 Method 对象数组，表示此类声明的所有方法（包括私有方法）。getDeclaredFields()：返回一个 Field 对象数组，表示此类声明的所有字段（包括私有字段）。getDeclaredConstructors()：返回一个 Constructor 对象数组，表示此类声明的所有构造函数。 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-04T13:23:23+08:00">
    <meta property="article:modified_time" content="2024-08-04T13:23:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">了解Java中的反射，带你如何使用反射</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>反射的定义</h2> 
<p>反射（Reflection）是Java的一种强大机制，它允许程序在运行时动态地查询和操作类的属性和方法。通过反射，Java程序可以获取类的信息，比如类的名称、方法、字段，以及可以动态地创建对象、调用方法和改变字段的值。</p> 
<p>反射的主要用途包括：</p> 
<ol><li><strong>动态加载类</strong>：在运行时加载类，而不需要在编译时确定。</li><li><strong>查看类的结构</strong>：获取类的方法、字段、构造函数等信息，便于开发和调试。</li><li><strong>实现通用代码</strong>：通过反射可以编写更为通用的代码，例如框架和库可以利用反射来实现插件或扩展机制。</li><li><strong>访问和修改属性</strong>：可以在不知道对象具体类型的情况下，访问和修改其属性。</li></ol> 
<p>反射的实现一般通过Java的 <code>java.lang.reflect</code> 包进行，常用的类包括 <code>Class</code>、<code>Method</code>、<code>Field</code> 和 <code>Constructor</code> 等。使用反射需要注意性能开销和安全问题，因此在使用时要权衡其必要性。</p> 
<h2>反射的用途</h2> 
<p>反射在Java中的用途非常广泛，以下是一些主要的用途：</p> 
<ol><li> <p><strong>动态类加载</strong>：</p> 
  <ul><li>可以在运行时加载和实例化类，而不需要在编译时确定类的确切类型。这对于插件架构和动态模块加载非常有用。</li></ul></li><li> <p><strong>获取类的信息</strong>：</p> 
  <ul><li>通过反射，可以获取类的名称、父类、接口、构造函数、方法和字段等信息，这对于调试和开发工具的实现非常重要。</li></ul></li><li> <p><strong>动态方法调用</strong>：</p> 
  <ul><li>可以在运行时调用对象的方法，而不需要在编译时知道方法名。这使得可以实现更加灵活的代码，比如根据用户输入或配置文件调用不同的方法。</li></ul></li><li> <p><strong>访问和修改属性</strong>：</p> 
  <ul><li>可以访问和修改对象的私有字段，例如进行测试时需要操作私有属性的情况。</li></ul></li><li> <p><strong>实现通用库和框架</strong>：</p> 
  <ul><li>许多Java框架（如Spring、Hibernate）使用反射来实现依赖注入、AOP（面向切面编程）、ORM（对象关系映射）等功能，使得框架能够对用户的应用程序进行灵活处理。</li></ul></li><li> <p><strong>对象序列化与反序列化</strong>：</p> 
  <ul><li>反射可以用于将对象转换为字节流或从字节流恢复对象，常用于对象的持久化和网络传输。</li></ul></li><li> <p><strong>单元测试和Mock对象</strong>：</p> 
  <ul><li>在单元测试中，可以使用反射来创建Mock对象，或访问被测试对象的私有方法和属性，进行更全面的测试。</li></ul></li></ol> 
<p>反射提供了灵活性和可扩展性，但使用时也要注意其性能开销和对程序安全性的影响。</p> 
<p></p> 
<h2>反射相关的类</h2> 
<p>在Java中，反射相关的类主要集中在 <code>java.lang.reflect</code> 包中，以下是一些常用的反射相关类：</p> 
<ol><li> <p><strong>Class</strong>：</p> 
  <ul><li>代表一个类或接口的对象。可以用它来获取类的信息，包括类的名称、父类、实现的接口、字段、方法和构造方法等。</li></ul></li><li> <p><strong>Method</strong>：</p> 
  <ul><li>表示类中的某个方法。可以通过 <code>Method</code> 类调用该方法，获取方法的参数类型、返回值类型等信息。</li></ul></li><li> <p><strong>Field</strong>：</p> 
  <ul><li>表示类中的某个字段（属性）。可以用它来获取字段的类型、访问修饰符，并可以通过反射访问或修改字段的值。</li></ul></li><li> <p><strong>Constructor</strong>：</p> 
  <ul><li>表示类的构造函数。可以通过 <code>Constructor</code> 类创建新的对象实例，并获取构造函数的参数类型、修饰符等信息。</li></ul></li><li> <p><strong>Array</strong>：</p> 
  <ul><li>提供了对数组的静态方法，可以动态地创建和访问数组。</li></ul></li><li> <p><strong>AccessibleObject</strong>：</p> 
  <ul><li>是 <code>Field</code>、<code>Method</code> 和 <code>Constructor</code> 的父类，包含了一个用于设置访问权限的方法 <code>setAccessible(boolean flag)</code>，可以通过它来访问私有成员。</li></ul></li><li> <p><strong>InvocationTargetException</strong>：</p> 
  <ul><li>当通过反射调用方法时，如果被调用的方法抛出异常，将会封装在这个异常中。</li></ul></li></ol> 
<p>这些类提供了强大的能力，使得开发者能够在运行时动态地操作类和对象，从而实现灵活和可扩展的代码设计。在使用反射时，需要注意性能开销和安全性问题。</p> 
<p></p> 
<h2>反射的一些相关类的方法</h2> 
<p></p> 
<h3 id="1-class-类的方法">1. Class 类的方法</h3> 
<ul><li><code>getName()</code>：返回类的完全限定名（包括包名）。</li><li><code>getSuperclass()</code>：返回此 Class 对象所表示的类的父类的 Class 对象。</li><li><code>getInterfaces()</code>：返回一个 Class 对象数组，表示所实现的接口。</li><li><code>getDeclaredMethods()</code>：返回一个 Method 对象数组，表示此类声明的所有方法（包括私有方法）。</li><li><code>getDeclaredFields()</code>：返回一个 Field 对象数组，表示此类声明的所有字段（包括私有字段）。</li><li><code>getDeclaredConstructors()</code>：返回一个 Constructor 对象数组，表示此类声明的所有构造函数。</li></ul> 
<h3 id="2-method-类的方法">2. Method 类的方法</h3> 
<ul><li><code>getName()</code>：返回方法的名称。</li><li><code>getReturnType()</code>：返回方法的返回类型。</li><li><code>getParameterTypes()</code>：返回一个 Class 对象数组，表示方法的参数类型。</li><li><code>invoke(Object obj, Object... args)</code>：在指定对象上调用此 Method 对象表示的原始方法。</li><li><code>setAccessible(boolean flag)</code>：设置此方法是否可以通过反射访问（包括私有方法）。</li></ul> 
<h3 id="3-field-类的方法">3. Field 类的方法</h3> 
<ul><li><code>getName()</code>：返回字段的名称。</li><li><code>getType()</code>：返回字段的类型（Class 对象）。</li><li><code>get(Object obj)</code>：返回指定对象上此 Field 对象表示的字段的值。</li><li><code>set(Object obj, Object value)</code>：为指定对象上此 Field 对象表示的字段设置值。</li><li><code>setAccessible(boolean flag)</code>：设置此字段是否可以通过反射访问（包括私有字段）。</li></ul> 
<h3 id="4-constructor-类的方法">4. Constructor 类的方法</h3> 
<ul><li><code>getName()</code>：返回构造函数的名称。</li><li><code>getParameterTypes()</code>：返回一个 Class 对象数组，表示构造函数的参数类型。</li><li><code>newInstance(Object... initargs)</code>：用构造函数创建新对象实例。</li></ul> 
<h3 id="5-array-类的方法">5. Array 类的方法</h3> 
<ul><li><code>newInstance(Class&lt;?&gt; componentType, int... dimensions)</code>：创建一个指定组件类型和维度的新数组。</li><li><code>get(Object array, int index)</code>：返回数组中指定索引处的值。</li><li><code>set(Object array, int index, Object value)</code>：设置数组中指定索引处的值。</li></ul> 
<h3 id="6-accessibleobject-类的方法">6. AccessibleObject 类的方法</h3> 
<ul><li><code>setAccessible(boolean flag)</code>：设置此对象是否可被反射访问（如私有成员）。</li></ul> 
<p>这些方法使得Java反射能够处理类和对象的多种操作，增强了程序的灵活性和动态性。在使用时，请注意性能和安全性。</p> 
<p></p> 
<h2><strong>反射的使用</strong></h2> 
<p>下面是一个简单的示例，演示如何使用反射来获取一个类的信息，并调用其方法。</p> 
<p>假设我们有一个简单的类 <code>Person</code>，包含一些属性和一个方法：</p> 
<pre><code class="language-java">// Person.java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void introduce() {
        System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
    }

    // Getter和Setter方法
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre> 
<p>以下是使用反射来访问 <code>Person</code> 类的代码：</p> 
<pre><code class="language-java">import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Field;

public class ReflectionExample {
    public static void main(String[] args) {
        try {
            // 获取Person类的Class对象
            Class&lt;?&gt; personClass = Class.forName("Person");

            // 获取构造函数并创建实例
            Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, int.class);
            Object personInstance = constructor.newInstance("Alice", 30);

            // 获取并调用introduce方法
            Method introduceMethod = personClass.getMethod("introduce");
            introduceMethod.invoke(personInstance);

            // 获取并修改私有字段name
            Field nameField = personClass.getDeclaredField("name");
            nameField.setAccessible(true); // 允许访问私有字段
            nameField.set(personInstance, "Bob"); // 修改字段值

            // 再次调用introduce方法
            introduceMethod.invoke(personInstance);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<h3 id="代码解释：">代码解释：</h3> 
<ol><li>使用 <code>Class.forName</code> 获取 <code>Person</code> 类的 <code>Class</code> 对象。</li><li>通过 <code>getConstructor</code> 方法获取带有参数的构造函数，并使用 <code>newInstance</code> 方法创建 <code>Person</code> 类的一个实例。</li><li>使用 <code>getMethod</code> 获取 <code>introduce</code> 方法，并通过 <code>invoke</code> 调用该方法。</li><li>使用 <code>getDeclaredField</code> 获取私有字段 <code>name</code>，并通过 <code>setAccessible(true)</code> 允许访问私有字段，接着修改它的值。</li><li>再次调用 <code>introduce</code> 方法，输出修改后的结果。</li></ol> 
<p>这个示例展示了如何通过反射访问和操作类的属性和方法。</p> 
<p></p> 
<h2>反射优点和缺点</h2> 
<h3>优点：</h3> 
<ul><li>1. 对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法</li><li>2. 增加程序的灵活性和扩展性，降低耦合性，提高自适应能力</li><li>3. 反射已经运用在了很多流行框架如：Struts、Hibernate、Spring 等等。</li></ul> 
<h3>缺点：</h3> 
<ul><li>1.使用反射会有效率问题。会导致程序效率降低。具体参考这里：<a href="http://www.imooc.com/article/293679" rel="nofollow" title="大家都说 Java 反射效率低，你知道原因在哪里么_慕课手记">大家都说 Java 反射效率低，你知道原因在哪里么_慕课手记</a></li><li>2. 反射技术绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂 </li></ul> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5e67eaf7c42896596da3cf14899c1e8f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode面试150——134加油站</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/978d33b9588977ee795b02f63ee61c06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">手机在网状态接口如何对接？（二）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>