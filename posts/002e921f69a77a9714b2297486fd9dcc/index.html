<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文通透位置编码：从标准位置编码、旋转位置编码RoPE到ALiBi、LLaMA 2 Long - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/002e921f69a77a9714b2297486fd9dcc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="一文通透位置编码：从标准位置编码、旋转位置编码RoPE到ALiBi、LLaMA 2 Long">
  <meta property="og:description" content="前言 关于位置编码和RoPE 应用广泛，是很多大模型使用的一种位置编码方式，包括且不限于LLaMA、baichuan、ChatGLM等等我之前在本博客中的另外两篇文章中有阐述过(一篇是关于LLaMA解读的，一篇是关于transformer从零实现的)，但自觉写的不是特别透彻好懂
再后来在我参与主讲的类ChatGPT微调实战课中也有讲过，但有些学员依然反馈RoPE不是特别好理解 考虑到只要花足够多的时间 心思 投入，没有写不清楚的，讲课更是如此，故为彻底解决这个位置编码/RoPE的问题，我把另外两篇文章中关于位置编码的内容抽取出来，并不断深入、扩展、深入，比如其中最关键的改进是两轮改进，一个12.16那天，一个12.21那天
12.16那天
小的改进是把“1.1 标准位置编码的起源”中，关于i、2i、2i&#43;1的一系列计算结果用表格规整了下
如此，相比之前把一堆数字一堆，表格更加清晰、一目了然
大的改进是把“3.1.1 第一种形式的推导(通俗易懂版)”的细节重新梳理了以下，以更加一目了然、一看即懂，可能是全网关于RoPE最通俗细致的推导12.21那天
把RoPE的本质给强调出来 最终成为本文
第一部分 transformer原始论文中的标准位置编码 如此篇文章《Transformer通俗笔记：从Word2Vec、Seq2Seq逐步理解到GPT、BERT》所述，RNN的结构包含了序列的时序信息，而Transformer却完全把时序信息给丢掉了，比如“他欠我100万”，和“我欠他100万”，两者的意思千差万别，故为了解决时序的问题，Transformer的作者用了一个绝妙的办法：位置编码(Positional Encoding)
1.1 标准位置编码的起源 即将每个位置编号，从而每个编号对应一个向量，最终通过结合位置向量和词向量，作为输入embedding，就给每个词都引入了一定的位置信息，这样Attention就可以分辨出不同位置的词了，具体怎么做呢？
如果简单粗暴的话，直接给每个向量分配一个数字，比如1到1000之间也可以用one-hot编码表示位置 transformer论文中作者通过sin函数和cos函数交替来创建 positional encoding，其计算positional encoding的公式如下 其中，pos相当于是每个token在整个序列中的位置，相当于是0, 1, 2, 3...(看序列长度是多大，比如10，比如100)，代表位置向量的维度(也是词embedding的维度，transformer论文中设置的512维) 至于是embedding向量的位置下标对2求商并取整(可用双斜杠表示整数除法，即求商并取整)，它的取值范围是，比如
位置向量的第多少维
(0 2 4等偶数维用sin函数计算)0 1 2 3 4 56....510511 相当于
是指向量维度中的偶数维，即第0维、第2维、第4维...，第510维，用sin函数计算
是向量维度中的奇数维，即第1维、第3维、第5维..，第511维，用cos函数计算 不要小看transformer的这个位置编码，不少做NLP多年的人也不一定对其中的细节有多深入，而网上大部分文章谈到这个位置编码时基本都是千篇一律、泛泛而谈，很少有深入，故本文还是细致探讨下
1.2 标准位置编码的示例：多图多举例 考虑到一图胜千言 一例胜万语，举个例子，当我们要编码「我 爱 你」的位置向量，假定每个token都具备512维，如果位置下标从0开始时，则根据位置编码的计算公式可得『且为让每个读者阅读本文时一目了然，我计算了每个单词对应的位置编码示例(在此之前，这些示例在其他地方基本没有)』
当对上的单词「我」进行位置编码时，它本身的维度有512维
当对上的单词「爱」进行位置编码时，它本身的维度有512维 然后再叠加上embedding向量，可得
当对上的单词「你」进行位置编码时，它本身的维度有512维
.... 最终得到的可视化效果如下图所示
1.3 标准位置编码的coding实现 代码实现如下
“”“位置编码的实现，调用父类nn.Module的构造函数”“” class PositionalEncoding(nn.Module): def __init__(self, d_model, dropout, max_len=5000): super(PositionalEncoding, self).">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-01T17:15:05+08:00">
    <meta property="article:modified_time" content="2024-02-01T17:15:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文通透位置编码：从标准位置编码、旋转位置编码RoPE到ALiBi、LLaMA 2 Long</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>关于位置编码和RoPE </p> 
<ol><li>应用广泛，是很多大模型使用的一种位置编码方式，包括且不限于LLaMA、baichuan、ChatGLM等等</li><li>我之前在本博客中的另外两篇文章中有阐述过(一篇是关于LLaMA解读的，一篇是关于transformer从零实现的)，但自觉写的不是特别透彻好懂<br> 再后来在我参与主讲的类ChatGPT微调实战课中也有讲过，但有些学员依然反馈RoPE不是特别好理解</li></ol> 
<p>考虑到只要花足够多的时间 心思 投入，没有写不清楚的，讲课更是如此，故为彻底解决这个位置编码/RoPE的问题，我把另外两篇文章中关于位置编码的内容抽取出来，并不断深入、扩展、深入，比如其中最关键的改进是两轮改进，一个12.16那天，一个12.21那天</p> 
<ol><li>12.16那天<br> 小的改进是把“1.1 标准位置编码的起源”中，关于i、2i、2i+1的一系列计算结果用表格规整了下<br> 如此，相比之前把一堆数字一堆，表格更加清晰、一目了然<br> 大的改进是把“3.1.1 第一种形式的推导(通俗易懂版)”的细节重新梳理了以下，以更加一目了然、一看即懂，可能是全网关于RoPE最通俗细致的推导</li><li>12.21那天<br> 把RoPE的本质给强调出来</li></ol> 
<p>最终成为本文</p> 
<p></p> 
<h2>第一部分 transformer原始论文中的标准位置编码</h2> 
<p>如此篇文章《<a class="link-info" href="https://blog.csdn.net/v_JULY_v/article/details/127411638" title="Transformer通俗笔记：从Word2Vec、Seq2Seq逐步理解到GPT、BERT">Transformer通俗笔记：从Word2Vec、Seq2Seq逐步理解到GPT、BERT</a>》所述，RNN的结构包含了序列的时序信息，而Transformer却完全把时序信息给丢掉了，比如“他欠我100万”，和“我欠他100万”，两者的意思千差万别，故为了解决时序的问题，Transformer的作者用了一个绝妙的办法：位置编码(Positional Encoding)</p> 
<h3>1.1 标准位置编码的起源</h3> 
<p>即将每个位置编号，从而每个编号对应一个向量，最终通过结合位置向量和词向量，作为输入embedding，就给每个词都引入了一定的位置信息，这样Attention就可以分辨出不同位置的词了，具体怎么做呢？</p> 
<ol><li>如果简单粗暴的话，直接给每个向量分配一个数字，比如1到1000之间</li><li>也可以用one-hot编码表示位置 <p class="img-center"><img alt="" height="326" src="https://images2.imgbox.com/18/61/jMBM5b8H_o.png" width="500"></p> </li><li>transformer论文中作者通过sin函数和cos函数交替来创建 positional encoding，其计算positional encoding的公式如下 <p class="img-center"><img alt="PE_{(pos,2i+1)} = cos\left ( \frac{pos}{10000^{\frac{2i}{d_{model}}}} \right )" class="mathcode" src="https://images2.imgbox.com/ae/92/1epkwqhV_o.png"></p> <p class="img-center"><img alt="PE_{(pos,2i)} = sin\left ( \frac{pos}{10000^{\frac{2i}{d_{model}}}} \right )" class="mathcode" src="https://images2.imgbox.com/73/99/R5MfApuz_o.png"></p> 其中，pos相当于是每个token在整个序列中的位置，相当于是0, 1, 2, 3...(看序列长度是多大，比如10，比如100)，<img alt="d_{model}" src="https://images2.imgbox.com/90/7c/O7sh3xEY_o.png">代表位置向量的维度(也是词embedding的维度，transformer论文中设置的512维)  <p>至于<img alt="i" src="https://images2.imgbox.com/c6/da/ziVk9FiS_o.png">是embedding向量的位置下标对2求商并取整(可用双斜杠<img alt="//" src="https://images2.imgbox.com/cb/2a/HiKvMVQM_o.png">表示整数除法，即求商并取整)，它的取值范围是<img alt="[0,...,\frac{d_{model}}{2}]" src="https://images2.imgbox.com/85/1b/D5L4egCv_o.png">，比如</p> 
  <table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:210px;"><strong>位置向量的第多少维</strong><br><span style="color:#ed7976;">(0 2 4等偶数维用sin函数计算)</span></td><td style="width:275px;"><strong><img alt="i" class="mathcode" src="https://images2.imgbox.com/25/4e/UkjXMWUn_o.png"></strong></td><td style="width:185px;"><strong><img alt="2i" class="mathcode" src="https://images2.imgbox.com/76/a1/cV156zj3_o.png"></strong></td><td><strong><img alt="2i+1" class="mathcode" src="https://images2.imgbox.com/ba/99/v5MqLBKA_o.png"></strong></td></tr><tr><td style="width:210px;"><span style="color:#fe2c24;">0</span></td><td style="width:275px;"><img alt="i = 0 // 2 = 0" class="mathcode" src="https://images2.imgbox.com/41/8a/XuwdOucd_o.png"></td><td style="width:185px;"><span style="color:#ed7976;"><img alt="2i = 0" class="mathcode" src="https://images2.imgbox.com/91/86/1smTsThn_o.png"> </span></td><td></td></tr><tr><td style="width:210px;">1</td><td style="width:275px;"><img alt="i = 1 //2 =0" class="mathcode" src="https://images2.imgbox.com/7c/4c/Cix55pRG_o.png"></td><td style="width:185px;"><img alt="2i = 0" class="mathcode" src="https://images2.imgbox.com/ab/81/ZxTqpiCP_o.png">  </td><td><img alt="2i+1 = 1" class="mathcode" src="https://images2.imgbox.com/60/9d/ulbV4tNY_o.png"> </td></tr><tr><td style="width:210px;"><span style="color:#fe2c24;">2</span></td><td style="width:275px;"><img alt="i = 2 // 2 = 1" class="mathcode" src="https://images2.imgbox.com/23/dc/8Ls3HnWO_o.png"></td><td style="width:185px;"><span style="color:#ed7976;"><img alt="2i = 2" class="mathcode" src="https://images2.imgbox.com/85/77/VjG0bPzV_o.png"> </span></td><td></td></tr><tr><td style="width:210px;">3</td><td style="width:275px;"><img alt="i = 3 // 2 = 1" class="mathcode" src="https://images2.imgbox.com/a8/a8/EGC7SAHv_o.png"></td><td style="width:185px;"><img alt="2i = 2" class="mathcode" src="https://images2.imgbox.com/ae/d6/nV4GpFpO_o.png"></td><td><img alt="2i+1 = 3" class="mathcode" src="https://images2.imgbox.com/9b/c4/GN6RjX5F_o.png"> </td></tr><tr><td style="width:210px;"><span style="color:#fe2c24;">4</span></td><td style="width:275px;"><img alt="i = 4 // 2 = 2" class="mathcode" src="https://images2.imgbox.com/57/b7/IixvN79L_o.png"></td><td style="width:185px;"><span style="color:#ed7976;"><img alt="2i = 4" class="mathcode" src="https://images2.imgbox.com/3a/02/dh2M1dTv_o.png">  </span></td><td></td></tr><tr><td style="width:210px;">5</td><td style="width:275px;"><img alt="i = 5//2 = 2" class="mathcode" src="https://images2.imgbox.com/ad/1e/54gj7rnF_o.png"></td><td style="width:185px;"><img alt="2i = 4" class="mathcode" src="https://images2.imgbox.com/a0/1b/8z3d1Qrb_o.png"></td><td><img alt="2i + 1 =5" class="mathcode" src="https://images2.imgbox.com/28/a8/fVrkH70f_o.png"></td></tr><tr><td style="width:210px;">6</td><td style="width:275px;"></td><td style="width:185px;"></td><td></td></tr><tr><td style="width:210px;">....</td><td style="width:275px;"></td><td style="width:185px;"></td><td></td></tr><tr><td style="width:210px;"><span style="color:#fe2c24;">510</span></td><td style="width:275px;"><img alt="i = 510 // 2 = 255" class="mathcode" src="https://images2.imgbox.com/e6/ec/3QtvJXH9_o.png"></td><td style="width:185px;"><span style="color:#ed7976;"><img alt="2i = 510" class="mathcode" src="https://images2.imgbox.com/d1/14/rysqkL30_o.png"></span></td><td></td></tr><tr><td style="width:210px;">511</td><td style="width:275px;"><img alt="i = 511 // 2 = 255" class="mathcode" src="https://images2.imgbox.com/67/76/eZkrYDcs_o.png"></td><td style="width:185px;"><img alt="2i = 510" class="mathcode" src="https://images2.imgbox.com/1f/02/ybvr1dNG_o.png"></td><td><img alt="2i + 1 = 511" class="mathcode" src="https://images2.imgbox.com/94/97/YjPjHWm9_o.png"></td></tr></tbody></table> 相当于<br><img alt="2i" src="https://images2.imgbox.com/53/76/3nn1ZqeQ_o.png">是指向量维度中的偶数维，即第0维、第2维、第4维...，第510维，用sin函数计算<br><img alt="2i+1" src="https://images2.imgbox.com/20/d7/GCep6KJe_o.png"> 是向量维度中的奇数维，即第1维、第3维、第5维..，第511维，用cos函数计算</li></ol> 
<p>不要小看transformer的这个位置编码，不少做NLP多年的人也不一定对其中的细节有多深入，而网上大部分文章谈到这个位置编码时基本都是千篇一律、泛泛而谈，很少有深入，故本文还是细致探讨下</p> 
<h3>1.2 标准位置编码的示例：多图多举例</h3> 
<p>考虑到一图胜千言 一例胜万语，举个例子，当我们要编码「我 爱 你」的位置向量，假定每个token都具备512维，如果位置下标从0开始时，则根据位置编码的计算公式可得<strong>『</strong><span style="color:#7b7f82;"><em>且为让每个读者阅读本文时一目了然，我计算了<u>每个单词对应的位置编码示例</u>(在此之前，这些示例在其他地方基本没有)</em></span><strong>』</strong></p> 
<ul><li>当对<img alt="pos = 0" src="https://images2.imgbox.com/49/db/tQSiEa1q_o.png">上的单词「我」进行位置编码时，它本身的维度有512维<br><img alt="PE_0 = [sin(\frac{0}{10000^{\frac{0}{512}}}),cos(\frac{0}{10000^{\frac{0}{512}}}), sin(\frac{0}{10000^{\frac{2}{512}}}),cos(\frac{0}{10000^{\frac{2}{512}}}), sin(\frac{0}{10000^{\frac{4}{512}}}), cos(\frac{0}{10000^{\frac{4}{512}}}),..., sin(\frac{0}{10000^{\frac{510}{512}}}),cos(\frac{0}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/69/31/9dDGY6Fb_o.png"></li><li>当对<img alt="pos = 1" src="https://images2.imgbox.com/de/82/DXWMZQGa_o.png">上的单词「爱」进行位置编码时，它本身的维度有512维 <p class="img-center"><img alt="" height="425" src="https://images2.imgbox.com/09/c7/J0volGrn_o.png" width="600"></p> <img alt="PE_1 = [sin(\frac{1}{10000^{\frac{0}{512}}}),cos(\frac{1}{10000^{\frac{0}{512}}}), sin(\frac{1}{10000^{\frac{2}{512}}}),cos(\frac{1}{10000^{\frac{2}{512}}}), sin(\frac{1}{10000^{\frac{4}{512}}}), cos(\frac{1}{10000^{\frac{4}{512}}}),..., sin(\frac{1}{10000^{\frac{510}{512}}}),cos(\frac{1}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/ef/a6/Nea2oi44_o.png"><p> 然后再叠加上embedding向量，可得</p> <p class="img-center"><img alt="" height="276" src="https://images2.imgbox.com/81/f5/uLVeDZqC_o.png" width="700"></p> </li><li>当对<img alt="pos = 2" src="https://images2.imgbox.com/c6/14/or1lM8T8_o.png">上的单词「你」进行位置编码时，它本身的维度有512维<br><img alt="PE_2 = [sin(\frac{2}{10000^{\frac{0}{512}}}),cos(\frac{2}{10000^{\frac{0}{512}}}), sin(\frac{2}{10000^{\frac{2}{512}}}),cos(\frac{2}{10000^{\frac{2}{512}}}), sin(\frac{2}{10000^{\frac{4}{512}}}), cos(\frac{2}{10000^{\frac{4}{512}}}),..., sin(\frac{2}{10000^{\frac{510}{512}}}),cos(\frac{2}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/35/e8/csqMa3Xp_o.png"></li><li>....</li></ul> 
<p>最终得到的可视化效果如下图所示</p> 
<p class="img-center"><img alt="" height="443" src="https://images2.imgbox.com/ce/21/kx4VQNKr_o.png" width="700"></p> 
<h3>1.3 标准位置编码的coding实现</h3> 
<p>代码实现如下</p> 
<pre><code>“”“位置编码的实现，调用父类nn.Module的构造函数”“”
class PositionalEncoding(nn.Module):
    def __init__(self, d_model, dropout, max_len=5000):
        super(PositionalEncoding, self).__init__()  
        self.dropout = nn.Dropout(p=dropout)  # 初始化dropout层
        
        # 计算位置编码并将其存储在pe张量中
        pe = torch.zeros(max_len, d_model)                # 创建一个max_len x d_model的全零张量
        position = torch.arange(0, max_len).unsqueeze(1)  # 生成0到max_len-1的整数序列，并添加一个维度
        # 计算div_term，用于缩放不同位置的正弦和余弦函数
        div_term = torch.exp(torch.arange(0, d_model, 2) *
                             -(math.log(10000.0) / d_model))

        # 使用正弦和余弦函数生成位置编码，对于d_model的偶数索引，使用正弦函数；对于奇数索引，使用余弦函数。
        pe[:, 0::2] = torch.sin(position * div_term)
        pe[:, 1::2] = torch.cos(position * div_term)
        pe = pe.unsqueeze(0)                  # 在第一个维度添加一个维度，以便进行批处理
        self.register_buffer('pe', pe)        # 将位置编码张量注册为缓冲区，以便在不同设备之间传输模型时保持其状态
        
    # 定义前向传播函数
    def forward(self, x):
        # 将输入x与对应的位置编码相加
        x = x + Variable(self.pe[:, :x.size(1)], 
                         requires_grad=False)
        # 应用dropout层并返回结果
        return self.dropout(x)</code></pre> 
<p>本文发布之后，有同学留言问，上面中的第11行、12行代码</p> 
<pre><code>div_term = torch.exp(torch.arange(0, d_model, 2) * -(math.log(10000.0) / d_model))</code></pre> 
<p>为什么先转换为了等价的指数+对数运算，而不是直接幂运算？是效率、精度方面有差异吗？</p> 
<p>这里使用指数和对数运算的原因是为了确保数值稳定性和计算效率</p> 
<ul><li>一方面，直接使用幂运算可能会导致数值上溢或下溢。当d_model较大时，10000.0 ** (-i / d_model)中的幂可能会变得非常小，以至于在数值计算中产生下溢。通过将其转换为指数和对数运算，可以避免这种情况，因为这样可以在计算过程中保持更好的数值范围</li><li>二方面，在许多计算设备和库中，指数和对数运算的实现通常比幂运算更快。这主要是因为指数和对数运算在底层硬件和软件中有特定的优化实现，而幂运算通常需要计算更多的中间值</li></ul> 
<p>所以，使用指数和对数运算可以在保持数值稳定性的同时提高计算效率。</p> 
<p>既然提到了这行代码，我们干脆就再讲更细致些，上面那行代码对应的公式为</p> 
<p class="img-center"><img alt="" height="159" src="https://images2.imgbox.com/d7/da/jX4PhJkj_o.png" width="600"></p> 
<p>其中的中括号对应的是一个从 0 到 <img alt="d_{\text{model}} - 1" src="https://images2.imgbox.com/b1/6b/BKbZaa9V_o.png"> 的等差数列(步长为 2)，设为<img alt="i" src="https://images2.imgbox.com/47/fb/1ITGdBDT_o.png"></p> 
<p>且上述公式与这个公式是等价的</p> 
<p class="img-center"><img alt="" height="98" src="https://images2.imgbox.com/ba/37/9NUBdF2Y_o.png" width="536"></p> 
<p>为何，原因在于<img alt="a^x=e^{(x\cdot ln(a))}" src="https://images2.imgbox.com/55/12/Drd8mlBv_o.png">，从而有<img alt="10000^{-\frac{i}{d_{model}}}=e^{(-\frac{i}{d_{model}}\cdot log(10000))}" src="https://images2.imgbox.com/19/1d/tO7JWRsB_o.png"></p> 
<p> 最终，再通过下面这两行代码完美实现位置编码</p> 
<pre><code>        # 使用正弦和余弦函数生成位置编码，对于d_model的偶数索引，使用正弦函数；对于奇数索引，使用余弦函数。
        pe[:, 0::2] = torch.sin(position * div_term)
        pe[:, 1::2] = torch.cos(position * div_term)</code></pre> 
<p></p> 
<h2>第二部分 从复数到欧拉公式</h2> 
<p>先复习下复数的一些关键概念</p> 
<ol><li>我们一般用<img alt="a + bi" src="https://images2.imgbox.com/d7/b4/SFBsykrW_o.png">表示<a href="https://zh.wikipedia.org/zh-hans/%E5%A4%8D%E6%95%B0_%28%E6%95%B0%E5%AD%A6%29" rel="nofollow" title="复数">复数</a>，实数<img alt="a" class="mathcode" src="https://images2.imgbox.com/65/42/ozgeprtL_o.png"> 叫做复数的实部，实数<img alt="b" class="mathcode" src="https://images2.imgbox.com/2c/f7/otOku1oU_o.png"> 叫做复数的虚部 <p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/41/29/neoaIZYO_o.png" width="397"></p> </li><li>复数的辐角是指复数在复平面上对应的向量和正向实数轴所成的有向角 <p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/34/3d/DU704YsB_o.png" width="300"></p> </li><li><img alt="z = a + ib" src="https://images2.imgbox.com/22/c6/2SLsBNb7_o.png">的共轭复数定义为：<img alt="z^* = a - ib" src="https://images2.imgbox.com/2a/84/T1jGFbEP_o.png">，也可记作<img alt="\bar{z}" src="https://images2.imgbox.com/78/a3/KKCbw2FR_o.png">，复数与其共轭的乘积等于它的模的平方，即<img alt="z \times z^* = a^2 + b^2 = |z|^2" src="https://images2.imgbox.com/27/5a/zIKGJE2n_o.png">，这是一个实数</li></ol> 
<h3>2.1 如何通俗易懂的理解复数</h3> 
<p>在我们的日常生活中，经常会遇到各种平移运动，为了描述这些平移运动，数学上定义了加减乘除，然还有一类运动是旋转运动，而加减乘除无法去描述旋转运动，而有了复数之后，便不一样了，此话怎讲？</p> 
<p>根据复数的定义：<img alt="i=\sqrt{-1}" class="mathcode" src="https://images2.imgbox.com/f7/2e/LVvxIRFd_o.png">，可以看出来：<img alt="i^{2}=1 \times i \times i=-1" class="mathcode" src="https://images2.imgbox.com/61/bc/ecG0kQhW_o.png">，而这个展开过程就揭示了虚数 <img alt="i" class="mathcode" src="https://images2.imgbox.com/57/49/pwuGHUfK_o.png"> 背后的本质，因为这个展开过程中的两次乘法可以看成连续的操作</p> 
<ul><li>即把 1 经过2次完全一样的操作：<img alt="\times i" class="mathcode" src="https://images2.imgbox.com/4f/b0/tP0PUXUy_o.png">，变成了 −1 ，那什么样的操作能得到这个效果呢？</li><li>你两眼一亮，直呼：旋转啊，先旋转 90度，再旋转 90 度就可以了啊，如下图所示 <p class="img-center"><img alt="" height="274" src="https://images2.imgbox.com/0f/da/ovrL1hPm_o.png" width="500"></p> </li></ul> 
<p>so，<img alt="i" class="mathcode" src="https://images2.imgbox.com/04/3b/u0MEeP4u_o.png"> 就代表了旋转(<span style="color:#7b7f82;"><em>至此，可能你已经隐隐约约意识到，为何我们在解释旋转位置编码时，为何要扯上复数了</em></span>)，为形象说明，再举两个例子</p> 
<ul><li>比如对于<img alt="e^{i \pi}+1=0" class="mathcode" src="https://images2.imgbox.com/78/e7/UUTysHVz_o.png">，自然数 1，绕坐标中心旋转180度(<img alt="e^{i \pi}" class="mathcode" src="https://images2.imgbox.com/33/a4/Bhd60kSE_o.png">)，再平移1 ，就回到坐标原点</li><li>再比如对于<img alt="(a+b i) i=-b+a i" class="mathcode" src="https://images2.imgbox.com/06/9d/az3WmiDC_o.png"><p class="img-center"><img alt="" height="264" src="https://images2.imgbox.com/1c/40/wxJNv6Oi_o.png" width="384"></p> </li></ul> 
<h3>2.2 如何快速理解欧拉公式</h3> 
<h4>2.2.1 什么是欧拉公式</h4> 
<p>当<img alt="x" class="mathcode" src="https://images2.imgbox.com/1e/ab/MDuZjha9_o.png"> 表示任意实数，<img alt="e" class="mathcode" src="https://images2.imgbox.com/18/c0/qSN4VFns_o.png"> 是自然对数的底数，<img alt="i" class="mathcode" src="https://images2.imgbox.com/7b/1d/9iMAB7mj_o.png"> 是复数中的虚数单位，则根据欧拉公式有</p> 
<p style="text-align:center;"><img alt="e^{i x}=\cos x+i \sin x" class="mathcode" src="https://images2.imgbox.com/9e/6d/e3han2bd_o.png"></p> 
<p>表达的含义在于该指数函数可以表示为实部为<img alt="cos x" class="mathcode" src="https://images2.imgbox.com/a5/27/9VRbQWuN_o.png">，虚部为<img alt="sinx" class="mathcode" src="https://images2.imgbox.com/aa/d9/IjpWOhks_o.png">的一个复数</p> 
<blockquote> 
 <p>该欧拉公式相当于建立了指数函数、三角函数和复数之间的桥梁，但怎么推导出来的呢，其实很简单</p> 
 <ol><li>由于有 <p style="text-align:center;"><img alt="e^{x}=1+x+\frac{1}{2 !} x^{2}+\frac{1}{3 !} x^{3}+\cdots" class="mathcode" src="https://images2.imgbox.com/40/04/onUjswNn_o.png"></p> <p style="text-align:center;"><img alt="\sin (x)=x-\frac{1}{3 !} x^{3}+\frac{1}{5 !} x^{5}+\cdots" class="mathcode" src="https://images2.imgbox.com/e1/cf/JXNxGiCr_o.png"></p> <p style="text-align:center;"><img alt="\cos (x)=1-\frac{1}{2 !} x^{2}+\frac{1}{4 !} x^{4}+\cdots" class="mathcode" src="https://images2.imgbox.com/be/9e/OrnCIf15_o.png"></p> </li><li>所以，如果<img alt="x = i\theta" class="mathcode" src="https://images2.imgbox.com/0f/08/lYcKbY6Q_o.png"> ，则有</li></ol> 
 <p style="text-align:center;"><img alt="\begin{aligned} e^{i \theta} &amp; =1+i \theta+\frac{(i \theta)^{2}}{2 !}+\frac{(i \theta)^{3}}{3 !}+\frac{(i \theta)^{4}}{4 !}+\frac{(i \theta)^{5}}{5 !}+\frac{(i \theta)^{6}}{6 !}+\frac{(i \theta)^{7}}{7 !}+\frac{(i \theta)^{8}}{8 !}+\cdots \\ &amp; =1+i \theta-\frac{\theta^{2}}{2 !}-\frac{i \theta^{3}}{3 !}+\frac{\theta^{4}}{4 !}+\frac{i \theta^{5}}{5 !}-\frac{\theta^{6}}{6 !}-\frac{i \theta^{7}}{7 !}+\frac{\theta^{8}}{8 !}+\cdots \\ &amp; =\left(1-\frac{\theta^{2}}{2 !}+\frac{\theta^{4}}{4 !}-\frac{\theta^{6}}{6 !}+\frac{\theta^{8}}{8 !}-\cdots\right)+i\left(\theta-\frac{\theta^{3}}{3 !}+\frac{\theta^{5}}{5 !}-\frac{\theta^{7}}{7 !}+\cdots\right) \\ &amp; =\cos \theta+i \sin \theta \end{aligned}" class="mathcode" src="https://images2.imgbox.com/9c/48/mlXlXCeO_o.png"></p> 
</blockquote> 
<h4>2.2.2 欧拉公式与三角函数</h4> 
<p>如何直观的理解这个欧拉公式呢？</p> 
<p>其实，可以把<img alt="e^{i \theta}" class="mathcode" src="https://images2.imgbox.com/5b/44/anyMrABK_o.png">看作通过单位圆的圆周运动来描述单位圆上的点，<img alt="\cos \theta+i \sin \theta" class="mathcode" src="https://images2.imgbox.com/09/c0/DTUqggkV_o.png">通过复平面的坐标来描述单位圆上的点，是同一个点不同的描述方式，所以有<img alt="e^{i \theta}=\cos \theta+i \sin \theta" class="mathcode" src="https://images2.imgbox.com/2c/70/SuBTdhDt_o.png">，如下图所示</p> 
<p class="img-center"><img alt="" height="474" src="https://images2.imgbox.com/86/4e/yLx2UrpR_o.png" width="600"></p> 
<p>根据欧拉公式<img alt="e^{i \theta}=\cos \theta+i \sin \theta" class="mathcode" src="https://images2.imgbox.com/51/39/GCrLy5gJ_o.png">，可以轻易推出：</p> 
<p style="text-align:center;"><img alt="\sin \theta=\frac{e^{i \theta}-e^{-i \theta}}{2 i}" class="mathcode" src="https://images2.imgbox.com/ea/20/ilQmQLoz_o.png"></p> 
<p style="text-align:center;"><img alt="\cos \theta=\frac{e^{i \theta}+e^{-i \theta}}{2}" class="mathcode" src="https://images2.imgbox.com/c5/15/HpUAJPgU_o.png"></p> 
<p>我们把复数当作向量来看待，复数的实部是<img alt="x" class="mathcode" src="https://images2.imgbox.com/4d/7c/GOLoBxhJ_o.png">方向，虚部是<img alt="y" class="mathcode" src="https://images2.imgbox.com/0c/4d/gOxEHLte_o.png">方向，很容易观察出其几何意义，如下图所示</p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/f5/29/ukfbp2jF_o.png" width="470"><img alt="" height="445" src="https://images2.imgbox.com/29/8e/aJ1X4oQj_o.png" width="470"></p> 
<blockquote> 
 <p>还在思考怎么得来的？很简单哦，还记得向量的加减法么？</p> 
 <p><img alt="" height="330" src="https://images2.imgbox.com/ae/e2/DFzd3QZR_o.png" width="468"><img alt="" height="330" src="https://images2.imgbox.com/59/db/pv08h5jb_o.png" width="415"></p> 
</blockquote> 
<h2>第三部分 旋转位置编码(RoPE)的推导与实现</h2> 
<h3>3.1 旋转位置编码的原理与推导</h3> 
<p>所谓旋转位置编码，其在位置编码上删除了绝对位置嵌入，而在网络的每一层增加了苏剑林等人(2021)提出的<a href="https://kexue.fm/archives/8265" rel="nofollow" title="旋转位置嵌入(RoPE)">旋转位置嵌入(RoPE)</a>，其思想是采用绝对位置编码的形式 实现相对位置编码，且RoPE主要借助了复数的思想</p> 
<p>具体来说，当咱们给self-attention中的<img alt="q,k,v" class="mathcode" src="https://images2.imgbox.com/a1/53/YW7ath3c_o.png">向量都加入了位置信息后，便可以表示为</p> 
<p style="text-align:center;"><img alt="\begin{aligned} \boldsymbol{q}_{m} &amp; =f_{q}\left(\boldsymbol{x}_{m}, m\right) \\ \boldsymbol{k}_{n} &amp; =f_{k}\left(\boldsymbol{x}_{n}, n\right) \\ \boldsymbol{v}_{n} &amp; =f_{v}\left(\boldsymbol{x}_{n}, n\right) \end{aligned}" class="mathcode" src="https://images2.imgbox.com/49/b8/f1u9cfWv_o.png"></p> 
<p>其中</p> 
<ul><li><img alt="\boldsymbol{q}_{m}" class="mathcode" src="https://images2.imgbox.com/97/2b/rruF7Gdk_o.png">表示「第 <img alt="m" class="mathcode" src="https://images2.imgbox.com/20/d7/b82o6h9U_o.png"> 个 token 对应的词向量 <img alt="x_m" class="mathcode" src="https://images2.imgbox.com/8b/fa/NMzjokzp_o.png"> 」集成「位置信息 <img alt="m" class="mathcode" src="https://images2.imgbox.com/4c/94/Nsp7aW20_o.png"> 」之后的 query 向量</li><li>而<img alt="k_n" class="mathcode" src="https://images2.imgbox.com/36/50/tc2CjadH_o.png"> 、 <img alt="v_n" class="mathcode" src="https://images2.imgbox.com/5c/07/MZXpy2du_o.png"> 则分别表示<strong>第 <img alt="n" class="mathcode" src="https://images2.imgbox.com/59/c6/SRQlPomE_o.png"> 个 token 对应的词向量 <img alt="x_n" class="mathcode" src="https://images2.imgbox.com/c7/5c/uTJqogKG_o.png"></strong> 集成<strong>位置信息 <img alt="n" class="mathcode" src="https://images2.imgbox.com/81/dd/dbfLTlxb_o.png"> 之后</strong>的 key 向量、 value 向量</li></ul> 
<h4>3.1.1 第一种形式的推导(可能是全网最通俗易懂版)</h4> 
<p>接着论文中提出为了能利用上 token 之间的相对位置信息，假定 query 向量 <img alt="q_m" class="mathcode" src="https://images2.imgbox.com/74/02/ShTyTQQN_o.png"> 和 key 向量 <img alt="k_n" class="mathcode" src="https://images2.imgbox.com/d2/f1/cEOFZKRs_o.png"> 之间的内积操作可以被一个函数 <img alt="g" class="mathcode" src="https://images2.imgbox.com/cb/10/f9UvQBeA_o.png"> 表示，该函数 <img alt="g" class="mathcode" src="https://images2.imgbox.com/a1/ac/d3oh67cA_o.png"> 的输入是词嵌入向量 <img alt="x_m" class="mathcode" src="https://images2.imgbox.com/f1/4a/Chg3DgP2_o.png">、<img alt="x_n" class="mathcode" src="https://images2.imgbox.com/c5/72/d8kkYHAZ_o.png"> ，和它们之间的相对位置 <img alt="m - n" class="mathcode" src="https://images2.imgbox.com/5b/74/h189D2zS_o.png">：</p> 
<p style="text-align:center;"><img alt="&lt;f_{q}\left(x_{m}, m\right), f_{k}\left(x_{n}, n\right)&gt;=g\left(x_{m}, x_{n}, m-n\right)" class="mathcode" src="https://images2.imgbox.com/56/bb/KyK6mHQn_o.png"></p> 
<blockquote> 
 <p>这里面其实有很大的一个关键，但大部分资料甚至RoPE原始论文都不会给你特别强调出来，即为何要构造这么一个等式呢？</p> 
 <ul><li>原因在于左边算是q和k向量的内积，而这恰好是transformer计算自注意力机制的核心一步，右边等式则意味着m与n的相对位置<br> 如此一来，该等式便把“q和k的内积”与“它们的相对位置”给串起来了</li><li>也如阿荀所说，左边是含有各自绝对位置信息的q向量和k向量，而这个等式就是RoPE追求的目标，物理含义就是<strong>通过显式传入绝对位置信息实现与传入相对位置信息对等</strong>的情况</li></ul> 
</blockquote> 
<p>假定现在词嵌入向量的维度是两维 <img alt="d = 2" class="mathcode" src="https://images2.imgbox.com/3b/8f/91CSLTPQ_o.png"> ，然后RoPE利用2维度平面上的向量的几何性质，再结合复数的性质，神奇般的找到了<span style="color:#be191c;">满足上述等式</span>的 <img alt="f" class="mathcode" src="https://images2.imgbox.com/67/64/KLOKumQy_o.png"> 和 <img alt="g" class="mathcode" src="https://images2.imgbox.com/b0/9e/bMbEUB6H_o.png"> ，其形式如下：</p> 
<p style="text-align:center;"><img alt="\begin{array}{l} f_{q}\left(\boldsymbol{x}_{m}, m\right)=\left(\boldsymbol{W}_{q} \boldsymbol{x}_{m}\right) e^{i m \theta} \\ f_{k}\left(\boldsymbol{x}_{n}, n\right)=\left(\boldsymbol{W}_{k} \boldsymbol{x}_{n}\right) e^{i n \theta} \\ g\left(\boldsymbol{x}_{m}, \boldsymbol{x}_{n}, m-n\right)=\operatorname{Re}\left[\left(\boldsymbol{W}_{q} \boldsymbol{x}_{m}\right)\left(\boldsymbol{W}_{k} \boldsymbol{x}_{n}\right)^{*} e^{i(m-n) \theta}\right] \end{array}" class="mathcode" src="https://images2.imgbox.com/59/69/ba0buP2p_o.png"></p> 
<p>这里面的 Re 表示复数的实部</p> 
<ul><li>进一步地， <img alt="f_q" class="mathcode" src="https://images2.imgbox.com/4e/90/Xks50GyC_o.png">可以表示成下面的式子(<span style="color:#7b7f82;"><em>如果此刻你觉得你有点懵，没事，下文马上会一步一步的详细推导</em></span>)：</li></ul> 
<p style="text-align:center;"><img alt="\begin{aligned} f_{q}\left(\boldsymbol{x}_{m}, m\right) &amp; =\left(\begin{array}{cc} \cos m \theta &amp; -\sin m \theta) \\ \sin m \theta &amp; \cos m \theta \end{array}\right)\left(\begin{array}{ll} W_{q}^{(1,1)} &amp; W_{q}^{(1,2)} \\ W_{q}^{(2,1)} &amp; W_{q}^{(2,2)} \end{array}\right)\left(\begin{array}{c} x_{m}^{(1)} \\ x_{m}^{(2)} \end{array}\right) \\ &amp; =\left(\begin{array}{cc} \cos m \theta &amp; -\sin m \theta) \\ \sin m \theta &amp; \cos m \theta \end{array}\right)\left(\begin{array}{c} q_{m}^{(1)} \\ q_{m}^{(2)} \end{array}\right) \end{aligned}" class="mathcode" src="https://images2.imgbox.com/bd/b2/Vi2ehNZr_o.png"></p> 
<ul><li>看到这里会发现，这不就是 query 向量乘以了一个旋转矩阵吗？这就是为什么叫做旋转位置编码的原因<br> 同理，<img alt="f_k" class="mathcode" src="https://images2.imgbox.com/83/0d/m1aIZUjl_o.png">  可以表示成下面的式子：</li></ul> 
<p style="text-align:center;"><img alt="\begin{aligned} f_{k}\left(\boldsymbol{x}_{m}, m\right) &amp; =\left(\begin{array}{cc} \cos m \theta &amp; -\sin m \theta) \\ \sin m \theta &amp; \cos m \theta \end{array}\right)\left(\begin{array}{ll} W_{k}^{(1,1)} &amp; W_{k}^{(1,2)} \\ W_{k}^{(2,1)} &amp; W_{k}^{(2,2)} \end{array}\right)\left(\begin{array}{c} x_{m}^{(1)} \\ x_{m}^{(2)} \end{array}\right) \\ &amp; =\left(\begin{array}{cc} \cos m \theta &amp; -\sin m \theta) \\ \sin m \theta &amp; \cos m \theta \end{array}\right)\left(\begin{array}{l} k_{m}^{(1)} \\ k_{m}^{(2)} \end{array}\right) \end{aligned}" class="mathcode" src="https://images2.imgbox.com/ad/74/f2lkzTtt_o.png"></p> 
<ul><li>最终<img alt="g\left(\boldsymbol{x}_{m}, \boldsymbol{x}_{n}, m-n\right)" class="mathcode" src="https://images2.imgbox.com/6b/4a/E6e2H0X3_o.png">可以表示如下：</li></ul> 
<p style="text-align:center;"><img alt="g\left(\boldsymbol{x}_{m}, \boldsymbol{x}_{n}, m-n\right)=\left(\begin{array}{ll} \boldsymbol{q}_{m}^{(1)} &amp; \boldsymbol{q}_{m}^{(2)} \end{array}\right)\left(\begin{array}{cc} \cos ((m-n) \theta) &amp; -\sin ((m-n) \theta) \\ \sin ((m-n) \theta) &amp; \cos ((m-n) \theta) \end{array}\right)\left(\begin{array}{c} k_{n}^{(1)} \\ k_{n}^{(2)} \end{array}\right)" class="mathcode" src="https://images2.imgbox.com/96/ce/JSkNXiZD_o.png"></p> 
<blockquote> 
 <p>然上述分别关于<img alt="f_q" class="mathcode" src="https://images2.imgbox.com/58/6c/PnO3J48b_o.png">、<img alt="f_k" class="mathcode" src="https://images2.imgbox.com/3f/80/V5sTIrAw_o.png">、<img alt="g\left(\boldsymbol{x}_{m}, \boldsymbol{x}_{n}, m-n\right)" class="mathcode" src="https://images2.imgbox.com/53/ff/qwMrWCA0_o.png">的三个式子，咋一步一步推导来的？为做细致说明，特参考<a class="link-info" href="https://zhuanlan.zhihu.com/p/642884818" rel="nofollow" title="此文">此文</a>一步一步解释下</p> 
 <hr> 
 <p>首先看<span style="color:#ed7976;">第一个式子</span>，对于<img alt="f_{q}\left(x_{m}, m\right)=\left(W_{q} x_{m}\right) e^{i m \theta}" class="mathcode" src="https://images2.imgbox.com/a4/0c/7XWwRCxC_o.png">，这个式子的右边项有两部分，一部分是<img alt="W_{q} x_{m}" class="mathcode" src="https://images2.imgbox.com/34/2c/eFjMB01V_o.png">、一部分是<img alt="e^{i m \theta}" class="mathcode" src="https://images2.imgbox.com/9d/28/gRGD147W_o.png"></p> 
 <ol><li><span style="color:#1a439c;">对于前者<img alt="W_{q} x_{m}" class="mathcode" src="https://images2.imgbox.com/6a/2b/CIpdlQHd_o.png"></span>，可知其中的<img alt="W_q" class="mathcode" src="https://images2.imgbox.com/bd/52/4KbXTZbP_o.png">是个二维矩阵，<img alt="x_m" class="mathcode" src="https://images2.imgbox.com/9a/6c/rDGTmdv4_o.png">是个二维向量，自然相乘的结果也必然是一个二维向量，<span style="color:#1a439c;">用<img alt="q_m" class="mathcode" src="https://images2.imgbox.com/dd/d8/kwvlvO82_o.png">表示</span><br><img alt="q_{m}=\left(\begin{array}{c} q_{m}^{(1)} \\ q_{m}^{(2)} \end{array}\right)=W_{q} x_{m}=\left(\begin{array}{ll} W_{q}^{(11)} &amp; W_{q}^{(12)} \\ W_{q}^{(21)} &amp; W_{q}^{(22)} \end{array}\right)\left(\begin{array}{c} x_{m}^{(1)} \\ x_{m}^{(2)} \end{array}\right)" class="mathcode" src="https://images2.imgbox.com/c5/ac/nCzvYvyZ_o.png"></li><li><span style="color:#1a439c;">对于后者<img alt="e^{i m \theta}" class="mathcode" src="https://images2.imgbox.com/b6/d9/XK1g09pc_o.png"></span>，根据欧拉公式<img alt="e^{i x}=\cos x+i \sin x" class="mathcode" src="https://images2.imgbox.com/43/f5/rkgUr0i5_o.png">，可得<br><img alt="\begin{array}{c} e^{i m \theta}=\cos (m \theta)+i \sin (m \theta) \\ e^{i n \theta}=\cos (n \theta)+i \sin (n \theta) \\ e^{i(m-n) \theta}=\cos ((m-n) \theta)+i \sin ((m-n) \theta) \end{array}" class="mathcode" src="https://images2.imgbox.com/7b/0b/ecn6If2E_o.png"><br>  </li><li>基于上面第1点结论，可知<br><img alt="f_{q}\left(x_{m}, m\right)=\left(W_{q} x_{m}\right) e^{i m \theta}=q_{m} e^{i m \theta}" class="mathcode" src="https://images2.imgbox.com/bc/79/skGzg5Rl_o.png"><br> 然后将<img alt="q_m" class="mathcode" src="https://images2.imgbox.com/f7/0d/Jtshkmo2_o.png">表示成复数形式，可得<br><img alt="q_{m}=\left[q_{m}^{(1)}, q_{m}^{(2)}\right]=\left[q_{m}^{(1)}+i q_{m}^{(2)}\right]" class="mathcode" src="https://images2.imgbox.com/41/ce/0nG7OCmB_o.png"><br> 从而有<br><img alt="f_{q}\left(x_{m}, m\right)= q_{m} e^{i m \theta} = \left[q_{m}^{(1)}+i q_{m}^{(2)}\right] e^{i m \theta}" class="mathcode" src="https://images2.imgbox.com/87/e2/f4nogPFz_o.png"><br><br> 基于上面第2点结论，可知<img alt="f_{q}\left(x_{m}, m\right)" class="mathcode" src="https://images2.imgbox.com/b4/9c/h2mTFL1H_o.png">即是两个复数相乘<br><img alt="f_{q}\left(x_{m}, m\right) = q_{m} e^{i m \theta}=\left(q_{m}^{(1)}+i q_{m}^{(2)}\right) *(\cos (m \theta)+i \sin (m \theta))" class="mathcode" src="https://images2.imgbox.com/42/7f/fXCzA52x_o.png"></li><li>考虑到以下两个关于复数的背景知识<br><img alt="(a+i b) \cdot(c+i d)=a c+i b c+i a d+i^{2} b d=(a c-b d)+i(b c+a d)" class="mathcode" src="https://images2.imgbox.com/11/20/CQtV4OU9_o.png"><br><img alt="i^{2}=-1" class="mathcode" src="https://images2.imgbox.com/6a/5c/ovpMvQzq_o.png"><br><br> 可得<br><img alt="\begin{aligned} q_{m} e^{i m \theta} &amp; =\left(q_{m}^{(1)}+i q_{m}^{(2)}\right) *(\cos (m \theta)+i \sin (m \theta)) \\ =\left(q_{m}^{(1)} \cos (m \theta)\right. &amp; \left.-q_{m}^{(2)} \sin (m \theta)\right)+i\left(q_{m}^{(2)} \cos (m \theta)+q_{m}^{(1)} \sin (m \theta)\right) \end{aligned}" class="mathcode" src="https://images2.imgbox.com/59/24/T8aV2Gee_o.png"><br><br> 将这个结果表达成实数向量形式，即是<br><img alt="q_{m} e^{i m \theta}=\left[q_{m}^{(1)} \cos (m \theta)-q_{m}^{(2)} \sin (m \theta), q_{m}^{(2)} \cos (m \theta)+q_{m}^{(1)} \sin (m \theta)\right]" class="mathcode" src="https://images2.imgbox.com/de/32/Atb5685F_o.png"><br><br> 至此，你也就不难发现，这不就是<strong>query向量乘以了一个旋转矩阵</strong>么<br><img alt="\begin{array}{c} f_{q}\left(x_{m}, m\right)=\left(W_{q} x_{m}\right) e^{i m \theta}=q_{m} e^{i m \theta} \\ =\left[q_{m}^{(1)} \cos (m \theta)-q_{m}^{(2)} \sin (m \theta), q_{m}^{(2)} \cos (m \theta)+q_{m}^{(1)} \sin (m \theta)\right] \\ =\left(\begin{array}{cc} \cos (m \theta) &amp; -\sin (m \theta) \\ \sin (m \theta) &amp; \cos (m \theta) \end{array}\right)\left(\begin{array}{c} q_{m}^{(1)} \\ q_{m}^{(2)} \end{array}\right) \end{array}" class="mathcode" src="https://images2.imgbox.com/7e/db/LF9wV05n_o.png"></li></ol> 
 <p>至于<span style="color:#ed7976;">第二个式子</span>，根据上述过程同理，可得key向量<img alt="k_n" class="mathcode" src="https://images2.imgbox.com/99/7a/PP2BlBnM_o.png"></p> 
 <ul><li><img alt="\begin{array}{c} f_{k}\left(x_{n}, n\right)=\left(W_{k} x_{n}\right) e^{i n \theta}=k_{n} e^{i n \theta} \\ =\left[k_{n}^{(1)} \cos (n \theta)-k_{n}^{(2)} \sin (n \theta), k_{n}^{(2)} \cos (n \theta)+k_{n}^{(1)} \sin (n \theta)\right] \\ =\left(\begin{array}{cc} \cos (n \theta) &amp; -\sin (n \theta) \\ \sin (n \theta) &amp; \cos (n \theta) \end{array}\right)\left(\begin{array}{c} k_{n}^{(1)} \\ k_{n}^{(2)} \end{array}\right) \end{array}" class="mathcode" src="https://images2.imgbox.com/3c/fd/q68qFzpp_o.png"></li></ul> 
 <p>最后<span style="color:#ed7976;">第三个式子</span>，函数g，则可得</p> 
 <ul><li><img alt="g\left(x_{m}, x_{n}, m-n\right)=\operatorname{Re}\left[\left(W_{q} x_{m}\right)\left(W_{k} x_{n}\right)^{*} e^{i(m-n) \theta}\right]" class="mathcode" src="https://images2.imgbox.com/17/e7/KqevLehj_o.png"></li></ul> 
 <p>其中，<img alt="Re[x]" class="mathcode" src="https://images2.imgbox.com/d5/af/KnSWUqfz_o.png">表示一个复数<img alt="x" class="mathcode" src="https://images2.imgbox.com/87/25/Xy0cLJ4s_o.png">的实数部分，而<img alt="\left(W_{k} x_{n}\right)^{*}" class="mathcode" src="https://images2.imgbox.com/fc/19/vsvPsSyU_o.png">则表示复数<img alt="W_{k} x_{n}" class="mathcode" src="https://images2.imgbox.com/12/c9/4lv8DmH4_o.png">的共轭</p> 
 <ol><li>考虑到<br><img alt="\begin{array}{c} z=a+i b \\ z^{*}=a-i b \end{array}" class="mathcode" src="https://images2.imgbox.com/3b/4c/fK9wwDc3_o.png"><br> 再结合上面第一个式子中的推导，可得<br><img alt="\begin{array}{c} W_{q} x_{m}=q_{m}=q_{m}^{(1)}+i q_{m}^{(2)} \\ W_{k} x_{n}=k_{n}=k_{n}^{(1)}+i k_{n}^{(2)} \\ \left(W_{k} x_{n}\right)^{*}=k_{n}^{*}=k_{n}^{(1)}-i k_{n}^{(2)} \\ e^{i(m-n) \theta}=\cos ((m-n) \theta)+i \sin ((m-n) \theta) \end{array}" class="mathcode" src="https://images2.imgbox.com/49/fd/9EMoiyxU_o.png"><br> 继续结合上面第一个式子中的推导(<span style="color:#7b7f82;"><em>比如<img alt="(a+i b) \cdot(c+i d)=a c+i b c+i a d+i^{2} b d=(a c-b d)+i(b c+a d)" class="mathcode" src="https://images2.imgbox.com/fb/0b/fbAKQsKO_o.png">，及</em></span><img alt="i^{2}=-1" class="mathcode" src="https://images2.imgbox.com/e4/e5/6j3VTNbp_o.png">)，继续可知，我们现在要证明的是存在<br><img alt="\begin{array}{c} g\left(x_{m}, x_{n}, m-n\right)=\operatorname{Re}\left[\left(W_{q} x_{m}\right)\left(W_{k} x_{n}\right)^{*} e^{i(m-n) \theta}\right] \\ =\operatorname{Re}\left[\left(q_{m}^{(1)}+i q_{m}^{(2)}\right)\left(k_{n}^{(1)}-i k_{n}^{(2)}\right)(\cos ((m-n) \theta)+i \sin ((m-n) \theta))\right] \\ =\operatorname{Re}\left[\left(\left(q_{m}^{(1)} k_{n}^{(1)}+q_{m}^{(2)} k_{n}^{(2)}\right)+i\left(q_{m}^{(2)} k_{n}^{(1)}-q_{m}^{(1)} k_{n}^{(2)}\right)\right)(\cos ((m-n) \theta)+i \sin ((m-n) \theta))\right] \\ =\left(q_{m}^{(1)} k_{n}^{(1)}+q_{m}^{(2)} k_{n}^{(2)}\right) \cos ((m-n) \theta)-\left(q_{m}^{(2)} k_{n}^{(1)}-q_{m}^{(1)} k_{n}^{(2)}\right) \sin ((m-n) \theta) \end{array}" class="mathcode" src="https://images2.imgbox.com/a6/2f/ZIbG7DIn_o.png"></li><li>总之，接下来我们就要证明上述函数 g 的计算公式是成立的<br> 首先，回顾一下attention操作，位置m的query和位置n的key会做一个内积操作<br> 即由<br><img alt="\begin{array}{c} f_{q}\left(x_{m}, m\right)=\left[q_{m}^{(1)} \cos (m \theta)-q_{m}^{(2)} \sin (m \theta), q_{m}^{(2)} \cos (m \theta)+q_{m}^{(1)} \sin (m \theta)\right] \\ f_{k}\left(x_{n}, n\right)=\left[k_{n}^{(1)} \cos (n \theta)-k_{n}^{(2)} \sin (n \theta), k_{n}^{(2)} \cos (n \theta)+k_{n}^{(1)} \sin (n \theta)\right] \end{array}" class="mathcode" src="https://images2.imgbox.com/38/25/KhAyPALl_o.png"><br> 可得<br><img alt="\begin{array}{c} &lt;f_{q}\left(x_{m}, m\right), f_{k}\left(x_{n}, n\right)&gt; \\ = \left(q_{m}^{(1)} \cos (m \theta)-q_{m}^{(2)} \sin (m \theta)\right)\left(k_{n}^{(1)} \cos (n \theta)-k_{n}^{(2)} \sin (n \theta)\right) \\ +\left(q_{m}^{(2)} \cos (m \theta)+q_{m}^{(1)} \sin (m \theta)\right)\left(k_{n}^{(2)} \cos (n \theta)+k_{n}^{(1)} \sin (n \theta)\right) \\ =q_{m}^{(1)} \cos (m \theta) k_{n}^{(1)} \cos (n \theta)-q_{m}^{(1)} \cos (m \theta) k_{n}^{(2)} \sin (n \theta) \\ -q_{m}^{(2)} \sin (m \theta) k_{n}^{(1)} \cos (n \theta)+q_{m}^{(2)} \sin (m \theta) k_{n}^{(2)} \sin (n \theta) \\ +q_{m}^{(2)} \cos (m \theta) k_{n}^{(2)} \cos (n \theta)+q_{m}^{(2)} \cos (m \theta) k_{n}^{(1)} \sin (n \theta) \\ +q_{m}^{(1)} \sin (m \theta) k_{n}^{(2)} \cos (n \theta)+q_{m}^{(1)} \sin (m \theta) k_{n}^{(1)} \sin (n \theta) \end{array}" class="mathcode" src="https://images2.imgbox.com/ed/70/R3ymdfh4_o.png"><br> 「<span style="color:#7b7f82;"><em>相当于[A,B]与[C,D]做内积，则相当于A B横着，C D竖着，最终结果为AC BD，最后再把括号里的项全部对应相乘、展开</em></span>」</li><li>首先，把上面第二点的式子整理一下，总计8项，为了把<img alt="qk" class="mathcode" src="https://images2.imgbox.com/52/16/jh6r6ngo_o.png">相关的项提取出来，第1项 8项合并处理、第2项 7项合并处理、第3项 6项合并处理、第4项 5项合并处理<br> 其次，考虑到<br><img alt="\begin{array}{l} \sin (a+b)=\sin a \cos b+\cos a \sin b \\ \sin (a-b)=\sin a \cos b-\cos a \sin b \\ \cos (a+b)=\cos a \cos b-\sin a \sin b \\ \cos (a-b)=\cos a \cos b+\sin a \sin b \end{array}" class="mathcode" src="https://images2.imgbox.com/31/dc/4BdG3rZH_o.png"><br> 最后，再把相关项的特点，两次调整下顺序即可<br><br> 依据以上三点，从而有<br><img alt="\begin{array}{c} &lt;f_{q}\left(x_{m}, m\right), f_{k}\left(x_{n}, n\right)&gt;\\ = q_{m}^{(1)} k_{n}^{(1)}(\cos (m \theta) \cos (n \theta)+\sin (m \theta) \sin (n \theta)) \\ +q_{m}^{(1)} k_{n}^{(2)}(-\cos (m \theta) \sin (n \theta)+\sin (m \theta) \cos (n \theta)) \\ +q_{m}^{(2)} k_{n}^{(1)}(-\sin (m \theta) \cos (n \theta)+\cos (m \theta) \sin (n \theta)) \\ +q_{m}^{(2)} k_{n}^{(2)}(\sin (m \theta) \sin (n \theta)+\cos (m \theta) \cos (n \theta)) \\ =q_{m}^{(1)} k_{n}^{(1)} \cos ((m-n) \theta) \\ +q_{m}^{(1)} k_{n}^{(2)} \sin ((m-n) \theta) \\ -q_{m}^{(2)} k_{n}^{(1)} \sin ((m-n) \theta) \\ +q_{m}^{(2)} k_{n}^{(2)} \cos ((m-n) \theta) \\ =\left(q_{m}^{(1)} k_{n}^{(1)}+q_{m}^{(2)} k_{n}^{(2)}\right) \cos ((m-n) \theta)+\left(q_{m}^{(1)} k_{n}^{(2)}-q_{m}^{(2)} k_{n}^{(1)}\right) \sin ((m-n) \theta) \\ =\left(q_{m}^{(1)} k_{n}^{(1)}+q_{m}^{(2)} k_{n}^{(2)}\right) \cos ((m-n) \theta)-\left(q_{m}^{(2)} k_{n}^{(1)}-q_{m}^{(1)} k_{n}^{(2)}\right) \sin ((m-n) \theta) \\ =g\left(x_{m}, x_{n}, m-n\right) \end{array}" class="mathcode" src="https://images2.imgbox.com/2e/87/rAbjAsT6_o.png"><br><br> 完美! 如此，也就证明了，位置 m 的 query 和位置 n 的 key 的内积就是函数 g 
   <hr><p>最后，把上面的式子一、式子二的最终结果都分别用矩阵向量乘的形式来表达就是：</p> <p style="text-align:center;"><img alt="\begin{array}{c} &lt;f_{q}\left(x_{m}, m\right), f_{k}\left(x_{n}, n\right)&gt; \\ =\left(\left(\begin{array}{cc} \cos (m \theta) &amp; -\sin (m \theta) \\ \sin (m \theta) &amp; \cos (m \theta) \end{array}\right)\left(\begin{array}{c} q_{m}^{(1)} \\ q_{m}^{(2)} \end{array}\right)\right)^{T}\left(\left(\begin{array}{cc} \cos (n \theta) &amp; -\sin (n \theta) \\ \sin (n \theta) &amp; \cos (n \theta) \end{array}\right)\left(\begin{array}{c} k_{n}^{(1)} \\ k_{n}^{(2)} \end{array}\right)\right) \\ =\left(\begin{array}{ll} q_{m}^{(1)} &amp; q_{m}^{(2)} \end{array}\right)\left(\begin{array}{cc} \cos (m \theta) &amp; \sin (m \theta) \\ -\sin (m \theta) &amp; \cos (m \theta) \end{array}\right)\left(\begin{array}{cc} \cos (n \theta) &amp; -\sin (n \theta) \\ \sin (n \theta) &amp; \cos (n \theta) \end{array}\right)\left(\begin{array}{l} k_{n}^{(1)} \\ k_{n}^{(2)} \end{array}\right) \end{array}" class="mathcode" src="https://images2.imgbox.com/2e/e8/L4eYfOjT_o.png"></p> <p></p> <p>接下来，我们要计算两个旋转矩阵的乘积，即中间部分的这个式子</p> <p style="text-align:center;"><img alt="\left(\begin{array}{cc} \cos (m \theta) &amp; \sin (m \theta) \\ -\sin (m \theta) &amp; \cos (m \theta) \end{array}\right)\left(\begin{array}{cc} \cos (n \theta) &amp; -\sin (n \theta) \\ \sin (n \theta) &amp; \cos (n \theta) \end{array}\right)" class="mathcode" src="https://images2.imgbox.com/db/02/SFGEud5p_o.png"></p> <p></p> <p>展开之后，可得</p> <p style="text-align:center;"><img alt="\left(\begin{array}{cc} \cos (m \theta) \cos (n \theta)+\sin (m \theta) \sin (n \theta) &amp; -\cos (m \theta) \sin (n \theta)+\sin (m \theta) \cos (n \theta) \\ -\sin (m \theta) \cos (n \theta)+\cos (m \theta) \sin (n \theta) &amp; \sin (m \theta) \sin (n \theta)+\cos (m \theta) \cos (n \theta) \end{array}\right)" class="mathcode" src="https://images2.imgbox.com/e4/ac/q9Aottoc_o.png"></p> <p></p> <p>从而有</p> <p style="text-align:center;"><img alt="\begin{array}{l} &lt;f_{q}\left(x_{m}, m\right), {f_{k}\left(x_{n}, n\right)&gt;} \\ =\left(\begin{array}{ll} q_{m}^{(1)} &amp; q_{m}^{(2)} \end{array}\right)\left(\begin{array}{cc} \cos ((m-n) \theta) &amp; -\sin ((m-n) \theta) \\ \sin ((m-n) \theta) &amp; \cos ((m-n) \theta) \end{array}\right)\left(\begin{array}{c} k_{n}^{(1)} \\ k_{n}^{(2)} \end{array}\right) \end{array}" class="mathcode" src="https://images2.imgbox.com/f7/41/AZmrXuED_o.png"></p> </li></ol> 
</blockquote> 
<p>上面都还只是针对词嵌入维度为2的情况，那对于<img alt="d&gt;=2" class="mathcode" src="https://images2.imgbox.com/45/f5/tuVA9ipZ_o.png">的通用情况呢，将2维推广到任意维度，可以表示如下：</p> 
<p style="text-align:center;"><img alt="f_{\{q, k\}}\left(\boldsymbol{x}_{m}, m\right)=\boldsymbol{R}_{\Theta, m}^{d} \boldsymbol{W}_{\{q, k\}} \boldsymbol{x}_{m}" class="mathcode" src="https://images2.imgbox.com/a7/fa/8n1O9Uyn_o.png"></p> 
<p>内积满足线性叠加性，因此任意偶数维的RoPE，我们都可以表示为二维情形的拼接，即将词嵌入向量元素按照两两一组分组</p> 
<p style="text-align:center;"><img alt="\boldsymbol{R}_{\Theta, m}^{d}=\underbrace{\left(\begin{array}{ccccccc} \cos m \theta_{0} &amp; -\sin m \theta_{0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ \sin m \theta_{0} &amp; \cos m \theta_{0} &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \cos m \theta_{1} &amp; -\sin m \theta_{1} &amp; \cdots &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \sin m \theta_{1} &amp; \cos m \theta_{1} &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cos m \theta_{d / 2-1} &amp; -\sin m \theta_{d / 2-1} \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \sin m \theta_{d / 2-1} &amp; \cos m \theta_{d / 2-1} \end{array}\right)}_{\boldsymbol{W}_{m}}" class="mathcode" src="https://images2.imgbox.com/b1/b7/DYA7s8hL_o.png"></p> 
<p>每组应用同样的旋转操作且每组的旋转角度计算方式如下：</p> 
<p style="text-align:center;"><img alt="\Theta=\left\{\theta_{i}=10000^{-2(i-1) / d}, i \in[1,2, \ldots, d / 2]\right\}" class="mathcode" src="https://images2.imgbox.com/9b/26/eKH3Df9A_o.png"></p> 
<p>所以简单来说 RoPE 的 self-attention 操作的流程是</p> 
<p class="img-center"><img alt="" height="398" src="https://images2.imgbox.com/e9/cc/968mIeGM_o.png" width="700"></p> 
<ol><li>对于 token 序列中的每个词嵌入向量，首先计算其对应的 query 和 key 向量</li><li>然后对每个 token 位置都计算对应的旋转位置编码</li><li>接着对每个 token 位置的 query 和 key 向量的元素按照 两两一组 应用旋转变换</li><li>最后再计算 query 和 key 之间的内积得到 self-attention 的计算结果</li></ol> 
<h4>3.1.2 第二种形式的推导(苏剑林版)</h4> 
<p>与上面第一种形式的推导类似，为了引入复数，首先假设了在加入位置信息之前，原有的编码向量是二维行向量<img alt="q_m" src="https://images2.imgbox.com/7e/4d/3wc3EAsM_o.png">和<img alt="k_n" src="https://images2.imgbox.com/ce/d8/t5e6aFHt_o.png">，其中<img alt="m" src="https://images2.imgbox.com/99/46/aqZVBabr_o.png">和<img alt="n" src="https://images2.imgbox.com/ec/2e/xSZOZiVF_o.png">是绝对位置，现在需要构造一个变换，将<img alt="m" src="https://images2.imgbox.com/4d/c0/O5KgVJgE_o.png">和<img alt="n" src="https://images2.imgbox.com/fb/d5/PLB6OP1O_o.png">引入到<img alt="q_m" src="https://images2.imgbox.com/0c/fb/djln1iwR_o.png">和<img alt="k_n" src="https://images2.imgbox.com/5a/6e/TBddWAlO_o.png">中，即寻找变换： </p> 
<p class="img-center"><img alt="\tilde {q_m} = f(q, m), \tilde{k_n} = f(k, n)" class="mathcode" src="https://images2.imgbox.com/9f/fd/E1QC78uj_o.png"></p> 
<p>也就是说，我们分别为<img alt="q" src="https://images2.imgbox.com/13/a2/U2NKcNKd_o.png">、<img alt="k" src="https://images2.imgbox.com/de/6d/Q4RniwPF_o.png">设计操作<img alt="f(\cdot ,m)" src="https://images2.imgbox.com/d1/c6/58ZvW5sN_o.png">、<img alt="f(\cdot ,n)" src="https://images2.imgbox.com/7b/f5/yyd7ZKRf_o.png">，使得经过该操作后，<img alt="\tilde {q_m}" src="https://images2.imgbox.com/17/35/FUtqLGNF_o.png">、<img alt="\tilde{k_n}" src="https://images2.imgbox.com/ce/e4/A6fNuDjm_o.png">就带有了位置<img alt="m" src="https://images2.imgbox.com/78/e5/NvNu82zu_o.png">、<img alt="n" src="https://images2.imgbox.com/3d/b1/7nLFbc8S_o.png">的绝对位置信息<br> 考虑到Attention的核心计算是内积：</p> 
<p style="text-align:center;"><img alt="Attention(Q, K,V) = softmax(\frac {QK^T} {\sqrt{d_k}})V" class="mathcode" src="https://images2.imgbox.com/b0/c1/0f17H9Vz_o.png"></p> 
<p>故我们希望的内积的结果带有相对位置信息，即寻求的这个<img alt="f(*)" src="https://images2.imgbox.com/f6/b2/Jx8rHNrf_o.png">变换，应该具有特性：</p> 
<p class="img-center"><img alt="\langle f(q, m), f(k, n) \rangle = g(q, k, m-n)" src="https://images2.imgbox.com/5b/09/Y1Yw9BVY_o.png"></p> 
<p>「<strong>怎么理解？很简单，当m和n表示了绝对位置之后，m与n在句子中的距离即位置差m-n，就可以表示为相对位置了，且对于复数，内积通常定义为一个复数与另一个复数的共轭的乘积」</strong></p> 
<ol><li>为合理的求出该恒等式的一个尽可能简单的解，可以设定一些初始条件，比如<img alt="f(q,0)=q" src="https://images2.imgbox.com/ca/ee/0JNZrVK8_o.png">、<img alt="f(k,0)=k" src="https://images2.imgbox.com/ed/9e/88jbgrHK_o.png">，然后可以先考虑二维情形，然后借助复数来求解<br> 在复数中有<img alt="\langle\boldsymbol{q}, \boldsymbol{k}\rangle=\operatorname{Re}\left[\boldsymbol{q} \boldsymbol{k}^{*}\right]" src="https://images2.imgbox.com/d2/4e/emzVkqOd_o.png">，<img alt="Re[]" src="https://images2.imgbox.com/5e/ee/tSeIe0ej_o.png">表示取实部的操作(复数 <img alt="q" src="https://images2.imgbox.com/45/e7/78S7Ow3W_o.png"> 和“ 复数 <img alt="k" src="https://images2.imgbox.com/c3/b3/U29YY5rc_o.png"> 的共轭即<img alt="k^*" class="mathcode" src="https://images2.imgbox.com/26/d1/maqdtCis_o.png"> ”之积仍是一个复数)<br><em><span style="color:#7b7f82;">因论文100课的群里有学员对该点存在疑问，故借用七月黄老师的回复补充下：这个等式和复数乘法和向量乘积的联系有关<br> 考虑两个复数<br><img alt="q = a + bi" class="mathcode" src="https://images2.imgbox.com/a2/12/p3BfLxFV_o.png"><br><img alt="k = c + di" class="mathcode" src="https://images2.imgbox.com/aa/8c/jRXq4DqS_o.png">，<img alt="k" class="mathcode" src="https://images2.imgbox.com/5c/ee/ifEdgTTe_o.png">的共轭是<img alt="k^*= c - di" class="mathcode" src="https://images2.imgbox.com/8d/d9/ShwoZ1S9_o.png"><br><strong>一方面，对于等式的右边项而言</strong><br> q和k*的乘积是 <img alt="q k^* = (a + bi)(c - di) = ac - adi + cbi + bd = (ac + bd) + (cb - ad)i" class="mathcode" src="https://images2.imgbox.com/70/fc/LqT3LDxc_o.png"><br> 这个结果的实部是 <img alt="ac + bd" class="mathcode" src="https://images2.imgbox.com/78/f5/txWgQISV_o.png"><br><strong>二方面，对于等式的左边项而言</strong><br> 其对应于<img alt="q" class="mathcode" src="https://images2.imgbox.com/a5/50/USciaNaV_o.png">对应的实数向量<img alt="[a, b]" class="mathcode" src="https://images2.imgbox.com/95/69/kGLM8ktB_o.png">和<img alt="k" class="mathcode" src="https://images2.imgbox.com/1f/69/Q8j9Hx1g_o.png">对应的实数向量<img alt="[c, d]" class="mathcode" src="https://images2.imgbox.com/9e/7c/72Z2sFwz_o.png">的乘积<br><img alt="[a, b] \cdot [c, d] = ac + bd" class="mathcode" src="https://images2.imgbox.com/bb/59/FeLVWtvI_o.png"><br> 综合以上两点，可知右边项所表示的“复数q和复数k的共轭k*的乘积”，和左边项做表示的“q、k所对应向量的乘积”是一样的</span></em><br><br> 总之，我们需要寻找一种<img alt="f(*)" src="https://images2.imgbox.com/89/3e/dWOTHz9A_o.png">变换，使得<br><img alt="Re[f(q,m)f^{*}(k,n)] = g(q,k,m-n)" src="https://images2.imgbox.com/07/f0/rAGe3bsG_o.png"></li><li>简单起见，我们假设存在复数<img alt="g(q,k,m-n)" src="https://images2.imgbox.com/c8/13/sXMTfYTB_o.png">，使得<img alt="f(q,m)f^*(k,n)=g(q,k,m-n)" src="https://images2.imgbox.com/d0/0f/RT2vH132_o.png">，然后我们用复数的指数形式，设<br><img alt="\begin{aligned} \boldsymbol{f}(\boldsymbol{q}, m) &amp; =R_{f}(\boldsymbol{q}, m) e^{\mathrm{i} \Theta_{f}(\boldsymbol{q}, m)} \\ \boldsymbol{f}(\boldsymbol{k}, n) &amp; =R_{f}(\boldsymbol{k}, n) e^{\mathrm{i} \Theta_{f}(\boldsymbol{k}, n)} \\ \boldsymbol{g}(\boldsymbol{q}, \boldsymbol{k}, m-n) &amp; =R_{g}(\boldsymbol{q}, \boldsymbol{k}, m-n) e^{\mathrm{i} \Theta_{g}(\boldsymbol{q}, \boldsymbol{k}, m-n)} \end{aligned}" src="https://images2.imgbox.com/8b/09/VQf7Pn5B_o.png"></li><li>那么代入方程后就得到两个方程<br> 方程1：<img alt="Rf(q,m)Rf(k,n) = Rg(q,k,m-n)" src="https://images2.imgbox.com/15/50/atfi1kCe_o.png"><br> 方程2：<strong>Θf(q,m)−Θf(k,n) = Θg(q,k,m−n)</strong><br><br><img alt="\rightarrow" src="https://images2.imgbox.com/ef/8c/LwJ9xSvD_o.png">  对于方程1，代入<img alt="m=n" src="https://images2.imgbox.com/0f/93/vSooaay1_o.png">得到(接着，再把<img alt="m" src="https://images2.imgbox.com/76/1d/LkquhNhR_o.png">和<img alt="n" src="https://images2.imgbox.com/d6/0a/k2iTJGA3_o.png">都设为0)<br><img alt="R_{f}(\boldsymbol{q}, m) R_{f}(\boldsymbol{k}, m)=R_{g}(\boldsymbol{q}, \boldsymbol{k}, 0)=R_{f}(\boldsymbol{q}, 0) R_{f}(\boldsymbol{k}, 0)=\|\boldsymbol{q}\|\|\boldsymbol{k}\|" src="https://images2.imgbox.com/b1/11/8eungHGG_o.png"><br> 最后一个等号源于初始条件<img alt="f(q,0) = q" src="https://images2.imgbox.com/f8/1c/VaCDqZ0A_o.png">和<img alt="f(k,0) = k" src="https://images2.imgbox.com/e8/26/2bbuewdx_o.png">，所以现在我们可以很简单地设<img alt="Rf(q,m) = \left \| q \right \|" class="mathcode" src="https://images2.imgbox.com/08/20/cVSiuqSU_o.png">，<img alt="Rf(k,m)= \left \| k \right \|" src="https://images2.imgbox.com/04/3c/pdlYNabH_o.png">，即它不依赖于<img alt="m" src="https://images2.imgbox.com/83/99/AhGEC16X_o.png"><br><br><img alt="\rightarrow" src="https://images2.imgbox.com/be/0a/BkgUiZmq_o.png">  至于方程2，同样代入<img alt="m=n" src="https://images2.imgbox.com/a6/a3/SclLQO7j_o.png">得到<br> Θf(q,m)−Θf(k,m) = Θg(q,k,0) = Θf(q,0)−Θf(k,0)<strong> </strong>= Θ(q)−Θ(k)<br><br> 这里的<img alt="\Theta(q)" class="mathcode" src="https://images2.imgbox.com/88/7a/jq3KXJQO_o.png">、<img alt="\Theta(k)" src="https://images2.imgbox.com/4e/8c/tAFBZsPW_o.png">是<img alt="q" src="https://images2.imgbox.com/dc/47/qP0B0gwJ_o.png">、<img alt="k" src="https://images2.imgbox.com/87/69/YWxlk7tK_o.png">本身的幅角，而最后一个等号同样源于初始条件<br> 根据上式Θf(q,m)−Θf(k,m) = Θ(q)−Θ(k)，可得Θf(q,m)−Θ(q)=Θf(k,m)−Θ(k)，所以Θf(q,m)−Θ(q)的结果是一个只与m相关、跟q无关的函数，记为φ(m)，即Θf(q,m)=Θ(q)+φ(m)</li><li>接着令n=m−1代入<strong>Θf(q,m)−Θf(k,n) = Θg(q,k,m−n)</strong>，可以得到 <u>Θf(q,m)−Θf(k,m-1) = Θg(q,k,1)</u><br> 然后将 <u>Θf(q,m) 和 Θf(k,m-1)</u> 的等式代入Θf(q,m)=Θ(q)+φ(m)，我们可以得到 Θ(q) + φ(m) - (Θ(k) + φ(m-1)) = Θg(q,k,1)，整理一下就得到<br><img alt="\varphi(m)-\varphi(m-1)=\Theta g(q, k, 1)+\Theta(k)-\Theta(q)" class="mathcode" src="https://images2.imgbox.com/27/ff/ZhRjtcr4_o.png"><br> 即{φ(m)}是等差数列，设右端为θ，那么就解得<strong>φ(m)=mθ</strong><br><br> 综上，我们得到二维情况下用复数表示的RoPE：<br><strong><img alt="\boldsymbol{f}(\boldsymbol{q}, m)=R_{f}(\boldsymbol{q}, m) e^{\mathrm{i} \Theta f(\boldsymbol{q}, m)}=\|q\| e^{\mathrm{i}(\Theta(\boldsymbol{q})+m \theta)}=\boldsymbol{q} e^{\mathrm{i} m \theta}" src="https://images2.imgbox.com/14/24/Leb0Jq3x_o.png"></strong></li><li>所以说，寻求的变换就是<img alt="q_me^{im\theta}" src="https://images2.imgbox.com/c9/c7/YbaVIXXt_o.png">，也就是给<img alt="q_m" src="https://images2.imgbox.com/77/c8/nQpUn3TM_o.png">乘以<img alt="e^{im\theta}" class="mathcode" src="https://images2.imgbox.com/e6/a5/CkGW7cnf_o.png">，相应地，<img alt="k_n" src="https://images2.imgbox.com/1f/44/78YPsn21_o.png">乘以<img alt="e^{in\theta}" src="https://images2.imgbox.com/21/9e/YQTlMkwB_o.png"><br> 做了这样一个变换之后，根据复数的特性，有：<img alt="\langle q_m, k_n \rangle = Re[q_mk^*_n]" class="mathcode" src="https://images2.imgbox.com/35/4c/qfH2Rd1k_o.png"> 也就是，如果把二维向量看做复数，那么它们的内积，等于一个复数乘以另一个复数的共轭，得到的结果再取实部，代入上面的变换，也就有： <p class="img-center"><img alt="\langle q_me^{im\theta}, k_ne^{in\theta} \rangle = Re[(q_me^{im\theta}) (k_ne^{in\theta})^*] =Re[q_mk_n^*e^{i(m-n)\theta}]" class="mathcode" src="https://images2.imgbox.com/10/5b/IfBwS5BA_o.png"></p> 这样一来，内积的结果就只依赖于<img alt="(m-n)" src="https://images2.imgbox.com/22/9a/7ZyK05h8_o.png">，也就是相对位置了<br> 换言之，经过这样一番操作，通过给Embedding添加绝对位置信息，可以使得两个token的编码，经过内积变换（self-attn）之后，得到结果是受它们位置的差值，即相对位置影响的</li></ol> 
<p>于是，对于任意的位置为<img alt="m" src="https://images2.imgbox.com/a3/33/pfTMMjq6_o.png">的二维向量<img alt="[x, y]" class="mathcode" src="https://images2.imgbox.com/0b/c6/apOxhL7G_o.png">，把它看做复数，乘以<img alt="e^{im\theta}" class="mathcode" src="https://images2.imgbox.com/1f/5f/KoibKGia_o.png">，而根据欧拉公式，有：</p> 
<p class="img-center"><img alt="e^{im\theta}=\cos{m\theta}+i\sin{m\theta}" class="mathcode" src="https://images2.imgbox.com/2f/65/ztplMdR2_o.png"></p> 
<p>从而上述的相乘变换也就变成了(过程中注意：<img alt="i^2=-1" class="mathcode" src="https://images2.imgbox.com/2b/04/0kDpLcQe_o.png">)：</p> 
<p class="img-center"><img alt="(x+iy)e^{im\theta} \\= (x+ i y) (\cos{m\theta}+i\sin{m\theta}) \\= x\cos{m\theta} + ix\sin{m\theta} + iy\cos{m\theta} - y\sin{m\theta} \\ = (x\cos{m\theta}-y\sin{m\theta})+i(x\sin{m\theta}+y\cos{m\theta})" src="https://images2.imgbox.com/74/8b/ZAL9tlZ7_o.png"></p> 
<p>把上述式子写成矩阵形式：</p> 
<p class="img-center"><img alt="" height="74" src="https://images2.imgbox.com/de/d3/oslkijw4_o.png" width="400"></p> 
<p>而这个变换的几何意义，就是在二维坐标系下，对向量<img alt="(q_0, q_1)" class="mathcode" src="https://images2.imgbox.com/5e/68/m4KdaijN_o.png">进行了旋转，因而这种位置编码方法，被称为旋转位置编码</p> 
<p>根据刚才的结论，结合内积的线性叠加性，可以将结论推广到高维的情形。可以理解为，每两个维度一组，进行了上述的“旋转”操作，然后再拼接在一起：</p> 
<p class="img-center"><img alt="" height="181" src="https://images2.imgbox.com/1c/71/MinDI1jK_o.png" width="700"></p> 
<p>由于矩阵的稀疏性，会造成计算上的浪费，所以在计算时采用逐位相乘再相加的方式进行：</p> 
<p class="img-center"><img alt="" height="158" src="https://images2.imgbox.com/a8/9f/ZOweDzLY_o.png" width="400"></p> 
<p>其中<img alt="\otimes" class="mathcode" src="https://images2.imgbox.com/49/55/MIxm88hR_o.png">为矩阵逐位相乘操作</p> 
<h3>3.2 旋转位置编码的coding实现(分非LLaMA版和LLaMA版两种)</h3> 
<p>原理理解了，接下来可以代码实现旋转位置编码，考虑到LLaMA本身的实现不是特别好理解，所以我们先通过一份非LLaMA实现的版本，最后再看下LLaMA实现的版本</p> 
<p>对于，非LLaMA版的实现，其核心就是实现下面这三个函数 (再次强调，本份关于RoPE的非LLaMA版的实现 与上面和之后的代码并非一体的，仅为方便理解RoPE的实现)</p> 
<h4>3.2.1 非LLaMA版的实现</h4> 
<h5>3.2.1.1 sinusoidal_position_embedding的编码实现</h5> 
<p>sinusoidal_position_embedding：这个函数用来生成正弦形状的位置编码。这种编码用来在序列中的令牌中添加关于相对或绝对位置的信息</p> 
<pre><code class="language-python">def sinusoidal_position_embedding(batch_size, nums_head, max_len, output_dim, device):
    # (max_len, 1)
    position = torch.arange(0, max_len, dtype=torch.float).unsqueeze(-1)

    # (output_dim//2)
    # 即公式里的i, i的范围是 [0,d/2]
    ids = torch.arange(0, output_dim // 2, dtype=torch.float)  
    theta = torch.pow(10000, -2 * ids / output_dim)

    # (max_len, output_dim//2)
    # 即公式里的：pos / (10000^(2i/d))
    embeddings = position * theta 

    # (max_len, output_dim//2, 2)
    embeddings = torch.stack([torch.sin(embeddings), torch.cos(embeddings)], dim=-1)

    # (bs, head, max_len, output_dim//2, 2)
    # 在bs维度重复，其他维度都是1不重复
    embeddings = embeddings.repeat((batch_size, nums_head, *([1] * len(embeddings.shape))))  

    # (bs, head, max_len, output_dim)
    # reshape后就是：偶数sin, 奇数cos了
    embeddings = torch.reshape(embeddings, (batch_size, nums_head, max_len, output_dim))
    embeddings = embeddings.to(device)
    return embeddings</code></pre> 
<p>一般的文章可能解释道这个程度基本就over了，但为了让初学者一目了然计，我还是再通过一个完整的示例，来一步步说明上述各个步骤都是怎么逐一结算的，整个过程和之前此文里介绍过的transformer的位置编码本质上是一回事..</p> 
<p>为方便和transformer的位置编码做对比，故这里也假定output_dim = 512</p> 
<ol><li>首先，我们有 ids 张量，当 output_dim 为 512 时，则 <p><img alt="i = 0 // 2 = 0" src="https://images2.imgbox.com/be/1d/JGlcija7_o.png">，<img alt="2i = 0" src="https://images2.imgbox.com/cd/94/cWCHJJvo_o.png"><br><img alt="i = 1 //2 =0" src="https://images2.imgbox.com/2a/8a/DhtEZyHx_o.png">，<img alt="2i = 0,2i+1 = 1" src="https://images2.imgbox.com/92/09/Jictw44m_o.png"><br><img alt="i = 2 // 2 = 1" src="https://images2.imgbox.com/c9/61/rAJTy56Z_o.png">，<img alt="2i = 2" src="https://images2.imgbox.com/f4/7a/LtYDlSI9_o.png"><br><img alt="i = 3 // 2 = 1" src="https://images2.imgbox.com/fb/89/wGenlset_o.png">，<img alt="2i = 2,2i+1 = 3" src="https://images2.imgbox.com/57/74/kBwbmcbr_o.png"><br><img alt="i = 4 // 2 = 2" src="https://images2.imgbox.com/67/f3/3rGSdraO_o.png">，<img alt="2i = 4" src="https://images2.imgbox.com/c1/94/AVrs6OcS_o.png"><br><img alt="i = 5//2 = 2" src="https://images2.imgbox.com/51/8a/sK856T8Z_o.png">，<img alt="2i = 4, 2i + 1 =5" src="https://images2.imgbox.com/8a/eb/rBy3Kn6m_o.png"><br> ...<br><img alt="i = 510 // 2 = 255" src="https://images2.imgbox.com/c7/fb/fsJk4t1j_o.png">，<img alt="2i = 510" src="https://images2.imgbox.com/50/36/Enlb8E22_o.png"><br><img alt="i = 511 // 2 = 255" src="https://images2.imgbox.com/e0/14/3XCjxk1M_o.png">，<img alt="2i = 510,2i + 1 = 511" src="https://images2.imgbox.com/63/b8/ydvwQ8FP_o.png"><br> ids = [0,0, 1,1, 2,2, ..., 254,254, 255,255]</p> 然后我们有一个基数为10000的指数运算，使用了公式 torch.pow(10000, -2 * ids / output_dim) <p><img alt="[\frac{1}{10000^{\frac{0}{512}}},\frac{1}{10000^{\frac{0}{512}}}, \frac{1}{10000^{\frac{2}{512}}},\frac{1}{10000^{\frac{2}{512}}}, \frac{1}{10000^{\frac{4}{512}}}, \frac{1}{10000^{\frac{4}{512}}},..., \frac{1}{10000^{\frac{510}{512}}},\frac{1}{10000^{\frac{510}{512}}}]" src="https://images2.imgbox.com/29/c5/UQoWGaG8_o.png"></p> </li><li>执行 embeddings = position * theta 这行代码，它会将 position 的每个元素与 theta 的相应元素相乘，前三个元素为<img alt="[\frac{0}{10000^{\frac{0}{512}}},\frac{0}{10000^{\frac{0}{512}}}, \frac{0}{10000^{\frac{2}{512}}},\frac{0}{10000^{\frac{2}{512}}}, \frac{0}{10000^{\frac{4}{512}}}, \frac{0}{10000^{\frac{4}{512}}},..., \frac{0}{10000^{\frac{510}{512}}},\frac{0}{10000^{\frac{510}{512}}}]" class="mathcode" src="https://images2.imgbox.com/c5/7f/9houkWDk_o.png"><br><img alt="[\frac{1}{10000^{\frac{0}{512}}},\frac{1}{10000^{\frac{0}{512}}}, \frac{1}{10000^{\frac{2}{512}}},\frac{1}{10000^{\frac{2}{512}}}, \frac{1}{10000^{\frac{4}{512}}}, \frac{1}{10000^{\frac{4}{512}}},..., \frac{1}{10000^{\frac{510}{512}}},\frac{1}{10000^{\frac{510}{512}}}]" src="https://images2.imgbox.com/43/88/D0pqwzcn_o.png"><br><img alt="[\frac{2}{10000^{\frac{0}{512}}},\frac{2}{10000^{\frac{0}{512}}}, \frac{2}{10000^{\frac{2}{512}}},\frac{2}{10000^{\frac{2}{512}}}, \frac{2}{10000^{\frac{4}{512}}}, \frac{2}{10000^{\frac{4}{512}}},..., \frac{2}{10000^{\frac{510}{512}}},\frac{2}{10000^{\frac{510}{512}}}]" src="https://images2.imgbox.com/4b/fb/xsQT92I0_o.png"></li><li>接下来我们将对 embeddings 的每个元素应用 torch.sin 和 torch.cos 函数<br> 对于 torch.sin(embeddings)，我们将取 embeddings 中的每个元素的正弦值：<br><img alt="[sin(\frac{0}{10000^{\frac{0}{512}}}), sin(\frac{0}{10000^{\frac{2}{512}}}), sin(\frac{0}{10000^{\frac{4}{512}}}),..., sin(\frac{0}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/c4/f7/Rrze9hjz_o.png"><br><img alt="[sin(\frac{1}{10000^{\frac{0}{512}}}), sin(\frac{1}{10000^{\frac{2}{512}}}), sin(\frac{1}{10000^{\frac{4}{512}}}),..., sin(\frac{1}{10000^{\frac{510}{512}}})]" class="mathcode" src="https://images2.imgbox.com/a7/c0/y5qq0TUv_o.png"><br><img alt="[sin(\frac{2}{10000^{\frac{0}{512}}}), sin(\frac{2}{10000^{\frac{2}{512}}}), sin(\frac{2}{10000^{\frac{4}{512}}}),..., sin(\frac{2}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/d1/d8/zA5ePoYg_o.png"><br> 对于 torch.cos(embeddings)，我们将取 embeddings 中的每个元素的余弦值：<br><img alt="[cos(\frac{0}{10000^{\frac{0}{512}}}),cos(\frac{0}{10000^{\frac{2}{512}}}), cos(\frac{0}{10000^{\frac{4}{512}}}),..., ,cos(\frac{0}{10000^{\frac{510}{512}}})]" class="mathcode" src="https://images2.imgbox.com/7f/8a/ReshoMvB_o.png"><br><img alt="[cos(\frac{1}{10000^{\frac{0}{512}}}),cos(\frac{1}{10000^{\frac{2}{512}}}), cos(\frac{1}{10000^{\frac{4}{512}}}),..., ,cos(\frac{1}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/a1/42/RHynRwBu_o.png"><br><img alt="[cos(\frac{2}{10000^{\frac{0}{512}}}),cos(\frac{2}{10000^{\frac{2}{512}}}), cos(\frac{2}{10000^{\frac{4}{512}}}),..., ,cos(\frac{2}{10000^{\frac{510}{512}}})]" class="mathcode" src="https://images2.imgbox.com/97/d1/sGRwKQLX_o.png"><br> 最后，torch.stack([torch.sin(embeddings), torch.cos(embeddings)], dim=-1) 将这两个新的张量沿着一个新的维度堆叠起来，得到的 embeddings如下 <p><img alt="PE_0 = [sin(\frac{0}{10000^{\frac{0}{512}}}),cos(\frac{0}{10000^{\frac{0}{512}}}), sin(\frac{0}{10000^{\frac{2}{512}}}),cos(\frac{0}{10000^{\frac{2}{512}}}), sin(\frac{0}{10000^{\frac{4}{512}}}), cos(\frac{0}{10000^{\frac{4}{512}}}),..., sin(\frac{0}{10000^{\frac{510}{512}}}),cos(\frac{0}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/6e/e2/tmIIjqM6_o.png"></p> <p><img alt="PE_1 = [sin(\frac{1}{10000^{\frac{0}{512}}}),cos(\frac{1}{10000^{\frac{0}{512}}}), sin(\frac{1}{10000^{\frac{2}{512}}}),cos(\frac{1}{10000^{\frac{2}{512}}}), sin(\frac{1}{10000^{\frac{4}{512}}}), cos(\frac{1}{10000^{\frac{4}{512}}}),..., sin(\frac{1}{10000^{\frac{510}{512}}}),cos(\frac{1}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/25/62/fQ0Ra9m0_o.png"></p> <p><img alt="PE_2 = [sin(\frac{2}{10000^{\frac{0}{512}}}),cos(\frac{2}{10000^{\frac{0}{512}}}), sin(\frac{2}{10000^{\frac{2}{512}}}),cos(\frac{2}{10000^{\frac{2}{512}}}), sin(\frac{2}{10000^{\frac{4}{512}}}), cos(\frac{2}{10000^{\frac{4}{512}}}),..., sin(\frac{2}{10000^{\frac{510}{512}}}),cos(\frac{2}{10000^{\frac{510}{512}}})]" src="https://images2.imgbox.com/2c/bb/3PLplRIt_o.png"></p> </li><li>最终，得到如下结果 <pre><code>[
  [
    [
      [sin(\frac{0}{10000^{\frac{0}{512}}}), cos(\frac{0}{10000^{\frac{0}{512}}}), sin(\frac{0}{10000^{\frac{2}{512}}}), cos(\frac{0}{10000^{\frac{2}{512}}}), ..., cos(\frac{0}{10000^{\frac{510}{512}}})],
      [sin(\frac{1}{10000^{\frac{0}{512}}}), cos(\frac{1}{10000^{\frac{0}{512}}}), sin(\frac{1}{10000^{\frac{2}{512}}}), cos(\frac{1}{10000^{\frac{2}{512}}}), ..., cos(\frac{1}{10000^{\frac{510}{512}}})],
      [sin(\frac{2}{10000^{\frac{0}{512}}}), cos(\frac{2}{10000^{\frac{0}{512}}}), sin(\frac{2}{10000^{\frac{2}{512}}}), cos(\frac{2}{10000^{\frac{2}{512}}}), ..., cos(\frac{2}{10000^{\frac{510}{512}}})]
    ]
  ]
]</code></pre> </li></ol> 
<h5>3.2.1.2 RoPE的编码实现</h5> 
<p>RoPE：这个函数将相对位置编码（RoPE）应用到注意力机制中的查询和键上。这样，模型就可以根据相对位置关注不同的位置</p> 
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F
import math


def RoPE(q, k):
    # q,k: (bs, head, max_len, output_dim)
    batch_size = q.shape[0]
    nums_head = q.shape[1]
    max_len = q.shape[2]
    output_dim = q.shape[-1]

    # (bs, head, max_len, output_dim)
    pos_emb = sinusoidal_position_embedding(batch_size, nums_head, max_len, output_dim, q.device)


    # cos_pos,sin_pos: (bs, head, max_len, output_dim)
    # 看rope公式可知，相邻cos，sin之间是相同的，所以复制一遍。如(1,2,3)变成(1,1,2,2,3,3)
    cos_pos = pos_emb[...,  1::2].repeat_interleave(2, dim=-1)  # 将奇数列信息抽取出来也就是cos 拿出来并复制
    sin_pos = pos_emb[..., ::2].repeat_interleave(2, dim=-1)  # 将偶数列信息抽取出来也就是sin 拿出来并复制

    # q,k: (bs, head, max_len, output_dim)
    q2 = torch.stack([-q[..., 1::2], q[..., ::2]], dim=-1)
    q2 = q2.reshape(q.shape)  # reshape后就是正负交替了

    # 更新qw, *对应位置相乘
    q = q * cos_pos + q2 * sin_pos

    k2 = torch.stack([-k[..., 1::2], k[..., ::2]], dim=-1)
    k2 = k2.reshape(k.shape)
    # 更新kw, *对应位置相乘
    k = k * cos_pos + k2 * sin_pos

    return q, k</code></pre> 
<p>老规矩，为一目了然起见，还是一步一步通过一个示例来加深理解</p> 
<ol><li>sinusoidal_position_embedding函数生成位置嵌入。在output_dim=512的情况下，每个位置的嵌入会有512个维度，但为了简单起见，我们只考虑前8个维度，前4个维度为sin编码，后4个维度为cos编码。所以，我们可能得到类似以下的位置嵌入 <pre><code># 注意，这只是一个简化的例子，真实的位置嵌入的值会有所不同。
pos_emb = torch.tensor([[[[0.0000, 0.8415, 0.9093, 0.1411, 1.0000, 0.5403, -0.4161, -0.9900],
                          [0.8415, 0.5403, 0.1411, -0.7568, 0.5403, -0.8415, -0.9900, -0.6536],
                          [0.9093, -0.4161, -0.8415, -0.9589, -0.4161, -0.9093, -0.6536, 0.2836]]]])</code></pre> </li><li>然后，我们提取出所有的sin位置编码和cos位置编码，并在最后一个维度上每个位置编码进行复制 <pre><code>sin_pos = pos_emb[..., ::2].repeat_interleave(2, dim=-1)  # 提取出所有sin编码，并在最后一个维度上复制
cos_pos = pos_emb[..., 1::2].repeat_interleave(2, dim=-1)  # 提取出所有cos编码，并在最后一个维度上复制</code></pre> </li><li>更新query向量<br> 我们首先构建一个新的q2向量，这个向量是由原来向量的负的cos部分和sin部分交替拼接而成的<br> 我们用cos_pos对q进行元素级乘法，用sin_pos对q2进行元素级乘法，并将两者相加得到新的query向量 <pre><code>q2 = torch.stack([-q[..., 1::2], q[..., ::2]], dim=-1).flatten(start_dim=-2)
# q2: tensor([[[[-0.2,  0.1, -0.4,  0.3, -0.6,  0.5, -0.8,  0.7],
#               [-1.0,  0.9, -1.2,  1.1, -1.4,  1.3, -1.6,  1.5],
#               [-1.8,  1.7, -2.0,  1.9, -2.2,  2.1, -2.4,  2.3]]]])

q = q * cos_pos + q2 * sin_pos</code></pre> 公式表示如下 <p class="img-center"><img alt="" height="158" src="https://images2.imgbox.com/53/f2/e0DbLktB_o.png" width="400"></p> </li><li>​​​​​更新key向量<br> 对于key向量，我们的处理方法与query向量类似 <pre><code>k2 = torch.stack([-k[..., 1::2], k[..., ::2]], dim=-1).flatten(start_dim=-2)
# k2: tensor([[[[-0.15,  0.05, -0.35,  0.25, -0.55,  0.45, -0.75,  0.65</code></pre> </li></ol> 
<h5>3.2.1.3 attention的编码实现</h5> 
<p>attention：这是注意力机制的主要功能</p> 
<ul><li>首先，如果use_RoPE被设置为True，它会应用RoPE，通过取查询和键的点积（并进行缩放）</li><li>然后，进行softmax操作来计算注意力分数，以得到概率，输出是值的加权和，权重是计算出的概率</li><li>最后，旋转后的q和k计算点积注意力后，自然就具备了相对位置信息</li></ul> 
<pre><code class="language-python">def attention(q, k, v, mask=None, dropout=None, use_RoPE=True):
    # q.shape: (bs, head, seq_len, dk)
    # k.shape: (bs, head, seq_len, dk)
    # v.shape: (bs, head, seq_len, dk)

    if use_RoPE:
        # 使用RoPE进行位置编码
        q, k = RoPE(q, k)

    d_k = k.size()[-1]

    # 计算注意力权重
    # (bs, head, seq_len, seq_len)
    att_logits = torch.matmul(q, k.transpose(-2, -1))  
    att_logits /= math.sqrt(d_k)

    if mask is not None:
        # 对权重进行mask，将为0的部分设为负无穷大
        att_scores = att_logits.masked_fill(mask == 0, -1e-9)  

    # 对权重进行softmax归一化
    # (bs, head, seq_len, seq_len)
    att_scores = F.softmax(att_logits, dim=-1)  

    if dropout is not None:
        # 对权重进行dropout
        att_scores = dropout(att_scores)

    # 注意力权重与值的加权求和
    # (bs, head, seq_len, seq_len) * (bs, head, seq_len, dk) = (bs, head, seq_len, dk)
    return torch.matmul(att_scores, v), att_scores


if __name__ == '__main__':
    # (bs, head, seq_len, dk)
    q = torch.randn((8, 12, 10, 32))
    k = torch.randn((8, 12, 10, 32))
    v = torch.randn((8, 12, 10, 32))

    # 进行注意力计算
    res, att_scores = attention(q, k, v, mask=None, dropout=None, use_RoPE=True)

    # 输出结果的形状
    # (bs, head, seq_len, dk),  (bs, head, seq_len, seq_len)
    print(res.shape, att_scores.shape)</code></pre> 
<h4>3.2.2 LLaMA版的实现</h4> 
<p>接下来，我们再来看下LLaMA里是怎么实现这个旋转位置编码的，具体而言，<a href="https://github.com/facebookresearch/llama/blob/main/llama/model.py" title="LLaMA 的model.py">LLaMA 的model.py</a>文件里面实现了旋转位置编码(为方便大家理解，我给相关代码 加了下注释)<br> 首先，逐一实现这三个函数<br> precompute_freqs_cis<br> reshape_for_broadcast<br> apply_rotary_emb</p> 
<pre><code># 预计算频率和复数的函数
def precompute_freqs_cis(dim: int, end: int, theta: float = 10000.0):
    freqs = 1.0 / (theta ** (torch.arange(0, dim, 2)[: (dim // 2)].float() / dim))    # 计算频率
    t = torch.arange(end, device=freqs.device)    # 根据结束位置生成序列
    freqs = torch.outer(t, freqs).float()    # 计算外积得到新的频率
    freqs_cis = torch.polar(torch.ones_like(freqs), freqs)    # 计算复数
    return freqs_cis    # 返回复数</code></pre> 
<pre><code># 重塑的函数
def reshape_for_broadcast(freqs_cis: torch.Tensor, x: torch.Tensor):
    ndim = x.ndim    # 获取输入张量的维度
    assert 0 &lt;= 1 &lt; ndim    # 检查维度的合理性
    assert freqs_cis.shape == (x.shape[1], x.shape[-1])    # 检查复数的形状
    shape = [d if i == 1 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)]    # 计算新的形状
    return freqs_cis.view(*shape)    # 重塑复数的形状并返回</code></pre> 
<pre><code># 应用旋转嵌入的函数
def apply_rotary_emb(
    xq: torch.Tensor,
    xk: torch.Tensor,
    freqs_cis: torch.Tensor,
) -&gt; Tuple[torch.Tensor, torch.Tensor]:
    xq_ = torch.view_as_complex(xq.float().reshape(*xq.shape[:-1], -1, 2))    # 将xq视为复数
    xk_ = torch.view_as_complex(xk.float().reshape(*xk.shape[:-1], -1, 2))    # 将xk视为复数
    freqs_cis = reshape_for_broadcast(freqs_cis, xq_)    # 重塑复数的形状
    xq_out = torch.view_as_real(xq_ * freqs_cis).flatten(3)    # 计算xq的输出
    xk_out = torch.view_as_real(xk_ * freqs_cis).flatten(3)    # 计算xk的输出
    return xq_out.type_as(xq), xk_out.type_as(xk)    # 返回xq和xk的输出</code></pre> 
<p>之后，在注意力机制的前向传播函数中调用上面实现的第三个函数 apply_rotary_emb，赋上位置信息</p> 
<pre><code>        # 对Query和Key应用旋转嵌入
        xq, xk = apply_rotary_emb(xq, xk, freqs_cis=freqs_cis)</code></pre> 
<p></p> 
<h2>第四部分 线性偏差注意力ALiBi</h2> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td>模型名称    </td><td>隐藏层维度    </td><td>层数    </td><td>注意力头数    </td><td>词表大小    </td><td>训练数据（tokens）    </td><td>位置编码    </td><td>最大长度</td></tr><tr><td>Baichuan-7B</td><td>4,096</td><td>32</td><td>32</td><td>64,000</td><td>1.2 万亿</td><td>RoPE</td><td>4,096</td></tr><tr><td>Baichuan-13B</td><td>5,120</td><td>40</td><td>40</td><td>64,000</td><td>1.4 万亿</td><td>ALiBi</td><td>4,096</td></tr><tr><td>Baichuan 2-7B</td><td>4096</td><td>32</td><td>32</td><td>125,696</td><td>2.6万亿</td><td>RoPE</td><td>4096</td></tr><tr><td>Baichuan 2-13B</td><td>5120</td><td>40</td><td>40</td><td>125,696</td><td>2.6万亿</td><td>ALiBi</td><td>4096</td></tr></tbody></table> 
<p>注意看上表的位置编码那一列，baichuan 7B无论第一代还是第二代，位置编码均用的RoPE，而baichuan 13B则无论是第一代还是第二代，均用的ALiBi</p> 
<p>下面便详细介绍下该ALiBi</p> 
<h4>4.1 什么是ALiBi</h4> 
<p>ALiBi全称是Attention with Linear Biases，通过论文《<a class="link-info" href="https://arxiv.org/abs/2108.12409" rel="nofollow" title="Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation">Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation</a>》提出<span style="color:#000000;">，</span>其不像标准transformer那样，在embedding层添加位置编码，而是在softmax的结果后添加一个静态的不可学习的偏置项(说白了，就是数值固定)</p> 
<p>具体而言，如下图所示</p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/98/74/TwMLpVuQ_o.png" width="600"></p> 
<ol><li>当计算每个头的注意力分数时，线性偏差注意力方法ALiBi会向每个注意力分数(<img alt="q_i\cdot k_j" class="mathcode" src="https://images2.imgbox.com/99/d1/ZfkslOim_o.png">，左)添加一个常数偏差(右)<br><span style="color:#7b7f82;"><em>When computing attention scores for each head, our linearly biased attention method, ALiBi, adds a constant bias (right) to each attention score (qi· kj , left).</em></span><br>   <p>左边是自注意力得分，关于q和k的内积<br> 右边是一个相对距离的矩阵，<br><span style="color:#1a439c;">q1  q2 q3 q4 q5<br> k1  k2  k3 k4 k5</span><br> 所以才有<br><img alt="\rightarrow" class="mathcode" src="https://images2.imgbox.com/9f/67/qC2nggta_o.png">  q1和k1之间的距离是0，所以对应位置就是0<br><img alt="\rightarrow" class="mathcode" src="https://images2.imgbox.com/59/51/9b9b6TLX_o.png">  q2和k1之间的距离是「相对位置偏移为“<strong>k的索引</strong>”1」 - 「q的索引2」，得到1-2 = -1，就对应到了中间矩阵的取值为-1了<br> 以此类推，相对距离矩阵的中间对角线上都是0，然后左下角的取值都是对应的「k的索引」-「q的索引」了</p> </li><li>那m具体怎么取值呢，按论文中的说法是<br> 当8个heads的时候，m的取值为：<br><img alt="\frac{1}{2^{1}}, \frac{1}{2^{2}}, \ldots, \frac{1}{2^{8}}" class="mathcode" src="https://images2.imgbox.com/6f/0f/6rblC9AR_o.png"><img alt="1, 2, ..., i" class="mathcode" src="https://images2.imgbox.com/78/6a/llYkMeyx_o.png"><br> 如果是16个heads，则m的取值为：<br><img alt="\frac{1}{2^{0.5}}, \frac{1}{2^{1}}, \frac{1}{2^{1.5}}, \ldots, \frac{1}{2^{8}}" class="mathcode" src="https://images2.imgbox.com/a9/7d/4xkl7Jt3_o.png"><br> 相当于追加了一半的1/sqrt(2)到原来的8个head的每个m的取值<br><br> 扩展到一般情况就是：对于n个head的话，m的取值就是<img alt="2^{\frac{-8}{n}}" class="mathcode" src="https://images2.imgbox.com/82/e6/AsqiVSd3_o.png">，即如下<br><img alt="2^{\frac{-8}{1}}, 2^{\frac{-8}{2}}, 2^{\frac{-8}{3}}, \ldots, 2^{\frac{-8}{n}}" class="mathcode" src="https://images2.imgbox.com/9f/98/59mBegwt_o.png">， 这样的m个坡度了<br><br><span style="color:#7b7f82;">最终整体的公式便是<br><img alt="\operatorname{softmax}\left(\mathbf{q}_{i} \mathbf{K}^{\top}+m \cdot[-(i-1), \ldots,-2,-1,0]\right)" class="mathcode" src="https://images2.imgbox.com/e1/22/5tBkbCln_o.png"><br> 对于第i个query来说，他们之间的相对距离就是：k的索引 - q的索引<br> 具体而言，k的索引 遍历<img alt="1, 2, ..., i" class="mathcode" src="https://images2.imgbox.com/a4/63/sco7Ktmh_o.png">，而q的索引 取值为<img alt="i" class="mathcode" src="https://images2.imgbox.com/f8/e1/d5VXaW1t_o.png"></span></li></ol> 
<p>// 待更</p> 
<h2>第五部分 LLaMA 2 Long中位置编码的修改</h2> 
<h3>5.1 LLaMA 2 Long相比LLaMA 2的变化：修改位置编码 长度达到32K</h3> 
<p>9月底，GenAI, Meta正式发布LLaMA 2 Long(<em><span style="color:#7b7f82;">这是其论文《<a class="link-info" href="https://arxiv.org/pdf/2309.16039" rel="nofollow" title="Effective Long-Context Scaling of Foundation Models">Effective Long-Context Scaling of Foundation Models</a>》</span></em>)，与LLaMA 2相比，LLaMA 2 Long的变化主要体现在以下两点</p> 
<ol><li>一是训练参数上，采用了<strong>高达4000亿token</strong>的数据源(<span style="color:#7b7f82;"><em>We build our models by continually pretraining from LLAMA 2 checkpoints with additional 400 billion tokens formed as long training sequences</em></span>)<br> ——相反，原始LLaMA 2包含多个变体，但最多的版本也只有700亿</li><li>二是架构上，与LLaMA 2保持不变，但对位置编码进行了一个非常小的必要修改，以此完成高达3.2万token的上下文窗口支持</li></ol> 
<h4>5.1.1 LLaMA 2 Long中的位置编码做了怎样的修改</h4> 
<p>在LLaMA 2中，它的位置编码采用的是旋转编码RoPE方法，其通过旋转矩阵来实现位置编码的外推</p> 
<ol><li>本质上来说，RoPE就是将表示单词、数字等信息的token embeddings映射到3D图表上，给出它们相对于其他token的位置——即使在旋转时也如此</li><li>这就能够使模型产生准确且有效的响应，并且比其他方法需要的信息更少，因此占用的计算存储也更小</li></ol> 
<p>然，Meta的研究人员通过对70亿规模的LLaMA 2进行实验，确定了LLaMA 2中的RoPE方法的一个<strong>局限性</strong>，即，阻止注意力模块聚集远处token的信息</p> 
<p>为此，Meta想出了一个非常简单的破解办法：</p> 
<blockquote> 
 <p><strong>减少每个维度的旋转角度</strong><span style="color:#7b7f82;"><em>(which essentially reduces the rotation angles of each dimension</em></span>)<br> 具体而言就是将超参数“基频(base frequency)b”从10000增加到500000(<span style="color:#7b7f82;"><em>increasing the “base frequency b” of ROPE from 10, 000 to 500, 000)</em></span></p> 
</blockquote> 
<p>在附录中，Meta还通过可视化为螺旋图这一非常有趣的方式，将RoPE ABF与RoPE PI的差异进行了理论分析</p> 
<p class="img-center"><img alt="" height="388" src="https://images2.imgbox.com/ce/b7/ckaE9I1w_o.png" width="1000"></p> 
<ul><li>上图b旨在说明位置插值对映射向量相对位置的影响，与上图a相比，连续点之间的距离被大幅缩小<br><span style="color:#7b7f82;"><em>Figure 8b aims to illustrate the impact of Position Interpolation on the relative position of the mapped vectors. The distance between the consecutive points got reduced considerably compered to Figure8a.</em></span></li><li>上图c说明了调整基频对结果的影响(<span style="color:#7b7f82;"><em>The impact of Adjusted Base Frequency is illustrated on Figure 8c</em></span>)<br> 虽然螺旋频率增加导致点之间最小距离缩小(<span style="color:#7b7f82;"><em>although the minimal distance between points got considerably reduced due to the increased frequency of the helix</em></span>)<br> 但连续点之间的距离几乎与上图a相同(<span style="color:#7b7f82;"><em>The distance between the <strong>consecutive points</strong> remained almost the same as on Figure 8a</em></span>)<br> 即螺旋频率增加所带来的影响将在高频段中逐渐减少(<span style="color:#7b7f82;"><em>This effect of increasedfrequency of the helix would be reduced in the high</em></span>)</li></ul> 
<p>总之，与RoPE PI相比，<strong>RoPE ABF的优势主要体现在</strong>它能以更大的粒度分配嵌入向量(the embedded vectors)，从而使模型更容易区分位置</p> 
<p>此外，他们还观察到，嵌入向量之间的相对距离既对RoPE PI的关键参数有线性依赖性，也对RoPE ABF的关键参数也有对数依赖性。</p> 
<p>这也就是为什么可以很容易地对基频这一超参数“下手”</p> 
<h4>5.1.2 改动之后的效果</h4> 
<p>这一改动立刻奏效，缩小了RoPE对远端token的衰减效应，并且在扩展LLAMA的上下文长度上优于一项类似的名为“位置插值”的方法RoPE PI(<em>如下图所示，RoPE表示基线方法，RoPE ABF为Meta此次发明的新方法，xPos是另一种应用了该方法的旋转编码变体</em>)</p> 
<p class="img-center"><img alt="" height="344" src="https://images2.imgbox.com/f6/d8/OT3wVfvL_o.png" width="500"></p> 
<p>然，一个问题是，通过上面这个可视化结果，Meta观察到RoPE在长程区域出现了较大的“振荡”，这对于语言建模来说可能不是个好消息</p> 
<p>不过，通过报告几种方法在长序列困惑度和FIRST-SENTENCE-RETRIEVAL两个任务上的表现来看，问题不大</p> 
<p class="img-center"><img alt="" height="194" src="https://images2.imgbox.com/29/07/xpNQdJqv_o.png" width="500"></p> 
<p>而且，尤其在后者任务上，他们提出的RoPE ABF是唯一一个可以始终保持性能的变体</p> 
<p class="img-center"><img alt="" height="287" src="https://images2.imgbox.com/aa/4e/lNqpwIo9_o.png" width="700"></p> 
<p>最终，LLaMA 2 Long凭借着这一改动，达成了3.2万的上下文token，并通过长下文连续预训练的共同作用，获得了开头所示的好成绩：</p> 
<p>除了全面超越LLaMA 2、在特定任务上超越Claude 2和ChatGPT，Meta也给出了它和一些开源长下文模型的对比。结果也相当不赖，如下图所示</p> 
<p>//待更</p> 
<hr> 
<h2>后记</h2> 
<p>最后，说明下为何像开头说的是「23年12.16日这天对本文做了大修」呢，原因在于</p> 
<ol><li>我司《<a class="link-info" href="https://blog.csdn.net/v_JULY_v/article/details/134183799" title="论文审稿GPT第2版">论文审稿GPT第2版</a>》即将进入模型训练阶段，其涉及到三个候选模型：mistral-yarn、mistral、llama-longlora<br> 故准备解析下YaRN，顺带把外推、内插都全面介绍下，而过程中不可避免会提到RoPE，故也总算把RoPE彻底写清楚了</li><li>这些东西，哪怕是近期最新的技术、模型等理解了后 会发现都不难，但我总想把理解的门槛无限降低，所以<strong>想真正写清楚或讲清楚一个东西，必须得反复琢磨、反复修改，以让更多人因此看懂，更何况当我和我的团队每天看paper、做项目，更可以帮到大家不断进阶、深入</strong></li></ol> 
<p>如今博客的访问PV2000万，希望明年达到2000万UV以上，以上视为后记</p> 
<h2></h2> 
<h2>参考文献与推荐阅读</h2> 
<ol><li>马同学关于向量和欧拉公式的几篇科普文章<br><a class="link-info" href="https://www.matongxue.com/parts/1991/" rel="nofollow" title="向量的加法">向量的加法</a><br><a class="link-info" href="https://www.matongxue.com/madocs/2066" rel="nofollow" title="欧拉公式，复数域的成人礼">欧拉公式，复数域的成人礼</a></li><li>关于欧拉公式的几篇文章<br><a class="link-info" href="https://zhuanlan.zhihu.com/p/40302967" rel="nofollow" title="被众人膜拜的欧拉恒等式是个什么东东？">被众人膜拜的欧拉恒等式是个什么东东？</a><br><a class="link-info" href="https://www.zhihu.com/question/41134540/answer/112430787" rel="nofollow" title="怎么向小学生解释欧拉公式 e^(πi)+1=0？">怎么向小学生解释欧拉公式 e^(πi)+1=0？</a></li><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/647109286" rel="nofollow" title="读懂旋转编码（RoPE）">读懂旋转编码（RoPE）</a></li><li><a class="link-info" href="https://zhuanlan.zhihu.com/p/642289220" rel="nofollow" title="LLM学习记录（五）--超简单的RoPE理解方式">LLM学习记录（五）--超简单的RoPE理解方式</a>，这篇文章很不错</li><li>苏剑林：<a class="link-info" href="https://kexue.fm/archives/8265" rel="nofollow" title="Transformer升级之路：2、博采众长的旋转式位置编码">Transformer升级之路：2、博采众长的旋转式位置编码</a></li><li><a class="link-info" href="https://blog.csdn.net/v_JULY_v/article/details/129709105" title="LLaMA的解读与其微调：Alpaca-LoRA/Vicuna/BELLE/中文LLaMA/姜子牙/LLaMA 2">LLaMA的解读与其微调：Alpaca-LoRA/Vicuna/BELLE/中文LLaMA/姜子牙/LLaMA 2</a></li><li>关于ALiBi的两篇文章<br><a class="link-info" href="https://zhuanlan.zhihu.com/p/632780188" rel="nofollow" title="[速读经典]ALiBi - 给注意力加上线性偏置">[速读经典]ALiBi - 给注意力加上线性偏置</a><br><a class="link-info" href="https://zhuanlan.zhihu.com/p/642846676" rel="nofollow" title="关于Transformer中的位置编码-ALiBi">关于Transformer中的位置编码-ALiBi</a></li><li><a class="link-info" href="https://mp.weixin.qq.com/s?__biz=MzIzNjc1NzUzMw==&amp;mid=2247697635&amp;idx=1&amp;sn=9cdb5237077dbc4500856ef1d02c9464&amp;chksm=e8df7391dfa8fa87fa014ba09deffc81b7ccf64ce68bd3b6ef39b9eced9e157a066651cddef5&amp;mpshare=1&amp;scene=23&amp;srcid=09301p6Q6O51wRLPlYryhkVJ&amp;sharer_shareinfo=3c6f02f7dd69fe81e8114949c8cc0feb&amp;sharer_shareinfo_first=dd23961fd33178f3f5fff3d6324d4593#rd" rel="nofollow" title="最强LLaMA突然来袭！只改一个超参数，实现上下文3.2万token，多个任务打败ChatGPT、Claude 2">最强LLaMA突然来袭！只改一个超参数，实现上下文3.2万token，多个任务打败ChatGPT、Claude 2</a></li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10e7a011da295d1fc1543b4877934f6b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AIGC面经大全（持续更新）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a24966fc0a9d36ece7e183cddbb534a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搞定mysql的 行转列（7种方法） 和 列转行</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>