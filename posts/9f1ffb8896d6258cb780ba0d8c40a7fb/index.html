<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL统计函数count详解】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9f1ffb8896d6258cb780ba0d8c40a7fb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL统计函数count详解】">
  <meta property="og:description" content="MySQL统计函数count详解 1. count()概述2. count(1)和count(*)和count(列名)的区别3. count(*)的实现方式 1. count()概述 count() 是一个聚合函数，返回指定匹配条件的行数。开发中常用来统计表中数据，全部数据，不为null数据，或者去重数据。
2. count(1)和count(*)和count(列名)的区别 1.函数说明
count(1)：统计所有的记录（包括null）。
count(*)：统计所有的记录（包括null）。
count(字段)：统计该&#34;字段&#34;不为null的记录。
count(distinct 字段)：统计该&#34;字段&#34;去重且不为null的记录。
count(1)中的1并不是表示第一个字段，而是表示一个固定值。其实就可以想成表中有这么一个字段，这个字段就是固定值1，count(1)，就是计算一共有多少个1。count(*)，执行时会把星号翻译成字段的具体名字，效果也是一样的，不过多了一个翻译的动作，比固定值的方式效率稍微低一些。
2.执行效率
他们之间根据不同情况会有些许区别，MySQL 会对count()做优化。(1)如果表中只有一列，则count( )效率最优。(2)如果表有多列，且存在主键，count (主键列名)效率最优，其次是：count (1) &gt;count( *)。(3)如果表有多列，且不存在主键，则count(1 )效率优于count( *)
3.执行过程
count(*)包括了所有的列，相当于行数，在统计结果的时候， 包括列值为NULL的行。
count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 包括列值为NULL的行。
count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计。
4.注意事项
阿里开发手册规范相关规定：
1.【强制】不要使用 count(列名)或 count(常量)来替代 count(),count()是 SQL92 定义的标 准统计行数的语法,跟数据库无关,跟 NULL 和非 NULL 无关. 说明：count(*)会统计值为 NULL 的行,而 count(列名)不会统计此列为 NULL 值的行.
2.【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数,注意 count(distinct col1, col2) 如果其中一列全为 NULL,那么即使另一列有不同的值,也返回为 0.
3. count(*)的实现方式 在日常开发中经常会统计一个表的行数，通过select count(*) from t很容易实现，可是随着记录数越来越多，统计函数执行越来越慢，然后呢可能会想mysql记录个总数不行吗，为什么每次都要逐行累加呢，count(列名)的时候还要判空，那么今天我们就聊聊count(*)的实现方式。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-17T00:09:10+08:00">
    <meta property="article:modified_time" content="2024-06-17T00:09:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL统计函数count详解】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="font-size:16px;">MySQL统计函数count详解</span></h2> 
<ul><li>1. count()概述</li><li>2. count(1)和count(*)和count(列名)的区别</li><li>3. count(*)的实现方式</li></ul> 
<h3><a name="t1"></a>1. count()概述</h3> 
<p>count() 是一个聚合函数，返回指定匹配条件的行数。开发中常用来统计表中数据，全部数据，不为null数据，或者去重数据。</p> 
<h3><a name="t2"></a>2. count(1)和count(*)和count(列名)的区别</h3> 
<p><strong>1.函数说明</strong><br> count(1)：统计所有的记录（包括null）。<br> count(*)：统计所有的记录（包括null）。<br> count(字段)：统计该"字段"不为null的记录。<br> count(distinct 字段)：统计该"字段"去重且不为null的记录。</p> 
<p>count(1)中的1并不是表示第一个字段，而是表示一个固定值。其实就可以想成表中有这么一个字段，这个字段就是固定值1，count(1)，就是计算一共有多少个1。count(*)，执行时会把星号翻译成字段的具体名字，效果也是一样的，不过多了一个翻译的动作，比固定值的方式效率稍微低一些。</p> 
<p><strong>2.执行效率</strong><br> 他们之间根据不同情况会有些许区别，MySQL 会对count()做优化。(1)如果表中只有一列，则count( )效率最优。(2)如果表有多列，且存在主键，count (主键列名)效率最优，其次是：count (1) &gt;count( *)。(3)如果表有多列，且不存在主键，则count(1 )效率优于count( *)</p> 
<p><strong>3.执行过程</strong><br> count(*)包括了所有的列，相当于行数，在统计结果的时候， 包括列值为NULL的行。<br> count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候， 包括列值为NULL的行。<br> count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计。</p> 
<p><strong>4.注意事项</strong><br> 阿里开发手册规范相关规定：<br> 1.【强制】不要使用 count(列名)或 count(常量)来替代 count(),count()是 SQL92 定义的标 准统计行数的语法,跟数据库无关,跟 NULL 和非 NULL 无关. 说明：count(*)会统计值为 NULL 的行,而 count(列名)不会统计此列为 NULL 值的行.<br> 2.【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数,注意 count(distinct col1, col2) 如果其中一列全为 NULL,那么即使另一列有不同的值,也返回为 0.</p> 
<h3><a name="t3"></a>3. count(*)的实现方式</h3> 
<p>在日常开发中经常会统计一个表的行数，通过select count(<code>*</code>) from t很容易实现，可是随着记录数越来越多，统计函数执行越来越慢，然后呢可能会想mysql记录个总数不行吗，为什么每次都要逐行累加呢，count(列名)的时候还要判空，那么今天我们就聊聊count(<code>*</code>)的实现方式。</p> 
<p>你首先要明确的是，在不同的<a href="https://so.csdn.net/so/search?q=MySQL%E5%BC%95%E6%93%8E&amp;spm=1001.2101.3001.7020" title="MySQL引擎">MySQL引擎</a>中，count(<code>*</code>)有不同的实现方式。<br> MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(<em>)的时候会直接返回这个数，效率很高；<br> 而InnoDB引擎就麻烦了，它执行count(</em>)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。<br> 这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的count(*)，如果加了where 条件的话，MyISAM表也是不能返回得这么快的。</p> 
<p>我们一起分析了为什么要使用InnoDB，因为不论是在事务支持、并发能力还是在<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8&amp;spm=1001.2101.3001.7020" title="数据安全">数据安全</a>方面，InnoDB都优于MyISAM。我猜你的表也一定是用了InnoDB引擎。这就是当你的记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。那为什么InnoDB不跟不 MyISAM一样，也把数字存起来呢？</p> 
<p>这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”也是不确定的。这里，我用一个算count(*)的例子来为你解释一下。</p> 
<p>假设表t中现在有10000条记录，我们设计了三个用户并行的会话。</p> 
<ul><li>会话A先启动事务并查询一次表的总行数；</li><li>会话B启动事务，插入一行后记录后，查询表的总行数；</li><li>会话C先启动一个单独的语句，插入一行记录后，查询表的总行数。<br> 我们假设从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/03/2b/TkXUTMpX_o.png">你会看到，在最后一个时刻，三个会话A、B、C会同时查询表t的总行数，但拿到的结果却不同。这和InnoDB的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是MVCC来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于count(*)请求来说，InnoDB只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。不同版本的会话统计的行数是不一样的，所以统计行数直接保存不支持。</li></ul> 
<p>当然，现在这个看上去笨笨的MySQL，在执行count(<code>*</code>)操作的时候还是做了优化的。<br> 你知道的，InnoDB是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于count(*)这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正 在确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</p> 
<p>如果你用过showtable status 命令的话，就会发现这个命令的输出结果里面也有一个TABLE_ROWS用于显示这个表当前有多少行，这个命令执行挺快的，那这个TABLE_ROWS能代替count(*)吗？</p> 
<p>你可能还记得在第10篇文章<a href="https://blog.csdn.net/m0_37583655/article/details/127829608" title="《 MySQL为什么有时候会选错索引？》">《 MySQL为什么有时候会选错索引？》</a>中我提到过，索引统计的值是通过采样来估算的。实际上，TABLE_ROWS就是从这个采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到40%到50%。所以， 所 show table status s 命令显示的行 命数也不能直接使用。</p> 
<p>到这里我们小结一下：<br> MyISAM表虽然count(<code>*</code>)很快，但是不支持事务，而且带有条件的时候也是不能直接使用记录的总数的；<br> showtable status命令虽然返回很快，但是不准确；<br> InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</p> 
<p>那么，回到文章开头的问题，如果你现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，我们只能自己计数。接下来，我们讨论一下，看看自己计数有哪些方法，以及每种方法的优缺点有哪些。这里，我先和你说一下这些方法的基本思路：你需要自己找一个地方，把操作记录表的行数存起来。</p> 
<p><strong>用缓存系统保存计数</strong><br> 对于更新很频繁的库来说，你可能会第一时间想到，用缓存系统来支持。<br> 你可以用一个Redis服务来保存这个表的总行数。这个表每被插入一行Redis计数就加1，每被删除一行Redis计数就减1。这种方式下，读和更新操作都很快，但你再想一下这种方式存在什么问题吗？没错，缓存系统可能会丢失更新。<br> Redis的数据不能永久地留在内存里，所以你会找一个地方把这个值定期地持久化存储起来。但即使这样，仍然可能丢失更新。试想如果刚刚在数据表中插入了一行，Redis中保存的值也加了1，然后Redis异常重启了，重启后你要从存储redis数据的地方把这个值读回来，而刚刚加1的这个计数操作却丢失了。</p> 
<p>当然了，这还是有解的。比如，Redis异常重启以后，到数据库里面单独执行一次count(*)获取真实的行数，再把这个值写回到Redis里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。但实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 将 Redis R 正常工 正作，这个值还是逻辑上不精确的。 作你可以设想一下有这么一个页面，要显示操作记录的总数，同时还要显示最近操作的100条记录。那么，这个页面的逻辑就需要先到Redis里面取出计数，再到数据表里面取数据记录。我们是这么定义不精确的：</p> 
<ol><li>一种是，查到的100行结果里面有最新插入记录，而Redis的计数里还没加1；</li><li>另一种是，查到的100行结果里没有最新插入的记录，而Redis的计数里已经加了1。<br> 这两种情况，都是逻辑不一致的。</li></ol> 
<p><strong>数据库保存计数</strong><br> 根据上面的分析，用缓存系统保存计数有丢失数据和计数不精确的问题。那么，如果我们把这 如个计数直接放到数据库里单独的一张计数表 个 C中，又会怎么样呢？</p> 
<p>首先，这解决了崩溃丢失的问题，InnoDB是支持崩溃恢复不丢数据的。然后，我们再看看能不能解决计数不精确的问题。</p> 
<p><strong>不同count用法</strong><br> 这里，首先你要弄清楚count()的语义。count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p> 
<p>所以，count(*)、count(主键id)和count(1) 都表示返回满足条件的结果集的总行数；而count(字段），则表示返回满足条件的数据行里面，参数“字段”不为NULL的总个数。</p> 
<p>至于分析性能差别的时候，你可以记住这么几个原则：</p> 
<ol><li>server层要什么就给什么；</li><li>InnoDB只给必要的值；</li><li>现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。</li></ol> 
<p>这是什么意思呢？接下来，我们就一个个地来看看。<br><strong>对于对 count( c 主键主 id) i 来说来</strong> ：<br> InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加。<br> 对于对 count(1) c 来说来 ，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。<br> 单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p> 
<p><strong>对 count( c 字段字 )来说来 ：</strong></p> 
<ol><li>如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</li><li>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。<br> 也就是前面的第一条原则，server层要什么字段，InnoDB就返回什么字段。</li></ol> 
<p><strong>对 count( <code>*</code> )来说来 ：</strong><br> 但 count(<code>*</code>) 是例外 是 ，并不会把全部字段取出来，而是专门做了优化，不取值。count(<code>*</code>)肯定不是null，按行累加。</p> 
<p>看到这里，你一定会说，优化器就不能自己判断一下吗，主键id肯定非空啊，为什么不能按照count(<code>*</code>)来处理，多么简单的优化啊。</p> 
<p>当然，MySQL专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且MySQL已经优化过count(<code>*</code>)了，你直接使用这种用法就可以了。</p> 
<p>所以结论是：按照效率排序的话，count(字段)&lt;count(主键id)&lt;count(1)≈count(<code>*</code>)，所以我建议你，尽量使用count(*)。</p> 
<p>文章知识点与官方知识档案匹配，可进一步学习相关知识</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/416072a5a2f48a834a889218239d6479/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言——扫雷游戏（简易版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0d4d560f164692e9aecaeda3e57414a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">elasticsearch过滤器filter：原理及使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>