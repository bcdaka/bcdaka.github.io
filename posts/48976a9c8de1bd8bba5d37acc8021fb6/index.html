<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>★ 数据结构 ★ 二叉树（下） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/48976a9c8de1bd8bba5d37acc8021fb6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="★ 数据结构 ★ 二叉树（下）">
  <meta property="og:description" content="Ciallo～(∠・ω&lt; )⌒☆ ~ 今天，我将继续和大家一起学习数据结构中的二叉树~
目录
一 二叉树链式结构的实现
二 二叉树的遍历
2.1 前序、中序以及后序遍历
2.2 层序遍历
三 二叉树实现的一些函数
3.1 二叉树结点个数
3.2 二叉树叶子结点个数
3.3 二叉树层数
3.4 二叉树第k层结点个数
3.5 二叉树查找值为x的结点
3.6二叉树的销毁
3.7 判断二叉树是否是完全二叉树
四 二叉树的一些选择题
一 二叉树链式结构的实现 二叉树的基本结构：
typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType a; struct BinaryTreeNode* left; struct BinaryTreeNode* right; }BTNode; 手动快速创建一棵简单的二叉树的方式~
BTNode* CreatBinaryTree() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); node1-&gt;left = node2; node1-&gt;right = node4; node2-&gt;left = node3; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 注意：上述代码并不是创建二叉树的方式，真正创建二叉树方式后序讲解。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-26T15:43:54+08:00">
    <meta property="article:modified_time" content="2024-08-26T15:43:54+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">★ 数据结构 ★ 二叉树（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="color:#9c8ec1;">Ciallo～(∠・ω&lt; )⌒☆ ~ </span>今天，我将继续和大家一起学习数据结构中的二叉树~</strong></p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/2e/fc/BCXHrSJM_o.jpg" width="559"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%B8%80%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">一  二叉树链式结构的实现</a></p> 
<p id="%E4%BA%8C%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow">二  二叉树的遍历</a></p> 
<p id="2.1%20%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#2.1%20%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">2.1 前序、中序以及后序遍历</a></p> 
<p id="2.2%C2%A0%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#2.2%C2%A0%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">2.2 层序遍历</a></p> 
<p id="%E4%B8%89%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E4%B8%89%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0" rel="nofollow">三  二叉树实现的一些函数</a></p> 
<p id="3.1%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">3.1 二叉树结点个数</a></p> 
<p id="3.2%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.2%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">3.2 二叉树叶子结点个数</a></p> 
<p id="3.3%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.3%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%95%B0" rel="nofollow">3.3 二叉树层数</a></p> 
<p id="3.4%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%ACk%E5%B1%82%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.4%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%ACk%E5%B1%82%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">3.4 二叉树第k层结点个数</a></p> 
<p id="3.5%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9-toc" style="margin-left:80px;"><a href="#3.5%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9" rel="nofollow">3.5 二叉树查找值为x的结点</a></p> 
<p id="3.6%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#3.6%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">3.6二叉树的销毁</a></p> 
<p id="3.7%C2%A0%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#3.7%C2%A0%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">3.7 判断二叉树是否是完全二叉树</a></p> 
<p id="%E5%9B%9B%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%89%E6%8B%A9%E9%A2%98-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%89%E6%8B%A9%E9%A2%98" rel="nofollow">四  二叉树的一些选择题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h3 id="%E4%B8%80%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#511b78;">一  二叉树链式结构的实现</span></h3> 
<p><strong><span style="background-color:#dad5e9;">二叉树的基本结构：</span></strong></p> 
<pre><code class="language-cpp">typedef int BTDataType;
typedef struct BinaryTreeNode
{
	BTDataType a;
	struct BinaryTreeNode* left;
	struct BinaryTreeNode* right;
}BTNode;</code></pre> 
<p>手动快速创建一棵简单的二叉树的方式~</p> 
<pre><code class="language-cpp">BTNode* CreatBinaryTree()
{
	BTNode* node1 = BuyNode(1);
	BTNode* node2 = BuyNode(2);
	BTNode* node3 = BuyNode(3);
	BTNode* node4 = BuyNode(4);
	BTNode* node5 = BuyNode(5);
	BTNode* node6 = BuyNode(6);

	node1-&gt;left = node2;
	node1-&gt;right = node4;
	node2-&gt;left = node3;
	node4-&gt;left = node5;
	node4-&gt;right = node6;
	return node1;
}</code></pre> 
<p>注意：上述代码<strong><span style="background-color:#dad5e9;">并不是创建二叉树的方式</span></strong>，真正创建二叉树方式后序讲解。</p> 
<p><img alt="" height="199" src="https://images2.imgbox.com/ac/f3/WV2LP4Ax_o.png" width="441"></p> 
<h3 id="%E4%BA%8C%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span style="color:#511b78;">二  二叉树的遍历</span></h3> 
<h4 id="2.1%20%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E4%BB%A5%E5%8F%8A%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" style="background-color:transparent;"><span style="color:#9c8ec1;">2.1 前序、中序以及后序遍历</span></h4> 
<p>所谓二叉树遍历(Traversal)是<strong><span style="background-color:#dad5e9;">按照某种特定的规则，依次对二叉树中的结点进行相应的操作，并且每个结点只操作一次</span></strong>。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。</p> 
<p>按照规则，二叉树的遍历有：<strong><span style="background-color:#dad5e9;">前序/中序/后序的递归结构遍历：</span></strong></p> 
<ul><li>1. 前序遍历(Preorder Traversal )——访问根结点的操作发生在遍历其左右子树之前。</li><li>2. 中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。</li><li>3. 后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。</li></ul> 
<p>由于被访问的结点必是某子树的根，所以N(Node）、L(Left subtree）和R(Right subtree）又可解释为根、根的左子树和根的右子树。<strong><span style="background-color:#dad5e9;">NLR、LNR和LRN</span></strong>分别又称为先根遍历、中根遍历和后根遍历。</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/73/9e/1CDKDWiJ_o.png" width="235"></p> 
<p>以上树为例，</p> 
<ul><li>前序遍历的访问顺序应为：<strong><span style="background-color:#dad5e9;">1 2 3 N N N 4 5 N N 6 N N</span></strong></li><li>中序遍历的访问顺序应为：<strong><span style="background-color:#dad5e9;">N 3 N 2 N 1 N 5 N 4 N 6 N</span></strong></li><li>后序遍历的访问顺序应为：<strong><span style="background-color:#dad5e9;">N N 3 N 2 N N 5 N N 6 4 1</span></strong></li></ul> 
<pre><code class="language-cpp">// 二叉树前序遍历
void PreOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	printf("%d ", root-&gt;a);
	PreOrder(root-&gt;left);
	PreOrder(root-&gt;right);
} // 1 2 3 N N N 4 5 N N 6 N N</code></pre> 
<p><img alt="" height="839" src="https://images2.imgbox.com/6f/e3/ehg7MLkW_o.png" width="851"></p> 
<p>同理：~ </p> 
<pre><code class="language-cpp">// 二叉树中序遍历
void InOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	InOrder(root-&gt;left);
	printf("%d ", root-&gt;a);
	InOrder(root-&gt;right);
} // N 3 N 2 N 1 N 5 N 4 N 6 N

// 二叉树后序遍历
void PostOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	PostOrder(root-&gt;left);
	PostOrder(root-&gt;right);
	printf("%d ", root-&gt;a);
} // N N 3 N 2 N N 5 N N 6 4 1</code></pre> 
<h4 id="2.2%C2%A0%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span style="color:#9c8ec1;">2.2 层序遍历</span></h4> 
<p><strong><span style="background-color:#dad5e9;">层序遍历：</span></strong>除了先序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历。设二叉树的根结点所在层数为1，层序遍历就是从所在二叉树的根结点出发，首先访问第一层的树根结点，然后从左到右访问第2层上的结点，接着是第三层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/a8/ad/W5j8xCtx_o.png" width="226"></p> 
<p><strong><span style="background-color:#dad5e9;">核心为节点出栈时把子节点入栈。</span></strong></p> 
<pre><code class="language-cpp">typedef struct BinaryTreeNode* QDataType;

typedef struct QueueNode
{
	struct QueueNode* next;
	QDataType val;
}QNode;

typedef struct Queue
{
	QNode* phead;
	QNode* ptail;
	int size;
}Queue;</code></pre> 
<pre><code class="language-cpp">// 层序遍历
void LevelOrder(BTNode* root)
{
	Queue q;
	QueueInit(&amp;q);
	if (root)
		QueuePush(&amp;q, root);
	while (!QueueEmpty(&amp;q))
	{
		BTNode* front = QueueFront(&amp;q);
		QueuePop(&amp;q);
		printf("%d ", front-&gt;a);

		if (front-&gt;left)
			QueuePush(&amp;q, front-&gt;left);
		if (front-&gt;right)
			QueuePush(&amp;q, front-&gt;right);
	}
	QueueDestory(&amp;q);
}</code></pre> 
<p></p> 
<h3 id="%E4%B8%89%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0" style="background-color:transparent;"><span style="color:#511b78;">三  二叉树实现的一些函数</span></h3> 
<h4 id="3.1%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span style="color:#9c8ec1;">3.1 二叉树结点个数</span></h4> 
<p>按遍历的方法我们可以得到以下程序：</p> 
<pre><code class="language-cpp">// 二叉树结点个数
int size = 0; // 放在全局
int BinaryTreeSize(BTNode* root)
{
	static int size = 0;
	if (root == NULL)
	{
		return 0;
	}
	else
	{
		++size;
	}
	BinaryTreeSize(root-&gt;left);
	BinaryTreeSize(root-&gt;right);
	return size;
}</code></pre> 
<p>然而此程序的全局变量size每次使用都要置为0， 若放在函数内定义为static int 则多次调用就会报错，解决方法为<strong><span style="background-color:#dad5e9;">再传一个指针变量</span></strong>，或者写<strong><span style="background-color:#dad5e9;">如下更好的写法</span></strong>：</p> 
<p>因为节点个数只有两种情况，<strong><span style="background-color:#dad5e9;">为空--0，不为空--左子树+右子树+1</span></strong></p> 
<p></p> 
<h4 id="3.2%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span style="color:#9c8ec1;">3.2 二叉树叶子结点个数</span></h4> 
<pre><code class="language-cpp">// 二叉树叶子结点个数
int BinaryTreeLeafSize(BTNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
	{
		return 1;
	}
	return BinaryTreeLeafSize(root-&gt;left) + BinaryTreeLeafSize(root-&gt;right);
}</code></pre> 
<h4 id="3.3%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%95%B0"><span style="color:#9c8ec1;">3.3 二叉树层数</span></h4> 
<pre><code class="language-cpp">// 二叉树层数
int BinaryTreeHeight(BTNode* root)
{
	if (root == NULL)
	{
		return 0;
	}
	// 直接写return效率很差~ 会重复调用很多次~
	//return BinaryTreeHeight(root-&gt;left) &gt; BinaryTreeHeight(root-&gt;right) ?
		//BinaryTreeHeight(root-&gt;left) + 1 : BinaryTreeHeight(root-&gt;right);
	int left = BinaryTreeHeight(root-&gt;left);
	int right = BinaryTreeHeight(root-&gt;right);
	return left &gt; right ? left + 1 : right + 1;
}</code></pre> 
<h4 id="3.4%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%ACk%E5%B1%82%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span style="color:#9c8ec1;">3.4 二叉树第k层结点个数</span></h4> 
<pre><code class="language-cpp">// 二叉树第k层结点个数
int BinaryTreeLevelKSize(BTNode* root, int k)
{
	if (root == NULL)
	{
		return 0;
	}
	if (k == 1) // 每次到底返回1
	{
		return 1;

	}
	return BinaryTreeLevelKSize(root-&gt;left, k - 1)
		+ BinaryTreeLevelKSize(root-&gt;right, k - 1);
}</code></pre> 
<h4 id="3.5%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9"><span style="color:#9c8ec1;">3.5 二叉树查找值为x的结点</span></h4> 
<pre><code class="language-cpp">// 二叉树查找值为x的结点
BTNode* BinaryTreeFind(BTNode* root, BTDataType x)
{
	if (root == NULL)
	{
		return NULL;
	}
	if (root-&gt;a == x)
	{
		return root;
	}
	BTNode* ret1 = BinaryTreeFind(root-&gt;left, x);
	if (ret1)
		return ret1;
	BTNode* ret2 = BinaryTreeFind(root-&gt;right, x);
	if (ret2)
		return ret2;
	return NULL;
}</code></pre> 
<p><strong><span style="background-color:#dad5e9;">要接收找到后的返回值~ 前序遍历~</span></strong></p> 
<h4 id="3.6%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81" style="background-color:transparent;"><span style="color:#9c8ec1;"><strong>3.6二叉树的销毁</strong></span></h4> 
<pre><code class="language-cpp">void TreeDestory(BTNode* root)
{
	if (root == NULL)
		return;
	TreeDestory(root-&gt;left);
	TreeDestory(root-&gt;right);
	free(root);
}</code></pre> 
<p>利用后序销毁</p> 
<p></p> 
<h4 id="3.7%C2%A0%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" style="background-color:transparent;"><span style="color:#9c8ec1;">3.7 判断二叉树是否是完全二叉树</span></h4> 
<ul><li>层序遍历走，空也进队列</li><li>遇到第一个空节点时，开始判断，后面空就是完全二叉树，后面有非空就不是完全二叉树。</li></ul> 
<p>不可能出现遇到空时后面还有非空没进队列，后面的非空一定时前面非空的孩子，层序出到空时，前面非空都出完了，那他的孩子一定进堆列了。</p> 
<pre><code class="language-cpp">// 判断二叉树是否是完全二叉树
bool BinaryTreeComplete(BTNode* root)
{
	Queue q;
	QueueInit(&amp;q);
	if (root)
		QueuePush(&amp;q, root);
	while (!QueueEmpty(&amp;q))
	{
		BTNode* front = QueueFront(&amp;q);
		QueuePop(&amp;q);
		// 遇到第一个空就可以判断了，队列还有非空就不是完全二叉树
		if (front == NULL)
		{
			break;
		}
		QueuePush(&amp;q, front-&gt;left);
		QueuePush(&amp;q, front-&gt;right);
	}
	while (!QueueEmpty(&amp;q))
	{
		BTNode* front = QueueFront(&amp;q);
		QueuePop(&amp;q);
		// 如果队列中还有非空就不是完全二叉树
		if (front)
		{
			QueueDestory(&amp;q);
			return false;
		}
	}
	QueueDestory(&amp;q);
	return true;
}</code></pre> 
<h3 id="%E5%9B%9B%C2%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%89%E6%8B%A9%E9%A2%98"><span style="color:#511b78;">四  二叉树的一些选择题</span></h3> 
<p><strong><span style="background-color:#dad5e9;">1. </span></strong>某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为（ B ）</p> 
<p>A . 不存在这样的二叉树   B. 200  C. 198  D. 199</p> 
<p>对任何一棵二叉树, 如果度为0其叶结点个数为n1, 度为2的分支结点个数为n2 ,则有 n1＝ n2＋1，199+1 = 200</p> 
<p></p> 
<p><strong><span style="background-color:#dad5e9;">2.</span></strong>下列数据结构中，不适合采用顺序存储结构的是（ A ）</p> 
<p>A .非完全二叉树   B. 堆   C .队列   D. 栈</p> 
<p></p> 
<p><strong><span style="background-color:#dad5e9;">3.</span></strong>在具有 2n 个结点的完全二叉树中，叶子结点个数为（ A ）</p> 
<p>A .n     B. n+1     C .n-1     D. n/2</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/c9/ae/sVt4k53n_o.png" width="1200"></p> 
<p><strong><span style="background-color:#dad5e9;">4.</span></strong>一个具有767个结点的完全二叉树，其叶子结点个数为（ B ）</p> 
<p>A .383     B .384     C .385     D .386</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/42/49/vYZHCPY2_o.png" width="1200"></p> 
<p><strong><span style="background-color:#dad5e9;">5.</span></strong>一棵完全二叉树的结点数位为531个，那么这棵树的高度为（ B ）</p> 
<p>A. 11     B. 10     C. 8     D. 12 </p> 
<p><strong><span style="background-color:#dad5e9;">2 ^( h - 1)   ~   2 ^ h - 1</span></strong></p> 
<p></p> 
<p><strong><span style="background-color:#dad5e9;">6.</span></strong>给前序和中序确定二叉树的方法</p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/42/be/G02ztQ40_o.png" width="895"></p> 
<p></p> 
<p><strong><span style="background-color:#dad5e9;">~完~ </span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d25e360d7a25216702d3033d18bd7e3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">react面试题九</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1d987b3a044cce43de97344a23a5018/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nginx &#43; lnmp架构部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>