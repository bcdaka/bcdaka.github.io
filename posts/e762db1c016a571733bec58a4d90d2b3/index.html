<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【算法系列篇】分治-快排 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e762db1c016a571733bec58a4d90d2b3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【算法系列篇】分治-快排">
  <meta property="og:description" content="文章目录 前言什么是分冶1.颜色分类1.1 题目要求1.2 做题思路1.3 Java代码实现 2. 排序数组2.1 题目要求2.2 做题思路2.3 Java代码实现 3.数组中的第k个最大元素3.1 题目要求3.2 做题思路3.3 Java代码实现 4. 最小的k个数4.1 题目要求4.2 做题思路4.3 Java代码实现 总结 前言 我相信看到这里很多人都学过八大排序了吧，其中快速排序是一种非常高效的排序方式，那么今天我们将会使用快速排序的算法来解决实际生活中的某些问题。
什么是分冶 分治算法是一种算法设计策略，它将大问题分解成更小的子问题，并通过解决子问题来解决原始问题。分治算法的基本思想是将问题分解成若干个规模较小但结构与原问题相似的子问题，然后递归地解决这些子问题，最后再将子问题的解合并得到原问题的解。
一般而言，分治算法可以分为三个步骤：
分解（Divide）：将原问题划分成若干个规模较小且相互独立的子问题，通常通过递归方式实现。
解决（Conquer）：递归地解决子问题。如果子问题的规模足够小，无需继续分解，直接求解并返回结果。
合并（Merge）：将子问题的解合并成原问题的解。这一步骤通常涉及对子问题解的操作，以得到原问题的解。
分治算法的典型应用包括排序算法（如快速排序和归并排序）、查找算法（如二分查找）、图算法（如最大子数组和、最短路径问题）等。
分治算法的优点在于它能够高效地解决某些复杂问题，尤其适用于可以被划分为多个子问题的情况。通过将问题分解为更小的子问题，分治算法可以减少问题的规模，简化问题的解决过程。
然而，需要注意的是，并非所有问题都适合采用分治算法。在使用分治算法时，需要保证子问题相对独立且可以有效地解决。此外，分治算法在涉及大量递归调用时可能会带来额外的开销，因此在设计算法时需要注意递归深度与性能之间的平衡。
我们今天使用的快速排序的算法则是很好的利用了分冶将大事化小的思想来解决问题的，将整个数组分为若干小区间来进行排序，最终得到我们想要的结果。
1.颜色分类 https://leetcode.cn/problems/sort-colors/
1.1 题目要求 给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
必须在不使用库内置的 sort 函数的情况下解决这个问题。
示例 1：
输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2：
输入：nums = [2,0,1] 输出：[0,1,2] 提示：
n == nums.length1 &lt;= n &lt;= 300nums[i] 为 0、1 或 2 进阶：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-05T14:20:49+08:00">
    <meta property="article:modified_time" content="2023-09-05T14:20:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【算法系列篇】分治-快排</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/f1/f2/XchTGL01_o.gif" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">前言</a></li><li><a href="#_5" rel="nofollow">什么是分冶</a></li><li><a href="#1_24" rel="nofollow">1.颜色分类</a></li><li><ul><li><a href="#11__27" rel="nofollow">1.1 题目要求</a></li><li><a href="#12__65" rel="nofollow">1.2 做题思路</a></li><li><a href="#13_Java_69" rel="nofollow">1.3 Java代码实现</a></li></ul> 
  </li><li><a href="#2__92" rel="nofollow">2. 排序数组</a></li><li><ul><li><a href="#21__95" rel="nofollow">2.1 题目要求</a></li><li><a href="#22__123" rel="nofollow">2.2 做题思路</a></li><li><a href="#23_Java_126" rel="nofollow">2.3 Java代码实现</a></li></ul> 
  </li><li><a href="#3k_159" rel="nofollow">3.数组中的第k个最大元素</a></li><li><ul><li><a href="#31__162" rel="nofollow">3.1 题目要求</a></li><li><a href="#32__194" rel="nofollow">3.2 做题思路</a></li><li><a href="#33_Java_199" rel="nofollow">3.3 Java代码实现</a></li></ul> 
  </li><li><a href="#4_k_232" rel="nofollow">4. 最小的k个数</a></li><li><ul><li><a href="#41__235" rel="nofollow">4.1 题目要求</a></li><li><a href="#42__262" rel="nofollow">4.2 做题思路</a></li><li><a href="#43_Java_266" rel="nofollow">4.3 Java代码实现</a></li></ul> 
  </li><li><a href="#_301" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>前言</h2> 
<p>我相信看到这里很多人都学过八大排序了吧，其中快速排序是一种非常高效的排序方式，那么今天我们将会使用快速排序的算法来解决实际生活中的某些问题。</p> 
<h2><a id="_5"></a>什么是分冶</h2> 
<p>分治算法是一种算法设计策略，它将大问题分解成更小的子问题，并通过解决子问题来解决原始问题。分治算法的基本思想是将问题分解成若干个规模较小但结构与原问题相似的子问题，然后递归地解决这些子问题，最后再将子问题的解合并得到原问题的解。</p> 
<p>一般而言，分治算法可以分为三个步骤：</p> 
<ol><li> <p>分解（Divide）：将原问题划分成若干个规模较小且相互独立的子问题，通常通过递归方式实现。</p> </li><li> <p>解决（Conquer）：递归地解决子问题。如果子问题的规模足够小，无需继续分解，直接求解并返回结果。</p> </li><li> <p>合并（Merge）：将子问题的解合并成原问题的解。这一步骤通常涉及对子问题解的操作，以得到原问题的解。</p> </li></ol> 
<p>分治算法的典型应用包括排序算法（如快速排序和归并排序）、查找算法（如二分查找）、图算法（如最大子数组和、最短路径问题）等。</p> 
<p>分治算法的优点在于它能够高效地解决某些复杂问题，尤其适用于可以被划分为多个子问题的情况。通过将问题分解为更小的子问题，分治算法可以减少问题的规模，简化问题的解决过程。</p> 
<p>然而，需要注意的是，并非所有问题都适合采用分治算法。在使用分治算法时，需要保证子问题相对独立且可以有效地解决。此外，分治算法在涉及大量递归调用时可能会带来额外的开销，因此在设计算法时需要注意递归深度与性能之间的平衡。</p> 
<p>我们今天使用的快速排序的算法则是很好的利用了分冶将大事化小的思想来解决问题的，将整个数组分为若干小区间来进行排序，最终得到我们想要的结果。</p> 
<h2><a id="1_24"></a>1.颜色分类</h2> 
<p><a href="https://leetcode.cn/problems/sort-colors/" rel="nofollow">https://leetcode.cn/problems/sort-colors/</a></p> 
<h3><a id="11__27"></a>1.1 题目要求</h3> 
<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p> 
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p> 
<p><font color="CC0000">必须在不使用库内置的 sort 函数的情况下解决这个问题。</font></p> 
<p>示例 1：</p> 
<pre><code>输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：nums = [2,0,1]
输出：[0,1,2]
</code></pre> 
<p>提示：</p> 
<ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 300</li><li>nums[i] 为 0、1 或 2</li></ul> 
<p>进阶：</p> 
<p>你能想出一个仅使用常数空间的一趟扫描算法吗？</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12__65"></a>1.2 做题思路</h3> 
<p>前面学习的快速排序，每一趟排序过程会以一个数为基准，使最终结果这个基准值的左边小于等于这个基准值，右边部分都是大于这个基准值，所以这个题目我们同样可以使用这种快排的思想，以1为基准，然后用 i 来遍历数组，left 指针以及 left 指针左边都是0，right 指针以及 right 指针右边部分都是2。left 一开始的位置指向 -1，right 指针指向 n（数组大小），当 i 所指向的数据小于 1 的时候，就先将 left++ ，然后将left 所指的内容与 i 所指的内容交换位置，交换结束之后，i++；如果 i 所指向的内容等于 1 的之后，直接i++；如果 i 指向的内容大于 1 ，则先需要将 right–，然后交换right 与 i 所指向的内容，但是这里交换完成之后，i 不能++，因为与 right 指向的内容交换位置之后，i 所指向的内容是 i 没有遍历过的，如果 i++，那么这个数字将会被跳过。<br> <img src="https://images2.imgbox.com/07/64/BrPjlYAH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="13_Java_69"></a>1.3 Java代码实现</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> t <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sortColors</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>right <span class="token operator">=</span> n<span class="token punctuation">,</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">++</span>left<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">--</span>right<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/50/c0/Yt7ZnIPk_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2__92"></a>2. 排序数组</h2> 
<p><a href="https://leetcode.cn/problems/sort-an-array/" rel="nofollow">https://leetcode.cn/problems/sort-an-array/</a></p> 
<h3><a id="21__95"></a>2.1 题目要求</h3> 
<p>给你一个整数数组 nums，请你将该数组<font color="CC0000">升序</font>排列。</p> 
<p>示例 1：</p> 
<pre><code>输入：nums = [5,2,3,1]
输出：[1,2,3,5]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
</code></pre> 
<p>提示：</p> 
<ul><li>1 &lt;= nums.length &lt;= 5 * 104</li><li>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="22__123"></a>2.2 做题思路</h3> 
<p>这道题就很简单明了，直接将数组进行升序排序，我们可以使用分冶的思想，讲整个数组分为 n 个部分，然后在这 n 个小部分中使用快排的思想进行排序，需要注意的是，如果数组趋于有序的话，快速排序的时间复杂度会下降到 O(N^2) ，所以我们可以对快速排序进行优化，优化的方式有很多：三数取中等等，这里我们使用的方式是随机取基准值的方法吗，这样能使快排的时间复杂度基本趋于 O(N*logN)。</p> 
<h3><a id="23_Java_126"></a>2.3 Java代码实现</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//递归结束的条件</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>right <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span>
        <span class="token comment">//在[l,r]区间内，随机取一个数作为基准值</span>
        <span class="token keyword">int</span> key <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> l<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">++</span>left<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">--</span>right<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//当将基准值排序到最终位置之后，还需要将基准位置左右两边部分继续排序</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>right<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> t <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/fd/06/myzQZuaX_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3k_159"></a>3.数组中的第k个最大元素</h2> 
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" rel="nofollow">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p> 
<h3><a id="31__162"></a>3.1 题目要求</h3> 
<p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p> 
<p><font color="CC0000">请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</font></p> 
<p><font color="CC0000">你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</font></p> 
<p>示例 1:</p> 
<pre><code>输入: [3,2,1,5,6,4], k = 2
输出: 5
</code></pre> 
<p>示例 2:</p> 
<pre><code>输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
</code></pre> 
<p>提示：</p> 
<ul><li>1 &lt;= k &lt;= nums.length &lt;= 105</li><li>-104 &lt;= nums[i] &lt;= 104</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="32__194"></a>3.2 做题思路</h3> 
<p>要想找到数组中的第k个最大元素，我们能想到的还是将数组进行排序，然后从大到小找到第k个元素。这道题目可以使用堆排序，创建出大小为 k 的小根堆。但是我们不使用堆排序的方法，而是使用分冶-快排的方法来解决。如何使用快排的方式来解决呢？同样是先找一个元素作为基准值，进行快排，将数组分为 a——小于基准值的部分、b——等于基准值的部分和c——大于基准值的部分，因为要找到第 k 个最大的元素，所以首先我们需要在大于基准的部分中找这个元素是否存在，如果 c 部分的长度大于等于 k ，则说明这个部分中存在第 k 大的元素，然后我们在这个部分中继续寻找；如果 c 的长度小于 k ，并且 b + c 的长度大于等于 k，那么我们可以直接返回 b 部分的元素，因为 c 部分的长度小于 k ，所以这个第 k 大的元素存在于 b 部分，而 b 部分都是等于基准值的部分，可以直接返回；如果前面两种情况都不存在，那么这个第 k 大的元素就在 a 部分，我们需要在 a 部分中找到第 k - b - c 大的元素，这个操作跟前面的递归操作类似。</p> 
<p><img src="https://images2.imgbox.com/6c/39/LLUGDr8k_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33_Java_199"></a>3.3 Java代码实现</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> key <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> l<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">++</span>left<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">--</span>right<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//c表示大于key的部分，b表示等于key的部分，剩下的部分就是小于key的部分</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> r <span class="token operator">-</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>right<span class="token punctuation">,</span>r<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">+</span> c <span class="token operator">&gt;=</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>left<span class="token punctuation">,</span>k <span class="token operator">-</span> b <span class="token operator">-</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e7/da/9NqJvtRG_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_k_232"></a>4. 最小的k个数</h2> 
<p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/" rel="nofollow">https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/</a></p> 
<h3><a id="41__235"></a>4.1 题目要求</h3> 
<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p> 
<p>示例 1：</p> 
<pre><code>输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
</code></pre> 
<p>示例 2：</p> 
<pre><code>输入：arr = [0,1,2,1], k = 1
输出：[0]
</code></pre> 
<p>限制：</p> 
<ul><li>0 &lt;= k &lt;= arr.length &lt;= 10000</li><li>0 &lt;= arr[i] &lt;= 10000</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="42__262"></a>4.2 做题思路</h3> 
<p>因为这道题目没有要求要按照元素的大小顺序返回，所以我们可以模仿上面的第 k 个最大元素的思路进行分冶-快排的算法，对数组进行简单的排序，并且将数组分为：a——小于基准值的部分，b——等于基准值的部分，c——大于基准值的部分。<br> 如果a &gt; k，则需要在 a 部分中继续递归，找到最小的 k 个数；如果a &lt;= k，但是 a + b &gt;= k ，因为 b 部分都是相等的数据，所以可以直接返回；如果前面两种情况都不符合的话，就还需要在 c 部分中继续进行排序，直到在 c 部分中找到 第k - a -b小的元素，然后该位置之前的部分就是我们需要的最小的 k 个数。</p> 
<h3><a id="43_Java_266"></a>4.3 Java代码实现</h3> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getLeastNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ret<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> key <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> l<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">=</span> l<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">++</span>left<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token operator">--</span>right<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> left <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>b <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> k<span class="token punctuation">)</span> <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>l<span class="token punctuation">,</span>left<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b <span class="token operator">&gt;=</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>right<span class="token punctuation">,</span>r<span class="token punctuation">,</span>k <span class="token operator">-</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> t <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/29/f9/giIcIalV_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_301"></a>总结</h2> 
<p>通过本篇博客，我们深入了解了分治算法以及其在快速排序算法中的应用。快速排序是一种高效的排序算法，它利用了分治策略，将大问题逐步分解为规模较小的子问题，并通过递归地解决和合并子问题来完成整个排序过程。</p> 
<p>快速排序算法的核心思想是选择一个基准元素，将待排序数组分割成两个子数组，一个小于等于基准的子数组和一个大于基准的子数组。然后，递归地对两个子数组进行排序，最后合并得到最终的有序数组。</p> 
<p>快速排序算法具有以下优点：</p> 
<ol><li> <p>高效性：快速排序算法的平均时间复杂度为O(nlogn)，在实际应用中表现出良好的性能。它通过不断地将数组划分为较小的子数组进行排序，从而减少了比较和交换的次数。</p> </li><li> <p>原地排序：快速排序算法可以在原数组上进行排序，不需要额外的辅助空间。这对于内存受限的环境来说具有重要意义。</p> </li></ol> 
<p>然而，快速排序算法也存在一些注意事项和局限性：</p> 
<ol><li> <p>对于初始数组的选择敏感：快速排序算法的性能高度依赖于选择的基准元素。最理想的情况是选择一个能够将数组划分成大小相似的子数组的基准元素，以避免出现最坏情况的时间复杂度。</p> </li><li> <p>递归深度：在快速排序算法中，递归调用的深度取决于划分操作的方式和基准元素的选择。当数组中存在大量重复元素时，可能会导致递归深度增加，影响算法的性能。</p> </li></ol> 
<p>总结而言，快速排序算法是一种高效、原地排序的算法，通过分治策略实现了对待排序数组的快速排序。它在实践中被广泛使用，具有较好的性能。然而，需要根据具体问题选择合适的基准元素，并考虑递归深度对算法性能的影响。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1334b8dfff875bce0c97d25812df8881/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">中文大语言模型 Llama-2 7B（或13B） 本地化部署 （国内云服务器、GPU单卡16GB、中文模型、WEB页面TextUI、简单入门）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21a89ec460fb5b7bb26fbe99b43ec6b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java之文件操作与IO</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>