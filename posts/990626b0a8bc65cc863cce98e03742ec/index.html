<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法总结（1） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/990626b0a8bc65cc863cce98e03742ec/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="贪心算法总结（1）">
  <meta property="og:description" content="一、贪心算法简介 常用方法：交换论证法、数学归纳法、反证法、分类讨论 二、柠檬水找零（交换论证法） . - 力扣（LeetCode）
class Solution { public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { int five=0,ten=0; for(auto&amp;e:bills) if(e==5) &#43;&#43;five; else if(e==10) { if(five==0) return false; --five,&#43;&#43;ten; } else //贪心策略 { if(five&amp;&amp;ten) --five,--ten; else if(five&gt;=3) five-=3; else return false; } return true; } //交换论证法、数学归纳法和反证法常用的策略 }; 三、将数组减半的最小操作次数（交换论证法） . - 力扣（LeetCode）
class Solution { public: int halveArray(vector&lt;int&gt;&amp; nums) { priority_queue&lt;double&gt; q(nums.begin(),nums.end()); double sum=accumulate(nums.begin(),nums.end(),0.0); int ret=0; sum/=2.0; while(sum&gt;0) { double t=q.top()/2.0; q.pop(); sum-=t; q.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-20T09:25:35+08:00">
    <meta property="article:modified_time" content="2024-07-20T09:25:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法总结（1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="286" src="https://images2.imgbox.com/70/4a/mi5e02Ur_o.gif" width="558"></h2> 
<h2>一、贪心算法简介</h2> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/64/5c/36a0SlmW_o.png" width="1200"></p> 
<p>常用方法：交换论证法、数学归纳法、反证法、分类讨论 </p> 
<h2> 二、柠檬水找零（交换论证法）</h2> 
<p><a href="https://leetcode.cn/problems/lemonade-change/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="673" src="https://images2.imgbox.com/44/e8/EQAjcQ3g_o.png" width="908"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a5/d0/6Sz09CiK_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    bool lemonadeChange(vector&lt;int&gt;&amp; bills) {
         int five=0,ten=0;
         for(auto&amp;e:bills)
            if(e==5) ++five;
            else if(e==10)
            {
                if(five==0) return false;
                --five,++ten;
            }
            else //贪心策略
            {
                if(five&amp;&amp;ten) --five,--ten;
                else if(five&gt;=3) five-=3;
                else return false;
            }
         return true;
    }
    //交换论证法、数学归纳法和反证法常用的策略
};</code></pre> 
<h2>三、将数组减半的最小操作次数（交换论证法）</h2> 
<p><a href="https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a><img alt="" height="636" src="https://images2.imgbox.com/2e/48/LH7uGLYl_o.png" width="903"></p> 
<p><img alt="" height="835" src="https://images2.imgbox.com/81/68/gclZyQUV_o.png" width="1157"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int halveArray(vector&lt;int&gt;&amp; nums) {
        priority_queue&lt;double&gt; q(nums.begin(),nums.end());
        double sum=accumulate(nums.begin(),nums.end(),0.0);
        int ret=0;
        sum/=2.0;
        while(sum&gt;0)
        {
            double t=q.top()/2.0;
            q.pop();
            sum-=t;
            q.push(t);
            ++ret;
        }
        return ret;
    }
};</code></pre> 
<h2>四、最大数（排序规则理解+全序性证明）</h2> 
<p><a href="https://leetcode.cn/problems/largest-number/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="695" src="https://images2.imgbox.com/14/34/wfknUPdC_o.png" width="912"></p> 
<p><img alt="" height="1147" src="https://images2.imgbox.com/71/54/SCrllVuz_o.png" width="1174"><img alt="" height="1200" src="https://images2.imgbox.com/c3/3f/5ackW4hP_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    string largestNumber(vector&lt;int&gt;&amp; nums) {
       //贪心策略 先转化成字符串 然后利用字典序排序
       vector&lt;string&gt; strs;
       strs.reserve(nums.size());//提前扩容 小优化
       for(auto&amp;e:nums) strs.emplace_back(to_string(e));
       sort(strs.begin(),strs.end(),[](const string&amp;s1,const string&amp;s2)
       {
               return s1+s2&gt;s2+s1;//大的在前面
       });
       //按顺序加入到ret中返回 
       string ret;
       for(auto&amp;s:strs) ret+=s;
       //细节处理:前导0 除非都是0才会出现前导0  所以我们只需要当出现前导0的时候，返回"0"即可
       if(ret[0]=='0') return "0";
       return ret;
    }
    //全序关系  一个集合中任意选出两个元素 如果在你定义的比较规则下能够满足全序关系
                //我们就说这个集合是可以排序的
        //1、完全性 可以推测出他的大小关系（a&gt;=b a&lt;=b）
        //2、反对称性 a&gt;=b&amp;&amp;b&gt;=a  ——&gt;a==b   a前和b前无所谓(唯一性)
        //3、传递性 a&gt;=b  b&gt;=c a&gt;=c
};</code></pre> 
<h2>五、摆动序列（反证法）</h2> 
<p><a href="https://leetcode.cn/problems/wiggle-subsequence/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="704" src="https://images2.imgbox.com/9b/fa/kZRx45Y5_o.png" width="796"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a4/29/n02B8AcK_o.png" width="1200"></p> 
<pre><code class="language-cpp">class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) 
    {
        int n=nums.size();
        if(n&lt;2) return n;
      //总是选择当前的最优策略
       int left=0,ret=0; //left表示左边的状态
       for(int i=0;i&lt;n-1;++i)
       {
        int right=nums[i+1]-nums[i];
        if(right==0) continue;//跳过相等的情况
        if(right*left&lt;=0) ++ret;
        left=right;
       }
      return ret+1; //算上最后一个
    }
};</code></pre> 
<h2> 六、最长递增子序列（交换论证）</h2> 
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="658" src="https://images2.imgbox.com/19/a7/ooKUmmc6_o.png" width="912"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/99/3a/3ye1kDgn_o.png" width="1028"></p> 
<p>贪心+二分</p> 
<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) 
    {
       //贪心+二分
       int n=nums.size();
       vector&lt;int&gt; ret;
       ret.emplace_back(nums[0]);
       for(int i=1;i&lt;n;++i)
         //如果比最后一个数大 就直接尾插即可
         if(nums[i]&gt;ret.back()) ret.emplace_back(nums[i]);
         //否则就用二分
         else 
         {
            int left=0,right=ret.size()-1;
            while(left&lt;right)
            {
                int mid=(left+right)&gt;&gt;1;
                if(ret[mid]&lt;nums[i]) left=mid+1;
                else right=mid;
            }
            ret[left]=nums[i];
         }
        return ret.size();
    }
};</code></pre> 
<h2> 七、递增的三元子序列</h2> 
<p><a href="https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/1204375/di-zeng-de-san-yuan-zi-xu-lie-by-leetcod-dp2r/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<h2><img alt="" height="705" src="https://images2.imgbox.com/48/de/vJrFAv3T_o.png" width="921"></h2> 
<p><img alt="" height="633" src="https://images2.imgbox.com/d2/0c/4Tl6y4Yc_o.png" width="1028">贪心： </p> 
<pre><code class="language-cpp">class Solution {
public:
    bool increasingTriplet(vector&lt;int&gt;&amp; nums) {
     //贪心策略
     int n=nums.size();
     if(n&lt;3) return false;
     int first=nums[0];
     int second=INT_MAX;
     for(int i=1;i&lt;n;++i)
        if(nums[i]&gt;second) return true;
        else if(nums[i]&gt;first) second=nums[i];
        else first=nums[i];//否则我肯定比较小 就得更新first
     return false;
    }
};</code></pre> 
<h2>八、最长连续递增子序列</h2> 
<p><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/solutions/573383/zui-chang-lian-xu-di-zeng-xu-lie-by-leet-dmb8/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="619" src="https://images2.imgbox.com/d2/56/0tk81tok_o.png" width="901"></p> 
<p><img alt="" height="493" src="https://images2.imgbox.com/44/19/ZisBefj5_o.png" width="985"></p> 
<p>贪心+滑动窗口： </p> 
<pre><code class="language-cpp">class Solution {
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {
     //贪心+双指针
     int ret=0;
     int n=nums.size();
     for(int i=0;i&lt;n;)
     {
       int j=i+1;
       while(j&lt;n&amp;&amp;nums[j]&gt;nums[j-1]) ++j;
       ret=max(j-i,ret);
       i=j;
     }
     return ret;
    }
};</code></pre> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/74/28/0uMrYSFH_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0cc2e9ddd4b96d89a6105e4cb9a3a011/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">目前比较好用的AI大模型创作工具地址合集及亮点应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b76420af8b731959ba5f551b98b750e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GraphRAG &#43; GPT-4o mini 低成本构建 AI 图谱知识库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>