<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】——堆排序以及向上、向下调整算法的时间复杂度推导及实现（超详细） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/339c261b12f00cabe7f8c00d23385688/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】——堆排序以及向上、向下调整算法的时间复杂度推导及实现（超详细）">
  <meta property="og:description" content="什么是堆排序？ 堆排序是由堆这种数据结构所设计的一种排序算法
堆的分类： 大根堆：每个父结点的值都大于子结点
小根堆 ：每个父结点的值都小于子结点
在了解完堆之后，需要先了解建堆，建堆有向上建堆建大堆或者小堆，也有向下建堆建大堆或者小堆 建大堆还是小堆看子结点和父结点的比较关系是大于还是小于
向上调整算法 新数据插⼊到数组的尾上，再进行向上调整算法，直到满⾜堆。
• 先将元素插⼊到堆的末尾,即最后⼀个孩⼦之后 • 插⼊之后如果堆的性质遭到破坏，将新插⼊结点顺着其双双亲往上调整到合适位置即可
void swap(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; } //建大堆还是小堆将两个算法的第一个判断条件修改相反即可 //向上调整 void AdjustUp(HPDataType* arr,int child) { int parent = (child - 1) / 2;//根据子结点求父结点 while (child &gt; 0)//直到子结点为根结点即循环停止 { // &gt; if (arr[child] &lt; arr[parent])//子结点小就交换，创建小堆 { swap(&amp;arr[child], &amp;arr[parent]); child = parent; parent = (child - 1) / 2; } else { break; } } } 向上调整算法时间复杂度计算推导 第1层，2^0个结点，需要向上移动0层">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-06T12:57:39+08:00">
    <meta property="article:modified_time" content="2024-09-06T12:57:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】——堆排序以及向上、向下调整算法的时间复杂度推导及实现（超详细）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>什么是堆排序？</h2> 
<p>堆排序是由堆<strong>这种数据结构所设计的一种<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/0?fromModule=lemma_inlink" rel="nofollow" title="排序算法">排序算法</a></strong></p> 
<h2>堆的分类：</h2> 
<p>大根堆：每个父结点的值都大于子结点</p> 
<p>小根堆 ：每个父结点的值都小于子结点<img alt="" height="341" src="https://images2.imgbox.com/2c/26/Wiz5tGHW_o.png" width="700"></p> 
<p> <img alt="" height="332" src="https://images2.imgbox.com/f2/51/K2UMbWb5_o.png" width="700"></p> 
<p>在了解完堆之后，需要先了解建堆，建堆有向上建堆<strong><span style="color:#fe2c24;">建大堆或者小堆</span></strong>，也有向下建堆<span style="color:#fe2c24;"><strong>建大堆或者小堆 </strong></span></p> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">建大堆还是小堆看子结点和父结点的比较关系是大于还是小于</span></strong></span></p> 
<h2> 向上调整算法</h2> 
<p><strong>新数据插⼊到数组的尾上，再进行向上调整算法，直到满⾜堆。</strong></p> 
<blockquote> 
 <p><span style="background-color:#ffd900;">• 先将元素插⼊到堆的末尾,即最后⼀个孩⼦之后 </span></p> 
 <p><span style="background-color:#ffd900;">• 插⼊之后如果堆的性质遭到破坏，将新插⼊结点顺着其双双亲往上调整到合适位置即可</span></p> 
</blockquote> 
<p><img alt="" height="653" src="https://images2.imgbox.com/93/98/KZhjCEhw_o.png" width="969"></p> 
<pre><code class="language-cpp">void swap(int* x, int* y)
{
	int tmp = *x;
	*x = *y;
	*y = tmp;
}
 
//建大堆还是小堆将两个算法的第一个判断条件修改相反即可
//向上调整
void AdjustUp(HPDataType* arr,int child)
{
	int parent = (child - 1) / 2;//根据子结点求父结点
	while (child &gt; 0)//直到子结点为根结点即循环停止
	{
//                     &gt;
		if (arr[child] &lt; arr[parent])//子结点小就交换，创建小堆
		{
			swap(&amp;arr[child], &amp;arr[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<h2> 向上调整算法时间复杂度计算推导</h2> 
<p><img alt="" height="281" src="https://images2.imgbox.com/50/b8/kYlVbHK5_o.png" width="481"></p> 
<blockquote> 
 <p>第1层，2^0个结点，需要向上移动0层</p> 
 <p>第2层，2^1个结点，需要向上移动1层</p> 
 <p>第3层，2^2个结点，需要向上移动2层 </p> 
 <p>第4层，2^3个结点，需要向上移动3层</p> 
 <p>..............................................................</p> 
 <p>第h层，2^(h-1)个结点，需要向上移动h-1层</p> 
</blockquote> 
<p>则需要移动结点总的移动步数为：每层结点个数  *  向上调整次数（第⼀层调整次数为0） </p> 
<p><img alt="" height="686" src="https://images2.imgbox.com/08/70/Uyr9Jz4c_o.png" width="900"></p> 
<p>由此可得：</p> 
<p><strong><span style="background-color:#ffd900;">向上调整算法建堆时间复杂度为：O(n ∗ log2 n)</span></strong></p> 
<p>因为堆是完全⼆叉树，⽽满⼆叉树也是完全⼆叉树，此处为了简化使⽤满⼆叉树来证明(时间复杂度本 来看的就是近似值，多⼏个结点不影响最终结果)</p> 
<h2>向下调整算法</h2> 
<p>堆的删除：</p> 
<p>删除堆是删除堆顶的数据，将堆顶的数据根最后⼀个数据⼀换，然后删除数组最后⼀个数据，再进⾏向下调整算法。</p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/30/91/2FDbRGz6_o.png" width="1179"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">• 将堆顶元素与堆中最后⼀个元素进⾏交换 </span></strong></span></p> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">• 删除堆中最后⼀个元素 </span></strong></span></p> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">• 将堆顶元素向下调整到满⾜堆特性为⽌  </span></strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">//向下调整
void AdjustDown(HPDataType* arr, int parent, int n)
{
	int child = parent * 2 + 1;
	while (child &lt; n)
	{
		//小堆：找左右孩子中找最小的
		//大堆：找左右孩子中找大的
//                                      &lt;
		if (child + 1 &lt; n &amp;&amp; arr[child] &gt; arr[child + 1])
		{
			child++;
		}
//                     &gt;
		if (arr[child] &lt; arr[parent])  //小堆，什么时候交换？ 孩子比父亲小
		{
			swap(&amp;arr[child], &amp;arr[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

void HPPop(HP* php)
{
     assert(php);
     assert(php-&gt;size &gt; 0);
     Swap(&amp;php-&gt;a[0], &amp;php-&gt;a[php-&gt;size - 1]);
     php-&gt;size--;
     AdjustDown(php-&gt;a, php-&gt;size, 0);
}
</code></pre> 
<h2> 向下调整算法时间复杂度计算推导</h2> 
<p><img alt="" height="281" src="https://images2.imgbox.com/df/be/8O0QLVGo_o.png" width="481"></p> 
<blockquote> 
 <p>第1层，2^0个结点，需要向下移动h-1层 </p> 
 <p>第2层，2^1个结点，需要向下移动h-2层</p> 
 <p>第3层，2^2个结点，需要向下移动h-3层</p> 
 <p>第4层，2^3个结点，需要向下移动h-4层</p> 
 <p>......</p> 
 <p>第h-1层，2^(h−2)个结点，需要向下移动1层 </p> 
</blockquote> 
<p>则需要移动结点总的移动步数为：每层结点个数  *  向下调整次数</p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/3a/cd/JQfoYWOr_o.png" width="1187"></p> 
<p><strong><span style="background-color:#ffd900;">向下调整算法建堆时间复杂度为：O(n) </span></strong></p> 
<h2>堆排序的应用</h2> 
<pre><code class="language-cpp">//堆排序
void HeapSort(int* arr, int n)
{
	//建堆
	//升序——大堆
	//降序——小堆
	//向上调整算法建堆
	//for (int i = 0; i &lt; 6; i++)
	//{
	//	AdjustUp(arr, i);
	//}


	//向下调整算法建堆
	//for (int i = (n - 1- 1) / 2; i &gt;= 0; i--)
	//{
	//	AdjustDown(arr, i, n);
	//}

	//循环将堆顶数据和最后一个数据进行交换
	int end = n - 1;
	while (end &gt; 0)
	{
		swap(&amp;arr[0], &amp;arr[end]);
		AdjustDown(arr, 0, end);
		end--;
	}
}</code></pre> 
<p><img alt="" height="394" src="https://images2.imgbox.com/64/29/PjO4CcCA_o.png" width="1123"></p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/72/23/sbJLMgx6_o.png" width="926"></p> 
<h2 style="background-color:transparent;">堆排序时间复杂度计算  </h2> 
<p><img alt="" height="345" src="https://images2.imgbox.com/a7/b6/KmVLhVeu_o.png" width="542"></p> 
<blockquote> 
 <p>第1层，2^0个结点，交换到根结点后，需要向下 移动0层</p> 
 <p>第2层，2^1个结点，交换到根结点后，需要向下 移动1层</p> 
 <p>第3层，2^2个结点，交换到根结点后，需要向下 移动2层</p> 
 <p>第4层，2^3个结点，交换到根结点后，需要向下 移动3层</p> 
 <p>......</p> 
 <p>第h层，2^(h-1)个结点，交换到根结点后，需要向 下移动h-1层</p> 
</blockquote> 
<p> 通过分析发现，堆排序第⼆个循环中的向下调整与建堆中的向上调整算法时间复杂度计算⼀致，此处 不再赘述。<strong><span style="background-color:#ffd900;">因此，堆排序的时间复杂度为O(n + n ∗ log n) ，即(n log n)</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41e7422fcfb6dfc113dfb54d04476ced/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最新版本Anaconda 2024.06-1安装设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a47abc7691633c7afff9d555600d8de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于HarmonyOS的学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>