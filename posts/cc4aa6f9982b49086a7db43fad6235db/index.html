<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL-触发器（TRIGGER） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cc4aa6f9982b49086a7db43fad6235db/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MySQL-触发器（TRIGGER）">
  <meta property="og:description" content="文章目录 1. 触发器是什么？2. 触发器的优缺点3. 触发器的类型3.1 INSERT触发器3.2 UPDATE触发器3.3 DELETE触发器 4. 触发器的相关语法4.1 创建触发器4.2 查看触发器4.3 删除触发器 1. 触发器是什么？ 定义：MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（ INSERT， DELETE 或 UPDATE）时就会激活它执行。作用：触发器与数据表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表保持数据的一致性、日志记录 , 数据校验等操作。 2. 触发器的优缺点 触发器的优点如下：
触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。 触发器的缺点如下：
使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难。大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性，如果需要变动的数据量较大时，触发器的执行效率会非常低。 3. 触发器的类型 在实际使用中， MySQL 所支持的触发器有三种： INSERT 触发器、 UPDATE 触发器和 DELETE 触发器。
使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。
触发器类型NEW 和 OLDINSERT 型触发器NEW 表示将要或者已经新增的数据UPDATE 型触发器OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据DELETE 型触发器OLD 表示将要或者已经删除的数据 3.1 INSERT触发器 在 INSERT 语句执行之前或之后响应的触发器，使用 INSERT 触发器需要注意以下几点：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-29T15:49:45+08:00">
    <meta property="article:modified_time" content="2024-02-29T15:49:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL-触发器（TRIGGER）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1__1" rel="nofollow">1. 触发器是什么？</a></li><li><a href="#2__8" rel="nofollow">2. 触发器的优缺点</a></li><li><a href="#3__25" rel="nofollow">3. 触发器的类型</a></li><li><ul><li><a href="#31_INSERT_39" rel="nofollow">3.1 INSERT触发器</a></li><li><a href="#32_UPDATE_51" rel="nofollow">3.2 UPDATE触发器</a></li><li><a href="#33_DELETE_64" rel="nofollow">3.3 DELETE触发器</a></li></ul> 
   </li><li><a href="#4__83" rel="nofollow">4. 触发器的相关语法</a></li><li><ul><li><a href="#41__85" rel="nofollow">4.1 创建触发器</a></li><li><a href="#42__164" rel="nofollow">4.2 查看触发器</a></li><li><a href="#43__192" rel="nofollow">4.3 删除触发器</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1__1"></a>1. 触发器是什么？</h3> 
<ul><li>定义：MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（ INSERT， DELETE 或 UPDATE）时就会激活它执行。</li><li>作用：触发器与数据表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表<strong>保持数据的一致性</strong>、<strong>日志记录</strong> , <strong>数据校验</strong>等操作。</li></ul> 
<h3><a id="2__8"></a>2. 触发器的优缺点</h3> 
<p>触发器的优点如下：</p> 
<ul><li>触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。</li><li>触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。</li><li>触发器可以实现表数据的级联更改，在一定程度上保证了<strong>数据的完整性</strong>。</li></ul> 
<p>触发器的缺点如下：</p> 
<ul><li>使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，<strong>会使后期维护变得困难</strong>。</li><li>大量使用触发器容易导致代码结构被打乱，<strong>增加了程序的复杂性</strong>，</li><li>如果需要变动的数据量较大时，触发器的执行效率会非常低。</li></ul> 
<h3><a id="3__25"></a>3. 触发器的类型</h3> 
<ul><li> <p>在实际使用中， MySQL 所支持的触发器有三种： <code>INSERT 触发器</code>、 <code>UPDATE 触发器</code>和 <code>DELETE 触发器</code>。</p> </li><li> <p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。<mark>现在触发器还只支持行级触发，不支持语句级触发</mark>。</p> 
  <table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table></li></ul> 
<h4><a id="31_INSERT_39"></a>3.1 INSERT触发器</h4> 
<ul><li> <p>在 INSERT 语句执行之前或之后响应的触发器，使用 INSERT 触发器需要注意以下几点：</p> 
  <ol><li> <p>更多操作在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</p> </li><li> <p>在 BEFORE INSERT 触发器中， NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</p> </li><li> <p>对于 AUTO_INCREMENT 列， NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。</p> </li></ol> </li></ul> 
<h4><a id="32_UPDATE_51"></a>3.2 UPDATE触发器</h4> 
<ul><li> <p>在 UPDATE 语句执行之前或之后响应的触发器，使用 UPDATE 触发器需要注意以下几点：</p> 
  <ol><li>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</li><li>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ol> <p><mark>注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许</mark>。</p> </li></ul> 
<h4><a id="33_DELETE_64"></a>3.3 DELETE触发器</h4> 
<ul><li> <p>DELETE 语句执行之前或之后响应的触发器，使用 DELETE 触发器需要注意以下几点：</p> 
  <ol><li> <p>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</p> </li><li> <p>OLD 中的值全部是只读的，不能被更新。</p> </li></ol> </li></ul> 
<hr> 
<p>总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。</p> 
<ol><li>对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。</li><li>若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。</li><li>若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。</li><li>仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行 AFTER 触发程序。</li></ol> 
<h3><a id="4__83"></a>4. 触发器的相关语法</h3> 
<h4><a id="41__85"></a>4.1 创建触发器</h4> 
<ul><li> <p>在 MySQL 5.7 中，可以使用 CREATE TRIGGER 语句创建触发器，语法格式如下：</p> <pre><code class="prism language-mysql">CREATE &lt;触发器名&gt; &lt; BEFORE | AFTER &gt;
&lt;INSERT | UPDATE | DELETE &gt;
ON &lt;表名&gt; FOR EACH Row&lt;触发器主体&gt;
</code></pre> </li></ul> 
<ol><li>触发器名</li></ol> 
<p>触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。</p> 
<ol start="2"><li>INSERT | UPDATE | DELETE</li></ol> 
<p>触发事件，用于指定激活触发器的语句的种类。</p> 
<p>注意：三种触发器的执行时间如下。</p> 
<ul><li>INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。</li><li>DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。</li><li>UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。</li></ul> 
<ol start="3"><li>BEFORE | AFTER</li></ol> 
<p>BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。</p> 
<ol start="4"><li>表名</li></ol> 
<p>与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。</p> 
<ol start="5"><li>触发器主体</li></ol> 
<p>触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。</p> 
<ol start="6"><li>FOR EACH ROW</li></ol> 
<p>一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。</p> 
<hr> 
<ul><li> <p>案例1：插入数据触发器</p> <pre><code class="prism language-mysql">create trigger tb_user_insert_trigger
after insert on tb_user for each row
begin
	insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES
	(null, 'insert', now(), new.id, concat('插入的数据内容为:id=',new.id,',name=',new.name, ', phone=', 	NEW.phone, ', email=', NEW.email, ',profession=', NEW.profession));
end; 
</code></pre> </li><li> <p>案例2：修改触发器</p> <pre><code class="prism language-mysql">create trigger tb_user_update_trigger
after update on tb_user for each row
begin
	insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES
	(null, 'update', now(), new.id,concat('更新之前的数据: id=',old.id,',name=',old.name, ', phone=',
	old.phone, ', email=', old.email, ', profession=', old.profession,' | 更新之后的数据: 					id=',new.id,',name=',new.name, ', phone=',NEW.phone, ', email=', NEW.email, ', profession=', 		NEW.profession));
end;
</code></pre> </li><li> <p>案例3：删除触发器</p> <pre><code class="prism language-mysql">create trigger tb_user_delete_trigger
after delete on tb_user for each row
begin
	insert into user_logs(id, operation, operate_time, operate_id, operate_params) VALUES
	(null, 'delete', now(), old.id,concat('删除之前的数据: id=',old.id,',name=',old.name, ', phone=',
	old.phone, ', email=', old.email, ', profession=', old.profession));
end;
</code></pre> </li></ul> 
<h4><a id="42__164"></a>4.2 查看触发器</h4> 
<ul><li> <p>在 MySQL 中，可以通过 SHOW TRIGGERS 语句来查看触发器的基本信息，语法格式如下：</p> <pre><code class="prism language-mysql">SHOW TRIGGERS;
</code></pre> <p><img src="https://images2.imgbox.com/2b/26/66ACKhsT_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在 MySQL 中，所有触发器的信息都存在 information_schema 数据库的 triggers 表中，可以通过查询命令 SELECT 来查看，具体的语法如下：</p> <pre><code class="prism language-mysql">SELECT * FROM information_schema.triggers WHERE trigger_name= '触发器名';
</code></pre> <p><img src="https://images2.imgbox.com/ff/c4/hOwpuOJy_o.png" alt="在这里插入图片描述"></p> </li><li> <p>查看所有的触发器:</p> <pre><code class="prism language-mysql">SELECT * FROM information_schema.triggers
</code></pre> </li></ul> 
<h4><a id="43__192"></a>4.3 删除触发器</h4> 
<ul><li> <p>使用 DROP TRIGGER 语句可以删除 MySQL 中已经定义的触发器。</p> <pre><code class="prism language-mysql">DROP TRIGGER [ IF EXISTS ] [数据库名] &lt;触发器名&gt;
</code></pre> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e0cc014ccf6debcbe3a96be2ebe0dfa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决android studio build Output中文乱码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/110647096d7ecfc01e5b10dbe6c608a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Stable Diffusion 解析：探寻 AI 绘画背后的科技神秘</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>