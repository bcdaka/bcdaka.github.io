<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python解析xml - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f0d957ec9eaf3bdc92d2230a1cde955a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="python解析xml">
  <meta property="og:description" content="Python 有三种方法解析 XML：ElementTree、SAX 以及 DOM。
使用 ElementTree 解析 xml xml.etree.ElementTree 是 Python 标准库中用于处理 XML 的模块。
ElementTree 和 Element 对象:
ElementTree： ElementTree 类是 XML 文档的树形表示。它包含一个或多个 Element 对象，代表整个 XML 文档。Element： Element 对象是 XML 文档中元素的表示。每个元素都有一个标签、一组属性和零个或多个子元素。 ET.ElementTree() ET.ElementTree() 是 xml.etree.ElementTree 模块中的一个类，它用于创建一个 ElementTree 对象，这个对象可以包含一个完整的 XML 文档树结构。通过这个类，你可以方便地操作整个 XML 文档，包括解析、创建、修改和写入 XML 数据。
当你创建一个 ElementTree 对象时，你通常需要提供一个根元素（Root Element）作为参数。这个根元素是整个 XML 文档的顶级元素，所有的其他元素都会作为它的子元素存在。
以下是 ET.ElementTree() 类的一些常用方法：
parse(): 解析一个 XML 文件或字符串，并返回一个 ElementTree 对象。write(): 将 ElementTree 对象写入到一个文件或文件对象中。find(): 在 ElementTree 对象中查找与指定路径或标签名匹配的元素。findall(): 在 ElementTree 对象中查找所有与指定路径或标签名匹配的元素。 import xml.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-15T15:35:05+08:00">
    <meta property="article:modified_time" content="2024-04-15T15:35:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python解析xml</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Python 有三种方法解析 XML：<strong>ElementTree</strong>、<strong>SAX</strong> 以及 <strong>DOM</strong>。</p> 
<h2 style="background-color:transparent;">使用 ElementTree 解析 xml</h2> 
<p><strong>xml.etree.ElementTree </strong>是 Python 标准库中用于处理 XML 的模块。</p> 
<p>ElementTree 和 Element 对象:</p> 
<ul><li><strong>ElementTree</strong>： ElementTree 类是 XML 文档的<strong>树形</strong>表示。它包含一个或多个 Element 对象，代表整个 XML 文档。</li><li><strong>Element</strong>： Element 对象是 XML 文档中<strong>元素</strong>的表示。每个元素都有一个标签、一组属性和零个或多个子元素。</li></ul> 
<h3><code>ET.ElementTree()</code></h3> 
<p><code>ET.ElementTree()</code> 是 <code>xml.etree.ElementTree</code> 模块中的<strong>一个类</strong>，它用于<strong>创建一个 ElementTree 对象</strong>，这个对象可以包含一个完整的<strong> XML 文档树结构</strong>。通过这个类，你可以方便地操作整个 XML 文档，包括解析、创建、修改和写入 XML 数据。</p> 
<p>当你创建一个 <code>ElementTree</code> 对象时，你通常需要<strong>提供一个根元素</strong>（Root Element）作为<strong>参数</strong>。这个根元素是整个 XML 文档的顶级元素，所有的其他元素都会作为它的子元素存在。</p> 
<p>以下是 <code>ET.ElementTree()</code> 类的一些常用方法：</p> 
<ol><li><strong><code>parse()</code></strong>: 解析一个 XML 文件或字符串，并返回一个 ElementTree 对象。</li><li><strong><code>write()</code></strong>: 将 ElementTree 对象写入到一个文件或文件对象中。</li><li><strong><code>find()</code></strong>: 在 ElementTree 对象中查找与指定路径或标签名匹配的元素。</li><li><strong><code>findall()</code></strong>: 在 ElementTree 对象中查找所有与指定路径或标签名匹配的元素。</li></ol> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 创建根元素
root = ET.Element('bookstore')

# 创建子元素并添加到根元素
book = ET.SubElement(root, 'book', category='cooking', lang='en')
title = ET.SubElement(book, 'title', lang='en')
title.text = 'Everyday Italian'
author = ET.SubElement(book, 'author')
author.text = 'Giada De Laurentiis'

# 创建 ElementTree 对象
tree = ET.ElementTree(root)

# 写入到文件
tree.write('example.xml', encoding='utf-8', xml_declaration=True)

# 解析文件并获取 ElementTree 对象
new_tree = ET.parse('example.xml')
new_root = new_tree.getroot()

# 查找特定的元素
for book in new_root.findall('book'):
    print(f"Book Category: {book.attrib['category']}")
    print(f"Book Language: {book.attrib['lang']}")
    print(f"Book Title: {book.find('title').text}")
    print("-" * 40)</code></pre> 
<p></p> 
<h3 style="background-color:transparent;"><code>解析xml</code></h3> 
<h4 style="background-color:transparent;"><code>fromstring()</code></h4> 
<p><code>fromstring()</code> 函数是该模块提供的一个便捷方法，用于将<strong>包含 XML 数据的字符串解析为一个 Element 对象</strong>，这个对象是 XML 树结构中的一个节点。</p> 
<p><code>fromstring()</code> 函数特别有用，当你需要从一个<strong> XML 格式的字符串</strong>直接<strong>创建一个 Element 对象</strong>时。这个函数属于 <code>xml.etree.ElementTree</code> 模块，它能够解析 XML 字符串并返回一个 Element 对象，你可以对这个对象进行进一步的操作，比如<strong>提取数据、修改 XML 结构</strong>等。</p> 
<p>以下是一个使用 <code>fromstring()</code> 函数的示例：</p> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 假设我们有一个 XML 格式的字符串
xml_string = """
&lt;bookstore&gt;
  &lt;book category="cooking"&gt;
    &lt;title lang="en"&gt;Everyday Italian&lt;/title&gt;
    &lt;author&gt;Giada De Laurentiis&lt;/author&gt;
    &lt;year&gt;2005&lt;/year&gt;
    &lt;price&gt;30.00&lt;/price&gt;
  &lt;/book&gt;
  &lt;book category="children"&gt;
    &lt;title lang="en"&gt;Harry Potter&lt;/title&gt;
    &lt;author&gt;J.K. Rowling&lt;/author&gt;
    &lt;year&gt;2005&lt;/year&gt;
    &lt;price&gt;29.99&lt;/price&gt;
  &lt;/book&gt;
  &lt;book category="web"&gt;
    &lt;title lang="en"&gt;Learning XML&lt;/title&gt;
    &lt;author&gt;Erik T. Ray&lt;/author&gt;
    &lt;year&gt;2003&lt;/year&gt;
    &lt;price&gt;39.95&lt;/price&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;
"""

# 使用 fromstring() 方法将 XML 字符串解析为 Element 对象
root = ET.fromstring(xml_string)

# 打印解析后的 Element 对象的 tag 和 text
print(f"Tag: {root.tag}, Text: {root.text}")

# 可以通过遍历 Element 对象的子节点来访问 XML 数据
for child in root:
    print(f"Title: {child.find('title').text}")
    print(f"Author: {child.find('author').text}")
    print(f"Year: {child.find('year').text}")
    print(f"Price: {child.find('price').text}")
    print("-" * 40)</code></pre> 
<p>在这个例子中，首先定义了一个包含多个书籍信息的 XML 字符串。然后，使用 <code>fromstring()</code> 函数将这个字符串解析为一个 Element 对象。通过这个 Element 对象，我们可以访问 XML 文档中的各种信息，例如书名、作者、出版年份和价格。</p> 
<h4><strong>parse()</strong></h4> 
<p><code>parse()</code> 函数是 <code>xml.etree.ElementTree</code> 模块中的另一个重要方法，它用于<strong>解析 XML 文件并返回一个 ElementTree 对象</strong>，该对象<strong>包含了整个 XML 文档的树形结构</strong>。与 <strong><code>fromstring()</code> 方法不同</strong>，<code>parse()</code> 方法<strong>用于从文件对象读取 XML 数据</strong>，而 <code>fromstring()</code> 则是用于<strong>从字符串读取 </strong>XML 数据。</p> 
<p>使用 <code>parse()</code> 方法时，你<strong>需要提供一个打开的文件对象</strong>（例如，使用<strong> <code>open()</code> 函数返回</strong>的对象），该文件对象包含 XML 数据。<code>parse()</code> 方法会读取文件内容，并构建出一个 ElementTree 对象，你可以使用这个对象来访问和操作 XML 文档的结构和数据。</p> 
<p>以下是一个使用 <code>parse()</code> 方法的示例：</p> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 假设我们有一个名为 'example.xml' 的 XML 文件
# 文件内容与之前提供的 XML 字符串相同

# 使用 open() 函数以读取模式打开 XML 文件
with open('example.xml', 'r') as xml_file:
    # 使用 parse() 方法解析 XML 文件并返回 ElementTree 对象
    tree = ET.parse(xml_file)

    # 根元素可以通过 getroot() 方法获取
    root = tree.getroot()
    print(f"Root Element: {root.tag}")

    # 可以通过根元素来访问 XML 文档中的所有子元素
    for child in root:
        print(f"Book Title: {child.find('title').text}")
        print(f"Book Author: {child.find('author').text}")
        print(f"Book Year: {child.find('year').text}")
        print(f"Book Price: {child.find('price').text}")
        print("-" * 40)</code></pre> 
<p></p> 
<p>在这个例子中，我们首先<strong>打开了</strong>一个名为 <code>example.xml</code> 的<strong>文件</strong>，该文件包含了 XML 数据。然后，我们使用 <code>parse()</code> 方法来解析这个文件，并获取到一个 ElementTree 对象。通过<strong>调用 <code>getroot()</code> 方法</strong>，我们可以<strong>获取到 XML 文档的根元素</strong>。之后，我们可以<strong>遍历根元素的子元素</strong>，提取出每本书的标题、作者、出版年份和价格等信息。</p> 
<p><code>parse()</code> 方法是处理存储在文件中的 XML 数据的有效方式，它允许你构建出一个完整的 XML 树形结构，从而可以方便地对整个 XML 文档进行解析和操作。</p> 
<p></p> 
<h3 style="background-color:transparent;"><code>getroot()</code></h3> 
<p><code>getroot()</code> 是 <code>xml.etree.ElementTree</code> 模块中的一个方法，它用于<strong>获取解析后的 XML 文档的根元素</strong>。当你使用 <code>parse()</code> 函数从文件中解析 XML 数据时，它会返回一个<strong> ElementTree 对象</strong>，该对象包含了整个 XML 文档的树形结构。通过这个 ElementTree 对象，你可以调用 <code>getroot()</code> 方法来<strong>访问</strong> XML 文档的<strong>根节点</strong>。</p> 
<p>根节点是 XML 文档结构的<strong>最顶层元素</strong>，它包含了<strong>所有的子元素和数据</strong>。通过访问根节点，你可以开始<strong>遍历</strong>整个 XML 文档，查找特定的元素，提取数据或者对 XML 结构进行修改。</p> 
<p></p> 
<h3><strong>find() </strong></h3> 
<p><code>find()</code> 用于在当前 Element 对象的子元素中<strong>查找与指定路径或标签名</strong>匹配的<strong>第一个元素</strong>。这个方法非常有用，当你需要在 XML 文档中定位到特定的元素并对其进行操作时。</p> 
<p><code>find()</code> 方法可以接受两个参数：</p> 
<ol><li><code>path</code>：这是一个字符串，表示从当前 Element 向下查找的 <strong>XPath</strong> 路径。XPath 是一种在 XML 和 HTML 文档中查找信息的语言。你可以使用标签名、属性和其他选择器来构建路径。</li><li><code>namespaces</code>：这是一个可选的字典，用于指定命名空间的前缀和 URI。如果你的 XML 文档使用了命名空间，你需要提供这个参数来正确解析路径。</li></ol> 
<p><code>find()</code> 方法返回与指定路径或标签名匹配的第一个 Element 对象，如果没有找到匹配的元素，则返回 <code>None</code>。</p> 
<p>以下是一个使用 <code>find()</code> 方法的示例：</p> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 假设我们有一个名为 'example.xml' 的 XML 文件
# 文件内容如下：
'''
&lt;bookstore&gt;
  &lt;book category="cooking"&gt;
    &lt;title lang="en"&gt;Everyday Italian&lt;/title&gt;
    &lt;author&gt;Giada De Laurentiis&lt;/author&gt;
  &lt;/book&gt;
  &lt;book category="children"&gt;
    &lt;title lang="en"&gt;Harry Potter&lt;/title&gt;
    &lt;author&gt;J.K. Rowling&lt;/author&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;
'''

# 解析 XML 文件并获取根元素
root = ET.parse('example.xml').getroot()

# 使用 find() 方法查找第一个 &lt;book&gt; 元素
first_book = root.find('book')

# 打印找到的 &lt;book&gt; 元素的标题
title_element = first_book.find('title')
if title_element is not None:
    print(f"Book Title: {title_element.text}")

# 使用 XPath 路径查找特定的 &lt;book&gt; 元素
cooking_book = root.find('.//book[@category="cooking"]')

# 打印找到的烹饪类书籍的作者
if cooking_book is not None:
    author_element = cooking_book.find('author')
    if author_element is not None:
        print(f"Cooking Book Author: {author_element.text}")
</code></pre> 
<p>在这个示例中，我们首先解析了一个名为 <code>example.xml</code> 的 XML 文件，并获取了根元素。然后，我们使用 <code>find()</code> 方法查找了第一个 <code>&lt;book&gt;</code> 元素，并打印出了它的标题。接着，我们使用了一个 XPath 路径来查找分类为 "cooking" 的书籍，并打印出了它的作者信息。</p> 
<p><code>find()</code> 方法是处理 XML 数据时的一个非常有用的工具，它允许你快速定位到 XML 文档中的特定元素，并对其进行操作。通过结合使用标签名和 XPath 路径，你可以灵活地在 XML 文档中导航和查询。</p> 
<p><strong>findall() 方法</strong>： 使用 findall() 方法可以查找具有指定标签的所有子元素：</p> 
<p></p> 
<h3><strong><code>attrib</code> 属性</strong></h3> 
<p>在 <code>xml.etree.ElementTree</code> 模块中，<strong>每个 <code>Element</code> 对象都有一个 <code>attrib</code> 属性</strong>，它是一个<strong>字典</strong>，用于<strong>存储与该元素关联的属性</strong>。属性通常以名称和值对的形式存在，名称是属性的名称，值是属性的值。这个属性在解析 XML 文档时特别有用，因为它允许你访问元素的属性，如类名、ID、样式等。</p> 
<p>当你使用 <code>xml.etree.ElementTree</code> 模块解析一个 XML 文档时，所有的属性都会被读取并存储在 <code>Element</code> 对象的 <code>attrib</code> 属性中。你可以像访问普通字典一样访问 <code>attrib</code> 属性。</p> 
<p>以下是一个使用 <code>attrib</code> 属性的示例：</p> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 假设我们有一个包含属性的 XML 字符串
xml_string = """
&lt;bookstore&gt;
  &lt;book category="cooking" lang="en"&gt;
    &lt;title&gt;Everyday Italian&lt;/title&gt;
    &lt;author&gt;Giada De Laurentiis&lt;/author&gt;
  &lt;/book&gt;
  &lt;book category="children" lang="en"&gt;
    &lt;title&gt;Harry Potter&lt;/title&gt;
    &lt;author&gt;J.K. Rowling&lt;/author&gt;
  &lt;/book&gt;
&lt;/bookstore&gt;
"""

# 解析 XML 字符串并获取根元素
root = ET.fromstring(xml_string)

# 遍历根元素的所有 &lt;book&gt; 子元素
for book in root.findall('book'):
    # 打印每个 &lt;book&gt; 元素的属性
    print(f"Book Category: {book.attrib['category']}")
    print(f"Book Language: {book.attrib['lang']}")
    print("-" * 40)</code></pre> 
<p>在这个示例中，我们首先定义了一个包含两个 <code>&lt;book&gt;</code> 元素的 XML 字符串，每个元素都有 <code>category</code> 和 <code>lang</code> 属性。然后，我们使用 <code>fromstring()</code> 方法将这个字符串解析为一个 Element 对象，并获取根元素。接着，我们使用 <code>findall()</code> 方法找到所有的 <code>&lt;book&gt;</code> 子元素，并遍历它们。对于每个 <code>&lt;book&gt;</code> 元素，我们通过 <code>attrib</code> 属性访问并打印了它的 <code>category</code> 和 <code>lang</code> 属性。</p> 
<p></p> 
<h3>text 属性</h3> 
<p><code>text</code> 属性用于获取或设置与 <code>Element</code> 对象关联的文本内容。这个属性通常用于访问或修改元素内的纯文本数据。需要注意的是，<code>text</code> 属性可能包含空白字符，如空格、换行符和制表符等。</p> 
<p></p> 
<h3>创建xml</h3> 
<h4 style="background-color:transparent;">Element() </h4> 
<p><code>Element()</code> 函数是 <code>xml.etree.ElementTree</code> 模块中的一个<strong>构造函数</strong>，用于<strong>创建一个新的 XML 元素</strong>（Element 对象）。这个函数通常用于<strong>构建 XML 文档的树结构</strong>，或者在已有的 XML 文档中<strong>添加新的元素节点</strong>。</p> 
<p>当你调用 <code>Element()</code> 函数时，你可以传递<strong>多个参数</strong>来<strong>初始化</strong> Element 对象：</p> 
<ol><li><code>tag</code>：<strong>必需参数</strong>，表示元素的标签名。</li><li><code>attrib</code>：可选参数，一个字典，用于指定<strong>元素的属性</strong>。</li><li><code>*children</code>：可选参数，可以是<strong>一个或多个子元素</strong>，用于构建元素的子节点结构。</li></ol> 
<p>创建 Element 对象后，你可以使用 <code>attrib</code> 属性来添加或修改元素的属性，使用 <code>text</code> 属性来设置或获取元素的文本内容，以及使用<strong> <code>append()</code> 方法</strong>来添加子元素。</p> 
<p>以下是一个使用 <code>Element()</code> 函数的示例：</p> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 创建一个新的根元素
root = ET.Element('bookstore')

# 创建一个新的 &lt;book&gt; 元素，并设置属性和文本内容
book = ET.Element('book', attrib={'category': 'cooking', 'lang': 'en'})
book.text = 'This is a cooking book.'

# 创建 &lt;title&gt; 和 &lt;author&gt; 子元素
title = ET.Element('title')
title.text = 'Everyday Italian'

author = ET.Element('author')
author.text = 'Giada De Laurentiis'

# 将子元素添加到 &lt;book&gt; 元素中
book.append(title)
book.append(author)

# 将 &lt;book&gt; 元素添加到根元素中
root.append(book)

# 打印构建的 XML 树结构
print(ET.tostring(root, encoding='unicode'))</code></pre> 
<p>在这个示例中，首先创建了一个新的根元素 <code>bookstore</code>。然后，创建了一个新的 <code>book</code> 元素，并为其设置了属性和文本内容。接着，创建了 <code>title</code> 和 <code>author</code> 子元素，并将它们的文本内容分别设置为书籍的标题和作者。之后，将这些子元素添加到 <code>book</code> 元素中，然后将 <code>book</code> 元素添加到根元素 <code>bookstore</code> 中。最后，使用 <code>tostring()</code> 方法将构建的 XML 树结构转换为字符串并打印出来。</p> 
<p></p> 
<h4 style="background-color:transparent;"><code>SubElement()</code></h4> 
<p><code>SubElement()</code> 函数用于在<strong>已存在的 XML 元素下创建一个新的子元素</strong>。这个方法是 <code>Element</code> 类的一个方法，可以通过调用已存在的元素的 <code>SubElement</code> 方法来使用。它简化了创建和添加子元素到 XML 树结构的过程。</p> 
<p>当你调用 <code>SubElement()</code> 方法时，你需要提供以下参数：</p> 
<ol><li><code>tag</code>：<strong>必需参数</strong>，表示要创建的子元素的标签名。</li><li><code>attrib</code>：可选参数，一个字典，用于指定子元素的属性。</li></ol> 
<p><code>SubElement()</code> 方法会<strong>创建一个新的 <code>Element</code> 对象</strong>，并将其<strong>作为当前元素的子元素插入</strong>。这个方法也<strong>返回创建的 <code>Element</code> 对象</strong>，允许你对新创建的子元素进行进一步的操作，如设置文本内容或添加更多子元素。</p> 
<p>以下是一个使用 <code>SubElement()</code> 方法的示例：</p> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 创建根元素
root = ET.Element('bookstore')

# 使用 SubElement() 方法创建一个新的 &lt;book&gt; 子元素
book = root.SubElement('book', category='cooking', lang='en')

# 为 &lt;book&gt; 元素创建 &lt;title&gt; 和 &lt;author&gt; 子元素
book.set('isbn', '1234567890')  # 设置属性的快捷方式
title = book.SubElement('title')
title.text = 'Everyday Italian'
author = book.SubElement('author')
author.text = 'Giada De Laurentiis'

# 打印构建的 XML 树结构
tree = ET.ElementTree(root)
print(ET.tostring(root, encoding='unicode', method='xml'))</code></pre> 
<p>在这个示例中，我们首先创建了一个名为 <code>bookstore</code> 的根元素。然后，我们使用 <code>SubElement()</code> 方法为根元素创建了一个 <code>&lt;book&gt;</code> 子元素，并为其设置了 <code>category</code> 和 <code>lang</code> 属性。接着，我们为 <code>&lt;book&gt;</code> 元素创建了 <code>&lt;title&gt;</code> 和 <code>&lt;author&gt;</code> 子元素，并设置了它们的文本内容。我们还使用了 <code>set()</code> 方法来为 <code>&lt;book&gt;</code> 元素设置了一个 <code>isbn</code> 属性。最后，我们使用 <code>ElementTree()</code> 方法将根元素转换成一个 ElementTree 对象，并使用 <code>tostring()</code> 方法将 XML 树结构转换为字符串并打印出来。</p> 
<h3 style="background-color:transparent;">修改xml</h3> 
<p><strong>1.直接赋值</strong>：你可以直接通过元素的 <code>attrib</code> 属性来赋新值给已有的属性，或者添加新的属性。</p> 
<pre><code class="hljs"># 假设我们有一个名为 element 的 Element 对象，并且它有一个名为 'att1' 的属性
element = ET.Element('example')
element.set('att1', 'value1')

# 修改属性值
element.attrib['att1'] = 'new_value'

# 添加新属性
element.attrib['att2'] = 'another_value'</code></pre> 
<p><strong>2.使用 <code>set()</code> 方法</strong>：<code>Element</code> 对象的 <code>set()</code> 方法可以用来设置属性的值。这个方法允许你通过属性名和值作为参数来设置。</p> 
<pre><code class="hljs"># 修改属性值
element.set('att1', 'updated_value')

# 添加新属性
element.set('att3', 'new_value')</code></pre> 
<h3></h3> 
<h3 style="background-color:transparent;">删除xml</h3> 
<p>remove() 方法可以删除元素</p> 
<pre><code class="hljs">root.remove(title_element)</code></pre> 
<h3></h3> 
<h3>练习</h3> 
<p>创建文档，把文档保存到xml文件，再解析xml的实例</p> 
<pre><code class="hljs">import xml.etree.ElementTree as ET

# 创建一个XML文档
root = ET.Element('bookstore')

# 添加第一本书
book1 = ET.SubElement(root, 'book')
title1 = ET.SubElement(book1, 'title')
title1.text = 'Introduction to Python'
author1 = ET.SubElement(book1, 'author')
author1.text = 'John Doe'
price1 = ET.SubElement(book1, 'price')
price1.text = '29.99'

# 添加第二本书
book2 = ET.SubElement(root, 'book')
title2 = ET.SubElement(book2, 'title')
title2.text = 'Data Science with Python'
author2 = ET.SubElement(book2, 'author')
author2.text = 'Jane Smith'
price2 = ET.SubElement(book2, 'price')
price2.text = '39.95'

# 将XML文档保存到文件
tree = ET.ElementTree(root)
tree.write('books.xml')

# 从文件中解析XML文档
parsed_tree = ET.parse('books.xml')
parsed_root = parsed_tree.getroot()

# 遍历XML树并打印书籍信息
for book in parsed_root.findall('book'):
    title = book.find('title').text
    author = book.find('author').text
    price = book.find('price').text
    print(f'Title: {title}, Author: {author}, Price: {price}')</code></pre> 
<p></p> 
<h2>使用 SAX 解析 xml</h2> 
<p>SAX（Simple API for XML）是一种<strong>基于事件</strong>的 XML 处理模型，它允许你<strong>逐个元素地访问</strong> XML 文档的内容，而<strong>不是一次性</strong>将整个文档加载到内存中。这种解析方式对于<strong>处理大型 XML 文件</strong>非常有用，因为它可以<strong>减少内存消耗</strong>并<strong>提高处理速度</strong>。</p> 
<p>Python 通过 <code>xml.sax</code> 模块提供了对 SAX 解析的支持。以下是使用 <code>xml.sax</code> 进行 XML 解析的基本步骤：</p> 
<ol><li> <p><strong>创建 SAX 解析器实例</strong>：你需要创建一个解析器对象，Python 支持两种解析器：<strong><code>xml.sax.make_parser()</code></strong> 可以创建一个基于纯 Python 的解析器，或者你可以指定一个外部解析器，如 <code>lxml.etree</code>。</p> </li><li> <p><strong>定义 SAX 事件处理器</strong>：你需要<strong>定义一个或多个事件处理器类</strong>，这些类继承自 <strong><code>xml.sax.handler.ContentHandler</code></strong> 并<strong>实现其方法</strong>，以<strong>处理 XML 文档中的不同事件</strong>，如开始元素、结束元素、字符数据等。</p> </li><li> <p><strong>注册事件处理器</strong>：将你的事件处理器<strong>注册</strong>到解析器中，这样当解析器遇到相应的事件时，就会调用处理器中的方法。</p> </li><li> <p><strong>解析 XML 文档</strong>：使用解析器对象的<strong> <code>parse()</code></strong> 方法来读取和解析 XML 文档。</p> </li></ol> 
<p>以下是一个使用 <code>xml.sax</code> 进行 SAX 解析的示例：</p> 
<pre><code class="hljs">import xml.sax
from xml.sax import handler

class MyContentHandler(handler.ContentHandler):
    def __init__(self):
        handler.ContentHandler.__init__(self)
        self.current_element = None

    def startElement(self, name, attrs):
        self.current_element = name
        print(f"Start Element: {name}")

    def endElement(self, name):
        print(f"End Element: {name}")

    def characters(self, content):
        if self.current_element and content.strip():
            print(f"Characters in {self.current_element}: {content}")

# 创建解析器实例
parser = xml.sax.make_parser()

# 注册事件处理器
parser.setContentHandler(MyContentHandler())

# 解析 XML 文件
parser.parse(r'C:\Users\Administrator\Desktop\文件夹\解析xml\example.xml')</code></pre> 
<p>在这个示例中，我们首先定义了一个 <code>MyContentHandler</code> 类，它<strong>实现了 <code>ContentHandler</code> 的几个方法来处理不同的事件</strong>。然后，我们<strong>创建</strong>了一个<strong>解析器实例</strong>并将我们的<strong>事件处理器注册</strong>到<strong>它上面</strong>。最后，我们调用<strong> <code>parse()</code> 方法</strong>来<strong>解析</strong>一个名为 <code>example.xml</code> 的<strong>文件</strong>。</p> 
<p>当你运行这个程序时，它会打印出 XML 文档中每个元素的开始和结束事件，以及元素内的字符数据（如果存在的话）。</p> 
<p>SAX 解析是一种高效的处理 XML 的方式，特别是对于大型文件或流式数据，它可以帮助你在不过度消耗资源的情况下处理 XML 数据。</p> 
<p></p> 
<h3><code>ContentHandler</code> 类</h3> 
<p><code>ContentHandler</code> 类是 Python <code>xml.sax</code> 模块中的<strong>一个接口</strong>，用于<strong>处理 SAX 解析器</strong>在解析 XML 文档时产生的<strong>事件</strong>。当使用 SAX 进行 XML 解析时，解析器<strong>会遍历整个文档</strong>，并在遇到文档的不同部分时<strong>触发事件</strong>，如遇到元素的开始、结束、字符数据等。<code>ContentHandler</code> 类定义了这些事件的处理器，你可以继承这个类并实现其中的方法来处理这些事件。</p> 
<p>以下是 <code>ContentHandler</code> 类中定义的一些常用方法，你可以重写这些方法来处理解析事件：</p> 
<ol><li><code>startDocument()</code>: 在文档开始解析时调用。</li><li><code>endDocument()</code>: 在文档解析结束时调用。</li><li><code>startElement()</code>: 在遇到元素的开始标签时调用，参数包括元素名和属性字典。</li><li><code>endElement()</code>: 在遇到元素的结束标签时调用，参数为元素名。</li><li><code>characters()</code>: 在遇到元素的字符数据时调用，参数为字符串。</li></ol> 
<h3>make_parser（）</h3> 
<p>用于创建一个 SAX 解析器对象。这个对象是 SAX 解析流程的核心，负责读取 XML 数据并触发相应的事件。你可以通过配置这个解析器对象来指定如何处理 XML 文档中的不同事件，例如通过设置内容处理器（<code>ContentHandler</code>）来处理文档中的数据。</p> 
<p></p> 
<h3>setContentHandler（）</h3> 
<p>用于<strong>设置</strong>处理 SAX 解析事件的<strong>内容处理器</strong>。内容处理器是一个实现了 <code>xml.sax.ContentHandler</code> 接口的类实例，它定义了如何处理 XML 文档中的不同事件，如元素的开始、结束、字符数据等。</p> 
<p>当你创建了一个自定义的内容处理器类并想要将其与 SAX 解析器关联时，你会使用 <code>setContentHandler()</code> 方法。这样，当解析器读取和解析 XML 文档时，它将调用内容处理器中的方法来处理相应的事件。</p> 
<p></p> 
<h3 style="background-color:transparent;"><code>parse()</code></h3> 
<p><code>parse()</code>方法是<code>XMLReader</code>类的实例（通常称为解析器）的一个方法，用于<strong>开始整个XML文档的解析过程</strong>。当你调用这个方法时，它会<strong>触发一系列的事件</strong>，这些事件会通知你XML文档的结构和内容，包括元素的开始、结束、文本内容等。</p> 
<p><code>parse()</code>方法可以接受两个参数：</p> 
<ol><li> <p><strong>源（source）</strong>：这是一个可选参数，指定了要解析的XML数据的来源。它可以是一个文件路径字符串，一个打开的文件对象，或者一个<code>io.BytesIO</code>对象（如果你正在处理二进制数据）。如果省略这个参数，解析器会从标准输入读取数据。</p> </li><li> <p><strong>处理程序（handler）</strong>：这是另一个可选参数，指定了一个<code>ContentHandler</code>对象，用于接收和处理解析事件。如果你没有提供处理程序，或者提供了<code>None</code>，那么解析器将使用默认的处理程序，它实际上不会做任何事情。</p> </li></ol> 
<p>练习：解析movies.xml</p> 
<pre><code class="hljs">#!/usr/bin/python3

import xml.sax

class MovieHandler( xml.sax.ContentHandler ):
   def __init__(self):
      self.CurrentData = ""
      self.type = ""
      self.format = ""
      self.year = ""
      self.rating = ""
      self.stars = ""
      self.description = ""

   # 元素开始调用
   def startElement(self, tag, attributes):
      self.CurrentData = tag
      if tag == "movie":
         print ("*****Movie*****")
         title = attributes["title"]
         print ("Title:", title)

   # 元素结束调用
   def endElement(self, tag):
      if self.CurrentData == "type":
         print ("Type:", self.type)
      elif self.CurrentData == "format":
         print ("Format:", self.format)
      elif self.CurrentData == "year":
         print ("Year:", self.year)
      elif self.CurrentData == "rating":
         print ("Rating:", self.rating)
      elif self.CurrentData == "stars":
         print ("Stars:", self.stars)
      elif self.CurrentData == "description":
         print ("Description:", self.description)
      self.CurrentData = ""

   # 读取字符时调用
   def characters(self, content):
      if self.CurrentData == "type":
         self.type = content
      elif self.CurrentData == "format":
         self.format = content
      elif self.CurrentData == "year":
         self.year = content
      elif self.CurrentData == "rating":
         self.rating = content
      elif self.CurrentData == "stars":
         self.stars = content
      elif self.CurrentData == "description":
         self.description = content
  
if ( __name__ == "__main__"):
   
   # 创建一个 XMLReader
   parser = xml.sax.make_parser()
   # 关闭命名空间
   parser.setFeature(xml.sax.handler.feature_namespaces, 0)

   # 重写 ContextHandler
   Handler = MovieHandler()
   parser.setContentHandler( Handler )
   
   parser.parse("movies.xml")</code></pre> 
<h3></h3> 
<h2 style="background-color:transparent;">使用xml.dom解析xml</h2> 
<p><code>xml.dom</code> 是 Python 标准库中的一个模块，它提供了一个 DOM（文档对象模型）接口来处理 XML 数据。DOM 将 XML 文档表示为一个树结构，其中<strong>每个节点</strong>都是 <strong><code>xml.dom.minidom.Node</code> 类的实例</strong>。使用 <code>xml.dom</code> 模块，你可以方便地访问和操作 XML 文档中的元素和属性。</p> 
<p>以下是使用 <code>xml.dom.minidom</code> 解析 XML 的基本步骤：</p> 
<ol><li>导入 <code>xml.dom.minidom</code> 模块。</li><li>使用 <code>parse()</code> 方法解析 XML 文件或字符串。</li><li>通过返回的 <code>Document</code> 对象访问和操作 XML 数据。</li></ol> 
<pre><code class="hljs">from xml.dom import minidom

# 解析 XML 文件
def parse_xml_file(file_path):
    doc = minidom.parse(file_path)
    return doc

# 解析 XML 字符串
def parse_xml_string(xml_string):
    doc = minidom.fromstring(xml_string)
    return doc

# 假设我们有一个名为 'example.xml' 的 XML 文件
xml_file_path = 'example.xml'

# 解析文件并获取 Document 对象
doc = parse_xml_file(xml_file_path)

# 访问并打印文档的根元素
root = doc.documentElement
print(f"Root Element: {root.tagName}")

# 遍历根元素的子元素
for child in root.childNodes:
    print(f"Child Element: {child.tagName}, Content: {child.textContent}")</code></pre> 
<p>在这个示例中，首先定义了两个函数，<code>parse_xml_file</code> 和 <code>parse_xml_string</code>，分别用于解析 XML 文件和字符串。然后使用 <code>minidom.parse()</code> 方法解析了一个名为 <code>example.xml</code> 的文件，并获取了 <code>Document</code> 对象。通过这个对象，可以访问 XML 文档的根元素，并遍历它的子元素。</p> 
<p></p> 
<h3><code>documentElement</code> 属性</h3> 
<p>在 XML 文档对象模型（DOM）中，<code>documentElement</code> 属性是一个<strong> <code>Document</code> 对象的属性</strong>，它<strong>返回文档的根元素</strong>。在 XML 文档中，根元素是包含所有其他元素的最外层元素。通过 <code>documentElement</code> 属性，你可以快速访问 XML 文档的顶级元素，并从那里开始遍历或操作整个文档。</p> 
<p>练习</p> 
<pre><code class="hljs">#!/usr/bin/python3

from xml.dom.minidom import parse
import xml.dom.minidom

# 使用minidom解析器打开 XML 文档
DOMTree = xml.dom.minidom.parse("movies.xml")
collection = DOMTree.documentElement
if collection.hasAttribute("shelf"):
   print ("Root element : %s" % collection.getAttribute("shelf"))

# 在集合中获取所有电影
movies = collection.getElementsByTagName("movie")

# 打印每部电影的详细信息
for movie in movies:
   print ("*****Movie*****")
   if movie.hasAttribute("title"):
      print ("Title: %s" % movie.getAttribute("title"))

   type = movie.getElementsByTagName('type')[0]
   print ("Type: %s" % type.childNodes[0].data)
   format = movie.getElementsByTagName('format')[0]
   print ("Format: %s" % format.childNodes[0].data)
   rating = movie.getElementsByTagName('rating')[0]
   print ("Rating: %s" % rating.childNodes[0].data)
   description = movie.getElementsByTagName('description')[0]
   print ("Description: %s" % description.childNodes[0].data)</code></pre> 
<h3><code>hasAttribute()</code></h3> 
<p><code>hasAttribute()</code> 方法是 DOM（文档对象模型）中 <code>Node</code> 接口的一部分，它用于检查一个元素是否具有指定的属性。这个方法在 <code>Element</code> 类中被实现，因为只有元素节点（<code>Element</code> 类的实例）可以拥有属性。</p> 
<p>当你调用一个 <code>Element</code> 对象的 <code>hasAttribute()</code> 方法时，你需要传递一个字符串参数，该参数是你要检查的属性名。如果该元素具有该属性，<code>hasAttribute()</code> 方法返回 <code>True</code>；如果没有，返回 <code>False</code>。</p> 
<h3><code>getAttribute（）</code></h3> 
<p><code>getAttribute</code> 方法是 DOM（文档对象模型）中 <code>Element</code> 接口的一部分，它用于<strong>获取指定属性的值</strong>。当你想要从一个元素节点中检索属性值时，可以使用这个方法。如果指定的属性<strong>存在</strong>于元素上，<code>getAttribute</code> 方法将<strong>返回该属性的值</strong>；如果属性不存在，则返回一个空字符串。</p> 
<p>这个方法在 <code>Element</code> 类中被实现，因此只有元素节点（<code>Element</code> 类的实例）可以使用它。<code>getAttribute</code> 方法接受一个参数，即你要检索的属性名。</p> 
<h3><code>getElementsByTagName()</code></h3> 
<p><code>getElementsByTagName()</code> 方法是 DOM（文档对象模型）中 <code>Node</code> 接口的一部分，它<strong>用于从当前节点（或文档）中检索所有后代节点</strong>，这些后代节点的<strong>标签名</strong>与提供的<strong>参数匹配</strong>。这个方法返回一个包含所有匹配元素的<strong> <code>NodeList</code> 对象</strong>，你可以遍历这个列表来访问每个元素。</p> 
<p>这个方法在 <code>Element</code> 类中特别有用，因为它允许你轻松地查询文档中的元素。<code>getElementsByTagName()</code> 方法<strong>接受一个参数</strong>，即你要<strong>搜索的标签名</strong>。这个方法对大小写不敏感，这意味着 "TAG" 和 "tag" 被认为是相同的标签名。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61739d5a1951a229026f0b70a92472a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI绘画Stable Diffusion提示词（Prompt）原理详解，扫盲级教程还请收藏！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81a04a2258fc11a09f47129d82324cf7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python实用技巧：输出列表（list）的倒序/逆序的几种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>