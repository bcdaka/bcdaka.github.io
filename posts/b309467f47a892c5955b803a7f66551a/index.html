<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA 使用RSA算法进行数字签名验证-附完整代码 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b309467f47a892c5955b803a7f66551a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JAVA 使用RSA算法进行数字签名验证-附完整代码">
  <meta property="og:description" content="前言： 公司项目是有做资金管理相关的，涉及到充值，提现，转账等关键性的功能，需要保证数据传输的安全性，所以使用了较为简单的RSA进行生成秘钥且每个接口都需要做验签。
简介： RSA是一种非对称加密算法，它是由Rivest-Shamir-Adleman三位密码学家于1978年提出的。
RSA算法的加密规则如下：
钥匙生成：RSA算法使用两个密钥，一个是公钥（public key），用于加密数据，另一个是私钥（private key），用于解密数据。首先，密钥生成者生成一对公钥和私钥，其中公钥可以公开给任何人使用，而私钥必须保密。
加密过程：发送方使用接收方的公钥对数据进行加密。发送方将数据按照一定的规则进行转换，并使用公钥进行加密操作。加密后的数据将无法直接被解密，只能使用私钥才能将其解密。
解密过程：接收方使用自己的私钥对加密后的数据进行解密。接收方使用私钥对加密后的数据进行解密操作，从而得到原始的明文数据。
RSA算法的安全性基于两个数学难题：
质因数分解问题：将一个大的合数（通常是两个大素数的乘积）分解成质数的乘积。这个问题在目前的计算能力下非常困难。
数论中的指数问题：计算一个大数的指数函数的反函数。这个问题同样在目前的计算能力下非常困难。
通过利用这两个数学难题，RSA算法能够保证数据的加密和解密过程的安全性，确保只有持有私钥的人才能够解密数据。
本次案例用于签名验证，使用私钥用于数字签名，公钥用于验证签名的有效性
测试代码：
public static void main(String[] args) { Entity entity = new Entity(); // 使用RSA算法生成 公钥与私钥, 生成的公私钥 是一一对应的。 createRSAKey(entity); String body = &#34;123456&#34;; String body2 = &#34;77897&#34;; // 将入参数据以及私钥进行数字加签 String sign = sign(body, entity.getPrivateKey()); // 根据入参数据以及公钥进行验证签名，若入参数据body被修改或者秘钥不正确都会导致验签失败；例如加签使用body，验签使用body2则导致验签失败 boolean verifyFlag = verify(body,entity.getPublicKey(), sign); if (verifyFlag) { logger.info(&#34;验签成功&#34;); } else { logger.info(&#34;验签失败&#34;); } } 1. 根据RSA生成一对秘钥 构建保存秘钥的实体类Entity
@Data @Builder @AllArgsConstructor @NoArgsConstructor public class Entity { /** * 公钥 **/ private String publicKey; /** * 私钥 **/ private String privateKey; } 根据RSA算法生成秘钥">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-21T17:24:51+08:00">
    <meta property="article:modified_time" content="2023-08-21T17:24:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA 使用RSA算法进行数字签名验证-附完整代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言：</h4> 
<p>        公司项目是有做资金管理相关的，涉及到充值，提现，转账等关键性的功能，需要保证数据传输的安全性，所以使用了较为简单的RSA进行生成秘钥且每个接口都需要做验签。</p> 
<h4>简介：</h4> 
<p>RSA是一种非对称加密算法，它是由Rivest-Shamir-Adleman三位密码学家于1978年提出的。</p> 
<p>RSA算法的加密规则如下：</p> 
<ol><li> <p>钥匙生成：RSA算法使用两个密钥，一个是公钥（public key），用于加密数据，另一个是私钥（private key），用于解密数据。首先，密钥生成者生成一对公钥和私钥，其中公钥可以公开给任何人使用，而私钥必须保密。</p> </li><li> <p>加密过程：发送方使用接收方的公钥对数据进行加密。发送方将数据按照一定的规则进行转换，并使用公钥进行加密操作。加密后的数据将无法直接被解密，只能使用私钥才能将其解密。</p> </li><li> <p>解密过程：接收方使用自己的私钥对加密后的数据进行解密。接收方使用私钥对加密后的数据进行解密操作，从而得到原始的明文数据。</p> </li></ol> 
<p>RSA算法的安全性基于两个数学难题：</p> 
<ol><li> <p>质因数分解问题：将一个大的合数（通常是两个大素数的乘积）分解成质数的乘积。这个问题在目前的计算能力下非常困难。</p> </li><li> <p>数论中的指数问题：计算一个大数的指数函数的反函数。这个问题同样在目前的计算能力下非常困难。</p> </li></ol> 
<p>通过利用这两个数学难题，RSA算法能够保证数据的加密和解密过程的安全性，确保只有持有私钥的人才能够解密数据。</p> 
<p><strong>本次案例用于签名验证，使用私钥用于数字签名，公钥用于验证签名的有效性</strong></p> 
<p>测试代码：</p> 
<pre><code class="language-java">  public static void main(String[] args) {
    Entity entity = new Entity();
    // 使用RSA算法生成 公钥与私钥, 生成的公私钥 是一一对应的。
    createRSAKey(entity);
    String body = "123456";
    String body2 = "77897";
    // 将入参数据以及私钥进行数字加签
    String sign = sign(body, entity.getPrivateKey());
    // 根据入参数据以及公钥进行验证签名，若入参数据body被修改或者秘钥不正确都会导致验签失败；例如加签使用body，验签使用body2则导致验签失败
    boolean verifyFlag = verify(body,entity.getPublicKey(), sign);
    if (verifyFlag) {
      logger.info("验签成功");
    } else {
      logger.info("验签失败");
    }
  }</code></pre> 
<p><img alt="" height="129" src="https://images2.imgbox.com/69/ca/xnBfrrsy_o.png" width="1144"></p> 
<p></p> 
<h4>1. 根据RSA生成一对秘钥</h4> 
<p>构建保存秘钥的实体类Entity</p> 
<pre><code class="language-java">@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Entity {

  /**
   * 公钥
   **/
  private String publicKey;
  /**
   * 私钥
   **/
  private String privateKey;

}</code></pre> 
<p>根据RSA算法生成秘钥</p> 
<pre><code class="language-java">  /**
   * 生成对应的 与我通信的公钥和私钥
   * @return
   */
  public static void createRSAKey(Entity entity) {
    try {
      // 创建KeyPairGenerator 指定算法为RSA，用于生成对应的公钥和私钥
      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
      // 指定字节长度
      keyPairGenerator.initialize(1024);

      // 秘钥生成器
      KeyPair keyPair = keyPairGenerator.generateKeyPair();

      // 公钥
      RSAPublicKey publicKey = (RSAPublicKey)keyPair.getPublic();
      // 进行Base64编码存入
      String clientPublicKey = Base64.encodeBase64String(publicKey.getEncoded());
      logger.info("生成的clientPublicKey是: {}", clientPublicKey);
      entity.setPublicKey(clientPublicKey);

      // 私钥
      RSAPrivateKey privateKey = (RSAPrivateKey)keyPair.getPrivate();
      // 进行Base64编码存入
      String clientPrivateKey = Base64.encodeBase64String(privateKey.getEncoded());
      logger.info("生成的clientPrivateKey是: {}", clientPrivateKey);
      entity.setPrivateKey(clientPrivateKey);
    } catch (Exception e) {
      logger.error("生成秘钥失败");
      e.printStackTrace();
    }
  }</code></pre> 
<h4>2. 生成数字签名</h4> 
<pre><code class="language-java">  /**
   * 利用私钥信息生成数字签名
   * @param data 入参数据body
   * @param privateKey 私钥
   * @return
   */
  public static String sign(String data, String privateKey) {
    try {
      // 入参数据body字节数组
      byte[] dataBytes = data.getBytes();
      // 获取私钥秘钥字节数组
      byte[] keyBytes = Base64.decodeBase64(privateKey);
      // 使用给定的编码密钥创建一个新的PKCS8EncodedKeySpec。
      // PKCS8EncodedKeySpec 是 PKCS#8标准作为密钥规范管理的编码格式
      PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
      // 实例化KeyFactory,指定为加密算法 为 RSA
      KeyFactory keyFactory = KeyFactory.getInstance("RSA");
      // 获得PrivateKey对象
      PrivateKey privateKey1 = keyFactory.generatePrivate(keySpec);
      // 用私钥对信息生成数字签名，指定签名算法为 MD5withRSA
      Signature signature = Signature.getInstance("MD5withRSA");
      // 初始化签名
      signature.initSign(privateKey1);
      // 数据body带入
      signature.update(dataBytes);
      // 对签名进行Base64编码
      return Base64.encodeBase64String(signature.sign());
    } catch (Exception e) {
      e.printStackTrace();
    }
    return null;
  }</code></pre> 
<h4>3. 校验数字签名</h4> 
<pre><code class="language-java">  /**
   * 利用公钥校验数字签名
   * @param data 入参数据body
   * @param publicKey 公钥
   * @param sign 签名
   * @return
   */
  public static boolean verify(String data, String publicKey, String sign) {
    try {
      // 入参数据body字节数组
      byte[] dataBytes = data.getBytes("UTF-8");
      // 获取公钥秘钥字节数组
      byte[] keyBytes = Base64.decodeBase64(publicKey);
      // 使用给定的编码密钥创建一个新的X509EncodedKeySpec
      // X509EncodedKeySpec是基于X.509证书提前的公钥，一种java秘钥规范
      X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(keyBytes);
      // 实例化KeyFactory,指定为加密算法 为 RSA
      KeyFactory keyFactory = KeyFactory.getInstance("RSA");
      // 获取publicKey对象
      PublicKey publicKey1 = keyFactory.generatePublic(x509EncodedKeySpec);
      // 用私钥对信息生成数字签名，指定签名算法为 MD5withRSA
      Signature signature = Signature.getInstance("MD5withRSA");
      // 带入公钥进行验证
      signature.initVerify(publicKey1);
      // 数据body带入
      signature.update(dataBytes);
      // 验证签名
      return signature.verify(Base64.decodeBase64(sign));
    } catch (Exception e) {
      e.printStackTrace();
      return false;
    }
  }</code></pre> 
<h4>附完整代码：</h4> 
<pre><code class="language-java">package com.example.demo.rsaSecret;

import org.apache.commons.codec.binary.Base64;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

/**
 * 功能说明: RSA加密解密工具类
 */
public class RSAUtil {

  private static final Logger logger = LoggerFactory.getLogger(RSAUtil.class);

  public static void main(String[] args) {
    Entity entity = new Entity();
    // 使用RSA算法生成 公钥与私钥, 生成的公私钥 是一一对应的。
    createRSAKey(entity);
    String body = "123456";
    String body2 = "77897";
    // 将入参数据以及私钥进行数字加签
    String sign = sign(body, entity.getPrivateKey());
    // 根据入参数据以及公钥进行验证签名，若入参数据body被修改或者秘钥不正确都会导致验签失败；例如加签使用body，验签使用body2则导致验签失败
    boolean verifyFlag = verify(body,entity.getPublicKey(), sign);
    if (verifyFlag) {
      logger.info("验签成功");
    } else {
      logger.info("验签失败");
    }
  }

  /**
   * 生成对应的 与我通信的公钥和私钥
   * @return
   */
  public static void createRSAKey(Entity entity) {
    try {
      // 创建KeyPairGenerator 指定算法为RSA，用于生成对应的公钥和私钥
      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
      // 指定字节长度
      keyPairGenerator.initialize(1024);

      // 秘钥生成器
      KeyPair keyPair = keyPairGenerator.generateKeyPair();

      // 公钥
      RSAPublicKey publicKey = (RSAPublicKey)keyPair.getPublic();
      // 进行Base64编码存入
      String clientPublicKey = Base64.encodeBase64String(publicKey.getEncoded());
      logger.info("生成的clientPublicKey是: {}", clientPublicKey);
      entity.setPublicKey(clientPublicKey);

      // 私钥
      RSAPrivateKey privateKey = (RSAPrivateKey)keyPair.getPrivate();
      // 进行Base64编码存入
      String clientPrivateKey = Base64.encodeBase64String(privateKey.getEncoded());
      logger.info("生成的clientPrivateKey是: {}", clientPrivateKey);
      entity.setPrivateKey(clientPrivateKey);
    } catch (Exception e) {
      logger.error("生成秘钥失败");
      e.printStackTrace();
    }
  }


  /**
   * 利用私钥信息生成数字签名
   * @param data 入参数据body
   * @param privateKey 私钥
   * @return
   */
  public static String sign(String data, String privateKey) {
    try {
      // 入参数据body字节数组
      byte[] dataBytes = data.getBytes();
      // 获取私钥秘钥字节数组
      byte[] keyBytes = Base64.decodeBase64(privateKey);
      // 使用给定的编码密钥创建一个新的PKCS8EncodedKeySpec。
      // PKCS8EncodedKeySpec 是 PKCS#8标准作为密钥规范管理的编码格式
      PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
      // 实例化KeyFactory,指定为加密算法 为 RSA
      KeyFactory keyFactory = KeyFactory.getInstance("RSA");
      // 获得PrivateKey对象
      PrivateKey privateKey1 = keyFactory.generatePrivate(keySpec);
      // 用私钥对信息生成数字签名，指定签名算法为 MD5withRSA
      Signature signature = Signature.getInstance("MD5withRSA");
      // 初始化签名
      signature.initSign(privateKey1);
      // 数据body带入
      signature.update(dataBytes);
      // 对签名进行Base64编码
      return Base64.encodeBase64String(signature.sign());
    } catch (Exception e) {
      e.printStackTrace();
    }
    return null;
  }

  /**
   * 利用公钥校验数字签名
   * @param data 入参数据body
   * @param publicKey 公钥
   * @param sign 签名
   * @return
   */
  public static boolean verify(String data, String publicKey, String sign) {
    try {
      // 入参数据body字节数组
      byte[] dataBytes = data.getBytes("UTF-8");
      // 获取公钥秘钥字节数组
      byte[] keyBytes = Base64.decodeBase64(publicKey);
      // 使用给定的编码密钥创建一个新的X509EncodedKeySpec
      // X509EncodedKeySpec是基于X.509证书提前的公钥，一种java秘钥规范
      X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(keyBytes);
      // 实例化KeyFactory,指定为加密算法 为 RSA
      KeyFactory keyFactory = KeyFactory.getInstance("RSA");
      // 获取publicKey对象
      PublicKey publicKey1 = keyFactory.generatePublic(x509EncodedKeySpec);
      // 用私钥对信息生成数字签名，指定签名算法为 MD5withRSA
      Signature signature = Signature.getInstance("MD5withRSA");
      // 带入公钥进行验证
      signature.initVerify(publicKey1);
      // 数据body带入
      signature.update(dataBytes);
      // 验证签名
      return signature.verify(Base64.decodeBase64(sign));
    } catch (Exception e) {
      e.printStackTrace();
      return false;
    }
  }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f30293d5c33a3185d3ae6b6c5b0a7df9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【前端vue升级】vue2&#43;js&#43;elementUI升级为vue3&#43;ts&#43;elementUI plus</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f78848f928a671f381108844fb7c26c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（三）Linux中卸载docker（非常详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>