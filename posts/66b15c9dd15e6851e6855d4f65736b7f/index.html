<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JUC 包中的 Atomic 原子类总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/66b15c9dd15e6851e6855d4f65736b7f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JUC 包中的 Atomic 原子类总结">
  <meta property="og:description" content="人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
🌈个人主页：人不走空 💖系列专栏：算法专题
⏰诗词歌赋：斯是陋室，惟吾德馨
Atomic 原子类介绍
基本类型原子类
数组类型原子类
引用类型原子类
对象的属性修改类型原子类
作者其他作品：
JavaGuide官方网站：javaguide.cn
Atomic 原子类介绍 Atomic 翻译成中文是“原子”的意思。在化学上，原子是构成物质的最小单位，在化学反应中不可分割。在编程中，Atomic 指的是一个操作具有原子性，即该操作不可分割、不可中断。即使在多个线程同时执行时，该操作要么全部执行完成，要么不执行，不会被其他线程看到部分完成的状态。
原子类简单来说就是具有原子性操作特征的类。
java.util.concurrent.atomic 包中的 Atomic 原子类提供了一种线程安全的方式来操作单个变量。
Atomic 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 synchronized 块或 ReentrantLock）。
这篇文章我们只介绍 Atomic 原子类的概念，具体实现原理可以阅读笔者写的这篇文章：什么是乐观锁和悲观锁？Java 中 CAS 是如何实现的？。
JUC原子类概览
根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：
1、基本类型
使用原子的方式更新基本类型
AtomicInteger：整型原子类
AtomicLong：长整型原子类
AtomicBoolean：布尔型原子类
2、数组类型
使用原子的方式更新数组里的某个元素
AtomicIntegerArray：整型数组原子类
AtomicLongArray：长整型数组原子类
AtomicReferenceArray：引用类型数组原子类
3、引用类型
AtomicReference：引用类型原子类
AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。
🐛 修正（参见：issue#626：https://github.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T21:51:53+08:00">
    <meta property="article:modified_time" content="2024-07-17T21:51:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JUC 包中的 Atomic 原子类总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<div style="text-align:center;"> 
 <figure class="image"> 
  <img alt="" src="https://images2.imgbox.com/f9/f5/csXcZ8wm_o.png"> 
  <figcaption> 
   <strong>人不走空</strong> 
  </figcaption> 
 </figure> 
</div> 
<p></p> 
<p>                                                                      </p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%F0%9F%8C%88%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%EF%BC%9A%E4%BA%BA%E4%B8%8D%E8%B5%B0%E7%A9%BA%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" style="text-align:center;">      🌈<strong>个人主页：<strong><a href="https://blog.csdn.net/double222222?type=blog" title="人不走空">人不走空</a></strong></strong><strong>      </strong></h3> 
<h3 id="%F0%9F%92%96%E7%B3%BB%E5%88%97%E4%B8%93%E6%A0%8F%EF%BC%9A%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98" style="text-align:center;"><strong>💖系列专栏：<strong><a href="https://blog.csdn.net/double222222/category_12487653.html?spm=1001.2014.3001.5482" title="算法专题">算法专题</a></strong></strong></h3> 
<h3 id="%E2%8F%B0%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B%EF%BC%9A%E6%96%AF%E6%98%AF%E9%99%8B%E5%AE%A4%EF%BC%8C%E6%83%9F%E5%90%BE%E5%BE%B7%E9%A6%A8" style="text-align:center;"><strong>⏰诗词歌赋：</strong>斯是陋室，惟吾德馨</h3> 
<p></p> 
<p><img alt="" height="92" src="https://images2.imgbox.com/04/bf/AJXfuFmp_o.gif" width="733"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%F0%9F%8C%88%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%EF%BC%9A%E4%BA%BA%E4%B8%8D%E8%B5%B0%E7%A9%BA%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%F0%9F%8C%88%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%EF%BC%9A%E4%BA%BA%E4%B8%8D%E8%B5%B0%E7%A9%BA%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">      🌈个人主页：人不走空      </a></p> 
<p id="%F0%9F%92%96%E7%B3%BB%E5%88%97%E4%B8%93%E6%A0%8F%EF%BC%9A%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-toc" style="margin-left:40px;"><a href="#%F0%9F%92%96%E7%B3%BB%E5%88%97%E4%B8%93%E6%A0%8F%EF%BC%9A%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98" rel="nofollow">💖系列专栏：算法专题</a></p> 
<p id="%E2%8F%B0%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B%EF%BC%9A%E6%96%AF%E6%98%AF%E9%99%8B%E5%AE%A4%EF%BC%8C%E6%83%9F%E5%90%BE%E5%BE%B7%E9%A6%A8-toc" style="margin-left:40px;"><a href="#%E2%8F%B0%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B%EF%BC%9A%E6%96%AF%E6%98%AF%E9%99%8B%E5%AE%A4%EF%BC%8C%E6%83%9F%E5%90%BE%E5%BE%B7%E9%A6%A8" rel="nofollow">⏰诗词歌赋：斯是陋室，惟吾德馨</a></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="Atomic%20%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#Atomic%20%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%BB%8B%E7%BB%8D" rel="nofollow">Atomic 原子类介绍</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB" rel="nofollow">基本类型原子类</a></p> 
<p id="%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB" rel="nofollow">数组类型原子类</a></p> 
<p id="%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB" rel="nofollow">引用类型原子类</a></p> 
<p id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB" rel="nofollow">对象的属性修改类型原子类</a></p> 
<p id="%E4%BD%9C%E8%80%85%E5%85%B6%E4%BB%96%E4%BD%9C%E5%93%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BD%9C%E8%80%85%E5%85%B6%E4%BB%96%E4%BD%9C%E5%93%81%EF%BC%9A" rel="nofollow">作者其他作品：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<p></p> 
<p class="img-center"><img alt="图片" height="579" src="https://images2.imgbox.com/38/d9/8cc3KrtZ_o.png" width="1080"></p> 
<p><strong>JavaGuide官方网站</strong>：<strong>javaguide.cn</strong></p> 
<h3></h3> 
<h3 id="Atomic%20%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%BB%8B%E7%BB%8D">Atomic 原子类介绍</h3> 
<p><code>Atomic</code> 翻译成中文是“原子”的意思。在化学上，原子是构成物质的最小单位，在化学反应中不可分割。在编程中，<code>Atomic</code> 指的是一个操作具有原子性，即该操作不可分割、不可中断。即使在多个线程同时执行时，该操作要么全部执行完成，要么不执行，不会被其他线程看到部分完成的状态。</p> 
<p>原子类简单来说就是具有原子性操作特征的类。</p> 
<p><code>java.util.concurrent.atomic</code> 包中的 <code>Atomic</code> 原子类提供了一种线程安全的方式来操作单个变量。</p> 
<p><code>Atomic</code> 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 <code>synchronized</code> 块或 <code>ReentrantLock</code>）。</p> 
<p>这篇文章我们只介绍 Atomic 原子类的概念，具体实现原理可以阅读笔者写的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247544503&amp;idx=1&amp;sn=949c4e8cf2a1d23cf85af413e1ba6498&amp;scene=21#wechat_redirect" rel="nofollow" title="什么是乐观锁和悲观锁？Java 中 CAS 是如何实现的？">什么是乐观锁和悲观锁？Java 中 CAS 是如何实现的？</a>。</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="367" src="https://images2.imgbox.com/25/41/dErXtwR3_o.png" width="317"></p> 
<p>JUC原子类概览</p> 
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：</p> 
<p><strong>1、基本类型</strong></p> 
<p>使用原子的方式更新基本类型</p> 
<ul><li> <p><code>AtomicInteger</code>：整型原子类</p> </li><li> <p><code>AtomicLong</code>：长整型原子类</p> </li><li> <p><code>AtomicBoolean</code>：布尔型原子类</p> </li></ul> 
<p><strong>2、数组类型</strong></p> 
<p>使用原子的方式更新数组里的某个元素</p> 
<ul><li> <p><code>AtomicIntegerArray</code>：整型数组原子类</p> </li><li> <p><code>AtomicLongArray</code>：长整型数组原子类</p> </li><li> <p><code>AtomicReferenceArray</code>：引用类型数组原子类</p> </li></ul> 
<p><strong>3、引用类型</strong></p> 
<ul><li> <p><code>AtomicReference</code>：引用类型原子类</p> </li><li> <p><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p> </li><li> <p><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p> </li></ul> 
<p><strong>🐛 修正（参见：</strong><strong>issue#626：<em>https://github.com/Snailclimb/JavaGuide/issues/626</em></strong><strong>）</strong> : <code>AtomicMarkableReference</code> 不能解决 ABA 问题。</p> 
<p><strong>4、对象的属性修改类型</strong></p> 
<ul><li> <p><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</p> </li><li> <p><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</p> </li><li> <p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</p> </li></ul> 
<h3 id="%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB">基本类型原子类</h3> 
<p>使用原子的方式更新基本类型</p> 
<ul><li> <p><code>AtomicInteger</code>：整型原子类</p> </li><li> <p><code>AtomicLong</code>：长整型原子类</p> </li><li> <p><code>AtomicBoolean</code>：布尔型原子类</p> </li></ul> 
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicInteger</code> 为例子来介绍。</p> 
<p><strong><code>AtomicInteger</code> 类常用方法</strong> ：</p> 
<pre><code>public final int get() //获取当前的值
public final int getAndSet(int newValue)//获取当前的值，并设置新的值
public final int getAndIncrement()//获取当前的值，并自增
public final int getAndDecrement() //获取当前的值，并自减
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
public final void lazySet(int newValue)//最终设置为newValue, lazySet 提供了一种比 set 方法更弱的语义，可能导致其他线程在之后的一小段时间内还是可以读到旧的值，但可能更高效。
</code></pre> 
<p><strong><code>AtomicInteger</code> 类使用示例</strong> :</p> 
<pre><code class="language-java">// 初始化 AtomicInteger 对象，初始值为 0
AtomicInteger atomicInt = new AtomicInteger(0);

// 使用 getAndSet 方法获取当前值，并设置新值为 3
int tempValue = atomicInt.getAndSet(3);
System.out.println("tempValue: " + tempValue + "; atomicInt: " + atomicInt);

// 使用 getAndIncrement 方法获取当前值，并自增 1
tempValue = atomicInt.getAndIncrement();
System.out.println("tempValue: " + tempValue + "; atomicInt: " + atomicInt);

// 使用 getAndAdd 方法获取当前值，并增加指定值 5
tempValue = atomicInt.getAndAdd(5);
System.out.println("tempValue: " + tempValue + "; atomicInt: " + atomicInt);

// 使用 compareAndSet 方法进行原子性条件更新，期望值为 9，更新值为 10
boolean updateSuccess = atomicInt.compareAndSet(9, 10);
System.out.println("Update Success: " + updateSuccess + "; atomicInt: " + atomicInt);

// 获取当前值
int currentValue = atomicInt.get();
System.out.println("Current value: " + currentValue);

// 使用 lazySet 方法设置新值为 15
atomicInt.lazySet(15);
System.out.println("After lazySet, atomicInt: " + atomicInt);
</code></pre> 
<p>输出：</p> 
<pre><code>tempValue: 0; atomicInt: 3
tempValue: 3; atomicInt: 4
tempValue: 4; atomicInt: 9
Update Success: true; atomicInt: 10
Current value: 10
After lazySet, atomicInt: 15
</code></pre> 
<h3 id="%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB">数组类型原子类</h3> 
<p>使用原子的方式更新数组里的某个元素</p> 
<ul><li> <p><code>AtomicIntegerArray</code>：整形数组原子类</p> </li><li> <p><code>AtomicLongArray</code>：长整形数组原子类</p> </li><li> <p><code>AtomicReferenceArray</code>：引用类型数组原子类</p> </li></ul> 
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerArray</code> 为例子来介绍。</p> 
<p><strong><code>AtomicIntegerArray</code> 类常用方法</strong>：</p> 
<pre><code>public final int get(int i) //获取 index=i 位置元素的值
public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue
public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增
public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减
public final int getAndAdd(int i, int delta) //获取 index=i 位置元素的值，并加上预期的值
boolean compareAndSet(int i, int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）
public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
</code></pre> 
<p><strong><code>AtomicIntegerArray</code> 类使用示例</strong> :</p> 
<pre><code class="language-java">int[] nums = {1, 2, 3, 4, 5, 6};
// 创建 AtomicIntegerArray
AtomicIntegerArray atomicArray = new AtomicIntegerArray(nums);

// 打印 AtomicIntegerArray 中的初始值
System.out.println("Initial values in AtomicIntegerArray:");
for (int j = 0; j &lt; nums.length; j++) {
    System.out.print("Index " + j + ": " + atomicArray.get(j) + " ");
}

// 使用 getAndSet 方法将索引 0 处的值设置为 2，并返回旧值
int tempValue = atomicArray.getAndSet(0, 2);
System.out.println("\nAfter getAndSet(0, 2):");
System.out.println("Returned value: " + tempValue);
for (int j = 0; j &lt; atomicArray.length(); j++) {
    System.out.print("Index " + j + ": " + atomicArray.get(j) + " ");
}

// 使用 getAndIncrement 方法将索引 0 处的值加 1，并返回旧值
tempValue = atomicArray.getAndIncrement(0);
System.out.println("\nAfter getAndIncrement(0):");
System.out.println("Returned value: " + tempValue);
for (int j = 0; j &lt; atomicArray.length(); j++) {
    System.out.print("Index " + j + ": " + atomicArray.get(j) + " ");
}

// 使用 getAndAdd 方法将索引 0 处的值增加 5，并返回旧值
tempValue = atomicArray.getAndAdd(0, 5);
System.out.println("\nAfter getAndAdd(0, 5):");
System.out.println("Returned value: " + tempValue);
for (int j = 0; j &lt; atomicArray.length(); j++) {
    System.out.print("Index " + j + ": " + atomicArray.get(j) + " ");
}
</code></pre> 
<p>输出：</p> 
<pre><code>Initial values in AtomicIntegerArray:
Index 0: 1 Index 1: 2 Index 2: 3 Index 3: 4 Index 4: 5 Index 5: 6 
After getAndSet(0, 2):
Returned value: 1
Index 0: 2 Index 1: 2 Index 2: 3 Index 3: 4 Index 4: 5 Index 5: 6 
After getAndIncrement(0):
Returned value: 2
Index 0: 3 Index 1: 2 Index 2: 3 Index 3: 4 Index 4: 5 Index 5: 6 
After getAndAdd(0, 5):
Returned value: 3
Index 0: 8 Index 1: 2 Index 2: 3 Index 3: 4 Index 4: 5 Index 5: 6 
</code></pre> 
<h3 id="%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB">引用类型原子类</h3> 
<p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p> 
<ul><li> <p><code>AtomicReference</code>：引用类型原子类</p> </li><li> <p><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p> </li><li> <p><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p> </li></ul> 
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicReference</code> 为例子来介绍。</p> 
<p><strong><code>AtomicReference</code> 类使用示例</strong> :</p> 
<pre><code class="language-java">// Person 类
class Person {
    private String name;
    private int age;
    //省略getter/setter和toString
}


// 创建 AtomicReference 对象并设置初始值
AtomicReference&lt;Person&gt; ar = new AtomicReference&lt;&gt;(new Person("SnailClimb", 22));

// 打印初始值
System.out.println("Initial Person: " + ar.get().toString());

// 更新值
Person updatePerson = new Person("Daisy", 20);
ar.compareAndSet(ar.get(), updatePerson);

// 打印更新后的值
System.out.println("Updated Person: " + ar.get().toString());

// 尝试再次更新
Person anotherUpdatePerson = new Person("John", 30);
boolean isUpdated = ar.compareAndSet(updatePerson, anotherUpdatePerson);

// 打印是否更新成功及最终值
System.out.println("Second Update Success: " + isUpdated);
System.out.println("Final Person: " + ar.get().toString());
</code></pre> 
<p>输出：</p> 
<pre><code>Initial Person: Person{name='SnailClimb', age=22}
Updated Person: Person{name='Daisy', age=20}
Second Update Success: true
Final Person: Person{name='John', age=30}
</code></pre> 
<p><strong><code>AtomicStampedReference</code> 类使用示例</strong> :</p> 
<pre><code class="language-java">// 创建一个 AtomicStampedReference 对象，初始值为 "SnailClimb"，初始版本号为 1
AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference&lt;&gt;("SnailClimb", 1);

// 打印初始值和版本号
int[] initialStamp = new int[1];
String initialRef = asr.get(initialStamp);
System.out.println("Initial Reference: " + initialRef + ", Initial Stamp: " + initialStamp[0]);

// 更新值和版本号
int oldStamp = initialStamp[0];
String oldRef = initialRef;
String newRef = "Daisy";
int newStamp = oldStamp + 1;

boolean isUpdated = asr.compareAndSet(oldRef, newRef, oldStamp, newStamp);
System.out.println("Update Success: " + isUpdated);

// 打印更新后的值和版本号
int[] updatedStamp = new int[1];
String updatedRef = asr.get(updatedStamp);
System.out.println("Updated Reference: " + updatedRef + ", Updated Stamp: " + updatedStamp[0]);

// 尝试用错误的版本号更新
boolean isUpdatedWithWrongStamp = asr.compareAndSet(newRef, "John", oldStamp, newStamp + 1);
System.out.println("Update with Wrong Stamp Success: " + isUpdatedWithWrongStamp);

// 打印最终的值和版本号
int[] finalStamp = new int[1];
String finalRef = asr.get(finalStamp);
System.out.println("Final Reference: " + finalRef + ", Final Stamp: " + finalStamp[0]);
</code></pre> 
<p>输出结果如下：</p> 
<pre><code>Initial Reference: SnailClimb, Initial Stamp: 1
Update Success: true
Updated Reference: Daisy, Updated Stamp: 2
Update with Wrong Stamp Success: false
Final Reference: Daisy, Final Stamp: 2
</code></pre> 
<p><strong><code>AtomicMarkableReference</code> 类使用示例</strong> :</p> 
<pre><code class="language-java">// 创建一个 AtomicMarkableReference 对象，初始值为 "SnailClimb"，初始标记为 false
AtomicMarkableReference&lt;String&gt; amr = new AtomicMarkableReference&lt;&gt;("SnailClimb", false);

// 打印初始值和标记
boolean[] initialMark = new boolean[1];
String initialRef = amr.get(initialMark);
System.out.println("Initial Reference: " + initialRef + ", Initial Mark: " + initialMark[0]);

// 更新值和标记
String oldRef = initialRef;
String newRef = "Daisy";
boolean oldMark = initialMark[0];
boolean newMark = true;

boolean isUpdated = amr.compareAndSet(oldRef, newRef, oldMark, newMark);
System.out.println("Update Success: " + isUpdated);

// 打印更新后的值和标记
boolean[] updatedMark = new boolean[1];
String updatedRef = amr.get(updatedMark);
System.out.println("Updated Reference: " + updatedRef + ", Updated Mark: " + updatedMark[0]);

// 尝试用错误的标记更新
boolean isUpdatedWithWrongMark = amr.compareAndSet(newRef, "John", oldMark, !newMark);
System.out.println("Update with Wrong Mark Success: " + isUpdatedWithWrongMark);

// 打印最终的值和标记
boolean[] finalMark = new boolean[1];
String finalRef = amr.get(finalMark);
System.out.println("Final Reference: " + finalRef + ", Final Mark: " + finalMark[0]);
</code></pre> 
<p>输出结果如下：</p> 
<pre><code>Initial Reference: SnailClimb, Initial Mark: false
Update Success: true
Updated Reference: Daisy, Updated Mark: true
Update with Wrong Mark Success: false
Final Reference: Daisy, Final Mark: true
</code></pre> 
<h3 id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB">对象的属性修改类型原子类</h3> 
<p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p> 
<ul><li> <p><code>AtomicIntegerFieldUpdater</code>:原子更新整形字段的更新器</p> </li><li> <p><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</p> </li><li> <p><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段的更新器</p> </li></ul> 
<p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p> 
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p> 
<p><strong><code>AtomicIntegerFieldUpdater</code> 类使用示例</strong> :</p> 
<pre><code class="language-java">// Person 类
class Person {
    private String name;
    // 要使用 AtomicIntegerFieldUpdater，字段必须是 public volatile
    private volatile int age;
    //省略getter/setter和toString
}

// 创建 AtomicIntegerFieldUpdater 对象
AtomicIntegerFieldUpdater&lt;Person&gt; ageUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class, "age");

// 创建 Person 对象
Person person = new Person("SnailClimb", 22);

// 打印初始值
System.out.println("Initial Person: " + person);

// 更新 age 字段
ageUpdater.incrementAndGet(person); // 自增
System.out.println("After Increment: " + person);

ageUpdater.addAndGet(person, 5); // 增加 5
System.out.println("After Adding 5: " + person);

ageUpdater.compareAndSet(person, 28, 30); // 如果当前值是 28，则设置为 30
System.out.println("After Compare and Set (28 to 30): " + person);

// 尝试使用错误的比较值进行更新
boolean isUpdated = ageUpdater.compareAndSet(person, 28, 35); // 这次应该失败
System.out.println("Compare and Set (28 to 35) Success: " + isUpdated);
System.out.println("Final Person: " + person);
</code></pre> 
<p>输出结果：</p> 
<pre><code>Initial Person: Name: SnailClimb, Age: 22
After Increment: Name: SnailClimb, Age: 23
After Adding 5: Name: SnailClimb, Age: 28
After Compare and Set (28 to 30): Name: SnailClimb, Age: 30
Compare and Set (28 to 35) Success: false
Final Person: Name: SnailClimb, Age: 30</code></pre> 
<h2>本文来自于恩师 公众号Guide <a id="js_name">JavaGuide</a></h2> 
<hr> 
<h2 id="%E4%BD%9C%E8%80%85%E5%85%B6%E4%BB%96%E4%BD%9C%E5%93%81%EF%BC%9A">作者其他作品：</h2> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136338757?spm=1001.2014.3001.5502" rel="nofollow" title="【Java】Spring循环依赖：原因与解决方法">【Java】Spring循环依赖：原因与解决方法</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136336417?spm=1001.2014.3001.5502" rel="nofollow" title="OpenAI Sora来了，视频生成领域的GPT-4时代来了">OpenAI Sora来了，视频生成领域的GPT-4时代来了</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136200396?spm=1001.2014.3001.5502" rel="nofollow" title="[Java·算法·简单] LeetCode 14. 最长公共前缀 详细解读">[Java·算法·简单] LeetCode 14. 最长公共前缀 详细解读</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136318553?spm=1001.2014.3001.5502" rel="nofollow" title="【Java】深入理解Java中的static关键字">【Java】深入理解Java中的static关键字</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136292910?spm=1001.2014.3001.5502" rel="nofollow" title="[Java·算法·简单] LeetCode 28. 找出字a符串中第一个匹配项的下标 详细解读">[Java·算法·简单] LeetCode 28. 找出字a符串中第一个匹配项的下标 详细解读</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136256523?spm=1001.2014.3001.5502" rel="nofollow" title="了解 Java 中的 AtomicInteger 类">了解 Java 中的 AtomicInteger 类</a></p> 
<p><a href="https://cyberspace.blog.csdn.net/article/details/136275183?spm=1001.2014.3001.5502" rel="nofollow" title="算法题 — 整数转二进制，查找其中1的数量">算法题 — 整数转二进制，查找其中1的数量</a></p> 
<p><a class="link-info" href="https://cyberspace.blog.csdn.net/article/details/136223146?spm=1001.2014.3001.5502" rel="nofollow" title="深入理解MySQL事务特性：保证数据完整性与一致性">深入理解MySQL事务特性：保证数据完整性与一致性</a></p> 
<p><a class="link-info" href="https://cyberspace.blog.csdn.net/article/details/136102269?spm=1001.2014.3001.5502" rel="nofollow" title="Java企业应用软件系统架构演变史">Java企业应用软件系统架构演变史</a> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ebf2b3fc0db1dff9c76c67843427d3e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jupyter: 交互式计算的革命</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/550f6d951e74c1ef42df24ae6e4b538e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">list模拟实现【C&#43;&#43;】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>