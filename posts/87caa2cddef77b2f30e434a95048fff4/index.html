<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTPS 的加密流程 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/87caa2cddef77b2f30e434a95048fff4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="HTTPS 的加密流程">
  <meta property="og:description" content="HTTPS 本质上就是 HTTP 的基础上增加了一个加密层，抛开加密之后，剩下的部分就和 HTTP 是一样的，在HTTPS中，比HTTP多了一个&#34;S&#34;，这里的S是SSL。HTTPS=HTTP&#43;SSL。
HTTPS引入的背景是臭名昭著的运营商劫持
在当年，法律在互联网相关的东西上面还不是很完善
在使用https，加密的过程中，涉及到了密码学中的几个核心的概念
（1）明文：要传输的真正的意识是啥
（2）密文：加密之后得到的数据
（3）密钥：用来加密和解密的重要道具
这个过程简单来说就是，把明文通过密钥变成密文 ，把密文通过密钥变成明文
对称加密和非对称加密 对称加密：加密和解密，使用同一个密钥就行了，加密解密速度比较快。
非对称加密：密钥是一对(分别称为公钥和私钥)加密解密速度比较慢，安全性更高。可以使用公钥加密，此时就是私钥解密。或者可以使用私钥加密,公钥解密.
HTTP本身是不安全的，为了能够安全，最简单的做法就是使用对称加密来进行操作
这里有一个问题
对称密钥，当有多个客户端的时候，是要有一个密钥还是多个密钥？？所有客户端使用同一个对称密钥，还是每个客户端有一个自己的呢?
（1）对称密钥 如果只有一个密钥，黑客使用自己的客户端，不就知道密钥是啥了嘛~~黑客就可以把密文进行解密了呀~~
所以让每个客户端生成一个自己的密钥，让后告诉服务器就可以了
在这里就又有一个新的问题了，如图所示
在上述过程中，密钥在第一次传输的时候，也可能被黑客获取到，那之后的的加密也就是形同虚设了。
（2）非对称密钥 在这里我们引入非对称密钥，通过非对称密钥，对对称密钥进行加密
引入非对称加密，不是针对后续传输的数据内容展开的，而是只针对对称密钥来进行！！
在上述过程中，客户端持有公钥，服务器持有私钥，通过公钥对对称密钥进行加密，服务器用私钥解密，得到对称密钥。
黑客拿到加密后的对称密钥之后，是无法解密的，使用公钥加密，得拿着对应的私钥来解密，黑客能轻松拿到公钥，但是拿不到私钥
上述过程中看起来很美好，实际上黑客还是有办法获取到原始数据的
（3）中间人攻击 黑客可以自己冒充自己是服务器
在上述过程中，服务器生成一对公钥和私钥（假设是pub和pri），再把公钥发给客户端的途中，黑客获取到，黑客可以自己生成一对公钥和私钥（pub2和pri2）,让后把自己生成的公钥发给客户端，让后客户端基于黑客给的公钥来加密密钥，黑客就可以根据自己的密钥来进行解密，得到其中的密钥，让后用服务器给的公钥来加密，再返还给服务器。
此时黑客面对客户端的时候，扮演服务器的角色，面对服务器的时候，扮演客户端的角色,客户端和服务器, 都不知道 黑客的存在~~
（4）解决中间人攻击 最关键的切入点，就是让客户端能够区分出当前的公钥是不是服务器自己的公钥，是不是被伪造出来的公钥~~
在这里引入第三方公证机构。
公证机构对公钥进行公证，此时客户端看到这个公钥被公证了，就可以认为是合法的了
在上述过程中，服务器上线就会向第三方公正机构申请一个证书，此时服务器就会保存好自己申请道德证书（不是字纸的，而是数字的字符串）。之后返回给客户端
（1）客户端收到证书后，会对证书的合法性进行校验，针对证书中的内容1.发证机构2.证书的有效期3.服务器的公钥4.证书的所有者5.持有者网站的主域名6.数字签名。在上述的6个内容中，只有数字签名是加密的，其他的属性都是明文的。数字签名是前5个内容进行加密得到的，前5个内容计算的校验和为校验和1
（2）针对数字签名进行解密
数字签名是基于公正机构的私钥来加密的，就需要拿着公正机构的公钥来解密，获取公正机构的公钥，不是通过&#34;网络&#34;的方式获取到的！！！通过网络的方式，就可能会得到黑客伪造的公钥，而是操作系统会内置公正机构的公钥！！
公正机构，一共没有多少，你一个操作系统， 就可以在发布的时候，把市面上的公正机构的公钥都打包放到一起。随着安装操作系统，公钥就有了！(系统内置的公钥，一定是正经公钥，不是伪造的！！
（3）客户端对比校验和1和校验和2是否相等
接下来，就可以使用公正机构的公钥 (系统内置)来对数字签名进行解密了，解密之后得到校验和 2，客户端会对比校验和1和校验和2是否相等，相等就说明整个证书，都是没有被篡改过的，此时,证书既然都是有效的，证书中包含的公钥自然就是可信的服务器公钥了。
针对公正机构加密的数字签名，进行解密是很容易的，公正机构的公钥是内置到系统中的,用户可以解密，黑客当然也能解密了
黑客很容易能拿到校验和，虽然能拿到，但是无法篡改，也无法伪造!!!
1)如果黑客修改了证书中的公钥，但是不修改数字签名，客户端校验的时候就会发现，自己算出来的校验和和从数字签名中解密出来的校验和，不一致了！！！客户端就可以判定,证书非法！
2）如果黑客修改了公钥, 并且自己重新计算校验和，重新加密得到数字签名??
黑客不知道公正机构的私钥是啥。黑客只能拿着自己生成的私钥来加密，客户端收到数据之后，肯定是拿着公正机构的公钥来解密，此时就会出现解密失败！！客户端也可以判定,证书非法~~
大家还记得在安装fidder,开启https的时候，会有一个”安装证书“过程，必须要选同意！！
这个过程就是给你的系统里增加一个公证机构，fiddler的公证机构">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T18:11:07+08:00">
    <meta property="article:modified_time" content="2024-05-27T18:11:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTPS 的加密流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>HTTPS 本质上就是 HTTP 的基础上增加了一个加密层，抛开加密之后，剩下的部分就和 HTTP 是一样的，在HTTPS中，比HTTP多了一个"S"，这里的S是SSL。HTTPS=HTTP+SSL。</p> 
<p>HTTPS引入的背景是臭名昭著的运营商劫持</p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/aa/41/Ng5nWNJ0_o.png" width="814"></p> 
<p>在当年，法律在互联网相关的东西上面还不是很完善</p> 
<p>在使用https，加密的过程中，涉及到了密码学中的几个核心的概念</p> 
<p>（1）明文：要传输的真正的意识是啥</p> 
<p>（2）密文：加密之后得到的数据</p> 
<p>（3）密钥：用来加密和解密的重要道具</p> 
<p>这个过程简单来说就是，把明文通过密钥变成密文 ，把密文通过密钥变成明文</p> 
<h3>对称加密和非对称加密</h3> 
<p>对称加密：加密和解密，使用同一个密钥就行了，加密解密速度比较快。</p> 
<p>非对称加密：密钥是一对(分别称为公钥和私钥)加密解密速度比较慢，安全性更高。可以使用公钥加密，此时就是私钥解密。或者可以使用私钥加密,公钥解密.</p> 
<p>HTTP本身是不安全的，为了能够安全，最简单的做法就是使用对称加密来进行操作</p> 
<p><img alt="" height="631" src="https://images2.imgbox.com/3e/21/13VwOEEC_o.png" width="1115"></p> 
<p>这里有一个问题</p> 
<p>对称密钥，当有多个客户端的时候，是要有一个密钥还是多个密钥？？所有客户端使用同一个对称密钥，还是每个客户端有一个自己的呢?</p> 
<h4>（1）对称密钥</h4> 
<p>如果只有一个密钥，黑客使用自己的客户端，不就知道密钥是啥了嘛~~黑客就可以把密文进行解密了呀~~</p> 
<p>所以让每个客户端生成一个自己的密钥，让后告诉服务器就可以了</p> 
<p>在这里就又有一个新的问题了，如图所示</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/06/c2/NMMFHx5w_o.png" width="765"></p> 
<p>在上述过程中，密钥在第一次传输的时候，也可能被黑客获取到，那之后的的加密也就是形同虚设了。</p> 
<h4>（2）非对称密钥</h4> 
<p>在这里我们引入非对称密钥，通过非对称密钥，对对称密钥进行加密</p> 
<p>引入非对称加密，不是针对后续传输的数据内容展开的，而是只针对对称密钥来进行！！</p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/99/9d/ybLWJTyf_o.png" width="807"></p> 
<p>在上述过程中，客户端持有公钥，服务器持有私钥，通过公钥对对称密钥进行加密，服务器用私钥解密，得到对称密钥。</p> 
<p>黑客拿到加密后的对称密钥之后，是无法解密的，使用公钥加密，得拿着对应的私钥来解密，黑客能轻松拿到公钥，但是拿不到私钥</p> 
<p>上述过程中看起来很美好，实际上黑客还是有办法获取到原始数据的</p> 
<h4>（3）中间人攻击</h4> 
<p>黑客可以自己冒充自己是服务器</p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/85/24/C8zAJgHN_o.png" width="1200"></p> 
<p>在上述过程中，服务器生成一对公钥和私钥（假设是pub和pri），再把公钥发给客户端的途中，黑客获取到，黑客可以自己生成一对公钥和私钥（pub2和pri2）,让后把自己生成的公钥发给客户端，让后客户端基于黑客给的公钥来加密密钥，黑客就可以根据自己的密钥来进行解密，得到其中的密钥，让后用服务器给的公钥来加密，再返还给服务器。</p> 
<p><strong>此时黑客面对客户端的时候，扮演服务器的角色，面对服务器的时候，扮演客户端的角色,客户端和服务器, 都不知道 黑客的存在~~</strong></p> 
<h4>（4）解决中间人攻击</h4> 
<p>最关键的切入点，就是让客户端能够区分出当前的公钥是不是服务器自己的公钥，是不是被伪造出来的公钥~~</p> 
<p>在这里引入第三方公证机构。</p> 
<p>公证机构对公钥进行公证，此时客户端看到这个公钥被公证了，就可以认为是合法的了</p> 
<p><img alt="" height="590" src="https://images2.imgbox.com/fa/df/cdxtDF9x_o.png" width="1200"></p> 
<p>在上述过程中，服务器上线就会向第三方公正机构申请一个证书，此时服务器就会保存好自己申请道德证书（不是字纸的，而是数字的字符串）。之后返回给客户端</p> 
<p>（1）客户端收到证书后，会对证书的合法性进行校验，针对证书中的内容1.发证机构2.证书的有效期3.服务器的公钥4.证书的所有者5.持有者网站的主域名6.数字签名。在上述的6个内容中，只有数字签名是<strong>加密的</strong>，其他的属性都是明文的。数字签名是前5个内容进行加密得到的，前5个内容计算的校验和为<strong>校验和1</strong></p> 
<p>（2）针对数字签名进行解密</p> 
<p>数字签名是基于公正机构的私钥来加密的，就需要拿着公正机构的公钥来解密，获取公正机构的公钥，<strong>不是通过"网络"的方式获取到的</strong>！！！通过网络的方式，就可能会得到黑客伪造的公钥，而是<strong>操作系统会内置公正机构的公钥</strong>！！</p> 
<p>公正机构，一共没有多少，你一个操作系统， 就可以在发布的时候，把市面上的公正机构的公钥都打包放到一起。随着安装操作系统，公钥就有了！(系统内置的公钥，一定是正经公钥，不是伪造的！！</p> 
<p>（3）客户端对比校验和1和校验和2是否相等</p> 
<p>接下来，就可以使用公正机构的公钥 (系统内置)来对数字签名进行解密了，解密之后得到校验和 2，客户端会对比校验和1和校验和2是否相等，相等就说明整个证书，都是没有被篡改过的，此时,证书既然都是有效的，证书中包含的公钥自然就是可信的服务器公钥了。</p> 
<p></p> 
<p>针对公正机构加密的数字签名，进行解密是很容易的，公正机构的公钥是内置到系统中的,用户可以解密，黑客当然也能解密了</p> 
<p>黑客很容易能拿到校验和，虽然能拿到，但是无法篡改，也无法伪造!!!</p> 
<p>1)如果黑客修改了证书中的公钥，但是不修改数字签名，客户端校验的时候就会发现，自己算出来的校验和和从数字签名中解密出来的校验和，不一致了！！！客户端就可以判定,证书非法！</p> 
<p>2）如果黑客修改了公钥, 并且自己重新计算校验和，重新加密得到数字签名??</p> 
<p>黑客不知道公正机构的私钥是啥。黑客只能拿着自己生成的私钥来加密，客户端收到数据之后，肯定是拿着公正机构的公钥来解密，此时就会出现解密失败！！客户端也可以判定,证书非法~~</p> 
<p>大家还记得在安装fidder,开启https的时候，会有一个”安装证书“过程，必须要选同意！！</p> 
<p>这个过程就是给你的系统里增加一个公证机构，fiddler的公证机构</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d7c06ba9b572308fd680cc7d2c19658/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">5 个不错的开源 AI 网络爬虫工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fbc0a1cf1a4c9f384da2938bcf9ab28f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">贪心算法--区间调度问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>