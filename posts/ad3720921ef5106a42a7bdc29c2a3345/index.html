<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>EasyExcel 初使用—— Java 实现读取 Excel 功能 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ad3720921ef5106a42a7bdc29c2a3345/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="EasyExcel 初使用—— Java 实现读取 Excel 功能">
  <meta property="og:description" content="前言 在我们项目的开发中啊，前端有时候会传送 Excel 文件给后端（Java）去解析，那我们作为后端该如何实现对 Excel 文件的解析和数据读取呢？说到这我就不得不推荐 EasyExcel 了！
EasyExcel 介绍 引用下官方对于 EasyExcel 介绍：EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。
官方网址：EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel
快速上手 EasyExcel 前置工作 先创建一个 Spring Boot 工程，并在 pom.xml 文件添加 EasyExcel 和 Lombok 依赖。
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; 知道表头 如果我们知道 Excel 数据的表头，即每列数据的类型包括有多少列时就可以用此方法读取 Excel 文件数据。
我们以下图数据为例，对改 Excel 中的数据进行获取和处理。
方法一： 首先我们创建一个名为 ExcelData 的 Java 对象，共有两个属性，分别是 date（日期列数据）和 useNum（用户列数据），每个属性对应 Excel 每列某一行中的数据。那么很显而易见，每一行的数据就是一个 ExcelData 对象，所有行的数据合起来就是一个泛型为 ExcelData 的 ExcelData 的集合。
@Data public class ExcelData implements Serializable { /** * 对应表格的日期列 */ private String date; /** * 对应表格的用户数列 */ private Integer userNum; } 随后编写一个测试类，并在其中编写测试方法。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T15:23:20+08:00">
    <meta property="article:modified_time" content="2024-07-26T15:23:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">EasyExcel 初使用—— Java 实现读取 Excel 功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>在我们项目的开发中啊，前端有时候会传送 Excel 文件给后端（Java）去解析，那我们作为后端该如何实现对 Excel 文件的解析和数据读取呢？说到这我就不得不推荐 EasyExcel 了！</p> 
<h3>EasyExcel 介绍</h3> 
<p>引用下官方对于 EasyExcel 介绍：EasyExcel是一个基于Java的、快速、简洁、解决大文件内存溢出的Excel处理工具。他能让你在不用考虑性能、内存的等因素的情况下，快速完成Excel的读、写等功能。</p> 
<p>官方网址：<a href="https://easyexcel.opensource.alibaba.com/" rel="nofollow" title="EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel">EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel</a></p> 
<h3>快速上手 EasyExcel</h3> 
<h4>前置工作</h4> 
<p>先创建一个 Spring Boot 工程，并在 pom.xml 文件添加 EasyExcel 和 Lombok 依赖。</p> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;
            &lt;version&gt;3.1.1&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<h4>知道表头</h4> 
<p>如果我们知道 Excel 数据的表头，即每列数据的类型包括有多少列时就可以用此方法读取 Excel 文件数据。</p> 
<p>我们以下图数据为例，对改 Excel 中的数据进行获取和处理。</p> 
<p><img alt="" height="566" src="https://images2.imgbox.com/44/be/QNXKuSiS_o.png" width="421"></p> 
<h5>方法一：</h5> 
<p>首先我们创建一个名为 ExcelData 的 Java 对象，共有两个属性，分别是 date（日期列数据）和 useNum（用户列数据），每个属性对应 Excel 每列某一行中的数据。那么很显而易见，每一行的数据就是一个 ExcelData 对象，所有行的数据合起来就是一个泛型为 ExcelData 的 ExcelData 的集合。</p> 
<pre><code class="language-java">@Data
public class ExcelData implements Serializable {
    /**
     * 对应表格的日期列
     */
    private String date;

    /**
     * 对应表格的用户数列
     */
    private Integer userNum;

}</code></pre> 
<p>随后编写一个测试类，并在其中编写测试方法。</p> 
<p>EasyExcel 的 read 方法有很多中构造方法，其中 Class head 就是表头类型，传入它还要传入 ReadListener 监听器，以便在去读取每行数据时做些自定义操作。我们直接传入它的实现类实例，因为 PageReadListener 支持逐页读取数据，通过读取指定行数的数据保证占用更少的内存。</p> 
<p><img alt="" height="288" src="https://images2.imgbox.com/35/cd/uMKChdM2_o.png" width="651"></p> 
<p>话不多说直接上代码：</p> 
<pre><code class="language-java">    /**
     * 知道表头，并形成映射关系
     */
    @Test
    public void doImportsForMapping() throws FileNotFoundException{
        // 读取 resource 目录下的 Excel 文件（网站数据.xlsx）
        File file = ResourceUtils.getFile("classpath:网站数据.xlsx");
        // 创建一个 list 存储每行的数据，即 ExcelData 对象
        List&lt;ExcelData&gt; list = new ArrayList&lt;&gt;();
        // 直接使用 EasyExcel 的 read 方法，同时定义表头的类型，以便将列中数据映射为 ExcelData 对象
        EasyExcel.read(file, ExcelData.class, new PageReadListener&lt;ExcelData&gt;(dataList -&gt; {
            // 并且每行数据，并将其 add 至 list 中
            for (ExcelData excelData : dataList) {
                if (excelData != null) {
                    list.add(excelData);
                }
            }
        })).excelType(ExcelTypeEnum.XLSX).sheet().doRead(); // 指定 Excel 的文件后缀，开始分析读取
        for (ExcelData excelData : list) {
            System.out.println(excelData.getDate() + "," + excelData.getUserNum());
        }
    }</code></pre> 
<p>执行结果：</p> 
<p> <img alt="" height="397" src="https://images2.imgbox.com/b5/e8/sKZeQGKE_o.png" width="538"></p> 
<h5>方法二：</h5> 
<blockquote> 
 <p>方法一是直接一次性读取 Excel 中的数据，缺少要读取的数据行数和一些自定义操作，所以我们在这里对上面的代码增强一下。</p> 
</blockquote> 
<p>在此方法中我们通过匿名内部类的方式实现 ReadListenser 接口，无需额外写一个类去实现 ReadListener了。我们设置了一个临时存储的列表（大小为 2），当每次读取的数据（执行 invoke 方法）添加到临时存储表中。当其长度超过 2 时进行全部删除，在删除前我们可以将临时存储的列表存到数据库中，或进行一些其他的自定义操作。</p> 
<p>doAfterAllAnalysed 方法是分析并获取所有的数据后会执行的一个方法，我们可以在其中打上日志，表示 Excel 所有数据已存入数据库中。</p> 
<pre><code class="language-java"> /**
     * 知道表头，并形成映射关系
     * @throws FileNotFoundException
     */
    @Test
    public void doImportsForMappingByInnerClass() throws FileNotFoundException{
        File file = ResourceUtils.getFile("classpath:网站数据.xlsx");
        EasyExcel.read(file, ExcelData.class, new ReadListener&lt;ExcelData&gt;() {

            // 单次缓存的数据量
            public static final int BATCH_COUNT = 2;

            // 临时存储的列表
            private List&lt;ExcelData&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
            @Override
            public void invoke(ExcelData excelData, AnalysisContext analysisContext) {
                cachedDataList.add(excelData);
                getData(excelData);
                if (cachedDataList.size() &gt;= BATCH_COUNT) {
                    cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
                }
            }

            @Override
            public void doAfterAllAnalysed(AnalysisContext analysisContext) {
                System.out.println("存储数据库成功");
            }

            private void getData(ExcelData excelData) {
                System.out.println(excelData.getDate() + "," + excelData.getUserNum());
            }
        }).excelType(ExcelTypeEnum.XLSX).sheet().doRead();

    }</code></pre> 
<p>执行结果：</p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/29/16/6GK7aewi_o.png" width="671"></p> 
<h4>不知道表头</h4> 
<h5 style="background-color:transparent;">方法三：</h5> 
<p>上面的两种方法都是我们知道表头，包括列的类型和列数量的情况下对 Excel 文件进行数据获取的。那我们不知道表头信息，又该如何操作呢？</p> 
<p>我们依赖利用 EasyExcel 的 read 方法，和前面的步骤大差不差，只不过这次参数少了，如果你还要获取表头即表格的第一行数据，还可通过 headRowNumber 方法指定首行编号为 0。</p> 
<p>此时返回的是一个 List&lt;Map&lt;Integer, String&gt;&gt; 集合，其中 Map 的 键对应表格的列编号（从 0 开始），值就是对应某一行某一列的值，List 的索引代表某一行的数据。调用 Map 对象的 values() 方法即可直接获取某一行数据的集合，List&lt;Map&lt;Integer, String&gt;&gt; 就是所有行数据的集合。我们这说可能不太直观，我把它打印出来给你们看就很简单明了了。</p> 
<pre><code class="language-java">[{0=日期, 1=用户数}, {0=1号, 1=10}, {0=2号, 1=20}, {0=3号, 1=30}, {0=4号, 1=70}, {0=5号, 1=20}, {0=6号, 1=29}, {0=7号, 1=24}, {0=8号, 1=31}, {0=9号, 1=40}, {0=10号, 1=38}, {0=11号, 1=43}]</code></pre> 
<p>代码如下：</p> 
<pre><code class="language-java">    @Test
    public void doImport() throws FileNotFoundException {
        List&lt;Map&lt;Integer, String&gt;&gt; list = null;
        File file = ResourceUtils.getFile("classpath:网站数据.xlsx");
        try {
            list = EasyExcel.read(file)
                    .excelType(ExcelTypeEnum.XLSX)
                    .sheet()
                    .headRowNumber(0)
                    .doReadSync();
        } catch (Exception e) {
            throw new RuntimeException("读取 Excel 文件失败");
        }
        StringBuilder stringBuilder = new StringBuilder();
        for (int i=0;i&lt;list.size();i++) {
            // 转为 LinkedHashMap 主要是为了保证读取的数据和表格顺序一致
            LinkedHashMap&lt;Integer, String&gt; linkedHashMap = (LinkedHashMap) list.get(i);
            List&lt;String&gt; dataList = linkedHashMap.values().stream()
                    .filter(ObjectUtils::isNotEmpty).collect(Collectors.toList());
            stringBuilder.append(StringUtils.join(dataList, ",")).append("\n");
        }
        System.out.println(stringBuilder.toString());
    }</code></pre> 
<p>执行结果：</p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/b0/ab/7DJMBgzQ_o.png" width="272"></p> 
<h3 style="background-color:transparent;">EasyExcel 写入 Excel</h3> 
<p>不知道 EasyExcel 如何写入 Excel 的小伙伴可以看看我写的这篇文章——<a href="https://blog.csdn.net/xyendjsj/article/details/140708831?spm=1001.2014.3001.5501" title="EasyExcel 初使用—— Java 实现多种写入 Excel 功能-CSDN博客">EasyExcel 初使用—— Java 实现多种写入 Excel 功能-CSDN博客</a>，看完后保准你有大收获。</p> 
<h3 style="background-color:transparent;">总结</h3> 
<p>如果知道表头并且数据量较小，就用方法一，如果数据量较大或者想添加一些自定操作就用方法二。如果不知道表头并且想要读取表头的信息就用方法三。</p> 
<h3>往期推荐</h3> 
<p><a href="https://blog.csdn.net/xyendjsj/article/details/131774615?spm=1001.2014.3001.5501" title="基于mysql+jdbc+java swing的学生成绩信息管理系统_用java和数据库做一个管理系统-CSDN博客">基于mysql+jdbc+java swing的学生成绩信息管理系统_用java和数据库做一个管理系统-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/xyendjsj/article/details/135921460?spm=1001.2014.3001.5501" title="宝塔部署 Vue + Spring Boot + MySQL + Redis 项目保姆级教程_宝塔添加springboot项目-CSDN博客">宝塔部署 Vue + Spring Boot + MySQL + Redis 项目保姆级教程_宝塔添加springboot项目-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/xyendjsj/article/details/136491990?spm=1001.2014.3001.5501" title="一篇文章带你快速上手 Redis GEO 并实现搜索附近用户-CSDN博客">一篇文章带你快速上手 Redis GEO 并实现搜索附近用户-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/xyendjsj/article/details/136198880?spm=1001.2014.3001.5501" title="四种限流算法详细介绍及Java代码实现-CSDN博客">四种限流算法详细介绍及Java代码实现-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/xyendjsj/article/details/136028873?spm=1001.2014.3001.5501" title="RabbitMQ——死信队列介绍和项目应用_mq死信队列消息需要处理么-CSDN博客">RabbitMQ——死信队列介绍和项目应用_mq死信队列消息需要处理么-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/xyendjsj/article/details/134820039?spm=1001.2014.3001.5501" title="Java课程设计之图书管理系统_设计一个图书管理系统-CSDN博客">Java课程设计之图书管理系统_设计一个图书管理系统-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e815b0ec94a7d0834a9f7d029044030/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用Vue3构建一个图像画廊，支持图片上传</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a39a13721fdd8788d40cbdd318e9500/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Go-Zero 数据库实战：配置、建模与业务逻辑一体化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>