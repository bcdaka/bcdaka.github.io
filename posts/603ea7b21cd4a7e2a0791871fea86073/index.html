<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>嵌入式数据库SQLite 3配置使用详细笔记教程 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/603ea7b21cd4a7e2a0791871fea86073/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="嵌入式数据库SQLite 3配置使用详细笔记教程">
  <meta property="og:description" content="0、惨痛教训 随着管理开发的项目体积越来越庞大，产品系统涉及的数据量也越来越多，并且伴随着项目不久就要交付给甲方了。如果项目的数据信息没有被妥善管理，后期设备的运行状态、操作状况等数据流信息不能被溯源，当出现了一些特殊意外时，就会导致对于故障信息不能迅速准确的追踪，甚至会被甩锅、推卸责任，白白当了冤大头。因此对于嵌入式项目中，其产品运行时的数据库建立非常有必要，且是迫在眉睫！！！
目前常用的数据库系统有：MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server、SQLite等。在嵌入式项目中，前面几个数据库显然是不合适的，而SQLite是一个轻量级的数据库管理系统，它包含在一个C库中，提供了零配置、无服务器、事务性的SQL数据库引擎。所以SQLite的特点使其非常适合嵌入式系统、移动设备、小型项目或者作为应用程序的本地数据库使用。本文选用了嵌入式数据库SQLite3进行配置和讲解。
1、Sqlite3环境配置 （1）、下载安装SQLite库 根据目标系统平台，下载sqlite源码，或下载官方提供的已经编译好的库。本文目标平台是Windows11 64位平台，进入SQLite Download Page的主页，选择需要的库版本（Windows）。
下载的压缩包一共有如下所示的三个：
sqlite-dll-win-x64-3450300.zip
sqlite-dll-win-x86-3450300.zip
sqlite-tools-win-x64-3450300.zip
（2）、解压下载的文件 本文中将对应的Sqlite库文件解压到了，C:\Program Files\sqlite路径下。
（3）、添加库路径到环境变量 根据下图所示的步骤，进入系统属性--&gt;环境变量--&gt;系统变量--&gt;编辑环境变量，将路径加入到环境变量中。
（4）、检查数据库安装状态 打开Windows的命令行，输入sqlite3，有类似如下的数据信息说明库安装成功，后续只需在程序代码中，将库加入到工程代码中即可。
（5）、SQLiteStudio工具 如果有可视化分析数据需求、推荐使用下载：SQLiteStudiohttps://sqlitestudio.pl/
2、SQLite3基础 SQL（Structured Query Language）是一种结构化查询语言，SQL 是一种专门用来与数据库通信的语言。
不同的数据库管理系统在其实践过程中都对 SOL 规范作了某些改编和扩充。故不同数据库管理系统之间的 SOL语言不能完全相互通用。
以下是SQLite的一些关键特点：
零配置: SQLite不需要安装或者管理服务器进程。启动一个使用SQLite的应用程序时，数据库文件会自动创建（如果尚不存在），并且直接通过程序访问。轻量级: SQLite的代码量小，资源消耗少，对硬件要求很低。这使得它非常适合资源有限的环境，如手机、平板电脑或微型设备。跨平台: SQLite兼容几乎所有主流的操作系统，包括Windows、Linux、Unix、Android、iOS等。服务器less: 由于SQLite是嵌入式的，没有单独运行的数据库服务器进程，数据直接存储在文件中。这简化了部署和维护过程。事务处理: SQLite支持ACID（原子性、一致性、隔离性、持久性）事务，确保数据的完整性。SQL标准兼容: 虽然SQLite有自己的SQL方言，但它大体上遵循ANSI SQL标准，支持大多数标准SQL语句。单一文件存储: SQLite数据库完全存储在一个磁盘文件中，这使得备份和迁移数据库变得非常简单，只需复制该文件即可。动态类型: SQLite具有弱类型特性，允许更灵活的数据存储，但也可能需要开发者更加注意数据类型的处理。广泛使用: SQLite被许多应用程序和操作系统采用，包括浏览器（如Firefox）、操作系统组件、手机应用等，是世界上最广泛部署的数据库引擎之一。 有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。一般数据采用固定的静态数据类型，而 SOLite 采用的是动态数据类型，会根据存入值自动判断。
SQLite 存储类：SOLite 具有以下五种基本数据类型
（1）integer：带符号的整型(最多64位)。
（2）real：8字节表示的浮点类型。
（3）text：字符类型，支持多种编码(如 UTF-8、UTF-16)，大小无限制。
（4）blob：任意类型的数据，大小无限制。 BLOB(binary large obiect)二进制大对象，使用二进制保存数据。
（5）null：表示空值
SQLite 亲和类型(Affinity)及类型名称">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-08T19:16:04+08:00">
    <meta property="article:modified_time" content="2024-05-08T19:16:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">嵌入式数据库SQLite 3配置使用详细笔记教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>0、惨痛教训</h3> 
<p>        随着管理开发的项目体积越来越庞大，产品系统涉及的数据量也越来越多，并且伴随着项目不久就要交付给甲方了。如果项目的数据信息没有被妥善管理，后期设备的运行状态、操作状况等数据流信息不能被溯源，当出现了一些特殊意外时，就会导致对于故障信息不能迅速准确的追踪，甚至会被甩锅、推卸责任，白白当了冤大头。因此对于嵌入式项目中，其产品运行时的数据库建立非常有必要，且是迫在眉睫！！！</p> 
<p>        目前常用的数据库系统有：MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server、SQLite等。在嵌入式项目中，前面几个数据库显然是不合适的，而<strong><span style="color:#fe2c24;">SQLite</span></strong>是一个轻量级的数据库管理系统，它包含在一个C库中，提供了零配置、无服务器、事务性的SQL数据库引擎。所以SQLite的特点使其非常适合嵌入式系统、移动设备、小型项目或者作为应用程序的本地数据库使用。本文选用了嵌入式数据库SQLite3进行配置和讲解。</p> 
<h3>1、Sqlite3环境配置</h3> 
<h4>（1）、下载安装SQLite库</h4> 
<p>根据目标系统平台，下载sqlite源码，或下载官方提供的已经编译好的库。本文目标平台是Windows11 64位平台，进入<a href="https://www.sqlite.org/download.html" rel="nofollow" title="SQLite Download Page">SQLite Download Page</a>的主页，选择需要的库版本（Windows）。</p> 
<p><img alt="" height="919" src="https://images2.imgbox.com/1f/72/5QlwTpOv_o.png" width="1200"></p> 
<p>下载的压缩包一共有如下所示的三个：</p> 
<p>sqlite-dll-win-x64-3450300.zip</p> 
<p>sqlite-dll-win-x86-3450300.zip</p> 
<p>sqlite-tools-win-x64-3450300.zip</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/8e/b3/KPzJEstP_o.png" width="647"></p> 
<h4>（2）、解压下载的文件</h4> 
<p>        本文中将对应的Sqlite库文件解压到了，<span style="color:#fe2c24;">C:\Program Files\sqlite</span>路径下。</p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/8c/78/H3DnLQex_o.png" width="686"></p> 
<h4 style="background-color:transparent;">（3）、添加库路径到环境变量</h4> 
<p>        根据下图所示的步骤，进入系统属性--&gt;环境变量--&gt;系统变量--&gt;编辑环境变量，将路径加入到环境变量中。</p> 
<p><img alt="" height="797" src="https://images2.imgbox.com/9a/cc/5bZPwzjP_o.png" width="1200"></p> 
<h4>（4）、检查数据库安装状态</h4> 
<p>        打开Windows的命令行，输入sqlite3，有类似如下的数据信息说明库安装成功，后续只需在程序代码中，将库加入到工程代码中即可。</p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/b5/54/c3Up8x4G_o.png" width="653"></p> 
<h4>（5）、SQLiteStudio工具</h4> 
<p>        如果有可视化分析数据需求、推荐使用下载：<a class="has-card" href="https://sqlitestudio.pl/" rel="nofollow" title="SQLiteStudio"><span class="link-card-box"><span class="link-title">SQLiteStudio</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/7c/69/EodP4OXk_o.png" alt="icon-default.png?t=N7T8">https://sqlitestudio.pl/</span></span></a><img alt="" height="715" src="https://images2.imgbox.com/a4/a5/bRE7JSd0_o.png" width="1146"></p> 
<h3>2、SQLite3基础</h3> 
<p>        SQL（Structured Query Language）是一种结构化查询语言，SQL 是一种专门用来与数据库通信的语言。</p> 
<p>        不同的数据库管理系统在其实践过程中都对 SOL 规范作了某些改编和扩充。故不同数据库管理系统之间的 SOL语言不能完全相互通用。</p> 
<p>        <strong>以下是SQLite的一些关键特点：</strong></p> 
<ul><li><span style="color:#494949;"><strong>零配置:</strong> SQLite不需要安装或者管理服务器进程。启动一个使用SQLite的应用程序时，数据库文件会自动创建（如果尚不存在），并且直接通过程序访问。</span></li><li><span style="color:#494949;"><strong>轻量级: </strong>SQLite的代码量小，资源消耗少，对硬件要求很低。这使得它非常适合资源有限的环境，如手机、平板电脑或微型设备。</span></li><li><span style="color:#494949;"><strong>跨平台: </strong>SQLite兼容几乎所有主流的操作系统，包括Windows、Linux、Unix、Android、iOS等。</span></li><li><span style="color:#494949;"><strong>服务器less: </strong>由于SQLite是嵌入式的，没有单独运行的数据库服务器进程，数据直接存储在文件中。这简化了部署和维护过程。</span></li><li><span style="color:#494949;"><strong>事务处理: </strong>SQLite支持ACID（原子性、一致性、隔离性、持久性）事务，确保数据的完整性。</span></li><li><span style="color:#494949;"><strong>SQL标准兼容: </strong>虽然SQLite有自己的SQL方言，但它大体上遵循ANSI SQL标准，支持大多数标准SQL语句。</span></li><li><span style="color:#494949;"><strong>单一文件存储: </strong>SQLite数据库完全存储在一个磁盘文件中，这使得备份和迁移数据库变得非常简单，只需复制该文件即可。</span></li><li><span style="color:#494949;"><strong>动态类型: </strong>SQLite具有弱类型特性，允许更灵活的数据存储，但也可能需要开发者更加注意数据类型的处理。</span></li><li><span style="color:#494949;"><strong>广泛使用: </strong>SQLite被许多应用程序和操作系统采用，包括浏览器（如Firefox）、操作系统组件、手机应用等，是世界上最广泛部署的数据库引擎之一。</span></li></ul> 
<p>        有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。一般数据采用固定的静态数据类型，而 SOLite 采用的是动态数据类型，会根据存入值自动判断。</p> 
<p>SQLite 存储类：SOLite 具有以下五种基本数据类型</p> 
<p>（1）<span style="color:#fe2c24;"><strong>integer</strong></span>：带符号的整型(最多64位)。</p> 
<p>（2）<span style="color:#fe2c24;"><strong>real</strong></span>：8字节表示的浮点类型。</p> 
<p>（3）<span style="color:#fe2c24;"><strong>text</strong></span>：字符类型，支持多种编码(如 UTF-8、UTF-16)，大小无限制。</p> 
<p>（4）<span style="color:#fe2c24;"><strong>blob</strong></span>：任意类型的数据，大小无限制。 BLOB(binary large obiect)二进制大对象，使用二进制保存数据。</p> 
<p>（5）<span style="color:#fe2c24;"><strong>null</strong></span>：表示空值</p> 
<p>SQLite 亲和类型(Affinity)及类型名称</p> 
<p>下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的<span style="color:#fe2c24;"><strong>亲和类型</strong></span>：</p> 
<table><tbody><tr><td> <p>数据类型</p> </td><td> <p>亲和类型</p> </td></tr><tr><td> 
    <ul><li>INT</li><li>INTEGER</li><li>TINYINT</li><li>SMALLINT</li><li>MEDIUMINT</li><li>BIGINT</li><li>UNSIGNED BIG INT</li><li>INT2</li><li>INT8</li></ul></td><td> <p>INTEGER</p> </td></tr><tr><td> 
    <ul><li>CHARACTER(20)</li><li>VARCHAR(255)</li><li>VARYING CHARACTER(255)</li><li>NCHAR(55)</li><li>NATIVE CHARACTER(70)</li><li>NVARCHAR(100)</li><li>TEXT</li><li>CLOB</li></ul></td><td> <p>TEXT</p> </td></tr><tr><td> 
    <ul><li>BLOB</li><li>未指定类型</li></ul></td><td> <p>BLOB</p> </td></tr><tr><td> 
    <ul><li>REAL</li><li>DOUBLE</li><li>DOUBLE PRECISION</li><li>FLOAT</li></ul></td><td> <p>REAL</p> </td></tr><tr><td> 
    <ul><li>NUMERIC</li><li>DECIMAL(10,5)</li><li>BOOLEAN</li><li>DATE</li><li>DATETIME</li></ul></td><td> <p>NUMERIC</p> </td></tr></tbody></table> 
<p>SQLite 语句：所有的 SQLite 语句可以以任何关键字开始，如 <strong><span style="color:#fe2c24;">SELECT、INSERT、UPDATE、DELETE、ALTER、DROP </span></strong>等，所有的语句以分号 ; 结束。</p> 
<h3>3、SQLite3基本语法</h3> 
<h4>（1）、创建数据库</h4> 
<pre><code class="language-cpp">//打开数据库,如不存在则会创建数据库
int ret = sqlite3_open("project_data.db", &amp;db);
if( ret )
{
    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
    exit(-1);
}
fprintf(stderr, "Opened database successfully\n");</code></pre> 
<h4>（2）、创建表</h4> 
<pre><code class="language-cpp">//CREATE TABLE 告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。
CREATE TABLE database_name.table_name(
   column1 datatype  PRIMARY KEY(one or more columns),
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
);

char table_name[200] = {0};
char *err_msg = NULL;
snprintf(table_name, sizeof(table_name), "create table if not exists camera(time_stamp integer primary key, action text, x integer, y integer, z integer, vx integer, vy integer, vz integer, time integer);");
int ret = sqlite3_exec(db, table_name, NULL, NULL, &amp;err_msg);
if(ret){
    fprintf(stderr, "create table err:%s\n", err_msg);
    return -1;
}
fprintf(stderr, "create table successfully\n");</code></pre> 
<h4>（3）、删除表</h4> 
<pre><code class="language-cpp">//SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。
//DROP TABLE 语句的基本语法如下。
DROP TABLE database_name.table_name;

char table_name[200] = {0};
char *err_msg = NULL;
snprintf(table_name, sizeof(table_name), "DROP TABLE database_name.table_name;");
int ret = sqlite3_exec(db, table_name, NULL, NULL, &amp;err_msg);
if(ret){
    fprintf(stderr, "delete table err:%s\n", err_msg);
    return -1;
}
fprintf(stderr, "delete table successfully\n");</code></pre> 
<h4>（4）、插入数据</h4> 
<pre><code class="language-cpp">INSERT INTO 语句有两种基本语法，如下所示：
INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  VALUES (value1, value2, value3,...valueN);//在这里，column1, column2,...columnN 是要插入数据的表中的列的名称
或
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);
//确保值的顺序与列在表中的顺序一致。

char table_value[200] = {0};
int ret = 0;
char *err_msg = NULL;
snprintf(table_value, sizeof(table_value),"insert into camera values(%lld, '%c', %d, %d, %d, %d, %d, %d, %d);", get_current_timestamp_ms(), action, x, y, z, vx, vy, vz, time);
ret = sqlite3_exec(db, table_value, NULL, NULL, &amp;err_msg);
if(ret)
{
    fprintf(stderr, "insert value to table err:%s\n", err_msg);
    return -1;
}
fprintf(stderr, "insert value to table successfully\n");</code></pre> 
<h4>（5）、查询数据</h4> 
<pre><code class="language-cpp">//SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。
//SQLite 的 SELECT 语句的基本语法如下：
SELECT column1, column2, columnN FROM table_name;//在这里，column1, column2...是表的字段，他们的值即是您要获取的。
SELECT * FROM table_name;    //获取所有可用的字段

char *err_msg = NULL;
sprintf(sql, "select * from table_value;");
ret = sqlite3_exec(db, sql, NULL, NULL, &amp;err_msg);   //执行 SQL 命令的快捷方式
if(ret)
{
    fprintf(stderr, "Can't select sqlite value: %s\n", sqlite3_errmsg(db));
    return -1;
}</code></pre> 
<h4>（6）、删除数据</h4> 
<pre><code class="language-cpp">//SQLite 的 DELETE 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。
//带有 WHERE 子句的 DELETE 查询的基本语法如下：
DELETE FROM table_name
WHERE [condition];
//可以使用 AND 或 OR 运算符来结合 N 个数量的条件。

char *err_msg = NULL;
sprintf(sql, "DELETE FROM camera WHERE time_stamp = 123456789;");
ret = sqlite3_exec(db, sql, NULL, NULL, &amp;err_msg);   //执行 SQL 命令的快捷方式
if(ret)
{
    fprintf(stderr, "Can't DELETE sqlite data: %s\n", sqlite3_errmsg(db));
    return -1;
}</code></pre> 
<h4>（7）、修改数据</h4> 
<pre><code class="language-cpp">//SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。
//带有 WHERE 子句的 UPDATE 查询的基本语法如下：
UPDATE table_name
SET column1 = value1, column2 = value2...., columnN = valueN
WHERE [condition];

char *err_msg = NULL;
sprintf(sql, "UPDATE camera SET action = 't' WHERE time_stamp = 123456789;");
ret = sqlite3_exec(db, sql, NULL, NULL, &amp;err_msg);   //执行 SQL 命令的快捷方式
if(ret)
{
    fprintf(stderr, "Can't DELETE sqlite data: %s\n", sqlite3_errmsg(db));
    return -1;
}</code></pre> 
<h3>4、SQLite3代码</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;sqlite3.h&gt;

int database_init();
int write_motor_info_to_database(sqlite3 *db, int motor_id, double target_pos, double real_pos, double real_speed, double real_current);
int write_camera_info_to_database(sqlite3 *db, char action, int x, int y, int z, int vx, int vy, int vz, int time);
long long get_current_timestamp_ms(void); 

int main(void)
{
    printf("sqlite3 database test!\n");    
    database_init();
    return 0;
}

/**
  * @brief  数据库初始化
  * @param  NONE
  * @retval 成功返回0， 失败返回-1
  */
int database_init(void)  
{
    int ret = -1;
    sqlite3 *db;
    char *err_msg = NULL;
    char database_name[128] = {0};
    //获取当前时间
    struct tm t; 
    time_t now;

    time(&amp;now);
    localtime_s(&amp;t, &amp;now);
    snprintf(database_name, sizeof(database_name),"%02d%02d%02d.db", t.tm_year + 1900, t.tm_mon + 1, t.tm_mday);
    printf("date:%s\n", database_name);

   //打开数据库
    ret = sqlite3_open(database_name, &amp;db);
    if( ret )
    {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        return -1;
    }
    fprintf(stderr, "Opened database successfully\n");

    char table_name[200] = {0};
    //时间戳 目标位置 实际位置 实际速度 实际电流
    //create table if not exists motor0 (time_stamp integer primary key, target_pos real, real_pos real, real_speed real, real_current, real);
    for(int motor_id = 0; motor_id &lt; 6; motor_id++)
    {
        snprintf(table_name, sizeof(table_name),"create table if not exists motor%d (time_stamp integer primary key, target_pos real, real_pos real, real_speed real, real_current real);", motor_id);
        ret = sqlite3_exec(db, table_name, NULL, NULL, &amp;err_msg);
        if(ret)
        {
            fprintf(stderr, "create table err:%s\n", err_msg);
            return -1;
        }
        fprintf(stderr, "create table successfully\n");
    }
    memset(table_name, 0, sizeof(table_name));
    snprintf(table_name, sizeof(table_name), "create table if not exists camera(time_stamp integer primary key, action text, x integer, y integer, z integer, vx integer, vy integer, vz integer, time integer);");
    ret = sqlite3_exec(db, table_name, NULL, NULL, &amp;err_msg);
    if(ret)
    {
        fprintf(stderr, "create table err:%s\n", err_msg);
        return -1;
    }
    fprintf(stderr, "create table successfully\n");

    write_motor_info_to_database(db, 0, 90.0, 87.2, 5.0, 0.85);
    write_motor_info_to_database(db, 1, 90.0, 87.2, 5.0, 0.85);
    write_motor_info_to_database(db, 2, 90.0, 87.2, 5.0, 0.85);
    write_motor_info_to_database(db, 3, 90.0, 87.2, 5.0, 0.85);
    write_motor_info_to_database(db, 4, 90.0, 87.2, 5.0, 0.85);
    write_motor_info_to_database(db, 5, 90.0, 87.2, 5.0, 0.85);
    write_camera_info_to_database(db, 't', 100,200,150,160,130,110,1000);
    
    return 0;
}

/**
  * @brief  写入电机数据到数据库中
  * @param  db：数据库文件描述符
  * @param  target_pos：目标位置
  * @param  real_pos：实际位置
  * @param  real_speed：实际速度
  * @param  real_current：实际电流
  * @retval 写入成功返回0，失败-1
  */
int write_motor_info_to_database(sqlite3 *db, int motor_id, double target_pos, double real_pos, double real_speed, double real_current)
{
    char table_value[200] = {0};
    int ret = 0;
    char *err_msg = NULL;
    //insert into motor0 values(1798345, 90.0, 88.66, 45.1, 0.97);
    snprintf(table_value, sizeof(table_value),"insert into motor%d values(%lld, %.2f, %.2f, %.2f, %.2f);", motor_id, get_current_timestamp_ms(), target_pos, real_pos, real_speed, real_current);
    ret = sqlite3_exec(db, table_value, NULL, NULL, &amp;err_msg);
    if(ret)
    {
        fprintf(stderr, "insert value to table err:%s\n", err_msg);
        return -1;
    }
    fprintf(stderr, "insert value to table successfully\n");

    return 0;
}

/**
  * @brief  写入相机数据到数据库中
  * @param  db：数据库文件描述符
  * @param  action:动作
  * @param  x：
  * @param  y：
  * @param  z:
  * @param  vx：
  * @param  vy：
  * @param  vz:
  * @retval 写入成功返回0，失败-1
  */
int write_camera_info_to_database(sqlite3 *db, char action, int x, int y, int z, int vx, int vy, int vz, int time)
{
    char table_value[200] = {0};
    int ret = 0;
    char *err_msg = NULL;
    //insert into motor0 values(1798345, 90.0, 88.66, 45.1, 0.97);
    snprintf(table_value, sizeof(table_value),"insert into camera values(%lld, '%c', %d, %d, %d, %d, %d, %d, %d);", get_current_timestamp_ms(), action, x, y, z, vx, vy, vz, time);
    ret = sqlite3_exec(db, table_value, NULL, NULL, &amp;err_msg);
    if(ret)
    {
        fprintf(stderr, "insert value to table err:%s\n", err_msg);
        return -1;
    }
    fprintf(stderr, "insert value to table successfully\n");

    return 0;
}

/**
  * @brief  获取毫秒级时间戳
  * @param  NONE
  * @retval 成功返回时间戳值，失败返回-1
  */
long long get_current_timestamp_ms(void)
{
#if defined(_WIN32) || defined(_WIN64)
    struct _timeb timebuffer;
    _ftime64_s(&amp;timebuffer);
    return (long long)timebuffer.time * 1000 + timebuffer.millitm;
#elif defined(__unix__) || defined(__unix) || defined(unix)
    struct timeval tv;
    gettimeofday(&amp;tv, NULL);
    return (long long)tv.tv_sec * 1000 + tv.tv_usec / 1000;
#endif
}
</code></pre> 
<p>参考代码运行结果</p> 
<p><img alt="" height="652" src="https://images2.imgbox.com/20/09/VRl8g5cj_o.png" width="667"></p> 
<p>使用可视化工具<span style="color:#fe2c24;">SQLiteStudio</span>，对SQLite3数据库进行查看。</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/46/8e/V2lpKem3_o.png" width="803"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8afa8cad9cbaf3c2334b2aae7d98a638/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中合并列表(list)的六种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6bf38a3145745b5e6f675e0c4eefb458/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构——顺序表专题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>